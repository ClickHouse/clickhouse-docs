---
title: Почему бы не использовать что‑то вроде MapReduce?
description: "Мы можем отнести такие системы, как MapReduce, к распределённым вычислительным системам, в которых операция reduce основана на распределённой сортировке. Наиболее распространённым решением с открытым исходным кодом в этом классе является Apache Hadoop."
date: 2021-09-01
tags: ['Concepts']
keywords: ['MapReduce']
---

{frontMatter.description}

{/* обрезка */}

## Почему не использовать что‑то вроде MapReduce? \{#why-not-use-something-like-mapreduce\}

Мы можем отнести системы вроде MapReduce к распределённым вычислительным системам, в которых операция reduce основана на распределённой сортировке. Наиболее распространённое open-source‑решение в этом классе — [Apache Hadoop](http://hadoop.apache.org).

Такие системы не подходят для онлайн‑запросов из‑за высокой задержки. Иными словами, их нельзя использовать в качестве back‑end&#39;а для веб-интерфейса. Эти типы систем также мало полезны для обновления данных в реальном времени. Распределённая сортировка — не лучший способ выполнять операции reduce, если результат операции и все промежуточные результаты (если они есть) находятся в оперативной памяти (RAM) одного сервера, что обычно и имеет место для онлайн‑запросов. В таком случае хеш-таблица является оптимальным способом выполнения операций reduce. Распространённый подход к оптимизации MapReduce‑задач — предагрегация (частичный reduce) с использованием хеш-таблицы в RAM. Пользователь выполняет эту оптимизацию вручную. Распределённая сортировка — одна из основных причин снижения производительности при запуске простых MapReduce‑задач.

Большинство реализаций MapReduce позволяют выполнять произвольный код на кластере. Но декларативный язык запросов лучше подходит для OLAP, если нужно быстро проводить эксперименты. Например, в Hadoop есть Hive и Pig. Также можно рассмотреть Cloudera Impala или Shark (устаревший) для Spark, а также Spark SQL, Presto и Apache Drill. Производительность при запуске таких задач значительно уступает специализированным системам, а относительно высокая задержка делает использование этих систем в качестве back‑end&#39;а для веб-интерфейса нереалистичным.
---
title: Советы и рекомендации по оптимизации базовых типов данных в ClickHouse
description: "Советы и рекомендации по оптимизации базовых типов данных в ClickHouse"
date: 2024-07-02
tags: ['Производительность и оптимизация']
keywords: ['Оптимизация базовых типов данных']
---

{frontMatter.description}

{/* обрезать */}

## Вопрос \{#question\}

Какие типы данных следует использовать в ClickHouse, чтобы оптимизировать запросы по быстродействию и экономии места на диске?

## Ответ \{#answer\}

Во многих случаях при автоматическом преобразовании данных из другой системы или при выборе типа данных пользователи склонны придерживаться подхода «чем больше, тем лучше», «выбрать то, что проще» или «выбрать наиболее общий вариант». Это, скорее всего, будет работать для относительно небольших наборов данных — с миллионами, возможно, даже миллиардами строк. Разница может быть незаметной и приемлемой для таких наборов, где различия в запросах пользователей для их сценариев использования невелики.

Однако по мере роста объема данных это перестанет быть приемлемым и станет гораздо более заметным.

Разница между запросом, выполняющимся за 50 мс и 500 мс, может быть приемлемой для большинства сценариев, например, в веб-интерфейсе, но второй вариант в 10 раз медленнее первого, даже если для пользователя фронтенда это не слишком заметно.

Пример исходной таблицы:

```
timestamp Datetime64(9),
group_id Int64,
vendor_id String,
product_id String,
category1 Int64,
code_name String,
paid_status String,
country_code String,
description String,
price Float64,
attributes Map(String, String)
```

Пример данных:

```
3456, 0123456789, bd6087b7-6026-4974-9122-bc99faae5d84, "2024-03-01 01:00:01.000", 98, "bear", paid", "us", "модель автомобиля corvette", 123.45, {"color" : "blue", "size" : "S"}
156, 0000012345, bd6087b7-6026-4974-9122-bc99faae5d84, "2024-03-01 01:00:02:123", 45, "tiger", "not paid", "uk", "электромобиль", 53432.10, {"color" : "red", "model" : "X"} 
...
```

Ниже приведены некоторые рекомендации по оптимизации этих данных:

`timestamp : DateTime64(9)`\
Если не требуется научная точность, точность 9 знаков (наносекунды), скорее всего, избыточна. Возможно, она нужна для отображения или упорядочивания, но обычно не используется в запросах для поиска, первичных ключей и т.п.

* **Рекомендация:**\
  Для PK, ORDER BY: DateTime\
  Для отображения или упорядочивания: добавить дополнительный столбец — например, `timestamp_microseconds : DateTime64(6)`

`group_id : Int64`\
Похоже, это целое число; выберите наименьший тип целого, который покроет максимально возможное значение для этого столбца. По этому образцу набора данных и названию столбца маловероятно, что понадобится квинтиллион значений — вероятно, подойдёт Int16, где возможно до 16 тыс. значений.

* **Рекомендация**: Int16

`vendor_id : String`\
Этот столбец выглядит как число, но с ведущими нулями — формат, скорее всего, важно сохранить. Также похоже, что количество символов ограничено.

* **Рекомендация**: FixedString(10)

`product_id : String`\
Это значение буквенно-цифровое, поэтому интуитивно кажется строкой, однако оно также является UUID.

* **Рекомендация**: UUID

`category1 : Int64`\
Значения небольшие, вероятно, категорий немного и их количество сильно расти не будет или ограничено. Меньше 255.

* **Рекомендация**: UInt8

`code_name : String`\
Похоже, что в этом поле используется только ограниченное количество строковых значений.
В такой ситуации, когда возможное число строковых значений исчисляется сотнями или тысячами, полезно использовать поля с низкой кардинальностью.

* **Рекомендация**: LowCardinality(String)

`paid_status : String`\
Строковое значение равно «paid» или «not&#95;paid». В ситуациях, когда возможно только два значения, лучше использовать логический тип.

* **Рекомендация**: Bool

`country_code : String`\
Иногда встречаются столбцы, к которым можно применить несколько видов оптимизации. В этом примере есть только ограниченное количество кодов стран, и все они — двухсимвольные идентификаторы.

* **Рекомендация**: LowCardinality(FixedString(2))

`price : Float64`\
Типы с плавающей точкой не рекомендуются, когда известна фиксированная точность, особенно для финансовых данных и вычислений. Наилучшим выбором будут типы Decimal с требуемой точностью. Для этого сценария, вероятно, цена товара не превышает 999,999.00

* **Рекомендация**: Decimal(10,2)

`attributes : map`\
Часто в таблице может быть столбец с динамическими атрибутами в `Map`. Поиск по ключам или значениям обычно медленный. Есть несколько способов сделать работу с `Map` быстрее. Если есть ключи, которые будут присутствовать в большинстве записей, лучше вынести их в отдельный столбец с низкой кардинальностью, а те, которые будут встречаться редко, — в другой столбец с высокой кардинальностью. После этого будет эффективнее создавать skip-индексы, хотя это может повысить сложность запросов.

* **Рекомендация:** lc&#95;attributes: Map(String, String), hc&#95;attributes: Map(String, String).

В зависимости от запросов можно также использовать следующие варианты для создания skip-индекса и/или извлечения атрибутов:\
использование Array Join для извлечения в столбцы с помощью материализованного представления:
https://clickhouse.com/docs/knowledgebase/using-array-join-to-extract-and-query-attributes\
использование skip-индекса для ключей:
https://clickhouse.com/docs/knowledgebase/improve-map-performance
---
title: Давайте вычислим число π с помощью SQL
description: Сегодня День числа π! Давайте вычислим число π с помощью SQL в ClickHouse
date: 2023-03-14
tags: ['Сценарии использования']
keywords: ['Вычисление числа π', 'SQL']
---

{frontMatter.description}

{/* обрезать */}

## Сегодня День числа Пи! Вычислим π с помощью SQL \{#its-pi-day-lets-calculate-pi-using-sql\}

С Днём числа Пи! Мы подумали, что было бы интересно вычислить число пи с помощью SQL-запросов в ClickHouse. Вот что у нас получилось на данный момент...

1. Здесь используется табличная функция ClickHouse `numbers_mt` для возврата 1 млрд строк, и на вычисление уходит всего 40 мс:

```sql
SELECT 4 * sum(if(number % 2, -1, 1) / ((number * 2) + 1)) AS pi
FROM numbers_mt(1000000000.)

┌────────────────pi─┐
│ 3.141592652589797 │
└───────────────────┘

1 строка в наборе. Затрачено: 0.432 сек. Обработано 1.00 миллиард строк, 8.00 ГБ (2.32 миллиарда строк/сек., 18.53 ГБ/сек.)
```

2. Следующий пример тоже обрабатывает 1 млрд чисел, но медленнее:

```sql
SELECT 3 + (4 * sum(if((number % 2) = 0, if((number % 4) = 0, -1 / ((number * (number + 1)) * (number + 2)), 1 / ((number * (number + 1)) * (number + 2))), 0))) AS pi
FROM numbers_mt(2, 10000000000)

┌─────────────────pi─┐
│ 3.1415926525808087 │
└────────────────────┘

1 row in set. Elapsed: 9.825 sec. Processed 10.00 billion rows, 80.00 GB (1.02 billion rows/s., 8.14 GB/s.)
```

3. Этот вариант, разумеется, наш любимый в ClickHouse (и самый точный!):

```sql
SELECT pi()

┌──────────────pi()─┐
│ 3.141592653589793 │
└───────────────────┘

1 row in set. Elapsed: 0.008 sec.
```

4. Тут кто-то явно знал толк в тригонометрии:

```sql
SELECT 2 * asin(1) AS pi

┌────────────────pi─┐
│ 3.141592653589793 │
└───────────────────┘

1 row in set. Elapsed: 0.005 sec.
```

5. Вот удобный API, который позволяет задать нужное вам количество цифр:

```sql
SELECT *
FROM url('https://api.pi.delivery/v1/pi?start=0&numberOfDigits=100', 'JSONEachRow')

┌───────────────content─┐
│ 3.1415926535897933e99 │
└───────────────────────┘

Получена 1 строка. Затрачено: 0.556 сек.
```

6. Этот приём интересен — он использует функции расстояния ClickHouse:

```sql
WITH random_points AS
    (
        SELECT (rand64(1) / pow(2, 64), rand64(2) / pow(2, 64)) AS point
        FROM numbers(1000000000)
    )
SELECT (4 * countIf(L2Norm(point) < 1)) / count() AS pi
FROM random_points


┌──────────pi─┐
│ 3.141627208 │
└─────────────┘

1 row in set. Elapsed: 4.742 sec. Processed 1.00 billion rows, 8.00 GB (210.88 million rows/s., 1.69 GB/s.)
```

7. Если вы физик, вам подойдёт этот вариант:

```sql
SELECT 22 / 7

┌─────divide(22, 7)─┐
│ 3.142857142857143 │
└───────────────────┘
```

8. Еще один косвенный метод (этот предложил Alexey Milovidov), обеспечивающий точность до 7 знаков после запятой — и он работает быстро:

```sql
WITH
    10 AS length,
    (number / 1000000000.) * length AS x
SELECT pow((2 * length) * avg(exp(-(x * x))), 2) AS pi
FROM numbers_mt(1000000000.)


┌─────────────────pi─┐
│ 3.1415926890388595 │
└────────────────────┘

Обработана 1 строка. Затрачено: 1.245 сек. Обработано 1.00 миллиард строк, 8.00 ГБ (803.25 миллионов строк/с., 6.43 ГБ/с.)
```

:::note
Если у вас есть дополнительные примеры, мы будем рады вашему вкладу. Спасибо!
:::
---
title: Улучшение производительности поиска по Map в ClickHouse
description: Узнайте, как оптимизировать поиск по столбцам типа Map в ClickHouse для повышения производительности запросов, материализуя отдельные ключи в самостоятельные столбцы.
date: 2022-10-30
tags: ['Оптимизация производительности']
keywords: ['Производительность Map']
---

{frontMatter.description}

{/* усечение */}


## Проблема

Обращение к Map, например `a['key']`, имеет линейную сложность (упоминается [здесь](https://clickhouse.com/docs/sql-reference/data-types/map)) и может быть неэффективным. Это связано с тем, что выбор значения по конкретному ключу из таблицы требует перебора всех ключей (~M) во всех строках (N) в столбце типа Map, что приводит к ~MxN операциям поиска.

Обращение с использованием Map может быть в 10 раз медленнее, чем по столбцу типа String. Эксперимент ниже также показывает примерно 10-кратное замедление для холодного запроса и различие в несколько порядков по объёму обрабатываемых данных (7.21 MB против 5.65 GB).

```sql
-- создать таблицу с SpanName как String и ResourceAttributes как Map
DROP TABLE IF EXISTS tbl;
CREATE TABLE tbl (
    `Timestamp` DateTime64(9) CODEC (Delta(8), ZSTD(1)),
    `TraceId` String CODEC (ZSTD(1)),
    `ServiceName` LowCardinality(String) CODEC (ZSTD(1)),
    `Duration` UInt8 CODEC (ZSTD(1)), -- Int64
    `SpanName` LowCardinality(String) CODEC (ZSTD(1)),
    `ResourceAttributes` Map(LowCardinality(String), String) CODEC (ZSTD(1))
)
ENGINE = MergeTree
PARTITION BY toDate(Timestamp)
ORDER BY (ServiceName, SpanName, toUnixTimestamp(Timestamp), TraceId);

-- создать пользовательскую функцию для генерации случайных данных Map для ResourceAttributes
DROP FUNCTION IF EXISTS genmap;
CREATE FUNCTION genmap AS (n) -> arrayMap (x-> (x::String, (x*rand32())::String), range(1, n));

-- проверить, что genmap работает корректно
SELECT genmap(10)::Map(String, String);

-- вставить 1 млн строк
INSERT INTO tbl
SELECT
    now() - randUniform(1, 1000000.) as Timestamp,
    randomPrintableASCII(2) as TraceId,
    randomPrintableASCII(2) as ServiceName,
    rand32() as Duration,
    randomPrintableASCII(2) as SpanName,
    genmap(rand64()%500)::Map(String, String) as ResourceAttributes
FROM numbers(1_000_000);

-- запрос по SpanName выполняется быстрее
-- [холодный] 0 rows in set. Elapsed: 0.642 sec. Processed 1.00 million rows, 7.21 MB (1.56 million rows/s., 11.22 MB/s.)
-- [горячий] 0 rows in set. Elapsed: 0.164 sec. Processed 1.00 million rows, 7.21 MB (6.10 million rows/s., 43.99 MB/s.)
SELECT
    COUNT(*),
    avg(Duration/1E6) as average,
    quantile(0.95)(Duration/1E6) as p95,
    quantile(0.99)(Duration/1E6) as p99,
    SpanName
FROM tbl
GROUP BY SpanName ORDER BY 1 DESC LIMIT 50 FORMAT Null;

-- запрос по ResourceAttributes выполняется медленнее
-- [холодный] 0 rows in set. Elapsed: 6.432 sec. Processed 1.00 million rows, 5.65 GB (155.46 thousand rows/s., 879.07 MB/s.)
-- [горячий] 0 rows in set. Elapsed: 5.935 sec. Processed 1.00 million rows, 5.65 GB (168.50 thousand rows/s., 952.81 MB/s.)
SELECT
    COUNT(*),
    avg(Duration/1E6) as average,
    quantile(0.95)(Duration/1E6) as p95,
    quantile(0.99)(Duration/1E6) as p99,
    ResourceAttributes['1'] as hostname
FROM tbl
GROUP BY hostname ORDER BY 1 DESC LIMIT 50 FORMAT Null;
```

**Решение**
Чтобы улучшить запрос, мы можем добавить дополнительный столбец, в котором по умолчанию будет использоваться значение для определённого ключа из столбца типа Map, а затем материализовать его, чтобы заполнить значения для существующих строк. Таким образом, мы извлекаем и сохраняем нужное значение во время вставки данных, тем самым ускоряя поиск при выполнении запроса.


```sql
-- решение — добавить столбец со значением по умолчанию из определённого ключа в Map
ALTER TABLE tbl ADD COLUMN hostname LowCardinality(String) DEFAULT ResourceAttributes['1'];
ALTER TABLE tbl MATERIALIZE COLUMN hostname;

-- запрос по hostname (новому столбцу) теперь выполняется быстрее
-- [холодный] 0 строк в наборе. Затрачено: 2.215 сек. Обработано 1.00 млн строк, 21.67 МБ (451.52 тыс. строк/с., 9.78 МБ/с.)
-- [тёплый] 0 строк в наборе. Затрачено: 0.541 сек. Обработано 1.00 млн строк, 21.67 МБ (1.85 млн строк/с., 40.04 МБ/с.)
SELECT
    COUNT(*),
    avg(Duration/1E6) as average,
    quantile(0.95)(Duration/1E6) as p95,
    quantile(0.99)(Duration/1E6) as p99,
    hostname
FROM tbl
GROUP BY hostname ORDER BY 1 DESC LIMIT 50 FORMAT Null;

-- очистить кеш для выполнения запроса на холодном кеше
SYSTEM DROP FILESYSTEM CACHE;
```

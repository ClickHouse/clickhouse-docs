---
title: "Профилирование ClickHouse с помощью LLVM XRay"
date: 2024-11-13
description: "Научитесь профилировать ClickHouse с помощью инструментального профилировщика LLVM XRay, визуализировать трейсы и анализировать производительность."
tags: ['Производительность и оптимизации', 'Инструменты и утилиты']
---

import Image from "@theme/IdealImage";
import clickhouse from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/profile.png'
import time_order from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/time-order.png'
import left_heavy from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/left-heavy.png'
import sandwich from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/sandwich.png'

{frontMatter.description}

{/* truncate */}

## Типы профайлеров \{#types-of-profilers\}

LLVM уже включает инструмент, который добавляет в код инструментацию и позволяет выполнять [профилирование с инструментированием](https://en.wikipedia.org/wiki/Profiling_\(computer_programming\)#Instrumentation). В отличие от [семплирующего или статистического профилирования](https://en.wikipedia.org/wiki/Profiling_\(computer_programming\)#Statistical_profilers),
оно обладает высокой точностью и не теряет ни одного вызова, но требует инструментирования кода и более ресурсоёмко.

Проще говоря, профайлер с инструментированием добавляет новый код для отслеживания вызовов всех функций.
Статистические профайлеры позволяют запускать код без каких-либо изменений, периодически делая снимки
состояния приложения. Поэтому учитываются только те функции, которые выполняются в момент снятия снимка.
[perf](https://en.wikipedia.org/wiki/Perf_%28Linux%29) — очень известный статистический профайлер.

## Профилирование ClickHouse с помощью интеграции XRay&#39;a \{#profiling-clickhouse-using-xray-integration\}

В ClickHouse 25.12 XRay интегрирован, что позволяет прозрачно добавлять новые точки инструментирования в функции.
Таким образом, любой официальный релиз уже содержит эту возможность, которую можно включать по
требованию, не влияя на общую производительность, пока она не активна. Идея состоит в том, чтобы
включать минимально необходимое количество точек инструментирования для получения ценной информации.

Мы можем добавить новую точку профилирования с помощью команды [SYSTEM INSTRUMENT ADD
PROFILE](https://clickhouse.com/docs/sql-reference/statements/system#instrument-add-profile).
Функции, для которых нужно включить инструментирование, можно получить из системной таблицы
[system.symbols](https://clickhouse.com/docs/operations/system-tables/symbols). Допустим, мы
хотим профилировать функцию `sleepForNanoseconds`, которая является удобным способом проверить,
сколько времени занимает выполнение.

```sql
SYSTEM INSTRUMENT ADD `sleepForNanoseconds` PROFILE
```

Затем оставляем его работать в течение требуемого периода профилирования, после чего останавливаем.

```sql
SYSTEM INSTRUMENT REMOVE ALL
```

Мы преобразуем данные, собранные в system.trace&#95;log, [в формат Chrome](https://clickhouse.com/docs/operations/system-tables/trace_log#chrome-event-trace-format),
чтобы визуализировать их в [Perfetto](https://ui.perfetto.dev). Обратите внимание на query&#95;id, cpu&#95;id и стек-трейс для
каждой записи.

<Image img={clickhouse} size="md" alt="time-order" />

## Профилирование нативного приложения с помощью XRay \{#profiling-a-native-application-using-xray\}

Следующий раздел приведён в качестве справки, чтобы показать, как XRay устроен «под капотом» и как его можно использовать без дополнительной настройки для профилирования нативного приложения.

### Инструментируйте код \{#instrument-the-code\}

Рассмотрим следующий исходный код:

```cpp
#include <chrono>
#include <cstdio>
#include <thread>

void one()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
}

void two()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(5));
}

int main()
{
    printf("Start\n");

    for (int i = 0; i < 10; ++i)
    {
        one();
        two();
    }

    printf("Finish\n");
}
```

Чтобы включить инструментирование с XRay, необходимо добавить следующие флаги:

```bash
clang++ -o test test.cpp -fxray-instrument -fxray-instruction-threshold=1
```

* `-fxray-instrument` нужен для инструментации кода.
* `-fxray-instruction-threshold=1` используется, чтобы инструментировать все функции, даже если они
  очень маленькие, как в нашем примере. По умолчанию инструментируются функции как минимум с [200
  инструкциями](https://llvm.org/docs/XRay.html#instrumenting-your-c-c-objective-c-application).

Мы можем убедиться, что код был корректно инструментирован, проверив, что в бинарном файле появился новый раздел:

```bash
objdump -h -j xray_instr_map test

test:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
 17 xray_instr_map 000005c0  000000000002f91c  000000000002f91c  0002f91c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
```

### Запустите процесс с корректными значениями переменных окружения для сбора трассировки \{#run-the-process-with-proper-env-var-values-to-collect-the-trace\}

По умолчанию профилировщик ничего не собирает, если его явно не задействовать. Другими словами, если мы не проводим профилирование, накладные расходы пренебрежимо малы. Мы можем задать разные значения для `XRAY_OPTIONS`, чтобы настроить, когда профилировщик начинает сбор данных и как он это делает.

```bash
XRAY_OPTIONS="patch_premain=true xray_mode=xray-basic verbosity=1" ./test
==74394==XRay: Log file in 'xray-log.test.14imlN'
Начало
Завершение
==74394==Cleaned up log for TID: 74394
```

### Преобразование трассировок \{#convert-the-trace\}

Трассировки XRay можно преобразовывать в несколько форматов. Формат `trace_event` очень удобен, так как его легко парсить, и уже существует множество инструментов, которые его поддерживают, поэтому мы будем использовать именно его:

```bash
llvm-xray convert --symbolize --instr_map=./test --output-format=trace_event xray-log.test.14imlN | gzip > test-trace.txt.gz
```

### Визуализация трассировки \{#visualize-the-trace\}

Мы можем использовать веб-интерфейсы, такие как [speedscope.app](https://www.speedscope.app/) или
[Perfetto](https://ui.perfetto.dev).

Хотя Perfetto упрощает визуализацию нескольких потоков и выполнение запросов к данным, speedscope лучше
подходит для построения flame-графа и слоистого (sandwich) представления ваших данных.

#### Временной порядок \{#time-order\}

<Image img={time_order} size="md" alt="временной порядок" />

#### Смещение влево \{#left-heavy\}

<Image img={left_heavy} size="md" alt="смещение влево" />

#### Сэндвич \{#sandwitch\}

<Image img={sandwich} size="md" alt="сэндвич" />

## Ознакомьтесь с документацией \{#check-out-the-docs\}

* [SYSTEM INSTRUMENT](https://clickhouse.com/docs/sql-reference/statements/system#instrument) — добавление
  или удаление точек инструментирования.
* [system.instrumentation](https://clickhouse.com/docs/operations/system-tables/instrumentation)
  — просмотр установленных точек инструментирования.
* [system.symbols](https://clickhouse.com/docs/operations/system-tables/symbols) — просмотр
  символов для добавления точек инструментирования.
* [system.trace&#95;log](https://clickhouse.com/docs/operations/system-tables/trace_log) — просмотр данных,
  собранных с использованием точек инструментирования.
* [XRay Instrumentation](https://llvm.org/docs/XRay.html)
* [Debugging with XRay](https://llvm.org/docs/XRayExample.html) — дополнительная документация для более детального изучения.
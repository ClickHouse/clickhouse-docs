---
title: 'Превышен лимит памяти для запроса'
description: 'Устранение ошибок превышения лимита памяти при выполнении запроса'
date: 2025-07-25
tags: ['Ошибки и исключения']
keywords: ['OOM', 'превышение лимита памяти']
---

{frontMatter.description}

{/* усечение */}

import Image from '@theme/IdealImage';
import joins from '@site/static/images/knowledgebase/memory-limit-exceeded-for-query.png';

## Превышен лимит памяти для запроса \{#troubleshooting-out-of-memory-issues\}

Для нового пользователя ClickHouse часто может казаться магией — каждый запрос
выполняется сверхбыстро, даже на самых больших наборах данных и при самых
сложных запросах. Однако эксплуатация в реальных условиях испытывает на прочность
даже возможности ClickHouse. Превышение лимита памяти запросами может происходить
по ряду причин. Чаще всего мы видим крупные `JOIN` или агрегации по полям с
высокой кардинальностью. Если производительность критична и эти запросы
необходимы, мы часто рекомендуем пользователям просто масштабировать кластер —
то, что ClickHouse Cloud делает автоматически и без усилий, чтобы ваши запросы
сохраняли высокую скорость отклика. Мы понимаем, однако, что в сценариях с
самостоятельным управлением это не всегда тривиально, и, возможно, максимальная
производительность даже не требуется. В таком случае у пользователей есть
несколько вариантов.

### Агрегации \{#aggregations\}

Для требовательных к памяти агрегаций или сценариев сортировки пользователи могут использовать настройки
[`max_bytes_before_external_group_by`](/operations/settings/settings#max_bytes_before_external_group_by)
и соответственно [`max_bytes_before_external_sort`](/operations/settings/settings#max_bytes_ratio_before_external_sort).
Первая из них подробно рассматривается [здесь](/sql-reference/statements/select/group-by/#group-by-in-external-memory).

Вкратце, это обеспечивает возможность «выгрузки» любых агрегаций на диск, если превышен порог по памяти.
Это неизбежно повлияет на производительность запроса, но поможет избежать OOM-ошибок.
Вторая настройка, связанная с сортировкой, помогает решать аналогичные проблемы с требовательными к памяти сортировками.
Это может быть особенно важно в распределённых средах, когда координирующий узел получает отсортированные ответы
от дочерних шардов. В таком случае координирующему серверу может потребоваться отсортировать набор данных,
превышающий объём доступной памяти. С настройкой [`max_bytes_before_external_sort`](/operations/settings/settings#max_bytes_ratio_before_external_sort)
сортировка может выполняться с выгрузкой на диск. Эта настройка также полезна в случаях, когда пользователь
использует `ORDER BY` после `GROUP BY` с `LIMIT`, особенно когда запрос является распределённым.

### Соединения \{#joins\}

Для соединений пользователи могут выбирать различные алгоритмы `JOIN`, которые помогают
снизить требования к памяти. По умолчанию используется хеш-соединение (hash join), которое
обеспечивает наибольшую полноту с точки зрения поддерживаемых возможностей и часто лучшую
производительность. Этот алгоритм загружает правую таблицу `JOIN` во внутреннюю хеш‑таблицу
в памяти, относительно которой затем вычисляется левая таблица. Чтобы минимизировать
потребление памяти, пользователи должны помещать меньшую таблицу справа. Однако такой
подход по‑прежнему имеет ограничения в сценариях, ограниченных по памяти. В этих случаях
можно включить `partial_merge` join через настройку [`join_algorithm`](/operations/settings/settings#join_algorithm).
Этот вариант [алгоритма сортировочного соединения](https://en.wikipedia.org/wiki/Sort-merge_join)
сначала сортирует правую таблицу на блоки и создаёт для них min-max‑индекс.
Затем части левой таблицы сортируются по ключу соединения и соединяются с правой
таблицей. Min-max‑индекс используется для пропуска ненужных блоков правой таблицы.
Такой подход менее требователен к памяти, но ценой снижения производительности. Развивая
эту идею, алгоритм `full_sorting_merge` позволяет выполнять `JOIN`, когда правая
часть очень велика, не помещается в памяти и прямые обращения к данным невозможны,
например, при сложном подзапросе. В этом случае и правая, и левая часть сортируются
на диске, если те не помещаются в памяти, что позволяет соединять большие таблицы.

<Image img={joins} size="md" alt="Алгоритмы соединений" />

Начиная с версии 20.3, ClickHouse поддерживает значение `auto` для настройки `join_algorithm`.
Оно указывает ClickHouse применять адаптивный подход к соединениям, при котором
алгоритм hash-join используется предпочтительно до тех пор, пока не будут нарушены
ограничения по памяти, после чего ClickHouse пытается использовать алгоритм
`partial_merge`. Наконец, в контексте соединений мы рекомендуем читателям обратить
внимание на поведение распределённых соединений и способы минимизации их потребления
памяти. Дополнительную информацию можно найти [здесь](/sql-reference/operators/in#distributed-subqueries).
---
date: 2023-05-02
title: Когда применяются правила TTL и можем ли мы этим управлять?
description: Правила TTL в ClickHouse рано или поздно автоматически применяются, и вы можете управлять временем их выполнения с помощью настройки `merge_with_ttl_timeout`. Узнайте, как принудительно запустить применение TTL и управлять фоновыми потоками, выполняющими TTL.
tags: ['Основные концепции данных']
keywords: ['TTL']
---

{frontMatter.description}

{/* очистить */}

## Правила и управление TTL \{#ttl-rules-and-control\}

TTL будет применён ***в конечном итоге***. Что это означает? Настройка таблицы `MergeTree` [`merge_with_ttl_timeout`](https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree#merge_with_ttl_timeout) задаёт минимальную задержку в секундах перед повторным выполнением операции слияния с TTL на удаление. Значение по умолчанию — 14400 секунд (4 часа). Но это лишь минимальная задержка — фактически может пройти больше времени, прежде чем будет инициировано слияние для применения TTL на удаление.

Вы можете просмотреть все текущие настройки TTL (такие как `merge_with_ttl_timeout`) с помощью этого запроса:

```sql
SELECT *
FROM system.merge_tree_settings
WHERE name like '%ttl%'
```

Ответ будет выглядеть примерно так:

```response
┌─name───────────────────────────────────────────────────────────┬─value───┬─changed─┬─description────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬─min──┬─max──┬─readonly─┬─type───┐
│ max_replicated_merges_with_ttl_in_queue                        │ 1       │       0 │ Максимальное количество задач слияния частей с TTL, которые могут выполняться одновременно в очереди ReplicatedMergeTree.                                                                  │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ max_number_of_merges_with_ttl_in_pool                          │ 2       │       0 │ Если в пуле находится больше указанного количества слияний с записями TTL, новые слияния с TTL не назначаются. Это позволяет оставить свободные потоки для обычных слияний и избежать ошибки "Too many parts" │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ merge_tree_clear_old_broken_detached_parts_ttl_timeout_seconds │ 2592000 │       1 │ Удалять старые поврежденные отсоединенные части в фоновом режиме, если они оставались нетронутыми в течение периода времени, заданного этой настройкой.                                    │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ merge_with_ttl_timeout                                         │ 14400   │       0 │ Минимальное время в секундах, через которое может быть повторено слияние с удалением по TTL.                                                                                               │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Int64  │
│ merge_with_recompression_ttl_timeout                           │ 14400   │       0 │ Минимальное время в секундах, через которое может быть повторено слияние с перекомпрессией по TTL.                                                                                         │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Int64  │
│ ttl_only_drop_parts                                            │ 0       │       0 │ Только полностью удалять истекшие части, не обрезая их частично.                                                                                                                           │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Bool   │
│ materialize_ttl_recalculate_only                               │ 0       │       0 │ Только пересчитывать информацию TTL при выполнении MATERIALIZE TTL                                                                                                                         │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Bool   │
└────────────────────────────────────────────────────────────────┴─────────┴─────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────┴──────┴──────────┴────────┘
```

Вы можете использовать `SHOW CREATE TABLE`, чтобы проверить, содержит ли ваша таблица правила TTL, а также были ли какие-либо параметры таблицы `SETTINGS` использованы для изменения значений настроек выше:

```sql
SHOW CREATE TABLE <TableName>
```

## Принудительное применение правила TTL \{#force-a-ttl-rule-to-be-applied\}

Это не самое изящное решение, но вы можете явно выполнить `MATERIALIZE TTL`, чтобы принудительно материализовать все правила TTL для таблицы:

```sql
ALTER TABLE my_table
    MATERIALIZE TTL
```

## Фоновые потоки, влияющие на TTL \{#background-threads-affecting-ttl\}

Возможно, ваши правила TTL не применяются, потому что в пуле фоновых потоков недостаточно потоков. Например, если вы интенсивно вставляете данные, весь пул фоновых потоков может быть занят выполнением обычных слияний. Однако вы можете увеличить размер фонового пула.

Вы можете проверить текущий размер фонового пула с помощью этого запроса:

```sql
SELECT *
FROM system.settings
WHERE name = 'background_pool_size';
```

Ответ будет выглядеть примерно так:

```response
┌─name─────────────────┬─value─┬─changed─┬─description─────────────────────┬─min──┬─max──┬─readonly─┬─type───┬─default─┬─alias_for─┐
│ background_pool_size │ 16    │       0 │ Устаревшая настройка, ничего не делает. │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │ 16      │           │
└──────────────────────┴───────┴─────────┴─────────────────────────────────┴──────┴──────┴──────────┴────────┴─────────┴───────────┘
```

Ознакомьтесь с документацией о том, как изменить [параметр `background_pool_size`](https://clickhouse.com/docs/operations/server-configuration-parameters/settings#background_pool_size), который настроен следующим образом:

```xml
<background_pool_size>16</background_pool_size>
```

Вы можете проверить текущую активность фонового пула с помощью этого запроса:

```sql
SELECT *
FROM system.metrics
WHERE metric like 'Background%'
```

---
'title': 'chDB Python API Справочник'
'sidebar_label': 'Python API'
'slug': '/chdb/api/python'
'description': 'Полный справочник Python API для chDB'
'keywords':
- 'chdb'
- 'embedded'
- 'clickhouse-lite'
- 'python'
- 'api'
- 'reference'
'doc_type': 'reference'
---


# Справочник по Python API
## Основные функции запросов {#core-query-functions}
### `chdb.query` {#chdb-query}

Выполнить SQL-запрос с использованием движка chDB.

Это основная функция запроса, которая выполняет SQL-операторы с использованием встроенного движка ClickHouse. Поддерживает различные форматы вывода и может работать с базами данных в памяти или на файловой основе.

**Синтаксис**

```python
chdb.query(sql, output_format='CSV', path='', udf_path='')
```

**Параметры**

| Параметр        | Тип   | По умолчанию | Описание                                                                                                                                                                                                                                                                                                     |
|------------------|-------|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sql`            | str   | *обязательный* | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                                          |
| `output_format`  | str   | `"CSV"`      | Формат вывода для результатов. Поддерживаемые форматы:<br/>• `"CSV"` - Значения, разделенные запятыми<br/>• `"JSON"` - Формат JSON<br/>• `"Arrow"` - Формат Apache Arrow<br/>• `"Parquet"` - Формат Parquet<br/>• `"DataFrame"` - Pandas DataFrame<br/>• `"ArrowTable"` - Таблица PyArrow<br/>• `"Debug"` - Включить детализированное логирование |
| `path`           | str   | `""`         | Путь к файлу базы данных. По умолчанию используется база данных в памяти.<br/>Может быть путем к файлу или `":memory:"` для базы данных в памяти                                                                                                                                                             |
| `udf_path`       | str   | `""`         | Путь к директории пользовательских функций                                                                                                                                                                                                                                                                 |

**Возвращает**

Возвращает результат запроса в указанном формате:

| Тип возврата      | Условие                                                |
|--------------------|--------------------------------------------------------|
| `str`              | Для текстовых форматов, таких как CSV, JSON          |
| `pd.DataFrame`     | Когда `output_format` равно `"DataFrame"` или `"dataframe"` |
| `pa.Table`         | Когда `output_format` равно `"ArrowTable"` или `"arrowtable"` |
| объект результата chdb | Для других форматов                                  |

**Вызывает**

| Исключение     | Условие                                                      |
|----------------|--------------------------------------------------------------|
| `ChdbError`    | Если выполнение SQL-запроса завершилось неудачей           |
| `ImportError`  | Если отсутствуют необходимые зависимости для форматов DataFrame/Arrow |

**Примеры**

```pycon
>>> # Basic CSV query
>>> result = chdb.query("SELECT 1, 'hello'")
>>> print(result)
"1,hello"
```

```pycon
>>> # Query with DataFrame output
>>> df = chdb.query("SELECT 1 as id, 'hello' as msg", "DataFrame")
>>> print(df)
   id    msg
0   1  hello
```

```pycon
>>> # Query with file-based database
>>> result = chdb.query("CREATE TABLE test (id INT)", path="mydb.chdb")
```

```pycon
>>> # Query with UDF
>>> result = chdb.query("SELECT my_udf('test')", udf_path="/path/to/udfs")
```

---
### `chdb.sql` {#chdb_sql}

Выполнить SQL-запрос с использованием движка chDB.

Это основная функция запроса, которая выполняет SQL-операторы с использованием встроенного движка ClickHouse. Поддерживает различные форматы вывода и может работать с базами данных в памяти или на файловой основе.

**Синтаксис**

```python
chdb.sql(sql, output_format='CSV', path='', udf_path='')
```

**Параметры**

| Параметр        | Тип   | По умолчанию | Описание                                                                                                                                                                                                                                                                                                     |
|------------------|-------|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sql`            | str   | *обязательный* | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                                          |
| `output_format`  | str   | `"CSV"`      | Формат вывода для результатов. Поддерживаемые форматы:<br/>• `"CSV"` - Значения, разделенные запятыми<br/>• `"JSON"` - Формат JSON<br/>• `"Arrow"` - Формат Apache Arrow<br/>• `"Parquet"` - Формат Parquet<br/>• `"DataFrame"` - Pandas DataFrame<br/>• `"ArrowTable"` - Таблица PyArrow<br/>• `"Debug"` - Включить детализированное логирование |
| `path`           | str   | `""`         | Путь к файлу базы данных. По умолчанию используется база данных в памяти.<br/>Может быть путем к файлу или `":memory:"` для базы данных в памяти                                                                                                                                                             |
| `udf_path`       | str   | `""`         | Путь к директории пользовательских функций                                                                                                                                                                                                                                                                 |

**Возвращает**

Возвращает результат запроса в указанном формате:

| Тип возврата      | Условие                                                |
|--------------------|--------------------------------------------------------|
| `str`              | Для текстовых форматов, таких как CSV, JSON          |
| `pd.DataFrame`     | Когда `output_format` равно `"DataFrame"` или `"dataframe"` |
| `pa.Table`         | Когда `output_format` равно `"ArrowTable"` или `"arrowtable"` |
| объект результата chdb | Для других форматов                                  |

**Вызывает**

| Исключение                 | Условие                                                      |
|---------------------------|--------------------------------------------------------------|
| [`ChdbError`](#chdberror) | Если выполнение SQL-запроса завершилось неудачей           |
| `ImportError`             | Если отсутствуют необходимые зависимости для форматов DataFrame/Arrow |

**Примеры**

```pycon
>>> # Basic CSV query
>>> result = chdb.query("SELECT 1, 'hello'")
>>> print(result)
"1,hello"
```

```pycon
>>> # Query with DataFrame output
>>> df = chdb.query("SELECT 1 as id, 'hello' as msg", "DataFrame")
>>> print(df)
   id    msg
0   1  hello
```

```pycon
>>> # Query with file-based database
>>> result = chdb.query("CREATE TABLE test (id INT)", path="mydb.chdb")
```

```pycon
>>> # Query with UDF
>>> result = chdb.query("SELECT my_udf('test')", udf_path="/path/to/udfs")
```

---
### `chdb.to_arrowTable` {#chdb-state-sqlitelike-to_arrowtable}

Преобразовать результат запроса в таблицу PyArrow.

Преобразует результат запроса chDB в таблицу PyArrow для эффективной обработки данных в столбцах. Возвращает пустую таблицу, если результат пуст.

**Синтаксис**

```python
chdb.to_arrowTable(res)
```

**Параметры**

| Параметр    | Описание                                           |
|--------------|---------------------------------------------------|
| `res`        | объект результата запроса chDB, содержащий бинарные данные Arrow |

**Возвращает**

| Тип возврата | Описание                                |
|--------------|------------------------------------------|
| `pa.Table`   | Таблица PyArrow, содержащая результаты запроса |

**Вызывает**

| Тип ошибки    | Описание                            |
|---------------|------------------------------------|
| `ImportError` | Если pyarrow или pandas не установлены |

**Пример**

```pycon
>>> result = chdb.query("SELECT 1 as id, 'hello' as msg", "Arrow")
>>> table = chdb.to_arrowTable(result)
>>> print(table.to_pandas())
   id    msg
0   1  hello
```

---
### `chdb.to_df` {#chdb_to_df}

Преобразовать результат запроса в pandas DataFrame.

Преобразует результат запроса chDB в pandas DataFrame, сначала преобразуя в таблицу PyArrow, а затем в pandas с использованием многопоточности для повышения производительности.

**Синтаксис**

```python
chdb.to_df(r)
```

**Параметры**

| Параметр  | Описание                                           |
|------------|---------------------------------------------------|
| `r`        | объект результата запроса chDB, содержащий бинарные данные Arrow |

**Возвращает**

| Тип возврата | Описание |
|--------------|----------|
| `pd.DataFrame` | pandas DataFrame, содержаший результаты запроса |

**Вызывает**

| Исключение     | Условие                              |
|----------------|--------------------------------------|
| `ImportError`  | Если pyarrow или pandas не установлены |

**Пример**

```pycon
>>> result = chdb.query("SELECT 1 as id, 'hello' as msg", "Arrow")
>>> df = chdb.to_df(result)
>>> print(df)
   id    msg
0   1  hello
```
## Управление соединением и сессиями {#connection-session-management}

Следующие функции сессии доступны:
### `chdb.connect` {#chdb-connect}

Создать соединение с фоновым сервером chDB.

Эта функция устанавливает [Соединение](#chdb-state-sqlitelike-connection) с движком базы данных chDB (ClickHouse). Разрешено только одно открытое соединение на процесс. Множественные вызовы с одной и той же строкой соединения будут возвращать один и тот же объект соединения.

```python
chdb.connect(connection_string: str = ':memory:') → Connection
```

**Параметры:**

| Параметр           | Тип   | По умолчанию | Описание                                    |
|---------------------|-------|--------------|----------------------------------------------|
| `connection_string` | str   | `":memory:"` | Строка соединения с базой данных. См. форматы ниже. |

**Базовые форматы**

| Формат                    | Описание                  |
|---------------------------|---------------------------|
| `":memory:"`              | База данных в памяти (по умолчанию) |
| `"test.db"`               | Файл базы данных с относительным путем  |
| `"file:test.db"`          | То же самое, что и относительный путь  |
| `"/path/to/test.db"`      | Файл базы данных с абсолютным путем  |
| `"file:/path/to/test.db"` | То же самое, что и абсолютный путь  |

**С параметрами запроса**

| Формат                                             | Описание               |
|----------------------------------------------------|-----------------------|
| `"file:test.db?param1=value1&param2=value2"`       | Относительный путь с параметрами |
| `"file::memory:?verbose&log-level=test"`           | В памяти с параметрами     |
| `"///path/to/test.db?param1=value1&param2=value2"` | Абсолютный путь с параметрами |

**Обработка параметров запроса**

Параметры запроса передаются в движок ClickHouse в качестве аргументов при запуске. Специальная обработка параметров:

| Специальный параметр  | становится        | Описание             |
|------------------------|-------------------|---------------------|
| `mode=ro`              | `--readonly=1`     | Режим только для чтения |
| `verbose`              | (флаг)            | Включает детализированное логирование |
| `log-level=test`       | (настройка)       | Устанавливает уровень логирования |

Для полного списка параметров см. `clickhouse local --help --verbose`

**Возвращает**

| Тип возврата  | Описание                                                                                                                                                                                                                                        |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Connection`  | Объект соединения с базой данных, который поддерживает:<br/>• Создание курсоров с помощью `Connection.cursor()`<br/>• Прямые запросы с помощью `Connection.query()`<br/>• Потоковые запросы с помощью `Connection.send_query()`<br/>• Протокол контекстного менеджера для автоматической очистки |

**Вызывает**

| Исключение      | Условие                       |
|------------------|---------------------------------|
| `RuntimeError`   | Если соединение с базой данных не удалось |

:::warning
Поддерживается только одно соединение на процесс. Создание нового соединения закроет любое существующее соединение.
:::

**Примеры**

```pycon
>>> # In-memory database
>>> conn = connect()
>>> conn = connect(":memory:")
>>>
>>> # File-based database
>>> conn = connect("my_data.db")
>>> conn = connect("/path/to/data.db")
>>>
>>> # With parameters
>>> conn = connect("data.db?mode=ro")  # Read-only mode
>>> conn = connect(":memory:?verbose&log-level=debug")  # Debug logging
>>>
>>> # Using context manager for automatic cleanup
>>> with connect("data.db") as conn:
...     result = conn.query("SELECT 1")
...     print(result)
>>> # Connection automatically closed
```

**Смотрите также**
- [`Connection`](#chdb-state-sqlitelike-connection) - Класс соединения с базой данных
- [`Cursor`](#chdb-state-sqlitelike-cursor) - Курсор базы данных для операций DB-API 2.0
## Обработка исключений {#chdb-exceptions}
### **class** `chdb.ChdbError` {#chdb_chdbError}

Базовый класс: `Exception`

Базовый класс исключений для ошибок, связанных с chDB.

Это исключение вызывается, когда выполнение запроса chDB завершается неудачей или происходит ошибка. Он наследует от стандартного класса исключений Python и предоставляет информацию об ошибке из движка ClickHouse.

---
### **class** `chdb.session.Session` {#chdb_session_session}

Базовый класс: `object`

Сессия будет сохранять состояние запроса. Если путь равен None, будет создан временный каталог, который будет использоваться в качестве пути к базе данных, и временный каталог будет удален, когда сессия будет закрыта. Вы также можете указать путь, чтобы создать базу данных в этом пути, где будут храниться ваши данные.

Вы также можете использовать строку соединения, чтобы передать путь и другие параметры.

```python
class chdb.session.Session(path=None)
```

**Примеры**

| Строка соединения                                  | Описание                          |
|----------------------------------------------------|-----------------------------------|
| `":memory:"`                                       | База данных в памяти               |
| `"test.db"`                                        | Относительный путь                |
| `"file:test.db"`                                   | То же самое, что и выше           |
| `"/path/to/test.db"`                               | Абсолютный путь                    |
| `"file:/path/to/test.db"`                          | То же самое, что и выше           |
| `"file:test.db?param1=value1&param2=value2"`       | Относительный путь с параметрами  |
| `"file::memory:?verbose&log-level=test"`           | База данных в памяти с параметрами |
| `"///path/to/test.db?param1=value1&param2=value2"` | Абсолютный путь с параметрами      |

:::note Обработка параметров строки соединения
Строки соединения, содержащие параметры запроса, такие как “[file:test.db?param1=value1&param2=value2](file:test.db?param1=value1&param2=value2)”
“param1=value1” будет передано в движок ClickHouse в качестве аргументов при старте.

Для получения дополнительной информации смотрите `clickhouse local –help –verbose`

Некоторые специальные параметры:
- “mode=ro” будет “–readonly=1” для clickhouse (режим только для чтения)
:::

:::warning Важно
- Может быть только одна сессия одновременно. Если вы хотите создать новую сессию, вам нужно закрыть существующую.
- Создание новой сессии закроет существующую.
:::

---
#### `cleanup` {#cleanup}

Очистка ресурсов сессии с обработкой исключений.

Этот метод пытается закрыть сессию, подавляя любые исключения, которые могут возникнуть в процессе очистки. Он особенно полезен в сценариях обработки ошибок или когда вам нужно гарантировать, что очистка произойдет независимо от состояния сессии.

**Синтаксис**

```python
cleanup()
```

:::note
Этот метод никогда не вызовет исключения, что делает его безопасным для вызова в
блоках finally или деструкторах.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>> try:
...     session.query("INVALID SQL")
... finally:
...     session.cleanup()  # Safe cleanup regardless of errors
```

**Смотрите также**
- [`close()`](#chdb-session-session-close) - Для явного закрытия сессии с распространением ошибок

---
#### `close` {#close}

Закрыть сессию и очистить ресурсы.

Этот метод закрывает базовое соединение и сбрасывает глобальное состояние сессии. После вызова этого метода сессия становится недействительной и не может использоваться для дальнейших запросов.

**Синтаксис**

```python
close()
```

:::note
Этот метод автоматически вызывается, когда сессия используется как контекстный менеджер
или когда объект сессии уничтожается.
:::

:::warning Важно
Любая попытка использовать сессию после вызова `close()` приведет к ошибке.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>> session.query("SELECT 1")
>>> session.close()  # Explicitly close the session
```

---
#### `query` {#chdb-session-session-query}

Выполнить SQL-запрос и вернуть результаты.

Этот метод выполняет SQL-запрос к базе данных сессии и возвращает
результаты в указанном формате. Метод поддерживает различные форматы вывода
и поддерживает состояние сессии между запросами.

**Синтаксис**

```python
query(sql, fmt='CSV', udf_path='')
```

**Параметры**

| Параметр  | Тип   | По умолчанию | Описание                                                                                                                                                                                                                                                                                                                  |
|------------|-------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sql`      | str   | *обязательный* | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                                                                  |
| `fmt`      | str   | `"CSV"`      | Формат вывода для результатов. Доступные форматы:<br/>• `"CSV"` - Значения, разделенные запятыми<br/>• `"JSON"` - Формат JSON<br/>• `"TabSeparated"` - Значения, разделенные табуляцией<br/>• `"Pretty"` - Формат таблицы с красивым выводом<br/>• `"JSONCompact"` - Компактный формат JSON<br/>• `"Arrow"` - Формат Apache Arrow<br/>• `"Parquet"` - Формат Parquet |
| `udf_path` | str   | `""`         | Путь к пользовательским функциям. Если не указан, используется путь UDF из инициализации сессии                                                                                                                                                                                                                              |

**Возвращает**

Возвращает результаты запроса в указанном формате. Точный тип возврата зависит от параметра формата:
- Строковые форматы (CSV, JSON и др.) возвращают str
- Бинарные форматы (Arrow, Parquet) возвращают bytes

**Вызывает**

| Исключение      | Условие                           |
|----------------|-----------------------------------|
| `RuntimeError` | Если сессия закрыта или недействительна |
| `ValueError`   | Если SQL-запрос имеет неверный формат |

:::note
Формат “Debug” не поддерживается и будет автоматически преобразован
в “CSV” с предупреждением.
Для отладки используйте параметры строки соединения вместо этого.
:::

:::warning Внимание
Этот метод выполняет запрос синхронно и загружает все результаты в
память. Для больших наборов результатов рассмотрите возможность использования [`send_query()`](#chdb-session-session-send_query) для
потоковой передачи результатов.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>>
>>> # Basic query with default CSV format
>>> result = session.query("SELECT 1 as number")
>>> print(result)
number
1
```

```pycon
>>> # Query with JSON format
>>> result = session.query("SELECT 1 as number", fmt="JSON")
>>> print(result)
{"number": "1"}
```

```pycon
>>> # Complex query with table creation
>>> session.query("CREATE TABLE test (id INT, name String)")
>>> session.query("INSERT INTO test VALUES (1, 'Alice'), (2, 'Bob')")
>>> result = session.query("SELECT * FROM test ORDER BY id")
>>> print(result)
id,name
1,Alice
2,Bob
```

**Смотрите также**
- [`send_query()`](#chdb-session-session-send_query) - Для потокового выполнения запросов
- [`sql`](#chdb-session-session-sql) - Псевдоним для этого метода

---
#### `send_query` {#chdb-session-session-send_query}

Выполнить SQL-запрос и вернуть итератор потокового результата.

Этот метод выполняет SQL-запрос к базе данных сессии и возвращает
объект потокового результата, который позволяет вам перебирать результаты, не загружая их все в память сразу. Это особенно полезно для больших наборов результатов.

**Синтаксис**

```python
send_query(sql, fmt='CSV') → StreamingResult
```

**Параметры**

| Параметр  | Тип   | По умолчанию | Описание                                                                                                                                                                                                                                                                    |
|------------|-------|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sql`      | str   | *обязательный* | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                    |
| `fmt`      | str   | `"CSV"`      | Формат вывода для результатов. Доступные форматы:<br/>• `"CSV"` - Значения, разделенные запятыми<br/>• `"JSON"` - Формат JSON<br/>• `"TabSeparated"` - Значения, разделенные табуляцией<br/>• `"JSONCompact"` - Компактный формат JSON<br/>• `"Arrow"` - Формат Apache Arrow<br/>• `"Parquet"` - Формат Parquet |

**Возвращает**

| Тип возврата       | Описание                                                                                                                                      |
|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| `StreamingResult` | Итератор потокового результата, который последовательно выдает результаты запроса. Итератор можно использовать в циклах for или преобразовывать в другие структуры данных |

**Вызывает**

| Исключение      | Условие                           |
|----------------|-------------------------------------|
| `RuntimeError` | Если сессия закрыта или недействительна |
| `ValueError`   | Если SQL-запрос имеет неверный формат       |

:::note
Формат “Debug” не поддерживается и будет автоматически преобразован
в “CSV” с предупреждением. Для отладки используйте параметры строки соединения вместо этого.
:::

:::warning
Возвращаемый объект StreamingResult следует потреблять быстро или хранить соответствующим образом, так как он поддерживает соединение с базой данных.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>> session.query("CREATE TABLE big_table (id INT, data String)")
>>>
>>> # Insert large dataset
>>> for i in range(1000):
...     session.query(f"INSERT INTO big_table VALUES ({i}, 'data_{i}')")
>>>
>>> # Stream results to avoid memory issues
>>> streaming_result = session.send_query("SELECT * FROM big_table ORDER BY id")
>>> for chunk in streaming_result:
...     print(f"Processing chunk: {len(chunk)} bytes")
...     # Process chunk without loading entire result set
```

```pycon
>>> # Using with context manager
>>> with session.send_query("SELECT COUNT(*) FROM big_table") as stream:
...     for result in stream:
...         print(f"Count result: {result}")
```

**Смотрите также**
- [`query()`](#chdb-session-session-query) - Для выполнения запроса без потоковой передачи
- `chdb.state.sqlitelike.StreamingResult` - Итератор потокового результата

---
#### `sql` {#chdb-session-session-sql}

Выполнить SQL-запрос и вернуть результаты.

Этот метод выполняет SQL-запрос к базе данных сессии и возвращает
результаты в указанном формате. Метод поддерживает различные форматы вывода
и поддерживает состояние сессии между запросами.

**Синтаксис**

```python
sql(sql, fmt='CSV', udf_path='')
```

**Параметры**

| Параметр  | Тип   | По умолчанию | Описание                                                                                                                                                                                                                                                                                                                  |
|------------|-------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sql`      | str   | *обязательный* | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                                                                  |
| `fmt`      | str   | `"CSV"`      | Формат вывода для результатов. Доступные форматы:<br/>• `"CSV"` - Значения, разделенные запятыми<br/>• `"JSON"` - Формат JSON<br/>• `"TabSeparated"` - Значения, разделенные табуляцией<br/>• `"Pretty"` - Формат таблицы с красивым выводом<br/>• `"JSONCompact"` - Компактный формат JSON<br/>• `"Arrow"` - Формат Apache Arrow<br/>• `"Parquet"` - Формат Parquet |
| `udf_path` | str   | `""`         | Путь к пользовательским функциям. Если не указан, используется путь UDF из инициализации сессии                                                                                                                                                                                                                              |

**Возвращает**

Возвращает результаты запроса в указанном формате. Точный тип возврата зависит от параметра формата:
- Строковые форматы (CSV, JSON и др.) возвращают str
- Бинарные форматы (Arrow, Parquet) возвращают bytes

**Вызывает:**

| Исключение      | Условие                           |
|----------------|-------------------------------------|
| `RuntimeError` | Если сессия закрыта или недействительна |
| `ValueError`   | Если SQL-запрос имеет неверный формат       |

:::note
Формат “Debug” не поддерживается и будет автоматически преобразован
в “CSV” с предупреждением. Для отладки используйте параметры строки соединения
вместо этого.
:::

:::warning Внимание
Этот метод выполняет запрос синхронно и загружает все результаты в
память.
Для больших наборов результатов рассмотрите возможность использования [`send_query()`](#chdb-session-session-send_query) для потоковых результатов.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>>
>>> # Basic query with default CSV format
>>> result = session.query("SELECT 1 as number")
>>> print(result)
number
1
```

```pycon
>>> # Query with JSON format
>>> result = session.query("SELECT 1 as number", fmt="JSON")
>>> print(result)
{"number": "1"}
```

```pycon
>>> # Complex query with table creation
>>> session.query("CREATE TABLE test (id INT, name String)")
>>> session.query("INSERT INTO test VALUES (1, 'Alice'), (2, 'Bob')")
>>> result = session.query("SELECT * FROM test ORDER BY id")
>>> print(result)
id,name
1,Alice
2,Bob
```

**Смотрите также**
- [`send_query()`](#chdb-session-session-send_query) - Для потокового выполнения запросов
- [`sql`](#chdb-session-session-sql) - Псевдоним для этого метода
## Управление состоянием {#chdb-state-management}
### `chdb.state.connect` {#chdb_state_connect}

Создать [Соединение](#chdb-state-sqlitelike-connection) с фоновым сервером chDB.

Эта функция устанавливает соединение с движком базы данных chDB (ClickHouse). Разрешено только одно открытое соединение на процесс. Множественные вызовы с одной и той же строкой соединения будут возвращать один и тот же объект соединения.

**Синтаксис**

```python
chdb.state.connect(connection_string: str = ':memory:') → Connection
```

**Параметры**

| Параметр                          | Тип   | По умолчанию | Описание                                    |
|------------------------------------|-------|--------------|----------------------------------------------|
| `connection_string(str, optional)` | str   | `":memory:"` | Строка соединения с базой данных. См. форматы ниже. |

**Базовые форматы**

Поддерживаемые форматы строк соединения:

| Формат                    | Описание                  |
|---------------------------|---------------------------|
| `":memory:"`              | База данных в памяти (по умолчанию) |
| `"test.db"`               | Файл базы данных с относительным путем  |
| `"file:test.db"`          | То же самое, что и относительный путь  |
| `"/path/to/test.db"`      | Файл базы данных с абсолютным путем  |
| `"file:/path/to/test.db"` | То же самое, что и абсолютный путь  |

**С параметрами запроса**

| Формат                                             | Описание               |
|----------------------------------------------------|-----------------------|
| `"file:test.db?param1=value1&param2=value2"`       | Относительный путь с параметрами |
| `"file::memory:?verbose&log-level=test"`           | В памяти с параметрами     |
| `"///path/to/test.db?param1=value1&param2=value2"` | Абсолютный путь с параметрами |

**Обработка параметров запроса**

Параметры запроса передаются в движок ClickHouse в качестве аргументов при запуске. Специальная обработка параметров:

| Специальный параметр  | становится        | Описание             |
|------------------------|-------------------|---------------------|
| `mode=ro`              | `--readonly=1`     | Режим только для чтения |
| `verbose`              | (флаг)            | Включает детализированное логирование |
| `log-level=test`       | (настройка)       | Устанавливает уровень логирования |

Для полного списка параметров см. `clickhouse local --help --verbose`

**Возвращает**

| Тип возврата  | Описание                                                                                                                                                                                                                                        |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Connection`  | Объект соединения с базой данных, который поддерживает:<br/>• Создание курсоров с помощью `Connection.cursor()`<br/>• Прямые запросы с помощью `Connection.query()`<br/>• Потоковые запросы с помощью `Connection.send_query()`<br/>• Протокол контекстного менеджера для автоматической очистки |

**Вызывает**

| Исключение      | Условие                       |
|------------------|---------------------------------|
| `RuntimeError`   | Если соединение с базой данных не удалось |

:::warning Внимание
Поддерживается только одно соединение на процесс. Создание нового соединения закроет любое существующее соединение.
:::

**Примеры**

```pycon
>>> # In-memory database
>>> conn = connect()
>>> conn = connect(":memory:")
>>>
>>> # File-based database
>>> conn = connect("my_data.db")
>>> conn = connect("/path/to/data.db")
>>>
>>> # With parameters
>>> conn = connect("data.db?mode=ro")  # Read-only mode
>>> conn = connect(":memory:?verbose&log-level=debug")  # Debug logging
>>>
>>> # Using context manager for automatic cleanup
>>> with connect("data.db") as conn:
...     result = conn.query("SELECT 1")
...     print(result)
>>> # Connection automatically closed
```

**Смотрите также**
- `Connection` - Класс соединения с базой данных
- `Cursor` - Курсор базы данных для операций DB-API 2.0
### **class** `chdb.state.sqlitelike.Connection` {#chdb-state-sqlitelike-connection}

Базовый класс: `object`

**Синтаксис**

```python
class chdb.state.sqlitelike.Connection(connection_string: str)
```

---
#### `close` {#chdb-session-session-close}

Закрыть соединение и очистить ресурсы.

Этот метод закрывает соединение с базой данных и очищает все связанные ресурсы, включая активные курсоры. После вызова этого метода
соединение становится недействительным и не может использоваться для дальнейших операций.

**Синтаксис**

```python
close() → None
```

:::note
Этот метод идемпотентен - безопасно вызывать его несколько раз.
:::

:::warning Внимание
Любые текущие потоковые запросы будут отменены, когда соединение
закроется. Убедитесь, что все важные данные обработаны перед закрытием.
:::

**Примеры**

```pycon
>>> conn = connect("test.db")
>>> # Use connection for queries
>>> conn.query("CREATE TABLE test (id INT)")
>>> # Close when done
>>> conn.close()
```

```pycon
>>> # Using with context manager (automatic cleanup)
>>> with connect("test.db") as conn:
...     conn.query("SELECT 1")
...     # Connection automatically closed
```

---
#### `cursor` {#chdb-state-sqlitelike-connection-cursor}

Создайте объект [Cursor](#chdb-state-sqlitelike-cursor) для выполнения запросов.

Этот метод создает курсор базы данных, который предоставляет стандартный интерфейс DB-API 2.0 для выполнения запросов и получения результатов. Курсор позволяет осуществлять детальный контроль над выполнением запросов и получением результатов.

**Синтаксис**

```python
cursor() → Cursor
```

**Возвращает**

| Тип возвращаемого значения | Описание                                              |
|---------------------------|-------------------------------------------------------|
| `Cursor`                  | Объект курсора для операций с базой данных           |

:::note
Создание нового курсора заменит любой существующий курсор, связанный с этим соединением. Поддерживается только один курсор на соединение.
:::

**Примеры**

```pycon
>>> conn = connect(":memory:")
>>> cursor = conn.cursor()
>>> cursor.execute("CREATE TABLE test (id INT, name String)")
>>> cursor.execute("INSERT INTO test VALUES (1, 'Alice')")
>>> cursor.execute("SELECT * FROM test")
>>> rows = cursor.fetchall()
>>> print(rows)
((1, 'Alice'),)
```

**Смотрите также**
- [`Cursor`](#chdb-state-sqlitelike-cursor) - Реализация курсора базы данных

---
#### `query` {#chdb-state-sqlitelike-connection-query}

Выполните SQL-запрос и верните полные результаты.

Этот метод выполняет SQL-запрос синхронно и возвращает полный набор результатов. Он поддерживает различные форматы вывода и автоматически применяет постобработку в зависимости от формата.

**Синтаксис**

```python
query(query: str, format: str = 'CSV') → Any
```

**Параметры:**

| Параметр | Тип   | По умолчанию | Описание                                                                                                                                                                                                                                                                                   |
|-----------|-------|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `query`   | str   | *обязательный* | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                         |
| `format`  | str   | `"CSV"`      | Формат вывода для результатов. Поддерживаемые форматы:<br/>• `"CSV"` - Значения, разделенные запятыми (строка)<br/>• `"JSON"` - Формат JSON (строка)<br/>• `"Arrow"` - Формат Apache Arrow (байты)<br/>• `"Dataframe"` - Pandas DataFrame (требует pandas)<br/>• `"Arrowtable"` - PyArrow Table (требует pyarrow) |

**Возвращает**

| Тип возвращаемого значения      | Описание                             |
|----------------------------------|-------------------------------------|
| `str`                            | Для строковых форматов (CSV, JSON) |
| `bytes`                          | Для формата Arrow                   |
| `pandas.DataFrame`              | Для формата DataFrame               |
| `pyarrow.Table`                 | Для формата arrowtable              |

**Вызывает**

| Исключение      | Условие                                              |
|-----------------|-----------------------------------------------------|
| `RuntimeError`  | Если выполнение запроса завершилось неуспешно      |
| `ImportError`   | Если необходимые пакеты для формата не установлены  |

:::warning Внимание
Этот метод загружает весь набор результатов в память. Для больших результатов рассмотрите возможность использования [`send_query()`](#chdb-state-sqlitelike-connection-send_query) для потоковой передачи.
:::

**Примеры**

```pycon
>>> conn = connect(":memory:")
>>>
>>> # Basic CSV query
>>> result = conn.query("SELECT 1 as num, 'hello' as text")
>>> print(result)
num,text
1,hello
```

```pycon
>>> # DataFrame format
>>> df = conn.query("SELECT number FROM numbers(5)", "dataframe")
>>> print(df)
   number
0       0
1       1
2       2
3       3
4       4
```

**Смотрите также**
- [`send_query()`](#chdb-state-sqlitelike-connection-send_query) - Для потокового выполнения запросов

---
#### `send_query` {#chdb-state-sqlitelike-connection-send_query}

Выполните SQL-запрос и верните итератор потоковых результатов.

Этот метод выполняет SQL-запрос и возвращает объект StreamingResult, который позволяет итеративно обрабатывать результаты без загрузки всего набора результатов в память сразу. Это идеально подходит для обработки больших наборов данных.

**Синтаксис**

```python
send_query(query: str, format: str = 'CSV') → StreamingResult
```

**Параметры**

| Параметр  | Тип  | По умолчанию | Описание                                                                                                                                                                                                                                                                  |
|------------|-------|---------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `query`    | str   | *обязательный* | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                  |
| `format`   | str   | `"CSV"`       | Формат вывода для результатов. Поддерживаемые форматы:<br/>• `"CSV"` - Значения, разделенные запятыми<br/>• `"JSON"` - Формат JSON<br/>• `"Arrow"` - Формат Apache Arrow (включает метод record_batch())<br/>• `"dataframe"` - Части DataFrame Pandas<br/>• `"arrowtable"` - Части таблицы PyArrow |

**Возвращает**

| Тип возвращаемого значения       | Описание                                                                                                                                                                                                                              |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `StreamingResult`                | Итератор потоковых результатов для запросов, который поддерживает:<br/>• Протокол итераторов (for циклы)<br/>• Протокол менеджера контекста (with операторы)<br/>• Ручное извлечение с помощью метода fetch()<br/>• Потоковая передача PyArrow RecordBatch (только формат Arrow) |

**Вызывает**

| Исключение      | Условие                                         |
|-----------------|---------------------------------------------------|
| `RuntimeError`  | Если выполнение запроса завершилось неуспешно      |
| `ImportError`   | Если необходимые пакеты для формата не установлены  |

:::note
Только формат “Arrow” поддерживает метод `record_batch()` на возвращенном StreamingResult.
:::

**Примеры**

```pycon
>>> conn = connect(":memory:")
>>>
>>> # Basic streaming
>>> stream = conn.send_query("SELECT number FROM numbers(1000)")
>>> for chunk in stream:
...     print(f"Processing chunk: {len(chunk)} bytes")
```

```pycon
>>> # Using context manager for cleanup
>>> with conn.send_query("SELECT * FROM large_table") as stream:
...     chunk = stream.fetch()
...     while chunk:
...         process_data(chunk)
...         chunk = stream.fetch()
```

```pycon
>>> # Arrow format with RecordBatch streaming
>>> stream = conn.send_query("SELECT * FROM data", "Arrow")
>>> reader = stream.record_batch(rows_per_batch=10000)
>>> for batch in reader:
...     print(f"Batch shape: {batch.num_rows} x {batch.num_columns}")
```

**Смотрите также**
- [`query()`](#chdb-state-sqlitelike-connection-query) - Для не потокового выполнения запросов
- `StreamingResult` - Итератор потоковых результатов

---
### **class** `chdb.state.sqlitelike.Cursor` {#chdb-state-sqlitelike-cursor}

Основы: `object`

```python
class chdb.state.sqlitelike.Cursor(connection)
```

---
#### `close` {#cursor-close-none}

Закройте курсор и очистите ресурсы.

Этот метод закрывает курсор и очищает все связанные ресурсы. После вызова этого метода курсор становится недействительным и не может использоваться для дальнейших операций.

**Синтаксис**

```python
close() → None
```

:::note
Этот метод идемпотентен - безопасно вызывать его несколько раз. Курсор также автоматически закрывается при закрытии соединения.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT 1")
>>> result = cursor.fetchone()
>>> cursor.close()  # Cleanup cursor resources
```

---
#### `column_names` {#chdb-state-sqlitelike-cursor-column_names}

Верните список имен колонок из последнего выполненного запроса.

Этот метод возвращает имена колонок из последнего выполненного запроса SELECT. Имена возвращаются в том же порядке, в котором они появляются в наборе результатов.

**Синтаксис**

```python
column_names() → list
```

**Возвращает**

| Тип возвращаемого значения | Описание                                                                                               |
|---------------------------|-----------------------------------------------------------------------------------------------------------|
| `list`                    | Список строк имен колонок, или пустой список, если запрос не был выполнен или запрос не вернул колонок |

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT id, name, email FROM users LIMIT 1")
>>> print(cursor.column_names())
['id', 'name', 'email']
```

**Смотрите также**
- [`column_types()`](#chdb-state-sqlitelike-cursor-column_types) - Получить информацию о типе колонок
- [`description`](#chdb-state-sqlitelike-cursor-description) - Описание колонок DB-API 2.0

---
#### `column_types` {#chdb-state-sqlitelike-cursor-column_types}

Верните список типов колонок из последнего выполненного запроса.

Этот метод возвращает имена типов колонок ClickHouse из последнего выполненного запроса SELECT. Типы возвращаются в том же порядке, в котором они появляются в наборе результатов.

**Синтаксис**

```python
column_types() → list
```

**Возвращает**

| Тип возвращаемого значения | Описание |
|---------------------------|-------------|
| `list`                    | Список строк имен типов ClickHouse, или пустой список, если запрос не был выполнен или запрос не вернул колонок |

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT toInt32(1), toString('hello')")
>>> print(cursor.column_types())
['Int32', 'String']
```

**Смотрите также**
- [`column_names()`](#chdb-state-sqlitelike-cursor-column_names) - Получить информацию о именах колонок
- [`description`](#chdb-state-sqlitelike-cursor-description) - Описание колонок DB-API 2.0

---
#### `commit` {#commit}

Зафиксировать любые незавершенные транзакции.

Этот метод фиксирует любые незавершенные транзакции базы данных. В ClickHouse большинство операций автоматически фиксируются, но этот метод предоставлен для совместимости с DB-API 2.0.

:::note
ClickHouse обычно автоматически фиксирует операции, поэтому явные фиксации обычно не нужны. Этот метод предоставлен для совместимости со стандартным рабочим процессом DB-API 2.0.
:::

**Синтаксис**

```python
commit() → None
```

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("INSERT INTO test VALUES (1, 'data')")
>>> cursor.commit()
```

---
#### `property description : list` {#chdb-state-sqlitelike-cursor-description}

Вернуть описание колонки в соответствии со спецификацией DB-API 2.0.

Это свойство возвращает список кортежей из 7 элементов, описывающих каждую колонку в наборе результатов последнего выполненного запроса SELECT. Каждый кортеж содержит: (name, type_code, display_size, internal_size, precision, scale, null_ok)

В настоящее время предоставляются только name и type_code, остальные поля установлены в None.

**Возвращает**

| Тип возвращаемого значения | Описание |
|---------------------------|-------------|
| `list`                    | Список кортежей из 7 элементов, описывающих каждую колонку, или пустой список, если запрос SELECT не был выполнен |

:::note
Это соответствует спецификации DB-API 2.0 для cursor.description. Только первые два элемента (name и type_code) содержат значимую информацию в этой реализации.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT id, name FROM users LIMIT 1")
>>> for desc in cursor.description:
...     print(f"Column: {desc[0]}, Type: {desc[1]}")
Column: id, Type: Int32
Column: name, Type: String
```

**Смотрите также**
- [`column_names()`](#chdb-state-sqlitelike-cursor-column_names) - Получить только имена колонок
- [`column_types()`](#chdb-state-sqlitelike-cursor-column_types) - Получить только типы колонок

---
#### `execute` {#execute}

Выполните SQL-запрос и подготовьте результаты для извлечения.

Этот метод выполняет SQL-запрос и подготавливает результаты для извлечения с помощью методов извлечения. Он обрабатывает анализ данных результата и автоматическое преобразование типов для типов данных ClickHouse.

**Синтаксис**

```python
execute(query: str) → None
```

**Параметры:**

| Параметр | Тип   | Описание                  |
|-----------|-------|-----------------------------|
| `query`   | str   | Строка SQL-запроса для выполнения |

**Вызывает**

| Исключение | Условие |
|------------|-----------|
| `Exception` | Если выполнение запроса не удалось или возникла ошибка при разборе результата |

:::note
Этот метод следует спецификациям DB-API 2.0 для `cursor.execute()`. После выполнения используйте `fetchone()`, `fetchmany()` или `fetchall()` для извлечения результатов.
:::

:::note
Метод автоматически преобразует типы данных ClickHouse в соответствующие типы Python:

- Int/UInt типы → int
- Float типы → float
- String/FixedString → str
- DateTime → datetime.datetime
- Date → datetime.date
- Bool → bool
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>>
>>> # Execute DDL
>>> cursor.execute("CREATE TABLE test (id INT, name String)")
>>>
>>> # Execute DML
>>> cursor.execute("INSERT INTO test VALUES (1, 'Alice')")
>>>
>>> # Execute SELECT and fetch results
>>> cursor.execute("SELECT * FROM test")
>>> rows = cursor.fetchall()
>>> print(rows)
((1, 'Alice'),)
```

**Смотрите также**
- [`fetchone()`](#chdb-state-sqlitelike-cursor-fetchone) - Извлечь одну строку
- [`fetchmany()`](#chdb-state-sqlitelike-cursor-fetchmany) - Извлечь несколько строк
- [`fetchall()`](#chdb-state-sqlitelike-cursor-fetchall) - Извлечь все оставшиеся строки

---
#### `fetchall` {#chdb-state-sqlitelike-cursor-fetchall}

Извлечь все оставшиеся строки из результата запроса.

Этот метод извлекает все оставшиеся строки из текущего набора результатов запроса, начиная с текущей позиции курсора. Он возвращает кортеж кортежей строк с применением соответствующего преобразования типов Python.

**Синтаксис**

```python
fetchall() → tuple
```

**Возвращает:**

| Тип возвращаемого значения | Описание |
|---------------------------|-------------|
| `tuple`                    | Кортеж, содержащий все оставшиеся кортежи строк из набора результатов. Возвращает пустой кортеж, если нет доступных строк |

:::warning Внимание
Этот метод загружает все оставшиеся строки в память сразу. Для больших наборов результатов рассмотрите возможность использования [`fetchmany()`](#chdb-state-sqlitelike-cursor-fetchmany) для обработки результатов партиями.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT id, name FROM users")
>>> all_users = cursor.fetchall()
>>> for user_id, user_name in all_users:
...     print(f"User {user_id}: {user_name}")
```

**Смотрите также**
- [`fetchone()`](#chdb-state-sqlitelike-cursor-fetchone) - Извлечь одну строку
- [`fetchmany()`](#chdb-state-sqlitelike-cursor-fetchmany) - Извлечь несколько строк партиями

---
#### `fetchmany` {#chdb-state-sqlitelike-cursor-fetchmany}

Извлечь несколько строк из результата запроса.

Этот метод извлекает до ‘size’ строк из текущего набора результатов запроса. Он возвращает кортеж кортежей строк, каждая из которых содержит значения колонок с соответствующим преобразованием типов Python.

**Синтаксис**

```python
fetchmany(size: int = 1) → tuple
```

**Параметры**

| Параметр | Тип | По умолчанию | Описание |
|-----------|------|---------------|-------------|
| `size`    | int  | `1`         | Максимальное количество строк для извлечения |

**Возвращает**

| Тип возвращаемого значения | Описание                                                                                     |
|---------------------------|-------------------------------------------------------------------------------------------------|
| `tuple`                   | Кортеж с до ‘size’ кортежами строк. Может содержать меньше строк, если набор результатов исчерпан |

:::note
Этот метод соответствует спецификациям DB-API 2.0. Он вернет меньше, чем ‘size’ строк, если набор результатов исчерпан.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT * FROM large_table")
>>>
>>> # Process results in batches
>>> while True:
...     batch = cursor.fetchmany(100)  # Fetch 100 rows at a time
...     if not batch:
...         break
...     process_batch(batch)
```

**Смотрите также**
- [`fetchone()`](#chdb-state-sqlitelike-cursor-fetchone) - Извлечь одну строку
- [`fetchall()`](#chdb-state-sqlitelike-cursor-fetchall) - Извлечь все оставшиеся строки

---
#### `fetchone` {#chdb-state-sqlitelike-cursor-fetchone}

Извлечь следующую строку из результата запроса.

Этот метод извлекает следующую доступную строку из текущего набора результатов запроса. Он возвращает кортеж, содержащий значения колонок с соответствующим преобразованием типов Python.

**Синтаксис** 

```python
fetchone() → tuple | None
```

**Возвращает:**

| Тип возвращаемого значения  | Описание                                                                 |
|----------------------------|-----------------------------------------------------------------------------|
| `Optional[tuple]`          | Следующая строка в виде кортежа значений колонок, или None, если больше строк нет |

:::note
Этот метод соответствует спецификациям DB-API 2.0. Значения колонок автоматически преобразуются в соответствующие типы Python на основе типов колонок ClickHouse.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT id, name FROM users")
>>> row = cursor.fetchone()
>>> while row is not None:
...     user_id, user_name = row
...     print(f"User {user_id}: {user_name}")
...     row = cursor.fetchone()
```

**Смотрите также**
- [`fetchmany()`](#chdb-state-sqlitelike-cursor-fetchmany) - Извлечь несколько строк
- [`fetchall()`](#chdb-state-sqlitelike-cursor-fetchall) - Извлечь все оставшиеся строки

---
### `chdb.state.sqlitelike` {#state-sqlitelike-to_arrowtable}

Конвертировать результат запроса в таблицу PyArrow.

Эта функция конвертирует результаты запроса chdb в формат таблицы PyArrow, который предоставляет эффективный доступ к колонным данным и совместимость с другими библиотеками обработки данных.

**Синтаксис**

```python
chdb.state.sqlitelike.to_arrowTable(res)
```

**Параметры:**

| Параметр  | Тип  | Описание                                                |
|------------|-------|------------------------------------------------------------|
| `res`      | -     | Объект результата запроса от chdb, содержащий данные в формате Arrow |

**Возвращает**

| Тип возвращаемого значения     | Описание                                |
|-------------------------------|--------------------------------------------|
| `pyarrow.Table`               | Таблица PyArrow, содержащая результаты запроса |

**Вызывает**

| Исключение     | Условие                                       |
|-----------------|-------------------------------------------------|
| `ImportError`    | Если пакеты pyarrow или pandas не установлены |

:::note
Эта функция требует, чтобы pyarrow и pandas были установлены. Установите их с помощью: `pip install pyarrow pandas`
:::

:::warning Внимание
Пустые результаты возвращают пустую таблицу PyArrow без схемы.
:::

**Примеры**

```pycon
>>> import chdb
>>> result = chdb.query("SELECT 1 as num, 'hello' as text", "Arrow")
>>> table = to_arrowTable(result)
>>> print(table.schema)
num: int64
text: string
>>> print(table.to_pandas())
   num   text
0    1  hello
```

---
### `chdb.state.sqlitelike.to_df` {#state-sqlitelike-to_df}

Конвертировать результат запроса в Pandas DataFrame.

Эта функция конвертирует результаты запроса chdb в формат Pandas DataFrame, сначала конвертируя в таблицу PyArrow, а затем в DataFrame. Это предоставляет удобные возможности для анализа данных с API Pandas.

**Синтаксис**

```python
chdb.state.sqlitelike.to_df(r)
```

**Параметры:**

| Параметр  | Тип  | Описание                                                |
|------------|-------|------------------------------------------------------------|
| `r`        | -     | Объект результата запроса от chdb, содержащий данные в формате Arrow |

**Возвращает:**

| Тип возвращаемого значения        | Описание                                                                         |
|-----------------------------------|-------------------------------------------------------------------------------------|
| `pandas.DataFrame`                | DataFrame, содержащий результаты запроса с соответствующими именами колонок и типами данных |

**Вызывает**

| Исключение     | Условие                                       |
|-----------------|-------------------------------------------------|
| `ImportError`   | Если пакеты pyarrow или pandas не установлены |

:::note
Эта функция использует многопоточность для конвертации Arrow в Pandas для повышения производительности на больших наборах данных.
:::

**Смотрите также**
- [`to_arrowTable()`](#chdb-state-sqlitelike-to_arrowtable) - Для конвертации в формат таблицы PyArrow

**Примеры**

```pycon
>>> import chdb
>>> result = chdb.query("SELECT 1 as num, 'hello' as text", "Arrow")
>>> df = to_df(result)
>>> print(df)
   num   text
0    1  hello
>>> print(df.dtypes)
num      int64
text    object
dtype: object
```
## Интеграция DataFrame {#dataframe-integration}
### **class** `chdb.dataframe.Table` {#chdb-dataframe-table}

Основы:

```python
class chdb.dataframe.Table(*args: Any, **kwargs: Any)
```
## Интерфейс API баз данных (DBAPI) 2.0 {#database-api-interface}

chDB предоставляет совместимый с Python интерфейс DB-API 2.0 для подключения к базе данных, позволяя использовать chDB с инструментами и фреймворками, которые ожидают стандартные интерфейсы базы данных.

Интерфейс DB-API 2.0 chDB включает:

- **Соединения**: Управление подключением к базе данных с помощью строк подключения
- **Курсоры**: Выполнение запросов и получение результатов
- **Система типов**: Константы и конвертеры типов, совместимые с DB-API 2.0
- **Обработка ошибок**: Стандартная иерархия исключений базы данных
- **Безопасность потоков**: Уровень 1 безопасности потоков (потоки могут совместно использовать модули, но не соединения)

---
### Основные функции {#core-functions}

Интерфейс API баз данных (DBAPI) 2.0 реализует следующие основные функции:
#### `chdb.dbapi.connect` {#dbapi-connect}

Инициализируйте новое соединение с базой данных.

**Синтаксис**

```python
chdb.dbapi.connect(*args, **kwargs)
```

**Параметры**

| Параметр  | Тип   | По умолчанию | Описание                                     |
|------------|-------|--------------|-------------------------------------------------|
| `path`     | str   | `None`       | Путь к файлу базы данных. None для базы данных в памяти |

**Вызывает**

| Исключение                            | Условие                           |
|--------------------------------------|-------------------------------------|
| [`err.Error`](#chdb-dbapi-err-error) | Если соединение не может быть установлено |

---
#### `chdb.dbapi.get_client_info()` {#dbapi-get-client-info}

Получить информацию о версии клиента.

Возвращает строку с версией клиента chDB для совместимости с MySQLdb.

**Синтаксис**

```python
chdb.dbapi.get_client_info()
```

**Возвращает**

| Тип возвращаемого значения | Описание                                  |
|---------------------------|----------------------------------------------|
| `str`                     | Строка версии в формате 'major.minor.patch' |

---
### Конструкторы типов {#type-constructors}
#### `chdb.dbapi.Binary(x)` {#dbapi-binary}

Вернуть x в виде двоичного типа.

Эта функция конвертирует входные данные в тип bytes для использования с двоичными полями базы данных, следуя спецификации DB-API 2.0.

**Синтаксис**

```python
chdb.dbapi.Binary(x)
```

**Параметры**

| Параметр  | Тип  | Описание                     |
|------------|-------|---------------------------------|
| `x`        | -     | Входные данные для конвертации в двоичный формат |

**Возвращает**

| Тип возвращаемого значения | Описание                  |
|---------------------------|------------------------------|
| `bytes`                   | Входные данные, конвертированные в bytes |

---
### Класс соединения {#connection-class}
#### **class** `chdb.dbapi.connections.Connection(path=None)` {#chdb-dbapi-connections-connection}

Основы: `object`

Соединение, соответствующее DB-API 2.0, с базой данных chDB.

Этот класс предоставляет стандартный интерфейс DB-API для подключения и взаимодействия с базами данных chDB. Он поддерживает как базы данных в памяти, так и основанные на файлах.

Соединение управляет движком chDB и предоставляет методы для выполнения запросов, управления транзакциями (нет операций для ClickHouse) и создания курсоров.

```python
class chdb.dbapi.connections.Connection(path=None)
```

**Параметры**

| Параметр  | Тип   | По умолчанию | Описание                                                                                                        |
|------------|-------|--------------|--------------------------------------------------------------------------------------------------------------------|
| `path`     | str   | `None`       | Путь к файлу базы данных. Если None, используется база данных в памяти. Может быть путь к файлу, например 'database.db', или None для ':memory:' |

**Переменные**

| Переменная | Тип   | Описание                                        |
|------------|-------|----------------------------------------------------|
| `encoding` | str   | Кодировка символов для запросов, по умолчанию 'utf8' |
| `open`     | bool  | True, если соединение открыто, False, если закрыто        |

**Примеры**

```pycon
>>> # In-memory database
>>> conn = Connection()
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT 1")
>>> result = cursor.fetchall()
>>> conn.close()
```

```pycon
>>> # File-based database
>>> conn = Connection('mydata.db')
>>> with conn.cursor() as cur:
...     cur.execute("CREATE TABLE users (id INT, name STRING)")
...     cur.execute("INSERT INTO users VALUES (1, 'Alice')")
>>> conn.close()
```

```pycon
>>> # Context manager usage
>>> with Connection() as cur:
...     cur.execute("SELECT version()")
...     version = cur.fetchone()
```

:::note
ClickHouse не поддерживает традиционные транзакции, поэтому операции commit() и rollback() не выполняют никаких действий, но предоставлены для соблюдения спецификации DB-API.
:::

---
#### `close` {#dbapi-connection-close}

Закрыть соединение с базой данных.

Закрывает внутреннее соединение chDB и помечает это соединение как закрытое. Последующие операции с этим соединением приведут к возникновению ошибки.

**Синтаксис**

```python
close()
```

**Вызывает**

| Исключение                            | Условие                       |
|--------------------------------------|---------------------------------|
| [`err.Error`](#chdb-dbapi-err-error) | Если соединение уже закрыто |

---
#### `commit` {#dbapi-commit}

Зафиксировать текущую транзакцию.

**Синтаксис**

```python
commit()
```

:::note
Это не выполняет никаких действий для chDB/ClickHouse, так как он не поддерживает традиционные транзакции. Предоставлено для соблюдения спецификации DB-API 2.0.
:::

---
#### `cursor` {#dbapi-cursor}

Создайте новый курсор для выполнения запросов.

**Синтаксис**

```python
cursor(cursor=None)
```

**Параметры**

| Параметр  | Тип  | Описание                         |
|------------|-------|-------------------------------------|
| `cursor`   | -     | Игнорируется, предоставлено для совместимости |

**Возвращает**

| Тип возвращаемого значения | Описание                           |
|---------------------------|---------------------------------------|
| `Cursor`                  | Новый объект курсора для этого соединения |

**Вызывает**

| Исключение                            | Условие               |
|--------------------------------------|-------------------------|
| [`err.Error`](#chdb-dbapi-err-error) | Если соединение закрыто |

**Пример**

```pycon
>>> conn = Connection()
>>> cur = conn.cursor()
>>> cur.execute("SELECT 1")
>>> result = cur.fetchone()
```

---
#### `escape` {#escape}

Экранировать значение для безопасного включения в SQL-запросы.

**Синтаксис**

```python
escape(obj, mapping=None)
```

**Параметры**

| Параметр  | Тип  | Описание                                   |
|------------|-------|-----------------------------------------------|
| `obj`      | -     | Значение для экранирования (строка, байты, число и т. д.) |
| `mapping`  | -     | Необратимое сопоставление символов для экранирования       |

**Возвращает**

| Тип возвращаемого значения | Описание                                           |
|---------------------------|-------------------------------------------------------|
| -                         | Эскейпированная версия ввода, подходящая для SQL-запросов |

**Пример**

```pycon
>>> conn = Connection()
>>> safe_value = conn.escape("O'Reilly")
>>> query = f"SELECT * FROM users WHERE name = {safe_value}"
```

---
#### `escape_string` {#escape-string}

Экранировать строковое значение для SQL-запросов.

**Синтаксис**

```python
escape_string(s)
```

**Параметры**

| Параметр  | Тип  | Описание      |
|------------|-------|------------------|
| `s`        | str   | Строка для экранирования |

**Возвращает**

| Тип возвращаемого значения | Описание                           |
|---------------------------|---------------------------------------|
| `str`                     | Эскейпированная строка, безопасная для включения в SQL |

---
#### `property open` {#property-open}

Проверить, открыто ли соединение.

**Возвращает**

| Тип возвращаемого значения | Описание                                 |
|---------------------------|---------------------------------------------|
| `bool`                    | True, если соединение открыто, False, если закрыто |

---
#### `query` {#dbapi-query}

Выполните SQL-запрос напрямую и верните необработанные результаты.

Этот метод обходит интерфейс курсоров и выполняет запросы напрямую. Для стандартного использования DB-API предпочтительно использовать метод cursor().
  
**Синтаксис**

```python
query(sql, fmt='CSV')
```

**Параметры:**

| Параметр  | Тип          | По умолчанию | Описание                                                                      |
|------------|--------------|--------------|----------------------------------------------------------------------------------|
| `sql`      | str или bytes | *обязательный* | SQL-запрос, который нужно выполнить                                           |
| `fmt`      | str          | `"CSV"`      | Формат вывода. Поддерживаемые форматы включают "CSV", "JSON", "Arrow", "Parquet" и т. д. |

**Возвращает**

| Тип возвращаемого значения | Описание                          |
|---------------------------|--------------------------------------|
| -                         | Результат запроса в указанном формате |

**Вызывает**

| Исключение                                              | Условие                              |
|--------------------------------------------------------|----------------------------------------|
| [`err.InterfaceError`](#chdb-dbapi-err-interfaceerror) | Если соединение закрыто или запрос завершился неуспешно |

**Пример**

```pycon
>>> conn = Connection()
>>> result = conn.query("SELECT 1, 'hello'", "CSV")
>>> print(result)
"1,hello\n"
```

---
#### `property resp` {#property-resp}

Получить последний ответ запроса.

**Возвращает**

| Тип возвращаемого значения | Описание                                 |
|---------------------------|---------------------------------------------|
| -                         | Необработанный ответ от последнего вызова query() |

:::note
Это свойство обновляется каждый раз, когда прямой вызов query(). Оно не отражает запросы, выполненные через курсоры. 
:::

---
#### `rollback` {#rollback}

Отменить текущую транзакцию.

**Синтаксис**

```python
rollback()
```

:::note
Это не выполняет никаких действий для chDB/ClickHouse, так как он не поддерживает традиционные транзакции. Предоставлено для соблюдения спецификации DB-API 2.0.
:::

---
### Класс курсора {#cursor-class}
#### **class** `chdb.dbapi.cursors.Cursor` {#chdb-dbapi-cursors-cursor}

Основы: `object`

Курсор DB-API 2.0 для выполнения запросов и получения результатов.

Курсор предоставляет методы для выполнения SQL-операторов, управления результатами запросов и навигации по наборам результатов. Он поддерживает привязку параметров, массовые операции и соблюдает спецификации DB-API 2.0.

Не создавайте экземпляры Cursor напрямую. Вместо этого используйте `Connection.cursor()`.

```python
class chdb.dbapi.cursors.Cursor(connection)
```

| Переменная          | Тип  | Описание                                                 |
|-------------------|-------|-------------------------------------------------------------|
| `description`     | tuple | Метаданные колонок для последнего результата запроса                   |
| `rowcount`        | int   | Количество строк, затронутых последним запросом (-1, если неизвестно)   |
| `arraysize`       | int   | Общее количество строк, которые нужно извлекать за раз (по умолчанию: 1)        |
| `lastrowid`       | -     | ID последней вставленной строки (если применимо)                 |
| `max_stmt_length` | int   | Максимальный размер оператора для executemany() (по умолчанию: 1024000) |

**Примеры**

```pycon
>>> conn = Connection()
>>> cur = conn.cursor()
>>> cur.execute("SELECT 1 as id, 'test' as name")
>>> result = cur.fetchone()
>>> print(result)  # (1, 'test')
>>> cur.close()
```

:::note
Смотрите [DB-API 2.0 Cursor Objects](https://www.python.org/dev/peps/pep-0249/#cursor-objects) для полного описания спецификации.
:::

---
#### `callproc` {#callproc}

Выполните хранимую процедуру (реализация-заглушка).

**Синтаксис**

```python
callproc(procname, args=())
```

**Параметры**

| Параметр  | Тип      | Описание                         |
|------------|----------|-------------------------------------|
| `procname` | str      | Имя хранимой процедуры для выполнения |
| `args`     | последовательность | Параметры для передачи в процедуру |

**Возвращает**

| Тип возвращаемого значения  | Описание                              |
|-----------------------------|------------------------------------------|
| `sequence`                  | Оригинальный параметр args (без изменений) |

:::note
chDB/ClickHouse не поддерживает хранимые процедуры в традиционном понимании. Этот метод предоставлен для совместимости с DB-API 2.0, но не выполняет никаких реальных операций. Используйте execute() для всех SQL-операций.
:::

:::warning Совместимость
Это реализация-заглушка. Традиционные функции хранимых процедур, такие как параметры OUT/INOUT, многократные наборы результатов и переменные сервера, не поддерживаются движком ClickHouse.
:::

---
#### `close` {#dbapi-cursor-close}

Закройте курсор и освободите связанные ресурсы.

После закрытия курсор становится непригодным для использования, и любая операция вызовет исключение. Закрытие курсора исчерпывает все оставшиеся данные и освобождает underlying cursor.

**Синтаксис**

```python
close()
```


#### `execute` {#dbapi-execute}

Выполнить SQL-запрос с необязательной привязкой параметров.

Этот метод выполняет одиночное SQL-выражение с возможной подстановкой параметров. Он поддерживает несколько стилей замены параметров для гибкости.

**Синтаксис**

```python
execute(query, args=None)
```

**Параметры**

| Параметр  | Тип            | По умолчанию | Описание                         |
|------------|-----------------|--------------|----------------------------------|
| `query`    | str             | *обязательно* | SQL-запрос для выполнения        |
| `args`     | tuple/list/dict | `None`      | Параметры, которые будут привязаны к заполнителям |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                      |
|----------------------------|-----------------------------------------------|
| `int`                      | Количество затронутых строк (-1, если неизвестно) |

**Стили параметров**

| Стиль                  | Пример                                          |
|------------------------|-------------------------------------------------|
| Стиль вопросительного знака | `"SELECT * FROM users WHERE id = ?"`             |
| Именованный стиль       | `"SELECT * FROM users WHERE name = %(name)s"`   |
| Стиль форматирования    | `"SELECT * FROM users WHERE age = %s"` (устаревший) |

**Примеры**

```pycon
>>> # Question mark parameters
>>> cur.execute("SELECT * FROM users WHERE id = ? AND age > ?", (123, 18))
>>>
>>> # Named parameters
>>> cur.execute("SELECT * FROM users WHERE name = %(name)s", {'name': 'Alice'})
>>>
>>> # No parameters
>>> cur.execute("SELECT COUNT(*) FROM users")
```

**Исключения**

| Исключение                                              | Условие                                  |
|--------------------------------------------------------|------------------------------------------|
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Если курсор закрыт или запрос неверен   |
| [`InterfaceError`](#chdb-dbapi-err-interfaceerror)     | Если происходит ошибка базы данных во время выполнения |

---
#### `executemany(query, args)` {#chdb-dbapi-cursors-cursor-executemany}

Выполнить запрос несколько раз с разными наборами параметров.

Этот метод эффективно выполняет один и тот же SQL-запрос несколько раз с различными значениями параметров. Это особенно полезно для массовых операций вставки.

**Синтаксис**

```python
executemany(query, args)
```

**Параметры**

| Параметр  | Тип     | Описание                                                   |
|------------|----------|-----------------------------------------------------------|
| `query`    | str      | SQL-запрос для многократного выполнения                   |
| `args`     | последовательность | Последовательность кортежей/словарей/списков параметров для каждого выполнения |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                         |
|----------------------------|-------------------------------------------------|
| `int`                      | Общее количество затронутых строк во всех выполнениях |

**Примеры**

```pycon
>>> # Bulk insert with question mark parameters
>>> users_data = [(1, 'Alice'), (2, 'Bob'), (3, 'Charlie')]
>>> cur.executemany("INSERT INTO users VALUES (?, ?)", users_data)
>>>
>>> # Bulk insert with named parameters
>>> users_data = [
...     {'id': 1, 'name': 'Alice'},
...     {'id': 2, 'name': 'Bob'}
... ]
>>> cur.executemany(
...     "INSERT INTO users VALUES (%(id)s, %(name)s)",
...     users_data
... )
```

:::note
Этот метод улучшает производительность для многорядных операций INSERT и UPDATE, оптимизируя процесс выполнения запросов.
:::

---
#### `fetchall()` {#dbapi-fetchall}

Получить все оставшиеся строки из результата запроса.

**Синтаксис**

```python
fetchall()
```

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                 |
|----------------------------|------------------------------------------|
| `list`                     | Список кортежей, представляющих все оставшиеся строки |

**Исключения**

| Исключение                                              | Условие                               |
|--------------------------------------------------------|---------------------------------------|
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Если `execute()` не был вызван первым |

:::warning Предупреждение
Этот метод может потреблять большие объемы памяти для крупных наборов результатов. 
Рекомендуется использовать `fetchmany()` для больших наборов данных.
:::

**Пример**

```pycon
>>> cursor.execute("SELECT id, name FROM users")
>>> all_rows = cursor.fetchall()
>>> print(len(all_rows))  # Number of total rows
```

---
#### `fetchmany` {#dbapi-fetchmany}

Получить несколько строк из результата запроса.

**Синтаксис**

```python
fetchmany(size=1)
```

**Параметры**

| Параметр  | Тип  | По умолчанию | Описание                                                       |
|------------|-------|--------------|---------------------------------------------------------------|
| `size`     | int   | `1`          | Количество строк для получения. Если не указано, используется cursor.arraysize |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                   |
|----------------------------|-------------------------------------------|
| `list`                     | Список кортежей, представляющих полученные строки |

**Исключения**

| Исключение                                              | Условие                               |
|--------------------------------------------------------|---------------------------------------|
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Если `execute()` не был вызван первым |

**Пример**

```pycon
>>> cursor.execute("SELECT id, name FROM users")
>>> rows = cursor.fetchmany(3)
>>> print(rows)  # [(1, 'Alice'), (2, 'Bob'), (3, 'Charlie')]
```

---
#### `fetchone` {#dbapi-fetchone}

Получить следующую строку из результата запроса.

**Синтаксис**

```python
fetchone()
```

**Возвращаемое значение**

| Тип возвращаемого значения  | Описание                                           |
|------------------------------|----------------------------------------------------|
| `tuple or None`             | Следующая строка в виде кортежа или None, если больше нет строк |

**Исключения**

| Исключение                                              | Условие                               |
|--------------------------------------------------------|---------------------------------------|
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Если `execute()` не был вызван первым |

**Пример**

```pycon
>>> cursor.execute("SELECT id, name FROM users LIMIT 3")
>>> row = cursor.fetchone()
>>> print(row)  # (1, 'Alice')
>>> row = cursor.fetchone()
>>> print(row)  # (2, 'Bob')
```

---
#### `max_stmt_length = 1024000` {#max-stmt-length}

Максимальный размер запроса, который генерирует [`executemany()`](#chdb-dbapi-cursors-cursor-executemany).

Значение по умолчанию — 1024000.

---
#### `mogrify` {#mogrify}

Вернуть точную строку запроса, которая будет отправлена в базу данных.

Этот метод отображает окончательный SQL-запрос после подстановки параметров, что полезно для отладки и логирования.

**Синтаксис**

```python
mogrify(query, args=None)
```

**Параметры**

| Параметр  | Тип            | По умолчанию | Описание                                   |
|------------|-----------------|--------------|--------------------------------------------|
| `query`    | str             | *обязательно* | SQL-запрос с заполнителями параметров      |
| `args`     | tuple/list/dict | `None`      | Параметры для подстановки                  |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                            |
|----------------------------|----------------------------------------------------|
| `str`                      | Окончательная строка SQL-запроса с замененными параметрами |

**Пример**

```pycon
>>> cur.mogrify("SELECT * FROM users WHERE id = ?", (123,))
"SELECT * FROM users WHERE id = 123"
```

:::note
Этот метод соответствует расширению DB-API 2.0, используемому Psycopg.
:::

---
#### `nextset` {#nextset}

Перейти к следующему набору результатов (не поддерживается).

**Синтаксис**

```python
nextset()
```

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                   |
|----------------------------|-----------------------------------------------------------|
| `None`                     | Всегда возвращает None, так как множественные наборы результатов не поддерживаются |

:::note
chDB/ClickHouse не поддерживает множественные наборы результатов из одного запроса. 
Этот метод предоставлен для соответствия спецификации DB-API 2.0, но всегда возвращает None.
:::

---
#### `setinputsizes` {#setinputsizes}

Установить размеры входных параметров (реализация без действия).

**Синтаксис**

```python
setinputsizes(*args)
```

**Параметры**

| Параметр  | Тип  | Описание                                   |
|------------|-------|-------------------------------------------|
| `*args`    | -     | Спецификации размеров параметров (игнорируются) |

:::note
Этот метод ничего не делает, но требуется спецификацией DB-API 2.0.
chDB автоматически обрабатывает размеры параметров внутри.
:::

---
#### `setoutputsizes` {#setoutputsizes}

Установить размеры выходных колонок (реализация без действия).

**Синтаксис**

```python
setoutputsizes(*args)
```

**Параметры**

| Параметр  | Тип  | Описание                                   |
|------------|-------|-------------------------------------------|
| `*args`    | -     | Спецификации размеров колонок (игнорируются) |

:::note
Этот метод ничего не делает, но требуется спецификацией DB-API 2.0.
chDB автоматически обрабатывает размеры выходов внутри.
:::

---
### Классы ошибок {#error-classes}

Классы исключений для операций с базой данных chdb.

Этот модуль предоставляет полную иерархию классов исключений для обработки ошибок, связанных с базой данных в chdb, в соответствии со Спецификацией API баз данных Python версии 2.0.

Иерархия исключений структурирована следующим образом:

```default
StandardError
├── Warning
└── Error
    ├── InterfaceError
    └── DatabaseError
        ├── DataError
        ├── OperationalError
        ├── IntegrityError
        ├── InternalError
        ├── ProgrammingError
        └── NotSupportedError
```

Каждый класс исключения представляет собой определенную категорию ошибок, связанных с базой данных:

| Исключение           | Описание                                                   |
|---------------------|-----------------------------------------------------------|
| `Warning`           | Ненасильственные предупреждения во время операций с базой данных  |
| `InterfaceError`    | Проблемы с самим интерфейсом базы данных                  |
| `DatabaseError`     | Базовый класс для всех ошибок, связанных с базой данных    |
| `DataError`         | Проблемы с обработкой данных (недопустимые значения, ошибки типов) |
| `OperationalError`  | Операционные проблемы базы данных (соединение, ресурсы)  |
| `IntegrityError`    | Нарушения ограничений (внешние ключи, уникальность)       |
| `InternalError`     | Внутренние ошибки базы данных и повреждения               |
| `ProgrammingError`  | Ошибки синтаксиса SQL и неправильное использование API    |
| `NotSupportedError` | Неподдерживаемые функции или операции                     |

:::note
Эти классы исключений соответствуют спецификации Python DB API 2.0 и обеспечивают последовательную обработку ошибок в различных операциях с базой данных.
:::

**Смотрите также**
- [Спецификация API базы данных Python версии 2.0](https://peps.python.org/pep-0249/)
- `chdb.dbapi.connections` - Управление соединениями с базой данных
- `chdb.dbapi.cursors` - Операции с курсорами базы данных

**Примеры**

```pycon
>>> try:
...     cursor.execute("SELECT * FROM nonexistent_table")
... except ProgrammingError as e:
...     print(f"SQL Error: {e}")
...
SQL Error: Table 'nonexistent_table' doesn't exist
```

```pycon
>>> try:
...     cursor.execute("INSERT INTO users (id) VALUES (1), (1)")
... except IntegrityError as e:
...     print(f"Constraint violation: {e}")
...
Constraint violation: Duplicate entry '1' for key 'PRIMARY'
```

---
#### **исключение** `chdb.dbapi.err.DataError` {#chdb-dbapi-err-dataerror}

Базируется на: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, вызываемое для ошибок, возникающих из-за проблем с обрабатываемыми данными.

Это исключение вызывается, когда операции с базой данных завершаются ошибкой из-за проблем с обрабатываемыми данными, таких как:

- Операции деления на ноль
- Числовые значения вне диапазона
- Неверные значения даты/времени
- Ошибки обрезки строк
- Ошибки преобразования типов
- Неверный формат данных для типа колонки

**Вызывает**

| Исключение | Условие                                    |
|------------|---------------------------------------------|
| [`DataError`](#chdb-dbapi-err-dataerror) | Когда проверка данных или обработка завершаются ошибкой |

**Примеры**

```pycon
>>> # Division by zero in SQL
>>> cursor.execute("SELECT 1/0")
DataError: Division by zero
```

```pycon
>>> # Invalid date format
>>> cursor.execute("INSERT INTO table VALUES ('invalid-date')")
DataError: Invalid date format
```

---
#### **исключение** `chdb.dbapi.err.DatabaseError` {#chdb-dbapi-err-databaseerror}

Базируется на: [`Error`](#chdb-dbapi-err-error)

Исключение, вызываемое для ошибок, связанных с базой данных.

Это базовый класс для всех ошибок, связанных с базой данных. Включает в себя все ошибки, которые происходят во время операций с базой данных и связаны с самой базой данных, а не с интерфейсом.

Распространенные сценарии включают:

- Ошибки выполнения SQL
- Проблемы с подключением к базе данных
- Проблемы, связанные с транзакциями
- Нарушения ограничений, специфичных для базы данных

:::note
Этот класс служит родительским для более специфичных типов ошибок базы данных, таких как [`DataError`](#chdb-dbapi-err-dataerror), [`OperationalError`](#chdb-dbapi-err-operationalerror) и т.д.
:::

---
#### **исключение** `chdb.dbapi.err.Error` {#chdb-dbapi-err-error}

Базируется на: [`StandardError`](#chdb-dbapi-err-standarderror)

Исключение, которое является базовым классом для всех остальных исключений ошибок (не предупреждений).

Это базовый класс для всех исключений ошибок в chdb, за исключением предупреждений. Он служит родительским классом для всех условий ошибок базы данных, которые мешают успешному завершению операций.

:::note
Эта иерархия исключений соответствует спецификации Python DB API 2.0.
:::

**Смотрите также**
- [`Warning`](#chdb-dbapi-err-warning) - Для ненасильственных предупреждений, которые не мешают завершению операции
#### **исключение** `chdb.dbapi.err.IntegrityError` {#chdb-dbapi-err-integrityerror}

Базируется на: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, вызываемое, когда нарушается реляционная целостность базы данных.

Это исключение вызывается, когда операции с базой данных нарушают ограничения целостности, включая:

- Нарушения ограничений внешнего ключа
- Нарушения ограничений первичного ключа или уникальности (дублирующие ключи)
- Нарушения ограничений проверки
- Нарушения ограничений NOT NULL
- Нарушения целостности ссылок

**Вызывает**

| Исключение                                          | Условие                                           |
|----------------------------------------------------|---------------------------------------------------|
| [`IntegrityError`](#chdb-dbapi-err-integrityerror) | Когда нарушаются ограничения целостности базы данных |

**Примеры**

```pycon
>>> # Duplicate primary key
>>> cursor.execute("INSERT INTO users (id, name) VALUES (1, 'John')")
>>> cursor.execute("INSERT INTO users (id, name) VALUES (1, 'Jane')")
IntegrityError: Duplicate entry '1' for key 'PRIMARY'
```

```pycon
>>> # Foreign key violation
>>> cursor.execute("INSERT INTO orders (user_id) VALUES (999)")
IntegrityError: Cannot add or update a child row: foreign key constraint fails
```

---
#### **исключение** `chdb.dbapi.err.InterfaceError` {#chdb-dbapi-err-interfaceerror}

Базируется на: [`Error`](#chdb-dbapi-err-error)

Исключение, вызываемое для ошибок, связанных с интерфейсом базы данных, а не с самой базой данных.

Это исключение вызывается, когда возникают проблемы с реализацией интерфейса базы данных, такие как:

- Неверные параметры подключения
- Неправильное использование API (вызов методов на закрытых соединениях)
- Ошибки протокола на уровне интерфейса
- Ошибки импорта или инициализации модуля

**Вызывает**

| Исключение                                          | Условие                                              |
|----------------------------------------------------|------------------------------------------------------|
| [`InterfaceError`](#chdb-dbapi-err-interfaceerror) | Когда интерфейс базы данных сталкивается с ошибками, не связанными с операциями базы данных |

:::note
Эти ошибки, как правило, являются ошибками программирования или конфигурации, которые можно решить, исправив клиентский код или конфигурацию.
:::

---
#### **исключение** `chdb.dbapi.err.InternalError` {#chdb-dbapi-err-internalerror}

Базируется на: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, возникающее, когда база данных сталкивается с внутренней ошибкой.

Это исключение вызывается, когда система базы данных сталкивается с внутренними ошибками, которые не вызваны приложением, такими как:

- Неверное состояние курсора (курсоры больше не действительны)
- Неконсистентности состояния транзакции (транзакция не синхронизирована)
- Проблемы с повреждением базы данных
- Повреждение внутренних структур данных
- Ошибки базы данных на уровне системы

**Вызывает**

| Исключение | Условие |
|-----------|-----------|
| [`InternalError`](#chdb-dbapi-err-internalerror) | Когда база данных сталкивается с внутренними несоответствиями |

:::warning Предупреждение
Внутренние ошибки могут указывать на серьезные проблемы с базой данных, требующие внимания администратора базы данных. Эти ошибки, как правило, не восстановимы с помощью логики повторной попытки на уровне приложения.
:::

:::note
Эти ошибки, как правило, выходят за рамки контроля приложения и могут потребовать перезапуска базы данных или операций восстановления.
:::

---
#### **исключение** `chdb.dbapi.err.NotSupportedError` {#chdb-dbapi-err-notsupportederror}

Базируется на: [`DatabaseError`](#chdb.dbapi-err-databaseerror)

Исключение, вызываемое, когда метод или API базы данных не поддерживается.

Это исключение вызывается, когда приложение пытается использовать функции базы данных или методы API, которые не поддерживаются текущей конфигурацией или версией базы данных, такие как:

- Запрос `rollback()` на соединениях без поддержки транзакций
- Использование расширенных функций SQL, не поддерживаемых версией базы данных
- Вызов методов, не реализованных текущим драйвером
- Попытка использовать отключенные функции базы данных

**Вызывает**

| Исключение                                                | Условие                                            |
|----------------------------------------------------------|----------------------------------------------------|
| [`NotSupportedError`](#chdb-dbapi-err-notsupportederror) | Когда обращаются к неподдерживаемым функциям базы данных |

**Примеры**

```pycon
>>> # Transaction rollback on non-transactional connection
>>> connection.rollback()
NotSupportedError: Transactions are not supported
```

```pycon
>>> # Using unsupported SQL syntax
>>> cursor.execute("SELECT * FROM table WITH (NOLOCK)")
NotSupportedError: WITH clause not supported in this database version
```

:::note
Проверьте документацию базы данных и возможности драйвера, чтобы избежать этих ошибок. Рассмотрите возможности плавного возврата, где это возможно.
:::

---
#### **исключение** `chdb.dbapi.err.OperationalError` {#chdb-dbapi-err-operationalerror}

Базируется на: [`DatabaseError`](#chdb.dbapi-err-databaseerror)

Исключение, возникающее для ошибок, связанных с работой базы данных.

Это исключение вызывается для ошибок, которые происходят во время работы базы данных и не обязательно находятся под контролем программиста, включая:

- Неожиданное отключение от базы данных
- Сервер базы данных не найден или недоступен
- Ошибки обработки транзакций
- Ошибки выделения памяти во время обработки
- Израсходование дискового пространства или ресурсов
- Внутренние ошибки сервера базы данных
- Ошибки аутентификации или авторизации

**Вызывает**

| Исключение                                              | Условие                                              |
|--------------------------------------------------------|------------------------------------------------------|
| [`OperationalError`](#chdb.dbapi-err-operationalerror) | Когда операции базы данных завершаются ошибкой из-за операционных проблем |

:::note
Эти ошибки, как правило, временные и могут быть устранены повторной попыткой операции или устранением проблем на уровне системы.
:::

:::warning Предупреждение
Некоторые операционные ошибки могут указывать на серьезные проблемы в системе, требующие административного вмешательства.
:::

---
#### **исключение** `chdb.dbapi.err.ProgrammingError` {#chdb.dbapi-err-programmingerror}

Базируется на: [`DatabaseError`](#chdb.dbapi-err-databaseerror)

Исключение, вызываемое для ошибок программирования в операциях с базой данных.

Это исключение вызывается, когда в использовании базы данных приложением возникают ошибки программирования, включая:

- Таблица или колонка не найдена
- Таблица или индекс уже существуют при создании
- Ошибки синтаксиса SQL в выражениях
- Неверное количество параметров, указанных в подготовленных выражениях
- Неверные операции SQL (например, DROP на несуществующих объектах)
- Неправильное использование методов API базы данных

**Вызывает**

| Исключение                                              | Условие                                        |
|--------------------------------------------------------|------------------------------------------------|
| [`ProgrammingError`](#chdb.dbapi-err-programmingerror) | Когда SQL-запросы или использование API содержат ошибки |

**Примеры**

```pycon
>>> # Table not found
>>> cursor.execute("SELECT * FROM nonexistent_table")
ProgrammingError: Table 'nonexistent_table' doesn't exist
```

```pycon
>>> # SQL syntax error
>>> cursor.execute("SELCT * FROM users")
ProgrammingError: You have an error in your SQL syntax
```

```pycon
>>> # Wrong parameter count
>>> cursor.execute("INSERT INTO users (name, age) VALUES (%s)", ('John',))
ProgrammingError: Column count doesn't match value count
```

---
#### **исключение** `chdb.dbapi.err.StandardError` {#chdb.dbapi-err-standarderror}

Базируется на: `Exception`

Исключение, связанное с операцией с chdb.

Это базовый класс для всех исключений, связанных с chdb. Он наследуется от встроенного класса Exception Python и служит корнем иерархии исключений для операций с базой данных.

:::note
Этот класс исключений соответствует спецификации Python DB API 2.0 для обработки исключений баз данных.
:::

---
#### **исключение** `chdb.dbapi.err.Warning` {#chdb.dbapi-err-warning}

Базируется на: [`StandardError`](#chdb.dbapi-err-standarderror)

Исключение, вызываемое для важных предупреждений, таких как обрезка данных во время вставки и т. д.

Это исключение вызывается, когда операция базы данных завершается, но с важными предупреждениями, на которые следует обратить внимание приложению. Распространенные сценарии включают:

- Обрезка данных во время вставки
- Потеря точности в числовых преобразованиях
- Предупреждения о преобразовании кодировок

:::note
Это соответствует спецификации Python DB API 2.0 для предупреждающих исключений.
:::

---
### Константы модуля {#module-constants}
#### `chdb.dbapi.apilevel = '2.0'` {#apilevel}

```python
str(object=’’) -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
```

Создает новый объект строки из указанного объекта. Если указаны кодировка или ошибки, то объект должен иметь буфер данных, который будет декодирован с использованием заданной кодировки и обработчика ошибок. В противном случае возвращает результат `object.__str__()` (если определен) или `repr(object)`.

- кодировка по умолчанию 'utf-8'.
- ошибки по умолчанию 'строгие'.

---
#### `chdb.dbapi.threadsafety = 1` {#threadsafety}

```python
int([x]) -> integer
int(x, base=10) -> integer
```

Преобразует число или строку в целое число или возвращает 0, если не указаны аргументы. Если x — число, возвращает x.__int__(). Для чисел с плавающей запятой это усечет в сторону нуля.

Если x не является числом или если указана основа, то x должен быть строкой, байтами или экземпляром bytearray, представляющим целочисленный литерал в заданной основе. Литерал может быть предшествован символами '+' или '-' и окружен пробелами. Основание по умолчанию — 10. Допустимые основания: 0 и 2-36. Основание 0 означает интерпретацию базы из строки как целочисленного литерала.

```python
>>> int(‘0b100’, base=0)
4
```

---
#### `chdb.dbapi.paramstyle = 'format'` {#paramstyle}

```python
str(object=’’) -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
```

Создает новый объект строки из указанного объекта. Если указаны кодировка или ошибки, то объект должен иметь буфер данных, который будет декодирован с использованием заданной кодировки и обработчика ошибок. В противном случае возвращает результат object.__str__() (если определен) или repr(object).
кодировка по умолчанию 'utf-8'.
ошибки по умолчанию 'строгие'.

---
### Константы типов {#type-constants}
#### `chdb.dbapi.STRING = frozenset({247, 253, 254})` {#string-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0. Он позволяет гибкое сравнение типов, когда отдельные элементы можно сравнивать с набором с использованием операторов равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы включить сравнения, такие как "field_type == STRING", где field_type — это одно значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---
#### `chdb.dbapi.BINARY = frozenset({249, 250, 251, 252})` {#binary-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0. Он позволяет гибкое сравнение типов, когда отдельные элементы можно сравнивать с набором с использованием операторов равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы включить сравнения, такие как "field_type == STRING", где field_type — это одно значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---
#### `chdb.dbapi.NUMBER = frozenset({0, 1, 3, 4, 5, 8, 9, 13})` {#number-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0. Он позволяет гибкое сравнение типов, когда отдельные элементы можно сравнивать с набором с использованием операторов равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы включить сравнения, такие как "field_type == STRING", где field_type — это одно значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---
#### `chdb.dbapi.DATE = frozenset({10, 14})` {#date-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0. Он позволяет гибкое сравнение типов, когда отдельные элементы можно сравнивать с набором с использованием операторов равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы включить сравнения, такие как "field_type == STRING", где field_type — это одно значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---
#### `chdb.dbapi.TIME = frozenset({11})` {#time-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0. Он позволяет гибкое сравнение типов, когда отдельные элементы можно сравнивать с набором с использованием операторов равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы включить сравнения, такие как "field_type == STRING", где field_type — это одно значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---
#### `chdb.dbapi.TIMESTAMP = frozenset({7, 12})` {#timestamp-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0. Он позволяет гибкое сравнение типов, когда отдельные элементы можно сравнивать с набором с использованием операторов равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы включить сравнения, такие как "field_type == STRING", где field_type — это одно значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```
#### `chdb.dbapi.DATETIME = frozenset({7, 12})` {#datetime-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0. Он позволяет гибкое сравнение типов, когда отдельные элементы можно сравнивать с набором с использованием операторов равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы включить сравнения, такие как "field_type == STRING", где field_type — это одно значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---
#### `chdb.dbapi.ROWID = frozenset({})` {#rowid-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0. Он позволяет гибкое сравнение типов, когда отдельные элементы можно сравнивать с набором с использованием операторов равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы включить сравнения, такие как "field_type == STRING", где field_type — это одно значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

**Примеры использования**

Пример основного запроса:

```python
import chdb.dbapi as dbapi

print("chdb driver version: {0}".format(dbapi.get_client_info()))


# Create connection and cursor
conn = dbapi.connect()
cur = conn.cursor()


# Execute query
cur.execute('SELECT version()')
print("description:", cur.description)
print("data:", cur.fetchone())


# Clean up
cur.close()
conn.close()
```

Работа с данными:

```python
import chdb.dbapi as dbapi

conn = dbapi.connect()
cur = conn.cursor()


# Create table
cur.execute("""
    CREATE TABLE employees (
        id UInt32,
        name String,
        department String,
        salary Decimal(10,2)
    ) ENGINE = Memory
""")


# Insert data
cur.execute("""
    INSERT INTO employees VALUES
    (1, 'Alice', 'Engineering', 75000.00),
    (2, 'Bob', 'Marketing', 65000.00),
    (3, 'Charlie', 'Engineering', 80000.00)
""")


# Query data
cur.execute("SELECT * FROM employees WHERE department = 'Engineering'")


# Fetch results
print("Column names:", [desc[0] for desc in cur.description])
for row in cur.fetchall():
    print(row)

conn.close()
```

Управление соединениями:

```python
import chdb.dbapi as dbapi


# In-memory database (default)
conn1 = dbapi.connect()


# Persistent database file
conn2 = dbapi.connect("./my_database.chdb")


# Connection with parameters
conn3 = dbapi.connect("./my_database.chdb?log-level=debug&verbose")


# Read-only connection
conn4 = dbapi.connect("./my_database.chdb?mode=ro")


# Automatic connection cleanup
with dbapi.connect("test.chdb") as conn:
    cur = conn.cursor()
    cur.execute("SELECT count() FROM numbers(1000)")
    result = cur.fetchone()
    print(f"Count: {result[0]}")
    cur.close()
```

**Лучшие практики**

1. **Управление соединениями**: Всегда закрывайте соединения и курсоры после завершения
2. **Контекстные менеджеры**: Используйте конструкции `with` для автоматической очистки
3. **Пакетная обработка**: Используйте `fetchmany()` для крупных наборов результатов
4. **Обработка ошибок**: Оборачивайте операции с базой данных в блоки try-except
5. **Привязка параметров**: Используйте параметризованные запросы, когда это возможно
6. **Управление памятью**: Избегайте `fetchall()` для очень крупных наборов данных

:::note
- Интерфейс DB-API 2.0 chDB совместим с большинством инструментов баз данных на Python
- Интерфейс предоставляет уровень 1 безопасности потоков (потоки могут совместно использовать модули, но не соединения)
- Строки подключения поддерживают те же параметры, что и сеансы chDB
- Все стандартные исключения DB-API 2.0 поддерживаются
:::

:::warning Предупреждение
- Всегда закрывайте курсоры и соединения, чтобы избежать утечек ресурсов
- Крупные наборы результатов должны обрабатываться пакетами
- Синтаксис привязки параметров следует стилю формата: `%s`
:::
## Пользовательские функции (UDF) {#user-defined-functions}

Модуль пользовательских функций для chDB.

Этот модуль предоставляет функциональность для создания и управления пользовательскими функциями (UDF) в chDB. Он позволяет расширить возможности chDB, написав собственные функции Python, которые могут быть вызваны из SQL-запросов.
### `chdb.udf.chdb_udf` {#chdb-udf}

Декоратор для chDB Python UDF (Пользовательская Определенная Функция).

**Синтаксис**

```python
chdb.udf.chdb_udf(return_type='String')
```

**Параметры**

| Параметр     | Тип  | По умолчанию | Описание                                                                      |
|---------------|-------|--------------|-------------------------------------------------------------------------------|
| `return_type` | str   | `"String"`   | Тип возвращаемого значения функции. Должен быть одним из типов данных ClickHouse |

**Заметки**

1. Функция должна быть статeless. Поддерживаются только UDF, не UDAF.
2. Тип возвращаемого значения по умолчанию — строка. Тип возвращаемого значения должен быть одним из типов данных ClickHouse.
3. Функция должна принимать аргументы типа строка. Все аргументы являются строками.
4. Функция будет вызвана для каждой строки входных данных.
5. Функция должна быть чистой функцией Python. Импортируйте все модули, используемые В ФУНКЦИИ.
6. Используемый интерпретатор Python такой же, как и тот, который использовался для запуска скрипта.

**Пример**

```python
@chdb_udf()
def sum_udf(lhs, rhs):
    return int(lhs) + int(rhs)

@chdb_udf()
def func_use_json(arg):
    import json
    # ... use json module
```

---
### `chdb.udf.generate_udf` {#generate-udf}

Сгенерировать конфигурацию UDF и исполняемые файлы скриптов.

Эта функция создает необходимые файлы для Пользовательской Определенной Функции (UDF) в chDB:
1. Исполняемый Python-скрипт, который обрабатывает входные данные
2. XML-файл конфигурации, который регистрирует UDF с ClickHouse

**Синтаксис**

```python
chdb.udf.generate_udf(func_name, args, return_type, udf_body)
```

**Параметры**

| Параметр     | Тип  | Описание                                   |
|---------------|-------|---------------------------------------------|
| `func_name`   | str   | Имя функции UDF                             |
| `args`        | list  | Список имен аргументов для функции         |
| `return_type` | str   | Тип возвращаемого значения ClickHouse для функции |
| `udf_body`    | str   | Тело исходного кода Python функции UDF     |

:::note
Эта функция обычно вызывается декоратором @chdb_udf и не должна вызываться пользователями напрямую.
:::

---
## Утилиты {#utilities}

Утилитные функции и вспомогательные средства для chDB.

Этот модуль содержит различные утилитные функции для работы с chDB, включая вывод типа данных, вспомогательные функции преобразования данных и утилиты отладки.

---
### `chdb.utils.convert_to_columnar` {#convert-to-columnar}

Преобразует список словарей в столбцовый формат.

Эта функция принимает список словарей и преобразует его в словарь, где каждый ключ соответствует колонке, а каждое значение является списком значений колонки. Пропущенные значения в словарях представлены как None.

**Синтаксис**

```python
chdb.utils.convert_to_columnar(items: List[Dict[str, Any]]) → Dict[str, List[Any]]
```

**Параметры**

| Параметр  | Тип                   | Описание                       |
|------------|------------------------|---------------------------------|
| `items`    | `List[Dict[str, Any]]` | Список словарей для преобразования |

**Возвращаемое значение**

| Тип возвращаемого значения            | Описание                                                                      |
|---------------------------------------|------------------------------------------------------------------------------|
| `Dict[str, List[Any]]`               | Словарь с ключами в виде имен колонок и значениями в виде списков значений колонок |

**Пример**

```pycon
>>> items = [
...     {"name": "Alice", "age": 30, "city": "New York"},
...     {"name": "Bob", "age": 25},
...     {"name": "Charlie", "city": "San Francisco"}
... ]
>>> convert_to_columnar(items)
{
    'name': ['Alice', 'Bob', 'Charlie'],
    'age': [30, 25, None],
    'city': ['New York', None, 'San Francisco']
}
```

---
### `chdb.utils.flatten_dict` {#flatten-dict}

Уплощает вложенный словарь.

Эта функция принимает вложенный словарь и уплощает его, соединяя вложенные ключи
с разделителем. Списки словарей сериализуются в JSON-строки.

**Синтаксис**

```python
chdb.utils.flatten_dict(d: Dict[str, Any], parent_key: str = '', sep: str = '_') → Dict[str, Any]
```

**Параметры**

| Параметр     | Тип                  | По умолчанию | Описание                                        |
|---------------|----------------------|--------------|-------------------------------------------------|
| `d`           | `Dict[str, Any]`     | *обязательный* | Словарь для уплощения                          |
| `parent_key`  | str                  | `""`         | Базовый ключ, который будет добавлен к каждому ключу |
| `sep`         | str                  | `"_"`        | Разделитель, используемый между соединёнными ключами |

**Возврат**

| Тип возврата       | Описание                          |
|--------------------|----------------------------------|
| `Dict[str, Any]`   | Уплощённый словарь               |

**Пример**

```pycon
>>> nested_dict = {
...     "a": 1,
...     "b": {
...         "c": 2,
...         "d": {
...             "e": 3
...         }
...     },
...     "f": [4, 5, {"g": 6}],
...     "h": [{"i": 7}, {"j": 8}]
... }
>>> flatten_dict(nested_dict)
{
    'a': 1,
    'b_c': 2,
    'b_d_e': 3,
    'f_0': 4,
    'f_1': 5,
    'f_2_g': 6,
    'h': '[{"i": 7}, {"j": 8}]'
}
```

---
### `chdb.utils.infer_data_type` {#infer-data-type}

Выводит наиболее подходящий тип данных для списка значений.

Эта функция анализирует список значений и определяет наиболее подходящий
тип данных, который может представить все значения в списке. Она учитывает целые,
беззнаковые целые, десятичные и плавающие типы, и по умолчанию возвращает “строку”, если значения не могут быть представлены любым числовым типом или если все значения равны None.

**Синтаксис**

```python
chdb.utils.infer_data_type(values: List[Any]) → str
```

**Параметры**

| Параметр   | Тип          | Описание                                                    |
|-------------|--------------|------------------------------------------------------------|
| `values`    | `List[Any]`  | Список значений для анализа. Значения могут быть любого типа |

**Возврат**

| Тип возврата | Описание                                                                                                                                                                                                                                               |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `str`        | Строка, представляющая выведенный тип данных. Возможные возвращаемые значения: ”int8”, “int16”, “int32”, “int64”, “int128”, “int256”, “uint8”, “uint16”, “uint32”, “uint64”, “uint128”, “uint256”, “decimal128”, “decimal256”, “float32”, “float64”, или “строка”. | 

:::note
- Если все значения в списке равны None, функция возвращает “строка”.
- Если любое значение в списке является строкой, функция немедленно возвращает “строка”.
- Функция предполагает, что числовые значения могут быть представлены как целые,
  десятичные или плавающие на основе их диапазона и точности.
:::

---
### `chdb.utils.infer_data_types` {#infer-data-types}

Выводит типы данных для каждой колонки в столбцовой структуре данных.

Эта функция анализирует значения в каждой колонке и выводит наиболее подходящий
тип данных для каждой колонки на основе выборки данных.

**Синтаксис**

```python
chdb.utils.infer_data_types`(column_data: Dict[str, List[Any]], n_rows: int = 10000) → List[tuple]
```

**Параметры**

| Параметр      | Тип                     | По умолчанию | Описание                                                                    |
|---------------|-------------------------|--------------|-----------------------------------------------------------------------------|
| `column_data` | `Dict[str, List[Any]]`  | *обязательный* | Словарь, где ключи — это имена колонок, а значения — списки значений колонок |
| `n_rows`      | int                     | `10000`      | Количество строк для выборки при выводе типов данных                       |

**Возврат**

| Тип возврата   | Описание                                                                |
|----------------|-------------------------------------------------------------------------|
| `List[tuple]`  | Список кортежей, каждый из которых содержит имя колонки и её выведенный тип данных |
## Abstract Base Classes {#abstract-base-classes}
### **class** `chdb.rwabc.PyReader`(data: Any)` {#pyreader}

Bases: `ABC`

```python
class chdb.rwabc.PyReader(data: Any)
```

---
#### **abstractmethod** `read` {#read}

Читает заданное количество строк из указанных колонок и возвращает список объектов,
где каждый объект является последовательностью значений для колонки.

```python
abstractmethod (col_names: List[str], count: int) → List[Any]
```

**Параметры**

| Параметр   | Тип          | Описание                        |
|-------------|--------------|---------------------------------|
| `col_names` | `List[str]`  | Список имен колонок для чтения |
| `count`     | int          | Максимальное количество строк для чтения |

**Возврат**

| Тип возврата  | Описание                        |
|---------------|---------------------------------|
| `List[Any]`   | Список последовательностей, по одной для каждой колонки |
### **class** `chdb.rwabc.PyWriter` {#pywriter}

Bases: `ABC`

```python
class chdb.rwabc.PyWriter(col_names: List[str], types: List[type], data: Any)
```

---
#### **abstractmethod** finalize {#finalize}

Собирает и возвращает окончательные данные из блоков. Должен быть реализован подклассами.

```python
abstractmethod finalize() → bytes
```

**Возврат**

| Тип возврата  | Описание                   |
|---------------|----------------------------|
| `bytes`       | Окончательные сериализованные данные |

---
#### **abstractmethod** `write` {#write}

Сохраняет колонки данных в блоки. Должен быть реализован подклассами.

```python
abstractmethod write(col_names: List[str], columns: List[List[Any]]) → None
```

**Параметры**

| Параметр   | Тип                | Описание                                                |
|-------------|---------------------|--------------------------------------------------------|
| `col_names` | `List[str]`        | Список имен колонок, которые записываются             |
| `columns`   | `List[List[Any]]`   | Список данных колонок, каждая колонка представлена списком |
## Exception Handling {#exception-handling}
### **class** `chdb.ChdbError` {#chdberror}

Bases: `Exception`

Базовый класс исключений для ошибок, связанных с chDB.

Это исключение вызывается, когда выполнение запроса chDB не удаётся или возникает ошибка. Оно наследуется от стандартного класса исключений Python и предоставляет информацию об ошибке из движка ClickHouse.

Сообщение об исключении обычно содержит подробную информацию об ошибке
из ClickHouse, включая синтаксические ошибки, несоответствия типов, отсутствующие
таблицы/колонки и другие проблемы выполнения запросов.

**Переменные**

| Переменная | Тип  | Описание                                                     |
|------------|------|-------------------------------------------------------------|
| `args`     | -    | Кортеж, содержащий сообщение об ошибке и любые дополнительные аргументы |

**Примеры**

```pycon
>>> try:
...     result = chdb.query("SELECT * FROM non_existent_table")
... except chdb.ChdbError as e:
...     print(f"Query failed: {e}")
Query failed: Table 'non_existent_table' doesn't exist
```

```pycon
>>> try:
...     result = chdb.query("SELECT invalid_syntax FROM")
... except chdb.ChdbError as e:
...     print(f"Syntax error: {e}")
Syntax error: Syntax error near 'FROM'
```

:::note
Это исключение автоматически вызывается chdb.query() и связанными
функциями, когда движок ClickHouse сообщает об ошибке.
Вы должны перехватывать это исключение при обработке потенциально неудачных
запросов, чтобы обеспечить соответствующую обработку ошибок в вашем приложении.
:::
## Version Information {#version-information}
### `chdb.chdb_version = ('3', '6', '0')` {#chdb-version}

Встроенная неизменяемая последовательность.

Если аргумент не указан, конструктор возвращает пустой кортеж.
Если указано итерируемое значение, то кортеж инициализируется значениями из этого итерируемого значения.

Если аргумент является кортежем, возвращаемое значение будет таким же объектом.

---
### `chdb.engine_version = '25.5.2.1'` {#engine-version}

```python
str(object=’’) -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
```

Создаёт новый объект строки из данного объекта. Если указан кодек или
ошибки, то объект должен поддерживать буфер данных,
который будет декодироваться с использованием указанного кодека и обработчика ошибок.
В противном случае возвращается результат object._\_str_\_() (если он определён)
или repr(object).

- кодек по умолчанию ‘utf-8’.
- обработка ошибок по умолчанию ‘строгая’.

---
### `chdb.__version__ = '3.6.0'` {#version}

```python
str(object=’’) -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
```

Создаёт новый объект строки из данного объекта. Если указан кодек или
ошибки, то объект должен поддерживать буфер данных,
который будет декодироваться с использованием указанного кодека и обработчика ошибок.
В противном случае возвращается результат object._\_str_\_() (если он определён)
или repr(object).

- кодек по умолчанию ‘utf-8’.
- обработка ошибок по умолчанию ‘строгая’.

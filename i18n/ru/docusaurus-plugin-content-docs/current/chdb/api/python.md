---
title: 'Справочник по Python API chDB'
sidebar_label: 'Python API'
slug: /chdb/api/python
description: 'Полный справочник по Python API chDB'
keywords: ['chdb', 'embedded', 'clickhouse-lite', 'python', 'api', 'reference']
doc_type: 'reference'
---



# Справочник по API Python



## Основные функции для выполнения запросов {#core-query-functions}

### `chdb.query` {#chdb-query}

Выполняет SQL‑запрос с использованием движка chDB.

Это основная функция для выполнения запросов, которая исполняет операторы SQL с использованием встроенного
движка ClickHouse. Поддерживает различные форматы вывода и может работать с базами данных
в памяти или на файловой системе.

**Синтаксис**

```python
chdb.query(sql, output_format='CSV', path='', udf_path='')
```

**Параметры**

| Параметр        | Тип  | Значение по умолчанию | Описание                                                                                                                                                                                                                                                                                                       |
| --------------- | ---- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sql`           | str  | _required_ | Строка SQL‑запроса для выполнения                                                                                                                                                                                                                                                                               |
| `output_format` | str  | `"CSV"`    | Формат вывода результата. Поддерживаемые форматы:<br/>• `"CSV"` — значения, разделённые запятыми<br/>• `"JSON"` — формат JSON<br/>• `"Arrow"` — формат Apache Arrow<br/>• `"Parquet"` — формат Parquet<br/>• `"DataFrame"` — объект Pandas DataFrame<br/>• `"ArrowTable"` — объект PyArrow Table<br/>• `"Debug"` — включает подробное логирование |
| `path`          | str  | `""`       | Путь к файлу базы данных. По умолчанию используется база данных в памяти.<br/>Может быть путём к файлу или `":memory:"` для базы данных в памяти                                                                                                                                                               |
| `udf_path`      | str  | `""`       | Путь к каталогу пользовательских функций (User-Defined Functions)                                                                                                                                                                                                                                              |

**Возвращаемое значение**

Возвращает результат запроса в указанном формате:

| Тип возвращаемого значения | Условие                                                 |
| ------------------ | -------------------------------------------------------- |
| `str`              | Для текстовых форматов, таких как CSV, JSON              |
| `pd.DataFrame`     | Когда `output_format` — `"DataFrame"` или `"dataframe"`  |
| `pa.Table`         | Когда `output_format` — `"ArrowTable"` или `"arrowtable"` |
| объект результата chdb | Для других форматов                                      |

**Исключения**

| Исключение    | Условие                                                          |
| ------------- | ---------------------------------------------------------------- |
| `ChdbError`   | Если не удалось выполнить SQL‑запрос                             |
| `ImportError` | Если отсутствуют необходимые зависимости для форматов DataFrame/Arrow |

**Примеры**

```pycon
>>> # Простой запрос с выводом в CSV
>>> result = chdb.query("SELECT 1, 'hello'")
>>> print(result)
"1,hello"
```

```pycon
>>> # Запрос с выводом в DataFrame
>>> df = chdb.query("SELECT 1 as id, 'hello' as msg", "DataFrame")
>>> print(df)
   id    msg
0   1  hello
```

```pycon
>>> # Запрос с базой данных, хранящейся в файле
>>> result = chdb.query("CREATE TABLE test (id INT) ENGINE = Memory", path="mydb.chdb")
```

```pycon
>>> # Запрос с использованием UDF
>>> result = chdb.query("SELECT my_udf('test')", udf_path="/path/to/udfs")
```

---

### `chdb.sql` {#chdb_sql}

Выполняет SQL‑запрос с использованием движка chDB.

Это основная функция для выполнения запросов, которая исполняет операторы SQL с использованием встроенного
движка ClickHouse. Поддерживает различные форматы вывода и может работать с базами данных
в памяти или на файловой системе.

**Синтаксис**

```python
chdb.sql(sql, output_format='CSV', path='', udf_path='')
```

**Параметры**

| Параметр        | Тип  | Значение по умолчанию | Описание                                                                                                                                                                                                                                                                                                       |
| --------------- | ---- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sql`           | str  | _required_ | Строка SQL‑запроса для выполнения                                                                                                                                                                                                                                                                               |
| `output_format` | str  | `"CSV"`    | Формат вывода результата. Поддерживаемые форматы:<br/>• `"CSV"` — значения, разделённые запятыми<br/>• `"JSON"` — формат JSON<br/>• `"Arrow"` — формат Apache Arrow<br/>• `"Parquet"` — формат Parquet<br/>• `"DataFrame"` — объект Pandas DataFrame<br/>• `"ArrowTable"` — объект PyArrow Table<br/>• `"Debug"` — включает подробное логирование |
| `path`          | str  | `""`       | Путь к файлу базы данных. По умолчанию используется база данных в памяти.<br/>Может быть путём к файлу или `":memory:"` для базы данных в памяти                                                                                                                                                               |
| `udf_path`      | str  | `""`       | Путь к каталогу пользовательских функций (User-Defined Functions)                                                                                                                                                                                                                                              |

**Возвращаемое значение**

Возвращает результат запроса в указанном формате:


| Тип возвращаемого значения | Условие                                                  |
| ------------------ | -------------------------------------------------------- |
| `str`              | Для текстовых форматов, таких как CSV, JSON              |
| `pd.DataFrame`     | Когда `output_format` имеет значение `"DataFrame"` или `"dataframe"` |
| `pa.Table`         | Когда `output_format` имеет значение `"ArrowTable"` или `"arrowtable"` |
| объект результата chdb | Для остальных форматов                                      |

**Исключения**

| Исключение                | Условие                                                          |
| ------------------------- | ---------------------------------------------------------------- |
| [`ChdbError`](#chdberror) | Если выполнение SQL-запроса завершается с ошибкой                |
| `ImportError`             | Если отсутствуют необходимые зависимости для форматов DataFrame/Arrow |

**Примеры**

```pycon
>>> # Базовый запрос с выводом в CSV
>>> result = chdb.query("SELECT 1, 'hello'")
>>> print(result)
"1,hello"
```

```pycon
>>> # Запрос с выводом в DataFrame
>>> df = chdb.query("SELECT 1 as id, 'hello' as msg", "DataFrame")
>>> print(df)
   id    msg
0   1  hello
```

```pycon
>>> # Запрос с использованием файловой базы данных
>>> result = chdb.query("CREATE TABLE test (id INT) ENGINE = Memory", path="mydb.chdb")
```

```pycon
>>> # Запрос с использованием UDF
>>> result = chdb.query("SELECT my_udf('test')", udf_path="/path/to/udfs")
```

---

### `chdb.to_arrowTable` {#chdb-state-sqlitelike-to_arrowtable}

Преобразование результата запроса в PyArrow Table.

Преобразует результат запроса chDB в PyArrow Table для эффективной колоночной обработки данных.
Возвращает пустую таблицу, если результат пуст.

**Синтаксис**

```python
chdb.to_arrowTable(res)
```

**Параметры**

| Параметр  | Описание                                              |
| --------- | ----------------------------------------------------- |
| `res`     | Объект результата запроса chDB, содержащий бинарные данные Arrow |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                   |
| ----------- | ------------------------------------------ |
| `pa.Table`  | PyArrow Table, содержащая результаты запроса |

**Исключения**

| Тип ошибки    | Описание                               |
| ------------- | -------------------------------------- |
| `ImportError` | Если pyarrow или pandas не установлены |

**Пример**

```pycon
>>> result = chdb.query("SELECT 1 as id, 'hello' as msg", "Arrow")
>>> table = chdb.to_arrowTable(result)
>>> print(table.to_pandas())
   id    msg
0   1  hello
```

---

### `chdb.to_df` {#chdb_to_df}

Преобразование результата запроса в pandas DataFrame.

Преобразует результат запроса chDB в pandas DataFrame, сначала преобразуя его в
PyArrow Table, а затем в pandas с использованием многопоточности для повышения производительности.

**Синтаксис**

```python
chdb.to_df(r)
```

**Параметры**

| Параметр  | Описание                                              |
| --------- | ----------------------------------------------------- |
| `r`       | Объект результата запроса chDB, содержащий бинарные данные Arrow |

**Returns**

| Тип возвращаемого значения | Описание                                   |
| -------------- | --------------------------------------------- |
| `pd.DataFrame` | pandas DataFrame, содержащий результаты запроса |

**Исключения**

| Исключение    | Условие                                |
| ------------- | -------------------------------------- |
| `ImportError` | Если pyarrow или pandas не установлены |

**Пример**

```pycon
>>> result = chdb.query("SELECT 1 as id, 'hello' as msg", "Arrow")
>>> df = chdb.to_df(result)
>>> print(df)
   id    msg
0   1  hello
```


## Управление подключениями и сеансами {#connection-session-management}

Доступны следующие функции для работы с сеансами:

### `chdb.connect` {#chdb-connect}

Создает подключение к фоновому серверу chDB.

Эта функция устанавливает [подключение](#chdb-state-sqlitelike-connection) к движку базы данных chDB (ClickHouse).
Для каждого процесса разрешено только одно открытое подключение.
Многократные вызовы с одной и той же строкой подключения вернут один и тот же объект подключения.

```python
chdb.connect(connection_string: str = ':memory:') → Connection
```

**Параметры:**

| Параметр            | Тип  | По умолчанию | Описание                                              |
| ------------------- | ---- | ------------ | ----------------------------------------------------- |
| `connection_string` | str  | `":memory:"` | Строка подключения к базе данных. См. форматы ниже.  |

**Базовые форматы**

| Формат                    | Описание                                  |
| ------------------------- | ----------------------------------------- |
| `":memory:"`              | База данных в памяти (по умолчанию)       |
| `"test.db"`               | Файл базы данных по относительному пути   |
| `"file:test.db"`          | То же, что и относительный путь           |
| `"/path/to/test.db"`      | Файл базы данных по абсолютному пути      |
| `"file:/path/to/test.db"` | То же, что и абсолютный путь              |

**С параметрами запроса**

| Формат                                             | Описание                              |
| -------------------------------------------------- | ------------------------------------- |
| `"file:test.db?param1=value1&param2=value2"`       | Относительный путь с параметрами      |
| `"file::memory:?verbose&log-level=test"`           | В памяти с параметрами                |
| `"///path/to/test.db?param1=value1&param2=value2"` | Абсолютный путь с параметрами         |

**Обработка параметров запроса**

Параметры запроса передаются движку ClickHouse в качестве аргументов запуска.
Специальная обработка параметров:

| Специальный параметр | Преобразуется в | Описание                           |
| -------------------- | --------------- | ---------------------------------- |
| `mode=ro`            | `--readonly=1`  | Режим только для чтения            |
| `verbose`            | (флаг)          | Включает подробное логирование     |
| `log-level=test`     | (настройка)     | Устанавливает уровень логирования  |

Полный список параметров см. в `clickhouse local --help --verbose`

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                                                                                                                                                                                                                                      |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Connection`               | Объект подключения к базе данных, который поддерживает:<br/>• Создание курсоров с помощью `Connection.cursor()`<br/>• Прямые запросы с помощью `Connection.query()`<br/>• Потоковые запросы с помощью `Connection.send_query()`<br/>• Протокол менеджера контекста для автоматической очистки |

**Исключения**

| Исключение     | Условие                                  |
| -------------- | ---------------------------------------- |
| `RuntimeError` | Если не удалось подключиться к базе данных |

:::warning
Поддерживается только одно подключение на процесс.
Создание нового подключения закроет любое существующее подключение.
:::

**Примеры**

```pycon
>>> # База данных в памяти
>>> conn = connect()
>>> conn = connect(":memory:")
>>>
>>> # Файловая база данных
>>> conn = connect("my_data.db")
>>> conn = connect("/path/to/data.db")
>>>
>>> # С параметрами
>>> conn = connect("data.db?mode=ro")  # Режим только для чтения
>>> conn = connect(":memory:?verbose&log-level=debug")  # Отладочное логирование
>>>
>>> # Использование менеджера контекста для автоматической очистки
>>> with connect("data.db") as conn:
...     result = conn.query("SELECT 1")
...     print(result)
>>> # Подключение автоматически закрыто
```

**См. также**

- [`Connection`](#chdb-state-sqlitelike-connection) — класс подключения к базе данных
- [`Cursor`](#chdb-state-sqlitelike-cursor) — курсор базы данных для операций DB-API 2.0


## Обработка исключений {#chdb-exceptions}

### **класс** `chdb.ChdbError` {#chdb_chdbError}

Базовый класс: `Exception`

Базовый класс исключений для ошибок, связанных с chDB.

Это исключение возникает при сбое выполнения запроса chDB или при возникновении
ошибки. Оно наследуется от стандартного класса Python Exception и
предоставляет информацию об ошибках из базового движка ClickHouse.

---

### **класс** `chdb.session.Session` {#chdb_session_session}

Базовый класс: `object`

Сессия сохраняет состояние запроса.
Если path равен None, будет создан временный каталог, который будет использоваться в качестве пути к базе данных,
и временный каталог будет удален при закрытии сессии.
Вы также можете передать путь для создания базы данных по этому пути, где будут храниться ваши данные.

Вы также можете использовать строку подключения для передачи пути и других параметров.

```python
class chdb.session.Session(path=None)
```

**Примеры**

| Строка подключения                                 | Описание                             |
| -------------------------------------------------- | ------------------------------------ |
| `":memory:"`                                       | База данных в памяти                 |
| `"test.db"`                                        | Относительный путь                   |
| `"file:test.db"`                                   | То же, что и выше                    |
| `"/path/to/test.db"`                               | Абсолютный путь                      |
| `"file:/path/to/test.db"`                          | То же, что и выше                    |
| `"file:test.db?param1=value1&param2=value2"`       | Относительный путь с параметрами запроса |
| `"file::memory:?verbose&log-level=test"`           | База данных в памяти с параметрами запроса |
| `"///path/to/test.db?param1=value1&param2=value2"` | Абсолютный путь с параметрами запроса |

:::note Обработка аргументов строки подключения
Строки подключения, содержащие параметры запроса, такие как "[file:test.db?param1=value1&param2=value2](file:test.db?param1=value1&param2=value2)",
"param1=value1" будут переданы движку ClickHouse в качестве аргументов запуска.

Для получения дополнительной информации см. `clickhouse local –help –verbose`

Обработка некоторых специальных аргументов:

- "mode=ro" будет преобразовано в "–readonly=1" для clickhouse (режим только для чтения)
  :::

:::warning Важно

- Одновременно может существовать только одна сессия. Если вы хотите создать новую сессию, необходимо закрыть существующую.
- Создание новой сессии закроет существующую.
  :::

---

#### `cleanup` {#cleanup}

Очистка ресурсов сессии с обработкой исключений.

Этот метод пытается закрыть сессию, подавляя любые исключения,
которые могут возникнуть в процессе очистки. Он особенно полезен в
сценариях обработки ошибок или когда необходимо обеспечить выполнение очистки независимо
от состояния сессии.

**Синтаксис**

```python
cleanup()
```

:::note
Этот метод никогда не вызовет исключение, что делает его безопасным для вызова в
блоках finally или деструкторах.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>> try:
...     session.query("INVALID SQL")
... finally:
...     session.cleanup()  # Безопасная очистка независимо от ошибок
```

**См. также**

- [`close()`](#chdb-session-session-close) - Для явного закрытия сессии с распространением ошибок

---

#### `close` {#close}

Закрытие сессии и очистка ресурсов.

Этот метод закрывает базовое соединение и сбрасывает глобальное состояние сессии.
После вызова этого метода сессия становится недействительной и не может использоваться для
дальнейших запросов.

**Синтаксис**

```python
close()
```

:::note
Этот метод автоматически вызывается, когда сессия используется в качестве контекстного менеджера
или когда объект сессии уничтожается.
:::

:::warning Важно
Любая попытка использовать сессию после вызова `close()` приведет к ошибке.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>> session.query("SELECT 1")
>>> session.close()  # Явное закрытие сессии
```

---

#### `query` {#chdb-session-session-query}

Выполнение SQL-запроса и возврат результатов.

Этот метод выполняет SQL-запрос к базе данных сессии и возвращает
результаты в указанном формате. Метод поддерживает различные форматы вывода
и сохраняет состояние сессии между запросами.

**Синтаксис**

```python
query(sql, fmt='CSV', udf_path='')
```

**Параметры**


| Параметр   | Тип  | По умолчанию | Описание                                                                                                                                                                                                                                                                                                                         |
| ---------- | ---- | ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sql`      | str  | _обязательный_ | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                                                                         |
| `fmt`      | str  | `"CSV"`    | Формат вывода результатов. Доступные форматы:<br/>• `"CSV"` — значения, разделённые запятыми<br/>• `"JSON"` — формат JSON<br/>• `"TabSeparated"` — значения, разделённые табуляцией<br/>• `"Pretty"` — форматированная таблица<br/>• `"JSONCompact"` — компактный формат JSON<br/>• `"Arrow"` — формат Apache Arrow<br/>• `"Parquet"` — формат Parquet |
| `udf_path` | str  | `""`       | Путь к пользовательским функциям. Если не указан, используется путь UDF из инициализации сессии                                                                                                                                                                                                                                     |

**Возвращаемое значение**

Возвращает результаты запроса в указанном формате.
Точный тип возвращаемого значения зависит от параметра формата:

- Строковые форматы (CSV, JSON и т. д.) возвращают str
- Бинарные форматы (Arrow, Parquet) возвращают bytes

**Исключения**

| Исключение     | Условие                              |
| -------------- | ------------------------------------ |
| `RuntimeError` | Если сессия закрыта или недействительна |
| `ValueError`   | Если SQL-запрос некорректен          |

:::note
Формат "Debug" не поддерживается и будет автоматически преобразован
в "CSV" с предупреждением.
Для отладки используйте параметры строки подключения.
:::

:::warning Предупреждение
Этот метод выполняет запрос синхронно и загружает все результаты в
память. Для больших наборов результатов используйте [`send_query()`](#chdb-session-session-send_query) для
потоковой передачи результатов.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>>
>>> # Базовый запрос с форматом CSV по умолчанию
>>> result = session.query("SELECT 1 as number")
>>> print(result)
number
1
```

```pycon
>>> # Запрос с форматом JSON
>>> result = session.query("SELECT 1 as number", fmt="JSON")
>>> print(result)
{"number": "1"}
```

```pycon
>>> # Сложный запрос с созданием таблицы
>>> session.query("CREATE TABLE test (id INT, name String) ENGINE = Memory")
>>> session.query("INSERT INTO test VALUES (1, 'Alice'), (2, 'Bob')")
>>> result = session.query("SELECT * FROM test ORDER BY id")
>>> print(result)
id,name
1,Alice
2,Bob
```

**См. также**

- [`send_query()`](#chdb-session-session-send_query) — для потокового выполнения запросов
- [`sql`](#chdb-session-session-sql) — псевдоним для этого метода

---

#### `send_query` {#chdb-session-session-send_query}

Выполнить SQL-запрос и вернуть итератор потоковых результатов.

Этот метод выполняет SQL-запрос к базе данных сессии и возвращает
объект потоковых результатов, который позволяет перебирать результаты без
загрузки всего в память сразу. Это особенно полезно для больших
наборов результатов.

**Синтаксис**

```python
send_query(sql, fmt='CSV') → StreamingResult
```

**Параметры**

| Параметр  | Тип  | По умолчанию | Описание                                                                                                                                                                                                                                                                          |
| --------- | ---- | ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `sql`     | str  | _обязательный_ | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                          |
| `fmt`     | str  | `"CSV"`    | Формат вывода результатов. Доступные форматы:<br/>• `"CSV"` — значения, разделённые запятыми<br/>• `"JSON"` — формат JSON<br/>• `"TabSeparated"` — значения, разделённые табуляцией<br/>• `"JSONCompact"` — компактный формат JSON<br/>• `"Arrow"` — формат Apache Arrow<br/>• `"Parquet"` — формат Parquet |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                                                                                                      |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| `StreamingResult` | Итератор потоковых результатов, который возвращает результаты запроса инкрементально. Итератор может использоваться в циклах for или преобразовываться в другие структуры данных |

**Исключения**

| Исключение     | Условие                              |
| -------------- | ------------------------------------ |
| `RuntimeError` | Если сессия закрыта или недействительна |
| `ValueError`   | Если SQL-запрос некорректен          |

:::note
The “Debug” format is not supported and will be automatically converted
to “CSV” with a warning. For debugging, use connection string parameters instead.
:::

:::warning
Возвращаемый объект StreamingResult следует использовать незамедлительно или хранить надлежащим образом, так как он поддерживает соединение с базой данных.
:::

**Примеры**


```pycon
>>> session = Session("test.db")
>>> session.query("CREATE TABLE big_table (id INT, data String) ENGINE = MergeTree() order by id")
>>>
>>> # Вставка большого набора данных
>>> for i in range(1000):
...     session.query(f"INSERT INTO big_table VALUES ({i}, 'data_{i}')")
>>>
>>> # Потоковая обработка результатов для предотвращения проблем с памятью
>>> streaming_result = session.send_query("SELECT * FROM big_table ORDER BY id")
>>> for chunk in streaming_result:
...     print(f"Processing chunk: {len(chunk)} bytes")
...     # Обработка фрагмента без загрузки всего набора результатов в память
```

```pycon
>>> # Использование с менеджером контекста
>>> with session.send_query("SELECT COUNT(*) FROM big_table") as stream:
...     for result in stream:
...         print(f"Count result: {result}")
```

**См. также**

- [`query()`](#chdb-session-session-query) — для выполнения запросов без потоковой передачи
- `chdb.state.sqlitelike.StreamingResult` — итератор потоковых результатов

---

#### `sql` {#chdb-session-session-sql}

Выполняет SQL-запрос и возвращает результаты.

Этот метод выполняет SQL-запрос к базе данных сессии и возвращает
результаты в указанном формате. Метод поддерживает различные форматы вывода
и сохраняет состояние сессии между запросами.

**Синтаксис**

```python
sql(sql, fmt='CSV', udf_path='')
```

**Параметры**

| Параметр   | Тип  | По умолчанию | Описание                                                                                                                                                                                                                                                                                                                                    |
| ---------- | ---- | ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sql`      | str  | _обязательный_ | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                                                                           |
| `fmt`      | str  | `"CSV"`      | Формат вывода результатов. Доступные форматы:<br/>• `"CSV"` — значения, разделенные запятыми<br/>• `"JSON"` — формат JSON<br/>• `"TabSeparated"` — значения, разделенные табуляцией<br/>• `"Pretty"` — форматированная таблица<br/>• `"JSONCompact"` — компактный формат JSON<br/>• `"Arrow"` — формат Apache Arrow<br/>• `"Parquet"` — формат Parquet |
| `udf_path` | str  | `""`         | Путь к пользовательским функциям. Если не указан, используется путь UDF из инициализации сессии                                                                                                                                                                                                                                             |

**Возвращаемое значение**

Возвращает результаты запроса в указанном формате.
Точный тип возвращаемого значения зависит от параметра формата:

- Строковые форматы (CSV, JSON и т. д.) возвращают str
- Бинарные форматы (Arrow, Parquet) возвращают bytes

**Исключения:**

| Исключение     | Условие                                  |
| -------------- | ---------------------------------------- |
| `RuntimeError` | Если сессия закрыта или недействительна  |
| `ValueError`   | Если SQL-запрос имеет неверный формат    |

:::note
Формат "Debug" не поддерживается и будет автоматически преобразован
в "CSV" с предупреждением. Для отладки используйте параметры строки подключения.
:::

:::warning Предупреждение
Этот метод выполняет запрос синхронно и загружает все результаты в
память.
Для больших наборов результатов рекомендуется использовать [`send_query()`](#chdb-session-session-send_query) для потоковой передачи результатов.
:::

**Примеры**

```pycon
>>> session = Session("test.db")
>>>
>>> # Базовый запрос с форматом CSV по умолчанию
>>> result = session.query("SELECT 1 as number")
>>> print(result)
number
1
```

```pycon
>>> # Запрос с форматом JSON
>>> result = session.query("SELECT 1 as number", fmt="JSON")
>>> print(result)
{"number": "1"}
```

```pycon
>>> # Сложный запрос с созданием таблицы
>>> session.query("CREATE TABLE test (id INT, name String) ENGINE = MergeTree() order by id")
>>> session.query("INSERT INTO test VALUES (1, 'Alice'), (2, 'Bob')")
>>> result = session.query("SELECT * FROM test ORDER BY id")
>>> print(result)
id,name
1,Alice
2,Bob
```

**См. также**

- [`send_query()`](#chdb-session-session-send_query) — для выполнения запросов с потоковой передачей
- [`sql`](#chdb-session-session-sql) — псевдоним для этого метода


## Управление состоянием {#chdb-state-management}

### `chdb.state.connect` {#chdb_state_connect}

Создает [Connection](#chdb-state-sqlitelike-connection) к фоновому серверу chDB.

Эта функция устанавливает соединение с движком базы данных chDB (ClickHouse).
Для каждого процесса допускается только одно открытое соединение. Повторные вызовы с одной и той же
строкой подключения будут возвращать один и тот же объект соединения.

**Синтаксис**

```python
chdb.state.connect(connection_string: str = ':memory:') → Connection
```

**Параметры**

| Параметр                           | Тип  | По умолчанию | Описание                                       |
| ---------------------------------- | ---- | ------------ | ---------------------------------------------- |
| `connection_string(str, optional)` | str  | `":memory:"` | Строка подключения к базе данных. См. форматы ниже. |

**Базовые форматы**

Поддерживаемые форматы строк подключения:

| Формат                    | Описание                     |
| ------------------------- | ---------------------------- |
| `":memory:"`              | База данных в памяти (по умолчанию) |
| `"test.db"`               | Файл базы данных с относительным путем |
| `"file:test.db"`          | То же, что и относительный путь |
| `"/path/to/test.db"`      | Файл базы данных с абсолютным путем |
| `"file:/path/to/test.db"` | То же, что и абсолютный путь |

**С параметрами запроса**

| Формат                                             | Описание                  |
| -------------------------------------------------- | ------------------------- |
| `"file:test.db?param1=value1&param2=value2"`       | Относительный путь с параметрами |
| `"file::memory:?verbose&log-level=test"`           | В памяти с параметрами    |
| `"///path/to/test.db?param1=value1&param2=value2"` | Абсолютный путь с параметрами |

**Обработка параметров запроса**

Параметры запроса передаются движку ClickHouse в качестве аргументов запуска.
Специальная обработка параметров:

| Специальный параметр | Преобразуется в | Описание             |
| -------------------- | --------------- | -------------------- |
| `mode=ro`            | `--readonly=1`  | Режим только для чтения |
| `verbose`            | (флаг)          | Включает подробное логирование |
| `log-level=test`     | (настройка)     | Устанавливает уровень логирования |

Полный список параметров см. в `clickhouse local --help --verbose`

**Возвращаемое значение**

| Тип возврата | Описание                                                                                                                                                                                                                                               |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Connection` | Объект подключения к базе данных, который поддерживает:<br/>• Создание курсоров с помощью `Connection.cursor()`<br/>• Прямые запросы с помощью `Connection.query()`<br/>• Потоковые запросы с помощью `Connection.send_query()`<br/>• Протокол менеджера контекста для автоматической очистки |

**Исключения**

| Исключение     | Условие                         |
| -------------- | ------------------------------- |
| `RuntimeError` | Если не удалось подключиться к базе данных |

:::warning Предупреждение
Поддерживается только одно соединение на процесс.
Создание нового соединения закроет любое существующее соединение.
:::

**Примеры**

```pycon
>>> # База данных в памяти
>>> conn = connect()
>>> conn = connect(":memory:")
>>>
>>> # Файловая база данных
>>> conn = connect("my_data.db")
>>> conn = connect("/path/to/data.db")
>>>
>>> # С параметрами
>>> conn = connect("data.db?mode=ro")  # Режим только для чтения
>>> conn = connect(":memory:?verbose&log-level=debug")  # Отладочное логирование
>>>
>>> # Использование менеджера контекста для автоматической очистки
>>> with connect("data.db") as conn:
...     result = conn.query("SELECT 1")
...     print(result)
>>> # Соединение автоматически закрыто
```

**См. также**

- `Connection` — класс подключения к базе данных
- `Cursor` — курсор базы данных для операций DB-API 2.0

### **class** `chdb.state.sqlitelike.Connection` {#chdb-state-sqlitelike-connection}

Базовый класс: `object`

**Синтаксис**

```python
class chdb.state.sqlitelike.Connection(connection_string: str)
```

---

#### `close` {#chdb-session-session-close}

Закрывает соединение и освобождает ресурсы.

Этот метод закрывает соединение с базой данных и освобождает все связанные
ресурсы, включая активные курсоры. После вызова этого метода
соединение становится недействительным и не может использоваться для дальнейших операций.

**Синтаксис**

```python
close() → None
```

:::note
Этот метод идемпотентен — его можно безопасно вызывать несколько раз.
:::

:::warning Предупреждение
Все выполняющиеся потоковые запросы будут отменены при закрытии соединения.
Убедитесь, что все важные данные обработаны перед закрытием.
:::

**Примеры**

```pycon
>>> conn = connect("test.db")
>>> # Использование соединения для запросов
>>> conn.query("CREATE TABLE test (id INT) ENGINE = Memory")
>>> # Закрытие по завершении
>>> conn.close()
```


```pycon
>>> # Использование с менеджером контекста (автоматическая очистка)
>>> with connect("test.db") as conn:
...     conn.query("SELECT 1")
...     # Соединение закрывается автоматически
```

---

#### `cursor` {#chdb-state-sqlitelike-connection-cursor}

Создает объект [Cursor](#chdb-state-sqlitelike-cursor) для выполнения запросов.

Этот метод создает курсор базы данных, предоставляющий стандартный
интерфейс DB-API 2.0 для выполнения запросов и получения результатов.
Курсор обеспечивает детальный контроль над выполнением запросов
и получением результатов.

**Синтаксис**

```python
cursor() → Cursor
```

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                  |
| -------------------------- | ----------------------------------------- |
| `Cursor`                   | Объект курсора для операций с базой данных |

:::note
Создание нового курсора заменит любой существующий курсор, связанный
с данным соединением. Поддерживается только один курсор на соединение.
:::

**Примеры**

```pycon
>>> conn = connect(":memory:")
>>> cursor = conn.cursor()
>>> cursor.execute("CREATE TABLE test (id INT, name String) ENGINE = Memory")
>>> cursor.execute("INSERT INTO test VALUES (1, 'Alice')")
>>> cursor.execute("SELECT * FROM test")
>>> rows = cursor.fetchall()
>>> print(rows)
((1, 'Alice'),)
```

**См. также**

- [`Cursor`](#chdb-state-sqlitelike-cursor) — реализация курсора базы данных

---

#### `query` {#chdb-state-sqlitelike-connection-query}

Выполняет SQL-запрос и возвращает полные результаты.

Этот метод синхронно выполняет SQL-запрос и возвращает полный
набор результатов. Он поддерживает различные форматы вывода и автоматически применяет
постобработку в зависимости от формата.

**Синтаксис**

```python
query(query: str, format: str = 'CSV') → Any
```

**Параметры:**

| Параметр | Тип | По умолчанию | Описание                                                                                                                                                                                                                                                                                        |
| -------- | --- | ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `query`  | str | _обязательно_ | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                               |
| `format` | str | `"CSV"`      | Формат вывода результатов. Поддерживаемые форматы:<br/>• `"CSV"` — значения, разделенные запятыми (строка)<br/>• `"JSON"` — формат JSON (строка)<br/>• `"Arrow"` — формат Apache Arrow (байты)<br/>• `"Dataframe"` — Pandas DataFrame (требуется pandas)<br/>• `"Arrowtable"` — PyArrow Table (требуется pyarrow) |

**Returns**

| Тип возвращаемого значения | Описание                           |
| -------------------------- | ---------------------------------- |
| `str`                      | Для строковых форматов (CSV, JSON) |
| `bytes`                    | Для формата Arrow                  |
| `pandas.DataFrame`         | Для формата dataframe              |
| `pyarrow.Table`            | Для формата arrowtable             |

**Исключения**

| Исключение     | Условие                                                  |
| -------------- | -------------------------------------------------------- |
| `RuntimeError` | Если выполнение запроса завершается с ошибкой            |
| `ImportError`  | Если необходимые пакеты для формата не установлены       |

:::warning Предупреждение
Этот метод загружает весь набор результатов в память. Для больших
результатов рекомендуется использовать [`send_query()`](#chdb-state-sqlitelike-connection-send_query) для потоковой передачи.
:::

**Примеры**

```pycon
>>> conn = connect(":memory:")
>>>
>>> # Базовый CSV-запрос
>>> result = conn.query("SELECT 1 as num, 'hello' as text")
>>> print(result)
num,text
1,hello
```

```pycon
>>> # Формат DataFrame
>>> df = conn.query("SELECT number FROM numbers(5)", "dataframe")
>>> print(df)
   number
0       0
1       1
2       2
3       3
4       4
```

**See also**

- [`send_query()`](#chdb-state-sqlitelike-connection-send_query) — для потокового выполнения запросов

---

#### `send_query` {#chdb-state-sqlitelike-connection-send_query}

Выполняет SQL-запрос и возвращает итератор потоковых результатов.

Этот метод выполняет SQL-запрос и возвращает объект StreamingResult,
который позволяет итерировать по результатам без загрузки всех данных
в память одновременно. Это идеально подходит для обработки больших наборов результатов.

**Синтаксис**

```python
send_query(query: str, format: str = 'CSV') → StreamingResult
```

**Параметры**


| Параметр | Тип | По умолчанию    | Описание                                                                                                                                                                                                                                                                       |
| --------- | ---- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `query`   | str  | _обязательный_ | Строка SQL-запроса для выполнения                                                                                                                                                                                                                                                                       |
| `format`  | str  | `"CSV"`    | Формат вывода результатов. Поддерживаемые форматы:<br/>• `"CSV"` — значения, разделённые запятыми<br/>• `"JSON"` — формат JSON<br/>• `"Arrow"` — формат Apache Arrow (включает метод record_batch())<br/>• `"dataframe"` — фрагменты Pandas DataFrame<br/>• `"arrowtable"` — фрагменты PyArrow Table |

**Возвращаемое значение**

| Тип возвращаемого значения       | Описание                                                                                                                                                                                                                                  |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `StreamingResult` | Потоковый итератор для результатов запроса, который поддерживает:<br/>• Протокол итератора (циклы for)<br/>• Протокол контекстного менеджера (операторы with)<br/>• Ручное извлечение с помощью метода fetch()<br/>• Потоковую передачу PyArrow RecordBatch (только для формата Arrow) |

**Исключения**

| Исключение      | Условие                                         |
| -------------- | ------------------------------------------------- |
| `RuntimeError` | Если выполнение запроса завершается неудачей                          |
| `ImportError`  | Если необходимые пакеты для формата не установлены |

:::note
Только формат "Arrow" поддерживает метод `record_batch()` для возвращаемого StreamingResult.
:::

**Примеры**

```pycon
>>> conn = connect(":memory:")
>>>
>>> # Базовая потоковая передача
>>> stream = conn.send_query("SELECT number FROM numbers(1000)")
>>> for chunk in stream:
...     print(f"Обработка фрагмента: {len(chunk)} байт")
```

```pycon
>>> # Использование контекстного менеджера для очистки
>>> with conn.send_query("SELECT * FROM large_table") as stream:
...     chunk = stream.fetch()
...     while chunk:
...         process_data(chunk)
...         chunk = stream.fetch()
```

```pycon
>>> # Формат Arrow с потоковой передачей RecordBatch
>>> stream = conn.send_query("SELECT * FROM data", "Arrow")
>>> reader = stream.record_batch(rows_per_batch=10000)
>>> for batch in reader:
...     print(f"Размер пакета: {batch.num_rows} x {batch.num_columns}")
```

**См. также**

- [`query()`](#chdb-state-sqlitelike-connection-query) — для выполнения запросов без потоковой передачи
- `StreamingResult` — итератор потоковых результатов

---

### **class** `chdb.state.sqlitelike.Cursor` {#chdb-state-sqlitelike-cursor}

Базовый класс: `object`

```python
class chdb.state.sqlitelike.Cursor(connection)
```

---

#### `close` {#cursor-close-none}

Закрыть курсор и освободить ресурсы.

Этот метод закрывает курсор и освобождает все связанные ресурсы.
После вызова этого метода курсор становится недействительным и не может
использоваться для дальнейших операций.

**Синтаксис**

```python
close() → None
```

:::note
Этот метод идемпотентен — его многократный вызов безопасен.
Курсор также автоматически закрывается при закрытии соединения.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT 1")
>>> result = cursor.fetchone()
>>> cursor.close()  # Освобождение ресурсов курсора
```

---

#### `column_names` {#chdb-state-sqlitelike-cursor-column_names}

Вернуть список имён столбцов из последнего выполненного запроса.

Этот метод возвращает имена столбцов из последнего выполненного
запроса SELECT. Имена возвращаются в том же порядке, в котором они
появляются в наборе результатов.

**Синтаксис**

```python
column_names() → list
```

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                                                               |
| ----------- | --------------------------------------------------------------------------------------------------------- |
| `list`      | Список строк с именами столбцов или пустой список, если запрос не был выполнен или запрос не вернул столбцов |

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT id, name, email FROM users LIMIT 1")
>>> print(cursor.column_names())
['id', 'name', 'email']
```

**See also**

- [`column_types()`](#chdb-state-sqlitelike-cursor-column_types) — получить информацию о типах столбцов
- [`description`](#chdb-state-sqlitelike-cursor-description) — описание столбцов DB-API 2.0

---

#### `column_types` {#chdb-state-sqlitelike-cursor-column_types}

Вернуть список типов столбцов из последнего выполненного запроса.

Этот метод возвращает имена типов столбцов ClickHouse из последнего
выполненного запроса SELECT. Типы возвращаются в том же порядке,
в котором они появляются в наборе результатов.

**Синтаксис**

```python
column_types() → list
```

**Возвращаемое значение**


| Тип возвращаемого значения | Описание                                                                                                        |
| ----------- | ------------------------------------------------------------------------------------------------------------------ |
| `list`      | Список строк с именами типов ClickHouse или пустой список, если запрос не выполнялся или не вернул столбцов |

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT toInt32(1), toString('hello')")
>>> print(cursor.column_types())
['Int32', 'String']
```

**См. также**

- [`column_names()`](#chdb-state-sqlitelike-cursor-column_names) - Получение информации об именах столбцов
- [`description`](#chdb-state-sqlitelike-cursor-description) - Описание столбцов DB-API 2.0

---

#### `commit` {#commit}

Фиксация незавершенной транзакции.

Этот метод фиксирует любую незавершенную транзакцию базы данных. В ClickHouse
большинство операций фиксируются автоматически, но этот метод предоставляется для
совместимости с DB-API 2.0.

:::note
ClickHouse обычно автоматически фиксирует операции, поэтому явная фиксация
обычно не требуется. Этот метод предоставляется для совместимости
со стандартным рабочим процессом DB-API 2.0.
:::

**Синтаксис**

```python
commit() → None
```

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("INSERT INTO test VALUES (1, 'data')")
>>> cursor.commit()
```

---

#### `property description : list` {#chdb-state-sqlitelike-cursor-description}

Возврат описания столбцов в соответствии со спецификацией DB-API 2.0.

Это свойство возвращает список кортежей из 7 элементов, описывающих каждый столбец
в наборе результатов последнего выполненного запроса SELECT. Каждый кортеж содержит:
(name, type_code, display_size, internal_size, precision, scale, null_ok)

В настоящее время предоставляются только name и type_code, остальные поля имеют значение None.

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                                                 |
| ----------- | ------------------------------------------------------------------------------------------- |
| `list`      | Список кортежей из 7 элементов, описывающих каждый столбец, или пустой список, если запрос SELECT не выполнялся |

:::note
Это соответствует спецификации DB-API 2.0 для cursor.description.
В данной реализации только первые два элемента (name и type_code) содержат
значимые данные.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT id, name FROM users LIMIT 1")
>>> for desc in cursor.description:
...     print(f"Столбец: {desc[0]}, Тип: {desc[1]}")
Столбец: id, Тип: Int32
Столбец: name, Тип: String
```

**См. также**

- [`column_names()`](#chdb-state-sqlitelike-cursor-column_names) - Получение только имен столбцов
- [`column_types()`](#chdb-state-sqlitelike-cursor-column_types) - Получение только типов столбцов

---

#### `execute` {#execute}

Выполнение SQL-запроса и подготовка результатов для извлечения.

Этот метод выполняет SQL-запрос и подготавливает результаты для извлечения
с помощью методов fetch. Он обрабатывает разбор данных результата и
автоматическое преобразование типов данных ClickHouse.

**Синтаксис**

```python
execute(query: str) → None
```

**Параметры:**

| Параметр | Тип | Описание                 |
| --------- | ---- | --------------------------- |
| `query`   | str  | Строка SQL-запроса для выполнения |

**Исключения**

| Исключение   | Условие                                        |
| ----------- | ------------------------------------------------ |
| `Exception` | Если выполнение запроса или разбор результата завершились неудачей |

:::note
Этот метод соответствует спецификациям DB-API 2.0 для `cursor.execute()`.
После выполнения используйте `fetchone()`, `fetchmany()` или `fetchall()` для
извлечения результатов.
:::

:::note
Метод автоматически преобразует типы данных ClickHouse в соответствующие
типы Python:

- Типы Int/UInt → int
- Типы Float → float
- String/FixedString → str
- DateTime → datetime.datetime
- Date → datetime.date
- Bool → bool
  :::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>>
>>> # Выполнение DDL
>>> cursor.execute("CREATE TABLE test (id INT, name String) ENGINE = Memory")
>>>
>>> # Выполнение DML
>>> cursor.execute("INSERT INTO test VALUES (1, 'Alice')")
>>>
>>> # Выполнение SELECT и извлечение результатов
>>> cursor.execute("SELECT * FROM test")
>>> rows = cursor.fetchall()
>>> print(rows)
((1, 'Alice'),)
```

**См. также**

- [`fetchone()`](#chdb-state-sqlitelike-cursor-fetchone) - Извлечение одной строки
- [`fetchmany()`](#chdb-state-sqlitelike-cursor-fetchmany) - Извлечение нескольких строк
- [`fetchall()`](#chdb-state-sqlitelike-cursor-fetchall) - Извлечение всех оставшихся строк


---

#### `fetchall` {#chdb-state-sqlitelike-cursor-fetchall}

Получение всех оставшихся строк из результата запроса.

Этот метод извлекает все оставшиеся строки из текущего набора результатов запроса,
начиная с текущей позиции курсора. Возвращает кортеж кортежей строк
с соответствующим преобразованием типов Python.

**Синтаксис**

```python
fetchall() → tuple
```

**Возвращаемое значение:**

| Тип возвращаемого значения | Описание |
|-------------|-------------|
| `tuple` | Кортеж, содержащий все оставшиеся кортежи строк из набора результатов. Возвращает пустой кортеж, если строки отсутствуют |

:::warning Предупреждение
Этот метод загружает все оставшиеся строки в память одновременно. Для больших
наборов результатов рекомендуется использовать [`fetchmany()`](#chdb-state-sqlitelike-cursor-fetchmany) для обработки результатов
пакетами.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT id, name FROM users")
>>> all_users = cursor.fetchall()
>>> for user_id, user_name in all_users:
...     print(f"User {user_id}: {user_name}")
```

**См. также**
- [`fetchone()`](#chdb-state-sqlitelike-cursor-fetchone) — получение одной строки
- [`fetchmany()`](#chdb-state-sqlitelike-cursor-fetchmany) — получение нескольких строк пакетами

---

#### `fetchmany` {#chdb-state-sqlitelike-cursor-fetchmany}

Получение нескольких строк из результата запроса.

Этот метод извлекает до `size` строк из текущего набора результатов запроса.
Возвращает кортеж кортежей строк, где каждая строка содержит значения столбцов
с соответствующим преобразованием типов Python.

**Синтаксис**

```python
fetchmany(size: int = 1) → tuple
```

**Параметры**

| Параметр | Тип | По умолчанию | Описание                     |
| --------- | ---- | ------- | ------------------------------- |
| `size`    | int  | `1`     | Максимальное количество строк для получения |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                                                     |
| ----------- | ----------------------------------------------------------------------------------------------- |
| `tuple`     | Кортеж, содержащий до `size` кортежей строк. Может содержать меньше строк, если набор результатов исчерпан |

:::note
Этот метод соответствует спецификации DB-API 2.0. Он вернёт меньше
строк, чем `size`, если набор результатов исчерпан.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT * FROM large_table")
>>>
>>> # Обработка результатов пакетами
>>> while True:
...     batch = cursor.fetchmany(100)  # Получение 100 строк за раз
...     if not batch:
...         break
...     process_batch(batch)
```

**См. также**

- [`fetchone()`](#chdb-state-sqlitelike-cursor-fetchone) — получение одной строки
- [`fetchall()`](#chdb-state-sqlitelike-cursor-fetchall) — получение всех оставшихся строк

---

#### `fetchone` {#chdb-state-sqlitelike-cursor-fetchone}

Получение следующей строки из результата запроса.

Этот метод извлекает следующую доступную строку из текущего набора
результатов запроса. Возвращает кортеж, содержащий значения столбцов
с соответствующим преобразованием типов Python.

**Синтаксис**

```python
fetchone() → tuple | None
```

**Возвращаемое значение:**

| Тип возвращаемого значения       | Описание                                                                 |
| ----------------- | --------------------------------------------------------------------------- |
| `Optional[tuple]` | Следующая строка в виде кортежа значений столбцов или `None`, если больше нет доступных строк |

:::note
Этот метод соответствует спецификации DB-API 2.0. Значения столбцов
автоматически преобразуются в соответствующие типы Python на основе
типов столбцов ClickHouse.
:::

**Примеры**

```pycon
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT id, name FROM users")
>>> row = cursor.fetchone()
>>> while row is not None:
...     user_id, user_name = row
...     print(f"User {user_id}: {user_name}")
...     row = cursor.fetchone()
```

**См. также**

- [`fetchmany()`](#chdb-state-sqlitelike-cursor-fetchmany) — получение нескольких строк
- [`fetchall()`](#chdb-state-sqlitelike-cursor-fetchall) — получение всех оставшихся строк

---

### `chdb.state.sqlitelike` {#state-sqlitelike-to_arrowtable}

Преобразование результата запроса в PyArrow Table.

Эта функция преобразует результаты запросов chdb в формат PyArrow Table,
который обеспечивает эффективный доступ к столбцовым данным и совместимость
с другими библиотеками обработки данных.

**Синтаксис**

```python
chdb.state.sqlitelike.to_arrowTable(res)
```

**Параметры:**


| Параметр | Тип | Описание                                                |
| --------- | ---- | ---------------------------------------------------------- |
| `res`     | -    | Объект результата запроса из chdb, содержащий данные в формате Arrow |

**Возвращаемое значение**

| Тип возвращаемого значения     | Описание                                |
| --------------- | ------------------------------------------ |
| `pyarrow.Table` | Таблица PyArrow, содержащая результаты запроса |

**Исключения**

| Исключение     | Условие                                       |
| ------------- | ----------------------------------------------- |
| `ImportError` | Если пакеты pyarrow или pandas не установлены |

:::note
Для работы этой функции требуется установка пакетов pyarrow и pandas.
Установите их с помощью команды: `pip install pyarrow pandas`
:::

:::warning Предупреждение
Пустые результаты возвращают пустую таблицу PyArrow без схемы.
:::

**Примеры**

```pycon
>>> import chdb
>>> result = chdb.query("SELECT 1 as num, 'hello' as text", "Arrow")
>>> table = to_arrowTable(result)
>>> print(table.schema)
num: int64
text: string
>>> print(table.to_pandas())
   num   text
0    1  hello
```

---

### `chdb.state.sqlitelike.to_df` {#state-sqlitelike-to_df}

Преобразование результата запроса в Pandas DataFrame.

Эта функция преобразует результаты запросов chdb в формат Pandas DataFrame,
сначала преобразуя их в таблицу PyArrow, а затем в DataFrame. Это обеспечивает
удобные возможности анализа данных с помощью API Pandas.

**Синтаксис**

```python
chdb.state.sqlitelike.to_df(r)
```

**Параметры:**

| Параметр | Тип | Описание                                                |
| --------- | ---- | ---------------------------------------------------------- |
| `r`       | -    | Объект результата запроса из chdb, содержащий данные в формате Arrow |

**Возвращаемое значение:**

| Тип возвращаемого значения        | Описание                                                                         |
| ------------------ | ----------------------------------------------------------------------------------- |
| `pandas.DataFrame` | DataFrame, содержащий результаты запроса с соответствующими именами столбцов и типами данных |

**Исключения**

| Исключение     | Условие                                       |
| ------------- | ----------------------------------------------- |
| `ImportError` | Если пакеты pyarrow или pandas не установлены |

:::note
Эта функция использует многопоточность для преобразования из Arrow в Pandas
с целью повышения производительности на больших наборах данных.
:::

**См. также**

- [`to_arrowTable()`](#chdb-state-sqlitelike-to_arrowtable) — для преобразования в формат таблицы PyArrow

**Примеры**

```pycon
>>> import chdb
>>> result = chdb.query("SELECT 1 as num, 'hello' as text", "Arrow")
>>> df = to_df(result)
>>> print(df)
   num   text
0    1  hello
>>> print(df.dtypes)
num      int64
text    object
dtype: object
```


## Интеграция DataFrame {#dataframe-integration}

### **class** `chdb.dataframe.Table` {#chdb-dataframe-table}

Базовые классы:

```python
class chdb.dataframe.Table(*args: Any, **kwargs: Any)
```


## Интерфейс Database API (DBAPI) 2.0 {#database-api-interface}

chDB предоставляет совместимый с Python DB-API 2.0 интерфейс для подключения к базе данных, позволяя использовать chDB с инструментами и фреймворками, которые ожидают стандартные интерфейсы баз данных.

Интерфейс chDB DB-API 2.0 включает:

- **Connections**: Управление подключениями к базе данных с помощью строк подключения
- **Cursors**: Выполнение запросов и получение результатов
- **Type System**: Константы типов и конвертеры, совместимые с DB-API 2.0
- **Error Handling**: Стандартная иерархия исключений базы данных
- **Thread Safety**: Потокобезопасность уровня 1 (потоки могут совместно использовать модули, но не подключения)

---

### Основные функции {#core-functions}

Интерфейс Database API (DBAPI) 2.0 реализует следующие основные функции:

#### `chdb.dbapi.connect` {#dbapi-connect}

Инициализирует новое подключение к базе данных.

**Синтаксис**

```python
chdb.dbapi.connect(*args, **kwargs)
```

**Параметры**

| Параметр | Тип | По умолчанию | Описание                                          |
| -------- | --- | ------------ | ------------------------------------------------- |
| `path`   | str | `None`       | Путь к файлу базы данных. None для базы данных в памяти |

**Исключения**

| Исключение                           | Условие                                     |
| ------------------------------------ | ------------------------------------------- |
| [`err.Error`](#chdb-dbapi-err-error) | Если не удается установить подключение     |

---

#### `chdb.dbapi.get_client_info()` {#dbapi-get-client-info}

Получает информацию о версии клиента.

Возвращает версию клиента chDB в виде строки для совместимости с MySQLdb.

**Синтаксис**

```python
chdb.dbapi.get_client_info()
```

**Возвращает**

| Тип возвращаемого значения | Описание                                    |
| -------------------------- | ------------------------------------------- |
| `str`                      | Строка версии в формате 'major.minor.patch' |

---

### Конструкторы типов {#type-constructors}

#### `chdb.dbapi.Binary(x)` {#dbapi-binary}

Возвращает x в виде бинарного типа.

Эта функция преобразует входные данные в тип bytes для использования с бинарными
полями базы данных в соответствии со спецификацией DB-API 2.0.

**Синтаксис**

```python
chdb.dbapi.Binary(x)
```

**Параметры**

| Параметр | Тип | Описание                                           |
| -------- | --- | -------------------------------------------------- |
| `x`      | -   | Входные данные для преобразования в бинарный тип  |

**Возвращает**

| Тип возвращаемого значения | Описание                                   |
| -------------------------- | ------------------------------------------ |
| `bytes`                    | Входные данные, преобразованные в bytes    |

---

### Класс Connection {#connection-class}

#### **class** `chdb.dbapi.connections.Connection(path=None)` {#chdb-dbapi-connections-connection}

Базовый класс: `object`

Подключение к базе данных chDB, совместимое с DB-API 2.0.

Этот класс предоставляет стандартный интерфейс DB-API для подключения и взаимодействия
с базами данных chDB. Он поддерживает как базы данных в памяти, так и файловые базы данных.

Подключение управляет базовым движком chDB и предоставляет методы для
выполнения запросов, управления транзакциями (не имеет эффекта для ClickHouse) и создания курсоров.

```python
class chdb.dbapi.connections.Connection(path=None)
```

**Параметры**

| Параметр | Тип | По умолчанию | Описание                                                                                                                                     |
| -------- | --- | ------------ | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `path`   | str | `None`       | Путь к файлу базы данных. Если None, используется база данных в памяти. Может быть путем к файлу, например 'database.db', или None для ':memory:' |

**Переменные**

| Переменная | Тип  | Описание                                                 |
| ---------- | ---- | -------------------------------------------------------- |
| `encoding` | str  | Кодировка символов для запросов, по умолчанию 'utf8'     |
| `open`     | bool | True, если подключение открыто, False, если закрыто     |

**Примеры**

```pycon
>>> # База данных в памяти
>>> conn = Connection()
>>> cursor = conn.cursor()
>>> cursor.execute("SELECT 1")
>>> result = cursor.fetchall()
>>> conn.close()
```

```pycon
>>> # Файловая база данных
>>> conn = Connection('mydata.db')
>>> with conn.cursor() as cur:
...     cur.execute("CREATE TABLE users (id INT, name STRING) ENGINE = MergeTree() order by id")
...     cur.execute("INSERT INTO users VALUES (1, 'Alice')")
>>> conn.close()
```

```pycon
>>> # Использование контекстного менеджера
>>> with Connection() as cur:
...     cur.execute("SELECT version()")
...     version = cur.fetchone()
```

:::note
ClickHouse не поддерживает традиционные транзакции, поэтому операции commit() и rollback()
не имеют эффекта, но предоставляются для соответствия DB-API.
:::

---

#### `close` {#dbapi-connection-close}


Закрыть соединение с базой данных.

Закрывает базовое соединение chDB и помечает это соединение как закрытое.
Последующие операции с этим соединением вызовут ошибку.

**Синтаксис**

```python
close()
```

**Исключения**

| Исключение                           | Условие                              |
| ------------------------------------ | ------------------------------------ |
| [`err.Error`](#chdb-dbapi-err-error) | Если соединение уже закрыто          |

---

#### `commit` {#dbapi-commit}

Зафиксировать текущую транзакцию.

**Синтаксис**

```python
commit()
```

:::note
Это пустая операция для chDB/ClickHouse, так как он не поддерживает традиционные
транзакции. Предоставляется для соответствия DB-API 2.0.
:::

---

#### `cursor` {#dbapi-cursor}

Создать новый курсор для выполнения запросов.

**Синтаксис**

```python
cursor(cursor=None)
```

**Параметры**

| Параметр  | Тип  | Описание                                      |
| --------- | ---- | --------------------------------------------- |
| `cursor`  | -    | Игнорируется, предоставляется для совместимости |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                  |
| -------------------------- | ----------------------------------------- |
| `Cursor`                   | Новый объект курсора для этого соединения |

**Исключения**

| Исключение                           | Условие                 |
| ------------------------------------ | ----------------------- |
| [`err.Error`](#chdb-dbapi-err-error) | Если соединение закрыто |

**Пример**

```pycon
>>> conn = Connection()
>>> cur = conn.cursor()
>>> cur.execute("SELECT 1")
>>> result = cur.fetchone()
```

---

#### `escape` {#escape}

Экранировать значение для безопасного включения в SQL-запросы.

**Синтаксис**

```python
escape(obj, mapping=None)
```

**Параметры**

| Параметр  | Тип  | Описание                                                      |
| --------- | ---- | ------------------------------------------------------------- |
| `obj`     | -    | Значение для экранирования (строка, байты, число и т. д.)      |
| `mapping` | -    | Необязательное сопоставление символов для экранирования       |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                      |
| -------------------------- | ------------------------------------------------------------- |
| -                          | Экранированная версия входных данных, пригодная для SQL-запросов |

**Пример**

```pycon
>>> conn = Connection()
>>> safe_value = conn.escape("O'Reilly")
>>> query = f"SELECT * FROM users WHERE name = {safe_value}"
```

---

#### `escape_string` {#escape-string}

Экранировать строковое значение для SQL-запросов.

**Синтаксис**

```python
escape_string(s)
```

**Параметры**

| Параметр  | Тип  | Описание                  |
| --------- | ---- | ------------------------- |
| `s`       | str  | Строка для экранирования  |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                              |
| -------------------------- | ----------------------------------------------------- |
| `str`                      | Экранированная строка, безопасная для включения в SQL |

---

#### `property open` {#property-open}

Проверить, открыто ли соединение.

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                           |
| -------------------------- | -------------------------------------------------- |
| `bool`                     | True, если соединение открыто, False, если закрыто |

---

#### `query` {#dbapi-query}

Выполнить SQL-запрос напрямую и вернуть необработанные результаты.

Этот метод обходит интерфейс курсора и выполняет запросы напрямую.
Для стандартного использования DB-API предпочтительнее использовать метод cursor().

**Синтаксис**

```python
query(sql, fmt='CSV')
```

**Параметры:**

| Параметр  | Тип          | По умолчанию | Описание                                                                                  |
| --------- | ------------ | ------------ | ----------------------------------------------------------------------------------------- |
| `sql`     | str or bytes | _обязательно_ | SQL-запрос для выполнения                                                                 |
| `fmt`     | str          | `"CSV"`      | Формат вывода. Поддерживаемые форматы включают "CSV", "JSON", "Arrow", "Parquet" и др.   |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                              |
| -------------------------- | ------------------------------------- |
| -                          | Результат запроса в указанном формате |

**Исключения**

| Исключение                                             | Условие                                          |
| ------------------------------------------------------ | ------------------------------------------------ |
| [`err.InterfaceError`](#chdb-dbapi-err-interfaceerror) | Если соединение закрыто или запрос завершился с ошибкой   |

**Пример**

```pycon
>>> conn = Connection()
>>> result = conn.query("SELECT 1, 'hello'", "CSV")
>>> print(result)
"1,hello\n"
```

---

#### `property resp` {#property-resp}

Получить ответ последнего запроса.

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                         |
| -------------------------- | ------------------------------------------------ |
| -                          | Необработанный ответ последнего вызова query()   |

:::note
Это свойство обновляется каждый раз при прямом вызове query().
Оно не отражает запросы, выполненные через курсоры.
:::

---

#### `rollback` {#rollback}


Откатить текущую транзакцию.

**Синтаксис**

```python
rollback()
```

:::note
Это пустая операция для chDB/ClickHouse, так как он не поддерживает традиционные
транзакции. Предоставляется для соответствия DB-API 2.0.
:::

---

### Класс Cursor {#cursor-class}

#### **class** `chdb.dbapi.cursors.Cursor` {#chdb-dbapi-cursors-cursor}

Базовый класс: `object`

Курсор DB-API 2.0 для выполнения запросов и получения результатов.

Курсор предоставляет методы для выполнения SQL-операторов, управления результатами запросов
и навигации по наборам результатов. Он поддерживает привязку параметров, массовые операции
и соответствует спецификации DB-API 2.0.

Не создавайте экземпляры Cursor напрямую. Используйте вместо этого `Connection.cursor()`.

```python
class chdb.dbapi.cursors.Cursor(connection)
```

| Переменная        | Тип   | Описание                                                           |
| ----------------- | ----- | ------------------------------------------------------------------ |
| `description`     | tuple | Метаданные столбцов для результата последнего запроса              |
| `rowcount`        | int   | Количество строк, затронутых последним запросом (-1, если неизвестно) |
| `arraysize`       | int   | Количество строк для выборки по умолчанию (по умолчанию: 1)        |
| `lastrowid`       | -     | ID последней вставленной строки (если применимо)                   |
| `max_stmt_length` | int   | Максимальный размер оператора для executemany() (по умолчанию: 1024000) |

**Примеры**

```pycon
>>> conn = Connection()
>>> cur = conn.cursor()
>>> cur.execute("SELECT 1 as id, 'test' as name")
>>> result = cur.fetchone()
>>> print(result)  # (1, 'test')
>>> cur.close()
```

:::note
См. [DB-API 2.0 Cursor Objects](https://www.python.org/dev/peps/pep-0249/#cursor-objects)
для получения полной информации о спецификации.
:::

---

#### `callproc` {#callproc}

Выполнить хранимую процедуру (заглушка реализации).

**Синтаксис**

```python
callproc(procname, args=())
```

**Параметры**

| Параметр   | Тип      | Описание                                  |
| ---------- | -------- | ----------------------------------------- |
| `procname` | str      | Имя хранимой процедуры для выполнения     |
| `args`     | sequence | Параметры для передачи в процедуру        |

**Возвращаемое значение**

| Тип возврата | Описание                                      |
| ------------ | --------------------------------------------- |
| `sequence`   | Исходный параметр args (без изменений)        |

:::note
chDB/ClickHouse не поддерживает хранимые процедуры в традиционном смысле.
Этот метод предоставляется для соответствия DB-API 2.0, но не выполняет
никаких фактических операций. Используйте execute() для всех SQL-операций.
:::

:::warning Совместимость
Это заглушка реализации. Традиционные возможности хранимых процедур,
такие как параметры OUT/INOUT, множественные наборы результатов и серверные
переменные, не поддерживаются базовым движком ClickHouse.
:::

---

#### `close` {#dbapi-cursor-close}

Закрыть курсор и освободить связанные ресурсы.

После закрытия курсор становится непригодным для использования, и любая операция вызовет исключение.
Закрытие курсора исчерпывает все оставшиеся данные и освобождает базовый курсор.

**Синтаксис**

```python
close()
```

---

#### `execute` {#dbapi-execute}

Выполнить SQL-запрос с необязательной привязкой параметров.

Этот метод выполняет один SQL-оператор с необязательной подстановкой параметров.
Он поддерживает несколько стилей заполнителей параметров для гибкости.

**Синтаксис**

```python
execute(query, args=None)
```

**Параметры**

| Параметр  | Тип             | По умолчанию | Описание                                  |
| --------- | --------------- | ------------ | ----------------------------------------- |
| `query`   | str             | _обязательно_ | SQL-запрос для выполнения                |
| `args`    | tuple/list/dict | `None`       | Параметры для привязки к заполнителям    |

**Возвращаемое значение**

| Тип возврата | Описание                                           |
| ------------ | -------------------------------------------------- |
| `int`        | Количество затронутых строк (-1, если неизвестно)  |

**Стили параметров**

| Стиль                  | Пример                                          |
| ---------------------- | ----------------------------------------------- |
| Стиль вопросительного знака | `"SELECT * FROM users WHERE id = ?"`            |
| Именованный стиль      | `"SELECT * FROM users WHERE name = %(name)s"`   |
| Стиль форматирования   | `"SELECT * FROM users WHERE age = %s"` (устаревший) |

**Примеры**


```pycon
>>> # Параметры с вопросительным знаком
>>> cur.execute("SELECT * FROM users WHERE id = ? AND age > ?", (123, 18))
>>>
>>> # Именованные параметры
>>> cur.execute("SELECT * FROM users WHERE name = %(name)s", {'name': 'Alice'})
>>>
>>> # Без параметров
>>> cur.execute("SELECT COUNT(*) FROM users")
```

**Исключения**

| Исключение                                             | Условие                                   |
| ------------------------------------------------------ | ----------------------------------------- |
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Если курсор закрыт или запрос имеет неверный формат |
| [`InterfaceError`](#chdb-dbapi-err-interfaceerror)     | Если при выполнении возникает ошибка базы данных |

---

#### `executemany(query, args)` {#chdb-dbapi-cursors-cursor-executemany}

Выполняет запрос несколько раз с различными наборами параметров.

Этот метод эффективно выполняет один и тот же SQL-запрос несколько раз с
различными значениями параметров. Особенно полезен для массовых операций INSERT.

**Синтаксис**

```python
executemany(query, args)
```

**Параметры**

| Параметр  | Тип      | Описание                                                    |
| --------- | -------- | ----------------------------------------------------------- |
| `query`   | str      | SQL-запрос для многократного выполнения                     |
| `args`    | sequence | Последовательность кортежей/словарей/списков параметров для каждого выполнения |

**Возвращаемое значение**

| Тип         | Описание                                            |
| ----------- | --------------------------------------------------- |
| `int`       | Общее количество затронутых строк по всем выполнениям |

**Примеры**

```pycon
>>> # Массовая вставка с параметрами-вопросительными знаками
>>> users_data = [(1, 'Alice'), (2, 'Bob'), (3, 'Charlie')]
>>> cur.executemany("INSERT INTO users VALUES (?, ?)", users_data)
>>>
>>> # Массовая вставка с именованными параметрами
>>> users_data = [
...     {'id': 1, 'name': 'Alice'},
...     {'id': 2, 'name': 'Bob'}
... ]
>>> cur.executemany(
...     "INSERT INTO users VALUES (%(id)s, %(name)s)",
...     users_data
... )
```

:::note
Этот метод повышает производительность операций INSERT и UPDATE с несколькими строками
за счет оптимизации процесса выполнения запросов.
:::

---

#### `fetchall()` {#dbapi-fetchall}

Извлекает все оставшиеся строки из результата запроса.

**Синтаксис**

```python
fetchall()
```

**Returns**

| Тип         | Описание                                       |
| ----------- | ---------------------------------------------- |
| `list`      | Список кортежей, представляющих все оставшиеся строки |

**Исключения**

| Исключение                                             | Условие                                |
| ------------------------------------------------------ | -------------------------------------- |
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Если execute() не был вызван ранее    |

:::warning Предупреждение
Этот метод может потреблять большие объемы памяти для больших наборов результатов.
Для больших наборов данных рекомендуется использовать `fetchmany()`.
:::

**Пример**

```pycon
>>> cursor.execute("SELECT id, name FROM users")
>>> all_rows = cursor.fetchall()
>>> print(len(all_rows))  # Общее количество строк
```

---

#### `fetchmany` {#dbapi-fetchmany}

Извлекает несколько строк из результата запроса.

**Синтаксис**

```python
fetchmany(size=1)
```

**Параметры**

| Параметр  | Тип  | По умолчанию | Описание                                                      |
| --------- | ---- | ------- | ---------------------------------------------------------------- |
| `size`    | int  | `1`     | Количество строк для извлечения. Если не указано, используется cursor.arraysize |

**Returns**

| Тип         | Описание                                     |
| ----------- | -------------------------------------------- |
| `list`      | Список кортежей, представляющих извлеченные строки |

**Исключения**

| Исключение                                             | Условие                                |
| ------------------------------------------------------ | -------------------------------------- |
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Если execute() не был вызван ранее    |

**Пример**

```pycon
>>> cursor.execute("SELECT id, name FROM users")
>>> rows = cursor.fetchmany(3)
>>> print(rows)  # [(1, 'Alice'), (2, 'Bob'), (3, 'Charlie')]
```

---

#### `fetchone` {#dbapi-fetchone}

Извлекает следующую строку из результата запроса.

**Синтаксис**

```python
fetchone()
```

**Returns**

| Тип             | Описание                                               |
| --------------- | ------------------------------------------------------ |
| `tuple or None` | Следующая строка в виде кортежа или None, если больше нет доступных строк |

**Исключения**

| Исключение                                             | Условие                                  |
| ------------------------------------------------------ | ---------------------------------------- |
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Если `execute()` не был вызван ранее    |

**Пример**


```pycon
>>> cursor.execute("SELECT id, name FROM users LIMIT 3")
>>> row = cursor.fetchone()
>>> print(row)  # (1, 'Alice')
>>> row = cursor.fetchone()
>>> print(row)  # (2, 'Bob')
```

---

#### `max_stmt_length = 1024000` {#max-stmt-length}

Максимальный размер оператора, генерируемого методом [`executemany()`](#chdb-dbapi-cursors-cursor-executemany).

Значение по умолчанию: 1024000.

---

#### `mogrify` {#mogrify}

Возвращает точную строку запроса, которая будет отправлена в базу данных.

Этот метод показывает итоговый SQL-запрос после подстановки параметров,
что полезно для отладки и логирования.

**Синтаксис**

```python
mogrify(query, args=None)
```

**Параметры**

| Параметр  | Тип             | По умолчанию | Описание                                    |
| --------- | --------------- | ------------ | ------------------------------------------- |
| `query`   | str             | _обязательно_ | SQL-запрос с заполнителями параметров      |
| `args`    | tuple/list/dict | `None`       | Параметры для подстановки                  |

**Возвращаемое значение**

| Тип возврата | Описание                                                    |
| ------------ | ----------------------------------------------------------- |
| `str`        | Итоговая строка SQL-запроса с подставленными параметрами   |

**Пример**

```pycon
>>> cur.mogrify("SELECT * FROM users WHERE id = ?", (123,))
"SELECT * FROM users WHERE id = 123"
```

:::note
Этот метод следует расширению DB-API 2.0, используемому в Psycopg.
:::

---

#### `nextset` {#nextset}

Переход к следующему набору результатов (не поддерживается).

**Синтаксис**

```python
nextset()
```

**Возвращаемое значение**

| Тип возврата | Описание                                                                  |
| ------------ | ------------------------------------------------------------------------- |
| `None`       | Всегда возвращает None, так как множественные наборы результатов не поддерживаются |

:::note
chDB/ClickHouse не поддерживает множественные наборы результатов из одного запроса.
Этот метод предоставлен для соответствия DB-API 2.0, но всегда возвращает None.
:::

---

#### `setinputsizes` {#setinputsizes}

Установка размеров входных параметров (пустая реализация).

**Синтаксис**

```python
setinputsizes(*args)
```

**Параметры**

| Параметр  | Тип  | Описание                                      |
| --------- | ---- | --------------------------------------------- |
| `*args`   | -    | Спецификации размеров параметров (игнорируются) |

:::note
Этот метод ничего не делает, но требуется спецификацией DB-API 2.0.
chDB автоматически обрабатывает размеры параметров внутри.
:::

---

#### `setoutputsizes` {#setoutputsizes}

Установка размеров выходных столбцов (пустая реализация).

**Синтаксис**

```python
setoutputsizes(*args)
```

**Параметры**

| Параметр  | Тип  | Описание                                    |
| --------- | ---- | ------------------------------------------- |
| `*args`   | -    | Спецификации размеров столбцов (игнорируются) |

:::note
Этот метод ничего не делает, но требуется спецификацией DB-API 2.0.
chDB автоматически обрабатывает размеры выходных данных внутри.
:::

---

### Классы ошибок {#error-classes}

Классы исключений для операций с базой данных chdb.

Этот модуль предоставляет полную иерархию классов исключений для обработки
ошибок, связанных с базой данных, в chdb, следуя спецификации Python Database API версии 2.0.

Иерархия исключений структурирована следующим образом:

```default
StandardError
├── Warning
└── Error
    ├── InterfaceError
    └── DatabaseError
        ├── DataError
        ├── OperationalError
        ├── IntegrityError
        ├── InternalError
        ├── ProgrammingError
        └── NotSupportedError
```

Каждый класс исключений представляет определённую категорию ошибок базы данных:

| Исключение          | Описание                                                           |
| ------------------- | ------------------------------------------------------------------ |
| `Warning`           | Некритичные предупреждения во время операций с базой данных        |
| `InterfaceError`    | Проблемы с самим интерфейсом базы данных                           |
| `DatabaseError`     | Базовый класс для всех ошибок, связанных с базой данных            |
| `DataError`         | Проблемы с обработкой данных (недопустимые значения, ошибки типов) |
| `OperationalError`  | Операционные проблемы базы данных (подключение, ресурсы)           |
| `IntegrityError`    | Нарушения ограничений (внешние ключи, уникальность)                |
| `InternalError`     | Внутренние ошибки и повреждения базы данных                        |
| `ProgrammingError`  | Синтаксические ошибки SQL и неправильное использование API         |
| `NotSupportedError` | Неподдерживаемые функции или операции                              |

:::note
Эти классы исключений соответствуют спецификации Python DB API 2.0
и обеспечивают согласованную обработку ошибок в различных операциях с базой данных.
:::


**См. также**

- [Python Database API Specification v2.0](https://peps.python.org/pep-0249/)
- `chdb.dbapi.connections` - Управление подключениями к базе данных
- `chdb.dbapi.cursors` - Операции с курсорами базы данных

**Примеры**

```pycon
>>> try:
...     cursor.execute("SELECT * FROM nonexistent_table")
... except ProgrammingError as e:
...     print(f"SQL Error: {e}")
...
SQL Error: Таблица 'nonexistent_table' не существует
```

```pycon
>>> try:
...     cursor.execute("INSERT INTO users (id) VALUES (1), (1)")
... except IntegrityError as e:
...     print(f"Constraint violation: {e}")
...
Constraint violation: Дублирующаяся запись '1' для ключа 'PRIMARY'
```

---

#### **exception** `chdb.dbapi.err.DataError` {#chdb-dbapi-err-dataerror}

Базовый класс: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, возникающее при ошибках, связанных с проблемами в обрабатываемых данных.

Это исключение возникает, когда операции с базой данных завершаются неудачей из-за проблем с
обрабатываемыми данными, таких как:

- Операции деления на ноль
- Числовые значения вне допустимого диапазона
- Недопустимые значения даты/времени
- Ошибки усечения строк
- Ошибки преобразования типов
- Недопустимый формат данных для типа столбца

**Возникает**

| Исключение                               | Условие                                            |
| ---------------------------------------- | -------------------------------------------------- |
| [`DataError`](#chdb-dbapi-err-dataerror) | Когда проверка или обработка данных завершается неудачей |

**Примеры**

```pycon
>>> # Деление на ноль в SQL
>>> cursor.execute("SELECT 1/0")
DataError: Деление на ноль
```

```pycon
>>> # Недопустимый формат даты
>>> cursor.execute("INSERT INTO table VALUES ('invalid-date')")
DataError: Недопустимый формат даты
```

---

#### **exception** `chdb.dbapi.err.DatabaseError` {#chdb-dbapi-err-databaseerror}

Базовый класс: [`Error`](#chdb-dbapi-err-error)

Исключение, возникающее при ошибках, связанных с базой данных.

Это базовый класс для всех ошибок, связанных с базой данных. Он охватывает
все ошибки, возникающие во время операций с базой данных и связанные с самой
базой данных, а не с интерфейсом.

Типичные сценарии включают:

- Ошибки выполнения SQL
- Проблемы с подключением к базе данных
- Проблемы, связанные с транзакциями
- Нарушения ограничений, специфичных для базы данных

:::note
Служит родительским классом для более специфичных типов ошибок базы данных,
таких как [`DataError`](#chdb-dbapi-err-dataerror), [`OperationalError`](#chdb-dbapi-err-operationalerror) и т. д.
:::

---

#### **exception** `chdb.dbapi.err.Error` {#chdb-dbapi-err-error}

Базовый класс: [`StandardError`](#chdb-dbapi-err-standarderror)

Исключение, являющееся базовым классом для всех остальных исключений ошибок (кроме предупреждений).

Это базовый класс для всех исключений ошибок в chdb, за исключением предупреждений.
Служит родительским классом для всех условий ошибок базы данных, которые препятствуют
успешному завершению операций.

:::note
Эта иерархия исключений соответствует спецификации Python DB API 2.0.
:::

**См. также**

- [`Warning`](#chdb-dbapi-err-warning) - Для некритичных предупреждений, которые не препятствуют завершению операции

#### **exception** `chdb.dbapi.err.IntegrityError` {#chdb-dbapi-err-integrityerror}

Bases: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, возникающее при нарушении реляционной целостности базы данных.

Это исключение возникает, когда операции с базой данных нарушают ограничения целостности,
включая:

- Нарушения ограничений внешнего ключа
- Нарушения ограничений первичного ключа или уникальности (дублирующиеся ключи)
- Нарушения ограничений проверки
- Нарушения ограничений NOT NULL
- Нарушения ссылочной целостности

**Raises**

| Исключение                                         | Условие                                                   |
| -------------------------------------------------- | --------------------------------------------------------- |
| [`IntegrityError`](#chdb-dbapi-err-integrityerror) | Когда нарушаются ограничения целостности базы данных |

**Примеры**

```pycon
>>> # Дублирующийся первичный ключ
>>> cursor.execute("INSERT INTO users (id, name) VALUES (1, 'John')")
>>> cursor.execute("INSERT INTO users (id, name) VALUES (1, 'Jane')")
IntegrityError: Дублирующаяся запись '1' для ключа 'PRIMARY'
```

```pycon
>>> # Нарушение внешнего ключа
>>> cursor.execute("INSERT INTO orders (user_id) VALUES (999)")
IntegrityError: Невозможно добавить или обновить дочернюю строку: ограничение внешнего ключа не выполнено
```

---

#### **exception** `chdb.dbapi.err.InterfaceError` {#chdb-dbapi-err-interfaceerror}

Bases: [`Error`](#chdb-dbapi-err-error)

Исключение, возникающее при ошибках, связанных с интерфейсом базы данных, а не с самой базой данных.


Это исключение возникает при проблемах с реализацией интерфейса базы данных,
таких как:

- Недопустимые параметры подключения
- Неправильное использование API (вызов методов на закрытых соединениях)
- Ошибки протокола на уровне интерфейса
- Ошибки импорта или инициализации модуля

**Вызывает**

| Исключение                                         | Условие                                                                           |
| -------------------------------------------------- | --------------------------------------------------------------------------------- |
| [`InterfaceError`](#chdb-dbapi-err-interfaceerror) | Когда интерфейс базы данных сталкивается с ошибками, не связанными с операциями БД |

:::note
Эти ошибки обычно являются ошибками программирования или проблемами конфигурации,
которые можно устранить, исправив клиентский код или конфигурацию.
:::

---

#### **исключение** `chdb.dbapi.err.InternalError` {#chdb-dbapi-err-internalerror}

Базовый класс: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, возникающее при обнаружении базой данных внутренней ошибки.

Это исключение возникает, когда система базы данных сталкивается с внутренними
ошибками, не вызванными приложением, такими как:

- Недопустимое состояние курсора (курсор больше не действителен)
- Несогласованность состояния транзакции (транзакция рассинхронизирована)
- Проблемы повреждения базы данных
- Повреждение внутренних структур данных
- Ошибки базы данных на системном уровне

**Вызывает**

| Исключение                                       | Условие                                                  |
| ------------------------------------------------ | -------------------------------------------------------- |
| [`InternalError`](#chdb-dbapi-err-internalerror) | Когда база данных сталкивается с внутренними несоответствиями |

:::warning Предупреждение
Внутренние ошибки могут указывать на серьезные проблемы базы данных, требующие
внимания администратора базы данных. Эти ошибки обычно не могут быть устранены
с помощью логики повторных попыток на уровне приложения.
:::

:::note
Эти ошибки обычно находятся вне контроля приложения
и могут требовать перезапуска базы данных или операций восстановления.
:::

---

#### **исключение** `chdb.dbapi.err.NotSupportedError` {#chdb-dbapi-err-notsupportederror}

Базовый класс: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, возникающее, когда метод или API базы данных не поддерживается.

Это исключение возникает, когда приложение пытается использовать функции
базы данных или методы API, которые не поддерживаются текущей конфигурацией
или версией базы данных, такие как:

- Запрос `rollback()` на соединениях без поддержки транзакций
- Использование расширенных возможностей SQL, не поддерживаемых версией базы данных
- Вызов методов, не реализованных текущим драйвером
- Попытка использования отключенных функций базы данных

**Вызывает**

| Исключение                                               | Условие                                                       |
| -------------------------------------------------------- | ------------------------------------------------------------- |
| [`NotSupportedError`](#chdb-dbapi-err-notsupportederror) | Когда осуществляется доступ к неподдерживаемым функциям базы данных |

**Примеры**

```pycon
>>> # Откат транзакции на нетранзакционном соединении
>>> connection.rollback()
NotSupportedError: Транзакции не поддерживаются
```

```pycon
>>> # Использование неподдерживаемого синтаксиса SQL
>>> cursor.execute("SELECT * FROM table WITH (NOLOCK)")
NotSupportedError: Конструкция WITH не поддерживается в этой версии базы данных
```

:::note
Проверяйте документацию базы данных и возможности драйвера, чтобы избежать
этих ошибок. По возможности предусматривайте корректные альтернативные варианты.
:::

---

#### **исключение** `chdb.dbapi.err.OperationalError` {#chdb-dbapi-err-operationalerror}

Базовый класс: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, возникающее при ошибках, связанных с работой базы данных.

Это исключение возникает при ошибках, которые происходят во время работы базы данных
и не обязательно находятся под контролем программиста, включая:

- Неожиданное отключение от базы данных
- Сервер базы данных не найден или недоступен
- Сбои обработки транзакций
- Ошибки выделения памяти во время обработки
- Исчерпание дискового пространства или ресурсов
- Внутренние ошибки сервера базы данных
- Сбои аутентификации или авторизации

**Вызывает**

| Исключение                                             | Условие                                                           |
| ------------------------------------------------------ | ----------------------------------------------------------------- |
| [`OperationalError`](#chdb-dbapi-err-operationalerror) | Когда операции базы данных завершаются неудачей из-за операционных проблем |

:::note
Эти ошибки обычно являются временными и могут быть устранены путем повторной попытки
выполнения операции или решения проблем на системном уровне.
:::

:::warning Предупреждение
Некоторые операционные ошибки могут указывать на серьезные системные проблемы,
требующие вмешательства администратора.
:::

---

#### **исключение** `chdb.dbapi.err.ProgrammingError` {#chdb-dbapi-err-programmingerror}

Базовый класс: [`DatabaseError`](#chdb-dbapi-err-databaseerror)

Исключение, возникающее при ошибках программирования в операциях базы данных.

Это исключение возникает при наличии ошибок программирования в
использовании базы данных приложением, включая:

- Таблица или столбец не найдены
- Таблица или индекс уже существуют при создании
- Синтаксические ошибки SQL в операторах
- Неправильное количество параметров, указанных в подготовленных операторах
- Недопустимые операции SQL (например, DROP для несуществующих объектов)
- Неправильное использование методов API базы данных

**Вызывает**

| Исключение                                             | Условие                                                    |
| ------------------------------------------------------ | ---------------------------------------------------------- |
| [`ProgrammingError`](#chdb-dbapi-err-programmingerror) | Когда операторы SQL или использование API содержат ошибки |

**Примеры**


```pycon
>>> # Таблица не найдена
>>> cursor.execute("SELECT * FROM nonexistent_table")
ProgrammingError: Table 'nonexistent_table' doesn't exist
```

```pycon
>>> # Синтаксическая ошибка SQL
>>> cursor.execute("SELCT * FROM users")
ProgrammingError: You have an error in your SQL syntax
```

```pycon
>>> # Неверное количество параметров
>>> cursor.execute("INSERT INTO users (name, age) VALUES (%s)", ('John',))
ProgrammingError: Column count doesn't match value count
```

---

#### **exception** `chdb.dbapi.err.StandardError` {#chdb-dbapi-err-standarderror}

Базовый класс: `Exception`

Исключение, связанное с операциями chdb.

Это базовый класс для всех исключений, связанных с chdb. Он наследуется от
встроенного класса Exception языка Python и служит корнем иерархии исключений
для операций с базой данных.

:::note
Этот класс исключений соответствует спецификации Python DB API 2.0
для обработки исключений базы данных.
:::

---

#### **exception** `chdb.dbapi.err.Warning` {#chdb-dbapi-err-warning}

Базовый класс: [`StandardError`](#chdb-dbapi-err-standarderror)

Исключение, возникающее при важных предупреждениях, таких как усечение данных при вставке и т. д.

Это исключение возникает, когда операция с базой данных завершается, но с
важными предупреждениями, на которые следует обратить внимание приложения.
Типичные сценарии включают:

- Усечение данных при вставке
- Потеря точности при числовых преобразованиях
- Предупреждения о преобразовании кодировок

:::note
Это соответствует спецификации Python DB API 2.0 для исключений-предупреждений.
:::

---

### Константы модуля {#module-constants}

#### `chdb.dbapi.apilevel = '2.0'` {#apilevel}

```python
str(object=’’) -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
```

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of `object._\_str_\_()` (if defined)
or `repr(object)`.

- encoding defaults to ‘utf-8’.
- errors defaults to ‘strict’.

---

#### `chdb.dbapi.threadsafety = 1` {#threadsafety}

```python
int([x]) -> integer
int(x, base=10) -> integer
```

Преобразует число или строку в целое число или возвращает 0, если аргументы
не указаны. Если x — число, возвращает x._\_int_\_(). Для чисел с плавающей
точкой выполняется усечение к нулю.

Если x не является числом или указан base, то x должен быть строкой,
bytes или экземпляром bytearray, представляющим целочисленный литерал в
заданной системе счисления. Литерал может начинаться с '+' или '-' и быть окружен
пробелами. По умолчанию base равен 10. Допустимые значения base: 0 и 2-36.
Base 0 означает определение системы счисления из строки как целочисленного литерала.

```python
>>> int(‘0b100’, base=0)
4
```

---

#### `chdb.dbapi.paramstyle = 'format'` {#paramstyle}

```python
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
```

Создает новый строковый объект из заданного объекта. Если указаны encoding или
errors, то объект должен предоставлять буфер данных,
который будет декодирован с использованием указанной кодировки и обработчика ошибок.
В противном случае возвращает результат object._\_str_\_() (если определен)
или repr(object).
encoding по умолчанию 'utf-8'.
errors по умолчанию 'strict'.

---

### Константы типов {#type-constants}

#### `chdb.dbapi.STRING = frozenset({247, 253, 254})` {#string-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0.
Он позволяет гибко проверять типы, где отдельные элементы можно сравнивать
с набором, используя операторы равенства и неравенства.

Это используется для констант типов, таких как STRING, BINARY, NUMBER и т. д., чтобы обеспечить
сравнения вида "field_type == STRING", где field_type — одиночное значение типа.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Возвращает True
>>> FIELD_TYPE.INT != string_types     # Возвращает True
>>> FIELD_TYPE.BLOB in string_types    # Возвращает False
```

---


#### `chdb.dbapi.BINARY = frozenset({249, 250, 251, 252})` {#binary-type}

Extended frozenset for DB-API 2.0 type comparison.

This class extends frozenset to support DB-API 2.0 type comparison semantics.
It allows for flexible type checking where individual items can be compared
against the set using both equality and inequality operators.

This is used for type constants like STRING, BINARY, NUMBER, etc. to enable
comparisons like “field_type == STRING” where field_type is a single type value.

**Examples**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---

#### `chdb.dbapi.NUMBER = frozenset({0, 1, 3, 4, 5, 8, 9, 13})` {#number-type}

Extended frozenset for DB-API 2.0 type comparison.

This class extends frozenset to support DB-API 2.0 type comparison semantics.
It allows for flexible type checking where individual items can be compared
against the set using both equality and inequality operators.

This is used for type constants like STRING, BINARY, NUMBER, etc. to enable
comparisons like “field_type == STRING” where field_type is a single type value.

**Examples**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---

#### `chdb.dbapi.DATE = frozenset({10, 14})` {#date-type}

Extended frozenset for DB-API 2.0 type comparison.

This class extends frozenset to support DB-API 2.0 type comparison semantics.
It allows for flexible type checking where individual items can be compared
against the set using both equality and inequality operators.

This is used for type constants like STRING, BINARY, NUMBER, etc. to enable
comparisons like “field_type == STRING” where field_type is a single type value.

**Examples**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---

#### `chdb.dbapi.TIME = frozenset({11})` {#time-type}

Extended frozenset for DB-API 2.0 type comparison.

This class extends frozenset to support DB-API 2.0 type comparison semantics.
It allows for flexible type checking where individual items can be compared
against the set using both equality and inequality operators.

This is used for type constants like STRING, BINARY, NUMBER, etc. to enable
comparisons like “field_type == STRING” where field_type is a single type value.

**Examples**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

---

#### `chdb.dbapi.TIMESTAMP = frozenset({7, 12})` {#timestamp-type}

Extended frozenset for DB-API 2.0 type comparison.

This class extends frozenset to support DB-API 2.0 type comparison semantics.
It allows for flexible type checking where individual items can be compared
against the set using both equality and inequality operators.

This is used for type constants like STRING, BINARY, NUMBER, etc. to enable
comparisons like “field_type == STRING” where field_type is a single type value.

**Examples**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Returns True
>>> FIELD_TYPE.INT != string_types     # Returns True
>>> FIELD_TYPE.BLOB in string_types    # Returns False
```

#### `chdb.dbapi.DATETIME = frozenset({7, 12})` {#datetime-type}

Extended frozenset for DB-API 2.0 type comparison.


Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0.
Он позволяет выполнять гибкую проверку типов, при которой отдельные элементы могут сравниваться
с набором с помощью операторов равенства и неравенства.

This is used for type constants like STRING, BINARY, NUMBER, etc. to enable
comparisons like “field_type == STRING” where field_type is a single type value.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Возвращает True
>>> FIELD_TYPE.INT != string_types     # Возвращает True
>>> FIELD_TYPE.BLOB in string_types    # Возвращает False
```

---

#### `chdb.dbapi.ROWID = frozenset({})` {#rowid-type}

Расширенный frozenset для сравнения типов DB-API 2.0.

Этот класс расширяет frozenset для поддержки семантики сравнения типов DB-API 2.0.
Он позволяет выполнять гибкую проверку типов, при которой отдельные элементы могут сравниваться
с набором с помощью операторов равенства и неравенства.

This is used for type constants like STRING, BINARY, NUMBER, etc. to enable
comparisons like “field_type == STRING” where field_type is a single type value.

**Примеры**

```pycon
>>> string_types = DBAPISet([FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING])
>>> FIELD_TYPE.STRING == string_types  # Возвращает True
>>> FIELD_TYPE.INT != string_types     # Возвращает True
>>> FIELD_TYPE.BLOB in string_types    # Возвращает False
```

**Примеры использования**

Пример базового запроса:

```python
import chdb.dbapi as dbapi

print("Версия драйвера chdb: {0}".format(dbapi.get_client_info()))

```


# Создайте соединение и курсор
conn = dbapi.connect()
cur = conn.cursor()



# Выполнить запрос
cur.execute('SELECT version()')
print("описание:", cur.description)
print("данные:", cur.fetchone())



# Завершение работы

cur.close()
conn.close()

````

Работа с данными:

```python
import chdb.dbapi as dbapi

conn = dbapi.connect()
cur = conn.cursor()
````


# Создать таблицу
cur.execute("""
    CREATE TABLE employees (
        id UInt32,
        name String,
        department String,
        salary Decimal(10,2)
    ) ENGINE = Memory
""")



# Вставка данных
cur.execute("""
    INSERT INTO employees VALUES
    (1, 'Alice', 'Engineering', 75000.00),
    (2, 'Bob', 'Marketing', 65000.00),
    (3, 'Charlie', 'Engineering', 80000.00)
""")



# Выполнение запроса
cur.execute("SELECT * FROM employees WHERE department = 'Engineering'")



# Получение результатов

print(&quot;Column names:&quot;, [desc[0] for desc in cur.description])
for row in cur.fetchall():
print(row)

conn.close()

````

Управление подключениями:

```python
import chdb.dbapi as dbapi
````


# База данных в памяти (по умолчанию)
conn1 = dbapi.connect()



# Постоянный файл базы данных
conn2 = dbapi.connect("./my_database.chdb")



# Подключение с параметрами
conn3 = dbapi.connect("./my_database.chdb?log-level=debug&verbose")



# Подключение в режиме только для чтения
conn4 = dbapi.connect("./my_database.chdb?mode=ro")



# Автоматическое закрытие соединения

with dbapi.connect(&quot;test.chdb&quot;) as conn:
cur = conn.cursor()
cur.execute(&quot;SELECT count() FROM numbers(1000)&quot;)
result = cur.fetchone()
print(f&quot;Count: {result[0]}&quot;)
cur.close()

```

**Рекомендации**

1. **Управление соединениями**: Всегда закрывайте соединения и курсоры после завершения работы
2. **Менеджеры контекста**: Используйте операторы `with` для автоматической очистки ресурсов
3. **Пакетная обработка**: Используйте `fetchmany()` для больших наборов результатов
4. **Обработка ошибок**: Оборачивайте операции с базой данных в блоки try-except
5. **Привязка параметров**: По возможности используйте параметризованные запросы
6. **Управление памятью**: Избегайте использования `fetchall()` для очень больших наборов данных

:::note
- Интерфейс DB-API 2.0 в chDB совместим с большинством инструментов для работы с базами данных Python
- Интерфейс обеспечивает потокобезопасность уровня 1 (потоки могут совместно использовать модули, но не соединения)
- Строки подключения поддерживают те же параметры, что и сессии chDB
- Поддерживаются все стандартные исключения DB-API 2.0
:::

:::warning Предупреждение
- Всегда закрывайте курсоры и соединения во избежание утечек ресурсов
- Большие наборы результатов следует обрабатывать пакетами
- Синтаксис привязки параметров соответствует стилю форматирования: `%s`
:::
```


## Пользовательские функции (UDF) {#user-defined-functions}

Модуль пользовательских функций для chDB.

Этот модуль предоставляет функциональность для создания и управления пользовательскими функциями (UDF)
в chDB. Он позволяет расширить возможности chDB, написав собственные функции на Python,
которые можно вызывать из SQL-запросов.

### `chdb.udf.chdb_udf` {#chdb-udf}

Декоратор для пользовательских функций Python в chDB (User Defined Function).

**Синтаксис**

```python
chdb.udf.chdb_udf(return_type='String')
```

**Параметры**

| Параметр      | Тип  | По умолчанию | Описание                                                              |
| ------------- | ---- | ---------- | ----------------------------------------------------------------------- |
| `return_type` | str  | `"String"` | Тип возвращаемого значения функции. Должен быть одним из типов данных ClickHouse |

**Примечания**

1. Функция должна быть без состояния. Поддерживаются только UDF, но не UDAF.
2. Тип возвращаемого значения по умолчанию — String. Тип возвращаемого значения должен быть одним из типов данных ClickHouse.
3. Функция должна принимать аргументы типа String. Все аргументы являются строками.
4. Функция будет вызываться для каждой строки входных данных.
5. Функция должна быть чистой функцией Python. Импортируйте все используемые модули ВНУТРИ ФУНКЦИИ.
6. Используется тот же интерпретатор Python, что и для запуска скрипта.

**Пример**

```python
@chdb_udf()
def sum_udf(lhs, rhs):
    return int(lhs) + int(rhs)

@chdb_udf()
def func_use_json(arg):
    import json
    # ... use json module
```

---

### `chdb.udf.generate_udf` {#generate-udf}

Генерирует файлы конфигурации UDF и исполняемого скрипта.

Эта функция создает необходимые файлы для пользовательской функции (UDF) в chDB:

1. Исполняемый скрипт Python, который обрабатывает входные данные
2. Конфигурационный файл XML, который регистрирует UDF в ClickHouse

**Синтаксис**

```python
chdb.udf.generate_udf(func_name, args, return_type, udf_body)
```

**Параметры**

| Параметр      | Тип  | Описание                                    |
| ------------- | ---- | ------------------------------------------- |
| `func_name`   | str  | Имя функции UDF                             |
| `args`        | list | Список имен аргументов функции              |
| `return_type` | str  | Тип возвращаемого значения ClickHouse для функции |
| `udf_body`    | str  | Тело исходного кода Python функции UDF      |

:::note
Эта функция обычно вызывается декоратором @chdb_udf и не должна
вызываться пользователями напрямую.
:::

---


## Утилиты {#utilities}

Вспомогательные функции и утилиты для chDB.

Этот модуль содержит различные вспомогательные функции для работы с chDB, включая
определение типов данных, функции преобразования данных и утилиты для отладки.

---

### `chdb.utils.convert_to_columnar` {#convert-to-columnar}

Преобразует список словарей в колоночный формат.

Эта функция принимает список словарей и преобразует его в словарь,
где каждый ключ соответствует столбцу, а каждое значение — список значений столбца.
Отсутствующие значения в словарях представлены как None.

**Синтаксис**

```python
chdb.utils.convert_to_columnar(items: List[Dict[str, Any]]) → Dict[str, List[Any]]
```

**Параметры**

| Параметр  | Тип                    | Описание                          |
| --------- | ---------------------- | --------------------------------- |
| `items`   | `List[Dict[str, Any]]` | Список словарей для преобразования |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                                    |
| -------------------------- | --------------------------------------------------------------------------- |
| `Dict[str, List[Any]]`     | Словарь с ключами в виде имён столбцов и значениями в виде списков значений столбцов |

**Пример**

```pycon
>>> items = [
...     {"name": "Alice", "age": 30, "city": "New York"},
...     {"name": "Bob", "age": 25},
...     {"name": "Charlie", "city": "San Francisco"}
... ]
>>> convert_to_columnar(items)
{
    'name': ['Alice', 'Bob', 'Charlie'],
    'age': [30, 25, None],
    'city': ['New York', None, 'San Francisco']
}
```

---

### `chdb.utils.flatten_dict` {#flatten-dict}

Выполняет выравнивание вложенного словаря.

Эта функция принимает вложенный словарь и выравнивает его, объединяя вложенные ключи
с помощью разделителя. Списки словарей сериализуются в строки JSON.

**Синтаксис**

```python
chdb.utils.flatten_dict(d: Dict[str, Any], parent_key: str = '', sep: str = '_') → Dict[str, Any]
```

**Параметры**

| Параметр     | Тип              | По умолчанию | Описание                                       |
| ------------ | ---------------- | ------------ | ---------------------------------------------- |
| `d`          | `Dict[str, Any]` | _обязательный_ | Словарь для выравнивания                      |
| `parent_key` | str              | `""`         | Базовый ключ, добавляемый к каждому ключу     |
| `sep`        | str              | `"_"`        | Разделитель, используемый между объединёнными ключами |

**Returns**

| Тип возвращаемого значения | Описание              |
| -------------------------- | --------------------- |
| `Dict[str, Any]`           | Выравненный словарь   |

**Пример**

```pycon
>>> nested_dict = {
...     "a": 1,
...     "b": {
...         "c": 2,
...         "d": {
...             "e": 3
...         }
...     },
...     "f": [4, 5, {"g": 6}],
...     "h": [{"i": 7}, {"j": 8}]
... }
>>> flatten_dict(nested_dict)
{
    'a': 1,
    'b_c': 2,
    'b_d_e': 3,
    'f_0': 4,
    'f_1': 5,
    'f_2_g': 6,
    'h': '[{"i": 7}, {"j": 8}]'
}
```

---

### `chdb.utils.infer_data_type` {#infer-data-type}

Определяет наиболее подходящий тип данных для списка значений.

Эта функция анализирует список значений и определяет наиболее подходящий
тип данных, который может представлять все значения в списке. Она рассматривает целочисленный,
беззнаковый целочисленный, десятичный и вещественный типы, и по умолчанию использует "string", если
значения не могут быть представлены каким-либо числовым типом или если все значения равны None.

**Синтаксис**

```python
chdb.utils.infer_data_type(values: List[Any]) → str
```

**Параметры**

| Параметр  | Тип         | Описание                                                   |
| --------- | ----------- | ---------------------------------------------------------- |
| `values`  | `List[Any]` | Список значений для анализа. Значения могут быть любого типа |

**Возвращаемое значение**


| Тип возвращаемого значения | Описание                                                                                                                                                                                                                                                 |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `str`       | Строка, представляющая определённый тип данных. Возможные возвращаемые значения: "int8", "int16", "int32", "int64", "int128", "int256", "uint8", "uint16","uint32", "uint64", "uint128", "uint256", "decimal128", "decimal256", "float32", "float64" или "string". |

:::note

- Если все значения в списке равны None, функция возвращает "string".
- Если хотя бы одно значение в списке является строкой, функция немедленно возвращает "string".
- Функция предполагает, что числовые значения могут быть представлены как целые числа,
  десятичные дроби или числа с плавающей точкой в зависимости от их диапазона и точности.
  :::

---

### `chdb.utils.infer_data_types` {#infer-data-types}

Определяет типы данных для каждого столбца в колоночной структуре данных.

Эта функция анализирует значения в каждом столбце и определяет наиболее подходящий
тип данных для каждого столбца на основе выборки данных.

**Синтаксис**

```python
chdb.utils.infer_data_types`(column_data: Dict[str, List[Any]], n_rows: int = 10000) → List[tuple]
```

**Параметры**

| Параметр      | Тип                    | По умолчанию | Описание                                                                    |
| ------------- | ---------------------- | ---------- | ------------------------------------------------------------------------------ |
| `column_data` | `Dict[str, List[Any]]` | _обязательный_ | Словарь, где ключи — имена столбцов, а значения — списки значений столбцов |
| `n_rows`      | int                    | `10000`    | Количество строк для выборки при определении типов                                |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                                                                |
| ------------- | -------------------------------------------------------------------------- |
| `List[tuple]` | Список кортежей, каждый из которых содержит имя столбца и его определённый тип данных |


## Абстрактные базовые классы {#abstract-base-classes}

### **class** `chdb.rwabc.PyReader`(data: Any)` {#pyreader}

Базовый класс: `ABC`

```python
class chdb.rwabc.PyReader(data: Any)
```

---

#### **abstractmethod** `read` {#read}

Читает указанное количество строк из заданных столбцов и возвращает список объектов,
где каждый объект представляет собой последовательность значений столбца.

```python
abstractmethod (col_names: List[str], count: int) → List[Any]
```

**Параметры**

| Параметр    | Тип         | Описание                       |
| ----------- | ----------- | ------------------------------ |
| `col_names` | `List[str]` | Список имён столбцов для чтения |
| `count`     | int         | Максимальное количество строк для чтения |

**Возвращаемое значение**

| Тип возвращаемого значения | Описание                |
| ----------- | -------------------------------------- |
| `List[Any]` | Список последовательностей, по одной на каждый столбец |

### **class** `chdb.rwabc.PyWriter` {#pywriter}

Базовый класс: `ABC`

```python
class chdb.rwabc.PyWriter(col_names: List[str], types: List[type], data: Any)
```

---

#### **abstractmethod** finalize {#finalize}

Собирает и возвращает итоговые данные из блоков. Должен быть реализован в подклассах.

```python
abstractmethod finalize() → bytes
```

**Возвращаемое значение**

| Return Type | Description               |
| ----------- | ------------------------- |
| `bytes`     | Итоговые сериализованные данные |

---

#### **abstractmethod** `write` {#write}

Сохраняет столбцы данных в блоки. Должен быть реализован в подклассах.

```python
abstractmethod write(col_names: List[str], columns: List[List[Any]]) → None
```

**Параметры**

| Параметр    | Тип               | Описание                                                   |
| ----------- | ----------------- | ---------------------------------------------------------- |
| `col_names` | `List[str]`       | Список имён столбцов, которые записываются                 |
| `columns`   | `List[List[Any]]` | Список данных столбцов, каждый столбец представлен в виде списка |


## Обработка исключений {#exception-handling}

### **class** `chdb.ChdbError` {#chdberror}

Базовый класс: `Exception`

Базовый класс исключений для ошибок, связанных с chDB.

Это исключение возникает при сбое выполнения запроса chDB или при
возникновении ошибки. Оно наследуется от стандартного класса Python Exception и
предоставляет информацию об ошибках из базового движка ClickHouse.

Сообщение об исключении обычно содержит подробную информацию об ошибке
из ClickHouse, включая синтаксические ошибки, несоответствия типов, отсутствующие
таблицы/столбцы и другие проблемы выполнения запросов.

**Переменные**

| Переменная | Тип | Описание                                                              |
| ---------- | --- | --------------------------------------------------------------------- |
| `args`     | -   | Кортеж, содержащий сообщение об ошибке и любые дополнительные аргументы |

**Примеры**

```pycon
>>> try:
...     result = chdb.query("SELECT * FROM non_existent_table")
... except chdb.ChdbError as e:
...     print(f"Query failed: {e}")
Запрос не выполнен: Таблица 'non_existent_table' не существует
```

```pycon
>>> try:
...     result = chdb.query("SELECT invalid_syntax FROM")
... except chdb.ChdbError as e:
...     print(f"Syntax error: {e}")
Синтаксическая ошибка: Синтаксическая ошибка рядом с 'FROM'
```

:::note
Это исключение автоматически возникает в chdb.query() и связанных
функциях, когда базовый движок ClickHouse сообщает об ошибке.
Вам следует перехватывать это исключение при обработке потенциально
неудачных запросов для обеспечения надлежащей обработки ошибок в вашем приложении.
:::


## Информация о версии {#version-information}

### `chdb.chdb_version = ('3', '6', '0')` {#chdb-version}

Встроенная неизменяемая последовательность.

Если аргумент не передан, конструктор возвращает пустой кортеж.
Если указан итерируемый объект, кортеж инициализируется его элементами.

Если аргумент является кортежем, возвращается тот же самый объект.

---

### `chdb.engine_version = '25.5.2.1'` {#engine-version}

```python
str(object=’’) -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
```

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object._\_str_\_() (if defined)
or repr(object).

- encoding defaults to ‘utf-8’.
- errors defaults to ‘strict’.

---

### `chdb.__version__ = '3.6.0'` {#version}

```python
str(object=’’) -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
```

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object._\_str_\_() (if defined)
or repr(object).

- encoding defaults to ‘utf-8’.
- errors defaults to ‘strict’.

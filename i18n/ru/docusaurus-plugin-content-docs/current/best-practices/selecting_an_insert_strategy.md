---
slug: /best-practices/selecting-an-insert-strategy
sidebar_position: 10
sidebar_label: 'Выбор стратегии вставки'
title: 'Выбор стратегии вставки'
description: 'Страница, посвящённая выбору стратегии вставки данных в ClickHouse'
keywords: ['INSERT', 'асинхронные вставки', 'сжатие', 'пакетные вставки']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import insert_process from '@site/static/images/bestpractices/insert_process.png';
import async_inserts from '@site/static/images/bestpractices/async_inserts.png';
import AsyncInserts from '@site/i18n/ru/docusaurus-plugin-content-docs/current/best-practices/_snippets/_async_inserts.md';
import BulkInserts from '@site/i18n/ru/docusaurus-plugin-content-docs/current/best-practices/_snippets/_bulk_inserts.md';

Эффективный приём данных лежит в основе высокопроизводительных развертываний ClickHouse. Выбор правильной стратегии вставки может существенно повлиять на пропускную способность, стоимость и надежность. В этом разделе изложены передовые практики, компромиссы и варианты конфигурации, которые помогут вам принять правильное решение для вашей нагрузки.

:::note
В дальнейшем предполагается, что вы отправляете данные в ClickHouse через клиент. Если вы загружаете данные в ClickHouse, например, используя встроенные табличные функции, такие как [s3](/sql-reference/table-functions/s3) и [gcs](/sql-reference/table-functions/gcs), мы рекомендуем наше руководство [&quot;Optimizing for S3 Insert and Read Performance&quot;](/integrations/s3/performance).
:::

## Синхронные вставки по умолчанию {#synchronous-inserts-by-default}

По умолчанию вставки в ClickHouse являются синхронными. Каждый запрос вставки немедленно создаёт часть данных в хранилище на диске, включая метаданные и индексы.

:::note Используйте синхронные вставки, если можете выполнять батчинг данных на стороне клиента
Если нет, см. раздел [Асинхронные вставки](#asynchronous-inserts) ниже.
:::

Ниже мы кратко рассмотрим механизм вставки в таблицы MergeTree в ClickHouse:

<Image img={insert_process} size="lg" alt="Insert processes" background="black"/>

#### Шаги на стороне клиента {#client-side-steps}

Для оптимальной производительности данные должны быть ①[ собраны в батчи](https://clickhouse.com/blog/asynchronous-data-inserts-in-clickhouse#data-needs-to-be-batched-for-optimal-performance), поэтому размер батча — это **первое решение**.

ClickHouse сохраняет вставленные данные на диск, [упорядоченными](/guides/best-practices/sparse-primary-indexes#data-is-stored-on-disk-ordered-by-primary-key-columns) по столбцу(ам) первичного ключа таблицы. **Второе решение** — нужно ли ② предварительно отсортировать данные перед передачей на сервер. Если батч приходит предварительно отсортированным по столбцу(ам) первичного ключа, ClickHouse может [пропустить](https://github.com/ClickHouse/ClickHouse/blob/94ce8e95404e991521a5608cd9d636ff7269743d/src/Storages/MergeTree/MergeTreeDataWriter.cpp#L595) шаг ⑩ сортировки, ускоряя ингестию.

Если данные для приёма не имеют заранее определённого формата, **ключевое решение** — выбор формата. ClickHouse поддерживает вставку данных в [более чем 70 форматах](/interfaces/formats). Однако при использовании командного клиента ClickHouse или клиентов для языков программирования этот выбор часто выполняется автоматически. При необходимости этот автоматический выбор также можно явно переопределить.

Следующее **важное решение** — ④ сжимать ли данные перед передачей на сервер ClickHouse. Сжатие уменьшает объём передаваемых данных и повышает эффективность сети, что приводит к более быстрой передаче данных и меньшему использованию полосы пропускания, особенно для больших наборов данных.

Данные ⑤ передаются в сетевой интерфейс ClickHouse — либо [native](/interfaces/tcp), либо [HTTP](/interfaces/http) интерфейс (которые мы [сравним](https://clickhouse.com/blog/clickhouse-input-format-matchup-which-is-fastest-most-efficient#clickhouse-client-defaults) позже в этом материале).

#### Шаги на стороне сервера {#server-side-steps}

После ⑥ получения данных ClickHouse ⑦ распаковывает их, если использовалось сжатие, затем ⑧ разбирает их из исходного формата.

Используя значения из этих отформатированных данных и [DDL](/sql-reference/statements/create/table) целевой таблицы, ClickHouse ⑨ строит в памяти [блок](/development/architecture#block) в формате MergeTree, ⑩ [сортирует](/parts#what-are-table-parts-in-clickhouse) строки по столбцам первичного ключа, если они ещё не были предварительно отсортированы, ⑪ создаёт [разреженный первичный индекс](/guides/best-practices/sparse-primary-indexes), ⑫ применяет [покомпонентное сжатие](/parts#what-are-table-parts-in-clickhouse) и ⑬ записывает данные как новую ⑭ [часть данных](/parts) на диск.

### Используйте батчевые вставки при синхронном режиме {#batch-inserts-if-synchronous}

<BulkInserts/>

### Обеспечьте идемпотентность повторных попыток {#ensure-idempotent-retries}

Синхронные вставки также **идемпотентны**. При использовании движков MergeTree ClickHouse по умолчанию дедуплицирует вставки. Это защищает от неоднозначных случаев сбоев, например:

* Вставка завершилась успешно, но клиент не получил подтверждение из-за сетевого сбоя.
* Вставка завершилась с ошибкой на стороне сервера и привела к тайм-ауту.

В обоих случаях безопасно **повторить вставку**, если состав батча и порядок данных остаются идентичными. По этой причине критически важно, чтобы клиенты выполняли повторные попытки последовательно, не изменяя и не переупорядочивая данные.

### Выберите правильную таблицу для вставки {#choose-the-right-insert-target}

Для шардированных кластеров есть два варианта:

* Вставлять данные напрямую в таблицу **MergeTree** или **ReplicatedMergeTree**. Это наиболее эффективный вариант, когда клиент может самостоятельно распределять нагрузку между шардами. При `internal_replication = true` ClickHouse прозрачно обрабатывает репликацию.
* Вставлять данные в таблицу [Distributed](/engines/table-engines/special/distributed). Это позволяет клиентам отправлять данные на любой узел и поручить ClickHouse пересылку на нужный шард. Это проще, но немного менее эффективно из-за дополнительного шага пересылки. `internal_replication = true` по-прежнему рекомендуется.

**В ClickHouse Cloud все узлы читают и записывают в один и тот же шард (single shard). Вставки автоматически балансируются между узлами. Пользователи могут просто отправлять вставки на публичную конечную точку (endpoint).**

### Выберите правильный формат {#choose-the-right-format}

Выбор правильного входного формата критически важен для эффективной ингестии данных в ClickHouse. При наличии более чем 70 поддерживаемых форматов выбор наиболее производительного варианта может существенно повлиять на скорость вставки, использование CPU и памяти, а также общую эффективность системы. 

Хотя гибкость важна для data engineering-задач и файловых импортов, **приложениям следует отдавать приоритет форматам, ориентированным на производительность**:

* **Native format** (рекомендуется): Наиболее эффективный. Колонко-ориентированный формат, на стороне сервера требуется минимальный парсинг. По умолчанию используется в Go- и Python-клиентах.
* **RowBinary**: Эффективный строковый формат, подходит, если сложно выполнить колонночное преобразование на стороне клиента. Используется Java-клиентом.
* **JSONEachRow**: Прост в использовании, но дорог в парсинге. Подходит для сценариев с низким объёмом данных или для быстрого создания интеграций.

### Используйте сжатие {#use-compression}

Сжатие играет ключевую роль в снижении сетевых накладных расходов, ускорении вставок и уменьшении затрат на хранение в ClickHouse. При грамотном использовании оно повышает производительность ингестии без необходимости изменять формат данных или схему.

Сжатие данных для вставки уменьшает размер полезной нагрузки, отправляемой по сети, минимизируя использование пропускной способности и ускоряя передачу.

Для вставок сжатие особенно эффективно в сочетании с форматом Native, который уже соответствует внутренней колонночной модели хранения ClickHouse. В такой конфигурации сервер может эффективно распаковать и напрямую сохранить данные с минимальными преобразованиями.

#### Используйте LZ4 для скорости, ZSTD для степени сжатия {#use-lz4-for-speed-zstd-for-compression-ratio}

ClickHouse поддерживает несколько кодеков сжатия при передаче данных. Два распространённых варианта:

* **LZ4**: Быстрый и лёгкий. Существенно уменьшает размер данных с минимальной нагрузкой на CPU, что делает его идеальным для вставок с высокой пропускной способностью и вариантом по умолчанию в большинстве клиентов ClickHouse.
* **ZSTD**: Обеспечивает более высокую степень сжатия, но более ресурсоёмок по CPU. Полезен, когда высока стоимость сетевой передачи — например, при межрегиональной передаче данных или между облачными провайдерами, — хотя это немного увеличивает вычислительную нагрузку на клиенте и время распаковки на сервере.

Рекомендуемая практика: используйте LZ4, если только у вас нет ограниченной пропускной способности или значимых затрат на исходящий трафик — в этом случае рассмотрите использование ZSTD.

:::note
В тестах [бенчмарка FastFormats](https://clickhouse.com/blog/clickhouse-input-format-matchup-which-is-fastest-most-efficient) вставки в формате Native, сжатые LZ4, уменьшили размер данных более чем на 50%, сократив время ингестии с 150 до 131 секунды для набора данных объёмом 5,6 GiB. Переход на ZSTD сжал тот же набор данных до 1,69 GiB, но немного увеличил время обработки на стороне сервера.
:::

#### Сжатие снижает использование ресурсов {#compression-reduces-resource-usage}

Сжатие не только уменьшает сетевой трафик — оно также повышает эффективность использования CPU и памяти на сервере. При сжатых данных ClickHouse принимает меньше байт и тратит меньше времени на парсинг больших объёмов входных данных. Этот эффект особенно важен при приёме данных от нескольких параллельных клиентов, например, в сценариях наблюдаемости (observability).

Влияние сжатия на CPU и память невелико для LZ4 и умеренно для ZSTD. Даже под нагрузкой эффективность сервера повышается за счёт уменьшения объёма данных.

**Сочетание сжатия с батчированием и эффективным входным форматом (например, Native) даёт наилучшую производительность ингестии.**

При использовании нативного интерфейса (например, [clickhouse-client](/interfaces/cli)) сжатие LZ4 включено по умолчанию. При необходимости вы можете переключиться на ZSTD через настройки.

С [HTTP-интерфейсом](/interfaces/http) используйте заголовок Content-Encoding для применения сжатия (например, Content-Encoding: lz4). Вся полезная нагрузка должна быть сжата перед отправкой.

### Предварительно сортируйте данные, если это недорого {#pre-sort-if-low-cost}

Предварительная сортировка данных по первичному ключу перед вставкой может повысить эффективность ингестии в ClickHouse, особенно для крупных пакетов вставки. 

Когда данные приходят предварительно отсортированными, ClickHouse может пропустить или упростить внутренний шаг сортировки при создании парта, снижая использование CPU и ускоряя процесс вставки. Предварительная сортировка также улучшает эффективность сжатия, поскольку схожие значения группируются вместе — это позволяет таким кодекам, как LZ4 или ZSTD, достигать более высокой степени сжатия. Это особенно полезно в сочетании с крупными пакетными вставками и сжатием, так как уменьшает и вычислительные накладные расходы, и объём передаваемых данных.

**Тем не менее предварительная сортировка — это опциональная оптимизация, а не требование.** ClickHouse очень эффективно сортирует данные с использованием параллельной обработки, и во многих случаях сортировка на стороне сервера быстрее или удобнее, чем предварительная сортировка на стороне клиента. 

**Мы рекомендуем выполнять предварительную сортировку только в том случае, если данные уже почти отсортированы или если ресурсы на стороне клиента (CPU, память) достаточны и при этом простаивают.** В сценариях, чувствительных к задержкам, или при высокой нагрузке, например в системах наблюдаемости, когда данные поступают вразнобой или от множества агентов, часто лучше отказаться от предварительной сортировки и полагаться на встроенную производительность ClickHouse.

## Асинхронные вставки {#asynchronous-inserts}

<AsyncInserts />

## Выберите интерфейс — HTTP или native {#choose-an-interface}

### Native {#choose-an-interface-native}

ClickHouse предлагает два основных интерфейса для ингестии данных: **native-интерфейс** и **HTTP-интерфейс** — каждый со своими компромиссами между производительностью и гибкостью. Native-интерфейс, используемый [clickhouse-client](/interfaces/cli) и рядом клиентских библиотек для языков, таких как Go и C++, специально оптимизирован под производительность. Он всегда передаёт данные в высокоэффективном формате Native ClickHouse, поддерживает блочное сжатие с помощью LZ4 или ZSTD и минимизирует серверную обработку, перекладывая такие задачи, как парсинг и конвертация форматов, на клиента. 

Он даже позволяет вычислять значения столбцов с MATERIALIZED и DEFAULT на стороне клиента, что даёт возможность серверу полностью пропустить эти шаги. Это делает native-интерфейс идеальным для сценариев высокопроизводительной ингестии данных, где критична эффективность.

### HTTP {#choose-an-interface-http}

В отличие от многих традиционных баз данных, ClickHouse также поддерживает HTTP-интерфейс. **Этот интерфейс, напротив, отдаёт приоритет совместимости и гибкости.** Он позволяет отправлять данные в [любом поддерживаемом формате](/integrations/data-formats) — включая JSON, CSV, Parquet и другие — и широко поддерживается большинством клиентов ClickHouse, включая Python, Java, JavaScript и Rust. 

Часто он предпочтительнее нативного протокола ClickHouse, поскольку позволяет легко маршрутизировать трафик с помощью балансировщиков нагрузки. Следует ожидать небольших различий в производительности вставки по сравнению с нативным протоколом, который имеет немного меньшие накладные расходы.

Однако он не обладает такой глубокой интеграцией, как нативный протокол, и не может выполнять оптимизации на стороне клиента, такие как вычисление материализованных значений или автоматическая конвертация в формат Native. Хотя вставки по HTTP по-прежнему могут сжиматься с использованием стандартных HTTP-заголовков (например, `Content-Encoding: lz4`), сжатие применяется ко всей полезной нагрузке целиком, а не к отдельным блокам данных. Этот интерфейс часто предпочитают в средах, где простота протокола, балансировка нагрузки или широкая совместимость форматов важнее максимальной производительности.

Более подробное описание этих интерфейсов приведено [здесь](/interfaces/overview).

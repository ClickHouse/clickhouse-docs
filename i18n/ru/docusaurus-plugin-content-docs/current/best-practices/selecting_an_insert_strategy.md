---
slug: '/best-practices/selecting-an-insert-strategy'
sidebar_label: 'Выбор стратегии вставки'
sidebar_position: 10
description: 'Страница, описывающая, как выбрать стратегию вставки в ClickHouse'
title: 'Выбор стратегии вставки'
doc_type: guide
show_related_blogs: true
---
import Image from '@theme/IdealImage';
import insert_process from '@site/static/images/bestpractices/insert_process.png';
import async_inserts from '@site/static/images/bestpractices/async_inserts.png';
import AsyncInserts from '@site/i18n/ru/docusaurus-plugin-content-docs/current/best-practices/_snippets/_async_inserts.md';
import BulkInserts from '@site/i18n/ru/docusaurus-plugin-content-docs/current/best-practices/_snippets/_bulk_inserts.md';

Эффективный прием данных составляет основу высокопроизводительных развертываний ClickHouse. Выбор правильной стратегии вставки может существенно повлиять на пропускную способность, стоимость и надежность. В этом разделе приведены лучшие практики, компромиссы и параметры конфигурации, чтобы помочь вам сделать правильный выбор для вашей нагрузки.

:::note
Предполагается, что вы отправляете данные в ClickHouse через клиента. Если вы извлекаете данные в ClickHouse, например, используя встроенные табличные функции, такие как [s3](/sql-reference/table-functions/s3) и [gcs](/sql-reference/table-functions/gcs), мы рекомендуем вам обратиться к нашему руководству ["Оптимизация для скорости вставки и чтения через S3"](/integrations/s3/performance).
:::

## Синхронные вставки по умолчанию {#synchronous-inserts-by-default}

По умолчанию, вставки в ClickHouse являются синхронными. Каждый запрос на вставку немедленно создает часть хранилища на диске, включая метаданные и индексы.

:::note Используйте синхронные вставки, если вы можете пакетировать данные на стороне клиента
Если нет, см. [Асинхронные вставки](#asynchronous-inserts) ниже.
:::

Мы кратко рассмотрим механику вставки MergeTree в ClickHouse ниже:

<Image img={insert_process} size="lg" alt="Процессы вставки" background="black"/>

#### Этапы на стороне клиента {#client-side-steps}

Для оптимальной производительности данные должны быть ① [пакетированы](https://clickhouse.com/blog/asynchronous-data-inserts-in-clickhouse#data-needs-to-be-batched-for-optimal-performance), таким образом размер пакета становится **первым решением**.

ClickHouse хранит вставленные данные на диске, [упорядоченные](/guides/best-practices/sparse-primary-indexes#data-is-stored-on-disk-ordered-by-primary-key-columns) по первичному ключу таблицы. **Второе решение** — это ② предварительная сортировка данных перед передачей на сервер. Если пакет приходит предварительно отсортированным по первичному ключу, ClickHouse может [пропустить](https://github.com/ClickHouse/ClickHouse/blob/94ce8e95404e991521a5608cd9d636ff7269743d/src/Storages/MergeTree/MergeTreeDataWriter.cpp#L595) шаг ⑨ сортировки, ускоряя прием данных.

Если данные для вставки не имеют заранее определенного формата, **ключевым решением** является выбор формата. ClickHouse поддерживает вставку данных в [более чем 70 форматах](/interfaces/formats). Однако, при использовании командного клиента ClickHouse или клиентов языков программирования, этот выбор часто обрабатывается автоматически. При необходимости этот автоматический выбор можно также явно переопределить.

Следующее **основное решение** — ④ нужно ли сжимать данные перед передачей на сервер ClickHouse. Сжатие уменьшает размер передаваемых данных и повышает сетевую эффективность, что приводит к более быстрым передачам данных и меньшему использованию пропускной способности, особенно для крупных наборов данных.

Данные ⑤ передаются на сетевой интерфейс ClickHouse — либо [нативный](/interfaces/tcp), либо [HTTP](/interfaces/http) интерфейс (который мы [сравниваем](https://clickhouse.com/blog/clickhouse-input-format-matchup-which-is-fastest-most-efficient#clickhouse-client-defaults) позже в этом посте).

#### Этапы на стороне сервера {#server-side-steps}

После ⑥ получения данных, ClickHouse ⑦ распаковывает их, если было использовано сжатие, а затем ⑧ разбирает их из первоначально отправленного формата.

Используя значения из этих отформатированных данных и заявление [DDL](/sql-reference/statements/create/table) целевой таблицы, ClickHouse ⑨ создает в памяти [блок](/development/architecture#block) в формате MergeTree, ⑩ [сортирует](/parts#what-are-table-parts-in-clickhouse) строки по столбцам первичного ключа, если они еще не отсортированы, ⑪ создает [разреженный первичный индекс](/guides/best-practices/sparse-primary-indexes), ⑫ применяет [сжатие по колонкам](/parts#what-are-table-parts-in-clickhouse) и ⑬ записывает данные как новую ⑭ [часть данных](/parts) на диск.

### Пакетные вставки, если синхронные {#batch-inserts-if-synchronous}

<BulkInserts/>

### Обеспечьте идемпотентные повторные попытки {#ensure-idempotent-retries}

Синхронные вставки также являются **идемпотентными**. При использовании движков MergeTree ClickHouse по умолчанию будет удалять дубликаты вставок. Это защищает от неоднозначных случаев сбоя, таких как:

* Вставка прошла успешно, но клиент никогда не получил подтверждение из-за сетевого сбоя.
* Вставка не удалась на стороне сервера и вышла за пределы времени ожидания.

В обоих случаях безопасно **повторить вставку** — пока содержимое пакета и порядок остаются идентичными. По этой причине критически важно, чтобы клиенты повторяли попытки последовательно, не изменяя и не меняя порядок данных.

### Выберите правильную цель вставки {#choose-the-right-insert-target}

Для шардированных кластеров у вас есть два варианта:

* Вставлять данные непосредственно в таблицу **MergeTree** или **ReplicatedMergeTree**. Это наиболее эффективный вариант, когда клиент может выполнять нагрузочное распределение по шардированным узлам. При `internal_replication = true` ClickHouse обрабатывает репликацию прозрачно.
* Вставлять данные в [распределенную таблицу](/engines/table-engines/special/distributed). Это позволяет клиентам отправлять данные любому узлу и позволяет ClickHouse перенаправлять их к правильному шардированному узлу. Это проще, но немного менее эффективно из-за дополнительного этапа перенаправления. Рекомендуется использовать `internal_replication = true`.

**В ClickHouse Cloud все узлы читают и записывают данные в один и тот же шард. Вставки автоматически распределяются по узлам. Пользователи могут просто отправлять вставки на открытый конечный узел.**

### Выберите правильный формат {#choose-the-right-format}

Выбор правильного формата ввода имеет решающее значение для эффективного приема данных в ClickHouse. С более чем 70 поддерживаемыми форматами, выбор наиболее производительного варианта может значительно повлиять на скорость вставки, использование CPU и памяти, а также общую эффективность системы.

Хотя гибкость полезна для обработки данных и импорта на основе файлов, **приложения должны придавать приоритет форматам, ориентированным на производительность**:

* **Нативный формат** (рекомендуется): Наиболее эффективный. Ориентирован на столбцы, минимальное парсинг требуется на стороне сервера. Используется по умолчанию в клиентах Go и Python.
* **RowBinary**: Эффективный формат на основе строк, идеален, если преобразование на колонках сложно для клиента. Используется клиентом Java.
* **JSONEachRow**: Легок в использовании, но дорогостоящий в парсинге. Подходит для случаев с низким объемом данных или быстрых интеграций.

### Используйте сжатие {#use-compression}

Сжатие играет критическую роль в уменьшении сетевой нагрузки, ускорении вставок и снижении затрат на хранение в ClickHouse. Эффективно использованное, оно улучшает производительность приема, не требуя изменений в формате данных или схеме.

Сжатие вставляемых данных уменьшает размер полезной нагрузки, отправляемой по сети, минимизируя использование пропускной способности и ускоряя передачу данных.

Для вставок сжатие особенно эффективно при использовании нативного формата, который уже соответствует внутренней модели столбцового хранения ClickHouse. В этой настройке сервер может эффективно распаковывать и напрямую хранить данные с минимальной трансформацией.

#### Используйте LZ4 для скорости, ZSTD для коэффициента сжатия {#use-lz4-for-speed-zstd-for-compression-ratio}

ClickHouse поддерживает несколько кодеков сжатия во время передачи данных. Два распространенных варианта:

* **LZ4**: Быстрый и легковесный. Значительно уменьшает размер данных при минимальных затратах CPU, что делает его идеальным для вставок с высокой пропускной способностью и используется по умолчанию в большинстве клиентов ClickHouse.
* **ZSTD**: Высокий коэффициент сжатия, но более затратный по CPU. Полезен, когда затраты на перенос данных через сеть высоки — например, в сценариях межрегиональных или облачных провайдеров — хотя это немного увеличивает время вычислений на стороне клиента и распаковки на стороне сервера.

Лучшие практики: Используйте LZ4, если у вас нет ограниченной ширины канала или если возникают затраты на выход данных — тогда рассмотрите использование ZSTD.

:::note
В тестах из [бенчмарка FastFormats](https://clickhouse.com/blog/clickhouse-input-format-matchup-which-is-fastest-most-efficient), вставки нативного формата, сжатые с помощью LZ4, уменьшили размер данных более чем на 50%, сократив время приема с 150 секунд до 131 секунд для набора данных в 5.6 ГиБ. Переход на ZSTD сжал тот же набор данных до 1.69 ГиБ, но немного увеличил время обработки на стороне сервера.
:::

#### Сжатие уменьшает использование ресурсов {#compression-reduces-resource-usage}

Сжатие не только снижает сетевой трафик, но и улучшает эффективность CPU и памяти на сервере. С сжатыми данными ClickHouse получает меньше байтов и тратит меньше времени на разбор больших входных данных. Это преимущество особенно важно при приеме данных от нескольких одновременно работающих клиентов, например, в сценариях наблюдения.

Влияние сжатия на CPU и память скромное для LZ4 и умеренное для ZSTD. Даже под нагрузкой эффективность на стороне сервера улучшается за счет уменьшенного объема данных.

**Совмещение сжатия с пакетированием и эффективным форматом ввода (таким как нативный) дает наилучшие результаты по производительности приема.**

При использовании нативного интерфейса (например, [clickhouse-client](/interfaces/cli)) сжатие LZ4 включено по умолчанию. Вы можете опционально переключиться на ZSTD через настройки.

С [HTTP интерфейсом](/interfaces/http) используйте заголовок Content-Encoding для применения сжатия (например, Content-Encoding: lz4). Вся полезная нагрузка должна быть сжата до отправки.

### Предварительная сортировка, если низкая стоимость {#pre-sort-if-low-cost}

Предварительная сортировка данных по первичному ключу перед вставкой может улучшить эффективность приема в ClickHouse, особенно для больших партий.

Когда данные приходят предварительно отсортированными, ClickHouse может пропустить или упростить внутренний шаг сортировки во время создания частей, уменьшая использование CPU и ускоряя процесс вставки. Предварительная сортировка также улучшает эффективность сжатия, поскольку схожие значения группируются вместе, позволяя кодекам, таким как LZ4 или ZSTD, достигать лучшего коэффициента сжатия. Это особенно полезно в сочетании с большими пакетными вставками и сжатием, так как это уменьшает как накладные расходы на обработку, так и объем передаваемых данных.

**Тем не менее, предварительная сортировка является необязательной оптимизацией — не требуемой.** ClickHouse сортирует данные с высокой эффективностью, используя параллельную обработку, и во многих случаях сортировка на стороне сервера быстрее или удобнее, чем предварительная сортировка на стороне клиента.

**Рекомендуем предварительную сортировку только в том случае, если данные уже почти упорядочены или если ресурсы на стороне клиента (CPU, память) достаточны и недостаточно используются.** В сценариях, чувствительных к задержкам или с высокой пропускной способностью, таких как наблюдение, где данные приходят вне порядка или от многих агентов, часто лучше пропускать предварительную сортировку и полагаться на встроенные возможности ClickHouse.

## Асинхронные вставки {#asynchronous-inserts}

<AsyncInserts />

## Выберите интерфейс - HTTP или нативный {#choose-an-interface}

### Нативный {#choose-an-interface-native}

ClickHouse предлагает два основных интерфейса для приема данных: **нативный интерфейс** и **HTTP интерфейс** - каждый из которых имеет компромиссы между производительностью и гибкостью. Нативный интерфейс, используемый клиентом [clickhouse-client](/interfaces/cli) и некоторыми клиентами языков программирования, такими как Go и C++, специально разработан для производительности. Он всегда передает данные в высокоэффективном нативном формате ClickHouse, поддерживает блочное сжатие с LZ4 или ZSTD и минимизирует обработку на стороне сервера, сокращая такие задачи, как разбор и преобразование формата, до клиента. 

Он даже позволяет вычислять значения MATERIALIZED и DEFAULT для колонок на стороне клиента, позволяя серверу пропускать эти шаги целиком. Это делает нативный интерфейс идеальным для сценариев высокой пропускной способности, где эффективность имеет решающее значение.

### HTTP {#choose-an-interface-http}

В отличие от многих традиционных баз данных, ClickHouse также поддерживает HTTP интерфейс. **Это, напротив, придает приоритет совместимости и гибкости.** Он позволяет отправлять данные в [любом поддерживаемом формате](/integrations/data-formats) - включая JSON, CSV, Parquet и другие - и широко поддерживается большинством клиентов ClickHouse, включая Python, Java, JavaScript и Rust.

Это часто предпочтительнее для нативного протокола ClickHouse, поскольку позволяет легко переключать трафик с помощью балансировщиков нагрузки. Мы ожидаем небольшие различия в производительности вставки с нативным протоколом, который требует чуть меньших накладных расходов.

Однако в нем отсутствует более глубокая интеграция нативного протокола, и он не может выполнять клиентские оптимизации, такие как вычисление значений materialized или автоматическое преобразование в нативный формат. Хотя вставки HTTP все еще могут быть сжаты с использованием стандартных заголовков HTTP (например, `Content-Encoding: lz4`), сжатие применяется ко всей полезной нагрузке, а не к отдельным блокам данных. Этот интерфейс часто предпочитают в средах, где простота протокола, балансировка нагрузки или широкая совместимость форматов важнее, чем чистая производительность.

Для более подробного описания этих интерфейсов см. [здесь](/interfaces/overview).
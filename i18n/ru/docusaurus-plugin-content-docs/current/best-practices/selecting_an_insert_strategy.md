---
slug: /best-practices/selecting-an-insert-strategy
sidebar_position: 10
sidebar_label: 'Выбор стратегии INSERT'
title: 'Выбор стратегии INSERT'
description: 'Страница с рекомендациями по выбору стратегии INSERT в ClickHouse'
keywords: ['INSERT', 'asynchronous inserts', 'compression', 'batch inserts']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import insert_process from '@site/static/images/bestpractices/insert_process.png';
import async_inserts from '@site/static/images/bestpractices/async_inserts.png';
import AsyncInserts from '@site/docs/best-practices/_snippets/_async_inserts.md';
import BulkInserts from '@site/docs/best-practices/_snippets/_bulk_inserts.md';

Эффективная загрузка данных является основой высокопроизводительных развертываний ClickHouse. Выбор правильной стратегии вставки может существенно повлиять на пропускную способность, стоимость и надежность. В этом разделе представлены рекомендации, компромиссы и варианты конфигурации, которые помогут вам принять оптимальное решение для вашей нагрузки.

:::note
Далее предполагается, что вы отправляете данные в ClickHouse через клиент. Если вы подтягиваете данные в ClickHouse, например, используя встроенные табличные функции [s3](/sql-reference/table-functions/s3) и [gcs](/sql-reference/table-functions/gcs), мы рекомендуем наше руководство [&quot;Оптимизация производительности вставки и чтения из S3&quot;](/integrations/s3/performance).
:::


## Синхронные вставки по умолчанию {#synchronous-inserts-by-default}

По умолчанию вставки в ClickHouse выполняются синхронно. Каждый запрос вставки немедленно создает часть хранилища на диске, включая метаданные и индексы.

:::note Используйте синхронные вставки, если можете группировать данные на стороне клиента
В противном случае см. раздел [Асинхронные вставки](#asynchronous-inserts) ниже.
:::

Ниже мы кратко рассмотрим механизм вставки MergeTree в ClickHouse:

<Image
  img={insert_process}
  size='lg'
  alt='Процессы вставки'
  background='black'
/>

#### Шаги на стороне клиента {#client-side-steps}

Для оптимальной производительности данные должны быть ①[ сгруппированы](https://clickhouse.com/blog/asynchronous-data-inserts-in-clickhouse#data-needs-to-be-batched-for-optimal-performance), что делает размер пакета **первым решением**.

ClickHouse хранит вставленные данные на диске,[ упорядоченные](/guides/best-practices/sparse-primary-indexes#data-is-stored-on-disk-ordered-by-primary-key-columns) по столбцам первичного ключа таблицы. **Второе решение** — следует ли ② предварительно отсортировать данные перед передачей на сервер. Если пакет поступает предварительно отсортированным по столбцам первичного ключа, ClickHouse может [пропустить](https://github.com/ClickHouse/ClickHouse/blob/94ce8e95404e991521a5608cd9d636ff7269743d/src/Storages/MergeTree/MergeTreeDataWriter.cpp#L595) шаг ⑩ сортировки, ускоряя процесс загрузки.

Если загружаемые данные не имеют предопределенного формата, **ключевым решением** является выбор формата. ClickHouse поддерживает вставку данных в [более чем 70 форматах](/interfaces/formats). Однако при использовании клиента командной строки ClickHouse или клиентов языков программирования этот выбор часто выполняется автоматически. При необходимости автоматический выбор можно явно переопределить.

Следующее **важное решение** — ④ следует ли сжимать данные перед передачей на сервер ClickHouse. Сжатие уменьшает объем передаваемых данных и повышает эффективность использования сети, что приводит к более быстрой передаче данных и меньшему потреблению пропускной способности, особенно для больших наборов данных.

Данные ⑤ передаются на сетевой интерфейс ClickHouse — либо [нативный](/interfaces/tcp), либо[ HTTP](/interfaces/http) интерфейс (которые мы [сравниваем](https://clickhouse.com/blog/clickhouse-input-format-matchup-which-is-fastest-most-efficient#clickhouse-client-defaults) далее в этой статье).

#### Шаги на стороне сервера {#server-side-steps}

После ⑥ получения данных ClickHouse ⑦ распаковывает их, если использовалось сжатие, затем ⑧ парсит их из исходного формата отправки.

Используя значения из этих отформатированных данных и инструкцию [DDL](/sql-reference/statements/create/table) целевой таблицы, ClickHouse ⑨ строит в памяти [блок](/development/architecture#block) в формате MergeTree, ⑩ [сортирует](/parts#what-are-table-parts-in-clickhouse) строки по столбцам первичного ключа, если они еще не отсортированы, ⑪ создает [разреженный первичный индекс](/guides/best-practices/sparse-primary-indexes), ⑫ применяет [сжатие по столбцам](/parts#what-are-table-parts-in-clickhouse) и ⑬ записывает данные в виде новой ⑭ [части данных](/parts) на диск.

### Группируйте вставки при синхронном режиме {#batch-inserts-if-synchronous}

<BulkInserts />

### Обеспечьте идемпотентность повторных попыток {#ensure-idempotent-retries}

Синхронные вставки также являются **идемпотентными**. При использовании движков MergeTree ClickHouse по умолчанию дедуплицирует вставки. Это защищает от неоднозначных случаев сбоя, таких как:

- Вставка выполнена успешно, но клиент не получил подтверждение из-за прерывания сети.
- Вставка завершилась неудачей на стороне сервера, и истекло время ожидания.

В обоих случаях безопасно **повторить вставку** — при условии, что содержимое и порядок пакета остаются идентичными. По этой причине критически важно, чтобы клиенты повторяли попытки последовательно, не изменяя и не переупорядочивая данные.

### Выберите правильную цель для вставки {#choose-the-right-insert-target}

Для шардированных кластеров у вас есть два варианта:

- Вставка напрямую в таблицу **MergeTree** или **ReplicatedMergeTree**. Это наиболее эффективный вариант, когда клиент может выполнять балансировку нагрузки между шардами. При `internal_replication = true` ClickHouse прозрачно обрабатывает репликацию.
- Вставка в [распределенную таблицу](/engines/table-engines/special/distributed). Это позволяет клиентам отправлять данные на любой узел, и ClickHouse перенаправит их на правильный шард. Это проще, но немного менее производительно из-за дополнительного шага перенаправления. Рекомендуется по-прежнему использовать `internal_replication = true`.


**В ClickHouse Cloud все узлы читают и записывают данные в один и тот же шард. Вставки автоматически балансируются между узлами. Пользователи могут просто отправлять вставки на доступную конечную точку.**

### Выбор правильного формата {#choose-the-right-format}

Выбор правильного входного формата имеет решающее значение для эффективной загрузки данных в ClickHouse. При наличии более 70 поддерживаемых форматов выбор наиболее производительного варианта может существенно повлиять на скорость вставки, использование ЦП и памяти, а также на общую эффективность системы.

Хотя гибкость полезна для инженерии данных и импорта на основе файлов, **приложения должны отдавать приоритет форматам, ориентированным на производительность**:

- **Формат Native** (рекомендуется): Наиболее эффективный. Колоночно-ориентированный, требует минимального разбора на стороне сервера. Используется по умолчанию в клиентах Go и Python.
- **RowBinary**: Эффективный строчный формат, идеален, если колоночное преобразование затруднительно на стороне клиента. Используется клиентом Java.
- **JSONEachRow**: Прост в использовании, но требует больших затрат на разбор. Подходит для сценариев с малым объёмом данных или быстрой интеграции.

### Использование сжатия {#use-compression}

Сжатие играет критически важную роль в снижении сетевых издержек, ускорении вставок и снижении затрат на хранение в ClickHouse. При эффективном использовании оно повышает производительность загрузки данных без необходимости изменения формата данных или схемы.

Сжатие вставляемых данных уменьшает размер полезной нагрузки, передаваемой по сети, минимизируя использование пропускной способности и ускоряя передачу.

Для вставок сжатие особенно эффективно при использовании с форматом Native, который уже соответствует внутренней колоночной модели хранения ClickHouse. В такой конфигурации сервер может эффективно распаковывать и напрямую сохранять данные с минимальными преобразованиями.

#### Использование LZ4 для скорости, ZSTD для степени сжатия {#use-lz4-for-speed-zstd-for-compression-ratio}

ClickHouse поддерживает несколько кодеков сжатия при передаче данных. Два распространённых варианта:

- **LZ4**: Быстрый и лёгкий. Значительно уменьшает размер данных при минимальной нагрузке на ЦП, что делает его идеальным для вставок с высокой пропускной способностью и используется по умолчанию в большинстве клиентов ClickHouse.
- **ZSTD**: Более высокая степень сжатия, но более интенсивное использование ЦП. Полезен, когда затраты на передачу по сети высоки — например, в межрегиональных сценариях или при работе с облачными провайдерами — хотя он немного увеличивает вычислительную нагрузку на стороне клиента и время распаковки на стороне сервера.

Рекомендация: используйте LZ4, если только у вас нет ограниченной пропускной способности или затрат на исходящий трафик данных — в таком случае рассмотрите ZSTD.

:::note
В тестах из [бенчмарка FastFormats](https://clickhouse.com/blog/clickhouse-input-format-matchup-which-is-fastest-most-efficient) вставки Native со сжатием LZ4 уменьшили размер данных более чем на 50%, сократив время загрузки с 150 до 131 секунды для набора данных размером 5,6 ГиБ. Переход на ZSTD сжал тот же набор данных до 1,69 ГиБ, но немного увеличил время обработки на стороне сервера.
:::

#### Сжатие снижает использование ресурсов {#compression-reduces-resource-usage}

Сжатие не только снижает сетевой трафик — оно также повышает эффективность использования ЦП и памяти на сервере. При сжатых данных ClickHouse получает меньше байтов и тратит меньше времени на разбор больших входных данных. Это преимущество особенно важно при загрузке данных от нескольких одновременных клиентов, например, в сценариях наблюдаемости.

Влияние сжатия на ЦП и память умеренное для LZ4 и среднее для ZSTD. Даже при нагрузке эффективность на стороне сервера улучшается благодаря уменьшенному объёму данных.

**Сочетание сжатия с пакетной обработкой и эффективным входным форматом (например, Native) обеспечивает наилучшую производительность загрузки данных.**

При использовании нативного интерфейса (например, [clickhouse-client](/interfaces/cli)) сжатие LZ4 включено по умолчанию. При необходимости можно переключиться на ZSTD через настройки.

При использовании [HTTP-интерфейса](/interfaces/http) используйте заголовок Content-Encoding для применения сжатия (например, Content-Encoding: lz4). Вся полезная нагрузка должна быть сжата перед отправкой.

### Предварительная сортировка при низких затратах {#pre-sort-if-low-cost}

Предварительная сортировка данных по первичному ключу перед вставкой может повысить эффективность загрузки данных в ClickHouse, особенно для больших пакетов.

Когда данные поступают предварительно отсортированными, ClickHouse может пропустить или упростить внутренний этап сортировки при создании части, снижая использование ЦП и ускоряя процесс вставки. Предварительная сортировка также повышает эффективность сжатия, поскольку похожие значения группируются вместе — позволяя кодекам, таким как LZ4 или ZSTD, достигать лучшей степени сжатия. Это особенно полезно в сочетании с большими пакетными вставками и сжатием, поскольку снижает как накладные расходы на обработку, так и объём передаваемых данных.

**Тем не менее, предварительная сортировка является необязательной оптимизацией, а не требованием.** ClickHouse сортирует данные очень эффективно с использованием параллельной обработки, и во многих случаях сортировка на стороне сервера быстрее или удобнее, чем предварительная сортировка на стороне клиента.


**Мы рекомендуем выполнять предварительную сортировку только в том случае, если данные уже почти отсортированы или если ресурсы на стороне клиента (CPU, память) достаточны и при этом используются не полностью.** В сценариях, чувствительных к задержкам, или при высоком потоке данных, например в задачах наблюдаемости, когда данные поступают в беспорядке или от множества агентов, часто лучше отказаться от предварительной сортировки и полагаться на встроенную производительность ClickHouse.



## Асинхронные вставки {#asynchronous-inserts}

<AsyncInserts />


## Выбор интерфейса — HTTP или нативный {#choose-an-interface}

### Нативный {#choose-an-interface-native}

ClickHouse предлагает два основных интерфейса для загрузки данных: **нативный интерфейс** и **HTTP-интерфейс** — каждый из которых имеет свои компромиссы между производительностью и гибкостью. Нативный интерфейс, используемый [clickhouse-client](/interfaces/cli) и некоторыми клиентами для языков программирования, таких как Go и C++, специально разработан для обеспечения высокой производительности. Он всегда передает данные в высокоэффективном нативном формате ClickHouse, поддерживает поблочное сжатие с помощью LZ4 или ZSTD и минимизирует обработку на стороне сервера, перекладывая такие задачи, как парсинг и преобразование форматов, на клиент.

Он даже позволяет вычислять значения столбцов MATERIALIZED и DEFAULT на стороне клиента, что позволяет серверу полностью пропустить эти шаги. Это делает нативный интерфейс идеальным для сценариев загрузки с высокой пропускной способностью, где критически важна эффективность.

### HTTP {#choose-an-interface-http}

В отличие от многих традиционных баз данных, ClickHouse также поддерживает HTTP-интерфейс. **Он, в свою очередь, отдает приоритет совместимости и гибкости.** Он позволяет отправлять данные в [любом поддерживаемом формате](/integrations/data-formats) — включая JSON, CSV, Parquet и другие — и широко поддерживается большинством клиентов ClickHouse, включая Python, Java, JavaScript и Rust.

Это часто предпочтительнее нативного протокола ClickHouse, поскольку позволяет легко переключать трафик с помощью балансировщиков нагрузки. Ожидается небольшая разница в производительности вставки по сравнению с нативным протоколом, который создает немного меньше накладных расходов.

Однако ему не хватает более глубокой интеграции нативного протокола, и он не может выполнять оптимизации на стороне клиента, такие как вычисление материализованных значений или автоматическое преобразование в нативный формат. Хотя HTTP-вставки все еще могут быть сжаты с использованием стандартных HTTP-заголовков (например, `Content-Encoding: lz4`), сжатие применяется ко всей полезной нагрузке, а не к отдельным блокам данных. Этот интерфейс часто предпочтителен в средах, где простота протокола, балансировка нагрузки или широкая совместимость форматов важнее, чем максимальная производительность.

Более подробное описание этих интерфейсов см. [здесь](/interfaces/overview).

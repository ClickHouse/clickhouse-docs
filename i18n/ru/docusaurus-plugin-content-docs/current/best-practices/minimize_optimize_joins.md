---
slug: /best-practices/minimize-optimize-joins
sidebar_position: 10
sidebar_label: 'Минимизация и оптимизация JOIN-ов'
title: 'Минимизация и оптимизация JOIN-ов'
description: 'Страница с рекомендациями по лучшим практикам работы с JOIN-ами'
keywords: ['JOIN', 'Parallel Hash JOIN']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import joins from '@site/static/images/bestpractices/joins-speed-memory.png';

ClickHouse поддерживает широкий спектр типов и алгоритмов `JOIN`, и их производительность значительно улучшилась в последних релизах. Однако операции `JOIN` по своей природе дороже, чем запрос к одной денормализованной таблице. Денормализация переносит вычислительную нагрузку с времени выполнения запроса на время вставки или предварительной обработки, что часто приводит к значительно меньшей задержке при выполнении запросов. Для потоковых или чувствительных к задержкам аналитических запросов **настоятельно рекомендуется использовать денормализацию**.

В общем случае стоит денормализовать данные, когда:

* Таблицы изменяются нечасто или допустимы пакетные обновления.
* Связи не являются «многие-ко-многим» или не обладают чрезмерно высокой кардинальностью.
* Будет запрашиваться только ограниченное подмножество столбцов, то есть некоторые столбцы можно исключить из денормализации.
* У вас есть возможность перенести часть обработки из ClickHouse во внешние системы, такие как Flink, где можно управлять обогащением данных в реальном времени или их «выпрямлением» (flattening).

Не все данные необходимо денормализовать — сосредоточьтесь на атрибутах, к которым часто обращаются в запросах. Также рассмотрите использование [материализованных представлений](/best-practices/use-materialized-views) для поэтапного вычисления агрегатов вместо дублирования целых подтаблиц. Когда изменения схемы редки, а задержка критична, денормализация обеспечивает наилучший баланс по производительности.

Полное руководство по денормализации данных в ClickHouse см. [здесь](/data-modeling/denormalization).


## Когда требуются JOIN {#when-joins-are-required}

Когда требуются JOIN, убедитесь, что вы используете **как минимум версию 24.12, а лучше последнюю версию**, поскольку производительность JOIN продолжает улучшаться с каждым новым релизом. Начиная с ClickHouse 24.12, планировщик запросов автоматически размещает меньшую таблицу с правой стороны соединения для оптимальной производительности — задача, которую ранее приходилось выполнять вручную. Скоро появятся ещё более значительные улучшения, включая более агрессивное проталкивание фильтров и автоматическую переупорядочивание множественных соединений.

Следуйте этим рекомендациям для улучшения производительности JOIN:

- **Избегайте декартовых произведений**: Если значение в левой части соответствует нескольким значениям в правой части, JOIN вернёт несколько строк — так называемое декартово произведение. Если вашему сценарию не нужны все совпадения из правой части, а достаточно любого одного совпадения, вы можете использовать `ANY` JOIN (например, `LEFT ANY JOIN`). Они быстрее и используют меньше памяти, чем обычные JOIN.
- **Уменьшайте размеры соединяемых таблиц**: Время выполнения и потребление памяти JOIN растут пропорционально размерам левой и правой таблиц. Чтобы уменьшить объём данных, обрабатываемых JOIN, добавьте дополнительные условия фильтрации в предложения `WHERE` или `JOIN ON` запроса. ClickHouse проталкивает условия фильтрации как можно глубже в план запроса, обычно перед JOIN. Если фильтры не проталкиваются автоматически (по какой-либо причине), перепишите одну сторону JOIN как подзапрос, чтобы принудительно выполнить проталкивание.
- **Используйте прямые JOIN через словари, где это уместно**: Стандартные JOIN в ClickHouse выполняются в две фазы: фаза построения, которая перебирает правую часть для построения хеш-таблицы, за которой следует фаза зондирования, которая перебирает левую часть для поиска соответствующих партнёров соединения через поиск в хеш-таблице. Если правая часть является [словарём](/dictionary) или другим движком таблиц с характеристиками ключ-значение (например, [EmbeddedRocksDB](/engines/table-engines/integrations/embedded-rocksdb) или [движок таблиц Join](/engines/table-engines/special/join)), то ClickHouse может использовать алгоритм «прямого» соединения, который фактически устраняет необходимость построения хеш-таблицы, ускоряя обработку запроса. Это работает для `INNER` и `LEFT OUTER` JOIN и предпочтительно для аналитических рабочих нагрузок в реальном времени.
- **Используйте сортировку таблиц для JOIN**: Каждая таблица в ClickHouse отсортирована по столбцам первичного ключа таблицы. Можно использовать сортировку таблицы, применяя так называемые алгоритмы JOIN с сортировкой-слиянием, такие как `full_sorting_merge` и `partial_merge`. В отличие от стандартных алгоритмов JOIN на основе хеш-таблиц (см. ниже, `parallel_hash`, `hash`, `grace_hash`), алгоритмы JOIN с сортировкой-слиянием сначала сортируют, а затем объединяют обе таблицы. Если запрос соединяет обе таблицы по их соответствующим столбцам первичного ключа, то сортировка-слияние имеет оптимизацию, которая пропускает этап сортировки, экономя время обработки и накладные расходы.
- **Избегайте JOIN со сбросом на диск**: Промежуточные состояния JOIN (например, хеш-таблицы) могут стать настолько большими, что больше не помещаются в оперативную память. В этой ситуации ClickHouse по умолчанию вернёт ошибку нехватки памяти. Некоторые алгоритмы соединения (см. ниже), например [`grace_hash`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2), [`partial_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3) и [`full_sorting_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3), способны сбрасывать промежуточные состояния на диск и продолжать выполнение запроса. Тем не менее, эти алгоритмы соединения следует использовать с осторожностью, поскольку доступ к диску может значительно замедлить обработку соединения. Вместо этого мы рекомендуем оптимизировать запрос JOIN другими способами, чтобы уменьшить размер промежуточных состояний.
- **Значения по умолчанию как маркеры отсутствия совпадений во внешних JOIN**: Левые/правые/полные внешние соединения включают все значения из левой/правой/обеих таблиц. Если для некоторого значения не найден партнёр соединения в другой таблице, ClickHouse заменяет партнёра соединения специальным маркером. Стандарт SQL требует, чтобы базы данных использовали NULL в качестве такого маркера. В ClickHouse это требует обёртывания результирующего столбца в Nullable, создавая дополнительные накладные расходы по памяти и производительности. В качестве альтернативы вы можете настроить параметр `join_use_nulls = 0` и использовать значение по умолчанию типа данных результирующего столбца в качестве маркера.


:::note Осторожно при использовании словарей
При использовании словарей для JOIN в ClickHouse важно понимать, что словари по своей природе не допускают дублирующихся ключей. При загрузке данных любые повторяющиеся ключи незаметно удаляются — сохраняется только последнее загруженное значение для данного ключа. Такое поведение делает словари идеальными для связей «один к одному» или «многие к одному», когда нужно только самое актуальное или эталонное значение. Однако использование словаря для связи «один ко многим» или «многие ко многим» (например, при соединении ролей с актёрами, где у актёра может быть несколько ролей) приведёт к незаметной потере данных, так как все совпадающие строки, кроме одной, будут отброшены. В результате словари не подходят для сценариев, где требуется полная реляционная точность при наличии нескольких совпадений.
:::



## Выбор подходящего алгоритма JOIN {#choosing-the-right-join-algorithm}

ClickHouse поддерживает несколько алгоритмов JOIN, которые представляют собой компромисс между скоростью и потреблением памяти:

- **Parallel Hash JOIN (по умолчанию):** Быстрый для небольших и средних правых таблиц, помещающихся в память.
- **Direct JOIN:** Идеален при использовании словарей (или других движков таблиц с характеристиками ключ-значение) с `INNER` или `LEFT ANY JOIN` — самый быстрый метод для точечных запросов, так как исключает необходимость построения хеш-таблицы.
- **Full Sorting Merge JOIN:** Эффективен, когда обе таблицы отсортированы по ключу соединения.
- **Partial Merge JOIN:** Минимизирует потребление памяти, но работает медленнее — лучше всего подходит для соединения больших таблиц при ограниченной памяти.
- **Grace Hash JOIN:** Гибкий и настраиваемый по памяти, хорош для больших наборов данных с регулируемыми характеристиками производительности.

<Image img={joins} size='md' alt='Соединения — скорость против памяти' />

:::note
Каждый алгоритм имеет различную поддержку типов JOIN. Полный список поддерживаемых типов соединений для каждого алгоритма можно найти [здесь](/guides/joining-tables#choosing-a-join-algorithm).
:::

Вы можете позволить ClickHouse выбрать оптимальный алгоритм, установив `join_algorithm = 'auto'` (по умолчанию), или явно управлять им в зависимости от вашей рабочей нагрузки. Если вам нужно выбрать алгоритм соединения для оптимизации производительности или потребления памяти, мы рекомендуем [это руководство](/guides/joining-tables#choosing-a-join-algorithm).

Для оптимальной производительности:

- Сводите количество JOIN к минимуму в высокопроизводительных рабочих нагрузках.
- Избегайте более 3–4 соединений на запрос.
- Тестируйте различные алгоритмы на реальных данных — производительность зависит от распределения ключей JOIN и размера данных.

Для получения дополнительной информации о стратегиях оптимизации JOIN, алгоритмах JOIN и способах их настройки обратитесь к [документации ClickHouse](/guides/joining-tables) и этой [серии статей в блоге](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1).

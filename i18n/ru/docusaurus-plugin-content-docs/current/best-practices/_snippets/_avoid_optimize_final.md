import Image from '@theme/IdealImage';
import simple_merges from '@site/static/images/bestpractices/simple_merges.png';

Таблицы ClickHouse, использующие **движок MergeTree**, хранят данные на диске в виде **неизменяемых кусков**, которые создаются при каждой вставке данных.

Каждая вставка создает новый кусок, содержащий отсортированные и сжатые файлы столбцов, а также метаданные, такие как индексы и контрольные суммы. Подробное описание структуры кусков и процесса их формирования приведено в этом [руководстве](/parts).

Со временем фоновые процессы объединяют мелкие куски в более крупные, чтобы уменьшить фрагментацию и улучшить производительность запросов.

<Image img={simple_merges} size="md" alt="Простые слияния" />

Хотя может возникнуть желание вручную инициировать это слияние с помощью:

```sql
OPTIMIZE TABLE <таблица> FINAL;
```

**в большинстве случаев следует избегать операции `OPTIMIZE FINAL`**, так как она запускает ресурсоёмкие процессы, которые могут повлиять на производительность кластера.

:::note OPTIMIZE FINAL vs FINAL
`OPTIMIZE FINAL` — это не то же самое, что `FINAL`, который иногда необходимо использовать,
чтобы получить результаты без дубликатов, например, с `ReplacingMergeTree`. В целом,
`FINAL` можно использовать, если ваши запросы фильтруют по тем же столбцам,
что и столбцы первичного ключа.
:::


## Почему следует избегать? {#why-avoid}

### Это дорого {#its-expensive}

Выполнение `OPTIMIZE FINAL` заставляет ClickHouse объединить **все** активные куски в **один кусок**, даже если крупные слияния уже произошли. Это включает:

1. **Распаковку** всех кусков
2. **Слияние** данных
3. **Повторное сжатие**
4. **Запись** итогового куска на диск или в объектное хранилище

Эти операции **интенсивно используют CPU и I/O** и могут создать значительную нагрузку на систему, особенно при работе с большими объёмами данных.

### Игнорирует защитные ограничения {#it-ignores-safety-limits}

Обычно ClickHouse избегает слияния кусков размером более ~150 ГБ (настраивается через [max_bytes_to_merge_at_max_space_in_pool](/operations/settings/merge-tree-settings#max_bytes_to_merge_at_max_space_in_pool)). Но `OPTIMIZE FINAL` **игнорирует эту защиту**, что означает:

- Может попытаться объединить **несколько кусков по 150 ГБ** в один массивный кусок
- Это может привести к **длительному времени слияния**, **нехватке памяти** или даже **ошибкам out-of-memory**
- Такие крупные куски могут стать проблемными для слияния, т. е. попытки дальнейшего слияния будут завершаться неудачей по причинам, указанным выше. В случаях, когда слияния необходимы для корректного поведения запросов, это может привести к нежелательным последствиям, таким как [накопление дубликатов в ReplacingMergeTree](/guides/developer/deduplication#using-replacingmergetree-for-upserts), что снижает производительность запросов.


## Позвольте фоновым слияниям делать свою работу {#let-background-merges-do-the-work}

ClickHouse уже выполняет интеллектуальные фоновые слияния для оптимизации хранения и эффективности запросов. Они выполняются инкрементально, учитывают доступные ресурсы и соблюдают настроенные пороговые значения. Если у вас нет особой необходимости (например, финализация данных перед заморозкой таблицы или экспортом), **лучше позволить ClickHouse управлять слияниями самостоятельно**.

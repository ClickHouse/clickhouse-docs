import Image from '@theme/IdealImage';
import simple_merges from '@site/static/images/bestpractices/simple_merges.png';

Таблицы ClickHouse, использующие **движок MergeTree**, хранят данные на диске в виде **неизменяемых частей (parts)**, которые создаются при каждой вставке данных.

Каждая вставка создает новую часть, содержащую отсортированные, сжатые файлы столбцов, а также метаданные, такие как индексы и контрольные суммы. Подробное описание структуры частей и порядка их формирования приведено в этом [руководстве](/parts).

Со временем фоновые процессы объединяют небольшие части в более крупные, чтобы уменьшить фрагментацию и повысить производительность запросов.

<Image img={simple_merges} size="md" alt="Простые слияния" />

При этом нередко возникает соблазн инициировать это слияние вручную с помощью:

```sql
OPTIMIZE TABLE <таблица> FINAL;
```

**в большинстве случаев следует избегать операции `OPTIMIZE FINAL`**, поскольку она запускает
ресурсоёмкие процессы, которые могут повлиять на производительность кластера.

:::note OPTIMIZE FINAL vs FINAL
`OPTIMIZE FINAL` — это не то же самое, что `FINAL`, который иногда необходимо использовать,
чтобы получить результаты без дубликатов, например, с `ReplacingMergeTree`. Как правило,
`FINAL` допустимо использовать, если ваши запросы фильтруют по тем же столбцам, что и столбцы
первичного ключа.
:::


## Почему следует избегать? {#why-avoid}

### Это дорого {#its-expensive}

Выполнение `OPTIMIZE FINAL` заставляет ClickHouse объединить **все** активные куски в **один кусок**, даже если крупные слияния уже произошли. Это включает:

1. **Распаковку** всех кусков
2. **Слияние** данных
3. **Повторное сжатие**
4. **Запись** итогового куска на диск или в объектное хранилище

Эти операции **интенсивно используют процессор и подсистему ввода-вывода** и могут создать значительную нагрузку на систему, особенно при работе с большими объёмами данных.

### Игнорирует защитные ограничения {#it-ignores-safety-limits}

Обычно ClickHouse избегает слияния кусков размером более ~150 ГБ (настраивается через [max_bytes_to_merge_at_max_space_in_pool](/operations/settings/merge-tree-settings#max_bytes_to_merge_at_max_space_in_pool)). Однако `OPTIMIZE FINAL` **игнорирует эту защиту**, что означает:

- Может попытаться объединить **несколько кусков по 150 ГБ** в один массивный кусок
- Это может привести к **длительному времени слияния**, **нехватке памяти** или даже **ошибкам исчерпания памяти**
- Эти крупные куски могут стать проблемными для слияния, т. е. попытки дальнейшего слияния будут завершаться неудачей по причинам, указанным выше. В случаях, когда слияния необходимы для корректного поведения запросов, это может привести к нежелательным последствиям, таким как [накопление дубликатов в ReplacingMergeTree](/guides/developer/deduplication#using-replacingmergetree-for-upserts), что снижает производительность выполнения запросов.


## Позвольте фоновым слияниям делать свою работу {#let-background-merges-do-the-work}

ClickHouse уже выполняет интеллектуальные фоновые слияния для оптимизации хранения и эффективности запросов. Они выполняются инкрементально, учитывают доступные ресурсы и соблюдают настроенные пороговые значения. Если у вас нет особой необходимости (например, финализация данных перед заморозкой таблицы или экспортом), **лучше позволить ClickHouse управлять слияниями самостоятельно**.

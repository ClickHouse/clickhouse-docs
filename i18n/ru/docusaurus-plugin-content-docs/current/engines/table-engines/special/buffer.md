---
description: 'Буферизует записываемые данные в оперативной памяти (RAM), периодически
  сбрасывая их в другую таблицу. При выполнении операции чтения данные читаются
  одновременно из буфера и из другой таблицы.'
sidebar_label: 'Buffer'
sidebar_position: 120
slug: /engines/table-engines/special/buffer
title: 'Табличный движок Buffer'
doc_type: 'reference'
---



# Движок таблиц Buffer

Буферизует данные для записи в оперативной памяти, периодически сбрасывая их в другую таблицу. При чтении данные считываются одновременно из буфера и из другой таблицы.

:::note
Рекомендуемой альтернативой движку таблиц Buffer является использование [асинхронных вставок](/guides/best-practices/asyncinserts.md).
:::

```sql
Buffer(database, table, num_layers, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes [,flush_time [,flush_rows [,flush_bytes]]])
```

### Параметры движка {#engine-parameters}

#### `database` {#database}

`database` – имя базы данных. Можно использовать `currentDatabase()` или другое константное выражение, возвращающее строку.

#### `table` {#table}

`table` – таблица, в которую сбрасываются данные.

#### `num_layers` {#num_layers}

`num_layers` – уровень параллелизма. Физически таблица будет представлена в виде `num_layers` независимых буферов.

#### `min_time`, `max_time`, `min_rows`, `max_rows`, `min_bytes` и `max_bytes` {#min_time-max_time-min_rows-max_rows-min_bytes-and-max_bytes}

Условия для сброса данных из буфера.

### Необязательные параметры движка {#optional-engine-parameters}

#### `flush_time`, `flush_rows` и `flush_bytes` {#flush_time-flush_rows-and-flush_bytes}

Условия для сброса данных из буфера в фоновом режиме (если параметры опущены или равны нулю, параметры `flush*` не используются).

Данные сбрасываются из буфера и записываются в целевую таблицу, если выполнены все условия `min*` или хотя бы одно условие `max*`.

Кроме того, если выполнено хотя бы одно условие `flush*`, сброс инициируется в фоновом режиме. Это отличается от `max*`, поскольку `flush*` позволяет настроить фоновые сбросы отдельно, чтобы избежать увеличения задержки для запросов `INSERT` в таблицы Buffer.

#### `min_time`, `max_time` и `flush_time` {#min_time-max_time-and-flush_time}

Условие по времени в секундах с момента первой записи в буфер.

#### `min_rows`, `max_rows` и `flush_rows` {#min_rows-max_rows-and-flush_rows}

Условие по количеству строк в буфере.

#### `min_bytes`, `max_bytes` и `flush_bytes` {#min_bytes-max_bytes-and-flush_bytes}

Условие по количеству байтов в буфере.

При записи данные вставляются в один или несколько случайных буферов (настраивается параметром `num_layers`). Если же вставляемая порция данных достаточно велика (больше `max_rows` или `max_bytes`), она записывается непосредственно в целевую таблицу, минуя буфер.

Условия для сброса данных рассчитываются отдельно для каждого из `num_layers` буферов. Например, если `num_layers = 16` и `max_bytes = 100000000`, максимальное потребление оперативной памяти составит 1,6 ГБ.

Пример:

```sql
CREATE TABLE merge.hits_buffer AS merge.hits ENGINE = Buffer(merge, hits, 1, 10, 100, 10000, 1000000, 10000000, 100000000)
```

Создание таблицы `merge.hits_buffer` с той же структурой, что и `merge.hits`, с использованием движка Buffer. При записи в эту таблицу данные буферизуются в оперативной памяти и затем записываются в таблицу 'merge.hits'. Создается один буфер, и данные сбрасываются, если выполняется одно из следующих условий:

- прошло 100 секунд с момента последнего сброса (`max_time`), или
- записан 1 миллион строк (`max_rows`), или
- записано 100 МБ данных (`max_bytes`), или
- прошло 10 секунд (`min_time`) и записано 10 000 строк (`min_rows`) и 10 МБ (`min_bytes`) данных

Например, если была записана только одна строка, через 100 секунд она будет сброшена в любом случае. Но если было записано много строк, данные будут сброшены раньше.

При остановке сервера, выполнении `DROP TABLE` или `DETACH TABLE` буферизованные данные также сбрасываются в целевую таблицу.

Можно указать пустые строки в одинарных кавычках для имени базы данных и таблицы. Это означает отсутствие целевой таблицы. В этом случае при достижении условий сброса данных буфер просто очищается. Это может быть полезно для хранения окна данных в памяти.


При чтении из таблицы Buffer данные обрабатываются как из буфера, так и из целевой таблицы (если она существует).
Учтите, что таблица Buffer не поддерживает индекс. Другими словами, данные в буфере полностью сканируются, что может быть медленным для больших буферов. (Для данных во вспомогательной таблице будет использоваться индекс, который она поддерживает.)

Если набор столбцов в таблице Buffer не совпадает с набором столбцов во вспомогательной таблице, вставляется подмножество столбцов, присутствующих в обеих таблицах.

Если типы не совпадают для одного из столбцов в таблице Buffer и во вспомогательной таблице, в журнал сервера записывается сообщение об ошибке, и буфер очищается.
То же самое происходит, если вспомогательная таблица не существует в момент сброса буфера.

:::note
Выполнение ALTER для таблицы Buffer в релизах, выпущенных до 26 октября 2021 года, приведёт к ошибке `Block structure mismatch` (см. [#15117](https://github.com/ClickHouse/ClickHouse/issues/15117) и [#30565](https://github.com/ClickHouse/ClickHouse/pull/30565)), поэтому единственный вариант — удалить таблицу Buffer и затем заново её создать. Перед попыткой выполнить ALTER для таблицы Buffer убедитесь, что эта ошибка исправлена в вашем релизе.
:::

Если сервер перезапущен аварийно, данные в буфере теряются.

`FINAL` и `SAMPLE` работают некорректно для таблиц Buffer. Эти условия передаются в целевую таблицу, но не используются при обработке данных в буфере. Если эти возможности необходимы, рекомендуется использовать таблицу Buffer только для записи, а чтение выполнять из целевой таблицы.

При добавлении данных в таблицу Buffer один из буферов блокируется. Это вызывает задержки, если одновременно с этим выполняется операция чтения из таблицы.

Данные, вставленные в таблицу Buffer, могут попасть во вспомогательную таблицу в другом порядке и в других блоках. Из‑за этого таблицу Buffer сложно корректно использовать для записи в CollapsingMergeTree. Чтобы избежать проблем, можно установить значение `num_layers` равным 1.

Если целевая таблица реплицируется, некоторые ожидаемые свойства реплицируемых таблиц теряются при записи в таблицу Buffer. Случайные изменения порядка строк и размеров кусков данных приводят к тому, что дедупликация данных перестаёт работать, что означает невозможность обеспечить надёжную запись в реплицируемые таблицы с семантикой «ровно один раз».

Из‑за этих недостатков мы можем рекомендовать использовать таблицу Buffer только в редких случаях.

Таблица Buffer используется, когда за единицу времени поступает слишком много операторов INSERT от большого числа серверов и данные не могут быть буферизованы перед вставкой, то есть операции INSERT не успевают выполняться достаточно быстро.

Обратите внимание, что вставка данных по одной строке не имеет смысла даже для таблиц Buffer. Это обеспечит скорость всего в несколько тысяч строк в секунду, в то время как вставка больших блоков данных может давать более миллиона строк в секунду.

---
slug: /engines/table-engines/special/memory
sidebar_position: 110
sidebar_label:  Память
title: "Движок таблицы Memory"
description: "Движок Memory хранит данные в RAM в некорректированном виде. Данные хранятся в точно такой же форме, в какой они поступают при чтении. Другими словами, чтение из этой таблицы абсолютно бесплатно."
---


# Движок таблицы Memory

:::note
При использовании движка таблицы Memory на ClickHouse Cloud данные не реплицируются по всем узлам (по замыслу). Чтобы гарантировать, что все запросы направляются на один и тот же узел и что движок таблицы Memory работает как ожидалось, вы можете сделать одно из следующих:
- Выполнять все операции в одной сессии
- Использовать клиент, который использует TCP или родной интерфейс (что позволяет поддерживать "липкие" соединения), например, [clickhouse-client](/interfaces/cli)
:::

Движок Memory хранит данные в RAM в некорректированном виде. Данные хранятся в точно такой же форме, в какой они поступают при чтении. Другими словами, чтение из этой таблицы абсолютно бесплатно.
Одновременный доступ к данным синхронизирован. Блокировки короткие: операции чтения и записи не блокируют друг друга.
Индексы не поддерживаются. Чтение параллелизовано.

Максимальная производительность (более 10 ГБ/с) достигается на простых запросах, потому что нет чтения с диска, декомпрессии или десериализации данных. (Следует отметить, что во многих случаях производительность движка MergeTree почти так же высока.)
При перезапуске сервера данные исчезают из таблицы, и таблица становится пустой.
Обычно использование этого движка таблицы не оправдано. Однако его можно использовать для тестов и для задач, где требуется максимальная скорость на относительно небольшом количестве строк (до примерно 100 000 000).

Движок Memory используется системой для временных таблиц с внешними данными запроса (см. раздел "Внешние данные для обработки запроса") и для реализации `GLOBAL IN` (см. раздел "Операторы IN").

Можно указать верхние и нижние границы, чтобы ограничить размер таблицы движка Memory, эффективно позволяя ей действовать как кольцевой буфер (см. [Параметры движка](#engine-parameters)).

## Параметры движка {#engine-parameters}

- `min_bytes_to_keep` — Минимальное количество байт для сохранения, когда размер таблицы в памяти ограничен.
  - Значение по умолчанию: `0`
  - Требует `max_bytes_to_keep`
- `max_bytes_to_keep` — Максимальное количество байт для сохранения в таблице памяти, где старые строки удаляются при каждом вставлении (т.е. кольцевой буфер). Максимальное количество байт может превышать указанное ограничение, если самая старая партия строк для удаления попадает под ограничение `min_bytes_to_keep` при добавлении большого блока.
  - Значение по умолчанию: `0`
- `min_rows_to_keep` — Минимальное количество строк для сохранения, когда размер таблицы в памяти ограничен.
  - Значение по умолчанию: `0`
  - Требует `max_rows_to_keep`
- `max_rows_to_keep` — Максимальное количество строк для сохранения в таблице памяти, где старые строки удаляются при каждом вставлении (т.е. кольцевой буфер). Максимальное количество строк может превышать указанное ограничение, если самая старая партия строк для удаления попадает под ограничение `min_rows_to_keep` при добавлении большого блока.
  - Значение по умолчанию: `0`
- `compress` - Необходимо ли сжимать данные в памяти.
  - Значение по умолчанию: `false`

## Использование {#usage}

**Инициализация настроек**
``` sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_rows_to_keep = 100, max_rows_to_keep = 1000;
```

**Изменение настроек**
```sql
ALTER TABLE memory MODIFY SETTING min_rows_to_keep = 100, max_rows_to_keep = 1000;
```

**Примечание:** Параметры ограничения как `bytes`, так и `rows` могут быть установлены одновременно, однако будут соблюдены нижние границы `max` и `min`.

## Примеры {#examples}
``` sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_bytes_to_keep = 4096, max_bytes_to_keep = 16384;

/* 1. тестирование того, что самая старая партия не удаляется из-за минимального порога - 3000 строк */
INSERT INTO memory SELECT * FROM numbers(0, 1600); -- 8'192 байт

/* 2. добавление блока, который не удаляется */
INSERT INTO memory SELECT * FROM numbers(1000, 100); -- 1'024 байт

/* 3. тестирование того, что самая старая партия удаляется - 9216 байт - 1100 */
INSERT INTO memory SELECT * FROM numbers(9000, 1000); -- 8'192 байт

/* 4. проверка, что очень большой блок переопределяет все */
INSERT INTO memory SELECT * FROM numbers(9000, 10000); -- 65'536 байт

SELECT total_bytes, total_rows FROM system.tables WHERE name = 'memory' and database = currentDatabase();
```

``` text
┌─total_bytes─┬─total_rows─┐
│       65536 │      10000 │
└─────────────┴────────────┘
```

также, для строк:

``` sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_rows_to_keep = 4000, max_rows_to_keep = 10000;

/* 1. тестирование того, что самая старая партия не удаляется из-за минимального порога - 3000 строк */
INSERT INTO memory SELECT * FROM numbers(0, 1600); -- 1'600 строк

/* 2. добавление блока, который не удаляется */
INSERT INTO memory SELECT * FROM numbers(1000, 100); -- 100 строк

/* 3. тестирование того, что самая старая партия удаляется - 9216 байт - 1100 */
INSERT INTO memory SELECT * FROM numbers(9000, 1000); -- 1'000 строк

/* 4. проверка, что очень большой блок переопределяет все */
INSERT INTO memory SELECT * FROM numbers(9000, 10000); -- 10'000 строк

SELECT total_bytes, total_rows FROM system.tables WHERE name = 'memory' and database = currentDatabase();
```

``` text
┌─total_bytes─┬─total_rows─┐
│       65536 │      10000 │
└─────────────┴────────────┘
```

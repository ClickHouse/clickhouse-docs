---
description: 'Движок Memory хранит данные в оперативной памяти в несжатом виде. Данные
  хранятся в точно таком же виде, в каком они поступают при записи. Другими словами, чтение
  из этой таблицы полностью бесплатно.'
sidebar_label: 'Memory'
sidebar_position: 110
slug: /engines/table-engines/special/memory
title: 'Движок таблицы Memory'
doc_type: 'reference'
---



# Табличный движок Memory

:::note
При использовании табличного движка Memory в ClickHouse Cloud данные намеренно не реплицируются по всем узлам. Чтобы гарантировать, что все запросы направляются на один и тот же узел и табличный движок Memory работает ожидаемым образом, вы можете выполнить одно из следующих действий:
- Выполнять все операции в одной и той же сессии
- Использовать клиент, который работает по TCP или использует нативный интерфейс (что обеспечивает поддержку закреплённых соединений), например [clickhouse-client](/interfaces/cli)
:::

Движок Memory хранит данные в ОЗУ в несжатом виде. Данные хранятся в точно том же виде, в котором они были получены при чтении. Другими словами, чтение из этой таблицы не накладывает дополнительных накладных расходов.
Параллельный доступ к данным синхронизирован. Блокировки кратковременны: операции чтения и записи не блокируют друг друга.
Индексы не поддерживаются. Чтение выполняется параллельно.

Максимальная производительность (более 10 ГБ/с) достигается на простых запросах, потому что нет чтения с диска, декомпрессии или десериализации данных. (Следует отметить, что во многих случаях производительность движка MergeTree почти столь же высока.)
При перезапуске сервера данные исчезают из таблицы, и таблица становится пустой.
Обычно использование этого табличного движка неоправданно. Однако его можно применять для тестов и для задач, где требуется максимальная скорость при относительно небольшом количестве строк (до примерно 100 000 000).

Движок Memory используется системой для временных таблиц с внешними данными запроса (см. раздел «Внешние данные для обработки запроса»), а также для реализации `GLOBAL IN` (см. раздел «Операторы IN»).

Для ограничения размера таблицы с движком Memory могут быть заданы верхняя и нижняя границы, что позволяет эффективно использовать её как кольцевой буфер (см. [Параметры движка](#engine-parameters)).



## Параметры движка {#engine-parameters}

- `min_bytes_to_keep` — Минимальное количество байт, которое необходимо сохранять при ограничении размера таблицы в памяти.
  - Значение по умолчанию: `0`
  - Требует указания `max_bytes_to_keep`
- `max_bytes_to_keep` — Максимальное количество байт для хранения в таблице в памяти, при превышении которого самые старые строки удаляются при каждой вставке (т.е. кольцевой буфер). Максимальное количество байт может превысить указанный лимит, если самая старая партия строк для удаления находится в пределах лимита `min_bytes_to_keep` при добавлении большого блока.
  - Значение по умолчанию: `0`
- `min_rows_to_keep` — Минимальное количество строк, которое необходимо сохранять при ограничении размера таблицы в памяти.
  - Значение по умолчанию: `0`
  - Требует указания `max_rows_to_keep`
- `max_rows_to_keep` — Максимальное количество строк для хранения в таблице в памяти, при превышении которого самые старые строки удаляются при каждой вставке (т.е. кольцевой буфер). Максимальное количество строк может превысить указанный лимит, если самая старая партия строк для удаления находится в пределах лимита `min_rows_to_keep` при добавлении большого блока.
  - Значение по умолчанию: `0`
- `compress` — Определяет, следует ли сжимать данные в памяти.
  - Значение по умолчанию: `false`


## Использование {#usage}

**Инициализация настроек**

```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_rows_to_keep = 100, max_rows_to_keep = 1000;
```

**Изменение настроек**

```sql
ALTER TABLE memory MODIFY SETTING min_rows_to_keep = 100, max_rows_to_keep = 1000;
```

**Примечание:** Параметры ограничения `bytes` и `rows` могут быть установлены одновременно, однако при этом будут соблюдаться нижние границы `max` и `min`.


## Примеры {#examples}

```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_bytes_to_keep = 4096, max_bytes_to_keep = 16384;

/* 1. проверка того, что самый старый блок не удаляется из-за минимального порога - 3000 строк */
INSERT INTO memory SELECT * FROM numbers(0, 1600); -- 8'192 байта

/* 2. добавление блока, который не удаляется */
INSERT INTO memory SELECT * FROM numbers(1000, 100); -- 1'024 байта

/* 3. проверка того, что самый старый блок удаляется - 9216 байт - 1100 */
INSERT INTO memory SELECT * FROM numbers(9000, 1000); -- 8'192 байта

/* 4. проверка того, что очень большой блок замещает все остальные */
INSERT INTO memory SELECT * FROM numbers(9000, 10000); -- 65'536 байт

SELECT total_bytes, total_rows FROM system.tables WHERE name = 'memory' AND database = currentDatabase();
```

```text
┌─total_bytes─┬─total_rows─┐
│       65536 │      10000 │
└─────────────┴────────────┘
```

также для строк:

```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_rows_to_keep = 4000, max_rows_to_keep = 10000;

/* 1. проверка того, что самый старый блок не удаляется из-за минимального порога - 3000 строк */
INSERT INTO memory SELECT * FROM numbers(0, 1600); -- 1'600 строк

/* 2. добавление блока, который не удаляется */
INSERT INTO memory SELECT * FROM numbers(1000, 100); -- 100 строк

/* 3. проверка того, что самый старый блок удаляется - 9216 байт - 1100 */
INSERT INTO memory SELECT * FROM numbers(9000, 1000); -- 1'000 строк

/* 4. проверка того, что очень большой блок замещает все остальные */
INSERT INTO memory SELECT * FROM numbers(9000, 10000); -- 10'000 строк

SELECT total_bytes, total_rows FROM system.tables WHERE name = 'memory' AND database = currentDatabase();
```

```text
┌─total_bytes─┬─total_rows─┐
│       65536 │      10000 │
└─────────────┴────────────┘
```

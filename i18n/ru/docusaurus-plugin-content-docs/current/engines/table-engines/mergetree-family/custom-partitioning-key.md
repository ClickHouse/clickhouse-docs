---
description: 'Узнайте, как добавить пользовательский ключ партиционирования для таблиц MergeTree.'
sidebar_label: 'Пользовательский ключ партиционирования'
sidebar_position: 30
slug: /engines/table-engines/mergetree-family/custom-partitioning-key
title: 'Пользовательский ключ партиционирования'
doc_type: 'guide'
---



# Пользовательский ключ партиционирования

:::note
В большинстве случаев вам вообще не нужен ключ партиционирования, а в большинстве остальных случаев достаточно партиционирования по месяцам, за исключением сценариев наблюдаемости (observability), где часто используется партиционирование по дням.

Никогда не используйте чрезмерно детальное партиционирование. Не партиционируйте данные по идентификаторам или именам клиентов. Вместо этого сделайте идентификатор или имя клиента первым столбцом в выражении ORDER BY.
:::

Партиционирование доступно для [таблиц семейства MergeTree](../../../engines/table-engines/mergetree-family/mergetree.md), включая [реплицируемые таблицы](../../../engines/table-engines/mergetree-family/replication.md) и [материализованные представления](/sql-reference/statements/create/view#materialized-view).

Партиция — это логическое объединение записей в таблице по заданному критерию. Вы можете задать партиционирование по произвольному критерию, например по месяцу, дню или типу события. Каждая партиция хранится отдельно, чтобы упростить операции с этими данными. При доступе к данным ClickHouse использует наименьшее возможное подмножество партиций. Партиционирование повышает производительность запросов, содержащих ключ партиционирования, поскольку ClickHouse отфильтрует нужную партицию до выбора кусков (parts) и гранул внутри этой партиции.

Партиция задаётся в предложении `PARTITION BY expr` при [создании таблицы](../../../engines/table-engines/mergetree-family/mergetree.md#table_engine-mergetree-creating-a-table). Ключ партиционирования может быть любым выражением из столбцов таблицы. Например, чтобы указать партиционирование по месяцам, используйте выражение `toYYYYMM(date_column)`:

```sql
CREATE TABLE visits
(
    VisitDate Date,
    Hour UInt8,
    ClientID UUID
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(VisitDate)
ORDER BY Hour;
```

Ключ партиционирования также может представлять собой кортеж выражений (аналогично [первичному ключу](../../../engines/table-engines/mergetree-family/mergetree.md#primary-keys-and-indexes-in-queries)). Например:

```sql
ENGINE = ReplicatedCollapsingMergeTree('/clickhouse/tables/name', 'replica1', Sign)
PARTITION BY (toMonday(StartDate), EventType)
ORDER BY (CounterID, StartDate, intHash32(UserID));
```

В этом примере мы настраиваем секционирование по типам событий, которые произошли на текущей неделе.

По умолчанию ключ секционирования с плавающей запятой не поддерживается. Чтобы его использовать, включите настройку [allow&#95;floating&#95;point&#95;partition&#95;key](../../../operations/settings/merge-tree-settings.md#allow_floating_point_partition_key).

При вставке новых данных в таблицу эти данные сохраняются как отдельная часть (chunk), отсортированная по первичному ключу. Через 10–15 минут после вставки части одного и того же раздела объединяются в единую часть.

:::info
Объединение работает только для частей данных, имеющих одинаковое значение выражения секционирования. Это означает, что **не следует делать чрезмерно детализированные разделы** (более чем примерно тысяча разделов). В противном случае запрос `SELECT` будет работать медленно из‑за неоправданно большого числа файлов в файловой системе и открытых дескрипторов файлов.
:::

Используйте таблицу [system.parts](../../../operations/system-tables/parts.md) для просмотра частей и разделов таблицы. Предположим, у нас есть таблица `visits` с секционированием по месяцам. Выполним запрос `SELECT` к таблице `system.parts`:

```sql
SELECT
    partition,
    name,
    active
FROM system.parts
WHERE table = 'visits'
```

```text
┌─partition─┬─name──────────────┬─active─┐
│ 201901    │ 201901_1_3_1      │      0 │
│ 201901    │ 201901_1_9_2_11   │      1 │
│ 201901    │ 201901_8_8_0      │      0 │
│ 201901    │ 201901_9_9_0      │      0 │
│ 201902    │ 201902_4_6_1_11   │      1 │
│ 201902    │ 201902_10_10_0_11 │      1 │
│ 201902    │ 201902_11_11_0_11 │      1 │
└───────────┴───────────────────┴────────┘
```

Столбец `partition` содержит имена партиций. В этом примере есть две партиции: `201901` и `201902`. Значение этого столбца можно использовать для указания имени партиции в запросах [ALTER ... PARTITION](../../../sql-reference/statements/alter/partition.md).


Столбец `name` содержит имена частей данных разделов. Вы можете использовать этот столбец, чтобы указать имя части в запросе [ALTER ATTACH PART](/sql-reference/statements/alter/partition#attach-partitionpart).

Разберём имя части: `201901_1_9_2_11`:

* `201901` — имя раздела.
* `1` — минимальный номер блока данных.
* `9` — максимальный номер блока данных.
* `2` — уровень части (глубина дерева слияний, из которого она сформирована).
* `11` — версия мутации (если часть была изменена).

:::info
Части таблиц старого типа имеют имя вида: `20190117_20190123_2_2_0` (минимальная дата — максимальная дата — минимальный номер блока — максимальный номер блока — уровень).
:::

Столбец `active` показывает статус части. `1` — активная; `0` — неактивная. Неактивные части — это, например, исходные части, которые остаются после слияния в более крупную часть. Повреждённые части данных также помечаются как неактивные.

Как видно в примере, существует несколько отдельных частей одного и того же раздела (например, `201901_1_3_1` и `201901_1_9_2`). Это означает, что эти части ещё не были слиты. ClickHouse периодически сливает вставленные части данных, примерно через 15 минут после вставки. Кроме того, вы можете выполнить внеплановое слияние с помощью запроса [OPTIMIZE](../../../sql-reference/statements/optimize.md). Пример:

```sql
OPTIMIZE TABLE visits PARTITION 201902;
```

```text
┌─partition─┬─name─────────────┬─active─┐
│ 201901    │ 201901_1_3_1     │      0 │
│ 201901    │ 201901_1_9_2_11  │      1 │
│ 201901    │ 201901_8_8_0     │      0 │
│ 201901    │ 201901_9_9_0     │      0 │
│ 201902    │ 201902_4_6_1     │      0 │
│ 201902    │ 201902_4_11_2_11 │      1 │
│ 201902    │ 201902_10_10_0   │      0 │
│ 201902    │ 201902_11_11_0   │      0 │
└───────────┴──────────────────┴────────┘
```

Неактивные части будут удалены примерно через 10 минут после слияния.

Другой способ просмотреть набор частей и партиций — перейти в каталог таблицы: `/var/lib/clickhouse/data/<database>/<table>/`. Например:

```bash
/var/lib/clickhouse/data/default/visits$ ls -l
total 40
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  1 16:48 201901_1_3_1
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 16:17 201901_1_9_2_11
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 15:52 201901_8_8_0
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 15:52 201901_9_9_0
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 16:17 201902_10_10_0
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 16:17 201902_11_11_0
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 16:19 201902_4_11_2_11
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 12:09 201902_4_6_1
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  1 16:48 detached
```

Папки &#39;201901&#95;1&#95;1&#95;0&#39;, &#39;201901&#95;1&#95;7&#95;1&#39; и так далее являются каталогами частей. Каждая часть относится к соответствующей партиции и содержит данные только за один месяц (в этой таблице в качестве примера используется разбиение по месяцам).


Каталог `detached` содержит части, которые были отделены от таблицы с помощью запроса [DETACH](/sql-reference/statements/detach). Повреждённые части также перемещаются в этот каталог вместо удаления. Сервер не использует части из каталога `detached`. Вы можете добавлять, удалять или изменять данные в этом каталоге в любой момент — сервер не узнает об этом, пока вы не выполните запрос [ATTACH](/sql-reference/statements/alter/partition#attach-partitionpart).

Обратите внимание, что на работающем сервере вы не можете вручную изменять набор частей или их данные в файловой системе, поскольку сервер не узнает об этом. Для нереплицируемых таблиц вы можете делать это, когда сервер остановлен, но это не рекомендуется. Для реплицируемых таблиц набор частей нельзя изменять ни при каких обстоятельствах.

ClickHouse позволяет выполнять операции с партициями: удалять их, копировать из одной таблицы в другую или создавать резервную копию. См. список всех операций в разделе [Операции с партициями и частями](/sql-reference/statements/alter/partition).



## Оптимизация GROUP BY с использованием ключа партиционирования {#group-by-optimisation-using-partition-key}

Для некоторых комбинаций ключа партиционирования таблицы и ключа GROUP BY запроса возможно выполнять агрегацию для каждой партиции независимо.
В этом случае не потребуется объединять частично агрегированные данные от всех потоков выполнения в конце,
поскольку гарантируется, что каждое значение ключа GROUP BY не может появиться в рабочих наборах двух разных потоков.

Типичный пример:

```sql
CREATE TABLE session_log
(
    UserID UInt64,
    SessionID UUID
)
ENGINE = MergeTree
PARTITION BY sipHash64(UserID) % 16
ORDER BY tuple();

SELECT
    UserID,
    COUNT()
FROM session_log
GROUP BY UserID;
```

:::note
Производительность такого запроса сильно зависит от структуры таблицы. По этой причине оптимизация по умолчанию отключена.
:::

Ключевые факторы для достижения высокой производительности:

- количество партиций, участвующих в запросе, должно быть достаточно большим (более `max_threads / 2`), иначе запрос не будет полностью использовать ресурсы машины
- партиции не должны быть слишком маленькими, чтобы пакетная обработка не вырождалась в построчную обработку
- партиции должны быть сопоставимы по размеру, чтобы все потоки выполняли примерно одинаковый объем работы

:::info
Рекомендуется применять хеш-функцию к столбцам в выражении `PARTITION BY` для равномерного распределения данных между партициями.
:::

Соответствующие настройки:

- `allow_aggregate_partitions_independently` — управляет включением оптимизации
- `force_aggregate_partitions_independently` — принудительно включает её использование, когда это применимо с точки зрения корректности, но отключается внутренней логикой, оценивающей её целесообразность
- `max_number_of_partitions_for_independent_aggregation` — жесткое ограничение на максимальное количество партиций таблицы

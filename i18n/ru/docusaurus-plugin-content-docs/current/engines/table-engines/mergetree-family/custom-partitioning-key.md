---
slug: /engines/table-engines/mergetree-family/custom-partitioning-key
sidebar_position: 30
sidebar_label: Пользовательский ключ партиционирования
title: 'Пользовательский ключ партиционирования'
description: 'Узнайте, как добавить пользовательский ключ партиционирования в таблицы MergeTree.'
---


# Пользовательский ключ партиционирования

:::note
В большинстве случаев вам не нужен ключ партиционирования, а в большинстве других случаев вам не нужен ключ партиционирования более детализированный, чем по месяцам.

Никогда не используйте слишком детализированное партиционирование. Не разбивайте данные по идентификаторам клиентов или именам. Вместо этого сделайте идентификатор клиента или имя первой колонкой в выражении ORDER BY.
:::

Партиционирование доступно для [таблиц семейства MergeTree](../../../engines/table-engines/mergetree-family/mergetree.md), включая [реплицированные таблицы](../../../engines/table-engines/mergetree-family/replication.md) и [материализованные представления](/sql-reference/statements/create/view#materialized-view).

Партиция — это логическая комбинация записей в таблице по указанному критерию. Вы можете установить партицию по произвольному критерию, например, по месяцу, по дню или по типу события. Каждая партиция хранится отдельно, чтобы упростить манипуляции с этими данными. При доступе к данным ClickHouse использует наименьший возможный подмножество партиций. Партиции улучшают производительность запросов, содержащих ключ партиционирования, потому что ClickHouse будет фильтровать по этой партиции перед выбором частей и гранул внутри партиции.

Партиция указывается в клаузе `PARTITION BY expr` при [создании таблицы](../../../engines/table-engines/mergetree-family/mergetree.md#table_engine-mergetree-creating-a-table). Ключ партиционирования может быть любым выражением из колонок таблицы. Например, чтобы указать партиционирование по месяцу, используйте выражение `toYYYYMM(date_column)`:

``` sql
CREATE TABLE visits
(
    VisitDate Date,
    Hour UInt8,
    ClientID UUID
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(VisitDate)
ORDER BY Hour;
```

Ключ партиционирования также может быть кортежем выражений (аналогично [первичному ключу](../../../engines/table-engines/mergetree-family/mergetree.md#primary-keys-and-indexes-in-queries)). Например:

``` sql
ENGINE = ReplicatedCollapsingMergeTree('/clickhouse/tables/name', 'replica1', Sign)
PARTITION BY (toMonday(StartDate), EventType)
ORDER BY (CounterID, StartDate, intHash32(UserID));
```

В этом примере мы устанавливаем партиционирование по типам событий, которые произошли на текущей неделе.

По умолчанию партиция с плавающей запятой не поддерживается. Чтобы использовать её, включите настройку [allow_floating_point_partition_key](../../../operations/settings/merge-tree-settings.md#allow_floating_point_partition_key).

При вставке новых данных в таблицу эти данные сохраняются как отдельная часть (чанк), отсортированная по первичному ключу. Через 10-15 минут после вставки части одной и той же партиции сливаются в целую часть.

:::info
Слияние работает только для частей данных, которые имеют одинаковое значение для выражения партиционирования. Это означает, что **вы не должны делать чрезмерно детализированные партиции** (более чем около тысячи партиций). В противном случае запрос `SELECT` будет работать плохо из-за неоправданно большого количества файлов в файловой системе и открытых дескрипторов файлов.
:::

Используйте таблицу [system.parts](../../../operations/system-tables/parts.md), чтобы просмотреть части таблицы и партиции. Например, предположим, что у нас есть таблица `visits` с партиционированием по месяцам. Выполним запрос `SELECT` для таблицы `system.parts`:

``` sql
SELECT
    partition,
    name,
    active
FROM system.parts
WHERE table = 'visits'
```

``` text
┌─partition─┬─name──────────────┬─active─┐
│ 201901    │ 201901_1_3_1      │      0 │
│ 201901    │ 201901_1_9_2_11   │      1 │
│ 201901    │ 201901_8_8_0      │      0 │
│ 201901    │ 201901_9_9_0      │      0 │
│ 201902    │ 201902_4_6_1_11   │      1 │
│ 201902    │ 201902_10_10_0_11 │      1 │
│ 201902    │ 201902_11_11_0_11 │      1 │
└───────────┴───────────────────┴────────┘
```

Столбец `partition` содержит названия партиций. В этом примере две партиции: `201901` и `201902`. Вы можете использовать это значение столбца, чтобы указать имя партиции в запросах [ALTER ... PARTITION](../../../sql-reference/statements/alter/partition.md).

Столбец `name` содержит названия частей данных партиции. Вы можете использовать это значение столбца, чтобы указать имя части в запросе [ALTER ATTACH PART](/sql-reference/statements/alter/partition#attach-partitionpart).

Рассмотрим название части: `201901_1_9_2_11`:

- `201901` — это имя партиции.
- `1` — минимальный номер блока данных.
- `9` — максимальный номер блока данных.
- `2` — уровень чанка (глубина дерева слияния, из которого он сформирован).
- `11` — версия мутации (если часть была мутирована)

:::info
Части таблиц старого типа имеют название: `20190117_20190123_2_2_0` (минимальная дата - максимальная дата - минимальный номер блока - максимальный номер блока - уровень).
:::

Столбец `active` показывает статус части. `1` — активная; `0` — неактивная. Неактивные части, например, это исходные части, остающиеся после слияния в более крупную часть. Коррупционные части данных также обозначаются как неактивные.

Как видно из примера, есть несколько разделенных частей одной и той же партиции (например, `201901_1_3_1` и `201901_1_9_2`). Это означает, что эти части еще не были объединены. ClickHouse периодически объединяет вставленные части данных, примерно через 15 минут после вставки. Кроме того, вы можете выполнить несогласованное слияние, используя запрос [OPTIMIZE](../../../sql-reference/statements/optimize.md). Пример:

``` sql
OPTIMIZE TABLE visits PARTITION 201902;
```

``` text
┌─partition─┬─name─────────────┬─active─┐
│ 201901    │ 201901_1_3_1     │      0 │
│ 201901    │ 201901_1_9_2_11  │      1 │
│ 201901    │ 201901_8_8_0     │      0 │
│ 201901    │ 201901_9_9_0     │      0 │
│ 201902    │ 201902_4_6_1     │      0 │
│ 201902    │ 201902_4_11_2_11 │      1 │
│ 201902    │ 201902_10_10_0   │      0 │
│ 201902    │ 201902_11_11_0   │      0 │
└───────────┴──────────────────┴────────┘
```

Неактивные части будут удалены примерно через 10 минут после слияния.

Еще один способ просмотра набора частей и партиций — зайти в директорию таблицы: `/var/lib/clickhouse/data/<database>/<table>/`. Например:

``` bash
/var/lib/clickhouse/data/default/visits$ ls -l
total 40
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  1 16:48 201901_1_3_1
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 16:17 201901_1_9_2_11
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 15:52 201901_8_8_0
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 15:52 201901_9_9_0
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 16:17 201902_10_10_0
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 16:17 201902_11_11_0
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 16:19 201902_4_11_2_11
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  5 12:09 201902_4_6_1
drwxr-xr-x 2 clickhouse clickhouse 4096 Feb  1 16:48 detached
```

Папки '201901_1_1_0', '201901_1_7_1' и так далее представляют собой директории частей. Каждая часть относится к соответствующей партиции и содержит данные только за определенный месяц (таблица в этом примере имеет партиционирование по месяцам).

Директория `detached` содержит части, которые были отсоединены от таблицы с использованием запроса [DETACH](/sql-reference/statements/detach). Поврежденные части также перемещаются в эту директорию вместо того, чтобы быть удаленными. Сервер не использует части из директории `detached`. Вы можете добавлять, удалять или изменять данные в этой директории в любое время — сервер не узнает об этом, пока вы не выполните запрос [ATTACH](/sql-reference/statements/alter/partition#attach-partitionpart).

Обратите внимание, что на работающем сервере вы не можете вручную изменять набор частей или их данные в файловой системе, так как сервер об этом не узнает. Для нереплицированных таблиц вы можете это сделать, когда сервер остановлен, но это не рекомендуется. Для реплицированных таблиц набор частей не может быть изменен ни в каком случае.

ClickHouse позволяет вам выполнять операции с партициями: удалять их, копировать из одной таблицы в другую или создавать резервные копии. См. список всех операций в разделе [Манипуляции с партициями и частями](/sql-reference/statements/alter/partition).

## Оптимизация Group By с использованием ключа партиционирования {#group-by-optimisation-using-partition-key}

Для некоторых комбинаций ключа партиционирования таблицы и ключа GROUP BY запроса может быть возможно выполнять агрегацию для каждой партиции независимо.
Тогда нам не придется объединять частично агрегированные данные из всех потоков выполнения в конце,
поскольку мы обеспечили гарантию, что каждое значение ключа GROUP BY не может появиться в рабочих наборах двух разных потоков.

Типичный пример:

``` sql
CREATE TABLE session_log
(
    UserID UInt64,
    SessionID UUID
)
ENGINE = MergeTree
PARTITION BY sipHash64(UserID) % 16
ORDER BY tuple();

SELECT
    UserID,
    COUNT()
FROM session_log
GROUP BY UserID;
```

:::note
Производительность такого запроса сильно зависит от структуры таблицы. Поэтому оптимизация не включена по умолчанию.
:::

Ключевые факторы для хорошей производительности:

- количество партиций, участвующих в запросе, должно быть достаточно большим (более `max_threads / 2`), в противном случае запрос будет недоиспользовать ресурсы машины
- партиции не должны быть слишком маленькими, чтобы пакетная обработка не превращалась в построчную
- партиции должны быть сопоставимы по размеру, чтобы все потоки выполняли примерно одно и то же количество работы

:::info
Рекомендуется применять какую-нибудь хеш-функцию к колонкам в клаузе `partition by`, чтобы равномерно распределить данные между партициями.
:::

Соответствующие настройки:

- `allow_aggregate_partitions_independently` - контролирует, включена ли оптимизация
- `force_aggregate_partitions_independently` - принудительно включает её использование, когда это применимо с точки зрения корректности, но внутренней логикой, которая оценивает её целесообразность, отключается
- `max_number_of_partitions_for_independent_aggregation` - жесткий лимит на максимальное количество партиций, которое может иметь таблица

---
description: 'Позволяет быстро записывать состояния объектов, которые постоянно меняются,
  и удалять старые состояния объектов в фоновом режиме.'
sidebar_label: 'VersionedCollapsingMergeTree'
sidebar_position: 80
slug: /engines/table-engines/mergetree-family/versionedcollapsingmergetree
title: 'Движок таблицы VersionedCollapsingMergeTree'
doc_type: 'reference'
---



# Движок таблиц VersionedCollapsingMergeTree

Этот движок:

- Обеспечивает быструю запись состояний объектов, которые постоянно изменяются.
- Удаляет старые состояния объектов в фоновом режиме. Это существенно сокращает объём хранилища.

См. раздел [Collapsing](#table_engines_versionedcollapsingmergetree) для подробностей.

Движок наследуется от [MergeTree](/engines/table-engines/mergetree-family/versionedcollapsingmergetree) и добавляет логику схлопывания строк к алгоритму слияния частей данных. `VersionedCollapsingMergeTree` служит той же цели, что и [CollapsingMergeTree](../../../engines/table-engines/mergetree-family/collapsingmergetree.md), но использует другой алгоритм схлопывания, который позволяет вставлять данные в любом порядке и с использованием нескольких потоков. В частности, столбец `Version` помогает корректно схлопывать строки, даже если они вставляются в неправильном порядке. Напротив, `CollapsingMergeTree` допускает только строго последовательную вставку.



## Создание таблицы {#creating-a-table}

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE = VersionedCollapsingMergeTree(sign, version)
[PARTITION BY expr]
[ORDER BY expr]
[SAMPLE BY expr]
[SETTINGS name=value, ...]
```

Описание параметров запроса см. в [описании запроса](../../../sql-reference/statements/create/table.md).

### Параметры движка {#engine-parameters}

```sql
VersionedCollapsingMergeTree(sign, version)
```

| Параметр  | Описание                                                                                      | Тип                                                                                                                                                                                                                                                                                           |
| --------- | --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sign`    | Имя столбца с типом строки: `1` — строка «состояния», `-1` — строка «отмены». | [`Int8`](/sql-reference/data-types/int-uint)                                                                                                                                                                                                                                                  |
| `version` | Имя столбца с версией состояния объекта.                               | [`Int*`](/sql-reference/data-types/int-uint), [`UInt*`](/sql-reference/data-types/int-uint), [`Date`](/sql-reference/data-types/date), [`Date32`](/sql-reference/data-types/date32), [`DateTime`](/sql-reference/data-types/datetime) или [`DateTime64`](/sql-reference/data-types/datetime64) |

### Секции запроса {#query-clauses}

При создании таблицы `VersionedCollapsingMergeTree` требуются те же [секции](../../../engines/table-engines/mergetree-family/mergetree.md), что и при создании таблицы `MergeTree`.

<details markdown="1">

<summary>Устаревший метод создания таблицы</summary>

:::note
Не используйте этот метод в новых проектах. По возможности переведите старые проекты на метод, описанный выше.
:::

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE [=] VersionedCollapsingMergeTree(date-column [, samp#table_engines_versionedcollapsingmergetreeling_expression], (primary, key), index_granularity, sign, version)
```

Все параметры, кроме `sign` и `version`, имеют то же значение, что и в `MergeTree`.

- `sign` — имя столбца с типом строки: `1` — строка «состояния», `-1` — строка «отмены».

  Тип данных столбца — `Int8`.

- `version` — имя столбца с версией состояния объекта.

  Тип данных столбца должен быть `UInt*`.

</details>


## Сворачивание {#table_engines_versionedcollapsingmergetree}

### Данные {#data}

Рассмотрим ситуацию, когда необходимо сохранять постоянно изменяющиеся данные для некоторого объекта. Разумно иметь одну строку для объекта и обновлять её при каждом изменении. Однако операция обновления является дорогостоящей и медленной для СУБД, поскольку требует перезаписи данных в хранилище. Обновление неприемлемо, если необходимо быстро записывать данные, но можно последовательно записывать изменения объекта следующим образом.

Используйте столбец `Sign` при записи строки. Если `Sign = 1`, это означает, что строка является состоянием объекта (назовём её строкой «состояния»). Если `Sign = -1`, это указывает на отмену состояния объекта с теми же атрибутами (назовём её строкой «отмены»). Также используйте столбец `Version`, который должен идентифицировать каждое состояние объекта отдельным номером.

Например, мы хотим подсчитать, сколько страниц посетили пользователи на некотором сайте и как долго они там находились. В некоторый момент времени мы записываем следующую строку с состоянием активности пользователя:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Позднее мы регистрируем изменение активности пользователя и записываем его следующими двумя строками.

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
│ 4324182021466249494 │         6 │      185 │    1 │       2 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Первая строка отменяет предыдущее состояние объекта (пользователя). Она должна копировать все поля отменяемого состояния, за исключением `Sign`.

Вторая строка содержит текущее состояние.

Поскольку нам нужно только последнее состояние активности пользователя, строки

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

могут быть удалены, сворачивая недействительное (старое) состояние объекта. `VersionedCollapsingMergeTree` выполняет это при слиянии частей данных.

Чтобы узнать, почему для каждого изменения нужны две строки, см. [Алгоритм](#table_engines-versionedcollapsingmergetree-algorithm).

**Примечания по использованию**

1.  Программа, которая записывает данные, должна запоминать состояние объекта, чтобы иметь возможность отменить его. Строка «отмены» должна содержать копии полей первичного ключа и версию строки «состояния», а также противоположный `Sign`. Это увеличивает начальный размер хранилища, но позволяет быстро записывать данные.
2.  Длинные растущие массивы в столбцах снижают эффективность движка из-за нагрузки при записи. Чем проще данные, тем выше эффективность.
3.  Результаты `SELECT` сильно зависят от согласованности истории изменений объекта. Будьте внимательны при подготовке данных для вставки. При несогласованных данных можно получить непредсказуемые результаты, например отрицательные значения для неотрицательных метрик, таких как глубина сеанса.

### Алгоритм {#table_engines-versionedcollapsingmergetree-algorithm}

Когда ClickHouse выполняет слияние частей данных, он удаляет каждую пару строк, имеющих одинаковый первичный ключ и версию, но различный `Sign`. Порядок строк не имеет значения.

Когда ClickHouse вставляет данные, он упорядочивает строки по первичному ключу. Если столбец `Version` не входит в первичный ключ, ClickHouse неявно добавляет его в первичный ключ как последнее поле и использует его для упорядочивания.


## Выборка данных {#selecting-data}

ClickHouse не гарантирует, что все строки с одинаковым первичным ключом окажутся в одном результирующем куске данных или даже на одном физическом сервере. Это справедливо как для записи данных, так и для последующего слияния кусков данных. Кроме того, ClickHouse обрабатывает запросы `SELECT` в несколько потоков и не может предсказать порядок строк в результате. Это означает, что для получения полностью «схлопнутых» данных из таблицы `VersionedCollapsingMergeTree` требуется агрегация.

Чтобы завершить схлопывание, напишите запрос с секцией `GROUP BY` и агрегатными функциями, которые учитывают знак. Например, для вычисления количества используйте `sum(Sign)` вместо `count()`. Для вычисления суммы используйте `sum(Sign * x)` вместо `sum(x)` и добавьте `HAVING sum(Sign) > 0`.

Агрегатные функции `count`, `sum` и `avg` могут быть вычислены таким образом. Агрегатная функция `uniq` может быть вычислена, если объект имеет хотя бы одно несхлопнутое состояние. Агрегатные функции `min` и `max` не могут быть вычислены, поскольку `VersionedCollapsingMergeTree` не сохраняет историю значений схлопнутых состояний.

Если необходимо извлечь данные со «схлопыванием», но без агрегации (например, чтобы проверить наличие строк, новейшие значения которых соответствуют определённым условиям), можно использовать модификатор `FINAL` для секции `FROM`. Этот подход неэффективен и не должен использоваться с большими таблицами.


## Пример использования {#example-of-use}

Пример данных:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
│ 4324182021466249494 │         6 │      185 │    1 │       2 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Создание таблицы:

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8,
    Version UInt8
)
ENGINE = VersionedCollapsingMergeTree(Sign, Version)
ORDER BY UserID
```

Вставка данных:

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1, 1)
```

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1, 1),(4324182021466249494, 6, 185, 1, 2)
```

Мы используем два запроса `INSERT` для создания двух различных кусков данных. Если вставить данные одним запросом, ClickHouse создаст один кусок данных и никогда не выполнит слияние.

Получение данных:

```sql
SELECT * FROM UAct
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │   -1 │       1 │
│ 4324182021466249494 │         6 │      185 │    1 │       2 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Что мы здесь видим и где свёрнутые части?
Мы создали два куска данных с помощью двух запросов `INSERT`. Запрос `SELECT` был выполнен в двух потоках, и в результате строки расположены в случайном порядке.
Свёртывание не произошло, потому что куски данных ещё не были слиты. ClickHouse выполняет слияние кусков данных в неопределённый момент времени, который невозможно предсказать.

Поэтому нам необходима агрегация:

```sql
SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration,
    Version
FROM UAct
GROUP BY UserID, Version
HAVING sum(Sign) > 0
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Version─┐
│ 4324182021466249494 │         6 │      185 │       2 │
└─────────────────────┴───────────┴──────────┴─────────┘
```

Если агрегация не требуется и необходимо принудительно выполнить свёртывание, можно использовать модификатор `FINAL` в секции `FROM`.

```sql
SELECT * FROM UAct FINAL
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         6 │      185 │    1 │       2 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Это очень неэффективный способ выборки данных. Не используйте его для больших таблиц.

---
slug: /engines/table-engines/mergetree-family/collapsingmergetree
sidebar_position: 70
sidebar_label: CollapsingMergeTree
keywords: ['обновления', 'сжатие']
title: 'CollapsingMergeTree'
description: 'Унаследован от MergeTree, но добавляет логику для сжатия строк в процессе слияния.'
---


# CollapsingMergeTree

## Описание {#description}

Двигатель `CollapsingMergeTree` унаследован от [MergeTree](../../../engines/table-engines/mergetree-family/mergetree.md) и добавляет логику для сжатия строк в процессе слияния. 
Двигатель таблицы `CollapsingMergeTree` асинхронно удаляет (сжимает) пары строк, если все поля в ключе сортировки (`ORDER BY`) эквивалентны, кроме специального поля `Sign`, которое может иметь значения `1` или `-1`. 
Строки без пары строк с противоположными значениями `Sign` сохраняются. 

Для получения дополнительной информации смотрите раздел [Collapsing](#table_engine-collapsingmergetree-collapsing) документа.

:::note
Этот движок может значительно уменьшить объем хранения, что, в свою очередь, увеличивает эффективность запросов `SELECT`.
:::

## Параметры {#parameters}

Все параметры этого движка таблицы, за исключением параметра `Sign`, имеют такое же значение, как и в [`MergeTree`](/engines/table-engines/mergetree-family/mergetree).

- `Sign` — Название колонки с типом строки, где `1` — это "строка состояния", а `-1` — "строка отмены". Тип: [Int8](/sql-reference/data-types/int-uint).

## Создание таблицы {#creating-a-table}

``` sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) 
ENGINE = CollapsingMergeTree(Sign)
[PARTITION BY expr]
[ORDER BY expr]
[SAMPLE BY expr]
[SETTINGS name=value, ...]
```

<details markdown="1">

<summary>Устаревший метод создания таблицы</summary>

:::note
Метод ниже не рекомендуется использовать в новых проектах. 
Советуем, если возможно, обновить старые проекты для использования нового метода.
:::

``` sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) 
ENGINE [=] CollapsingMergeTree(date-column [, sampling_expression], (primary, key), index_granularity, Sign)
```

`Sign` — Название колонки с типом строки, где `1` — это "строка состояния", а `-1` — "строка отмены". [Int8](/sql-reference/data-types/int-uint).

</details>

- Для описания параметров запроса смотрите [описание запроса](../../../sql-reference/statements/create/table.md).
- При создании таблицы `CollapsingMergeTree` необходимы те же [условия запроса](../../../engines/table-engines/mergetree-family/mergetree.md#table_engine-mergetree-creating-a-table), как и при создании таблицы `MergeTree`.

## Сжатие {#table_engine-collapsingmergetree-collapsing}

### Данные {#data}

Рассмотрим ситуацию, когда вам нужно сохранять постоянно изменяющиеся данные для некоторого объекта. 
Может показаться логичным иметь одну строку на объект и обновлять ее всякий раз, когда что-то изменяется, однако операции обновления дороги и медлительны для СУБД, так как они требуют переписывания данных в хранилище. 
Если нам необходимо быстро записывать данные, выполнять большое количество обновлений — это недопустимый подход, но мы всегда можем записывать изменения объекта последовательно. 
Для этого мы используем специальную колонку `Sign`.

- Если `Sign` = `1`, это означает, что строка является "строкой состояния": _строка, содержащая поля, представляющие текущий действительный статус_. 
- Если `Sign` = `-1`, это означает, что строка является "строкой отмены": _строка, используемая для отмены состояния объекта с теми же атрибутами_.

Например, мы хотим вычислить, сколько страниц пользователи проверили на некотором веб-сайте и как долго они их посещали. 
В какой-то момент мы записываем следующую строку со статусом активности пользователя:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

Позже мы фиксируем изменение активности пользователя и записываем это в две строки:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

Первая строка отменяет предыдущее состояние объекта (в данном случае представляющего пользователя). 
Она должна скопировать все поля ключа сортировки для "отмененной" строки, кроме `Sign`. 
Вторая строка выше содержит текущее состояние.

Так как нам нужно только последнее состояние активности пользователя, оригинальная "строка состояния" и "строка отмены", которые мы вставили, могут быть удалены, как показано ниже, сжимая недействительное (старое) состояние объекта:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │ -- старая "строка состояния" может быть удалена
│ 4324182021466249494 │         5 │      146 │   -1 │ -- "строка отмены" может быть удалена
│ 4324182021466249494 │         6 │      185 │    1 │ -- новая "строка состояния" остается
└─────────────────────┴───────────┴──────────┴──────┘
```

`CollapsingMergeTree` выполняет именно такое _сжатие_ во время слияния частей данных.

:::note
Причина, по которой для каждого изменения требуется две строки, обсуждается в разделе [Алгоритм](#table_engine-collapsingmergetree-collapsing-algorithm).
:::

**Особенности такого подхода**

1. Программа, которая записывает данные, должна помнить состояние объекта, чтобы иметь возможность его отменить. "Строка отмены" должна содержать копии полей ключа сортировки "строки состояния" и противоположный `Sign`. Это увеличивает начальный размер хранения, но позволяет нам быстро записывать данные.
2. Длинные растущие массивы в колонках уменьшают эффективность движка из-за увеличенной нагрузки на запись. Чем проще данные, тем выше эффективность.
3. Результаты `SELECT` сильно зависят от согласованности истории изменений объекта. Будьте внимательны при подготовке данных для вставки. Вы можете получить непредсказуемые результаты с несогласованными данными. Например, отрицательные значения для неотрицательных метрик, таких как глубина сессии.

### Алгоритм {#table_engine-collapsingmergetree-collapsing-algorithm}

Когда ClickHouse сливает данные [частей](/concepts/glossary#parts), каждый набор последовательных строк с одинаковым ключом сортировки (`ORDER BY`) сокращается до не более чем двух строк: "строки состояния" с `Sign` = `1` и "строки отмены" с `Sign` = `-1`. 
Иными словами, записи в ClickHouse сжимаются.

Для каждой результирующей части данных ClickHouse сохраняет:

|  |                                                                                                                                     |
|--|-------------------------------------------------------------------------------------------------------------------------------------|
|1.| Первая "строка отмены" и последняя "строка состояния", если количество "строк состояния" и "строк отмены" совпадает, а последняя строка — "строка состояния". |
|2.| Последняя "строка состояния", если "строк состояния" больше, чем "строк отмены".                                                            |
|3.| Первая "строка отмены", если "строк отмены" больше, чем "строк состояния".                                                          |
|4.| Ни одной строки в остальных случаях.                                                                                               |

Дополнительно, когда "строк состояния" как минимум на две больше, чем "строк отмены", или "строк отмены" как минимум на две больше, чем "строк состояния", слияние продолжается.
Тем не менее, ClickHouse рассматривает эту ситуацию как логическую ошибку и фиксирует это в журнале сервера. 
Эта ошибка может возникнуть, если одни и те же данные вставляются более одного раза. 
Таким образом, сжатие не должно изменять результаты вычисления статистики.
Изменения постепенно сжимаются, так что в конечном итоге остается только последнее состояние почти каждого объекта.

Столбец `Sign` необходим, потому что алгоритм слияния не гарантирует, что все строки с одинаковым ключом сортировки будут находиться в одной результирующей части данных и даже на одном физическом сервере. 
ClickHouse обрабатывает запросы `SELECT` с помощью нескольких потоков, и он не может предсказать порядок строк в результате. 

Агрегация требуется, если необходимо получить полностью "сжатые" данные из таблицы `CollapsingMergeTree`. 
Чтобы завершить сжатие, выполните запрос с клаузой `GROUP BY` и агрегирующими функциями, учитывающими знак. 
Например, для подсчета количества используйте `sum(Sign)` вместо `count()`. 
Для вычисления суммы чего-либо используйте `sum(Sign * x)` вместе с `HAVING sum(Sign) > 0` вместо `sum(x)`, как в [примере](#example-of-use) ниже.

Агрегаты `count`, `sum` и `avg` могут быть вычислены таким образом. 
Агрегат `uniq` может быть вычислен, если у объекта есть хотя бы одно не сжатое состояние. 
Агрегаты `min` и `max` не могут быть вычислены, так как `CollapsingMergeTree` не сохраняет историю сжатых состояний.

:::note
Если вам нужно извлечь данные без агрегации (например, проверить наличие строк, у которых последние значения соответствуют определенным условиям), вы можете использовать модификатор [`FINAL`](../../../sql-reference/statements/select/from.md#final-modifier) для клаузи `FROM`. Он объединит данные перед тем, как вернуть результат. 
Для CollapsingMergeTree возвращается только последняя строка состояния для каждого ключа.
:::

## Примеры {#examples}

### Пример использования {#example-of-use}

Дан следующий пример данных:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

Создадим таблицу `UAct` с помощью `CollapsingMergeTree`:

``` sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID
```

Затем мы вставим несколько данных:

``` sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1)
```

``` sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1),(4324182021466249494, 6, 185, 1)
```

Мы используем два запроса `INSERT`, чтобы создать две разные части данных. 

:::note
Если мы вставим данные одиночным запросом, ClickHouse создаст только одну часть данных и никогда не выполнит слияние.
:::

Мы можем выбрать данные с помощью:

``` sql
SELECT * FROM UAct
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

Давайте посмотрим на возвращенные данные и проверим, произошло ли сжатие...
С помощью двух запросов `INSERT` мы создали две части данных. 
Запрос `SELECT` был выполнен в два потока, и мы получили случайный порядок строк. 
Однако сжатие **не произошло**, потому что никакого слияния частей данных еще не было, 
и ClickHouse выполняет слияние частей данных в фоновом режиме в неизвестный момент времени, который мы не можем предсказать.

Следовательно, нам нужно агрегирование, которое мы выполняем с помощью агрегатной функции [`sum`](/sql-reference/aggregate-functions/reference/sum) и клаузой [`HAVING`](/sql-reference/statements/select/having):

``` sql
SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration
FROM UAct
GROUP BY UserID
HAVING sum(Sign) > 0
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

Если нам не нужно агрегирование и мы хотим принудительно выполнить сжатие, мы также можем использовать модификатор `FINAL` для клаузи `FROM`.

``` sql
SELECT * FROM UAct FINAL
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```
:::note
Такой способ выбора данных менее эффективен и не рекомендуется для использования с большими объемами сканируемых данных (миллионы строк).
:::

### Пример другого подхода {#example-of-another-approach}

Идея этого подхода заключается в том, что слияния учитывают только ключевые поля. 
В "строке отмены" мы можем, следовательно, указать отрицательные значения, которые уравновесят предыдущую версию строки при суммировании, не используя колонку `Sign`.

Для этого примера мы воспользуемся следующим примером данных:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
│ 4324182021466249494 │        -5 │     -146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

Для этого подхода необходимо изменить типы данных `PageViews` и `Duration`, чтобы хранить отрицательные значения. 
Поэтому мы изменим значения этих колонок с `UInt8` на `Int16`, когда создаем нашу таблицу `UAct`, используя `CollapsingMergeTree`:

``` sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews Int16,
    Duration Int16,
    Sign Int8
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID
```

Давайте протестируем подход, вставляя данные в нашу таблицу. 

Для примеров или небольших таблиц это, тем не менее, приемлемо:

``` sql
INSERT INTO UAct VALUES(4324182021466249494,  5,  146,  1);
INSERT INTO UAct VALUES(4324182021466249494, -5, -146, -1);
INSERT INTO UAct VALUES(4324182021466249494,  6,  185,  1);

SELECT * FROM UAct FINAL;
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

``` sql
SELECT
    UserID,
    sum(PageViews) AS PageViews,
    sum(Duration) AS Duration
FROM UAct
GROUP BY UserID
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

``` sql
SELECT COUNT() FROM UAct
```

``` text
┌─count()─┐
│       3 │
└─────────┘
```

``` sql
OPTIMIZE TABLE UAct FINAL;

SELECT * FROM UAct
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

---
description: 'Наследуется от MergeTree и добавляет логику схлопывания строк при слиянии.'
keywords: ['обновления', 'схлопывание']
sidebar_label: 'CollapsingMergeTree'
sidebar_position: 70
slug: /engines/table-engines/mergetree-family/collapsingmergetree
title: 'Движок таблицы CollapsingMergeTree'
doc_type: 'guide'
---



# Движок таблиц CollapsingMergeTree



## Description {#description}

Движок `CollapsingMergeTree` наследуется от [MergeTree](../../../engines/table-engines/mergetree-family/mergetree.md)
и добавляет логику сворачивания строк в процессе слияния.
Табличный движок `CollapsingMergeTree` асинхронно удаляет (сворачивает)
пары строк, если все поля в ключе сортировки (`ORDER BY`) эквивалентны, за исключением специального поля `Sign`,
которое может принимать значения `1` или `-1`.
Строки без пары с противоположным значением `Sign` сохраняются.

Подробнее см. раздел [Сворачивание](#table_engine-collapsingmergetree-collapsing).

:::note
Этот движок может значительно сократить объём хранилища,
что в свою очередь повышает эффективность запросов `SELECT`.
:::


## Параметры {#parameters}

Все параметры этого движка таблиц, за исключением параметра `Sign`,
имеют то же значение, что и в [`MergeTree`](/engines/table-engines/mergetree-family/mergetree).

- `Sign` — Имя столбца с типом строки, где `1` обозначает строку состояния, а `-1` — строку отмены. Тип: [Int8](/sql-reference/data-types/int-uint).


## Создание таблицы {#creating-a-table}

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
)
ENGINE = CollapsingMergeTree(Sign)
[PARTITION BY expr]
[ORDER BY expr]
[SAMPLE BY expr]
[SETTINGS name=value, ...]
```

<details markdown="1">

<summary>Устаревший метод создания таблицы</summary>

:::note
Использование описанного ниже метода не рекомендуется в новых проектах.
По возможности рекомендуется обновить старые проекты для использования нового метода.
:::

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
)
ENGINE [=] CollapsingMergeTree(date-column [, sampling_expression], (primary, key), index_granularity, Sign)
```

`Sign` — имя столбца с типом строки, где `1` обозначает строку «состояния», а `-1` — строку «отмены». [Int8](/sql-reference/data-types/int-uint).

</details>

- Описание параметров запроса см. в разделе [описание запроса](../../../sql-reference/statements/create/table.md).
- При создании таблицы `CollapsingMergeTree` требуются те же [секции запроса](../../../engines/table-engines/mergetree-family/mergetree.md#table_engine-mergetree-creating-a-table), что и при создании таблицы `MergeTree`.


## Схлопывание {#table_engine-collapsingmergetree-collapsing}

### Данные {#data}

Рассмотрим ситуацию, когда необходимо сохранять постоянно изменяющиеся данные для некоторого объекта.
Может показаться логичным иметь одну строку на объект и обновлять её при каждом изменении,
однако операции обновления являются дорогостоящими и медленными для СУБД, поскольку требуют перезаписи данных в хранилище.
Если необходимо быстро записывать данные, выполнение большого количества обновлений не является приемлемым подходом,
но мы всегда можем записывать изменения объекта последовательно.
Для этого используется специальный столбец `Sign`.

- Если `Sign` = `1`, это означает, что строка является строкой «состояния»: _строкой, содержащей поля, которые представляют текущее действительное состояние_.
- Если `Sign` = `-1`, это означает, что строка является строкой «отмены»: _строкой, используемой для отмены состояния объекта с теми же атрибутами_.

Например, мы хотим подсчитать, сколько страниц пользователи просмотрели на некотором веб-сайте и как долго они на них находились.
В некоторый момент времени мы записываем следующую строку с состоянием активности пользователя:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

В более поздний момент времени мы регистрируем изменение активности пользователя и записываем его следующими двумя строками:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

Первая строка отменяет предыдущее состояние объекта (в данном случае представляющего пользователя).
Она должна копировать все поля ключа сортировки отменяемой строки, за исключением `Sign`.
Вторая строка выше содержит текущее состояние.

Поскольку нам нужно только последнее состояние активности пользователя, исходная строка «состояния» и строка «отмены»,
которую мы вставили, могут быть удалены, как показано ниже, схлопывая недействительное (старое) состояние объекта:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │ -- старая строка «состояния» может быть удалена
│ 4324182021466249494 │         5 │      146 │   -1 │ -- строка «отмены» может быть удалена
│ 4324182021466249494 │         6 │      185 │    1 │ -- новая строка «состояния» остаётся
└─────────────────────┴───────────┴──────────┴──────┘
```

`CollapsingMergeTree` выполняет именно такое поведение _схлопывания_ во время слияния частей данных.

:::note
Причина, по которой для каждого изменения требуются две строки,
подробнее обсуждается в разделе [Алгоритм](#table_engine-collapsingmergetree-collapsing-algorithm).
:::

**Особенности такого подхода**

1.  Программа, которая записывает данные, должна помнить состояние объекта, чтобы иметь возможность его отменить. Строка «отмены» должна содержать копии полей ключа сортировки строки «состояния» и противоположный `Sign`. Это увеличивает начальный размер хранилища, но позволяет быстро записывать данные.
2.  Длинные растущие массивы в столбцах снижают эффективность движка из-за увеличенной нагрузки при записи. Чем проще данные, тем выше эффективность.
3.  Результаты `SELECT` сильно зависят от согласованности истории изменений объекта. Будьте внимательны при подготовке данных для вставки. При несогласованных данных можно получить непредсказуемые результаты. Например, отрицательные значения для неотрицательных метрик, таких как глубина сеанса.

### Алгоритм {#table_engine-collapsingmergetree-collapsing-algorithm}

Когда ClickHouse выполняет слияние [частей](/concepts/glossary#parts) данных,
каждая группа последовательных строк с одинаковым ключом сортировки (`ORDER BY`) сокращается до не более чем двух строк:
строки «состояния» с `Sign` = `1` и строки «отмены» с `Sign` = `-1`.
Другими словами, в ClickHouse записи схлопываются.


Для каждой результирующей части данных ClickHouse сохраняет:

|  |                                                                                                                                     |
|--|-------------------------------------------------------------------------------------------------------------------------------------|
|1.| Первую строку "cancel" и последнюю строку "state", если количество строк "state" и "cancel" совпадает и последняя строка — "state". |
|2.| Последнюю строку "state", если строк "state" больше, чем строк "cancel".                                                            |
|3.| Первую строку "cancel", если строк "cancel" больше, чем строк "state".                                                              |
|4.| Ни одной строки во всех остальных случаях.                                                                                          |

Кроме того, когда строк "state" как минимум на две больше, чем строк "cancel", 
или строк "cancel" как минимум на две больше, чем строк "state", слияние продолжается.
Однако ClickHouse рассматривает такую ситуацию как логическую ошибку и записывает её в журнал сервера. 
Эта ошибка может возникнуть, если одни и те же данные вставлены более одного раза. 
Таким образом, схлопывание не должно изменять результаты вычисления статистики.
Изменения постепенно схлопываются так, что в итоге остаётся только последнее состояние почти каждого объекта.

Столбец `Sign` необходим, потому что алгоритм слияния не гарантирует, 
что все строки с одинаковым ключом сортировки окажутся в одной и той же результирующей части данных и даже на одном и том же физическом сервере. 
ClickHouse обрабатывает запросы `SELECT` в несколько потоков и не может предсказать порядок строк в результате. 

Агрегация необходима, если требуется получить полностью "схлопнутые" данные из таблицы `CollapsingMergeTree`.
Чтобы завершить схлопывание, выполните запрос с оператором `GROUP BY` и агрегатными функциями, которые учитывают знак. 
Например, для вычисления количества используйте `sum(Sign)` вместо `count()`. 
Для вычисления суммы некоторого значения используйте `sum(Sign * x)` вместе с `HAVING sum(Sign) > 0` вместо `sum(x)`,
как в [примере](#example-of-use) ниже.

Агрегаты `count`, `sum` и `avg` могут вычисляться таким образом. 
Агрегат `uniq` может быть вычислен, если у объекта есть хотя бы одно несклопнутое состояние. 
Агрегаты `min` и `max` не могут быть вычислены, 
поскольку `CollapsingMergeTree` не сохраняет историю схлопнутых состояний.

:::note
Если вам нужно извлечь данные без агрегации 
(например, чтобы проверить, присутствуют ли строки, чьи самые новые значения удовлетворяют определённым условиям), 
вы можете использовать модификатор [`FINAL`](../../../sql-reference/statements/select/from.md#final-modifier) для оператора `FROM`. Он выполнит слияние данных до возврата результата.
Для CollapsingMergeTree для каждого ключа возвращается только строка с последним состоянием.
:::



## Примеры {#examples}

### Пример использования {#example-of-use}

Рассмотрим следующие примерные данные:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

Создадим таблицу `UAct`, используя движок `CollapsingMergeTree`:

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID
```

Далее вставим данные:

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1)
```

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1),(4324182021466249494, 6, 185, 1)
```

Мы используем два запроса `INSERT` для создания двух различных кусков данных.

:::note
Если вставить данные одним запросом, ClickHouse создаст только один кусок данных и никогда не выполнит слияние.
:::

Выполним выборку данных:

```sql
SELECT * FROM UAct
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

Рассмотрим возвращенные данные и проверим, произошло ли схлопывание...
С помощью двух запросов `INSERT` мы создали два куска данных.
Запрос `SELECT` был выполнен в двух потоках, и мы получили случайный порядок строк.
Однако схлопывание **не произошло**, потому что слияние кусков данных еще не выполнено,
а ClickHouse выполняет слияние кусков данных в фоновом режиме в непредсказуемый момент времени.

Поэтому необходимо использовать агрегацию
с помощью агрегатной функции [`sum`](/sql-reference/aggregate-functions/reference/sum)
и секции [`HAVING`](/sql-reference/statements/select/having):

```sql
SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration
FROM UAct
GROUP BY UserID
HAVING sum(Sign) > 0
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

Если агрегация не требуется и необходимо принудительно выполнить схлопывание, можно использовать модификатор `FINAL` в секции `FROM`.

```sql
SELECT * FROM UAct FINAL
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

:::note
Этот способ выборки данных менее эффективен и не рекомендуется для использования с большими объемами сканируемых данных (миллионы строк).
:::

### Пример альтернативного подхода {#example-of-another-approach}

Идея этого подхода заключается в том, что при слиянии учитываются только ключевые поля.
В строке «отмены» можно указать отрицательные значения,
которые при суммировании нейтрализуют предыдущую версию строки без использования столбца `Sign`.

Для этого примера используем следующие данные:


```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
│ 4324182021466249494 │        -5 │     -146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

В рамках этого подхода необходимо изменить типы данных столбцов `PageViews` и `Duration`, чтобы можно было хранить отрицательные значения.
Поэтому при создании таблицы `UAct` с использованием `collapsingMergeTree` мы изменяем типы этих столбцов с `UInt8` на `Int16`:

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews Int16,
    Duration Int16,
    Sign Int8
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID
```

Давайте опробуем этот подход, вставив данные в нашу таблицу.

Однако для примеров или небольших таблиц это приемлемо:

```sql
INSERT INTO UAct VALUES(4324182021466249494,  5,  146,  1);
INSERT INTO UAct VALUES(4324182021466249494, -5, -146, -1);
INSERT INTO UAct VALUES(4324182021466249494,  6,  185,  1);

SELECT * FROM UAct FINAL;
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

```sql
SELECT
    UserID,
    sum(PageViews) AS PageViews,
    sum(Duration) AS Duration
FROM UAct
GROUP BY UserID
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

```sql
SELECT COUNT() FROM UAct
```

```text
┌─count()─┐
│       3 │
└─────────┘
```

```sql
OPTIMIZE TABLE UAct FINAL;

SELECT * FROM UAct
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

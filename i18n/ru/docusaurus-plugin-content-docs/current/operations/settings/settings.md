---
slug: '/operations/settings/settings'
sidebar_label: 'Настройки Сессии'
description: 'Настройки, которые находятся в таблице ``system.settings``.'
title: 'Настройки Сессии'
doc_type: reference
toc_max_heading_level: 2
---
import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import BetaBadge from '@theme/badges/BetaBadge';
import CloudOnlyBadge from '@theme/badges/CloudOnlyBadge';
import SettingsInfoBlock from '@theme/SettingsInfoBlock/SettingsInfoBlock';
import VersionHistory from '@theme/VersionHistory/VersionHistory';

<!-- Autogenerated -->
Все настройки, приведенные ниже, также доступны в таблице [system.settings](/docs/operations/system-tables/settings). Эти настройки автоматически генерируются из [source](https://github.com/ClickHouse/ClickHouse/blob/master/src/Core/Settings.cpp).
## add_http_cors_header {#add_http_cors_header} 



<SettingsInfoBlock type="Bool" default_value="0" />

Записать заголовок HTTP CORS.
## additional_result_filter {#additional_result_filter} 

Дополнительное выражение фильтра, которое будет применено к результату запроса `SELECT`.
Эта настройка не применяется к подзапросам.

**Пример**

```sql
INSERT INTO table_1 VALUES (1, 'a'), (2, 'bb'), (3, 'ccc'), (4, 'dddd');
SElECT * FROM table_1;
```
```response
┌─x─┬─y────┐
│ 1 │ a    │
│ 2 │ bb   │
│ 3 │ ccc  │
│ 4 │ dddd │
└───┴──────┘
```
```sql
SELECT *
FROM table_1
SETTINGS additional_result_filter = 'x != 2'
```
```response
┌─x─┬─y────┐
│ 1 │ a    │
│ 3 │ ccc  │
│ 4 │ dddd │
└───┴──────┘
```
## additional_table_filters {#additional_table_filters} 



<SettingsInfoBlock type="Map" default_value="{}" />

Дополнительное выражение фильтра, которое применяется после чтения
из указанной таблицы.

**Пример**

```sql
INSERT INTO table_1 VALUES (1, 'a'), (2, 'bb'), (3, 'ccc'), (4, 'dddd');
SELECT * FROM table_1;
```
```response
┌─x─┬─y────┐
│ 1 │ a    │
│ 2 │ bb   │
│ 3 │ ccc  │
│ 4 │ dddd │
└───┴──────┘
```
```sql
SELECT *
FROM table_1
SETTINGS additional_table_filters = {'table_1': 'x != 2'}
```
```response
┌─x─┬─y────┐
│ 1 │ a    │
│ 3 │ ccc  │
│ 4 │ dddd │
└───┴──────┘
```
## aggregate_functions_null_for_empty {#aggregate_functions_null_for_empty} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает переписывание всех агрегатных функций в запросе, добавляя суффикс [-OrNull](/sql-reference/aggregate-functions/combinators#-ornull). Включите это для совместимости со стандартом SQL.
Реализуется через переопределение запроса (аналогично настройке [count_distinct_implementation](#count_distinct_implementation)), чтобы получить последовательные результаты для распределенных запросов.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

**Пример**

Рассмотрим следующий запрос с агрегатными функциями:
```sql
SELECT SUM(-1), MAX(0) FROM system.one WHERE 0;
```

С настройкой `aggregate_functions_null_for_empty = 0` он бы выдал:
```text
┌─SUM(-1)─┬─MAX(0)─┐
│       0 │      0 │
└─────────┴────────┘
```

С настройкой `aggregate_functions_null_for_empty = 1` результат будет:
```text
┌─SUMOrNull(-1)─┬─MAXOrNull(0)─┐
│          NULL │         NULL │
└───────────────┴──────────────┘
```
## aggregation_in_order_max_block_bytes {#aggregation_in_order_max_block_bytes} 



<SettingsInfoBlock type="UInt64" default_value="50000000" />

Максимальный размер блока в байтах, накопленных во время агрегации в порядке первичного ключа. Меньший размер блока позволяет параллелить больше финальной стадии объединения агрегации.
## aggregation_memory_efficient_merge_threads {#aggregation_memory_efficient_merge_threads} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Количество потоков, которые будут использоваться для объединения промежуточных результатов агрегации в памяти с эффективным использованием памяти. При большем значении будет потребляться больше памяти. 0 означает - то же, что и 'max_threads'.
## allow_aggregate_partitions_independently {#allow_aggregate_partitions_independently} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить независимую агрегацию партиций на отдельных потоках, когда ключ партиционирования соответствует ключу группировки. Это полезно, когда количество партиций близко к количеству ядер, и партиции имеют приблизительно одинаковый размер.
## allow_archive_path_syntax {#allow_archive_path_syntax} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "1"},{"label": "Added new setting to allow disabling archive path syntax."}]}, {"id": "row-2","items": [{"label": "24.5"},{"label": "1"},{"label": "Added new setting to allow disabling archive path syntax."}]}]}/>

Файловые/табличные движки S3 будут разбирать пути с '::' как `<archive>::<file>`, если архив имеет корректное расширение.
## allow_asynchronous_read_from_io_pool_for_merge_tree {#allow_asynchronous_read_from_io_pool_for_merge_tree} 



<SettingsInfoBlock type="Bool" default_value="0" />

Использовать фоновый пул ввода-вывода для чтения из таблиц MergeTree. Эта настройка может увеличить производительность для запросов, ограниченных вводом-выводом.
## allow_changing_replica_until_first_data_packet {#allow_changing_replica_until_first_data_packet} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, в запрашиваемых соединениях мы можем начать новое соединение до получения первого пакета данных, даже если мы уже сделали некоторый прогресс
(но прогресс не обновлен в течение времени `receive_data_timeout`), в противном случае мы отключаем изменение реплики после первого прогресса.
## allow_create_index_without_type {#allow_create_index_without_type} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить запрос CREATE INDEX без типа. Запрос будет игнорироваться. Сделано для тестов на совместимость с SQL.
## allow_custom_error_code_in_throwif {#allow_custom_error_code_in_throwif} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить использовать пользовательский код ошибки в функции throwIf(). Если true, выбрасываемые исключения могут иметь неожиданные коды ошибок.
## allow_ddl {#allow_ddl} 



<SettingsInfoBlock type="Bool" default_value="1" />

Если установлено в true, то пользователю разрешено выполнять DDL-запросы.
## allow_deprecated_database_ordinary {#allow_deprecated_database_ordinary} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить создание баз данных с устаревшим движком Ordinary.
## allow_deprecated_error_prone_window_functions {#allow_deprecated_error_prone_window_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "0"},{"label": "Allow usage of deprecated error prone window functions (neighbor, runningAccumulate, runningDifferenceStartingWithFirstValue, runningDifference)"}]}]}/>

Разрешить использование устаревших оконных функций, подверженных ошибкам (neighbor, runningAccumulate, runningDifferenceStartingWithFirstValue, runningDifference).
## allow_deprecated_snowflake_conversion_functions {#allow_deprecated_snowflake_conversion_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Disabled deprecated functions snowflakeToDateTime[64] and dateTime[64]ToSnowflake."}]}]}/>

Функции `snowflakeToDateTime`, `snowflakeToDateTime64`, `dateTimeToSnowflake` и `dateTime64ToSnowflake` устарели и отключены по умолчанию.
Пожалуйста, используйте функции `snowflakeIDToDateTime`, `snowflakeIDToDateTime64`, `dateTimeToSnowflakeID` и `dateTime64ToSnowflakeID` вместо этого.

Чтобы повторно включить устаревшие функции (например, в переходный период), пожалуйста, установите эту настройку в `true`.
## allow_deprecated_syntax_for_merge_tree {#allow_deprecated_syntax_for_merge_tree} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить создание *MergeTree таблиц с устаревшим синтаксисом определения движка.
## allow_distributed_ddl {#allow_distributed_ddl} 



<SettingsInfoBlock type="Bool" default_value="1" />

Если установлено в true, то пользователю разрешено выполнять распределенные DDL-запросы.
## allow_drop_detached {#allow_drop_detached} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить запросы ALTER TABLE ... DROP DETACHED PART[ITION] ...
## allow_dynamic_type_in_join_keys {#allow_dynamic_type_in_join_keys} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "0"},{"label": "Disallow using Dynamic type in JOIN keys by default"}]}]}/>

Разрешает использование типа Dynamic в ключах JOIN. Добавлено для совместимости. Не рекомендуется использовать тип Dynamic в ключах JOIN, поскольку сравнение с другими типами может привести к неожиданным результатам.
## allow_execute_multiif_columnar {#allow_execute_multiif_columnar} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить выполнение функции multiIf в столбцовом формате.
## allow_experimental_analyzer {#allow_experimental_analyzer} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Enable analyzer and planner by default."}]}]}/>

Разрешить новый анализатор запросов.
## allow_experimental_codecs {#allow_experimental_codecs} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Если установлено в true, разрешить указывать экспериментальные кодеки сжатия (но пока у нас их нет, и эта опция ничего не делает).
## allow_experimental_correlated_subqueries {#allow_experimental_correlated_subqueries} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "1"},{"label": "Mark correlated subqueries support as Beta."}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "Added new setting to allow correlated subqueries execution."}]}]}/>

Разрешить выполнять коррелированные подзапросы.
## allow_experimental_database_glue_catalog {#allow_experimental_database_glue_catalog} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "0"},{"label": "Allow experimental database engine DataLakeCatalog with catalog_type = 'glue'"}]}]}/>

Разрешить экспериментальный движок баз данных DataLakeCatalog с catalog_type = 'glue'.
## allow_experimental_database_hms_catalog {#allow_experimental_database_hms_catalog} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Allow experimental database engine DataLakeCatalog with catalog_type = 'hive'"}]}]}/>

Разрешить экспериментальный движок баз данных DataLakeCatalog с catalog_type = 'hms'.
## allow_experimental_database_iceberg {#allow_experimental_database_iceberg} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "0"},{"label": "New setting."}]}]}/>

Разрешить экспериментальный движок баз данных DataLakeCatalog с catalog_type = 'iceberg'.
## allow_experimental_database_materialized_postgresql {#allow_experimental_database_materialized_postgresql} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить создание базы данных с Engine=MaterializedPostgreSQL(...).
## allow_experimental_database_unity_catalog {#allow_experimental_database_unity_catalog} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "0"},{"label": "Allow experimental database engine DataLakeCatalog with catalog_type = 'unity'"}]}]}/>

Разрешить экспериментальный движок баз данных DataLakeCatalog с catalog_type = 'unity'.
## allow_experimental_delta_kernel_rs {#allow_experimental_delta_kernel_rs} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "New setting"}]}]}/>

Разрешить экспериментальную реализацию delta-kernel-rs.
## allow_experimental_delta_lake_writes {#allow_experimental_delta_lake_writes} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting."}]}]}/>

Включает функцию записи delta-kernel.
## allow_experimental_full_text_index {#allow_experimental_full_text_index} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Enable experimental text index"}]}]}/>

Если установлено в true, разрешить использование экспериментального текстового индекса.
## allow_experimental_funnel_functions {#allow_experimental_funnel_functions} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Включить экспериментальные функции для анализа воронок.
## allow_experimental_hash_functions {#allow_experimental_hash_functions} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Включить экспериментальные хеш-функции.
## allow_experimental_iceberg_compaction {#allow_experimental_iceberg_compaction} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting "}]}]}/>

Разрешить явное использование 'OPTIMIZE' для таблиц iceberg.
## allow_experimental_insert_into_iceberg {#allow_experimental_insert_into_iceberg} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "0"},{"label": "New setting."}]}]}/>

Разрешить выполнять запросы `insert` в iceberg.
## allow_experimental_join_right_table_sorting {#allow_experimental_join_right_table_sorting} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "If it is set to true, and the conditions of `join_to_sort_minimum_perkey_rows` and `join_to_sort_maximum_table_rows` are met, rerange the right table by key to improve the performance in left or inner hash join"}]}]}/>

Если установлено в true и выполнены условия `join_to_sort_minimum_perkey_rows` и `join_to_sort_maximum_table_rows`, отсортировать правую таблицу по ключу для улучшения производительности при левом или внутреннем хэш-присоединении.
## allow_experimental_kafka_offsets_storage_in_keeper {#allow_experimental_kafka_offsets_storage_in_keeper} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "Allow the usage of experimental Kafka storage engine that stores the committed offsets in ClickHouse Keeper"}]}]}/>

Разрешить экспериментальную функцию хранения смещений, связанных с Kafka, в ClickHouse Keeper. При включении путь ClickHouse Keeper и имя реплики могут быть указаны в движке таблицы Kafka. В результате вместо обычного движка Kafka будет использоваться новый тип движка хранения, который в первую очередь хранит зафиксированные смещения в ClickHouse Keeper.
## allow_experimental_kusto_dialect {#allow_experimental_kusto_dialect} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "A new setting"}]}]}/>

Включить язык запросов Kusto (KQL) - альтернативу SQL.
## allow_experimental_live_view {#allow_experimental_live_view} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает создание устаревшего LIVE VIEW.

Возможные значения:

- 0 — Работа с live-видами отключена.
- 1 — Работа с live-видами включена.
## allow_experimental_materialized_postgresql_table {#allow_experimental_materialized_postgresql_table} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает использовать движок таблиц MaterializedPostgreSQL. Отключен по умолчанию, так как эта функциональность экспериментальная.
## allow_experimental_nlp_functions {#allow_experimental_nlp_functions} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Включить экспериментальные функции для обработки естественного языка.
## allow_experimental_object_type {#allow_experimental_object_type} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить устаревший тип данных Object.
## allow_experimental_parallel_reading_from_replicas {#allow_experimental_parallel_reading_from_replicas} 

<BetaBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />

Использовать до `max_parallel_replicas` количества реплик из каждого шара для выполнения запроса SELECT. Чтение параллелится и координируется динамически. 0 - отключено, 1 - включено, отключается в случае сбоя, 2 - включено, выбрасывает исключение в случае сбоя.
## allow_experimental_prql_dialect {#allow_experimental_prql_dialect} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "A new setting"}]}]}/>

Включить PRQL - альтернативу SQL.
## allow_experimental_qbit_type {#allow_experimental_qbit_type} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "0"},{"label": "New experimental setting"}]}]}/>

Разрешает создание типа данных [QBit](../../sql-reference/data-types/qbit.md).
## allow_experimental_query_deduplication {#allow_experimental_query_deduplication} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Экспериментальная дедупликация данных для запросов SELECT на основе UUID частей.
## allow_experimental_statistics {#allow_experimental_statistics} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "The setting was renamed. The previous name is `allow_experimental_statistic`."}]}]}/>

Разрешает определять столбцы со [статистикой](../../engines/table-engines/mergetree-family/mergetree.md/#table_engine-mergetree-creating-a-table) и [манипулировать статистикой](../../engines/table-engines/mergetree-family/mergetree.md/#column-statistics).
## allow_experimental_time_series_aggregate_functions {#allow_experimental_time_series_aggregate_functions} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "0"},{"label": "New setting to enable experimental timeSeries* aggregate functions."}]}]}/>

Экспериментальные агрегатные функции timeSeries* для ресемплинга временных рядов, аналогичных Prometheus, расчета скорости, дельты.
## allow_experimental_time_series_table {#allow_experimental_time_series_table} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "Added new setting to allow the TimeSeries table engine"}]}]}/>

Разрешает создание таблиц с движком таблицы [TimeSeries](../../engines/table-engines/integrations/time-series.md). Возможные значения:
- 0 — движок таблицы [TimeSeries](../../engines/table-engines/integrations/time-series.md) отключен.
- 1 — движок таблицы [TimeSeries](../../engines/table-engines/integrations/time-series.md) включен.
## allow_experimental_time_time64_type {#allow_experimental_time_time64_type} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "0"},{"label": "New settings. Allows to use a new experimental Time and Time64 data types."}]}]}/>

Разрешает создание типов данных [Time](../../sql-reference/data-types/time.md) и [Time64](../../sql-reference/data-types/time64.md).
## allow_experimental_window_view {#allow_experimental_window_view} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Включить WINDOW VIEW. Недостаточно зрелая функциональность.
## allow_experimental_ytsaurus_dictionary_source {#allow_experimental_ytsaurus_dictionary_source} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting."}]}]}/>

Экспериментальный источник словаря для интеграции с YTsaurus.
## allow_experimental_ytsaurus_table_engine {#allow_experimental_ytsaurus_table_engine} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting."}]}]}/>

Экспериментальный движок таблиц для интеграции с YTsaurus.
## allow_experimental_ytsaurus_table_function {#allow_experimental_ytsaurus_table_function} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting."}]}]}/>

Экспериментальный движок таблиц для интеграции с YTsaurus.
## allow_general_join_planning {#allow_general_join_planning} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Allow more general join planning algorithm when hash join algorithm is enabled."}]}]}/>

Разрешает более общий алгоритм планирования соединений, который может обрабатывать более сложные условия, но работает только с хэш-присоединением. Если хэш-присоединение не включено, будет использоваться обычный алгоритм планирования соединения, независимо от значения этой настройки.
## allow_get_client_http_header {#allow_get_client_http_header} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Introduced a new function."}]}]}/>

Разрешает использовать функцию `getClientHTTPHeader`, которая позволяет получить значение заголовка текущего HTTP-запроса. По умолчанию не включена по соображениям безопасности, поскольку некоторые заголовки, такие как `Cookie`, могут содержать конфиденциальную информацию. Обратите внимание, что заголовки `X-ClickHouse-*` и `Authentication` всегда ограничены и не могут быть получены с помощью этой функции.
## allow_hyperscan {#allow_hyperscan} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешает функции, использующие библиотеку Hyperscan. Отключите, чтобы избежать потенциально долгих времён компиляции и чрезмерного использования ресурсов.
## allow_introspection_functions {#allow_introspection_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает [функции инстроспекции](../../sql-reference/functions/introspection.md) для профилирования запросов.

Возможные значения:

- 1 — Функции инстроспекции включены.
- 0 — Функции инстроспекции отключены.

**Смотрите также**

- [Профилировщик выборки запросов](../../operations/optimizing-performance/sampling-query-profiler.md)
- Системная таблица [trace_log](/operations/system-tables/trace_log)
## allow_materialized_view_with_bad_select {#allow_materialized_view_with_bad_select} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Don't allow creating MVs referencing nonexistent columns or tables"}]}, {"id": "row-2","items": [{"label": "24.9"},{"label": "1"},{"label": "Support (but not enable yet) stricter validation in CREATE MATERIALIZED VIEW"}]}]}/>

Разрешить создать МАТЕРИАЛИЗОВАННОЕ ПРЕДСТАВЛЕНИЕ с запросом SELECT, который ссылается на несуществующие таблицы или колонки. Он все еще должен быть синтаксически корректным. Не применяется к обновляемым МП. Не применяется, если схема МП должна быть выведена из запроса SELECT (т.е. если CREATE не имеет списка колонок и не указывает TO таблицу). Может быть использован для создания МП перед его исходной таблицей.
## allow_named_collection_override_by_default {#allow_named_collection_override_by_default} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить переопределение полей именованных коллекций по умолчанию.
## allow_non_metadata_alters {#allow_non_metadata_alters} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить выполнять изменения, которые затрагивают не только метаданные таблиц, но и данные на диске.
## allow_nonconst_timezone_arguments {#allow_nonconst_timezone_arguments} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "0"},{"label": "Allow non-const timezone arguments in certain time-related functions like toTimeZone(), fromUnixTimestamp*(), snowflakeToDateTime*()."}]}]}/>

Разрешить не константные аргументы часовых поясов в определенных функциях, связанных со временем, таких как toTimeZone(), fromUnixTimestamp*(), snowflakeToDateTime*().
Эта настройка существует только по соображениям совместимости. В ClickHouse часовой пояс — это свойство типа данных, соответственно, колонки.
Включение этой настройки создает ложное впечатление о том, что разные значения в одной колонке могут иметь разные часовые пояса.
Поэтому, пожалуйста, не включайте эту настройку.
## allow_nondeterministic_mutations {#allow_nondeterministic_mutations} 



<SettingsInfoBlock type="Bool" default_value="0" />

Настройка уровня пользователя, которая позволяет мутациям в реплицируемых таблицах использовать недетерминированные функции, такие как `dictGet`.

При этом, например, словари могут быть не синхронизированы между узлами, и мутации, которые извлекают значения из них, по умолчанию не разрешены на реплицируемых таблицах. Включение этой настройки допускает такое поведение, возлагая на пользователя ответственность за обеспечение синхронизации данных на всех узлах.

**Пример**

```xml
<profiles>
    <default>
        <allow_nondeterministic_mutations>1</allow_nondeterministic_mutations>

        <!-- ... -->
    </default>

    <!-- ... -->

</profiles>
```
## allow_nondeterministic_optimize_skip_unused_shards {#allow_nondeterministic_optimize_skip_unused_shards} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить недетерминированные (такие как `rand` или `dictGet`, так как последняя имеет некоторые нюансы с обновлениями) функции в ключе шардирования.

Возможные значения:

- 0 — Запрещено.
- 1 — Разрешено.
## allow_not_comparable_types_in_comparison_functions {#allow_not_comparable_types_in_comparison_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Don't allow not comparable types in comparison functions by default"}]}]}/>

Разрешает или ограничивает использование несравнимых типов (таких как JSON/Object/AggregateFunction) в функциях сравнения `equal/less/greater/etc`.
## allow_not_comparable_types_in_order_by {#allow_not_comparable_types_in_order_by} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Don't allow not comparable types in order by by default"}]}]}/>

Разрешает или ограничивает использование несравнимых типов (таких как JSON/Object/AggregateFunction) в ключах ORDER BY.
## allow_prefetched_read_pool_for_local_filesystem {#allow_prefetched_read_pool_for_local_filesystem} 



<SettingsInfoBlock type="Bool" default_value="0" />

Предпочитать предварительно загруженный пул потоков, если все части находятся в локальной файловой системе.
## allow_prefetched_read_pool_for_remote_filesystem {#allow_prefetched_read_pool_for_remote_filesystem} 



<SettingsInfoBlock type="Bool" default_value="1" />

Предпочитать предварительно загруженный пул потоков, если все части находятся в удаленной файловой системе.
## allow_push_predicate_ast_for_distributed_subqueries {#allow_push_predicate_ast_for_distributed_subqueries} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "A new setting"}]}]}/>

Разрешает использование предиката на уровне AST для распределенных подзапросов с включенным анализатором.
## allow_push_predicate_when_subquery_contains_with {#allow_push_predicate_when_subquery_contains_with} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешает использование предиката, когда подзапрос содержит оператор WITH.
## allow_reorder_prewhere_conditions {#allow_reorder_prewhere_conditions} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1"},{"label": "New setting"}]}]}/>

При перемещении условий из WHERE в PREWHERE позволяет изменять их порядок для оптимизации фильтрации.
## allow_settings_after_format_in_insert {#allow_settings_after_format_in_insert} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.4"},{"label": "0"},{"label": "Do not allow SETTINGS after FORMAT for INSERT queries because ClickHouse interpret SETTINGS as some values, which is misleading"}]}]}/>

Контролирует, разрешены ли `SETTINGS` после `FORMAT` в запросах `INSERT` или нет. Рекомендуется не использовать это, так как это может интерпретировать часть `SETTINGS` как значения.

Пример:

```sql
INSERT INTO FUNCTION null('foo String') SETTINGS max_threads=1 VALUES ('bar');
```

Но следующий запрос будет работать только с `allow_settings_after_format_in_insert`:

```sql
SET allow_settings_after_format_in_insert=1;
INSERT INTO FUNCTION null('foo String') VALUES ('bar') SETTINGS max_threads=1;
```

Возможные значения:

- 0 — Запрещено.
- 1 — Разрешено.

:::note
Используйте эту настройку только для обратной совместимости, если ваши случаи использования зависят от старого синтаксиса.
:::
## allow_simdjson {#allow_simdjson} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить использование библиотеки simdjson в функциях 'JSON*', если доступны инструкции AVX2. Если отключено, будет использоваться rapidjson.
## allow_statistics_optimize {#allow_statistics_optimize} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "The setting was renamed. The previous name is `allow_statistic_optimize`."}]}]}/>

Разрешает использование статистики для оптимизации запросов.
## allow_suspicious_codecs {#allow_suspicious_codecs} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "20.5"},{"label": "0"},{"label": "Don't allow to specify meaningless compression codecs"}]}]}/>

Если установлено в true, разрешить указывать бессмысленные кодеки сжатия.
## allow_suspicious_fixed_string_types {#allow_suspicious_fixed_string_types} 



<SettingsInfoBlock type="Bool" default_value="0" />

В операторе CREATE TABLE позволяет создавать колонки типа FixedString(n) с n > 256. FixedString с длиной >= 256 вызывает подозрения и, скорее всего, указывает на неправильное использование.
## allow_suspicious_indices {#allow_suspicious_indices} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "0"},{"label": "If true, index can defined with identical expressions"}]}]}/>

Отклонять первичные/вторичные индексы и сортировочные ключи с идентичными выражениями.
## allow_suspicious_low_cardinality_types {#allow_suspicious_low_cardinality_types} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает или ограничивает использование [LowCardinality](../../sql-reference/data-types/lowcardinality.md) с типами данных фиксированного размера 8 байт или меньше: числовые типы данных и `FixedString(8_bytes_or_less)`.

Для небольших фиксированных значений использование `LowCardinality` обычно нецелесообразно, поскольку ClickHouse хранит числовой индекс для каждой строки. В результате:

- Использование дискового пространства может возрасти.
- Использование оперативной памяти может быть выше, в зависимости от размера словаря.
- Некоторые функции могут работать медленнее из-за дополнительных операций кодирования/декодирования.

Времена слияния в таблицах с движком [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) могут увеличиться по всем вышеописанным причинам.

Возможные значения:

- 1 — Использование `LowCardinality` не ограничено.
- 0 — Использование `LowCardinality` ограничено.
## allow_suspicious_primary_key {#allow_suspicious_primary_key} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Forbid suspicious PRIMARY KEY/ORDER BY for MergeTree (i.e. SimpleAggregateFunction)"}]}]}/>

Разрешить подозрительные `PRIMARY KEY`/`ORDER BY` для MergeTree (т.е. SimpleAggregateFunction).
## allow_suspicious_ttl_expressions {#allow_suspicious_ttl_expressions} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.12"},{"label": "0"},{"label": "It is a new setting, and in previous versions the behavior was equivalent to allowing."}]}]}/>

Отклонять TTL-выражения, не зависящие от каких-либо столбцов таблицы. Это обычно указывает на ошибку пользователя.
## allow_suspicious_types_in_group_by {#allow_suspicious_types_in_group_by} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Don't allow Variant/Dynamic types in GROUP BY by default"}]}]}/>

Разрешает или ограничивает использование [Variant](../../sql-reference/data-types/variant.md) и [Dynamic](../../sql-reference/data-types/dynamic.md) типов в ключах GROUP BY.
## allow_suspicious_types_in_order_by {#allow_suspicious_types_in_order_by} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Don't allow Variant/Dynamic types in ORDER BY by default"}]}]}/>

Разрешает или ограничивает использование [Variant](../../sql-reference/data-types/variant.md) и [Dynamic](../../sql-reference/data-types/dynamic.md) типов в ключах ORDER BY.
## allow_suspicious_variant_types {#allow_suspicious_variant_types} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "0"},{"label": "Don't allow creating Variant type with suspicious variants by default"}]}]}/>

В операторе CREATE TABLE позволяет указывать тип Variant с похожими типами вариант (например, с разными числовыми или дата-типами). Включение этой настройки может внести некоторую неоднозначность при работе со значениями с похожими типами.
## allow_unrestricted_reads_from_keeper {#allow_unrestricted_reads_from_keeper} 



<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет неограниченные (без условия на путь) чтения из системной таблицы zookeeper, может быть полезно, но небезопасно для zookeeper.
## alter_move_to_space_execute_async {#alter_move_to_space_execute_async} 



<SettingsInfoBlock type="Bool" default_value="0" />

Выполнять ALTER TABLE MOVE ... TO [DISK|VOLUME] асинхронно.
## alter_partition_verbose_result {#alter_partition_verbose_result} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает отображение информации о частях, к которым были успешно применены операции манипуляции с партициями и частями.
Применимо к [ATTACH PARTITION|PART](/sql-reference/statements/alter/partition#attach-partitionpart) и к [FREEZE PARTITION](/sql-reference/statements/alter/partition#freeze-partition).

Возможные значения:

- 0 — отключить детальность.
- 1 — включить детальность.

**Пример**

```sql
CREATE TABLE test(a Int64, d Date, s String) ENGINE = MergeTree PARTITION BY toYYYYMDECLARE(d) ORDER BY a;
INSERT INTO test VALUES(1, '2021-01-01', '');
INSERT INTO test VALUES(1, '2021-01-01', '');
ALTER TABLE test DETACH PARTITION ID '202101';

ALTER TABLE test ATTACH PARTITION ID '202101' SETTINGS alter_partition_verbose_result = 1;

┌─command_type─────┬─partition_id─┬─part_name────┬─old_part_name─┐
│ ATTACH PARTITION │ 202101       │ 202101_7_7_0 │ 202101_5_5_0  │
│ ATTACH PARTITION │ 202101       │ 202101_8_8_0 │ 202101_6_6_0  │
└──────────────────┴──────────────┴──────────────┴───────────────┘

ALTER TABLE test FREEZE SETTINGS alter_partition_verbose_result = 1;

┌─command_type─┬─partition_id─┬─part_name────┬─backup_name─┬─backup_path───────────────────┬─part_backup_path────────────────────────────────────────────┐
│ FREEZE ALL   │ 202101       │ 202101_7_7_0 │ 8           │ /var/lib/clickhouse/shadow/8/ │ /var/lib/clickhouse/shadow/8/data/default/test/202101_7_7_0 │
│ FREEZE ALL   │ 202101       │ 202101_8_8_0 │ 8           │ /var/lib/clickhouse/shadow/8/ │ /var/lib/clickhouse/shadow/8/data/default/test/202101_8_8_0 │
└──────────────┴──────────────┴──────────────┴─────────────┴───────────────────────────────┴─────────────────────────────────────────────────────────────┘
```
## alter_sync {#alter_sync} 



<SettingsInfoBlock type="UInt64" default_value="1" />

Позволяет настроить ожидание выполнения действий на репликах через [ALTER](../../sql-reference/statements/alter/index.md), [OPTIMIZE](../../sql-reference/statements/optimize.md) или [TRUNCATE](../../sql-reference/statements/truncate.md) запросы.

Возможные значения:

- `0` — Не ждать.
- `1` — Ждать выполнения собственного запроса.
- `2` — Ждать выполнения всеми.

Значение по умолчанию для облака: `1`.

:::note
`alter_sync` применяется только к `Replicated` таблицам, он не оказывает влияния на изменения в непреплицированных таблицах.
:::
## alter_update_mode {#alter_update_mode} 



<SettingsInfoBlock type="AlterUpdateMode" default_value="heavy" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "heavy"},{"label": "A new setting"}]}]}/>

Режим для запросов `ALTER`, которые имеют команды `UPDATE`.

Возможные значения:
- `heavy` - выполнять обычную мутацию.
- `lightweight` - выполнять легковесное обновление, если это возможно, в противном случае запускать обычную мутацию.
- `lightweight_force` - выполнять легковесное обновление, если это возможно, в противном случае выбрасывать исключение.
## analyze_index_with_space_filling_curves {#analyze_index_with_space_filling_curves} 



<SettingsInfoBlock type="Bool" default_value="1" />

Если у таблицы есть заполненная пространственная кривая в ее индексе, например, `ORDER BY mortonEncode(x, y)` или `ORDER BY hilbertEncode(x, y)`, и запрос имеет условия на его аргументы, например, `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30`, используйте пространственную кривую для анализа индекса.
## analyzer_compatibility_allow_compound_identifiers_in_unflatten_nested {#analyzer_compatibility_allow_compound_identifiers_in_unflatten_nested} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "1"},{"label": "New setting."}]}]}/>

Разрешить добавление составных идентификаторов в вложенные. Это настройка совместимости, так как она изменяет результат запроса. Когда отключено, `SELECT a.b.c FROM table ARRAY JOIN a` не работает, и `SELECT a FROM table` не включает колонку `a.b.c` в результат `Nested a`.
## analyzer_compatibility_join_using_top_level_identifier {#analyzer_compatibility_join_using_top_level_identifier} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Force to resolve identifier in JOIN USING from projection"}]}]}/>

Принудительно разрешить идентификатор в JOIN USING из проекции (например, в `SELECT a + 1 AS b FROM t1 JOIN t2 USING (b)` соединение будет выполняться по `t1.a + 1 = t2.b`, а не по `t1.b = t2.b`).
## any_join_distinct_right_table_keys {#any_join_distinct_right_table_keys} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "19.14"},{"label": "0"},{"label": "Disable ANY RIGHT and ANY FULL JOINs by default to avoid inconsistency"}]}]}/>

Включает поведение сервера ClickHouse в `ANY INNER|LEFT JOIN` операциях.

:::note
Используйте эту настройку только для обратной совместимости, если ваши случаи использования зависят от устаревшего поведения `JOIN`.
:::

Когда устаревшее поведение включено:

- Результаты операций `t1 ANY LEFT JOIN t2` и `t2 ANY RIGHT JOIN t1` не равны, потому что ClickHouse использует логику с множественным отображением ключей таблиц слева направо.
- Результаты операций `ANY INNER JOIN` содержат все строки из левой таблицы, как делает это `SEMI LEFT JOIN`.

Когда устаревшее поведение отключено:

- Результаты операций `t1 ANY LEFT JOIN t2` и `t2 ANY RIGHT JOIN t1` равны, так как ClickHouse использует логику, которая обеспечивает отображение ключей один-на-много в операциях `ANY RIGHT JOIN`.
- Результаты операций `ANY INNER JOIN` содержат одну строку на ключ как из левой, так и из правой таблиц.

Возможные значения:

- 0 — Устаревшее поведение отключено.
- 1 — Устаревшее поведение включено.

Смотрите также:

- [Строгость JOIN](/sql-reference/statements/select/join#settings)
## apply_deleted_mask {#apply_deleted_mask} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает фильтрацию строк, удаленных с помощью легковесного DELETE. Если отключено, запрос сможет читать эти строки. Это полезно для отладки и "аннулирования" сценариев.
## apply_mutations_on_fly {#apply_mutations_on_fly} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если true, мутации (UPDATE и DELETE), которые не материализованы в части данных, будут применяться при SELECT.
## apply_patch_parts {#apply_patch_parts} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "A new setting"}]}]}/>

Если true, патч-части (представляющие собой легковесные обновления) применяются при SELECT.
## apply_patch_parts_join_cache_buckets {#apply_patch_parts_join_cache_buckets} 



<SettingsInfoBlock type="NonZeroUInt64" default_value="8" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "8"},{"label": "New setting"}]}]}/>

Количество ведер во временном кэше для применения патч-частей в режиме Join.
## apply_settings_from_server {#apply_settings_from_server} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Client-side code (e.g. INSERT input parsing and query output formatting) will use the same settings as the server, including settings from server config."}]}]}/>

Должен ли клиент принимать настройки от сервера.

Это влияет только на операции, выполняемые на стороне клиента, в частности, разбор входных данных INSERT и форматирование результата запроса. Большая часть выполнения запроса происходит на сервере и на эту настройку не влияет.

Обычно эта настройка должна быть настроена в профиле пользователя (users.xml или запросы вроде `ALTER USER`), а не через клиент (аргументы командной строки клиента, запрос `SET` или раздел `SETTINGS` запроса `SELECT`). Через клиент ее можно изменить на false, но нельзя изменить на true (поскольку сервер не отправит настройки, если в профиле пользователя установлено `apply_settings_from_server = false`).

Обратите внимание, что изначально (24.12) была настройка сервера (`send_settings_to_client`), но позже она была заменена на эту настройку клиента для лучшей удобства.
## asterisk_include_alias_columns {#asterisk_include_alias_columns} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включить [ALIAS](../../sql-reference/statements/create/table.md/#alias) столбцы для запроса wildcard (`SELECT *`).

Возможные значения:

- 0 - отключено
- 1 - включено
## asterisk_include_materialized_columns {#asterisk_include_materialized_columns} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включить [MATERIALIZED](/sql-reference/statements/create/view#materialized-view) столбцы для запроса wildcard (`SELECT *`).

Возможные значения:

- 0 - отключено
- 1 - включено
## async_insert {#async_insert} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если true, данные из запроса INSERT хранятся в очереди и позднее выводятся в таблицу в фоновом режиме. Если wait_for_async_insert равно false, запрос INSERT обрабатывается почти мгновенно, в противном случае клиент будет ждать, пока данные будут выведены в таблицу.
## async_insert_busy_timeout_decrease_rate {#async_insert_busy_timeout_decrease_rate} 



<SettingsInfoBlock type="Double" default_value="0.2" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "0.2"},{"label": "The exponential growth rate at which the adaptive asynchronous insert timeout decreases"}]}]}/>

Экспоненциальная скорость роста, с которой временной интервал для адаптивного асинхронного вставки уменьшается.
## async_insert_busy_timeout_increase_rate {#async_insert_busy_timeout_increase_rate} 



<SettingsInfoBlock type="Double" default_value="0.2" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "0.2"},{"label": "The exponential growth rate at which the adaptive asynchronous insert timeout increases"}]}]}/>

Экспоненциальная скорость роста, с которой временной интервал для адаптивного асинхронного вставки увеличивается.
## async_insert_busy_timeout_max_ms {#async_insert_busy_timeout_max_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="200" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "200"},{"label": "The minimum value of the asynchronous insert timeout in milliseconds; async_insert_busy_timeout_ms is aliased to async_insert_busy_timeout_max_ms"}]}]}/>

Максимальное время ожидания перед выгрузкой собранных данных по запросу с момента появления первых данных.
## async_insert_busy_timeout_min_ms {#async_insert_busy_timeout_min_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="50" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "50"},{"label": "The minimum value of the asynchronous insert timeout in milliseconds; it also serves as the initial value, which may be increased later by the adaptive algorithm"}]}]}/>

Если включена авторегулировка через async_insert_use_adaptive_busy_timeout, минимальное время ожидания перед сбросом собранных данных по запросу с момента появления первых данных. Также служит начальным значением для адаптивного алгоритма.
## async_insert_deduplicate {#async_insert_deduplicate} 

<SettingsInfoBlock type="Bool" default_value="0" />

Для асинхронных запросов INSERT в реплицируемой таблице указывает, что должна выполняться дедупликация вставляемых блоков.
## async_insert_max_data_size {#async_insert_max_data_size} 

<SettingsInfoBlock type="UInt64" default_value="10485760" />

Максимальный размер в байтах непарсенных данных, собранных по запросу перед вставкой.
## async_insert_max_query_number {#async_insert_max_query_number} 

<SettingsInfoBlock type="UInt64" default_value="450" />

Максимальное количество запросов на вставку перед их вставкой. Вступает в силу только если настройка [`async_insert_deduplicate`](#async_insert_deduplicate) равна 1.
## async_insert_poll_timeout_ms {#async_insert_poll_timeout_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="10" />

Таймаут для опроса данных из очереди асинхронной вставки.
## async_insert_use_adaptive_busy_timeout {#async_insert_use_adaptive_busy_timeout} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если установлено в true, использовать адаптивный таймаут занятости для асинхронных вставок.
## async_query_sending_for_remote {#async_query_sending_for_remote} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает создание асинхронного соединения и отправку запроса при выполнении удаленного запроса.

Включено по умолчанию.
## async_socket_for_remote {#async_socket_for_remote} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает асинхронное чтение из сокета при выполнении удаленного запроса.

Включено по умолчанию.
## azure_allow_parallel_part_upload {#azure_allow_parallel_part_upload} 

<SettingsInfoBlock type="Bool" default_value="1" />

Использовать несколько потоков для многокомпонентной загрузки в Azure.
## azure_check_objects_after_upload {#azure_check_objects_after_upload} 

<SettingsInfoBlock type="Bool" default_value="0" />

Проверить каждый загруженный объект в хранилище Azure blob, чтобы убедиться, что загрузка прошла успешно.
## azure_connect_timeout_ms {#azure_connect_timeout_ms} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Таймаут подключения для хоста из дисков Azure.
## azure_create_new_file_on_insert {#azure_create_new_file_on_insert} 

Включает или отключает создание нового файла при каждой вставке в таблицах движка Azure.
## azure_ignore_file_doesnt_exist {#azure_ignore_file_doesnt_exist} 

<SettingsInfoBlock type="Bool" default_value="0" />

Игнорировать отсутствие файла, если он не существует при чтении определенных ключей.

Возможные значения:
- 1 — `SELECT` возвращает пустой результат.
- 0 — `SELECT` вызывает исключение.
## azure_list_object_keys_size {#azure_list_object_keys_size} 

Максимальное количество файлов, которые могут быть возвращены пакетно запросом ListObject.
## azure_max_blocks_in_multipart_upload {#azure_max_blocks_in_multipart_upload} 

<SettingsInfoBlock type="UInt64" default_value="50000" />

Максимальное количество блоков в многокомпонентной загрузке для Azure.
## azure_max_get_burst {#azure_max_get_burst} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество запросов, которые могут быть выполнены одновременно перед достижением предела запросов в секунду. По умолчанию (0) равно `azure_max_get_rps`.
## azure_max_get_rps {#azure_max_get_rps} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Предел на количество GET запросов в секунду для Azure перед ограничением. Ноль означает отсутствие ограничений.
## azure_max_inflight_parts_for_one_file {#azure_max_inflight_parts_for_one_file} 

<SettingsInfoBlock type="UInt64" default_value="20" />

Максимальное количество одновременно загружаемых частей в запросе многокомпонентной загрузки. 0 означает отсутствие ограничений.
## azure_max_put_burst {#azure_max_put_burst} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество запросов, которые могут быть выполнены одновременно перед достижением предела запросов в секунду. По умолчанию (0) равно `azure_max_put_rps`.
## azure_max_put_rps {#azure_max_put_rps} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Предел на количество PUT запросов в секунду для Azure перед ограничением. Ноль означает отсутствие ограничений.
## azure_max_redirects {#azure_max_redirects} 

Максимальное количество перенаправлений Azure.
## azure_max_single_part_copy_size {#azure_max_single_part_copy_size} 

Максимальный размер объекта для копирования, используя одночастичное копирование в хранилище Azure blob.
## azure_max_single_part_upload_size {#azure_max_single_part_upload_size} 

Максимальный размер объекта для загрузки, используя одночастичную загрузку в хранилище Azure blob.
## azure_max_single_read_retries {#azure_max_single_read_retries} 

Максимальное количество повторных попыток во время одного чтения из хранилища Azure blob.
## azure_max_unexpected_write_error_retries {#azure_max_unexpected_write_error_retries} 

<SettingsInfoBlock type="UInt64" default_value="4" />

Максимальное количество повторных попыток в случае неожиданных ошибок при записи в хранилище Azure blob.
## azure_max_upload_part_size {#azure_max_upload_part_size} 

Максимальный размер части для загрузки во время многокомпонентной загрузки в хранилище Azure blob.
## azure_min_upload_part_size {#azure_min_upload_part_size} 

Минимальный размер части для загрузки во время многокомпонентной загрузки в хранилище Azure blob.
## azure_request_timeout_ms {#azure_request_timeout_ms} 

Таймаут бездействия для отправки и получения данных в/из Azure. Неудача, если один вызов TCP на чтение или запись блокирует так долго.
## azure_sdk_max_retries {#azure_sdk_max_retries} 

Максимальное количество повторных попыток в Azure SDK.
## azure_sdk_retry_initial_backoff_ms {#azure_sdk_retry_initial_backoff_ms} 

Минимальный интервал ожидания между повторными попытками в Azure SDK.
## azure_sdk_retry_max_backoff_ms {#azure_sdk_retry_max_backoff_ms} 

Максимальный интервал ожидания между повторными попытками в Azure SDK.
## azure_sdk_use_native_client {#azure_sdk_use_native_client} 

Использовать собственный HTTP-клиент ClickHouse для Azure SDK.
## azure_skip_empty_files {#azure_skip_empty_files} 

Включает или отключает пропуск пустых файлов в движке S3.

Возможные значения:
- 0 — `SELECT` вызывает исключение, если пустой файл несовместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.
## azure_strict_upload_part_size {#azure_strict_upload_part_size} 

Точный размер части для загрузки во время многокомпонентной загрузки в хранилище Azure blob.
## azure_throw_on_zero_files_match {#azure_throw_on_zero_files_match} 

Вызывает ошибку, если не совпало ни одного файла в соответствии с правилами расширения glob.

Возможные значения:
- 1 — `SELECT` вызывает исключение.
- 0 — `SELECT` возвращает пустой результат.
## azure_truncate_on_insert {#azure_truncate_on_insert} 

Включает или отключает усечение перед вставкой в таблицах движка Azure.
## azure_upload_part_size_multiply_factor {#azure_upload_part_size_multiply_factor} 

Умножает azure_min_upload_part_size на этот коэффициент каждый раз, когда загружались azure_multiply_parts_count_threshold частей из одной записи в хранилище Azure blob.
## azure_upload_part_size_multiply_parts_count_threshold {#azure_upload_part_size_multiply_parts_count_threshold} 

Каждый раз, когда это количество частей загружалось в хранилище Azure blob, azure_min_upload_part_size умножается на azure_upload_part_size_multiply_factor.
## azure_use_adaptive_timeouts {#azure_use_adaptive_timeouts} 

При установке в `true` для всех запросов Azure первые две попытки выполняются с низкими таймаутами отправки и получения. При установке в `false` все попытки выполняются с одинаковыми таймаутами.
## backup_restore_batch_size_for_keeper_multi {#backup_restore_batch_size_for_keeper_multi} 

Максимальный размер пакета для многорежимного запроса к [Zoo]Keeper во время резервного копирования или восстановления.
## backup_restore_batch_size_for_keeper_multiread {#backup_restore_batch_size_for_keeper_multiread} 

Максимальный размер пакета для многорежимного запроса к [Zoo]Keeper во время резервного копирования или восстановления.
## backup_restore_failure_after_host_disconnected_for_seconds {#backup_restore_failure_after_host_disconnected_for_seconds} 

Если хост во время операции BACKUP ON CLUSTER или RESTORE ON CLUSTER не восстанавливает свой временный 'alive' узел в ZooKeeper в течение этого времени, то все резервное копирование или восстановление считается неудачным. Это значение должно быть большим, чем любое разумное время для хоста, чтобы переподключиться к ZooKeeper после сбоя. Ноль означает неограниченное время.
## backup_restore_finish_timeout_after_error_sec {#backup_restore_finish_timeout_after_error_sec} 

Сколько времени инициатор должен ждать, чтобы другой хост отреагировал на узел 'error' и прекратил свою работу над текущей операцией BACKUP ON CLUSTER или RESTORE ON CLUSTER.
## backup_restore_keeper_fault_injection_probability {#backup_restore_keeper_fault_injection_probability} 

Приблизительная вероятность сбоя для запроса Keeper во время резервного копирования или восстановления. Допустимое значение находится в интервале [0.0f, 1.0f].
## backup_restore_keeper_fault_injection_seed {#backup_restore_keeper_fault_injection_seed} 

0 - случайное значение, в противном случае значение настройки.
## backup_restore_keeper_max_retries {#backup_restore_keeper_max_retries} 

Максимальные повторные попытки для операций [Zoo]Keeper в процессе резервного копирования или восстановления. Должно быть достаточно велико, чтобы вся операция не завершилась неудачей из-за временного сбоя [Zoo]Keeper.
## backup_restore_keeper_max_retries_while_handling_error {#backup_restore_keeper_max_retries_while_handling_error} 

Максимальные повторные попытки для операций [Zoo]Keeper во время обработки ошибки операции BACKUP ON CLUSTER или RESTORE ON CLUSTER.
## backup_restore_keeper_max_retries_while_initializing {#backup_restore_keeper_max_retries_while_initializing} 

Максимальные повторные попытки для операций [Zoo]Keeper во время инициализации операции BACKUP ON CLUSTER или RESTORE ON CLUSTER.
## backup_restore_keeper_retry_initial_backoff_ms {#backup_restore_keeper_retry_initial_backoff_ms} 

Начальный таймаут ожидания для операций [Zoo]Keeper во время резервного копирования или восстановления.
## backup_restore_keeper_retry_max_backoff_ms {#backup_restore_keeper_retry_max_backoff_ms} 

Максимальный таймаут ожидания для операций [Zoo]Keeper во время резервного копирования или восстановления.
## backup_restore_keeper_value_max_size {#backup_restore_keeper_value_max_size} 

Максимальный размер данных узла [Zoo]Keeper во время резервного копирования.
## backup_restore_s3_retry_attempts {#backup_restore_s3_retry_attempts} 

Настройка для Aws::Client::RetryStrategy, Aws::Client выполняет повторы самостоятельно, 0 означает отсутствие повторов. Эта настройка относится только к резервному копированию/восстановлению.
## backup_restore_s3_retry_initial_backoff_ms {#backup_restore_s3_retry_initial_backoff_ms} 

Начальная задержка ожидания в миллисекундах перед первой попыткой повтора во время резервного копирования и восстановления. Каждая следующая попытка увеличивает задержку экспоненциально, до максимума, установленного в `backup_restore_s3_retry_max_backoff_ms`.
## backup_restore_s3_retry_jitter_factor {#backup_restore_s3_retry_jitter_factor} 

Фактор неточности, применяемый к задержке повтора, в Aws::Client::RetryStrategy во время операций резервного копирования и восстановления. Рассчитанная задержка ожидания умножается на случайный фактор в диапазоне [1.0, 1.0 + jitter], до максимума `backup_restore_s3_retry_max_backoff_ms`. Должен находиться в интервале [0.0, 1.0].
## backup_restore_s3_retry_max_backoff_ms {#backup_restore_s3_retry_max_backoff_ms} 

Максимальная задержка в миллисекундах между повторами во время операций резервного копирования и восстановления.
## cache_warmer_threads {#cache_warmer_threads} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="4" />

Оказывает влияние только в ClickHouse Cloud. Количество фоновых потоков для спекулятивной загрузки новых частей данных в файловый кэш, когда [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch) включено. Ноль для отключения.
## calculate_text_stack_trace {#calculate_text_stack_trace} 

Вычесление текстового трассировки стека в случае исключений во время выполнения запроса. Это значение по умолчанию. Требует поиска символов, что может замедлить тесты на неявные ошибки при выполнении большого количества неправильных запросов. В обычных случаях вы не должны отключать эту опцию.
## cancel_http_readonly_queries_on_client_close {#cancel_http_readonly_queries_on_client_close} 

Отменяет HTTP запросы только для чтения (например, SELECT), когда клиент закрывает соединение, не дожидаясь ответа.

Cloud значение по умолчанию: `0`.
## cast_ipv4_ipv6_default_on_conversion_error {#cast_ipv4_ipv6_default_on_conversion_error} 

Оператор CAST в IPv4, оператор CAST в IPV6, функции toIPv4, toIPv6 будут возвращать значение по умолчанию вместо выбрасывания исключения при ошибке преобразования.
## cast_keep_nullable {#cast_keep_nullable} 

Включает или отключает сохранение типа данных `Nullable` в операциях [CAST](/sql-reference/functions/type-conversion-functions#cast).

Когда настройка включена и аргумент функции `CAST` является `Nullable`, результат также преобразуется в тип `Nullable`. Когда настройка отключена, результат всегда имеет точно указанный целевой тип.

Возможные значения:

- 0 — Результат `CAST` имеет точно указанный целевой тип.
- 1 — Если тип аргумента является `Nullable`, результат `CAST` преобразуется в `Nullable(DestinationDataType)`.

**Примеры**

Следующий запрос дает именно указанный целевой тип данных:

```sql
SET cast_keep_nullable = 0;
SELECT CAST(toNullable(toInt32(0)) AS Int32) as x, toTypeName(x);
```

Результат:

```text
┌─x─┬─toTypeName(CAST(toNullable(toInt32(0)), 'Int32'))─┐
│ 0 │ Int32                                             │
└───┴───────────────────────────────────────────────────┘
```

Следующий запрос приводит к модификации `Nullable` в целевом типе данных:

```sql
SET cast_keep_nullable = 1;
SELECT CAST(toNullable(toInt32(0)) AS Int32) as x, toTypeName(x);
```

Результат:

```text
┌─x─┬─toTypeName(CAST(toNullable(toInt32(0)), 'Int32'))─┐
│ 0 │ Nullable(Int32)                                   │
└───┴───────────────────────────────────────────────────┘
```

**См. также**

- [CAST](/sql-reference/functions/type-conversion-functions#cast) функция.
## cast_string_to_date_time_mode {#cast_string_to_date_time_mode} 

<SettingsInfoBlock type="DateTimeInputFormat" default_value="basic" />

Позволяет выбрать парсер текстового представления даты и времени при преобразовании из String.

Возможные значения:

- `'best_effort'` — Включает расширенный парсинг.

    ClickHouse может анализировать базовый формат `YYYY-MM-DD HH:MM:SS` и все форматы даты и времени [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601). Например, `'2018-06-08T01:02:03.000Z'`.

- `'best_effort_us'` — Похоже на `best_effort` (разница в [parseDateTimeBestEffortUS](../../sql-reference/functions/type-conversion-functions#parsedatetimebesteffortus).

- `'basic'` — Использовать базовый парсер.

    ClickHouse может анализировать только базовый формат `YYYY-MM-DD HH:MM:SS` или `YYYY-MM-DD`. Например, `2019-08-20 10:18:56` или `2019-08-20`.

Смотрите также:

- [Тип данных DateTime.](../../sql-reference/data-types/datetime.md)
- [Функции для работы с датами и временем.](../../sql-reference/functions/date-time-functions.md)
## cast_string_to_dynamic_use_inference {#cast_string_to_dynamic_use_inference} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использовать вывод типов при преобразовании из String в Dynamic.
## cast_string_to_variant_use_inference {#cast_string_to_variant_use_inference} 

<SettingsInfoBlock type="Bool" default_value="1" />

Использовать вывод типов при преобразовании из String в Variant.
## check_query_single_value_result {#check_query_single_value_result} 

Определяет уровень детализации результата запроса [CHECK TABLE](/sql-reference/statements/check-table) для движков семейства `MergeTree`.

Возможные значения:

- 0 — запрос показывает статус проверки для каждой отдельной части данных таблицы.
- 1 — запрос показывает общий статус проверки таблицы.
## check_referential_table_dependencies {#check_referential_table_dependencies} 

Проверяет, что DDL запрос (например, DROP TABLE или RENAME) не нарушит ссылочные зависимости.
## check_table_dependencies {#check_table_dependencies} 

Проверяет, что DDL запрос (например, DROP TABLE или RENAME) не нарушит зависимости.
## checksum_on_read {#checksum_on_read} 

Проверяет контрольные суммы при чтении. Это значение включается по умолчанию и всегда должно быть включено в производственной среде. Пожалуйста, не ожидайте никаких преимуществ от отключения этой настройки. Она может использоваться только для экспериментов и бенчмарков. Настройка применима только для таблиц семейства MergeTree. Контрольные суммы всегда проверяются для других движков таблиц и при получении данных по сети.
## cloud_mode {#cloud_mode} 

Облачный режим.
## cloud_mode_database_engine {#cloud_mode_database_engine} 

<SettingsInfoBlock type="UInt64" default_value="1" />

Движок базы данных, разрешенный в облаке. 1 - переписывать DDL с использованием реплицированной базы данных, 2 - переписывать DDL с использованием общей базы данных.
## cloud_mode_engine {#cloud_mode_engine} 

Семейство движков, разрешенных в облаке.

- 0 - разрешить все.
- 1 - переписывать DDL с использованием *ReplicatedMergeTree.
- 2 - переписывать DDL с использованием SharedMergeTree.
- 3 - переписывать DDL с использованием SharedMergeTree, за исключением случаев, когда явно указан удаленный диск.

UInt64 для минимизации публичной части.
## cluster_for_parallel_replicas {#cluster_for_parallel_replicas} 

<BetaBadge/>

Кластер для шарда, в котором находится текущий сервер.
## cluster_function_process_archive_on_multiple_nodes {#cluster_function_process_archive_on_multiple_nodes} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если установлено в `true`, повышает производительность обработки архивов в кластерных функциях. Должно быть установлено в `false` для совместимости и чтобы избежать ошибок при обновлении до 25.7+, если используются кластерные функции с архивами на более ранних версиях.
## collect_hash_table_stats_during_aggregation {#collect_hash_table_stats_during_aggregation} 

Включает сбор статистики хеш-таблицы для оптимизации распределения памяти.
## collect_hash_table_stats_during_joins {#collect_hash_table_stats_during_joins} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает сбор статистики хеш-таблицы для оптимизации распределения памяти.
## compatibility {#compatibility} 

Настройка `compatibility` заставляет ClickHouse использовать настройки по умолчанию предыдущей версии ClickHouse, где предыдущая версия указывается в настройке.

Если настройки установлены в ненастроенные значения, то эти настройки будут соблюдены (только настройки, которые не были изменены, подвержены действию настройки `compatibility`).

Эта настройка принимает номер версии ClickHouse в качестве строки, например, `22.3`, `22.8`. Пустое значение означает, что эта настройка отключена.

Отключено по умолчанию.

:::note
В ClickHouse Cloud настройка совместимости должна устанавливаться поддержкой ClickHouse Cloud. Пожалуйста, [откройте запрос](https://clickhouse.cloud/support) для ее установки.
:::
## compatibility_ignore_auto_increment_in_create_table {#compatibility_ignore_auto_increment_in_create_table} 

Игнорировать ключевое слово AUTO_INCREMENT в объявлении столбца, если true, в противном случае вернуть ошибку. Упрощает миграцию из MySQL.
## compatibility_ignore_collation_in_create_table {#compatibility_ignore_collation_in_create_table} 

Совместимость игнорирует сортировку в создании таблицы.
## compile_aggregate_expressions {#compile_aggregate_expressions} 

Включает или отключает JIT-компиляцию агрегатных функций в нативный код. Включение этой настройки может улучшить производительность.

Возможные значения:

- 0 — Агрегация выполняется без JIT-компиляции.
- 1 — Агрегация выполняется с использованием JIT-компиляции.

**Смотрите также**

- [min_count_to_compile_aggregate_expression](#min_count_to_compile_aggregate_expression).
## compile_expressions {#compile_expressions} 

<SettingsInfoBlock type="Bool" default_value="1" />

Компилирует некоторые скалярные функции и операторы в нативный код.
## compile_sort_description {#compile_sort_description} 

Компилирует описание сортировки в нативный код.
## connect_timeout {#connect_timeout} 

Таймаут соединения, если нет реплик.
## connect_timeout_with_failover_ms {#connect_timeout_with_failover_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="1000" />

Таймаут в миллисекундах для подключения к удаленному серверу для движка таблицы Distributed, если в определении кластера используются разделы 'shard' и 'replica'. Если не удается, выполняются несколько попыток подключения к различным репликам.
## connect_timeout_with_failover_secure_ms {#connect_timeout_with_failover_secure_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="1000" />

Таймаут подключения для выбора первой здоровой реплики (для защищенных соединений).
## connection_pool_max_wait_ms {#connection_pool_max_wait_ms} 

Время ожидания в миллисекундах для подключения, когда пул соединений полон.

Возможные значения:

- Положительное целое число.
- 0 — Безлимитный таймаут.
## connections_with_failover_max_tries {#connections_with_failover_max_tries} 

Максимальное количество попыток подключения к каждой реплике для движка таблицы Distributed.
## convert_query_to_cnf {#convert_query_to_cnf} 

Когда установлено в `true`, запрос `SELECT` будет преобразован в конъюнктивную нормальную форму (CNF). Есть сценарии, когда переписывание запроса в CNF может выполняться быстрее (смотрите этот [Github issue](https://github.com/ClickHouse/ClickHouse/issues/11749) для объяснения).

Например, обратите внимание, как следующий запрос `SELECT` не модифицирован (поведение по умолчанию):

```sql
EXPLAIN SYNTAX
SELECT *
FROM
(
    SELECT number AS x
    FROM numbers(20)
) AS a
WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))
SETTINGS convert_query_to_cnf = false;
```

Результат:

```response
┌─explain────────────────────────────────────────────────────────┐
│ SELECT x                                                       │
│ FROM                                                           │
│ (                                                              │
│     SELECT number AS x                                         │
│     FROM numbers(20)                                           │
│     WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15)) │
│ ) AS a                                                         │
│ WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))     │
│ SETTINGS convert_query_to_cnf = 0                              │
└────────────────────────────────────────────────────────────────┘
```

Давайте установим `convert_query_to_cnf` в `true` и посмотрим, что изменится:

```sql
EXPLAIN SYNTAX
SELECT *
FROM
(
    SELECT number AS x
    FROM numbers(20)
) AS a
WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))
SETTINGS convert_query_to_cnf = true;
```

Обратите внимание, что условие `WHERE` переписано в CNF, но результирующее множество идентично — логика булевого выражения не изменена:

```response
┌─explain───────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ SELECT x                                                                                                              │
│ FROM                                                                                                                  │
│ (                                                                                                                     │
│     SELECT number AS x                                                                                                │
│     FROM numbers(20)                                                                                                  │
│     WHERE ((x <= 15) OR (x <= 5)) AND ((x <= 15) OR (x >= 1)) AND ((x >= 10) OR (x <= 5)) AND ((x >= 10) OR (x >= 1)) │
│ ) AS a                                                                                                                │
│ WHERE ((x >= 10) OR (x >= 1)) AND ((x >= 10) OR (x <= 5)) AND ((x <= 15) OR (x >= 1)) AND ((x <= 15) OR (x <= 5))     │
│ SETTINGS convert_query_to_cnf = 1                                                                                     │
└───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

Возможные значения: true, false.
## correlated_subqueries_substitute_equivalent_expressions {#correlated_subqueries_substitute_equivalent_expressions} 

Использовать фильтровые выражения для вывода эквивалентных выражений и подстановки их вместо создания CROSS JOIN.
## count_distinct_implementation {#count_distinct_implementation} 

Указывает, какие из функций `uniq*` следует использовать для выполнения конструкции [COUNT(DISTINCT ...)](/sql-reference/aggregate-functions/reference/count).

Возможные значения:

- [uniq](/sql-reference/aggregate-functions/reference/uniq)
- [uniqCombined](/sql-reference/aggregate-functions/reference/uniqcombined)
- [uniqCombined64](/sql-reference/aggregate-functions/reference/uniqcombined64)
- [uniqHLL12](/sql-reference/aggregate-functions/reference/uniqhll12)
- [uniqExact](/sql-reference/aggregate-functions/reference/uniqexact)
## count_distinct_optimization {#count_distinct_optimization} 

Переписывать count distinct в подзапрос group by.
## count_matches_stop_at_empty_match {#count_matches_stop_at_empty_match} 

<SettingsInfoBlock type="Bool" default_value="0" />

Прекращать подсчет, как только образец совпадает с нулевой длиной в функции `countMatches`.
## create_if_not_exists {#create_if_not_exists} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает `IF NOT EXISTS` по умолчанию для оператора `CREATE`. Если либо эта настройка, либо `IF NOT EXISTS` указаны, и таблица с указанным именем уже существует, исключение не будет выдано.
## create_index_ignore_unique {#create_index_ignore_unique} 

Игнорировать ключевое слово UNIQUE при создании UNIQUE INDEX. Сделано для совместимости SQL.
## create_replicated_merge_tree_fault_injection_probability {#create_replicated_merge_tree_fault_injection_probability} 

Вероятность сбоя при инъекции ошибок во время создания таблицы после создания метаданных в ZooKeeper.
## create_table_empty_primary_key_by_default {#create_table_empty_primary_key_by_default} 

Разрешает создавать *MergeTree таблицы с пустым первичным ключом, когда ORDER BY и PRIMARY KEY не заданы.
## cross_join_min_bytes_to_compress {#cross_join_min_bytes_to_compress} 

Минимальный размер блока для сжатия в CROSS JOIN. Нулевое значение означает — отключить этот порог. Этот блок сжимается, когда достигается один из двух порогов (по строкам или по байтам).
## cross_join_min_rows_to_compress {#cross_join_min_rows_to_compress} 

Минимальное количество строк для сжатия блока в CROSS JOIN. Нулевое значение означает — отключить этот порог. Этот блок сжимается, когда достигается один из двух порогов (по строкам или по байтам).
## data_type_default_nullable {#data_type_default_nullable} 

Позволяет типам данных без явных модификаторов [NULL или NOT NULL](/sql-reference/statements/create/table#null-or-not-null-modifiers) в определении столбца быть [Nullable](/sql-reference/data-types/nullable).

Возможные значения:

- 1 — Типы данных в определениях столбцов по умолчанию устанавливаются как `Nullable`.
- 0 — Типы данных в определениях столбцов по умолчанию устанавливаются как не `Nullable`.
## database_atomic_wait_for_drop_and_detach_synchronously {#database_atomic_wait_for_drop_and_detach_synchronously} 

Добавляет модификатор `SYNC` ко всем запросам `DROP` и `DETACH`.

Возможные значения:

- 0 — Запросы будут выполняться с задержкой.
- 1 — Запросы будут выполняться без задержки.
## database_replicated_allow_explicit_uuid {#database_replicated_allow_explicit_uuid} 

0 - Не разрешать явно указывать UUID для таблиц в Реплицированных базах данных. 1 - Разрешить. 2 - Разрешить, но игнорировать указанный UUID и вместо этого сгенерировать случайный.
## database_replicated_allow_heavy_create {#database_replicated_allow_heavy_create} 

Разрешает длительные DDL-запросы (CREATE AS SELECT и POPULATE) в движке реплицированной базы данных. Обратите внимание, что это может блокировать очередь DDL на длительное время.
## database_replicated_allow_only_replicated_engine {#database_replicated_allow_only_replicated_engine} 

Разрешает создание только реплицированных таблиц в базе данных с движком Реплицированной.
## database_replicated_allow_replicated_engine_arguments {#database_replicated_allow_replicated_engine_arguments} 

0 - Не разрешать явно указывать путь ZooKeeper и имя реплики для таблиц *MergeTree в Реплицированных базах данных. 1 - Разрешить. 2 - Разрешить, но игнорировать указанный путь и использовать вместо этого значение по умолчанию. 3 - Разрешить и не записывать предупреждение в журнал.
## database_replicated_always_detach_permanently {#database_replicated_always_detach_permanently} 

Исполнять DETACH TABLE как DETACH TABLE PERMANENTLY, если движок базы данных реплицированный.
## database_replicated_enforce_synchronous_settings {#database_replicated_enforce_synchronous_settings} 

Обеспечивает синхронное ожидание для некоторых запросов (см. также database_atomic_wait_for_drop_and_detach_synchronously, mutations_sync, alter_sync). Настройки не рекомендуются для включения.
## database_replicated_initial_query_timeout_sec {#database_replicated_initial_query_timeout_sec} 

Указывает, как долго начальный DDL-запрос должен ждать, пока реплицированная база данных обработает предыдущие записи в очереди DDL в секундах.

Возможные значения:

- Положительное целое число.
- 0 — Безлимитно.
## decimal_check_overflow {#decimal_check_overflow} 

Проверка переполнения арифметических/сравнительных операций с десятичными числами.
## deduplicate_blocks_in_dependent_materialized_views {#deduplicate_blocks_in_dependent_materialized_views} 

Включает или отключает проверку дедупликации для материализованных представлений, которые получают данные из таблиц Replicated*.

Возможные значения:

0 — Отключено.
1 — Включено.

Когда включено, ClickHouse выполняет дедупликацию блоков в материализованных представлениях, которые зависят от таблиц Replicated*. Эта настройка полезна для обеспечения того, чтобы материализованные представления не содержали дублирующих данных, когда операция вставки повторяется из-за сбоя.

**Смотрите также**

- [Обработка NULL в операторах IN](/guides/developer/deduplicating-inserts-on-retries#insert-deduplication-with-materialized-views)
## default_materialized_view_sql_security {#default_materialized_view_sql_security} 

<SettingsInfoBlock type="SQLSecurityType" default_value="DEFINER" />

Позволяет установить значение по умолчанию для опции SQL SECURITY при создании материализованного представления. [Больше о SQL безопасности](../../sql-reference/statements/create/view.md/#sql_security).

Значение по умолчанию — `DEFINER`.
## default_max_bytes_in_join {#default_max_bytes_in_join} 

Максимальный размер правой таблицы, если требуется лимит, но `max_bytes_in_join` не установлен.
## default_normal_view_sql_security {#default_normal_view_sql_security} 

<SettingsInfoBlock type="SQLSecurityType" default_value="INVOKER" />

Позволяет установить опцию `SQL SECURITY` по умолчанию при создании обычного представления. [Больше о SQL безопасности](../../sql-reference/statements/create/view.md/#sql_security).

Значение по умолчанию — `INVOKER`.
## default_table_engine {#default_table_engine} 

<SettingsInfoBlock type="DefaultTableEngine" default_value="MergeTree" />

Движок таблицы по умолчанию для использования, когда `ENGINE` не установлен в операторе `CREATE`.

Возможные значения:

- строка, представляющая любое допустимое имя движка таблицы.

Значение по умолчанию для облака: `SharedMergeTree`.

**Пример**

Запрос:

```sql
SET default_table_engine = 'Log';

SELECT name, value, changed FROM system.settings WHERE name = 'default_table_engine';
```

Результат:

```response
┌─name─────────────────┬─value─┬─changed─┐
│ default_table_engine │ Log   │       1 │
└──────────────────────┴───────┴─────────┘
```

В этом примере любая новая таблица, не указывающая `Engine`, будет использовать движок таблицы `Log`:

Запрос:

```sql
CREATE TABLE my_table (
    x UInt32,
    y UInt32
);

SHOW CREATE TABLE my_table;
```

Результат:

```response
┌─statement────────────────────────────────────────────────────────────────┐
│ CREATE TABLE default.my_table
(
    `x` UInt32,
    `y` UInt32
)
ENGINE = Log
└──────────────────────────────────────────────────────────────────────────┘
```
## default_temporary_table_engine {#default_temporary_table_engine} 

То же самое, что и [default_table_engine](#default_table_engine), но для временных таблиц.

В этом примере любая новая временная таблица, не указывающая `Engine`, будет использовать движок таблицы `Log`:

Запрос:

```sql
SET default_temporary_table_engine = 'Log';

CREATE TEMPORARY TABLE my_table (
    x UInt32,
    y UInt32
);

SHOW CREATE TEMPORARY TABLE my_table;
```

Результат:

```response
┌─statement────────────────────────────────────────────────────────────────┐
│ CREATE TEMPORARY TABLE default.my_table
(
    `x` UInt32,
    `y` UInt32
)
ENGINE = Log
└──────────────────────────────────────────────────────────────────────────┘
```
## default_view_definer {#default_view_definer} 



<SettingsInfoBlock type="String" default_value="CURRENT_USER" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "CURRENT_USER"},{"label": "Allows to set default `DEFINER` option while creating a view"}]}]}/>

Позволяет задать значение по умолчанию для параметра `DEFINER` при создании представления. [Подробнее о безопасности SQL](../../sql-reference/statements/create/view.md/#sql_security).

Значение по умолчанию — `CURRENT_USER`.
## delta_lake_enable_engine_predicate {#delta_lake_enable_engine_predicate} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "1"},{"label": "New setting"}]}]}/>

Включает внутреннюю обрезку данных в delta-kernel.
## delta_lake_enable_expression_visitor_logging {#delta_lake_enable_expression_visitor_logging} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting"}]}]}/>

Включает журналы на уровне тестирования для посетителя выражений DeltaLake. Эти журналы могут быть слишком подробными даже для тестового логирования.
## delta_lake_insert_max_bytes_in_data_file {#delta_lake_insert_max_bytes_in_data_file} 



<SettingsInfoBlock type="NonZeroUInt64" default_value="1073741824" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "1073741824"},{"label": "New setting."}]}]}/>

Определяет предел в байтах для одного вставленного файла данных в delta lake.
## delta_lake_insert_max_rows_in_data_file {#delta_lake_insert_max_rows_in_data_file} 



<SettingsInfoBlock type="NonZeroUInt64" default_value="1000000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "100000"},{"label": "New setting."}]}, {"id": "row-2","items": [{"label": "25.10"},{"label": "1000000"},{"label": "New setting."}]}]}/>

Определяет предел в строках для одного вставленного файла данных в delta lake.
## delta_lake_log_metadata {#delta_lake_log_metadata} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "0"},{"label": "New setting."}]}]}/>

Включает запись метаданных файлов delta lake в системную таблицу.
## delta_lake_snapshot_version {#delta_lake_snapshot_version} 



<SettingsInfoBlock type="Int64" default_value="-1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "-1"},{"label": "New setting"}]}]}/>

Версия снимка delta lake для чтения. Значение -1 означает чтение последней версии (значение 0 является допустимой версией снимка).
## delta_lake_throw_on_engine_predicate_error {#delta_lake_throw_on_engine_predicate_error} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting"}]}]}/>

Включает генерацию исключения, если произошла ошибка при анализе предиката сканирования в delta-kernel.
## describe_compact_output {#describe_compact_output} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если истинно, включает только имена и типы колонок в результат запроса DESCRIBE.
## describe_extend_object_types {#describe_extend_object_types} 



<SettingsInfoBlock type="Bool" default_value="0" />

Выводит конкретный тип колонок типа Object в запросе DESCRIBE.
## describe_include_subcolumns {#describe_include_subcolumns} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает описание подколонок для запроса [DESCRIBE](../../sql-reference/statements/describe-table.md). Например, членов [Tuple](../../sql-reference/data-types/tuple.md) или подколонок типа [Map](/sql-reference/data-types/map#reading-subcolumns-of-map), [Nullable](../../sql-reference/data-types/nullable.md/#finding-null) или [Array](../../sql-reference/data-types/array.md/#array-size).

Возможные значения:

- 0 — Подколонки не включаются в запросы `DESCRIBE`.
- 1 — Подколонки включаются в запросы `DESCRIBE`.

**Пример**

Смотрите пример для оператора [DESCRIBE](../../sql-reference/statements/describe-table.md).
## describe_include_virtual_columns {#describe_include_virtual_columns} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если истинно, виртуальные колонки таблицы будут включены в результат запроса DESCRIBE.
## dialect {#dialect} 



<SettingsInfoBlock type="Dialect" default_value="clickhouse" />

Какой диалект будет использоваться для разбора запроса.
## dictionary_validate_primary_key_type {#dictionary_validate_primary_key_type} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Validate primary key type for dictionaries. By default id type for simple layouts will be implicitly converted to UInt64."}]}]}/>

Проверяет тип первичного ключа для словарей. По умолчанию тип id для простых схем будет неявно преобразован в UInt64.
## distinct_overflow_mode {#distinct_overflow_mode} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает поведение при превышении объема данных одного из пределов.

Возможные значения:
- `throw`: выбросить исключение (значение по умолчанию).
- `break`: прекратить выполнение запроса и вернуть частичный результат, как будто исходные данные закончились.
## distributed_aggregation_memory_efficient {#distributed_aggregation_memory_efficient} 



<SettingsInfoBlock type="Bool" default_value="1" />

Режим экономии памяти для распределенной агрегации включен.
## distributed_background_insert_batch {#distributed_background_insert_batch} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает/выключает отправку вставленных данных пакетами.

Когда отправка пакетами включена, движок таблицы [Distributed](../../engines/table-engines/special/distributed.md) пытается отправить несколько файлов вставленных данных за одну операцию вместо отправки их по отдельности. Пакетная отправка улучшает производительность кластера за счет более эффективного использования ресурсов сервера и сети.

Возможные значения:

- 1 — Включено.
- 0 — Отключено.
## distributed_background_insert_max_sleep_time_ms {#distributed_background_insert_max_sleep_time_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="30000" />

Максимальный интервал для движка таблицы [Distributed](../../engines/table-engines/special/distributed.md) для отправки данных. Ограничивает экспоненциальный рост интервала, установленного в настройке [distributed_background_insert_sleep_time_ms](#distributed_background_insert_sleep_time_ms).

Возможные значения:

- Положительное целое число в миллисекундах.
## distributed_background_insert_sleep_time_ms {#distributed_background_insert_sleep_time_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="100" />

Базовый интервал для движка таблицы [Distributed](../../engines/table-engines/special/distributed.md) для отправки данных. Фактический интервал растет экспоненциально в случае ошибок.

Возможные значения:

- Положительное целое число в миллисекундах.
## distributed_background_insert_split_batch_on_failure {#distributed_background_insert_split_batch_on_failure} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает/выключает разделение пакетов при сбоях.

Иногда отправка определенного пакета на удаленный шар может привести к сбою, из-за некоторого сложного конвейера после этого (например, `MATERIALIZED VIEW` с `GROUP BY`) из-за ошибок, таких как `Memory limit exceeded`. В этом случае повторная попытка не поможет (это приведет к блокировке распределенной отправки для таблицы), но отправка файлов из этого пакета по одному может привести к успешной вставке.

Таким образом, установка этой настройки в `1` отключит пакетирование для таких пакетов (т.е. временно отключит `distributed_background_insert_batch` для неудавшихся пакетов).

Возможные значения:

- 1 — Включено.
- 0 — Отключено.

:::note
Эта настройка также влияет на поврежденные пакеты (которые могут появиться из-за ненормального завершения работы сервера (машины) и отсутствия `fsync_after_insert`/`fsync_directories` для движка таблицы [Distributed](../../engines/table-engines/special/distributed.md)).
:::

:::note
Не следует полагаться на автоматическое разделение пакетов, поскольку это может негативно сказаться на производительности.
:::
## distributed_background_insert_timeout {#distributed_background_insert_timeout} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Таймаут для запроса вставки в распределенную таблицу. Настройка используется только при включенном insert_distributed_sync. Значение ноль означает отсутствие таймаута.
## distributed_cache_alignment {#distributed_cache_alignment} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "0"},{"label": "Rename of distributed_cache_read_alignment"}]}]}/>

Действует только в ClickHouse Cloud. Настройка для тестирования, не изменяйте её.
## distributed_cache_bypass_connection_pool {#distributed_cache_bypass_connection_pool} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Позволяет обойти пул соединений распределенного кэша.
## distributed_cache_connect_backoff_max_ms {#distributed_cache_connect_backoff_max_ms} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="50" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "50"},{"label": "New setting"}]}]}/>

Действует только в ClickHouse Cloud. Максимальное время ожидания в миллисекундах для создания соединения с распределенным кэшем.
## distributed_cache_connect_backoff_min_ms {#distributed_cache_connect_backoff_min_ms} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting"}]}]}/>

Действует только в ClickHouse Cloud. Минимальное время ожидания в миллисекундах для создания соединения с распределенным кэшем.
## distributed_cache_connect_max_tries {#distributed_cache_connect_max_tries} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="5" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "5"},{"label": "Changed setting value"}]}, {"id": "row-2","items": [{"label": "25.1"},{"label": "20"},{"label": "Cloud only"}]}, {"id": "row-3","items": [{"label": "24.10"},{"label": "20"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Количество попыток подключиться к распределенному кэшу в случае неудачи.
## distributed_cache_credentials_refresh_period_seconds {#distributed_cache_credentials_refresh_period_seconds} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="5" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "5"},{"label": "New private setting"}]}]}/>

Действует только в ClickHouse Cloud. Период обновления учетных данных.
## distributed_cache_data_packet_ack_window {#distributed_cache_data_packet_ack_window} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="5" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "5"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Окно отправки ACK для последовательности DataPacket в одном запросе на чтение из распределенного кэша.
## distributed_cache_discard_connection_if_unread_data {#distributed_cache_discard_connection_if_unread_data} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "New setting"}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "1"},{"label": "New setting"}]}]}/>

Действует только в ClickHouse Cloud. Устройства подключения, если некоторые данные не прочитаны.
## distributed_cache_fetch_metrics_only_from_current_az {#distributed_cache_fetch_metrics_only_from_current_az} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Получать метрики только из текущей зоны доступности в system.distributed_cache_metrics, system.distributed_cache_events.
## distributed_cache_log_mode {#distributed_cache_log_mode} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="DistributedCacheLogMode" default_value="on_error" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "on_error"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Режим записи в system.distributed_cache_log.
## distributed_cache_max_unacked_inflight_packets {#distributed_cache_max_unacked_inflight_packets} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="10" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "10"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Максимальное количество неподтвержденных пакетов в одном запросе на чтение из распределенного кэша.
## distributed_cache_min_bytes_for_seek {#distributed_cache_min_bytes_for_seek} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "New private setting."}]}]}/>

Действует только в ClickHouse Cloud. Минимальное количество байт для выполнения поиска в распределенном кэше.
## distributed_cache_pool_behaviour_on_limit {#distributed_cache_pool_behaviour_on_limit} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="DistributedCachePoolBehaviourOnLimit" default_value="wait" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "wait"},{"label": "Cloud only"}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "allocate_bypassing_pool"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Определяет поведение соединения с распределенным кэш-пулом при достижении предела.
## distributed_cache_prefer_bigger_buffer_size {#distributed_cache_prefer_bigger_buffer_size} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "0"},{"label": "New setting."}]}]}/>

Действует только в ClickHouse Cloud. То же самое, что и filesystem_cache_prefer_bigger_buffer_size, но для распределенного кэша.
## distributed_cache_read_only_from_current_az {#distributed_cache_read_only_from_current_az} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "New setting"}]}]}/>

Действует только в ClickHouse Cloud. Позволяет читать только из текущей зоны доступности. Если отключено, будут читать со всех серверов кэша во всех зонах доступности.
## distributed_cache_read_request_max_tries {#distributed_cache_read_request_max_tries} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="10" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "10"},{"label": "Changed setting value"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "20"},{"label": "New setting"}]}]}/>

Действует только в ClickHouse Cloud. Количество попыток выполнить запрос к распределенному кэшу в случае неудачи.
## distributed_cache_receive_response_wait_milliseconds {#distributed_cache_receive_response_wait_milliseconds} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="60000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "60000"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Время ожидания в миллисекундах для получения данных по запросу из распределенного кэша.
## distributed_cache_receive_timeout_milliseconds {#distributed_cache_receive_timeout_milliseconds} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="10000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "10000"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Время ожидания в миллисекундах для получения любого ответа от распределенного кэша.
## distributed_cache_throw_on_error {#distributed_cache_throw_on_error} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Повторно выбрасывает исключение, произошедшее во время общения с распределенным кэшом, или исключение, полученное от распределенного кэша. В противном случае переходит к пропуску распределенного кэша при ошибке.
## distributed_cache_wait_connection_from_pool_milliseconds {#distributed_cache_wait_connection_from_pool_milliseconds} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="100" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "100"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Время ожидания в миллисекундах для получения соединения из пула соединений, если distributed_cache_pool_behaviour_on_limit установлено на ожидание.
## distributed_connections_pool_size {#distributed_connections_pool_size} 



<SettingsInfoBlock type="UInt64" default_value="1024" />

Максимальное количество одновременных подключений к удалённым серверам для распределенной обработки всех запросов к одной таблице Distributed. Рекомендуется устанавливать значение не менее количества серверов в кластере.
## distributed_ddl_entry_format_version {#distributed_ddl_entry_format_version} 



<SettingsInfoBlock type="UInt64" default_value="5" />

Версия совместимости распределенных запросов DDL (ON CLUSTER).
## distributed_ddl_output_mode {#distributed_ddl_output_mode} 



<SettingsInfoBlock type="DistributedDDLOutputMode" default_value="throw" />

Устанавливает формат результата запроса распределенного DDL.

Возможные значения:

- `throw` — Возвращает набор результатов с состоянием выполнения запроса для всех хостов, где запрос завершился. Если запрос завершился с ошибкой на некоторых хостах, то будет повторно выброшено первое исключение. Если запрос еще не завершен на некоторых хостах и время ожидания [distributed_ddl_task_timeout](#distributed_ddl_task_timeout) превышено, то выбрасывается исключение `TIMEOUT_EXCEEDED`.
- `none` — Похоже на throw, но запрос распределенного DDL не возвращает никакого результата.
- `null_status_on_timeout` — Возвращает `NULL` в качестве состояния выполнения в некоторых строках результирующего набора вместо выбрасывания `TIMEOUT_EXCEEDED`, если запрос не завершен на соответствующих хостах.
- `never_throw` — Не выбрасывает `TIMEOUT_EXCEEDED` и не повторно выбрасывает исключения, если запрос завершился с ошибкой на некоторых хостах.
- `none_only_active` - похоже на `none`, но не дожидается неактивных реплик базы данных `Replicated`. Примечание: в этом режиме невозможно определить, что запрос не был выполнен на некоторых репликах и будет выполнен в фоновом режиме.
- `null_status_on_timeout_only_active` — похоже на `null_status_on_timeout`, но не дожидается неактивных реплик базы данных `Replicated`.
- `throw_only_active` — похоже на `throw`, но не дожидается неактивных реплик базы данных `Replicated`.

Значение по умолчанию в облаке: `throw`.
## distributed_ddl_task_timeout {#distributed_ddl_task_timeout} 



<SettingsInfoBlock type="Int64" default_value="180" />

Устанавливает таймаут для ответов на запросы DDL от всех хостов в кластере. Если запрос DDL не был выполнен на всех хостах, ответ будет содержать ошибку таймаута, и запрос будет выполнен в асинхронном режиме. Отрицательное значение означает бесконечный таймаут.

Возможные значения:

- Положительное целое число.
- 0 — Асинхронный режим.
- Отрицательное целое число — бесконечный таймаут.
## distributed_foreground_insert {#distributed_foreground_insert} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает синхронную вставку данных в таблицу [Distributed](/engines/table-engines/special/distributed).

По умолчанию, при вставке данных в таблицу `Distributed`, сервер ClickHouse отправляет данные на узлы кластера в фоновом режиме. Когда `distributed_foreground_insert=1`, данные обрабатываются синхронно, и операция `INSERT` завершается успешно только после того, как все данные сохранены на всех шардах (по крайней мере одна реплика для каждого шарда, если `internal_replication` истинно).

Возможные значения:

- `0` — Данные вставляются в фоновом режиме.
- `1` — Данные вставляются в синхронном режиме.

Значение по умолчанию в облаке: `0`.

**Смотрите также**

- [Двигатель таблицы Distributed](/engines/table-engines/special/distributed)
- [Управление распределенными таблицами](/sql-reference/statements/system#managing-distributed-tables)
## distributed_group_by_no_merge {#distributed_group_by_no_merge} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Не объединять состояния агрегации с разных серверов при распределенной обработке запросов, это можно использовать в случае, если точно известно, что на разных шардах находятся разные ключи.

Возможные значения:

- `0` — Отключено (финальная обработка запроса выполняется на инициаторе).
- `1` - Не объединять состояния агрегации с разных серверов при распределенной обработке запросов (запрос полностью обрабатывается на шарде, инициатор только проксирует данные), может быть использовано, если точно известно, что на разных шардах находятся разные ключи.
- `2` - То же самое, что и `1`, но применяется `ORDER BY` и `LIMIT` (это невозможно, когда запрос полностью обработан на удаленном узле, например, для `distributed_group_by_no_merge=1`) на инициаторе (может быть использовано для запросов с `ORDER BY` и/или `LIMIT`).

**Пример**

```sql
SELECT *
FROM remote('127.0.0.{2,3}', system.one)
GROUP BY dummy
LIMIT 1
SETTINGS distributed_group_by_no_merge = 1
FORMAT PrettyCompactMonoBlock

┌─dummy─┐
│     0 │
│     0 │
└───────┘
```

```sql
SELECT *
FROM remote('127.0.0.{2,3}', system.one)
GROUP BY dummy
LIMIT 1
SETTINGS distributed_group_by_no_merge = 2
FORMAT PrettyCompactMonoBlock

┌─dummy─┐
│     0 │
└───────┘
```
## distributed_insert_skip_read_only_replicas {#distributed_insert_skip_read_only_replicas} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "If true, INSERT into Distributed will skip read-only replicas"}]}]}/>

Включает пропуск чтения только для реплик при INSERT-запросах в Distributed.

Возможные значения:

- 0 — INSERT был выполнен как обычно, если он пройдет на только для чтения реплику, это завершится с ошибкой.
- 1 — Инициатор пропустит реплики только для чтения перед отправкой данных на шарды.
## distributed_plan_default_reader_bucket_count {#distributed_plan_default_reader_bucket_count} 

<ExperimentalBadge/>



<SettingsInfoBlock type="UInt64" default_value="8" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "8"},{"label": "New experimental setting."}]}]}/>

Количество задач по умолчанию для параллельного чтения в распределенном запросе. Задачи распределяются между репликами.
## distributed_plan_default_shuffle_join_bucket_count {#distributed_plan_default_shuffle_join_bucket_count} 

<ExperimentalBadge/>



<SettingsInfoBlock type="UInt64" default_value="8" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "8"},{"label": "New experimental setting."}]}]}/>

Количество ведер по умолчанию для распределенного shuffle-hash-join.
## distributed_plan_execute_locally {#distributed_plan_execute_locally} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "New experimental setting."}]}]}/>

Запустить все задачи плана распределенного запроса локально. Полезно для тестирования и отладки.
## distributed_plan_force_exchange_kind {#distributed_plan_force_exchange_kind} 

<ExperimentalBadge/>



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": ""},{"label": "New experimental setting."}]}]}/>

Принудительно задать определенный тип операций обмена между этапами распределенного запроса.

Возможные значения:

 - '' - не принуждать никакие типы операций обмена, позволить оптимизатору выбирать,
 - 'Persisted' - использовать временные файлы в объектном хранилище,
 - 'Streaming' - обмен данными через сеть.
## distributed_plan_force_shuffle_aggregation {#distributed_plan_force_shuffle_aggregation} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "0"},{"label": "New experimental setting"}]}]}/>

Используйте стратегию агрегирования Shuffle вместо PartialAggregation + Merge в плане распределенного запроса.
## distributed_plan_max_rows_to_broadcast {#distributed_plan_max_rows_to_broadcast} 

<ExperimentalBadge/>



<SettingsInfoBlock type="UInt64" default_value="20000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "20000"},{"label": "New experimental setting."}]}]}/>

Максимальное количество строк для использования широковещательной соединения вместо shuffle join в плане распределенного запроса.
## distributed_plan_optimize_exchanges {#distributed_plan_optimize_exchanges} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "New experimental setting."}]}]}/>

Удаляет ненужные обмены в плане распределенного запроса. Отключите для отладки.
## distributed_product_mode {#distributed_product_mode} 



<SettingsInfoBlock type="DistributedProductMode" default_value="deny" />

Изменяет поведение [распределенных подзапросов](../../sql-reference/operators/in.md).

ClickHouse применяет эту настройку, когда запрос содержит произведение распределенных таблиц, т.е. когда запрос для распределенной таблицы содержит подзапрос, не относящийся к GLOBAL для распределенной таблицы.

Ограничения:

- Применяется только для подзапросов IN и JOIN.
- Только если раздел FROM использует распределенную таблицу, содержащую более одного шарда.
- Если подзапрос касается распределенной таблицы, содержащей более одного шарда.
- Не используется для табличной функции [remote](../../sql-reference/table-functions/remote.md).

Возможные значения:

- `deny` — Значение по умолчанию. Запрещает использование этих типов подзапросов (возвращает исключение "Запрещены вложенные подзапросы IN/JOIN").
- `local` — Заменяет базу данных и таблицу в подзапросе на локальные для целевого сервера (шара), оставляя нормальные `IN`/`JOIN`.
- `global` — Заменяет запрос `IN`/`JOIN` на `GLOBAL IN`/`GLOBAL JOIN`.
- `allow` — Разрешает использование этих типов подзапросов.
## distributed_push_down_limit {#distributed_push_down_limit} 



<SettingsInfoBlock type="UInt64" default_value="1" />

Включает или отключает применение [LIMIT](#limit) на каждом шарде отдельно.

Это позволит избежать:
- Отправки дополнительных строк по сети;
- Обработки строк за пределами лимита инициатором.

Начиная с версии 21.9, вы больше не можете получить неточные результаты, поскольку `distributed_push_down_limit` изменяет выполнение запроса только в случае, если выполнено хотя бы одно из условий:
- [distributed_group_by_no_merge](#distributed_group_by_no_merge) > 0.
- Запрос **не содержит** `GROUP BY`/`DISTINCT`/`LIMIT BY`, но имеет `ORDER BY`/`LIMIT`.
- Запрос **содержит** `GROUP BY`/`DISTINCT`/`LIMIT BY` с `ORDER BY`/`LIMIT` и:
    - [optimize_skip_unused_shards](#optimize_skip_unused_shards) включен.
    - [optimize_distributed_group_by_sharding_key](#optimize_distributed_group_by_sharding_key) включен.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

Смотрите также:

- [distributed_group_by_no_merge](#distributed_group_by_no_merge)
- [optimize_skip_unused_shards](#optimize_skip_unused_shards)
- [optimize_distributed_group_by_sharding_key](#optimize_distributed_group_by_sharding_key)
## distributed_replica_error_cap {#distributed_replica_error_cap} 



<SettingsInfoBlock type="UInt64" default_value="1000" />

- Тип: без знака целое
- Значение по умолчанию: 1000

Количество ошибок каждой реплики ограничено этим значением, предотвращая накопление слишком большого количества ошибок в одной реплике.

Смотрите также:

- [load_balancing](#load_balancing-round_robin)
- [Двигатель таблицы Distributed](../../engines/table-engines/special/distributed.md)
- [distributed_replica_error_half_life](#distributed_replica_error_half_life)
- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)
## distributed_replica_error_half_life {#distributed_replica_error_half_life} 



<SettingsInfoBlock type="Seconds" default_value="60" />

- Тип: секунды
- Значение по умолчанию: 60 секунд

Контролирует скорость обнуления ошибок в распределенных таблицах. Если реплика недоступна в течение некоторого времени, накапливается 5 ошибок, а `distributed_replica_error_half_life` установлен на 1 секунду, тогда реплика считается нормальной через 3 секунды после последней ошибки.

Смотрите также:

- [load_balancing](#load_balancing-round_robin)
- [Двигатель таблицы Distributed](../../engines/table-engines/special/distributed.md)
- [distributed_replica_error_cap](#distributed_replica_error_cap)
- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)
## distributed_replica_max_ignored_errors {#distributed_replica_max_ignored_errors} 



<SettingsInfoBlock type="UInt64" default_value="0" />

- Тип: без знака целое
- Значение по умолчанию: 0

Количество ошибок, которые будут игнорироваться при выборе реплик (в соответствии с алгоритмом `load_balancing`).

Смотрите также:

- [load_balancing](#load_balancing-round_robin)
- [Двигатель таблицы Distributed](../../engines/table-engines/special/distributed.md)
- [distributed_replica_error_cap](#distributed_replica_error_cap)
- [distributed_replica_error_half_life](#distributed_replica_error_half_life)
## do_not_merge_across_partitions_select_final {#do_not_merge_across_partitions_select_final} 



<SettingsInfoBlock type="Bool" default_value="0" />

Объединять части только в одной партиции в select final.
## empty_result_for_aggregation_by_constant_keys_on_empty_set {#empty_result_for_aggregation_by_constant_keys_on_empty_set} 



<SettingsInfoBlock type="Bool" default_value="1" />

Возвращает пустой результат при агрегации по постоянным ключам на пустом наборе.
## empty_result_for_aggregation_by_empty_set {#empty_result_for_aggregation_by_empty_set} 



<SettingsInfoBlock type="Bool" default_value="0" />

Возвращает пустой результат при агрегации без ключей на пустом наборе.
## enable_adaptive_memory_spill_scheduler {#enable_adaptive_memory_spill_scheduler} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "0"},{"label": "New setting. Enable spill memory data into external storage adaptively."}]}]}/>

Включает процессор-распределитель для адаптивного слива данных во внешнее хранилище. В настоящее время поддерживается grace join.
## enable_add_distinct_to_in_subqueries {#enable_add_distinct_to_in_subqueries} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting to reduce the size of temporary tables transferred for distributed IN subqueries."}]}]}/>

Включает `DISTINCT` в подзапросах `IN`. Это компромиссная настройка: её включение может значительно уменьшить размер временных таблиц, передаваемых для распределенных подзапросов IN, и значительно ускорить передачу данных между шардами, обеспечивая, чтобы отправлялись только уникальные значения. Однако включение этой настройки добавляет дополнительные затраты на объединение на каждом узле, поскольку необходимо выполнять дедупликацию (DISTINCT). Используйте эту настройку, когда передача данных по сети является узким местом, и дополнительные затраты на объединение приемлемы.
## enable_blob_storage_log {#enable_blob_storage_log} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Write information about blob storage operations to system.blob_storage_log table"}]}]}/>

Записывает информацию о операциях с blob-хранилищем в таблицу system.blob_storage_log.
## enable_deflate_qpl_codec {#enable_deflate_qpl_codec} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, можно использовать кодек DEFLATE_QPL для сжатия колонок.
## enable_early_constant_folding {#enable_early_constant_folding} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию запроса, при которой мы анализируем функции и результаты подзапросов и переписываем запрос, если там есть константы.
## enable_extended_results_for_datetime_functions {#enable_extended_results_for_datetime_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает возврат результатов типа `Date32` с расширенным диапазоном (по сравнению с типом `Date`) или `DateTime64` с расширенным диапазоном (по сравнению с типом `DateTime`).

Возможные значения:

- `0` — Функции возвращают `Date` или `DateTime` для всех типов аргументов.
- `1` — Функции возвращают `Date32` или `DateTime64` для аргументов `Date32` или `DateTime64`, а для остальных — `Date` или `DateTime`.

Ниже представлена таблица, показывающая поведение этой настройки для различных функций даты и времени.

| Функция | `enable_extended_results_for_datetime_functions = 0` | `enable_extended_results_for_datetime_functions = 1` |
|----------|---------------------------------------------------|---------------------------------------------------|
| `toStartOfYear` | Возвращает `Date` или `DateTime` | Возвращает `Date`/`DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `Date32`/`DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfISOYear` | Возвращает `Date` или `DateTime` | Возвращает `Date`/`DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `Date32`/`DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfQuarter` | Возвращает `Date` или `DateTime` | Возвращает `Date`/`DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `Date32`/`DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfMonth` | Возвращает `Date` или `DateTime` | Возвращает `Date`/`DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `Date32`/`DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfWeek` | Возвращает `Date` или `DateTime` | Возвращает `Date`/`DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `Date32`/`DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toLastDayOfWeek` | Возвращает `Date` или `DateTime` | Возвращает `Date`/`DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `Date32`/`DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toLastDayOfMonth` | Возвращает `Date` или `DateTime` | Возвращает `Date`/`DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `Date32`/`DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toMonday` | Возвращает `Date` или `DateTime` | Возвращает `Date`/`DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `Date32`/`DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfDay` | Возвращает `DateTime`<br/>*Примечание: Неправильные результаты для значений вне диапазона 1970-2149* | Возвращает `DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfHour` | Возвращает `DateTime`<br/>*Примечание: Неправильные результаты для значений вне диапазона 1970-2149* | Возвращает `DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfFifteenMinutes` | Возвращает `DateTime`<br/>*Примечание: Неправильные результаты для значений вне диапазона 1970-2149* | Возвращает `DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfTenMinutes` | Возвращает `DateTime`<br/>*Примечание: Неправильные результаты для значений вне диапазона 1970-2149* | Возвращает `DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfFiveMinutes` | Возвращает `DateTime`<br/>*Примечание: Неправильные результаты для значений вне диапазона 1970-2149* | Возвращает `DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `toStartOfMinute` | Возвращает `DateTime`<br/>*Примечание: Неправильные результаты для значений вне диапазона 1970-2149* | Возвращает `DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `DateTime64` для входных данных типа `Date32`/`DateTime64` |
| `timeSlot` | Возвращает `DateTime`<br/>*Примечание: Неправильные результаты для значений вне диапазона 1970-2149* | Возвращает `DateTime` для входных данных типа `Date`/`DateTime`<br/>Возвращает `DateTime64` для входных данных типа `Date32`/`DateTime64` |
## enable_filesystem_cache {#enable_filesystem_cache} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кэш для удаленной файловой системы. Эта настройка не включает/не отключает кэш для дисков (это должно быть сделано через конфигурацию диска), но позволяет обойти кэш для некоторых запросов при необходимости.
## enable_filesystem_cache_log {#enable_filesystem_cache_log} 



<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет записывать журнал кэширования файловой системы для каждого запроса.
## enable_filesystem_cache_on_write_operations {#enable_filesystem_cache_on_write_operations} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает кэш `write-through`. Если установлено на `false`, кэш `write-through` отключается для операций записи. Если установлено на `true`, кэш `write-through` включается, пока `cache_on_write_operations` включен в разделе конфигурации диска сервера.
Смотрите ["Использование локального кэша"](/operations/storing-data#using-local-cache) для получения более подробной информации.
## enable_filesystem_read_prefetches_log {#enable_filesystem_read_prefetches_log} 



<SettingsInfoBlock type="Bool" default_value="0" />

Записывать в system.filesystem prefetch_log во время выполнения запроса. Должен использоваться только для тестирования или отладки, не рекомендуется включать по умолчанию.
## enable_global_with_statement {#enable_global_with_statement} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.2"},{"label": "1"},{"label": "Propagate WITH statements to UNION queries and all subqueries by default"}]}]}/>

Распространять операторы WITH на запросы UNION и все подзапросы.
## enable_hdfs_pread {#enable_hdfs_pread} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "New setting."}]}]}/>

Включает или отключает pread для файлов HDFS. По умолчанию используется `hdfsPread`. Если отключено, для чтения файлов hdfs будут использоваться `hdfsRead` и `hdfsSeek`.
## enable_http_compression {#enable_http_compression} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает сжатие данных в ответ на HTTP-запрос.

Для получения дополнительной информации читайте [описание HTTP интерфейса](../../interfaces/http.md).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
## enable_job_stack_trace {#enable_job_stack_trace} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "0"},{"label": "The setting was disabled by default to avoid performance overhead."}]}, {"id": "row-2","items": [{"label": "24.11"},{"label": "0"},{"label": "Enables collecting stack traces from job's scheduling. Disabled by default to avoid performance overhead."}]}]}/>

Выводить трассировку стека создателя задания, когда задание завершается с исключением. По умолчанию отключено, чтобы избежать снижения производительности.
## enable_join_runtime_filters {#enable_join_runtime_filters} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "0"},{"label": "New setting"}]}]}/>

Фильтровать левую сторону по набору ключей JOIN, собранных с правой стороны во время выполнения.
## enable_lightweight_delete {#enable_lightweight_delete} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включить легковесные мутации удаления для таблиц мердж-дерева.
## enable_lightweight_update {#enable_lightweight_update} 

<BetaBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "1"},{"label": "Lightweight updates were moved to Beta. Added an alias for setting 'allow_experimental_lightweight_update'."}]}]}/>

    Позволяет использовать легковесные обновления.
## enable_memory_bound_merging_of_aggregation_results {#enable_memory_bound_merging_of_aggregation_results} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включить стратегию слияния с ограничением по памяти для агрегации.
## enable_multiple_prewhere_read_steps {#enable_multiple_prewhere_read_steps} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переместить больше условий из WHERE в PREWHERE и выполнять чтение с диска и фильтрацию в несколько этапов, если есть несколько условий, комбинированных с AND.
## enable_named_columns_in_function_tuple {#enable_named_columns_in_function_tuple} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Generate named tuples in function tuple() when all names are unique and can be treated as unquoted identifiers."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "0"},{"label": "Disabled pending usability improvements"}]}]}/>

Сгенерировать именованные кортежи в функции tuple(), когда все имена уникальны и могут быть обработаны как не экранированные идентификаторы.
## enable_optimize_predicate_expression {#enable_optimize_predicate_expression} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "18.12.17"},{"label": "1"},{"label": "Optimize predicates to subqueries by default"}]}]}/>

Включает оптимизацию понижения предиката в запросах `SELECT`.

Оптимизация предиката может существенно уменьшить сетевой трафик для распределенных запросов.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

Использование

Рассмотрим следующие запросы:

1.  `SELECT count() FROM test_table WHERE date = '2018-10-10'`
2.  `SELECT count() FROM (SELECT * FROM test_table) WHERE date = '2018-10-10'`

Если `enable_optimize_predicate_expression = 1`, то время выполнения этих запросов равно, потому что ClickHouse применяет `WHERE` к подзапросу при его обработке.

Если `enable_optimize_predicate_expression = 0`, то время выполнения второго запроса значительно больше, потому что условие `WHERE` применяется ко всем данным после завершения подзапроса.
## enable_optimize_predicate_expression_to_final_subquery {#enable_optimize_predicate_expression_to_final_subquery} 

<SettingsInfoBlock type="Bool" default_value="1" />

Позволяет сдвиг предиката в финальный подзапрос.
## enable_order_by_all {#enable_order_by_all} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает сортировку с синтаксисом `ORDER BY ALL`, см. [ORDER BY](../../sql-reference/statements/select/order-by.md).

Возможные значения:

- 0 — Отключить ORDER BY ALL.
- 1 — Включить ORDER BY ALL.

**Пример**

Запрос:

```sql
CREATE TABLE TAB(C1 Int, C2 Int, ALL Int) ENGINE=Memory();

INSERT INTO TAB VALUES (10, 20, 30), (20, 20, 10), (30, 10, 20);

SELECT * FROM TAB ORDER BY ALL; -- returns an error that ALL is ambiguous

SELECT * FROM TAB ORDER BY ALL SETTINGS enable_order_by_all = 0;
```

Результат:

```text
┌─C1─┬─C2─┬─ALL─┐
│ 20 │ 20 │  10 │
│ 30 │ 10 │  20 │
│ 10 │ 20 │  30 │
└────┴────┴─────┘
```
## enable_parallel_blocks_marshalling {#enable_parallel_blocks_marshalling} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "true"},{"label": "A new setting"}]}]}/>

Касается только распределенных запросов. Если включено, блоки будут (де)сериализованы и (де)сжаты на потоках конвейера (т.е. с более высоким параллелизмом, чем это предусмотрено по умолчанию) до/после отправки инициатору.
## enable_parsing_to_custom_serialization {#enable_parsing_to_custom_serialization} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1"},{"label": "New setting"}]}]}/>

Если установлено в true, данные могут быть разобраны непосредственно в колонки с пользовательской сериализацией (например, Sparse) в соответствии с подсказками для сериализации, полученными из таблицы.
## enable_positional_arguments {#enable_positional_arguments} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.7"},{"label": "1"},{"label": "Enable positional arguments feature by default"}]}]}/>

Включает или отключает поддержку позиционных аргументов для операторов [GROUP BY](/sql-reference/statements/select/group-by), [LIMIT BY](../../sql-reference/statements/select/limit-by.md), [ORDER BY](../../sql-reference/statements/select/order-by.md).

Возможные значения:

- 0 — Позиционные аргументы не поддерживаются.
- 1 — Позиционные аргументы поддерживаются: номера колонок можно использовать вместо имен колонок.

**Пример**

Запрос:

```sql
CREATE TABLE positional_arguments(one Int, two Int, three Int) ENGINE=Memory();

INSERT INTO positional_arguments VALUES (10, 20, 30), (20, 20, 10), (30, 10, 20);

SELECT * FROM positional_arguments ORDER BY 2,3;
```

Результат:

```text
┌─one─┬─two─┬─three─┐
│  30 │  10 │   20  │
│  20 │  20 │   10  │
│  10 │  20 │   30  │
└─────┴─────┴───────┘
```
## enable_producing_buckets_out_of_order_in_aggregation {#enable_producing_buckets_out_of_order_in_aggregation} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "1"},{"label": "New setting"}]}]}/>

Позволяет агрегации с экономией памяти (см. `distributed_aggregation_memory_efficient`) производить ведра вне порядка.
Это может улучшить производительность, когда размеры ведер агрегации искажены, позволив реплике отправлять ведра с более высокими ID инициатору, пока она все еще обрабатывает более тяжелые ведра с более низкими ID.
Недостатком может быть потенциально большее использование памяти.
## enable_reads_from_query_cache {#enable_reads_from_query_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если включено, результаты запросов `SELECT` извлекаются из [кэша запросов](../query-cache.md).

Возможные значения:

- 0 - Отключено
- 1 - Включено
## enable_s3_requests_logging {#enable_s3_requests_logging} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включить очень явное логирование запросов S3. Имеет смысл только для отладки.
## enable_scalar_subquery_optimization {#enable_scalar_subquery_optimization} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "19.18"},{"label": "1"},{"label": "Prevent scalar subqueries from (de)serializing large scalar values and possibly avoid running the same subquery more than once"}]}]}/>

Если установлено в true, предотвращает (де)сериализацию больших скалярных значений для скалярных подзапросов и, возможно, избегает выполнения одного и того же подзапроса более одного раза.
## enable_scopes_for_with_statement {#enable_scopes_for_with_statement} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "1"},{"label": "New setting for backward compatibility with the old analyzer."}]}, {"id": "row-2","items": [{"label": "25.6"},{"label": "1"},{"label": "New setting for backward compatibility with the old analyzer."}]}, {"id": "row-3","items": [{"label": "25.5"},{"label": "1"},{"label": "New setting for backward compatibility with the old analyzer."}]}, {"id": "row-4","items": [{"label": "25.4"},{"label": "1"},{"label": "New setting for backward compatibility with the old analyzer."}]}]}/>

Если отключено, декларации в родительских клаузах WITH будут работать в той же области видимости, в которой они были объявлены в текущей области видимости.

Обратите внимание, что это настройка совместимости для нового анализатора, чтобы позволить выполнять некоторые некорректные запросы, которые мог выполнять старый анализатор.
## enable_shared_storage_snapshot_in_query {#enable_shared_storage_snapshot_in_query} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "0"},{"label": "A new setting to share storage snapshot in query"}]}]}/>

Если включено, все подзапросы в рамках одного запроса будут использовать одно и то же представление StorageSnapshot для каждой таблицы.
Это обеспечивает согласованный взгляд на данные во всем запросе, даже если одна и та же таблица обращается несколько раз.

Это необходимо для запросов, где внутреннее согласование данных частей важно. Пример:

```sql
SELECT
    count()
FROM events
WHERE (_part, _part_offset) IN (
    SELECT _part, _part_offset
    FROM events
    WHERE user_id = 42
)
```

Без этой настройки внешние и внутренние запросы могут работать с разными снимками данных, что приведет к неправильным результатам.

:::note
Включение этой настройки отключает оптимизацию, которая удаляет ненужные части данных из снимков после завершения стадии планирования.
В результате долго выполняющиеся запросы могут удерживать устаревшие части на протяжении всего их выполнения, что задерживает очистку частей и увеличивает нагрузку на хранение.

Эта настройка в настоящее время применяется только к таблицам из семейства MergeTree.
:::

Возможные значения:

- 0 - Отключено
- 1 - Включено
## enable_sharing_sets_for_mutations {#enable_sharing_sets_for_mutations} 

<SettingsInfoBlock type="Bool" default_value="1" />

Разрешает совместное использование объектов наборов, создаваемых для подзапросов IN, между различными задачами одной мутации. Это уменьшает использование памяти и потребление CPU.
## enable_software_prefetch_in_aggregation {#enable_software_prefetch_in_aggregation} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включить использование программного предварительного извлечения в агрегации.
## enable_unaligned_array_join {#enable_unaligned_array_join} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет ARRAY JOIN с несколькими массивами, которые имеют разные размеры. Когда эта настройка включена, массивы будут изменены в размер к самому длинному.
## enable_url_encoding {#enable_url_encoding} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Changed existing setting's default value"}]}]}/>

Позволяет включать/выключать декодирование/кодирование пути в uri в таблицах с движком [URL](../../engines/table-engines/special/url.md).

Отключено по умолчанию.
## enable_vertical_final {#enable_vertical_final} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Enable vertical final by default again after fixing bug"}]}, {"id": "row-2","items": [{"label": "24.1"},{"label": "1"},{"label": "Use vertical final by default"}]}]}/>

Если включено, удалить дублирующиеся строки во время FINаL, помечая строки как удаленные и фильтруя их позже вместо слияния строк.
## enable_writes_to_query_cache {#enable_writes_to_query_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если включено, результаты запросов `SELECT` сохраняются в [кэше запросов](../query-cache.md).

Возможные значения:

- 0 - Отключено
- 1 - Включено
## enable_zstd_qat_codec {#enable_zstd_qat_codec} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Add new ZSTD_QAT codec"}]}]}/>

Если включено, кодек ZSTD_QAT может использоваться для сжатия колонок.
## enforce_strict_identifier_format {#enforce_strict_identifier_format} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "New setting."}]}]}/>

Если включено, допускаются только идентификаторы, содержащие буквы и цифры, а также символы подчеркивания.
## engine_file_allow_create_multiple_files {#engine_file_allow_create_multiple_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает создание нового файла при каждой вставке в таблицах движка файла, если формат имеет суффикс (`JSON`, `ORC`, `Parquet` и т.д.). Если включено, при каждой вставке будет создаваться новый файл с именем, следуя этому образцу:

`data.Parquet` -> `data.1.Parquet` -> `data.2.Parquet` и т.д.

Возможные значения:
- 0 — Запрос `INSERT` добавляет новые данные в конец файла.
- 1 — Запрос `INSERT` создаёт новый файл.
## engine_file_empty_if_not_exists {#engine_file_empty_if_not_exists} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает выбор данных из таблицы движка файла без файла.

Возможные значения:
- 0 — `SELECT` вызывает исключение.
- 1 — `SELECT` возвращает пустой результат.
## engine_file_skip_empty_files {#engine_file_skip_empty_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает пропуск пустых файлов в таблицах с движком [File](../../engines/table-engines/special/file.md).

Возможные значения:
- 0 — `SELECT` вызывает исключение, если пустой файл не совместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.
## engine_file_truncate_on_insert {#engine_file_truncate_on_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает обрезку перед вставкой в таблицах с движком [File](../../engines/table-engines/special/file.md).

Возможные значения:
- 0 — Запрос `INSERT` добавляет новые данные в конец файла.
- 1 — Запрос `INSERT` заменяет существующее содержимое файла новыми данными.
## engine_url_skip_empty_files {#engine_url_skip_empty_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает пропуск пустых файлов в таблицах с движком [URL](../../engines/table-engines/special/url.md).

Возможные значения:
- 0 — `SELECT` вызывает исключение, если пустой файл не совместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.
## except_default_mode {#except_default_mode} 

<SettingsInfoBlock type="SetOperationMode" default_value="ALL" />

Установить режим по умолчанию в запросе EXCEPT. Возможные значения: пустая строка, 'ALL', 'DISTINCT'. Если пусто, запрос без режима вызовет исключение.
## exclude_materialize_skip_indexes_on_insert {#exclude_materialize_skip_indexes_on_insert} 

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": ""},{"label": "New setting."}]}]}/>

Исключает указанные индексы пропуска из построения и хранения во время вставок. Исключенные индексы пропуска по-прежнему будут строиться и храниться [во время слияний](merge-tree-settings.md/#materialize_skip_indexes_on_merge) или явным
[ЗАКРЫТИЕМ ИНДЕКСА](/sql-reference/statements/alter/skipping-index.md/#materialize-index) запросом.

Не имеет эффекта, если [materialize_skip_indexes_on_insert](#materialize_skip_indexes_on_insert) ложный.

Пример:

```sql
CREATE TABLE tab
(
    a UInt64,
    b UInt64,
    INDEX idx_a a TYPE minmax,
    INDEX idx_b b TYPE set(3)
)
ENGINE = MergeTree ORDER BY tuple();

SET exclude_materialize_skip_indexes_on_insert='idx_a'; -- idx_a will be not be updated upon insert
--SET exclude_materialize_skip_indexes_on_insert='idx_a, idx_b'; -- neither index would be updated on insert

INSERT INTO tab SELECT number, number / 50 FROM numbers(100); -- only idx_b is updated

-- since it is a session setting it can be set on a per-query level
INSERT INTO tab SELECT number, number / 50 FROM numbers(100, 100) SETTINGS exclude_materialize_skip_indexes_on_insert='idx_b';

ALTER TABLE tab MATERIALIZE INDEX idx_a; -- this query can be used to explicitly materialize the index

SET exclude_materialize_skip_indexes_on_insert = DEFAULT; -- reset setting to default
```
## execute_exists_as_scalar_subquery {#execute_exists_as_scalar_subquery} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "1"},{"label": "New setting"}]}]}/>

Выполнять некоррелируемые подзапросы EXISTS как скалярные подзапросы. Как и для скалярных подзапросов, используется кэш, и к результату применяется константная свертка.
## external_storage_connect_timeout_sec {#external_storage_connect_timeout_sec} 

<SettingsInfoBlock type="UInt64" default_value="10" />

Тайм-аут подключения в секундах. В настоящее время поддерживается только для MySQL.
## external_storage_max_read_bytes {#external_storage_max_read_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничение на максимальное количество байт, когда таблица с внешним движком должна сбросить исторические данные. В настоящее время поддерживается только для движка таблиц MySQL, движка базы данных и словаря. Если равно 0, эта настройка отключена.
## external_storage_max_read_rows {#external_storage_max_read_rows} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничение на максимальное количество строк, когда таблица с внешним движком должна сбросить исторические данные. В настоящее время поддерживается только для движка таблиц MySQL, движка базы данных и словаря. Если равно 0, эта настройка отключена.
## external_storage_rw_timeout_sec {#external_storage_rw_timeout_sec} 

<SettingsInfoBlock type="UInt64" default_value="300" />

Тайм-аут чтения/записи в секундах. В настоящее время поддерживается только для MySQL.
## external_table_functions_use_nulls {#external_table_functions_use_nulls} 

<SettingsInfoBlock type="Bool" default_value="1" />

Определяет, как таблицы функций [mysql](../../sql-reference/table-functions/mysql.md), [postgresql](../../sql-reference/table-functions/postgresql.md) и [odbc](../../sql-reference/table-functions/odbc.md) используют Nullable колонки.

Возможные значения:

- 0 — Табличная функция явно использует Nullable колонки.
- 1 — Табличная функция неявно использует Nullable колонки.

**Использование**

Если настройка установлена в `0`, табличная функция не создает Nullable колонки и вставляет значения по умолчанию вместо NULL. Это также относится к значениям NULL внутри массивов.
## external_table_strict_query {#external_table_strict_query} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если установлено в true, запрещается преобразование выражения в локальный фильтр для запросов к внешним таблицам.
## extract_key_value_pairs_max_pairs_per_row {#extract_key_value_pairs_max_pairs_per_row} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "0"},{"label": "Max number of pairs that can be produced by the `extractKeyValuePairs` function. Used as a safeguard against consuming too much memory."}]}]}/>

Максимальное количество пар, которые могут быть произведены функцией `extractKeyValuePairs`. Используется как предохранитель против чрезмерного использования памяти.
## extremes {#extremes} 

<SettingsInfoBlock type="Bool" default_value="0" />

Определяет, следует ли считать экстремальные значения (минимумы и максимумы в колонках результата запроса). Принимает 0 или 1. По умолчанию 0 (отключено).
Для получения дополнительной информации см. раздел "Экстремальные значения".
## fallback_to_stale_replicas_for_distributed_queries {#fallback_to_stale_replicas_for_distributed_queries} 

<SettingsInfoBlock type="Bool" default_value="1" />

Принуждает запрос к устаревшей реплике, если обновленные данные недоступны. См. [Репликация](../../engines/table-engines/mergetree-family/replication.md).

ClickHouse выбирает наиболее актуальную из устаревших реплик таблицы.

Используется при выполнении `SELECT` из распределенной таблицы, указывающей на реплицируемые таблицы.

По умолчанию 1 (включено).
## filesystem_cache_boundary_alignment {#filesystem_cache_boundary_alignment} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "New setting"}]}]}/>

Выравнивание границы кэша файловой системы. Эта настройка применяется только к чтению без диска (например, для кэша удаленных движков таблиц / табличных функций, но не для конфигурации хранения таблиц MergeTree). Значение 0 означает отсутствие выравнивания.
## filesystem_cache_enable_background_download_during_fetch {#filesystem_cache_enable_background_download_during_fetch} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "New setting"}]}]}/>

Имеет эффект только в ClickHouse Cloud. Время ожидания для блокировки кэша для резервирования места в кэше файловой системы.
## filesystem_cache_enable_background_download_for_metadata_files_in_packed_storage {#filesystem_cache_enable_background_download_for_metadata_files_in_packed_storage} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "New setting"}]}]}/>

Имеет эффект только в ClickHouse Cloud. Время ожидания для блокировки кэша для резервирования места в кэше файловой системы.
## filesystem_cache_max_download_size {#filesystem_cache_max_download_size} 

<SettingsInfoBlock type="UInt64" default_value="137438953472" />

Максимальный размер удаленного кэша файловой системы, который можно загрузить одним запросом.
## filesystem_cache_name {#filesystem_cache_name} 

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": ""},{"label": "Filesystem cache name to use for stateless table engines or data lakes"}]}]}/>

Имя кэша файловой системы для использования в безгосударственных движках таблиц или ДатаЛэйках.
## filesystem_cache_prefer_bigger_buffer_size {#filesystem_cache_prefer_bigger_buffer_size} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "New setting"}]}]}/>

Предпочитать больший размер буфера, если кэш файловой системы включен, чтобы избежать записи маленьких сегментов файлов, что ухудшает производительность кэша. С другой стороны, включение этой настройки может увеличить использование памяти.
## filesystem_cache_reserve_space_wait_lock_timeout_milliseconds {#filesystem_cache_reserve_space_wait_lock_timeout_milliseconds} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Время ожидания для блокировки кэша для резервирования места в кэше файловой системы.
## filesystem_cache_segments_batch_size {#filesystem_cache_segments_batch_size} 

<SettingsInfoBlock type="UInt64" default_value="20" />

Ограничение на размер одной партии сегментов файлов, которые буфер для чтения может запрашивать из кэша. Слишком низкое значение приведет к чрезмерным запросам к кэшу, слишком большое может замедлить вытеснение из кэша.
## filesystem_cache_skip_download_if_exceeds_per_query_cache_write_limit {#filesystem_cache_skip_download_if_exceeds_per_query_cache_write_limit} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Rename of setting skip_download_if_exceeds_query_cache_limit"}]}]}/>

Пропустить загрузку из удаленной файловой системы, если превышает размер кэша запросов.
## filesystem_prefetch_max_memory_usage {#filesystem_prefetch_max_memory_usage} 

<SettingsInfoBlock type="NonZeroUInt64" default_value="1073741824" />

Максимальное использование памяти для предварительных извлечений.
## filesystem_prefetch_step_bytes {#filesystem_prefetch_step_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Шаг предварительного извлечения в байтах. Ноль означает `auto` - приблизительно лучший шаг предварительного извлечения будет автоматически определен, но может не быть на 100% оптимальным. Фактическое значение может отличаться из-за настройки filesystem_prefetch_min_bytes_for_single_read_task.
## filesystem_prefetch_step_marks {#filesystem_prefetch_step_marks} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Шаг предварительного извлечения в метках. Ноль означает `auto` - приблизительно лучший шаг предварительного извлечения будет автоматически определен, но может не быть на 100% оптимальным. Фактическое значение может отличаться из-за настройки filesystem_prefetch_min_bytes_for_single_read_task.
## filesystem_prefetches_limit {#filesystem_prefetches_limit} 

<SettingsInfoBlock type="UInt64" default_value="200" />

Максимальное количество предварительных извлечений. Ноль означает неограниченное. Рекомендуется использовать настройку `filesystem_prefetches_max_memory_usage`, если вы хотите ограничить количество предварительных извлечений.
## final {#final} 

<SettingsInfoBlock type="Bool" default_value="0" />

Автоматически применяет модификатор [FINAL](../../sql-reference/statements/select/from.md/#final-modifier) ко всем таблицам в запросе, к таблицам, где [FINAL](../../sql-reference/statements/select/from.md/#final-modifier) применим, включая объединенные таблицы и таблицы в подзапросах, а также распределенные таблицы.

Возможные значения:

- 0 - отключено
- 1 - включено

Пример:

```sql
CREATE TABLE test
(
    key Int64,
    some String
)
ENGINE = ReplacingMergeTree
ORDER BY key;

INSERT INTO test FORMAT Values (1, 'first');
INSERT INTO test FORMAT Values (1, 'second');

SELECT * FROM test;
┌─key─┬─some───┐
│   1 │ second │
└─────┴────────┘
┌─key─┬─some──┐
│   1 │ first │
└─────┴───────┘

SELECT * FROM test SETTINGS final = 1;
┌─key─┬─some───┐
│   1 │ second │
└─────┴────────┘

SET final = 1;
SELECT * FROM test;
┌─key─┬─some───┐
│   1 │ second │
└─────┴────────┘
```
## flatten_nested {#flatten_nested} 

<SettingsInfoBlock type="Bool" default_value="1" />

Устанавливает формат данных для [вложенных](../../sql-reference/data-types/nested-data-structures/index.md) колонок.

Возможные значения:

- 1 — Вложенная колонка преобразуется в отдельные массивы.
- 0 — Вложенная колонка остается одним массивом кортежей.

**Использование**

Если настройка установлена в `0`, можно использовать произвольный уровень вложенности.

**Примеры**

Запрос:

```sql
SET flatten_nested = 1;
CREATE TABLE t_nest (`n` Nested(a UInt32, b UInt32)) ENGINE = MergeTree ORDER BY tuple();

SHOW CREATE TABLE t_nest;
```

Результат:

```text
┌─statement───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ CREATE TABLE default.t_nest
(
    `n.a` Array(UInt32),
    `n.b` Array(UInt32)
)
ENGINE = MergeTree
ORDER BY tuple()
SETTINGS index_granularity = 8192 │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

Запрос:

```sql
SET flatten_nested = 0;

CREATE TABLE t_nest (`n` Nested(a UInt32, b UInt32)) ENGINE = MergeTree ORDER BY tuple();

SHOW CREATE TABLE t_nest;
```

Результат:

```text
┌─statement──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ CREATE TABLE default.t_nest
(
    `n` Nested(a UInt32, b UInt32)
)
ENGINE = MergeTree
ORDER BY tuple()
SETTINGS index_granularity = 8192 │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```
## force_aggregate_partitions_independently {#force_aggregate_partitions_independently} 

<SettingsInfoBlock type="Bool" default_value="0" />

Принудительно использовать оптимизацию, когда это применимо, но эвристика решила ее не использовать.
## force_aggregation_in_order {#force_aggregation_in_order} 

<SettingsInfoBlock type="Bool" default_value="0" />

Эта настройка используется самим сервером для поддержки распределенных запросов. Не изменяйте ее вручную, так как это нарушит нормальную работу. (Принуждает использовать агрегацию в порядке на удаленных узлах во время распределенной агрегации).
## force_data_skipping_indices {#force_data_skipping_indices} 

Отключает выполнение запроса, если переданные индексы пропуска данных не были использованы.

Рассмотрим следующий пример:

```sql
CREATE TABLE data
(
    key Int,
    d1 Int,
    d1_null Nullable(Int),
    INDEX d1_idx d1 TYPE minmax GRANULARITY 1,
    INDEX d1_null_idx assumeNotNull(d1_null) TYPE minmax GRANULARITY 1
)
Engine=MergeTree()
ORDER BY key;

SELECT * FROM data_01515;
SELECT * FROM data_01515 SETTINGS force_data_skipping_indices=''; -- query will produce CANNOT_PARSE_TEXT error.
SELECT * FROM data_01515 SETTINGS force_data_skipping_indices='d1_idx'; -- query will produce INDEX_NOT_USED error.
SELECT * FROM data_01515 WHERE d1 = 0 SETTINGS force_data_skipping_indices='d1_idx'; -- Ok.
SELECT * FROM data_01515 WHERE d1 = 0 SETTINGS force_data_skipping_indices='`d1_idx`'; -- Ok (example of full featured parser).
SELECT * FROM data_01515 WHERE d1 = 0 SETTINGS force_data_skipping_indices='`d1_idx`, d1_null_idx'; -- query will produce INDEX_NOT_USED error, since d1_null_idx is not used.
SELECT * FROM data_01515 WHERE d1 = 0 AND assumeNotNull(d1_null) = 0 SETTINGS force_data_skipping_indices='`d1_idx`, d1_null_idx'; -- Ok.
```
## force_grouping_standard_compatibility {#force_grouping_standard_compatibility} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.9"},{"label": "1"},{"label": "Make GROUPING function output the same as in SQL standard and other DBMS"}]}]}/>

Заставляет функцию GROUPING возвращать 1, когда аргумент не используется как ключ агрегации.
## force_index_by_date {#force_index_by_date} 

<SettingsInfoBlock type="Bool" default_value="0" />

Отключает выполнение запроса, если индекс не может быть использован по дате.

Работает с таблицами семейства MergeTree.

Если `force_index_by_date=1`, ClickHouse проверяет, есть ли в запросе условие ключа даты, которое может быть использовано для ограничения диапазонов данных. Если нет подходящего условия, оно вызывает исключение. Однако не проверяется, уменьшает ли это условие объем данных для чтения. Например, условие `Date != '2000-01-01'` допустимо, даже если оно соответствует всем данным в таблице (т.е. выполнение запроса требует полного сканирования). Для получения дополнительной информации о диапазонах данных в таблицах MergeTree см. [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md).
## force_optimize_projection {#force_optimize_projection} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает обязательное использование [проекций](../../engines/table-engines/mergetree-family/mergetree.md/#projections) в запросах `SELECT`, когда оптимизация проекций включена (см. настройку [optimize_use_projections](#optimize_use_projections)).

Возможные значения:

- 0 — Оптимизация проекций не обязательна.
- 1 — Оптимизация проекций обязательна.
## force_optimize_projection_name {#force_optimize_projection_name} 

Если установлено в непустую строку, проверьте, что эта проекция используется в запросе хотя бы один раз.

Возможные значения:

- строка: имя проекции, использованной в запросе.
## force_optimize_skip_unused_shards {#force_optimize_skip_unused_shards} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Включает или отключает выполнение запроса, если [optimize_skip_unused_shards](#optimize_skip_unused_shards) включен и пропуск неиспользуемых шардов невозможен. Если пропуск невозможен, и настройка включена, будет вызвано исключение.

Возможные значения:

- 0 — Отключено. ClickHouse не вызывает исключение.
- 1 — Включено. Выполнение запроса отключается только если таблица имеет ключ шардирования.
- 2 — Включено. Выполнение запроса отключается независимо от того, определён ли ключ шардирования для таблицы.
## force_optimize_skip_unused_shards_nesting {#force_optimize_skip_unused_shards_nesting} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Контролирует [`force_optimize_skip_unused_shards`](#force_optimize_skip_unused_shards) (поэтому по-прежнему требует [`force_optimize_skip_unused_shards`](#force_optimize_skip_unused_shards)) в зависимости от уровня вложенности распределенного запроса (случай, когда у вас есть таблица `Distributed`, которая смотрит на другую таблицу `Distributed`).

Возможные значения:

- 0 - Отключено, `force_optimize_skip_unused_shards` всегда работает.
- 1 — Включает `force_optimize_skip_unused_shards` только для первого уровня.
- 2 — Включает `force_optimize_skip_unused_shards` до второго уровня.
## force_primary_key {#force_primary_key} 

<SettingsInfoBlock type="Bool" default_value="0" />

Отключает выполнение запроса, если индексация по первичному ключу невозможна.

Работает с таблицами семейства MergeTree.

Если `force_primary_key=1`, ClickHouse проверяет, есть ли в запросе условие первичного ключа, которое может быть использовано для ограничения диапазонов данных. Если нет подходящего условия, оно вызывает исключение. Однако не проверяется, уменьшает ли это условие объем данных для чтения. Для получения дополнительной информации о диапазонах данных в таблицах MergeTree см. [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md).
## force_remove_data_recursively_on_drop {#force_remove_data_recursively_on_drop} 

<SettingsInfoBlock type="Bool" default_value="0" />

Рекурсивно удаляет данные по запросу DROP. Избегает ошибки 'Каталог не пуст', но может незаметно удалить отсоединенные данные.
## formatdatetime_e_with_space_padding {#formatdatetime_e_with_space_padding} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Improved compatibility with MySQL DATE_FORMAT/STR_TO_DATE"}]}]}/>

Форматировщик '%e' в функции 'formatDateTime' выводит однозначные дни с ведущим пробелом, например, ' 2' вместо '2'.
## formatdatetime_f_prints_scale_number_of_digits {#formatdatetime_f_prints_scale_number_of_digits} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "New setting."}]}]}/>

Форматировщик '%f' в функции 'formatDateTime' выводит только количество разрядов для DateTime64 вместо фиксированных 6 разрядов.
## formatdatetime_f_prints_single_zero {#formatdatetime_f_prints_single_zero} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "0"},{"label": "Improved compatibility with MySQL DATE_FORMAT()/STR_TO_DATE()"}]}]}/>

Форматировщик '%f' в функции 'formatDateTime' выводит единственный ноль вместо шести нулей, если отформатированное значение не имеет дробных секунд.
## formatdatetime_format_without_leading_zeros {#formatdatetime_format_without_leading_zeros} 

<SettingsInfoBlock type="Bool" default_value="0" />

Форматировщики '%c', '%l' и '%k' в функции 'formatDateTime' выводят месяцы и часы без ведущих нулей.
## formatdatetime_parsedatetime_m_is_month_name {#formatdatetime_parsedatetime_m_is_month_name} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "1"},{"label": "Improved compatibility with MySQL DATE_FORMAT/STR_TO_DATE"}]}]}/>

Форматировщик '%M' в функциях 'formatDateTime' и 'parseDateTime' выводит/разбирает название месяца вместо минут.
## fsync_metadata {#fsync_metadata} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает [fsync](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html) при записи файлов `.sql`. Включено по умолчанию.

Имеет смысл отключить, если сервер имеет миллионы мелких таблиц, которые постоянно создаются и удаляются.
## function_date_trunc_return_type_behavior {#function_date_trunc_return_type_behavior} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "0"},{"label": "Add new setting to preserve old behaviour of dateTrunc function"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "Change the result type for dateTrunc function for DateTime64/Date32 arguments to DateTime64/Date32 regardless of time unit to get correct result for negative values"}]}]}/>

Позволяет изменить поведение типа результата функции `dateTrunc`.

Возможные значения:

- 0 - Когда второй аргумент — `DateTime64/Date32`, тип возврата будет `DateTime64/Date32` независимо от единицы времени в первом аргументе.
- 1 - Для `Date32` результат всегда будет `Date`. Для `DateTime64` результат будет `DateTime` для единиц времени `second` и выше.
## function_implementation {#function_implementation} 

Выберите реализацию функции для конкретной цели или варианта (экспериментально). Если пусто, включите все из них.
## function_json_value_return_type_allow_complex {#function_json_value_return_type_allow_complex} 

<SettingsInfoBlock type="Bool" default_value="0" />

Контролирует, допускается ли возвращение сложного типа (таких как: struct, array, map) для функции json_value.

```sql
SELECT JSON_VALUE('{"hello":{"world":"!"}}', '$.hello') settings function_json_value_return_type_allow_complex=true

┌─JSON_VALUE('{"hello":{"world":"!"}}', '$.hello')─┐
│ {"world":"!"}                                    │
└──────────────────────────────────────────────────┘

1 row in set. Elapsed: 0.001 sec.
```

Возможные значения:

- true — Разрешить.
- false — Запретить.
## function_json_value_return_type_allow_nullable {#function_json_value_return_type_allow_nullable} 

<SettingsInfoBlock type="Bool" default_value="0" />

Контролирует, допускается ли возвращение `NULL`, когда значение отсутствует для функции JSON_VALUE.

```sql
SELECT JSON_VALUE('{"hello":"world"}', '$.b') settings function_json_value_return_type_allow_nullable=true;

┌─JSON_VALUE('{"hello":"world"}', '$.b')─┐
│ ᴺᵁᴸᴸ                                   │
└────────────────────────────────────────┘

1 row in set. Elapsed: 0.001 sec.
```

Возможные значения:

- true — Разрешить.
- false — Запретить.
## function_locate_has_mysql_compatible_argument_order {#function_locate_has_mysql_compatible_argument_order} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Increase compatibility with MySQL's locate function."}]}]}/>

Контролирует порядок аргументов в функции [locate](../../sql-reference/functions/string-search-functions.md/#locate).

Возможные значения:

- 0 — Функция `locate` принимает аргументы `(haystack, needle[, start_pos])`.
- 1 — Функция `locate` принимает аргументы `(needle, haystack[, start_pos])` (совместимое с MySQL поведение).
## function_range_max_elements_in_block {#function_range_max_elements_in_block} 

<SettingsInfoBlock type="UInt64" default_value="500000000" />

Устанавливает предельный предел для объема данных, генерируемых функцией [range](/sql-reference/functions/array-functions#range). Определяет максимальное количество значений, генерируемых функцией на блок данных (сумма размеров массивов для каждой строки в блоке).

Возможные значения:

- Положительное целое число.

**См. также**

- [`max_block_size`](#max_block_size)
- [`min_insert_block_size_rows`](#min_insert_block_size_rows)
## function_sleep_max_microseconds_per_block {#function_sleep_max_microseconds_per_block} 

<SettingsInfoBlock type="UInt64" default_value="3000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.7"},{"label": "3000000"},{"label": "In previous versions, the maximum sleep time of 3 seconds was applied only for `sleep`, but not for `sleepEachRow` function. In the new version, we introduce this setting. If you set compatibility with the previous versions, we will disable the limit altogether."}]}]}/>

Максимальное количество микросекунд, на которое функция `sleep` разрешено спать для каждого блока. Если пользователь вызывается с большим значением, оно вызывает исключение. Это предельный порог.
## function_visible_width_behavior {#function_visible_width_behavior} 

<SettingsInfoBlock type="UInt64" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "1"},{"label": "We changed the default behavior of `visibleWidth` to be more precise"}]}]}/>

Версия поведения `visibleWidth`. 0 - учитываются только кодовые точки; 1 - корректно считается нулевая ширина и комбинирующие символы, учитываются знаки полной ширины как два, оценивается ширина табуляции, учитываются символы удаления.
## geo_distance_returns_float64_on_float64_arguments {#geo_distance_returns_float64_on_float64_arguments} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Increase the default precision."}]}]}/>

Если все четыре аргумента функций `geoDistance`, `greatCircleDistance`, `greatCircleAngle` — Float64, вернуть Float64 и использовать двойную точность для внутренних вычислений. В предыдущих версиях ClickHouse функции всегда возвращали Float32.
## geotoh3_argument_order {#geotoh3_argument_order} 

<BetaBadge/>

<SettingsInfoBlock type="GeoToH3ArgumentOrder" default_value="lat_lon" />

Функция 'geoToH3' принимает (lon, lat), если установлено 'lon_lat', и (lat, lon), если установлено 'lat_lon'.
## glob_expansion_max_elements {#glob_expansion_max_elements} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Максимальное количество разрешенных адресов (для внешних хранилищ, табличных функций и т.д.).
## grace_hash_join_initial_buckets {#grace_hash_join_initial_buckets} 

<ExperimentalBadge/>

<SettingsInfoBlock type="NonZeroUInt64" default_value="1" />

Начальное количество ведер для грациозного хеш-объединения.
## grace_hash_join_max_buckets {#grace_hash_join_max_buckets} 

<ExperimentalBadge/>

<SettingsInfoBlock type="NonZeroUInt64" default_value="1024" />

Ограничение на количество ведер для грациозного хеш-объединения.
## group_by_overflow_mode {#group_by_overflow_mode} 

<SettingsInfoBlock type="OverflowModeGroupBy" default_value="throw" />

Устанавливает, что происходит, когда количество уникальных ключей для агрегации превышает лимит:
- `throw`: выбросить исключение.
- `break`: остановить выполнение запроса и вернуть частичный результат.
- `any`: продолжать агрегацию для ключей, которые попали в набор, но не добавлять новые ключи в набор.

Использование значения 'any' позволяет запустить приближенную агрегацию GROUP BY. Качество 
этой аппроксимации зависит от статистической природы данных.
## group_by_two_level_threshold {#group_by_two_level_threshold} 

<SettingsInfoBlock type="UInt64" default_value="100000" />

С какого количества ключей начинается агрегация на двух уровнях. 0 - порог не установлен.
## group_by_two_level_threshold_bytes {#group_by_two_level_threshold_bytes} 

<SettingsInfoBlock type="UInt64" default_value="50000000" />

С какого размера состояния агрегации в байтах начинается использование двухуровневой агрегации. 0 - порог не установлен. Двухуровневая агрегация используется, когда хотя бы одно из пороговых значений срабатывает.
## group_by_use_nulls {#group_by_use_nulls} 

<SettingsInfoBlock type="Bool" default_value="0" />

Изменяет способ обработки [GROUP BY](/sql-reference/statements/select/group-by) типов ключей агрегации.
Когда используются спецификаторы `ROLLUP`, `CUBE` или `GROUPING SETS`, некоторые ключи агрегации могут не использоваться для генерации некоторых строк результата.
Столбцы для этих ключей заполняются либо значением по умолчанию, либо `NULL` в соответствующих строках в зависимости от этой настройки.

Возможные значения:

- 0 — Используется значение по умолчанию для типа ключа агрегации для генерации недостающих значений.
- 1 — ClickHouse выполняет `GROUP BY` так же, как говорит стандарт SQL. Типы ключей агрегации преобразуются в [Nullable](/sql-reference/data-types/nullable). Столбцы для соответствующих ключей агрегации заполняются [NULL](/sql-reference/syntax#null) для строк, которые их не использовали.

См. также:

- [GROUP BY](#GROUP BY)
## h3togeo_lon_lat_result_order {#h3togeo_lon_lat_result_order} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "A new setting"}]}]}/>

Функция 'h3ToGeo' возвращает (lon, lat), если true, иначе (lat, lon).
## handshake_timeout_ms {#handshake_timeout_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="10000" />

Тайм-аут в миллисекундах для получения Hello-пакета от реплик во время обмена ключами.
## hdfs_create_new_file_on_insert {#hdfs_create_new_file_on_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает создание нового файла при каждой вставке в таблицы HDFS. Если включено, при каждой вставке будет создан новый HDFS файл с именем, похожим на следующую схему:

начальный: `data.Parquet.gz` -> `data.1.Parquet.gz` -> `data.2.Parquet.gz` и так далее.

Возможные значения:
- 0 — `INSERT` запрос добавляет новые данные в конец файла.
- 1 — `INSERT` запрос создает новый файл.
## hdfs_ignore_file_doesnt_exist {#hdfs_ignore_file_doesnt_exist} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Allow to return 0 rows when the requested files don't exist instead of throwing an exception in HDFS table engine"}]}]}/>

Игнорировать отсутствие файла, если он не существует при чтении определенных ключей.

Возможные значения:
- 1 — `SELECT` возвращает пустой результат.
- 0 — `SELECT` выбрасывает исключение.
## hdfs_replication {#hdfs_replication} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Фактическое количество репликаций может быть указано при создании файла hdfs.
## hdfs_skip_empty_files {#hdfs_skip_empty_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает пропуск пустых файлов в [HDFS](../../engines/table-engines/integrations/hdfs.md) таблицах.

Возможные значения:
- 0 — `SELECT` выбрасывает исключение, если пустой файл несовместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.
## hdfs_throw_on_zero_files_match {#hdfs_throw_on_zero_files_match} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Allow to throw an error when ListObjects request cannot match any files in HDFS engine instead of empty query result"}]}]}/>

Бросает ошибку, если не найдено ни одного совпадающего файла в соответствии с правилами расширения glob.

Возможные значения:
- 1 — `SELECT` выбрасывает исключение.
- 0 — `SELECT` возвращает пустой результат.
## hdfs_truncate_on_insert {#hdfs_truncate_on_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает обрезку перед вставкой в таблицы hdfs. Если отключено, при попытке вставки, если файл в HDFS уже существует, будет выброшено исключение.

Возможные значения:
- 0 — `INSERT` запрос добавляет новые данные в конец файла.
- 1 — `INSERT` запрос заменяет существующее содержимое файла новыми данными.
## hedged_connection_timeout_ms {#hedged_connection_timeout_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="50" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "50"},{"label": "Start new connection in hedged requests after 50 ms instead of 100 to correspond with previous connect timeout"}]}]}/>

Тайм-аут подключения для установления соединения с репликой для хеджированных запросов.
## hnsw_candidate_list_size_for_search {#hnsw_candidate_list_size_for_search} 

<SettingsInfoBlock type="UInt64" default_value="256" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "256"},{"label": "New setting. Previously, the value was optionally specified in CREATE INDEX and 64 by default."}]}]}/>

Размер динамического списка кандидатов при поиске в индексе векторного сходства, также известном как 'ef_search'.
## hsts_max_age {#hsts_max_age} 

Максимальное время действия для HSTS. 0 означает отключение HSTS.
## http_connection_timeout {#http_connection_timeout} 

Тайм-аут подключения HTTP (в секундах).

Возможные значения:

- Любое положительное целое число.
- 0 - Отключено (бесконечный тайм-аут).
## http_headers_progress_interval_ms {#http_headers_progress_interval_ms} 

Не отправлять HTTP заголовки X-ClickHouse-Progress чаще, чем на каждом указанном интервале.
## http_make_head_request {#http_make_head_request} 

Настройка `http_make_head_request` позволяет выполняться запросу `HEAD` при чтении данных по HTTP для получения информации о файле, который будет прочитан, такой как его размер. Поскольку она по умолчанию включена, может быть целесообразно отключить эту настройку в случаях, когда сервер не поддерживает запросы `HEAD`.
## http_max_field_name_size {#http_max_field_name_size} 

Максимальная длина имени поля в HTTP заголовке.
## http_max_field_value_size {#http_max_field_value_size} 

Максимальная длина значения поля в HTTP заголовке.
## http_max_fields {#http_max_fields} 

Максимальное количество полей в HTTP заголовке.
## http_max_multipart_form_data_size {#http_max_multipart_form_data_size} 

Предел на размер содержимого multipart/form-data. Эта настройка не может быть распарсена из URL параметров и должна быть установлена в пользовательском профиле. Обратите внимание, что содержимое парсится, и внешние таблицы создаются в памяти перед началом выполнения запроса. И это единственный предел, который влияет на эту стадию (пределы на максимальное использование памяти и максимальное время выполнения не влияют на чтение данных HTTP формы).
## http_max_request_param_data_size {#http_max_request_param_data_size} 

Предел на размер данных запроса, используемых в качестве параметра запроса в предопределенных HTTP запросах.
## http_max_tries {#http_max_tries} 

Максимальное количество попыток чтения через http.
## http_max_uri_size {#http_max_uri_size} 

Устанавливает максимальную длину URI HTTP запроса.

Возможные значения:

- Положительное целое число.
## http_native_compression_disable_checksumming_on_decompress {#http_native_compression_disable_checksumming_on_decompress} 

Включает или отключает проверку контрольной суммы при декомпрессии HTTP POST данных от клиента. Используется только для нативного формата сжатия ClickHouse (не используется с `gzip` или `deflate`).

Для получения дополнительной информации читайте [Описание HTTP интерфейса](../../interfaces/http.md).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
## http_receive_timeout {#http_receive_timeout} 

<SettingsInfoBlock type="Seconds" default_value="30" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.6"},{"label": "30"},{"label": "See http_send_timeout."}]}]}/>

Тайм-аут получения HTTP (в секундах).

Возможные значения:

- Любое положительное целое число.
- 0 - Отключено (бесконечный тайм-аут).
## http_response_buffer_size {#http_response_buffer_size} 

Количество байтов для буферизации в памяти сервера перед отправкой ответа HTTP клиенту или очисткой на диск (при включении http_wait_end_of_query).
## http_response_headers {#http_response_headers} 

<SettingsInfoBlock type="Map" default_value="{}" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": ""},{"label": "New setting."}]}]}/>

Позволяет добавлять или переопределять HTTP заголовки, которые сервер будет возвращать в ответе с успешным результатом запроса.
Это касается только HTTP интерфейса.

Если заголовок уже установлен по умолчанию, предоставленное значение его переопределит.
Если заголовок не был установлен по умолчанию, он будет добавлен в список заголовков.
Заголовки, установленные сервером по умолчанию и не переопределенные этой настройкой, останутся.

Настройка позволяет установить заголовок на постоянное значение. В настоящее время нет способа установить заголовок на динамически вычисляемое значение.

Ни имена, ни значения не могут содержать управляющие символы ASCII.

Если вы реализуете UI приложение, позволяющее пользователям изменять настройки, но при этом принимающее решения на основе возвращаемых заголовков, рекомендуется ограничить эту настройку до readonly.

Пример: `SET http_response_headers = '{"Content-Type": "image/png"}'`
## http_retry_initial_backoff_ms {#http_retry_initial_backoff_ms} 

Минимальное количество миллисекунд для ожидания, когда повторная попытка чтения через http.
## http_retry_max_backoff_ms {#http_retry_max_backoff_ms} 

Максимальное количество миллисекунд для ожидания, когда повторная попытка чтения через http.
## http_send_timeout {#http_send_timeout} 

<SettingsInfoBlock type="Seconds" default_value="30" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.6"},{"label": "30"},{"label": "3 minutes seems crazy long. Note that this is timeout for a single network write call, not for the whole upload operation."}]}]}/>

Тайм-аут отправки HTTP (в секундах).

Возможные значения:

- Любое положительное целое число.
- 0 - Отключено (бесконечный тайм-аут).

:::note
Это применимо только к умолчанию профиля. Для применения изменений требуется перезапуск сервера.
:::
## http_skip_not_found_url_for_globs {#http_skip_not_found_url_for_globs} 

Пропуск URL для шаблонов с ошибкой HTTP_NOT_FOUND.
## http_wait_end_of_query {#http_wait_end_of_query} 

Включает буферизацию HTTP-ответов на стороне сервера.
## http_write_exception_in_output_format {#http_write_exception_in_output_format} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.9"},{"label": "1"},{"label": "Output valid JSON/XML on exception in HTTP streaming."}]}]}/>

Записывает исключение в выходном формате, чтобы создать действительный вывод. Работает с форматами JSON и XML.
## http_zlib_compression_level {#http_zlib_compression_level} 

Устанавливает уровень сжатия данных в ответ на HTTP запрос, если [enable_http_compression = 1](#enable_http_compression).

Возможные значения: Числа от 1 до 9.
## iceberg_delete_data_on_drop {#iceberg_delete_data_on_drop} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting"}]}]}/>

Удалять ли все файлы iceberg при удалении или нет.
## iceberg_insert_max_bytes_in_data_file {#iceberg_insert_max_bytes_in_data_file} 

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "100000000"},{"label": "New setting."}]}, {"id": "row-2","items": [{"label": "25.10"},{"label": "100000000"},{"label": "New setting."}]}]}/>

Максимальное количество строк в файле данных parquet iceberg при операции вставки.
## iceberg_insert_max_rows_in_data_file {#iceberg_insert_max_rows_in_data_file} 

<SettingsInfoBlock type="UInt64" default_value="1000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "100000"},{"label": "New setting."}]}, {"id": "row-2","items": [{"label": "25.10"},{"label": "1000000"},{"label": "New setting."}]}]}/>

Максимальное количество строк в файле данных parquet iceberg при операции вставки.
## iceberg_metadata_compression_method {#iceberg_metadata_compression_method} 

<ExperimentalBadge/>

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": ""},{"label": "New setting"}]}]}/>

Метод сжатия файла `.metadata.json`.
## iceberg_metadata_log_level {#iceberg_metadata_log_level} 

<SettingsInfoBlock type="IcebergMetadataLogLevel" default_value="none" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "none"},{"label": "New setting."}]}]}/>

Контролирует уровень ведения журнала метаданных для таблиц Iceberg в system.iceberg_metadata_log.
Обычно эта настройка может быть изменена для целей отладки.

Возможные значения:
- none - Нет журнала метаданных.
- metadata - Корневой файл metadata.json.
- manifest_list_metadata - Все вышеперечисленное + метаданные из avro списка манифестов, который соответствует снимку.
- manifest_list_entry - Все вышеперечисленное + записи списков манифестов avro.
- manifest_file_metadata - Все вышеперечисленное + метаданные из пройденных avro файлов манифестов.
- manifest_file_entry - Все вышеперечисленное + записи пройденных avro файлов манифестов.
## iceberg_snapshot_id {#iceberg_snapshot_id} 

<SettingsInfoBlock type="Int64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "New setting."}]}]}/>

Выполнить запрос к таблице Iceberg, используя конкретный идентификатор снимка.
## iceberg_timestamp_ms {#iceberg_timestamp_ms} 

<SettingsInfoBlock type="Int64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "New setting."}]}]}/>

Выполнить запрос к таблице Iceberg, используя снимок, который был актуален на конкретную временную метку.
## idle_connection_timeout {#idle_connection_timeout} 

Тайм-аут для закрытия неактивных TCP соединений после указанного количества секунд.

Возможные значения:

- Положительное целое число (0 - закрыть немедленно, через 0 секунд).
## ignore_cold_parts_seconds {#ignore_cold_parts_seconds} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Int64" default_value="0" />

Эта настройка влияет только на ClickHouse Cloud. Исключает новые части данных из SELECT запросов, пока они не будут либо предварительно разогреты (см. [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch)), либо не станут старыми на это количество секунд. Предназначено только для Replicated-/SharedMergeTree.
## ignore_data_skipping_indices {#ignore_data_skipping_indices} 

Игнорирует указанные индексы пропуска, если они используются запросом.

Рассмотрим следующий пример:

```sql
CREATE TABLE data
(
    key Int,
    x Int,
    y Int,
    INDEX x_idx x TYPE minmax GRANULARITY 1,
    INDEX y_idx y TYPE minmax GRANULARITY 1,
    INDEX xy_idx (x,y) TYPE minmax GRANULARITY 1
)
Engine=MergeTree()
ORDER BY key;

INSERT INTO data VALUES (1, 2, 3);

SELECT * FROM data;
SELECT * FROM data SETTINGS ignore_data_skipping_indices=''; -- query will produce CANNOT_PARSE_TEXT error.
SELECT * FROM data SETTINGS ignore_data_skipping_indices='x_idx'; -- Ok.
SELECT * FROM data SETTINGS ignore_data_skipping_indices='na_idx'; -- Ok.

SELECT * FROM data WHERE x = 1 AND y = 1 SETTINGS ignore_data_skipping_indices='xy_idx',force_data_skipping_indices='xy_idx' ; -- query will produce INDEX_NOT_USED error, since xy_idx is explicitly ignored.
SELECT * FROM data WHERE x = 1 AND y = 2 SETTINGS ignore_data_skipping_indices='xy_idx';
```

Запрос без игнорирования индексов:
```sql
EXPLAIN indexes = 1 SELECT * FROM data WHERE x = 1 AND y = 2;

Expression ((Projection + Before ORDER BY))
  Filter (WHERE)
    ReadFromMergeTree (default.data)
    Indexes:
      PrimaryKey
        Condition: true
        Parts: 1/1
        Granules: 1/1
      Skip
        Name: x_idx
        Description: minmax GRANULARITY 1
        Parts: 0/1
        Granules: 0/1
      Skip
        Name: y_idx
        Description: minmax GRANULARITY 1
        Parts: 0/0
        Granules: 0/0
      Skip
        Name: xy_idx
        Description: minmax GRANULARITY 1
        Parts: 0/0
        Granules: 0/0
```

Игнорируя индекс `xy_idx`:
```sql
EXPLAIN indexes = 1 SELECT * FROM data WHERE x = 1 AND y = 2 SETTINGS ignore_data_skipping_indices='xy_idx';

Expression ((Projection + Before ORDER BY))
  Filter (WHERE)
    ReadFromMergeTree (default.data)
    Indexes:
      PrimaryKey
        Condition: true
        Parts: 1/1
        Granules: 1/1
      Skip
        Name: x_idx
        Description: minmax GRANULARITY 1
        Parts: 0/1
        Granules: 0/1
      Skip
        Name: y_idx
        Description: minmax GRANULARITY 1
        Parts: 0/0
        Granules: 0/0
```

Работает с таблицами в семействе MergeTree.
## ignore_drop_queries_probability {#ignore_drop_queries_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "0"},{"label": "Allow to ignore drop queries in server with specified probability for testing purposes"}]}]}/>

Если включено, сервер будет игнорировать все запросы DROP таблиц с заданной вероятностью (для Memory и JOIN движков это заменит DROP на TRUNCATE). Используется для тестирования.
## ignore_materialized_views_with_dropped_target_table {#ignore_materialized_views_with_dropped_target_table} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Add new setting to allow to ignore materialized views with dropped target table"}]}]}/>

Игнорировать MVs с удаленной целевой таблицей при отправке в представления.
## ignore_on_cluster_for_replicated_access_entities_queries {#ignore_on_cluster_for_replicated_access_entities_queries} 

Игнорировать оператор ON CLUSTER для управления запросами на реплицированные сущности доступа.
## ignore_on_cluster_for_replicated_named_collections_queries {#ignore_on_cluster_for_replicated_named_collections_queries} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Ignore ON CLUSTER clause for replicated named collections management queries."}]}]}/>

Игнорировать оператор ON CLUSTER для управления запросами на реплицированные именованные коллекции.
## ignore_on_cluster_for_replicated_udf_queries {#ignore_on_cluster_for_replicated_udf_queries} 

Игнорировать оператор ON CLUSTER для управления запросами на реплицированные функции UDF.
## implicit_select {#implicit_select} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "A new setting."}]}]}/>

Позволяет писать простые SELECT запросы без ведущего ключевого слова SELECT, что делает их простыми для использования в калькуляторном стиле, например, `1 + 2` становится действительным запросом.

В `clickhouse-local` это включено по умолчанию и может быть явно отключено.
## implicit_table_at_top_level {#implicit_table_at_top_level} 

Если не пусто, запросы без FROM на верхнем уровне будут считываться из этой таблицы вместо system.one.

Это используется в clickhouse-local для обработки входных данных.
Настройка может быть установлена явно пользователем, но не предназначена для такого использования.

Подзапросы не подлежат влиянию этой настройки (ни скалярные, ни FROM, ни IN подзапросы).
SELECT на верхнем уровне цепочек UNION, INTERSECT, EXCEPT обрабатываются одинаково и подлежат влиянию этой настройки, независимо от их группировки в скобках.
Не определено, как эта настройка влияет на представления и распределенные запросы.

Настройка принимает имя таблицы (тогда таблица разрешается из текущей базы данных) или квалифицированное имя в формате 'database.table'.
Оба имени базы данных и таблицы должны быть не заключены в кавычки - допускаются только простые идентификаторы.
## implicit_transaction {#implicit_transaction} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

Если включено и не находится внутри транзакции, оборачивает запрос в полную транзакцию (начало + коммит или откат).
## inject_random_order_for_select_without_order_by {#inject_random_order_for_select_without_order_by} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "0"},{"label": "New setting"}]}]}/>

Если включено, добавляет 'ORDER BY rand()' в SELECT запросы без оператора ORDER BY.
Применяется только для глубины подзапроса = 0. Подзапросы и INSERT INTO ... SELECT не подлежат влиянию.
Если верхний уровень конструкция UNION, 'ORDER BY rand()' добавляется во все дочерние элементы независимо.
Полезно только для тестирования и разработки (отсутствие ORDER BY является источником недетерминированных результатов запросов).
## input_format_parallel_parsing {#input_format_parallel_parsing} 

Включает или отключает параллельный анализ форматов данных с сохранением порядка. Поддерживается только для форматов [TSV](../../interfaces/formats.md/#tabseparated), [TSKV](../../interfaces/formats.md/#tskv), [CSV](../../interfaces/formats.md/#csv) и [JSONEachRow](../../interfaces/formats.md/#jsoneachrow).

Возможные значения:

- 1 — Включено.
- 0 — Отключено.
## insert_allow_materialized_columns {#insert_allow_materialized_columns} 

Если настройка включена, разрешает использование материализованных столбцов при вставке.
## insert_deduplicate {#insert_deduplicate} 

Включает или отключает дедупликацию блока для `INSERT` (для Replicated* таблиц).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

По умолчанию блоки, вставленные в реплицированные таблицы заявлением `INSERT`, дедуплицируются (см. [Репликация данных](../../engines/table-engines/mergetree-family/replication.md)).
Для реплицированных таблиц по умолчанию дедуплицируются только последние 100 блоков для каждой партиции (см. [replicated_deduplication_window](merge-tree-settings.md/#replicated_deduplication_window), [replicated_deduplication_window_seconds](merge-tree-settings.md/#replicated_deduplication_window_seconds)).
Для нереплицированных таблиц см. [non_replicated_deduplication_window](merge-tree-settings.md/#non_replicated_deduplication_window).
## insert_deduplication_token {#insert_deduplication_token} 

Настройка позволяет пользователю предоставить собственную семантику дедупликации в MergeTree/ReplicatedMergeTree. Например, указав уникальное значение для настройки в каждом заявлении INSERT, пользователь может избежать дедупликации одинаковых данных.

Возможные значения:

- Любая строка.

`insert_deduplication_token` используется для дедупликации _только_ при ненулевом значении.

Для реплицированных таблиц по умолчанию дедуплицируются только последние 100 вставок для каждой партиции (см. [replicated_deduplication_window](merge-tree-settings.md/#replicated_deduplication_window), [replicated_deduplication_window_seconds](merge-tree-settings.md/#replicated_deduplication_window_seconds)).
Для нереплицированных таблиц см. [non_replicated_deduplication_window](merge-tree-settings.md/#non_replicated_deduplication_window).

:::note
`insert_deduplication_token` работает на уровне партиции (так же, как и контрольная сумма `insert_deduplication`). Несколько партиций могут иметь одинаковое `insert_deduplication_token`.
:::

Пример:

```sql
CREATE TABLE test_table
( A Int64 )
ENGINE = MergeTree
ORDER BY A
SETTINGS non_replicated_deduplication_window = 100;

INSERT INTO test_table SETTINGS insert_deduplication_token = 'test' VALUES (1);

-- the next insert won't be deduplicated because insert_deduplication_token is different
INSERT INTO test_table SETTINGS insert_deduplication_token = 'test1' VALUES (1);

-- the next insert will be deduplicated because insert_deduplication_token
-- is the same as one of the previous
INSERT INTO test_table SETTINGS insert_deduplication_token = 'test' VALUES (2);

SELECT * FROM test_table

┌─A─┐
│ 1 │
└───┘
┌─A─┐
│ 1 │
└───┘
```
## insert_keeper_fault_injection_probability {#insert_keeper_fault_injection_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

Приблизительная вероятность сбоя для запроса Keeper во время вставки. Допустимое значение находится в интервале [0.0f, 1.0f].
## insert_keeper_fault_injection_seed {#insert_keeper_fault_injection_seed} 

<SettingsInfoBlock type="UInt64" default_value="0" />

0 - случайный начальный вектор, в противном случае значение настройки.
## insert_keeper_max_retries {#insert_keeper_max_retries} 

<SettingsInfoBlock type="UInt64" default_value="20" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.2"},{"label": "20"},{"label": "Enable reconnections to Keeper on INSERT, improve reliability"}]}]}/>

Настройка устанавливает максимальное количество попыток для запросов ClickHouse Keeper (или ZooKeeper) во время вставки в реплицированный MergeTree. Учитываются только запросы Keeper, которые не удались из-за сетевой ошибки, истечения времени сеанса Keeper или истечения времени запросов.

Возможные значения:

- Положительное целое число.
- 0 — Повторные попытки отключены.

Cloud значение по умолчанию: `20`.

Повторы запросов Keeper выполняются после некоторого таймаута. Таймаут контролируется следующими настройками: `insert_keeper_retry_initial_backoff_ms`, `insert_keeper_retry_max_backoff_ms`.
Первая попытка выполняется после истечения таймаута `insert_keeper_retry_initial_backoff_ms`. Последующие таймауты будут рассчитаны следующим образом:
```
timeout = min(insert_keeper_retry_max_backoff_ms, latest_timeout * 2)
```

Например, если `insert_keeper_retry_initial_backoff_ms=100`, `insert_keeper_retry_max_backoff_ms=10000` и `insert_keeper_max_retries=8`, то таймауты будут `100, 200, 400, 800, 1600, 3200, 6400, 10000`.

Кроме отказоустойчивости, повторы имеют целью улучшить опыт работы с пользователем - они позволяют избежать возврата ошибки во время выполнения INSERT, если Keeper был перезапущен, например, из-за обновления.
## insert_keeper_retry_initial_backoff_ms {#insert_keeper_retry_initial_backoff_ms} 

Начальный тайм-аут (в миллисекундах) для повторной попытки неудавшегося запроса Keeper во время выполнения запроса INSERT.

Возможные значения:

- Положительное целое число.
- 0 — Без таймаута.
## insert_keeper_retry_max_backoff_ms {#insert_keeper_retry_max_backoff_ms} 

Максимальный тайм-аут (в миллисекундах) для повторной попытки неудавшегося запроса Keeper во время выполнения запроса INSERT.

Возможные значения:

- Положительное целое число.
- 0 — Максимальный тайм-аут не ограничен.
## insert_null_as_default {#insert_null_as_default} 

Включает или отключает вставку [значений по умолчанию](/sql-reference/statements/create/table#default_values) вместо [NULL](/sql-reference/syntax#null) в столбцы с не [null](ссылка на типы данных/nullable) типом данных.
Если тип столбца не допускает значения NULL и эта настройка отключена, то вставка `NULL` вызывает исключение. Если тип столбца допускает NULL, то значения NULL вставляются как есть, независимо от этой настройки.

Эта настройка применяется к запросам [INSERT ... SELECT](../../sql-reference/statements/insert-into.md/#inserting-the-results-of-select). Обратите внимание, что подзапросы `SELECT` могут быть объединены с клаузой `UNION ALL`.

Возможные значения:

- 0 — Вставка `NULL` в столбец, не допускающий NULL, вызывает исключение.
- 1 — Значение по умолчанию для столбца вставляется вместо `NULL`.
## insert_quorum {#insert_quorum} 

:::note
Эта настройка не применяется к SharedMergeTree, см. [Согласованность SharedMergeTree](/cloud/reference/shared-merge-tree#consistency) для получения дополнительной информации.
:::

Включает записи кворума.

- Если `insert_quorum < 2`, записи кворума отключены.
- Если `insert_quorum >= 2`, записи кворума включены.
- Если `insert_quorum = 'auto'`, используется большинство (`number_of_replicas / 2 + 1`) как число кворума.

Записи кворума.

`INSERT` успешно завершается только тогда, когда ClickHouse удается правильно записать данные на `insert_quorum` реплик в течение `insert_quorum_timeout`. Если по какой-либо причине количество реплик с успешными записями не достигает `insert_quorum`, запись считается неудачной, и ClickHouse удалит вставленный блок из всех реплик, куда данные уже были записаны.

Когда `insert_quorum_parallel` отключен, все реплики в кворуме согласованы, т.е. они содержат данные из всех предыдущих `INSERT` запросов (последовательность `INSERT` линеаризуется). При чтении данных, записанных с использованием `insert_quorum`, и `insert_quorum_parallel` отключен, вы можете включить последовательную согласованность для `SELECT` запросов, используя [select_sequential_consistency](#select_sequential_consistency).

ClickHouse генерирует исключение:

- Если количество доступных реплик в момент запроса меньше `insert_quorum`.
- Когда `insert_quorum_parallel` отключен и делается попытка записать данные, когда предыдущий блок еще не был вставлен в кворум реплик. Эта ситуация может возникнуть, если пользователь пытается выполнить другой запрос `INSERT` в ту же таблицу до завершения предыдущего с `insert_quorum`.

Смотрите также:

- [insert_quorum_timeout](#insert_quorum_timeout)
- [insert_quorum_parallel](#insert_quorum_parallel)
- [select_sequential_consistency](#select_sequential_consistency)
## insert_quorum_parallel {#insert_quorum_parallel} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.1"},{"label": "1"},{"label": "Use parallel quorum inserts by default. It is significantly more convenient to use than sequential quorum inserts"}]}]}/>

:::note
Эта настройка не применяется к SharedMergeTree, см. [Согласованность SharedMergeTree](/cloud/reference/shared-merge-tree#consistency) для получения дополнительной информации.
:::

Включает или отключает параллелизм для запросов `INSERT` с кворумом. Если включено, дополнительные запросы `INSERT` могут быть отправлены, пока предыдущие запросы еще не завершены. Если отключено, дополнительные записи в ту же таблицу будут отклонены.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

Смотрите также:

- [insert_quorum](#insert_quorum)
- [insert_quorum_timeout](#insert_quorum_timeout)
- [select_sequential_consistency](#select_sequential_consistency)
## insert_quorum_timeout {#insert_quorum_timeout} 

Тайм-аут записи в кворум в миллисекундах. Если тайм-аут истек и запись еще не произошла, ClickHouse сгенерирует исключение, и клиент должен повторить запрос, чтобы записать тот же блок в ту же или любую другую реплику.

Смотрите также:

- [insert_quorum](#insert_quorum)
- [insert_quorum_parallel](#insert_quorum_parallel)
- [select_sequential_consistency](#select_sequential_consistency)
## insert_shard_id {#insert_shard_id} 

Если не `0`, указывает шард [Distributed](/engines/table-engines/special/distributed) таблицы, в который данные будут вставлены синхронно.

Если значение `insert_shard_id` неверно, сервер выбросит исключение.

Чтобы получить количество шардов на `requested_cluster`, вы можете проверить конфигурацию сервера или использовать этот запрос:

```sql
SELECT uniq(shard_num) FROM system.clusters WHERE cluster = 'requested_cluster';
```

Возможные значения:

- 0 — Отключено.
- Любое число от `1` до `shards_num` соответствующей [Distributed](/engines/table-engines/special/distributed) таблицы.

**Пример**

Запрос:

```sql
CREATE TABLE x AS system.numbers ENGINE = MergeTree ORDER BY number;
CREATE TABLE x_dist AS x ENGINE = Distributed('test_cluster_two_shards_localhost', currentDatabase(), x);
INSERT INTO x_dist SELECT * FROM numbers(5) SETTINGS insert_shard_id = 1;
SELECT * FROM x_dist ORDER BY number ASC;
```

Результат:

```text
┌─number─┐
│      0 │
│      0 │
│      1 │
│      1 │
│      2 │
│      2 │
│      3 │
│      3 │
│      4 │
│      4 │
└────────┘
```
## interactive_delay {#interactive_delay} 

Интервал в микросекундах для проверки того, был ли отменен запрос и отправки прогресса.
## intersect_default_mode {#intersect_default_mode} 

Устанавливает режим по умолчанию в запросе INTERSECT. Возможные значения: пустая строка, 'ALL', 'DISTINCT'. Если пусто, запрос без режима выбрасывает исключение.
## jemalloc_collect_profile_samples_in_trace_log {#jemalloc_collect_profile_samples_in_trace_log} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting"}]}]}/>

Собирать образцы распределения и деалокации jemalloc в журнале трассировки.
## jemalloc_enable_profiler {#jemalloc_enable_profiler} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting"}]}]}/>

Включает профайлер jemalloc для запроса. Jemalloc будет собирать образцы распределения и все деалокации для собранных образцов.
Профили могут быть очищены с помощью SYSTEM JEMALLOC FLUSH PROFILE, что может быть использовано для анализа распределений.
Образцы также могут храниться в system.trace_log с использованием конфигурации jemalloc_collect_global_profile_samples_in_trace_log или с настройкой запроса jemalloc_collect_profile_samples_in_trace_log.
Смотрите [Профайлирование распределения](/operations/allocation-profiling).
## join_algorithm {#join_algorithm} 

<SettingsInfoBlock type="JoinAlgorithm" default_value="direct,parallel_hash,hash" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "direct,parallel_hash,hash"},{"label": "'default' was deprecated in favor of explicitly specified join algorithms, also parallel_hash is now preferred over hash"}]}]}/>

Указывает, какой [JOIN](../../sql-reference/statements/select/join.md) алгоритм используется.

Можно указать несколько алгоритмов, и доступный будет выбран для конкретного запроса на основе типа/строгости и движка таблиц.

Возможные значения:

- grace_hash

 Используется [Grace hash join](https://en.wikipedia.org/wiki/Hash_join#Grace_hash_join). Grace hash предоставляет вариант алгоритма, который обеспечивает производительные сложные соединения, ограничивая использование памяти.

 Первая фаза grace join считывает правую таблицу и разбивает ее на N бакетов в зависимости от значения хеша ключевых колонок (изначально N равно `grace_hash_join_initial_buckets`). Это делается таким образом, чтобы каждый бакет мог обрабатываться независимо. Строки из первого бакета добавляются в хеш-таблицу в памяти, в то время как остальные сохраняются на диске. Если хеш-таблица превышает пределы памяти (например, как установлено [`max_bytes_in_join`](/operations/settings/settings#max_bytes_in_join), количество бакетов увеличивается, и назначается бакет для каждой строки. Любые строки, которые не принадлежат текущему бакету, сбрасываются и переназначаются.

 Поддерживает `INNER/LEFT/RIGHT/FULL ALL/ANY JOIN`.

- hash

 Используется [Hash join algorithm](https://en.wikipedia.org/wiki/Hash_join). Самая обобщенная реализация, которая поддерживает все комбинации типа и строгости и несколько ключей соединения, которые объединяются с `OR` в секции `JOIN ON`.

 При использовании алгоритма `hash` правая часть `JOIN` загружается в оперативную память.

- parallel_hash

 Вариация `hash` join, которая разбивает данные на бакеты и строит несколько хеш-таблиц вместо одной параллельно для ускорения этого процесса.

 При использовании алгоритма `parallel_hash` правая часть `JOIN` загружается в оперативную память.

- partial_merge

 Вариация [sort-merge алгоритма](https://en.wikipedia.org/wiki/Sort-merge_join), где только правая таблица полностью отсортирована.

 `RIGHT JOIN` и `FULL JOIN` поддерживаются только с `ALL` строгостью (`SEMI`, `ANTI`, `ANY` и `ASOF` не поддерживаются).

 При использовании алгоритма `partial_merge` ClickHouse сортирует данные и сбрасывает их на диск. Алгоритм `partial_merge` в ClickHouse немного отличается от классической реализации. Сначала ClickHouse сортирует правую таблицу по ключам соединения в блоках и создает индекс min-max для отсортированных блоков. Затем он сортирует части левой таблицы по `join key` и соединяет их с правой таблицей. Индекс min-max также используется для пропуска ненужных блоков правой таблицы.

- direct

 Этот алгоритм можно применить, когда хранилище для правой таблицы поддерживает запросы по ключу-значению.

 Алгоритм `direct` выполняет поиск в правой таблице, используя строки из левой таблицы в качестве ключей. Поддерживается только специальным хранилищем, таким как [Dictionary](/engines/table-engines/special/dictionary) или [EmbeddedRocksDB](../../engines/table-engines/integrations/embedded-rocksdb.md) и только для `LEFT` и `INNER` JOINs.

- auto

 При установке на `auto`, сначала пробуется `hash` join, и алгоритм переключается на другой алгоритм, если нарушается ограничение по памяти.

- full_sorting_merge

 [Sort-merge algorithm](https://en.wikipedia.org/wiki/Sort-merge_join) с полной сортировкой соединенных таблиц перед соединением.

- prefer_partial_merge

 ClickHouse всегда старается использовать `partial_merge` join, если это возможно, иначе использует `hash`. *Устарело*, так же как и `partial_merge,hash`.

- default (устарело)

 Устаревшее значение, пожалуйста, больше не используйте.
 То же самое, что и `direct,hash`, т.е. пытаться использовать прямое соединение и хеш-соединение (в этом порядке).
## join_any_take_last_row {#join_any_take_last_row} 

<SettingsInfoBlock type="Bool" default_value="0" />

Изменяет поведение операций соединения с `ANY` строгостью.

:::note
Эта настройка применяется только к операциям `JOIN` с таблицами движка [Join](../../engines/table-engines/special/join.md).
:::

Возможные значения:

- 0 — Если у правой таблицы больше одной совпадающей строки, будет соединена только первая найденная.
- 1 — Если у правой таблицы больше одной совпадающей строки, будет соединена только последняя найденная.

Смотрите также:

- [JOIN clause](/sql-reference/statements/select/join)
- [Join table engine](../../engines/table-engines/special/join.md)
- [join_default_strictness](#join_default_strictness)
## join_default_strictness {#join_default_strictness} 

<SettingsInfoBlock type="JoinStrictness" default_value="ALL" />

Устанавливает строгий режим по умолчанию для [JOIN клаузов](/sql-reference/statements/select/join).

Возможные значения:

- `ALL` — Если у правой таблицы несколько совпадающих строк, ClickHouse создает [декартово произведение](https://en.wikipedia.org/wiki/Cartesian_product) из совпадающих строк. Это нормальное поведение `JOIN` по стандартному SQL.
- `ANY` — Если у правой таблицы несколько совпадающих строк, будет соединена только первая найденная. Если у правой таблицы только одна совпадающая строка, результаты `ANY` и `ALL` будут одинаковыми.
- `ASOF` — Для соединения последовательностей с неопределенным совпадением.
- `Пустая строка` — Если `ALL` или `ANY` не указаны в запросе, ClickHouse выбрасывает исключение.
## join_on_disk_max_files_to_merge {#join_on_disk_max_files_to_merge} 

Ограничивает количество файлов, разрешенных для параллельной сортировки в операциях MergeJoin, когда они выполняются на диске.

Чем больше значение настройки, тем больше используется оперативной памяти и тем меньше требуется ввода-вывода с диска.

Возможные значения:

- Любое положительное целое число, начиная с 2.
## join_output_by_rowlist_perkey_rows_threshold {#join_output_by_rowlist_perkey_rows_threshold} 

<SettingsInfoBlock type="UInt64" default_value="5" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "5"},{"label": "The lower limit of per-key average rows in the right table to determine whether to output by row list in hash join."}]}]}/>

Нижний предел среднего количества строк по ключу в правой таблице для определения, следует ли выводить по списку строк в хеш-объединении.
## join_overflow_mode {#join_overflow_mode} 

Определяет, какое действие ClickHouse выполняет, когда достигается любое из следующих лимитов соединения:

- [max_bytes_in_join](/operations/settings/settings#max_bytes_in_join)
- [max_rows_in_join](/operations/settings/settings#max_rows_in_join)

Возможные значения:

- `THROW` — ClickHouse выбрасывает исключение и прерывает операцию.
- `BREAK` — ClickHouse прерывает операцию и не выбрасывает исключение.

Значение по умолчанию: `THROW`.

**Смотрите также**

- [JOIN clause](/sql-reference/statements/select/join)
- [Join table engine](/engines/table-engines/special/join)
## join_runtime_bloom_filter_bytes {#join_runtime_bloom_filter_bytes} 

<ExperimentalBadge/>



<SettingsInfoBlock type="UInt64" default_value="524288" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "524288"},{"label": "New setting"}]}]}/>

Размер в байтах фильтра Блума, используемого в качестве фильтра времени выполнения JOIN (см. настройка enable_join_runtime_filters).
## join_runtime_bloom_filter_hash_functions {#join_runtime_bloom_filter_hash_functions} 

<ExperimentalBadge/>



<SettingsInfoBlock type="UInt64" default_value="3" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "3"},{"label": "New setting"}]}]}/>

Количество хеш-функций в фильтре Блума, используемом в качестве фильтра времени выполнения JOIN (см. настройка enable_join_runtime_filters).
## join_to_sort_maximum_table_rows {#join_to_sort_maximum_table_rows} 

<ExperimentalBadge/>



<SettingsInfoBlock type="UInt64" default_value="10000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "10000"},{"label": "The maximum number of rows in the right table to determine whether to rerange the right table by key in left or inner join"}]}]}/>

Максимальное количество строк в правой таблице для определения, нужно ли переставлять правую таблицу по ключу в левых или внутренних соединениях.
## join_to_sort_minimum_perkey_rows {#join_to_sort_minimum_perkey_rows} 

<ExperimentalBadge/>



<SettingsInfoBlock type="UInt64" default_value="40" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "40"},{"label": "The lower limit of per-key average rows in the right table to determine whether to rerange the right table by key in left or inner join. This setting ensures that the optimization is not applied for sparse table keys"}]}]}/>

Нижний предел среднего количества строк по ключу в правой таблице, чтобы определить, нужно ли переставлять правую таблицу по ключу в левых или внутренних соединениях. Эта настройка обеспечивает то, что оптимизация не применяется к разреженным ключам таблицы.
## join_use_nulls {#join_use_nulls} 



<SettingsInfoBlock type="Bool" default_value="0" />

Устанавливает тип поведения [JOIN](../../sql-reference/statements/select/join.md). При слиянии таблиц могут возникать пустые ячейки. ClickHouse заполняет их по-разному в зависимости от этой настройки.

Возможные значения:

- 0 — Пустые ячейки заполняются значением по умолчанию соответствующего типа поля.
- 1 — `JOIN` ведет себя так же, как в стандартном SQL. Тип соответствующего поля преобразуется в [Nullable](/sql-reference/data-types/nullable), и пустые ячейки заполняются [NULL](/sql-reference/syntax).
## joined_subquery_requires_alias {#joined_subquery_requires_alias} 



<SettingsInfoBlock type="Bool" default_value="1" />

Принуждает объединенные подзапросы и табличные функции иметь псевдонимы для корректной квалификации имен.
## kafka_disable_num_consumers_limit {#kafka_disable_num_consumers_limit} 



<SettingsInfoBlock type="Bool" default_value="0" />

Отключает ограничение на kafka_num_consumers, которое зависит от количества доступных ядер CPU.
## kafka_max_wait_ms {#kafka_max_wait_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="5000" />

Время ожидания в миллисекундах для чтения сообщений из [Kafka](/engines/table-engines/integrations/kafka) перед повторной попыткой.

Возможные значения:

- Положительное целое число.
- 0 — Бесконечный таймаут.

См. также:

- [Apache Kafka](https://kafka.apache.org/)
## keeper_map_strict_mode {#keeper_map_strict_mode} 



<SettingsInfoBlock type="Bool" default_value="0" />

Принуждает дополнительные проверки во время операций над KeeperMap. Например, выбрасывает исключение при вставке для уже существующего ключа.
## keeper_max_retries {#keeper_max_retries} 



<SettingsInfoBlock type="UInt64" default_value="10" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "10"},{"label": "Max retries for general keeper operations"}]}]}/>

Максимальное количество попыток для общих операций Keeper.
## keeper_retry_initial_backoff_ms {#keeper_retry_initial_backoff_ms} 



<SettingsInfoBlock type="UInt64" default_value="100" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "100"},{"label": "Initial backoff timeout for general keeper operations"}]}]}/>

Начальный таймаут ожидания для общих операций Keeper.
## keeper_retry_max_backoff_ms {#keeper_retry_max_backoff_ms} 



<SettingsInfoBlock type="UInt64" default_value="5000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "5000"},{"label": "Max backoff timeout for general keeper operations"}]}]}/>

Максимальный таймаут ожидания для общих операций Keeper.
## least_greatest_legacy_null_behavior {#least_greatest_legacy_null_behavior} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "0"},{"label": "New setting"}]}]}/>

Если включено, функции 'least' и 'greatest' возвращают NULL, если один из их аргументов равен NULL.
## legacy_column_name_of_tuple_literal {#legacy_column_name_of_tuple_literal} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.7"},{"label": "0"},{"label": "Add this setting only for compatibility reasons. It makes sense to set to 'true', while doing rolling update of cluster from version lower than 21.7 to higher"}]}]}/>

Перечисляет все имена элементов больших литералов кортежей в их именах колонок вместо хеша. Эта настройка существует только для совместимости. Имеет смысл установить на 'true' во время поэтапного обновления кластера с версии ниже 21.7 на более высокую.
## lightweight_delete_mode {#lightweight_delete_mode} 



<SettingsInfoBlock type="LightweightDeleteMode" default_value="alter_update" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "alter_update"},{"label": "A new setting"}]}]}/>

Режим внутреннего обновления запроса, который выполняется как часть легковесного удаления.

Возможные значения:
- `alter_update` - выполнить запрос `ALTER UPDATE`, который создает тяжелую мутацию.
- `lightweight_update` - выполнить легковесное обновление, если возможно, выполнить `ALTER UPDATE` в противном случае.
- `lightweight_update_force` - выполнить легковесное обновление, если возможно, выбросить в противном случае.
## lightweight_deletes_sync {#lightweight_deletes_sync} 



<SettingsInfoBlock type="UInt64" default_value="2" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "2"},{"label": "The same as 'mutation_sync', but controls only execution of lightweight deletes"}]}]}/>

То же, что и [`mutations_sync`](#mutations_sync), но контролирует только выполнение легковесных удалений.

Возможные значения:

| Значение | Описание                                                                                                                                           |
|----------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| `0`      | Мутации выполняются асинхронно.                                                                                                                 |
| `1`      | Запрос ожидает завершения легковесных удалений на текущем сервере.                                                                               |
| `2`      | Запрос ожидает завершения легковесных удалений на всех репликах (если они существуют).                                                           |
| `3`      | Запрос ждет только активные реплики. Поддерживается только для `SharedMergeTree`. Для `ReplicatedMergeTree` ведет себя так же, как `mutations_sync = 2`. |

**См. также**

- [Синхронность ALTER-запросов](../../sql-reference/statements/alter/index.md/#synchronicity-of-alter-queries)
- [Мутации](../../sql-reference/statements/alter/index.md/#mutations)
## limit {#limit} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает максимальное количество строк для получения из результата запроса. Он корректирует значение, установленное оператором [LIMIT](/sql-reference/statements/select/limit), так что лимит, указанный в запросе, не может превышать лимит, установленный этой настройкой.

Возможные значения:

- 0 — Количество строк не ограничено.
- Положительное целое число.
## live_view_heartbeat_interval {#live_view_heartbeat_interval} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Seconds" default_value="15" />

Интервал "сердцебиения" в секундах, указывающий, что live-запрос активен.
## load_balancing {#load_balancing} 



<SettingsInfoBlock type="LoadBalancing" default_value="random" />

Указывает алгоритм выбора реплик, который используется для распределенной обработки запросов.

ClickHouse поддерживает следующие алгоритмы выбора реплик:

- [Случайный](#load_balancing-random) (по умолчанию)
- [Ближайшее имя хоста](#load_balancing-nearest_hostname)
- [Расстояние Левенштейна имен хостов](#load_balancing-hostname_levenshtein_distance)
- [В порядке](#load_balancing-in_order)
- [Первый или случайный](#load_balancing-first_or_random)
- [Круговая проработка](#load_balancing-round_robin)

См. также:

- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)
### Случайный (по умолчанию) {#load_balancing-random}

```sql
load_balancing = random
```

Количество ошибок учитывается для каждой реплики. Запрос отправляется на реплику с наименьшим числом ошибок, и если таких несколько, то на любую из них.
Недостатки: Близость сервера не учитывается; если у реплик разные данные, вы также получите разные данные.
### Ближайшее имя хоста {#load_balancing-nearest_hostname}

```sql
load_balancing = nearest_hostname
```

Количество ошибок учитывается для каждой реплики. Каждые 5 минут общее количество ошибок делится на 2. Таким образом, количество ошибок рассчитывается за недавнее время с экспоненциальным сглаживанием. Если есть одна реплика с минимальным количеством ошибок (т.е. ошибки произошли недавно на других репликах), запрос отправляется на нее. Если есть несколько реплик с одинаковым минимальным количеством ошибок, запрос отправляется на реплику с именем хоста, наиболее похожим на имя сервера в конфигурационном файле (для числа различных символов в идентичных позициях, до минимальной длины обоих имен хостов).

Например, example01-01-1 и example01-01-2 различаются в одной позиции, в то время как example01-01-1 и example01-02-2 различаются в двух местах.
Этот метод может показаться примитивным, но он не требует внешних данных о топологии сети, и не сравнивает IP-адреса, что было бы сложно для наших IPv6 адресов.

Таким образом, если есть эквивалентные реплики, предпочтение отдается ближайшей по имени.
Также можно предположить, что, отправляя запрос тому же серверу, при отсутствии сбоев, распределенный запрос также пойдет на те же серверы. Поэтому, даже если на репликах размещены разные данные, запрос в основном вернет одинаковые результаты.
### Расстояние Левенштейна имен хостов {#load_balancing-hostname_levenshtein_distance}

```sql
load_balancing = hostname_levenshtein_distance
```

Точно так же, как `nearest_hostname`, но сравнивает имя хоста по методу [расстояния Левенштейна](https://en.wikipedia.org/wiki/Levenshtein_distance). Например:

```text
example-clickhouse-0-0 ample-clickhouse-0-0
1

example-clickhouse-0-0 example-clickhouse-1-10
2

example-clickhouse-0-0 example-clickhouse-12-0
3
```
### В порядке {#load_balancing-in_order}

```sql
load_balancing = in_order
```

Реплики с одинаковым количеством ошибок доступны в том же порядке, в котором они указаны в конфигурации.
Этот метод подходит, когда точно известно, какая реплика является предпочтительной.
### Первый или случайный {#load_balancing-first_or_random}

```sql
load_balancing = first_or_random
```

Этот алгоритм выбирает первую реплику в наборе или случайную реплику, если первая недоступна. Он эффективен в конфигурациях перекрестной репликации, но бесполезен в других конфигурациях.

Алгоритм `first_or_random` решает проблему алгоритма `in_order`. С `in_order`, если одна реплика выходит из строя, следующая получает двойную нагрузку, в то время как оставшиеся реплики обрабатывают обычный объем трафика. При использовании алгоритма `first_or_random` нагрузка равномерно распределяется среди реплик, которые все еще доступны.

Можно явно определить, какая реплика является первой, используя настройку `load_balancing_first_offset`. Это дает больше контроля для перераспределения нагрузки запросов между репликами.
### Круговая проработка {#load_balancing-round_robin}

```sql
load_balancing = round_robin
```

Этот алгоритм использует политику круговой проработки по репликам с одинаковым количеством ошибок (учитываются только запросы с политикой `round_robin`).
## load_balancing_first_offset {#load_balancing_first_offset} 



<SettingsInfoBlock type="UInt64" default_value="0" />

На какую реплику предпочтительно отправить запрос при использовании стратегии балансировки нагрузки FIRST_OR_RANDOM.
## load_marks_asynchronously {#load_marks_asynchronously} 



<SettingsInfoBlock type="Bool" default_value="0" />

Загрузка меток MergeTree асинхронно.
## local_filesystem_read_method {#local_filesystem_read_method} 



<SettingsInfoBlock type="String" default_value="pread_threadpool" />

Метод чтения данных из локальной файловой системы, один из: read, pread, mmap, io_uring, pread_threadpool.

Метод 'io_uring' является экспериментальным и не работает для Log, TinyLog, StripeLog, File, Set и Join, а также других таблиц с прилагаемыми файлами в случае одновременных чтений и записей.
Если вы читаете различные статьи о 'io_uring' в Интернете, не поддавайтесь им. Это не лучший метод чтения файлов, за исключением случая большого количества мелких IO запросов, что не относится к ClickHouse. Нет причин включать 'io_uring'.
## local_filesystem_read_prefetch {#local_filesystem_read_prefetch} 



<SettingsInfoBlock type="Bool" default_value="0" />

Следует использовать предварительную выборку при чтении данных из локальной файловой системы.
## lock_acquire_timeout {#lock_acquire_timeout} 



<SettingsInfoBlock type="Seconds" default_value="120" />

Определяет, сколько секунд запрос блокировки ждет, прежде чем завершиться ошибкой.

Таймаут блокировки используется для защиты от взаимных блокировок при выполнении операций чтения/записи с таблицами. Когда таймаут истекает и запрос блокировки завершается неудачно, сервер ClickHouse выбрасывает исключение "Таймаут попытки блокировки! Вероятно, избегнута взаимная блокировка. Клиент должен повторить попытку." с кодом ошибки `DEADLOCK_AVOIDED`.

Возможные значения:

- Положительное целое число (в секундах).
- 0 — Нет таймаута блокировки.
## log_comment {#log_comment} 

Указывает значение для поля `log_comment` таблицы [system.query_log](../system-tables/query_log.md) и текст комментария для серверного лога.

Это может быть использовано для улучшения читаемости серверных логов. Кроме того, это помогает выбрать запросы, относящиеся к тесту, из `system.query_log` после выполнения [clickhouse-test](../../development/tests.md).

Возможные значения:

- Любая строка длиной не более [max_query_size](#max_query_size). Если максимальный размер запроса превышен, сервер выбрасывает исключение.

**Пример**

Запрос:

```sql
SET log_comment = 'log_comment test', log_queries = 1;
SELECT 1;
SYSTEM FLUSH LOGS;
SELECT type, query FROM system.query_log WHERE log_comment = 'log_comment test' AND event_date >= yesterday() ORDER BY event_time DESC LIMIT 2;
```

Результат:

```text
┌─type────────┬─query─────┐
│ QueryStart  │ SELECT 1; │
│ QueryFinish │ SELECT 1; │
└─────────────┴───────────┘
```
## log_formatted_queries {#log_formatted_queries} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает логировать отформатированные запросы в системную таблицу [system.query_log](../../operations/system-tables/query_log.md) (заполняет колонку `formatted_query` в [system.query_log](../../operations/system-tables/query_log.md)).

Возможные значения:

- 0 — Отформатированные запросы не логируются в системной таблице.
- 1 — Отформатированные запросы логируются в системной таблице.
## log_processors_profiles {#log_processors_profiles} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Enable by default"}]}]}/>

Записывает время, затраченное процессором во время выполнения/ожидания данных, в таблицу `system.processors_profile_log`.

См. также:

- [`system.processors_profile_log`](../../operations/system-tables/processors_profile_log.md)
- [`EXPLAIN PIPELINE`](../../sql-reference/statements/explain.md/#explain-pipeline)
## log_profile_events {#log_profile_events} 



<SettingsInfoBlock type="Bool" default_value="1" />

Логирует статистику производительности запросов в query_log, query_thread_log и query_views_log.
## log_queries {#log_queries} 



<SettingsInfoBlock type="Bool" default_value="1" />

Настройка логирования запросов.

Запросы, отправленные в ClickHouse с этой настройкой, логируются в соответствии с правилами параметра конфигурации сервера [query_log](../../operations/server-configuration-parameters/settings.md/#query_log).

Пример:

```text
log_queries=1
```
## log_queries_cut_to_length {#log_queries_cut_to_length} 



<SettingsInfoBlock type="UInt64" default_value="100000" />

Если длина запроса превышает заданный порог (в байтах), то обрезать запрос при записи в журнал запросов. Также ограничить длину напечатанного запроса в обычном текстовом журнале.
## log_queries_min_query_duration_ms {#log_queries_min_query_duration_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="0" />

Если включено (больше нуля), запросы, которые быстрее значения этой настройки, не будут логироваться (вы можете рассматривать это как `long_query_time` для [MySQL Slow Query Log](https://dev.mysql.com/doc/refman/5.7/slow-query-log.html)), и это, по сути, означает, что вы не найдете их в следующих таблицах:

- `system.query_log`
- `system.query_thread_log`

Только запросы следующего типа попадут в журнал:

- `QUERY_FINISH`
- `EXCEPTION_WHILE_PROCESSING`

- Тип: миллисекунды
- Значение по умолчанию: 0 (любой запрос)
## log_queries_min_type {#log_queries_min_type} 



<SettingsInfoBlock type="LogQueriesType" default_value="QUERY_START" />

Минимальный тип `query_log` для логирования.

Возможные значения:
- `QUERY_START` (`=1`)
- `QUERY_FINISH` (`=2`)
- `EXCEPTION_BEFORE_START` (`=3`)
- `EXCEPTION_WHILE_PROCESSING` (`=4`)

Может быть использован для ограничения того, какие сущности попадут в `query_log`, например если вас интересуют только ошибки, тогда вы можете использовать `EXCEPTION_WHILE_PROCESSING`:

```text
log_queries_min_type='EXCEPTION_WHILE_PROCESSING'
```
## log_queries_probability {#log_queries_probability} 



<SettingsInfoBlock type="Float" default_value="1" />

Позволяет пользователю записывать в системные таблицы [query_log](../../operations/system-tables/query_log.md), [query_thread_log](../../operations/system-tables/query_thread_log.md) и [query_views_log](../../operations/system-tables/query_views_log.md) только выборку запросов, выбранных случайным образом с заданной вероятностью. Это помогает снизить нагрузку при большом объеме запросов в секунду.

Возможные значения:

- 0 — Запросы не логируются в системных таблицах.
- Положительное дробное число в диапазоне [0..1]. Например, если значение настройки равно `0.5`, около половины запросов логируются в системных таблицах.
- 1 — Все запросы логируются в системных таблицах.
## log_query_settings {#log_query_settings} 



<SettingsInfoBlock type="Bool" default_value="1" />

Логирует настройки запроса в query_log и журнал спанов OpenTelemetry.
## log_query_threads {#log_query_threads} 



<SettingsInfoBlock type="Bool" default_value="0" />

Настройка логирования потоков запросов.

Потоки запросов логируются в таблицу [system.query_thread_log](../../operations/system-tables/query_thread_log.md). Эта настройка имеет эффект только когда [log_queries](#log_queries) истина. Потоки запросов, выполняемые ClickHouse с этой настройкой, логируются в соответствии с правилами параметра конфигурации сервера [query_thread_log](/operations/server-configuration-parameters/settings#query_thread_log).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

**Пример**

```text
log_query_threads=1
```
## log_query_views {#log_query_views} 



<SettingsInfoBlock type="Bool" default_value="1" />

Настройка логирования представлений запросов.

Когда запрос, выполняемый ClickHouse с этой настройкой включенной, имеет связанные представления (материализованные или live представления), они логируются в параметре конфигурации сервера [query_views_log](/operations/server-configuration-parameters/settings#query_views_log).

Пример:

```text
log_query_views=1
```
## low_cardinality_allow_in_native_format {#low_cardinality_allow_in_native_format} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешает или ограничивает использование типа данных [LowCardinality](../../sql-reference/data-types/lowcardinality.md) с форматом [Native](../../interfaces/formats.md/#native).

Если использование `LowCardinality` ограничено, сервер ClickHouse преобразует колонки `LowCardinality` в обычные для запросов `SELECT`, и преобразует обычные колонки в колонки `LowCardinality` для запросов `INSERT`.

Эта настройка необходима в основном для сторонних клиентов, которые не поддерживают тип данных `LowCardinality`.

Возможные значения:

- 1 — Использование `LowCardinality` не ограничено.
- 0 — Использование `LowCardinality` ограничено.
## low_cardinality_max_dictionary_size {#low_cardinality_max_dictionary_size} 



<SettingsInfoBlock type="UInt64" default_value="8192" />

Устанавливает максимальный размер в строках общего глобального словаря для типа данных [LowCardinality](../../sql-reference/data-types/lowcardinality.md), который может быть записан в файловую систему хранения. Эта настройка предотвращает проблемы с ОЗУ в случае неограниченного роста словаря. Все данные, которые не могут быть закодированы из-за ограничения максимального размера словаря, ClickHouse записывает обычным способом.

Возможные значения:

- Любое положительное целое число.
## low_cardinality_use_single_dictionary_for_part {#low_cardinality_use_single_dictionary_for_part} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает использование одного словаря для части данных.

По умолчанию сервер ClickHouse отслеживает размер словарей, и если словарь переполнен, сервер начинает записывать следующий. Чтобы запретить создание нескольких словарей, установите `low_cardinality_use_single_dictionary_for_part = 1`.

Возможные значения:

- 1 — Создание нескольких словарей для части данных запрещено.
- 0 — Создание нескольких словарей для части данных не запрещено.
## low_priority_query_wait_time_ms {#low_priority_query_wait_time_ms} 

<BetaBadge/>



<SettingsInfoBlock type="Milliseconds" default_value="1000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1000"},{"label": "New setting."}]}]}/>

Когда механизм приоритизации запросов используется (см. настройку `priority`), запросы с низким приоритетом ждут завершения запросов с более высоким приоритетом. Эта настройка указывает продолжительность ожидания.
## make_distributed_plan {#make_distributed_plan} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "New experimental setting."}]}]}/>

Создать распределенный план запроса.
## materialize_skip_indexes_on_insert {#materialize_skip_indexes_on_insert} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Added new setting to allow to disable materialization of skip indexes on insert"}]}]}/>

Если INSERT создает и сохраняет индексы пропуска. Если отключено, индексы пропуска будут создаваться и сохраняться только [в процессе слияния](merge-tree-settings.md/#materialize_skip_indexes_on_merge) или по явному [MATERIALIZE INDEX](/sql-reference/statements/alter/skipping-index.md/#materialize-index).

См. также [exclude_materialize_skip_indexes_on_insert](#exclude_materialize_skip_indexes_on_insert).
## materialize_statistics_on_insert {#materialize_statistics_on_insert} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Added new setting to allow to disable materialization of statistics on insert"}]}]}/>

Если INSERT создает и сохраняет статистику. Если отключено, статистика будет создаваться и сохраняться во время слияний или по явному MATERIALIZE STATISTICS.
## materialize_ttl_after_modify {#materialize_ttl_after_modify} 



<SettingsInfoBlock type="Bool" default_value="1" />

Применить TTL для старых данных после выполнения запроса ALTER MODIFY TTL.
## materialized_views_ignore_errors {#materialized_views_ignore_errors} 



<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет игнорировать ошибки для МАТЕРИАЛИЗОВАННОГО ВИДА и доставлять оригинальный блок в таблицу независимо от MV.
## materialized_views_squash_parallel_inserts {#materialized_views_squash_parallel_inserts} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "1"},{"label": "Added setting to preserve old behavior if needed."}]}]}/>

Сжимает вставки в целевую таблицу материаловидов одного запроса INSERT из параллельных вставок, чтобы уменьшить количество создаваемых частей.
Если установлено в false и включена `parallel_view_processing`, запрос INSERT создаст часть в целевой таблице для каждого `max_insert_thread`.
## max_analyze_depth {#max_analyze_depth} 



<SettingsInfoBlock type="UInt64" default_value="5000" />

Максимальное количество анализов, выполняемых интерпретатором.
## max_ast_depth {#max_ast_depth} 



<SettingsInfoBlock type="UInt64" default_value="1000" />

Максимальная глубина вложенности синтаксического дерева запроса. Если превышена, выдается исключение.

:::note
На данный момент это не проверяется во время парсинга, а только после парсинга запроса.
Это означает, что слишком глубокое синтаксическое дерево может быть создано во время парсинга,
но запрос завершится неудачно.
:::
## max_ast_elements {#max_ast_elements} 



<SettingsInfoBlock type="UInt64" default_value="50000" />

Максимальное количество элементов в синтаксическом дереве запроса. Если превышено, выдается исключение.

:::note
На данный момент это не проверяется во время парсинга, а только после парсинга запроса.
Это означает, что слишком глубокое синтаксическое дерево может быть создано во время парсинга,
но запрос завершится неудачно.
:::
## max_autoincrement_series {#max_autoincrement_series} 



<SettingsInfoBlock type="UInt64" default_value="1000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1000"},{"label": "A new setting"}]}]}/>

Ограничение на количество последовательностей, созданных функцией `generateSeriesID`.

Поскольку каждая последовательность представляет собой узел в Keeper, рекомендуется не иметь более нескольких миллионов из них.
## max_backup_bandwidth {#max_backup_bandwidth} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость чтения в байтах в секунду для конкретного резервного копирования на сервере. Ноль означает без ограничений.
## max_block_size {#max_block_size} 



<SettingsInfoBlock type="NonZeroUInt64" default_value="65409" />

В ClickHouse данные обрабатываются блоками, которые представляют собой наборы частей колонок. Внутренние циклы обработки для одного блока эффективны, но при обработке каждого блока есть заметные затраты.

Настройка `max_block_size` указывает рекомендуемое максимальное количество строк, включаемых в один блок при загрузке данных из таблиц. Блоки размером `max_block_size` не всегда загружаются из таблицы: если ClickHouse определяет, что меньше данных нужно извлекать, обрабатывается меньший блок.

Размер блока не должен быть слишком маленьким, чтобы избежать заметных затрат при обработке каждого блока. Он также не должен быть слишком большим, чтобы обеспечить быструю обработку запросов с оператором LIMIT после обработки первого блока. При установке `max_block_size` цель должна заключаться в том, чтобы избежать чрезмерного потребления памяти при извлечении большого числа колонок в нескольких потоках и сохранить хотя бы некоторую локальность кэша.
## max_bytes_before_external_group_by {#max_bytes_before_external_group_by} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Облачное значение по умолчанию: половина объема памяти на реплику.

Включает или отключает выполнение операторов `GROUP BY` во внешней памяти.
(См. [GROUP BY во внешней памяти](/sql-reference/statements/select/group-by#group-by-in-external-memory))

Возможные значения:

- Максимальный объем ОЗУ (в байтах), который может быть использован одним оператором [GROUP BY](/sql-reference/statements/select/group-by).
- `0` — `GROUP BY` во внешней памяти отключен.

:::note
Если использование памяти во время операций GROUP BY превышает этот порог в байтах,
активируйте режим 'внешней агрегации' (сбросьте данные на диск).

Рекомендуемое значение составляет половину доступной системной памяти.
:::
## max_bytes_before_external_sort {#max_bytes_before_external_sort} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Облачное значение по умолчанию: половина объема памяти на реплику.

Включает или отключает выполнение операторов `ORDER BY` во внешней памяти. См. [Подробности реализации ORDER BY](../../sql-reference/statements/select/order-by.md#implementation-details)
Если использование памяти во время выполнения операции ORDER BY превышает этот порог в байтах, активируется режим 'внешней сортировки' (сброс данных на диск).

Возможные значения:

- Максимальный объем ОЗУ (в байтах), который может быть использован одним оператором [ORDER BY](../../sql-reference/statements/select/order-by.md).
  Рекомендуемое значение — половина доступной системной памяти.
- `0` — `ORDER BY` во внешней памяти отключен.
## max_bytes_before_remerge_sort {#max_bytes_before_remerge_sort} 



<SettingsInfoBlock type="UInt64" default_value="1000000000" />

В случае ORDER BY с LIMIT, когда использование памяти превышает указанный порог, выполняйте дополнительные шаги слияния блоков перед окончательным слиянием, чтобы сохранить только верхние LIMIT строки.
## max_bytes_in_distinct {#max_bytes_in_distinct} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт состояния (в несжатых байтах) в памяти, которые
используются хеш-таблицей при использовании DISTINCT.
## max_bytes_in_join {#max_bytes_in_join} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный размер в байтах хеш-таблицы, используемой при соединении таблиц.

Эта настройка применяется к операциям [SELECT ... JOIN](/sql-reference/statements/select/join)
и движку таблицы [Join](/engines/table-engines/special/join).

Если запрос содержит соединения, ClickHouse проверяет эту настройку для каждого промежуточного результата.

ClickHouse может продолжать выполнять разные действия, когда лимит достигнут. Используйте
настройки [join_overflow_mode](/operations/settings/settings#join_overflow_mode), чтобы выбрать действие.

Возможные значения:

- Положительное целое число.
- 0 — Контроль памяти отключен.
## max_bytes_in_set {#max_bytes_in_set} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт (несжатых данных), используемых множеством в IN-клаузе,
созданном из подзапроса.
## max_bytes_ratio_before_external_group_by {#max_bytes_ratio_before_external_group_by} 



<SettingsInfoBlock type="Double" default_value="0.5" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0.5"},{"label": "Enable automatic spilling to disk by default."}]}, {"id": "row-2","items": [{"label": "24.12"},{"label": "0"},{"label": "New setting."}]}]}/>

Соотношение доступной памяти, разрешённое для `GROUP BY`. После достижения этого порога
используется внешняя память для агрегации.

Например, если установлено на `0.6`, `GROUP BY` будет позволять использовать 60% доступной памяти
(для сервера/пользователя/слияний) в начале выполнения, после этого он начнет использовать внешнюю агрегацию.
## max_bytes_ratio_before_external_sort {#max_bytes_ratio_before_external_sort} 



<SettingsInfoBlock type="Double" default_value="0.5" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0.5"},{"label": "Enable automatic spilling to disk by default."}]}, {"id": "row-2","items": [{"label": "24.12"},{"label": "0"},{"label": "New setting."}]}]}/>

Соотношение доступной памяти, разрешённое для `ORDER BY`. После достижения этого порога используется внешняя сортировка.

Например, если установлено на `0.6`, `ORDER BY` будет позволять использовать 60% доступной памяти (для сервера/пользователя/слияний) в начале выполнения, после этого он начнет использовать внешнюю сортировку.

Обратите внимание, что `max_bytes_before_external_sort` все еще учитывается, сброс на диск будет выполнен только если сортировочный блок больше, чем `max_bytes_before_external_sort`.
## max_bytes_to_read {#max_bytes_to_read} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт (несжатых данных), которые могут быть прочитаны из таблицы при выполнении запроса.
Ограничение проверяется для каждого обработанного куска данных, применяется только к
самому глубокому выражению таблицы и при чтении с удаленного сервера проверяется только на
удаленном сервере.
## max_bytes_to_read_leaf {#max_bytes_to_read_leaf} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт (несжатых данных), которые могут быть прочитаны из локальной
таблицы на узле-листе при выполнении распределенного запроса. В то время как распределенные запросы
могут выдавать несколько подзапросов к каждой шарде (листву) - этот лимит
будет проверяться только на этапе чтения на узлах-листах и будет игнорироваться на этапе объединения результатов на корневом узле.

Например, кластер состоит из 2 шард и каждая шард содержит таблицу с
100 байт данных. Распределенный запрос, который должен прочитать все данные
из обеих таблиц с настройкой `max_bytes_to_read=150` завершится неудачно, так как в сумме это
будет 200 байт. Запрос с `max_bytes_to_read_leaf=150` будет успешным, так как
узлы-листы прочитают максимум 100 байт.

Ограничение проверяется для каждого обработанного куска данных.

:::note
Эта настройка нестабильна с `prefer_localhost_replica=1`.
:::
## max_bytes_to_sort {#max_bytes_to_sort} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт до сортировки. Если больше указанного количества
несжатых байт должно быть обработано для операции ORDER BY, поведение будет
определяться `sort_overflow_mode`, который по умолчанию установлен на `throw`.
## max_bytes_to_transfer {#max_bytes_to_transfer} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт (несжатых данных), которые могут быть переданы удаленному
серверу или сохранены во временной таблице, когда выполняется секция GLOBAL IN/JOIN.
## max_columns_to_read {#max_columns_to_read} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество колонок, которые могут быть прочитаны из таблицы в одном запросе.
Если запрос требует чтения более чем указанного количества колонок, выбрасывается исключение.

:::tip
Эта настройка полезна для предотвращения чрезмерно сложных запросов.
:::

Значение `0` означает без ограничений.
## max_compress_block_size {#max_compress_block_size} 



<SettingsInfoBlock type="UInt64" default_value="1048576" />

Максимальный размер блоков несжатых данных перед сжатием для записи в таблицу. По умолчанию 1,048,576 (1 МБ). Указание меньшего размера блока обычно приводит к немного меньшему коэффициенту сжатия, скорость сжатия и распаковки немного увеличивается благодаря локальности кэша, а потребление памяти снижается.

:::note
Это настройка уровня экспертов, и вам не следует изменять её, если вы только начинаете работать с ClickHouse.
:::

Не путайте блоки для сжатия (кусок памяти, состоящий из байтов) с блоками для обработки запросов (набор строк из таблицы).
## max_concurrent_queries_for_all_users {#max_concurrent_queries_for_all_users} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Выбрасывает исключение, если значение этой настройки меньше или равно текущему количеству одновременно обрабатываемых запросов.

Пример: `max_concurrent_queries_for_all_users` может быть установлено на 99 для всех пользователей, а администратор базы данных может установить его на 100 для себя, чтобы выполнять запросы для расследования, даже когда сервер перегружен.

Изменение настройки для одного запроса или пользователя не влияет на другие запросы.

Возможные значения:

- Положительное целое число.
- 0 — Нет ограничений.

**Пример**

```xml
<max_concurrent_queries_for_all_users>99</max_concurrent_queries_for_all_users>
```

**См. также**

- [max_concurrent_queries](/operations/server-configuration-parameters/settings#max_concurrent_queries)
## max_concurrent_queries_for_user {#max_concurrent_queries_for_user} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество одновременно обрабатываемых запросов на пользователя.

Возможные значения:

- Положительное целое число.
- 0 — Нет ограничений.

**Пример**

```xml
<max_concurrent_queries_for_user>5</max_concurrent_queries_for_user>
```
## max_distributed_connections {#max_distributed_connections} 

<SettingsInfoBlock type="UInt64" default_value="1024" />

Максимальное количество одновременных соединений с удалёнными серверами для распределённой обработки одного запроса к одной распределённой таблице. Рекомендуется устанавливать значение не меньше, чем количество серверов в кластере.

Следующие параметры используются только при создании распределённых таблиц (и при запуске сервера), поэтому нет необходимости изменять их во время выполнения.
## max_distributed_depth {#max_distributed_depth} 

<SettingsInfoBlock type="UInt64" default_value="5" />

Ограничивает максимальную глубину рекурсивных запросов для [распределённых](../../engines/table-engines/special/distributed.md) таблиц.

Если значение превышено, сервер выбрасывает исключение.

Допустимые значения:

- Положительное целое число.
- 0 — Неограниченная глубина.
## max_download_buffer_size {#max_download_buffer_size} 

<SettingsInfoBlock type="UInt64" default_value="10485760" />

Максимальный размер буфера для параллельной загрузки (например, для URL-движка) для каждого потока.
## max_download_threads {#max_download_threads} 

<SettingsInfoBlock type="MaxThreads" default_value="4" />

Максимальное количество потоков для загрузки данных (например, для URL-движка).
## max_estimated_execution_time {#max_estimated_execution_time} 

<SettingsInfoBlock type="Seconds" default_value="0" />

Максимальное оценочное время выполнения запроса в секундах. Проверяется для каждого блока данных, когда истекает [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed).
## max_execution_speed {#max_execution_speed} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк, обрабатываемых в секунду. Проверяется для каждого блока данных, когда истекает [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed). Если скорость выполнения высока, скорость выполнения будет снижена.
## max_execution_speed_bytes {#max_execution_speed_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт, обрабатываемых в секунду. Проверяется для каждого блока данных, когда истекает [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed). Если скорость выполнения высока, скорость выполнения будет снижена.
## max_execution_time {#max_execution_time} 

<SettingsInfoBlock type="Seconds" default_value="0" />

Максимальное время выполнения запроса в секундах.

Параметр `max_execution_time` может быть немного сложным для понимания. Он работает на основе интерполяции относительно текущей скорости выполнения запроса (это поведение контролируется [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)).

ClickHouse прерывает запрос, если ожидаемое время выполнения превышает заданное `max_execution_time`. По умолчанию `timeout_before_checking_execution_speed` установлен на 10 секунд. Это означает, что после 10 секунд выполнения запроса ClickHouse начнёт оценивать общее время выполнения. Если, например, `max_execution_time` установлен на 3600 секунд (1 час), ClickHouse завершит запрос, если ожидаемое время превысит этот лимит в 3600 секунд. Если вы установите `timeout_before_checking_execution_speed` в 0, ClickHouse будет использовать текущее время как основу для `max_execution_time`.

Если время выполнения запроса превышает указанное количество секунд, поведение будет определяться 'timeout_overflow_mode', который по умолчанию установлен на `throw`.

:::note
Таймаут проверяется, и запрос может быть остановлен только в определённых местах во время обработки данных. В настоящее время он не может быть остановлен во время объединения состояний агрегации или во время анализа запроса, и фактическое время выполнения будет выше значения этой настройки.
:::
## max_execution_time_leaf {#max_execution_time_leaf} 

<SettingsInfoBlock type="Seconds" default_value="0" />

Семантически аналогично [`max_execution_time`](#max_execution_time), но применяется только на конечных узлах для распределённых или удалённых запросов.

Например, если мы хотим ограничить время выполнения на конечном узле до `10s`, но не хотим устанавливать лимит на начальном узле, вместо того чтобы иметь `max_execution_time` в настройках вложенного подзапроса:

```sql
SELECT count()
FROM cluster(cluster, view(SELECT * FROM t SETTINGS max_execution_time = 10));
```

Мы можем использовать `max_execution_time_leaf` как настройки запроса:

```sql
SELECT count()
FROM cluster(cluster, view(SELECT * FROM t)) SETTINGS max_execution_time_leaf = 10;
```
## max_expanded_ast_elements {#max_expanded_ast_elements} 

<SettingsInfoBlock type="UInt64" default_value="500000" />

Максимальный размер синтаксического дерева запроса в количестве узлов после расширения псевдонимов и звёздочки.
## max_fetch_partition_retries_count {#max_fetch_partition_retries_count} 

<SettingsInfoBlock type="UInt64" default_value="5" />

Количество попыток при получении партиции с другого хоста.
## max_final_threads {#max_final_threads} 

<SettingsInfoBlock type="MaxThreads" default_value="'auto(N)'" />

Устанавливает максимальное число параллельных потоков для фазы чтения данных запроса `SELECT` с модификатором [FINAL](/sql-reference/statements/select/from#final-modifier).

Допустимые значения:

- Положительное целое число.
- 0 или 1 — Отключено. Запросы `SELECT` выполняются в одном потоке.
## max_http_get_redirects {#max_http_get_redirects} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество перенаправлений HTTP GET, разрешённых. Обеспечивает дополнительные меры безопасности, чтобы предотвратить возможность злонамеренного сервера перенаправлять ваши запросы на неожиданные сервисы.\n\nЭто происходит, когда внешний сервер перенаправляет на другой адрес, но этот адрес кажется внутренним для инфраструктуры компании, и отправив HTTP-запрос на внутренний сервер, вы можете запросить внутренний API из внутренней сети, минуя аутентификацию, или даже запрашивать другие сервисы, такие как Redis или Memcached. Когда у вас нет внутренней инфраструктуры (включая что-то, работающие на вашем локальном компьютере), или вы доверяете серверу, безопасно разрешить перенаправления. Хотя имейте в виду, что если URL использует HTTP вместо HTTPS, вам придётся доверять не только удалённому серверу, но и вашему провайдеру интернет-услуг и всем сетям посередине.
## max_hyperscan_regexp_length {#max_hyperscan_regexp_length} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Определяет максимальную длину каждого регулярного выражения в [многошаблонных функциях hyperscan](/sql-reference/functions/string-search-functions#multimatchany).

Допустимые значения:

- Положительное целое число.
- 0 - Длина не ограничена.

**Пример**

Запрос:

```sql
SELECT multiMatchAny('abcd', ['ab','bcd','c','d']) SETTINGS max_hyperscan_regexp_length = 3;
```

Результат:

```text
┌─multiMatchAny('abcd', ['ab', 'bcd', 'c', 'd'])─┐
│                                              1 │
└────────────────────────────────────────────────┘
```

Запрос:

```sql
SELECT multiMatchAny('abcd', ['ab','bcd','c','d']) SETTINGS max_hyperscan_regexp_length = 2;
```

Результат:

```text
Exception: Regexp length too large.
```

**Смотрите также**

- [max_hyperscan_regexp_total_length](#max_hyperscan_regexp_total_length)
## max_hyperscan_regexp_total_length {#max_hyperscan_regexp_total_length} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает максимальную общую длину всех регулярных выражений в каждой [многошаблонной функции hyperscan](/sql-reference/functions/string-search-functions#multimatchany).

Допустимые значения:

- Положительное целое число.
- 0 - Длина не ограничена.

**Пример**

Запрос:

```sql
SELECT multiMatchAny('abcd', ['a','b','c','d']) SETTINGS max_hyperscan_regexp_total_length = 5;
```

Результат:

```text
┌─multiMatchAny('abcd', ['a', 'b', 'c', 'd'])─┐
│                                           1 │
└─────────────────────────────────────────────┘
```

Запрос:

```sql
SELECT multiMatchAny('abcd', ['ab','bc','c','d']) SETTINGS max_hyperscan_regexp_total_length = 5;
```

Результат:

```text
Exception: Total regexp lengths too large.
```

**Смотрите также**

- [max_hyperscan_regexp_length](#max_hyperscan_regexp_length)
## max_insert_block_size {#max_insert_block_size} 

<SettingsInfoBlock type="NonZeroUInt64" default_value="1048449" />

Размер блоков (в количестве строк), которые формируются для вставки в таблицу. Эта настройка применяется только в случаях, когда сервер формирует блоки. Например, для INSERT через HTTP-интерфейс сервер разбирает формат данных и формирует блоки заданного размера. Но при использовании clickhouse-client клиент сам разбирает данные, и настройка 'max_insert_block_size' на сервере не влияет на размер вставляемых блоков. Эта настройка также не имеет смысла при использовании INSERT SELECT, так как данные вставляются с использованием тех же блоков, которые формируются после SELECT.

По умолчанию это немного больше, чем `max_block_size`. Причина этого в том, что определённые движки таблиц (`*MergeTree`) формируют часть данных на диске для каждого вставленного блока, который является достаточно большим объектом. Аналогичным образом, таблицы `*MergeTree` сортируют данные во время вставки, и достаточно большой размер блока позволяет сортировать больше данных в оперативной памяти.
## max_insert_delayed_streams_for_parallel_write {#max_insert_delayed_streams_for_parallel_write} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество потоков (колонок) для задержки окончательной выгрузки части. По умолчанию - авто (100 в случае, если базовая система хранения поддерживает параллельную запись, например S3, и отключена в противном случае)
## max_insert_threads {#max_insert_threads} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество потоков для выполнения запроса `INSERT SELECT`.

Допустимые значения:

- 0 (или 1) — `INSERT SELECT` без параллельного выполнения.
- Положительное целое число. Больше 1.

Облачное значение по умолчанию:
- `1` для узлов с 8 ГиБ памяти
- `2` для узлов с 16 ГиБ памяти
- `4` для более крупных узлов

Параллельный `INSERT SELECT` влияет только в том случае, если часть `SELECT` выполняется параллельно, см. настройку [`max_threads`](#max_threads). Более высокие значения приведут к большему использованию памяти.
## max_joined_block_size_bytes {#max_joined_block_size_bytes} 

<SettingsInfoBlock type="UInt64" default_value="4194304" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "4194304"},{"label": "New setting"}]}]}/>

Максимальный размер блока в байтах для результата JOIN (если алгоритм объединения это поддерживает). 0 означает неограниченный.
## max_joined_block_size_rows {#max_joined_block_size_rows} 

<SettingsInfoBlock type="UInt64" default_value="65409" />

Максимальный размер блока для результата JOIN (если алгоритм объединения это поддерживает). 0 означает неограниченный.
## max_limit_for_vector_search_queries {#max_limit_for_vector_search_queries} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1000"},{"label": "New setting"}]}]}/>

Запросы SELECT с LIMIT больше, чем это значение, не могут использовать векторные индексы сходства. Помогает предотвратить переполнение памяти в индексах векторного сходства.
## max_live_view_insert_blocks_before_refresh {#max_live_view_insert_blocks_before_refresh} 

<ExperimentalBadge/>

<SettingsInfoBlock type="UInt64" default_value="64" />

Ограничивает максимальное количество вставленных блоков, после которых объединяемые блоки сбрасываются, и запрос выполняется повторно.
## max_local_read_bandwidth {#max_local_read_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость локального чтения в байтах в секунду.
## max_local_write_bandwidth {#max_local_write_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость локальной записи в байтах в секунду.
## max_memory_usage {#max_memory_usage} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Облачное значение по умолчанию: зависит от объёма ОЗУ на реплике.

Максимальное количество оперативной памяти для использования при выполнении запроса на одном сервере. Значение `0` означает неограниченное.

Эта настройка не учитывает объём доступной памяти или общий объём памяти на машине. Ограничение применяется к одному запросу на одном сервере.

Вы можете использовать `SHOW PROCESSLIST`, чтобы увидеть текущее потребление памяти для каждого запроса. Пиковое потребление памяти отслеживается для каждого запроса и записывается в журнал.

Использование памяти не отслеживается полностью для состояний следующих агрегатных функций с аргументами `String` и `Array`:
- `min`
- `max`
- `any`
- `anyLast`
- `argMin`
- `argMax`

Потребление памяти также ограничивается параметрами [`max_memory_usage_for_user`](/operations/settings/settings#max_memory_usage_for_user)
и [`max_server_memory_usage`](/operations/server-configuration-parameters/settings#max_server_memory_usage).
## max_memory_usage_for_user {#max_memory_usage_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество оперативной памяти для использования при выполнении пользовательских запросов на одном сервере. Ноль означает неограниченное.

По умолчанию количество не ограничено (`max_memory_usage_for_user = 0`).

См. также описание [`max_memory_usage`](/operations/settings/settings#max_memory_usage).

Например, если вы хотите установить `max_memory_usage_for_user` на 1000 байт для пользователя с именем `clickhouse_read`, вы можете использовать оператор

```sql
ALTER USER clickhouse_read SETTINGS max_memory_usage_for_user = 1000;
```

Вы можете проверить, что это сработало, выйдя из вашего клиента, войдя снова, а затем используя функцию `getSetting`:

```sql
SELECT getSetting('max_memory_usage_for_user');
```
## max_network_bandwidth {#max_network_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает скорость обмена данными по сети в байтах в секунду. Эта настройка применяется к каждому запросу.

Допустимые значения:

- Положительное целое число.
- 0 — Контроль пропускной способности отключен.
## max_network_bandwidth_for_all_users {#max_network_bandwidth_for_all_users} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает скорость, с которой данные обмениваются по сети в байтах в секунду. Эта настройка применяется ко всем одновременно выполняемым запросам на сервере.

Допустимые значения:

- Положительное целое число.
- 0 — Контроль скорости передачи данных отключен.
## max_network_bandwidth_for_user {#max_network_bandwidth_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает скорость обмена данными по сети в байтах в секунду. Эта настройка применяется ко всем одновременно выполняемым запросам, выполняемым одним пользователем.

Допустимые значения:

- Положительное целое число.
- 0 — Контроль скорости передачи данных отключен.
## max_network_bytes {#max_network_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает объём данных (в байтах), которые принимаются или отправляются по сети при выполнении запроса. Эта настройка применяется к каждому отдельному запросу.

Допустимые значения:

- Положительное целое число.
- 0 — Контроль объёма данных отключен.
## max_number_of_partitions_for_independent_aggregation {#max_number_of_partitions_for_independent_aggregation} 

<SettingsInfoBlock type="UInt64" default_value="128" />

Максимальное количество партиций в таблице для применения оптимизации.
## max_os_cpu_wait_time_ratio_to_throw {#max_os_cpu_wait_time_ratio_to_throw} 

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Setting values were changed and backported to 25.4"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "New setting"}]}]}/>

Максимальное соотношение между временем ожидания CPU ОС (метрика OSCPUWaitMicroseconds) и временем занятия (метрика OSCPUVirtualTimeMicroseconds), чтобы рассмотреть возможность отклонения запросов. Линейная интерполяция между минимальным и максимальным соотношением используется для расчёта вероятности, вероятность равна 1 в этом случае.
## max_parallel_replicas {#max_parallel_replicas} 

<SettingsInfoBlock type="NonZeroUInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1000"},{"label": "Use up to 1000 parallel replicas by default."}]}]}/>

Максимальное количество реплик для каждой шардовой части при выполнении запроса.

Допустимые значения:

- Положительное целое число.

**Дополнительная информация**

Эта опция будет давать разные результаты в зависимости от используемых настроек.

:::note
Эта настройка даст некорректные результаты, когда вовлечены соединения или подзапросы, и все таблицы не соответствуют определённым требованиям. См. [Распределённые подзапросы и max_parallel_replicas](/operations/settings/settings#max_parallel_replicas) для получения дополнительных деталей.
:::
### Параллельная обработка с использованием ключа `SAMPLE`

Запрос может обрабатываться быстрее, если он выполняется параллельно на нескольких серверах. Но производительность запроса может ухудшиться в следующих случаях:

- Положение ключа выборки в ключе партиционирования не позволяет эффективно выполнять диапазонные сканирования.
- Добавление ключа выборки в таблицу делает фильтрацию по другим столбцам менее эффективной.
- Ключ выборки является выражением, которое дорого вычислять.
- Распределение задержек кластера имеет длинный хвост, так что опрос большего количества серверов увеличивает общую задержку запроса.
### Параллельная обработка с использованием [parallel_replicas_custom_key](#parallel_replicas_custom_key)

Эта настройка полезна для любой реплицированной таблицы.
## max_parser_backtracks {#max_parser_backtracks} 

<SettingsInfoBlock type="UInt64" default_value="1000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1000000"},{"label": "Limiting the complexity of parsing"}]}]}/>

Максимально допустимое количество попыток возврата парсера (сколько раз он пробует различные альтернативы в процессе рекурсивного разбиения на подчасти).
## max_parser_depth {#max_parser_depth} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Ограничивает максимальную глубину рекурсии в рекурсивном парсере. Позволяет контролировать размер стека.

Допустимые значения:

- Положительное целое число.
- 0 — Глубина рекурсии не ограничена.
## max_parsing_threads {#max_parsing_threads} 

<SettingsInfoBlock type="MaxThreads" default_value="'auto(N)'" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "0"},{"label": "Add a separate setting to control number of threads in parallel parsing from files"}]}]}/>

Максимальное количество потоков для разбора данных в форматах ввода, которые поддерживают параллельный разбор. По умолчанию определяется автоматически.
## max_partition_size_to_drop {#max_partition_size_to_drop} 

<SettingsInfoBlock type="UInt64" default_value="50000000000" />

Ограничение на удаление партиций во время выполнения запроса. Значение `0` означает, что вы можете удалять партиции без каких-либо ограничений.

Облачное значение по умолчанию: 1 ТБ.

:::note
Эта настройка запроса переопределяет эквивалент серверной настройки, см. [max_partition_size_to_drop](/operations/server-configuration-parameters/settings#max_partition_size_to_drop)
:::
## max_partitions_per_insert_block {#max_partitions_per_insert_block} 

<SettingsInfoBlock type="UInt64" default_value="100" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "19.5"},{"label": "100"},{"label": "Add a limit for the number of partitions in one block"}]}]}/>

Ограничивает максимальное количество партиций в одном вставленном блоке и выбрасывает исключение, если блок содержит слишком много партиций.

- Положительное целое число.
- `0` — Неограниченное количество партиций.

**Подробнее**

При вставке данных ClickHouse вычисляет число партиций в вставленном блоке. Если число партиций больше, чем `max_partitions_per_insert_block`, ClickHouse либо записывает предупреждение, либо выбрасывает исключение в зависимости от `throw_on_max_partitions_per_insert_block`. Исключения имеют следующий текст:

> "Слишком много партиций для одного блока INSERT (`partitions_count` партиций, лимит " + toString(max_partitions) + "). Лимит контролируется настройкой 'max_partitions_per_insert_block'. Большое количество партиций — это распространённое заблуждение. Это приведёт к серьёзным негативным последствиям для производительности, включая медленный запуск сервера, медленные запросы INSERT и медленные запросы SELECT. Рекомендуемое общее число партиций для таблицы составляет менее 1000..10000. Учтите, что партиционирование не предназначено для ускорения запросов SELECT (ORDER BY ключ достаточно, чтобы сделать диапазонные запросы быстрыми). Партиции предназначены для манипуляции данными (DROP PARTITION и т.д.)."

:::note
Эта настройка является «порогом безопасности», потому что использование большого количества партиций — распространённое заблуждение.
:::
## max_partitions_to_read {#max_partitions_to_read} 

<SettingsInfoBlock type="Int64" default_value="-1" />

Ограничивает максимальное количество партиций, к которым можно получить доступ в одном запросе.

Значение настройки, указанное при создании таблицы, может быть переопределено на уровне запроса.

Допустимые значения:

- Положительное целое число
- `-1` - неограниченный (по умолчанию)

:::note
Вы также можете указать настройку MergeTree [`max_partitions_to_read`](/operations/settings/settings#max_partitions_to_read) в настройках таблиц.
:::
## max_parts_to_move {#max_parts_to_move} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1000"},{"label": "New setting"}]}]}/>

Ограничивает количество частей, которые могут быть перемещены в одном запросе. Ноль означает неограниченное.
## max_query_size {#max_query_size} 

<SettingsInfoBlock type="UInt64" default_value="262144" />

Максимальное количество байт строки запроса, обрабатываемой SQL парсером. Данные в операторе VALUES запросов INSERT обрабатываются отдельным потоковым парсером (который использует O(1) ОЗУ) и не подвержены этому ограничению.

:::note
`max_query_size` не может быть установлен в рамках SQL-запроса (например, `SELECT now() SETTINGS max_query_size=10000`), так как ClickHouse должен выделить буфер для разбора запроса, и размер этого буфера определяется настройкой `max_query_size`, которая должна быть сконфигурирована до выполнения запроса.
:::
## max_read_buffer_size {#max_read_buffer_size} 

<SettingsInfoBlock type="NonZeroUInt64" default_value="1048576" />

Максимальный размер буфера для чтения с файловой системы.
## max_read_buffer_size_local_fs {#max_read_buffer_size_local_fs} 

<SettingsInfoBlock type="UInt64" default_value="131072" />

Максимальный размер буфера для чтения с локальной файловой системы. Если установлено в 0, будет использован max_read_buffer_size.
## max_read_buffer_size_remote_fs {#max_read_buffer_size_remote_fs} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный размер буфера для чтения с удалённой файловой системы. Если установлено в 0, будет использован max_read_buffer_size.
## max_recursive_cte_evaluation_depth {#max_recursive_cte_evaluation_depth} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "1000"},{"label": "Maximum limit on recursive CTE evaluation depth"}]}]}/>

Максимальный лимит глубины оценки рекурсивного CTE.
## max_remote_read_network_bandwidth {#max_remote_read_network_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость обмена данными по сети в байтах в секунду для чтения.
## max_remote_write_network_bandwidth {#max_remote_write_network_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость обмена данными по сети в байтах в секунду для записи.
## max_replica_delay_for_distributed_queries {#max_replica_delay_for_distributed_queries} 

<SettingsInfoBlock type="UInt64" default_value="300" />

Отключает задержки реплик для распределённых запросов. См. [Репликация](../../engines/table-engines/mergetree-family/replication.md).

Устанавливает время в секундах. Если задержка реплики превышает или равна установленному значению, эта реплика не используется.

Допустимые значения:

- Положительное целое число.
- 0 — Задержки репликации не проверяются.

Чтобы предотвратить использование любой реплики с ненулевой задержкой, установите этот параметр на 1.

Используется при выполнении `SELECT` из распределённой таблицы, которая указывает на реплицированные таблицы.
## max_result_bytes {#max_result_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает размер результата в байтах (не сжатый). Запрос будет остановлен после обработки блока данных, если достигается порог, но он не будут обрезать последний блок результата, поэтому размер результата может быть больше порога.

**Замечания**

Размер результата в памяти принимается во внимание для этого порога. Даже если размер результата мал, он может ссылаться на более крупные структуры данных в памяти, представляющие словари столбцов LowCardinality и арены столбцов AggregateFunction, поэтому порог может быть превышен, несмотря на небольшой размер результата.

:::warning
Настройка имеет довольно низкий уровень и должна использоваться с осторожностью.
:::
## max_result_rows {#max_result_rows} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Облачное значение по умолчанию: `0`.

Ограничивает количество строк в результате. Также проверяется для подзапросов и на удалённых серверах при выполнении частей распределённого запроса. Нет ограничения, если значение равно `0`.

Запрос будет остановлен после обработки блока данных, если достигается порог, но он не будут обрезать последний блок результата, поэтому размер результата может быть больше порога.
## max_rows_in_distinct {#max_rows_in_distinct} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество различных строк при использовании DISTINCT.
## max_rows_in_join {#max_rows_in_join} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает количество строк в хеш-таблице, используемой при объединении таблиц.

Эти настройки применяются к операциям [SELECT ... JOIN](/sql-reference/statements/select/join) и движку таблиц [Join](/engines/table-engines/special/join).

Если запрос содержит несколько объединений, ClickHouse проверяет эту настройку для каждого промежуточного результата.

ClickHouse может выполнить разные действия, когда лимит достигается. Используйте настройку [`join_overflow_mode`](/operations/settings/settings#join_overflow_mode), чтобы выбрать действие.

Допустимые значения:

- Положительное целое число.
- `0` — Неограниченное количество строк.
## max_rows_in_set {#max_rows_in_set} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк для набора данных в операторе IN, созданном из подзапроса.
## max_rows_in_set_to_optimize_join {#max_rows_in_set_to_optimize_join} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Disable join optimization as it prevents from read in order optimization"}]}]}/>

Максимально допустимый размер набора для фильтрации объединённых таблиц по наборам строк друг друга перед объединением.

Допустимые значения:

- 0 — Отключить.
- Любое положительное целое число.
## max_rows_to_group_by {#max_rows_to_group_by} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество уникальных ключей, получаемых из агрегации. Эта настройка позволяет ограничить потребление памяти при агрегировании.

Если агрегация во время GROUP BY генерирует больше указанного количества строк (уникальных ключей GROUP BY), поведение будет определяться 'group_by_overflow_mode', который по умолчанию установлен на `throw`, но также может быть переключен в приблизительный режим GROUP BY.
## max_rows_to_read {#max_rows_to_read} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк, которые можно прочитать из таблицы при выполнении запроса. Ограничение проверяется для каждого обрабатываемого блока данных, применяется только к самому глубокому выражению таблицы и при чтении с удалённого сервера, проверяется только на удалённом сервере.
## max_rows_to_read_leaf {#max_rows_to_read_leaf} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк, которые можно прочитать из локальной таблицы на конечном узле при выполнении распределённого запроса. Хотя распределённые запросы могут отправлять несколько подзапросов на каждую шард (лист) – этот лимит будет проверяться только на этапе чтения на конечных узлах и игнорироваться на этапе объединения результатов на корневом узле.

Например, кластер состоит из 2 шарда, и каждый шард содержит таблицу с 100 строками. Распределённый запрос, который должен прочитать все данные из обеих таблиц с настройкой `max_rows_to_read=150`, будет неудачным, так как в общем будет 200 строк. Запрос с `max_rows_to_read_leaf=150` будет успешным, так как конечные узлы будут читать максимум 100 строк.

Ограничение проверяется для каждого обрабатываемого блока данных.

:::note
Эта настройка нестабильна с `prefer_localhost_replica=1`.
:::
## max_rows_to_sort {#max_rows_to_sort} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк перед сортировкой. Это позволяет вам ограничить потребление памяти при сортировке. Если больше указанного количества записей должно быть обработано для операции ORDER BY, поведение будет определяться `sort_overflow_mode`, который по умолчанию установлен на `throw`.
## max_rows_to_transfer {#max_rows_to_transfer} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный размер (в строках), который можно передать удалённому серверу или сохранить во временной таблице при выполнении раздела GLOBAL IN/JOIN.
## max_sessions_for_user {#max_sessions_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество одновременных сессий для каждого аутентифицированного пользователя на сервере ClickHouse.

Пример:

```xml
<profiles>
    <single_session_profile>
        <max_sessions_for_user>1</max_sessions_for_user>
    </single_session_profile>
    <two_sessions_profile>
        <max_sessions_for_user>2</max_sessions_for_user>
    </two_sessions_profile>
    <unlimited_sessions_profile>
        <max_sessions_for_user>0</max_sessions_for_user>
    </unlimited_sessions_profile>
</profiles>
<users>
    <!-- User Alice can connect to a ClickHouse server no more than once at a time. -->
    <Alice>
        <profile>single_session_user</profile>
    </Alice>
    <!-- User Bob can use 2 simultaneous sessions. -->
    <Bob>
        <profile>two_sessions_profile</profile>
    </Bob>
    <!-- User Charles can use arbitrarily many of simultaneous sessions. -->
    <Charles>
        <profile>unlimited_sessions_profile</profile>
    </Charles>
</users>
```

Допустимые значения:
- Положительное целое число
- `0` - бесконечное количество одновременных сессий (по умолчанию)
## max_size_to_preallocate_for_aggregation {#max_size_to_preallocate_for_aggregation} 

<SettingsInfoBlock type="UInt64" default_value="1000000000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "1000000000000"},{"label": "Enable optimisation for bigger tables."}]}, {"id": "row-2","items": [{"label": "22.12"},{"label": "100000000"},{"label": "This optimizes performance"}]}]}/>

На сколько элементов разрешено заранее выделять место во всех хеш-таблицах в целом перед агрегацией.
## max_size_to_preallocate_for_joins {#max_size_to_preallocate_for_joins} 

<SettingsInfoBlock type="UInt64" default_value="1000000000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "100000000"},{"label": "New setting."}]}, {"id": "row-2","items": [{"label": "24.12"},{"label": "1000000000000"},{"label": "Enable optimisation for bigger tables."}]}]}/>

На сколько элементов разрешено заранее выделять место во всех хеш-таблицах в целом перед объединением.
## max_streams_for_merge_tree_reading {#max_streams_for_merge_tree_reading} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если не равно нулю, ограничивает количество потоков чтения для таблицы MergeTree.
## max_streams_multiplier_for_merge_tables {#max_streams_multiplier_for_merge_tables} 

<SettingsInfoBlock type="Float" default_value="5" />

Запрашивает больше потоков при чтении из объединяющей таблицы. Потоки будут распределены по таблицам, которые будет использовать объединяющая таблица. Это позволяет более равномерно распределить работу между потоками и особенно полезно, когда объединяемые таблицы различаются по размеру.
## max_streams_to_max_threads_ratio {#max_streams_to_max_threads_ratio} 

<SettingsInfoBlock type="Float" default_value="1" />

Позволяет использовать больше источников, чем количество потоков — для более равномерного распределения работы между потоками. Предполагается, что это временное решение, так как в будущем возможно сделать количество источников равным количеству потоков, но для каждого источника динамически выбирать доступную работу для себя.
## max_subquery_depth {#max_subquery_depth} 

<SettingsInfoBlock type="UInt64" default_value="100" />

Если в запросе больше указанного количества вложенных подзапросов, выбрасывает исключение.

:::tip
Это позволяет вам провести проверку на разумность, чтобы защитить пользователей вашего кластера от написания слишком сложных запросов.
:::
## max_table_size_to_drop {#max_table_size_to_drop} 

<SettingsInfoBlock type="UInt64" default_value="50000000000" />

Ограничение на удаление таблиц во время выполнения запроса. Значение `0` означает, что вы можете удалить все таблицы без ограничений.

Облачное значение по умолчанию: 1 ТБ.

:::note
Эта настройка запроса переопределяет эквивалент серверной настройки, см. [max_table_size_to_drop](/operations/server-configuration-parameters/settings#max_table_size_to_drop)
:::
## max_temporary_columns {#max_temporary_columns} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество временных колонок, которые должны храниться в оперативной памяти одновременно при выполнении запроса, включая постоянные колонки. Если запрос генерирует больше указанного количества временных колонок в памяти в результате промежуточных вычислений, выбрасывается исключение.

:::tip
Эта настройка полезна для предотвращения слишком сложных запросов.
:::

Значение `0` означает неограниченное количество.
## max_temporary_data_on_disk_size_for_query {#max_temporary_data_on_disk_size_for_query} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный объём данных, потребляемых временными файлами на диске в байтах для всех одновременно выполняемых запросов.

Допустимые значения:

- Положительное целое число.
- `0` — неограниченное (по умолчанию).
## max_temporary_data_on_disk_size_for_user {#max_temporary_data_on_disk_size_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный объём данных, потребляемых временными файлами на диске в байтах для всех одновременно выполняемых пользовательских запросов.

Допустимые значения:

- Положительное целое число.
- `0` — неограниченное (по умолчанию).
## max_temporary_non_const_columns {#max_temporary_non_const_columns} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Как `max_temporary_columns`, максимальное количество временных колонок, которые должны храниться в оперативной памяти одновременно при выполнении запроса, но без учёта постоянных колонок.

:::note
Постоянные колонки формируются довольно часто при выполнении запроса, но они требуют практически нулевых вычислительных ресурсов.
:::
## max_threads {#max_threads} 

<SettingsInfoBlock type="MaxThreads" default_value="'auto(N)'" />

Максимальное количество потоков обработки запроса, исключая потоки для получения данных с удалённых серверов (см. параметр 'max_distributed_connections').

Этот параметр относится к потокам, которые выполняют одни и те же стадии конвейера обработки запросов параллельно. Например, при чтении из таблицы, если возможно оценить выражения с функциями, фильтровать с помощью WHERE и предварительно агрегировать для GROUP BY параллельно, используя по крайней мере 'max_threads' количество потоков, то используются 'max_threads'.

Для запросов, которые завершаются быстро из-за LIMIT, вы можете установить более низкое значение 'max_threads'. Например, если необходимое количество записей находится в каждом блоке, и max_threads = 8, то извлекаются 8 блоков, хотя было бы достаточно прочитать только один.

Чем меньше значение `max_threads`, тем меньше используется память.

Облачное значение по умолчанию: `auto(3)`.
## max_threads_for_indexes {#max_threads_for_indexes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество потоков для обработки индексов.
## max_untracked_memory {#max_untracked_memory} 

<SettingsInfoBlock type="UInt64" default_value="4194304" />

Небольшие выделения и освобождения группируются в локальной переменной потока и отслеживаются или профилируются только тогда, когда сумма (в абсолютном значении) становится больше указанного значения. Если значение выше 'memory_profiler_step', оно будет эффективно снижено до 'memory_profiler_step'.
## memory_overcommit_ratio_denominator {#memory_overcommit_ratio_denominator} 

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.5"},{"label": "1073741824"},{"label": "Enable memory overcommit feature by default"}]}]}/>

Это представление мягкого предела памяти, когда на глобальном уровне достигается жёсткий предел. Это значение используется для вычисления коэффициента перерасхода для запроса. Ноль означает пропуск запроса. Подробнее о [перерасходе памяти](memory-overcommit.md).
## memory_overcommit_ratio_denominator_for_user {#memory_overcommit_ratio_denominator_for_user} 



<SettingsInfoBlock type="UInt64" default_value="1073741824" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.5"},{"label": "1073741824"},{"label": "Enable memory overcommit feature by default"}]}]}/>

Он представляет собой мягкий предел памяти, когда жесткий предел достигнут на уровне пользователя.
Это значение используется для вычисления коэффициента перерасхода памяти для запроса.
Ноль означает пропустить запрос.
Читать дальше о [перерасходе памяти](memory-overcommit.md).
## memory_profiler_sample_max_allocation_size {#memory_profiler_sample_max_allocation_size} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Собирает случайные распределения размера меньше или равного указанному значению с вероятностью, равной `memory_profiler_sample_probability`. 0 означает отключено. Возможно, вам нужно установить 'max_untracked_memory' в 0, чтобы этот порог работал как ожидается.
## memory_profiler_sample_min_allocation_size {#memory_profiler_sample_min_allocation_size} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Собирает случайные распределения размера больше или равного указанному значению с вероятностью, равной `memory_profiler_sample_probability`. 0 означает отключено. Возможно, вам нужно установить 'max_untracked_memory' в 0, чтобы этот порог работал как ожидается.
## memory_profiler_sample_probability {#memory_profiler_sample_probability} 



<SettingsInfoBlock type="Float" default_value="0" />

Собирает случайные выделения и освобождения памяти и записывает их в system.trace_log с типом трассировки 'MemorySample'. Вероятность применяется для каждого выделения/освобождения независимо от размера выделения (может быть изменена с помощью `memory_profiler_sample_min_allocation_size` и `memory_profiler_sample_max_allocation_size`). Обратите внимание, что выборка происходит только тогда, когда количество неслеженной памяти превышает 'max_untracked_memory'. Возможно, вам нужно установить 'max_untracked_memory' в 0 для более тонкого выбора.
## memory_profiler_step {#memory_profiler_step} 



<SettingsInfoBlock type="UInt64" default_value="4194304" />

Устанавливает шаг профайлера памяти. Когда использование памяти запроса превышает каждый следующий шаг в байтах, профайлер памяти соберет трассировку стека выделения и запишет ее в [trace_log](/operations/system-tables/trace_log).

Возможные значения:

- Положительное целое число в байтах.

- 0 для отключения профайлера памяти.
## memory_tracker_fault_probability {#memory_tracker_fault_probability} 



<SettingsInfoBlock type="Float" default_value="0" />

Для тестирования `безопасности исключений` - выбросить исключение каждый раз, когда вы выделяете память с указанной вероятностью.
## memory_usage_overcommit_max_wait_microseconds {#memory_usage_overcommit_max_wait_microseconds} 



<SettingsInfoBlock type="UInt64" default_value="5000000" />

Максимальное время, которое поток будет ждать, чтобы память была освобождена в случае перерасхода памяти на уровне пользователя.
Если таймаут превышен и память не освобождена, выбрасывается исключение.
Читать дальше о [перерасходе памяти](memory-overcommit.md).
## merge_table_max_tables_to_look_for_schema_inference {#merge_table_max_tables_to_look_for_schema_inference} 



<SettingsInfoBlock type="UInt64" default_value="1000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1000"},{"label": "A new setting"}]}]}/>

При создании `Merge` таблицы без явной схемы или при использовании табличной функции `merge`, определить схему как объединение не более указанного количества соответствующих таблиц.
Если существует большее количество таблиц, схема будет определена из первых указанного количества таблиц.
## merge_tree_coarse_index_granularity {#merge_tree_coarse_index_granularity} 



<SettingsInfoBlock type="UInt64" default_value="8" />

При поиске данных ClickHouse проверяет метки данных в файле индекса. Если ClickHouse обнаруживает, что необходимые ключи находятся в каком-то диапазоне, он делит этот диапазон на `merge_tree_coarse_index_granularity` поддиапазоны и рекурсивно ищет необходимые ключи там.

Возможные значения:

- Любое положительное четное целое число.
## merge_tree_compact_parts_min_granules_to_multibuffer_read {#merge_tree_compact_parts_min_granules_to_multibuffer_read} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="UInt64" default_value="16" />

Имеет эффект только в ClickHouse Cloud. Количество гранул в полосе компактной части таблиц MergeTree, которые используют многобуферный считыватель, который поддерживает параллельное чтение и предвыборку. В случае чтения из удаленной файловой системы использование многобуферного считывателя увеличивает количество запросов на чтение.
## merge_tree_determine_task_size_by_prewhere_columns {#merge_tree_determine_task_size_by_prewhere_columns} 



<SettingsInfoBlock type="Bool" default_value="1" />

Следует ли использовать только размер столбцов prewhere для определения размера задачи чтения.
## merge_tree_max_bytes_to_use_cache {#merge_tree_max_bytes_to_use_cache} 



<SettingsInfoBlock type="UInt64" default_value="2013265920" />

Если ClickHouse должен читать более `merge_tree_max_bytes_to_use_cache` байт за один запрос, он не использует кеш не сжатых блоков.

Кеш не сжатых блоков хранит данные, извлеченные для запросов. ClickHouse использует этот кеш для ускорения ответов на повторяющиеся небольшие запросы. Эта настройка защищает кеш от разрушения запросами, которые читают большой объем данных. Настройка сервера [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) определяет размер кеша не сжатых блоков.

Возможные значения:

- Любое положительное целое число.
## merge_tree_max_rows_to_use_cache {#merge_tree_max_rows_to_use_cache} 



<SettingsInfoBlock type="UInt64" default_value="1048576" />

Если ClickHouse должен читать более `merge_tree_max_rows_to_use_cache` строк за один запрос, он не использует кеш не сжатых блоков.

Кеш не сжатых блоков хранит данные, извлеченные для запросов. ClickHouse использует этот кеш для ускорения ответов на повторяющиеся небольшие запросы. Эта настройка защищает кеш от разрушения запросами, которые читают большой объем данных. Настройка сервера [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) определяет размер кеша не сжатых блоков.

Возможные значения:

- Любое положительное целое число.
## merge_tree_min_bytes_for_concurrent_read {#merge_tree_min_bytes_for_concurrent_read} 



<SettingsInfoBlock type="UInt64" default_value="251658240" />

Если количество байтов, которые нужно прочитать из одного файла таблицы [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) превышает `merge_tree_min_bytes_for_concurrent_read`, то ClickHouse пытается прочитать этот файл параллельно в нескольких потоках.

Возможное значение:

- Положительное целое число.
## merge_tree_min_bytes_for_concurrent_read_for_remote_filesystem {#merge_tree_min_bytes_for_concurrent_read_for_remote_filesystem} 



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Setting is deprecated"}]}]}/>

Минимальное количество байтов для чтения из одного файла перед тем, как движок [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) сможет параллелизировать чтение, при чтении из удаленной файловой системы. Мы не рекомендуем использовать эту настройку.

Возможные значения:

- Положительное целое число.
## merge_tree_min_bytes_for_seek {#merge_tree_min_bytes_for_seek} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Если расстояние между двумя блоками данных, которые нужно прочитать в одном файле, меньше чем `merge_tree_min_bytes_for_seek` байт, то ClickHouse последовательно читает диапазон файла, который содержит оба блока, избегая таким образом дополнительных переходов.

Возможные значения:

- Любое положительное целое число.
## merge_tree_min_bytes_per_task_for_remote_reading {#merge_tree_min_bytes_per_task_for_remote_reading} 



<SettingsInfoBlock type="UInt64" default_value="2097152" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "2097152"},{"label": "Value is unified with `filesystem_prefetch_min_bytes_for_single_read_task`"}]}]}/>

Минимальные байты для чтения на задачу.
## merge_tree_min_read_task_size {#merge_tree_min_read_task_size} 



<SettingsInfoBlock type="NonZeroUInt64" default_value="8" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "8"},{"label": "New setting"}]}]}/>

Жесткий нижний предел на размер задачи (даже когда количество гранул низкое и количество доступных потоков высокое, мы не будем выделять меньшие задачи).
## merge_tree_min_rows_for_concurrent_read {#merge_tree_min_rows_for_concurrent_read} 



<SettingsInfoBlock type="UInt64" default_value="163840" />

Если количество строк для чтения из файла таблицы [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) превышает `merge_tree_min_rows_for_concurrent_read`, то ClickHouse пытается выполнить параллельное чтение из этого файла в нескольких потоках.

Возможные значения:

- Положительное целое число.
## merge_tree_min_rows_for_concurrent_read_for_remote_filesystem {#merge_tree_min_rows_for_concurrent_read_for_remote_filesystem} 



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Setting is deprecated"}]}]}/>

Минимальное количество строк для чтения из одного файла перед тем, как движок [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) сможет параллелизировать чтение, при чтении из удаленной файловой системы. Мы не рекомендуем использовать эту настройку.

Возможные значения:

- Положительное целое число.
## merge_tree_min_rows_for_seek {#merge_tree_min_rows_for_seek} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Если расстояние между двумя блоками данных, которые нужно прочитать в одном файле, меньше чем `merge_tree_min_rows_for_seek` строк, тогда ClickHouse не производит переходов по файлу, а читает данные последовательно.

Возможные значения:

- Любое положительное целое число.
## merge_tree_read_split_ranges_into_intersecting_and_non_intersecting_injection_probability {#merge_tree_read_split_ranges_into_intersecting_and_non_intersecting_injection_probability} 



<SettingsInfoBlock type="Float" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "For testing of `PartsSplitter` - split read ranges into intersecting and non intersecting every time you read from MergeTree with the specified probability."}]}]}/>

Для тестирования `PartsSplitter` - разделять режимы чтения на пересекающиеся и непересекающиеся каждый раз при чтении из MergeTree с указанной вероятностью.
## merge_tree_storage_snapshot_sleep_ms {#merge_tree_storage_snapshot_sleep_ms} 



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "0"},{"label": "A new setting to debug storage snapshot consistency in query"}]}]}/>

Инъецировать искусственную задержку (в миллисекундах) при создании снимка хранилища для таблиц MergeTree.
Используется только для тестирования и отладки.

Возможные значения:
- 0 - Без задержки (по умолчанию)
- N - Задержка в миллисекундах
## merge_tree_use_const_size_tasks_for_remote_reading {#merge_tree_use_const_size_tasks_for_remote_reading} 



<SettingsInfoBlock type="Bool" default_value="1" />

Следует ли использовать задачи постоянного размера для чтения из удаленной таблицы.
## merge_tree_use_deserialization_prefixes_cache {#merge_tree_use_deserialization_prefixes_cache} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "A new setting to control the usage of deserialization prefixes cache in MergeTree"}]}]}/>

Включает кеширование метаданных столбцов из префиксов файлов при чтении с удаленных дисков в MergeTree.
## merge_tree_use_prefixes_deserialization_thread_pool {#merge_tree_use_prefixes_deserialization_thread_pool} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "A new setting controlling the usage of the thread pool for parallel prefixes deserialization in MergeTree"}]}]}/>

Включает использование пула потоков для параллельного чтения префиксов в широких частях в MergeTree. Размер этого пула потоков контролируется настройкой сервера `max_prefixes_deserialization_thread_pool_size`.
## merge_tree_use_v1_object_and_dynamic_serialization {#merge_tree_use_v1_object_and_dynamic_serialization} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Add new serialization V2 version for JSON and Dynamic types"}]}]}/>

Когда включено, будет использоваться версия серийной передачи V1 для типов JSON и Dynamic в MergeTree вместо V2. Изменение этой настройки вступает в силу только после перезапуска сервера.
## metrics_perf_events_enabled {#metrics_perf_events_enabled} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, некоторые из событий производительности будут измеряться в процессе выполнения запросов.
## metrics_perf_events_list {#metrics_perf_events_list} 

Список метрик производительности, разделенных запятыми, которые будут измеряться в процессе выполнения запросов. Пустой означает все события. См. PerfEventInfo в источниках для доступных событий.
## min_bytes_to_use_direct_io {#min_bytes_to_use_direct_io} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальный объем данных, необходимый для использования прямого доступа к накопителю.

ClickHouse использует эту настройку при чтении данных из таблиц. Если общий объем хранения всех данных, которые нужно прочитать, превышает `min_bytes_to_use_direct_io` байт, то ClickHouse считывает данные с диска хранения с опцией `O_DIRECT`.

Возможные значения:

- 0 — Прямое ввод-вывод отключено.
- Положительное целое число.
## min_bytes_to_use_mmap_io {#min_bytes_to_use_mmap_io} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Это экспериментальная настройка. Устанавливает минимальное количество памяти для чтения больших файлов без копирования данных из ядра в пользовательское пространство. Рекомендуемый порог составляет около 64 МБ, потому что [mmap/munmap](https://en.wikipedia.org/wiki/Mmap) медленно. Это имеет смысл только для больших файлов и помогает только если данные находятся в кэше страниц.

Возможные значения:

- Положительное целое число.
- 0 — Большие файлы читаются только с копированием данных из ядра в пользовательское пространство.
## min_chunk_bytes_for_parallel_parsing {#min_chunk_bytes_for_parallel_parsing} 



<SettingsInfoBlock type="NonZeroUInt64" default_value="10485760" />

- Тип: целое число без знака
- Значение по умолчанию: 1 МБ

Минимальный размер фрагмента в байтах, который каждый поток будет анализировать параллельно.
## min_compress_block_size {#min_compress_block_size} 



<SettingsInfoBlock type="UInt64" default_value="65536" />

Для таблиц [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md). Чтобы уменьшить задержку при обработке запросов, блок сжимается при записи следующей метки, если его размер составляет по крайней мере `min_compress_block_size`. По умолчанию, 65,536.

Фактический размер блока, если не сжатые данные меньше чем `max_compress_block_size`, не меньше этого значения и не меньше объема данных для одной метки.

Рассмотрим пример. Предположим, `index_granularity` была установлена на 8192 при создании таблицы.

Мы пишем колонку типа UInt32 (4 байта на значение). При записи 8192 строк, в сумме будет 32 КБ данных. Поскольку min_compress_block_size = 65,536, сжатый блок будет формироваться для каждых двух меток.

Мы пишем колонку URL с типом String (средний размер 60 байт на значение). При записи 8192 строк, в среднем будет чуть меньше 500 КБ данных. Поскольку это больше 65,536, сжатый блок будет формироваться для каждой метки. В этом случае, при чтении данных с диска в диапазоне одной метки, дополнительные данные не будут распакованы.

:::note
Это настройка на экспертном уровне, и вам не следует изменять ее, если вы только начинаете работать с ClickHouse.
:::
## min_count_to_compile_aggregate_expression {#min_count_to_compile_aggregate_expression} 



<SettingsInfoBlock type="UInt64" default_value="3" />

Минимальное количество одинаковых агрегатных выражений для запуска JIT-компиляции. Работает только если включена настройка [compile_aggregate_expressions](#compile_aggregate_expressions).

Возможные значения:

- Положительное целое число.
- 0 — Одинаковые агрегатные выражения всегда JIT-компилируются.
## min_count_to_compile_expression {#min_count_to_compile_expression} 



<SettingsInfoBlock type="UInt64" default_value="3" />

Минимальное количество исполнений одного и того же выражения перед его компиляцией.
## min_count_to_compile_sort_description {#min_count_to_compile_sort_description} 



<SettingsInfoBlock type="UInt64" default_value="3" />

Количество идентичных описаний сортировки перед их JIT-компиляцией.
## min_execution_speed {#min_execution_speed} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальная скорость выполнения в строках в секунду. Проверяется на каждом блоке данных, когда
[`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)
истекает. Если скорость выполнения ниже, выбрасывается исключение.
## min_execution_speed_bytes {#min_execution_speed_bytes} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальное количество выполняемых байтов в секунду. Проверяется на каждом блоке данных, когда
[`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)
истекает. Если скорость выполнения ниже, выбрасывается исключение.
## min_external_table_block_size_bytes {#min_external_table_block_size_bytes} 



<SettingsInfoBlock type="UInt64" default_value="268402944" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "268402944"},{"label": "Squash blocks passed to external table to specified size in bytes, if blocks are not big enough."}]}]}/>

Сжимать блоки, передаваемые во внешнюю таблицу, до указанного размера в байтах, если блоки недостаточно велики.
## min_external_table_block_size_rows {#min_external_table_block_size_rows} 



<SettingsInfoBlock type="UInt64" default_value="1048449" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1048449"},{"label": "Squash blocks passed to external table to specified size in rows, if blocks are not big enough"}]}]}/>

Сжимать блоки, передаваемые во внешнюю таблицу, до указанного размера в строках, если блоки недостаточно велики.
## min_free_disk_bytes_to_perform_insert {#min_free_disk_bytes_to_perform_insert} 



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Maintain some free disk space bytes from inserts while still allowing for temporary writing."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "0"},{"label": "New setting."}]}]}/>

Минимально свободное дисковое пространство в байтах для выполнения вставки.
## min_free_disk_ratio_to_perform_insert {#min_free_disk_ratio_to_perform_insert} 



<SettingsInfoBlock type="Float" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Maintain some free disk space bytes expressed as ratio to total disk space from inserts while still allowing for temporary writing."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "0"},{"label": "New setting."}]}]}/>

Минимальное соотношение свободного места на диске для выполнения вставки.
## min_free_disk_space_for_temporary_data {#min_free_disk_space_for_temporary_data} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальное дисковое пространство, которое необходимо сохранять при записи временных данных, используемых во внешней сортировке и агрегации.
## min_hit_rate_to_use_consecutive_keys_optimization {#min_hit_rate_to_use_consecutive_keys_optimization} 



<SettingsInfoBlock type="Float" default_value="0.5" />

Минимальный коэффициент попаданий кеша, который используется для оптимизации последовательных ключей в агрегации, чтобы он оставался включенным.
## min_insert_block_size_bytes {#min_insert_block_size_bytes} 



<SettingsInfoBlock type="UInt64" default_value="268402944" />

Устанавливает минимальное количество байтов в блоке, который может быть вставлен в таблицу с помощью запроса `INSERT`. Блоки меньшего размера сжимаются в более крупные.

Возможные значения:

- Положительное целое число.
- 0 — Сжатие отключено.
## min_insert_block_size_bytes_for_materialized_views {#min_insert_block_size_bytes_for_materialized_views} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает минимальное количество байтов в блоке, который может быть вставлен в таблицу с помощью запроса `INSERT`. Блоки меньшего размера сжимаются в более крупные. Эта настройка применяется только для блоков, вставляемых в [материализованное представление](../../sql-reference/statements/create/view.md). Настраивая эту настройку, вы контролируете сжатие блоков при отправке в материализованное представление и избегаете чрезмерного использования памяти.

Возможные значения:

- Любое положительное целое число.
- 0 — Сжатие отключено.

**См. также**

- [min_insert_block_size_bytes](#min_insert_block_size_bytes)
## min_insert_block_size_rows {#min_insert_block_size_rows} 



<SettingsInfoBlock type="UInt64" default_value="1048449" />

Устанавливает минимальное количество строк в блоке, который может быть вставлен в таблицу с помощью запроса `INSERT`. Блоки меньшего размера сжимаются в более крупные.

Возможные значения:

- Положительное целое число.
- 0 — Сжатие отключено.
## min_insert_block_size_rows_for_materialized_views {#min_insert_block_size_rows_for_materialized_views} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает минимальное количество строк в блоке, который может быть вставлен в таблицу с помощью запроса `INSERT`. Блоки меньшего размера сжимаются в более крупные. Эта настройка применяется только для блоков, вставляемых в [материализованное представление](../../sql-reference/statements/create/view.md). Настраивая эту настройку, вы контролируете сжатие блоков при отправке в материализованное представление и избегаете чрезмерного использования памяти.

Возможные значения:

- Любое положительное целое число.
- 0 — Сжатие отключено.

**См. также**

- [min_insert_block_size_rows](#min_insert_block_size_rows)
## min_joined_block_size_bytes {#min_joined_block_size_bytes} 



<SettingsInfoBlock type="UInt64" default_value="524288" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "524288"},{"label": "New setting."}]}]}/>

Минимальный размер блока в байтах для входных и выходных блоков JOIN (если алгоритм JOIN это поддерживает). Маленькие блоки будут сжиматься. 0 означает неограниченно.
## min_joined_block_size_rows {#min_joined_block_size_rows} 



<SettingsInfoBlock type="UInt64" default_value="65409" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "65409"},{"label": "New setting."}]}]}/>

Минимальный размер блока в строках для входных и выходных блоков JOIN (если алгоритм JOIN это поддерживает). Маленькие блоки будут сжиматься. 0 означает неограниченно.
## min_os_cpu_wait_time_ratio_to_throw {#min_os_cpu_wait_time_ratio_to_throw} 



<SettingsInfoBlock type="Float" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Setting values were changed and backported to 25.4"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "New setting"}]}]}/>

Минимальное соотношение времени ожидания ЦП ОС (метрика OSCPUWaitMicroseconds) и времени загрузки (метрика OSCPUVirtualTimeMicroseconds), чтобы рассматривать возможность отклонения запросов. Линейная интерполяция между минимальным и максимальным соотношением используется для вычисления вероятности, вероятность равна 0 в данной точке.
## min_outstreams_per_resize_after_split {#min_outstreams_per_resize_after_split} 



<SettingsInfoBlock type="UInt64" default_value="24" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "24"},{"label": "New setting."}]}]}/>

Указывает минимальное количество выходных потоков процессора `Resize` или `StrictResize` после разбиения, которое выполняется во время генерации конвейера. Если результатирующее количество потоков меньше этого значения, операция разделения не произойдет.
### Что такое узел Resize
Узел `Resize` — это процессор в конвейере запроса, который изменяет количество потоков данных, проходящих через конвейер. Он может либо увеличивать, либо уменьшать количество потоков, чтобы сбалансировать нагрузку между несколькими потоками или процессорами. Например, если запрос требует больше параллелизма, узел `Resize` может разделить один поток на несколько потоков. Напротив, он может объединить несколько потоков в меньшие потоки для консолидации обработки данных.

Узел `Resize` обеспечивает равномерное распределение данных между потоками, поддерживая структуру блоков данных. Это помогает оптимизировать использование ресурсов и улучшить производительность запросов.
### Почему узел Resize нужно разделить
Во время выполнения конвейера mutex состояния ExecutingGraph::Node::status_mutex центрального узла `Resize` значительно нагружается, особенно в средах с высоким количеством ядер, и это содержание приводит к:
1. Увеличению задержки для ExecutingGraph::updateNode, что напрямую влияет на производительность запросов.
2. Избыточные тактовые циклы CPU теряются из-за ожидания затворов (native_queued_spin_lock_slowpath), что снижает эффективность.
3. Снижению использования CPU, что ограничивает параллелизм и пропускную способность.
### Как узел Resize разделяется
1. Проверяется количество выходных потоков, чтобы убедиться, что разбиение может быть выполнено: выходные потоки каждого процессора, который выполняет разбиение, соответствуют или превышают порог `min_outstreams_per_resize_after_split`.
2. Узел `Resize` делится на более мелкие узлы `Resize` с равным количеством портов, каждый из которых обрабатывает подмножество входных и выходных потоков.
3. Каждая группа обрабатывается независимо, уменьшая нагрузку на блокировки.
### Разбиение узла Resize с произвольными входами/выходами
В некоторых случаях, когда входные/выходные данные не делятся на количество узлов `Resize`, некоторые входы подключены к `NullSource`, а некоторые выходы подключены к `NullSink`. Это позволяет выполнить разбиение, не затрагивая общий поток данных.
### Цель настройки
Настройка `min_outstreams_per_resize_after_split` гарантирует, что разбиение узлов `Resize` имеет смысл и избегает создания слишком малого количества потоков, что может привести к неэффективной параллельной обработке. Устанавливая минимальное количество выходных потоков, эта настройка помогает поддерживать баланс между параллелизмом и накладными расходами, оптимизируя выполнение запросов в сценариях, связанных с разбиением и объединением потоков.
### Отключение настройки
Чтобы отключить разбиение узлов `Resize`, установите эту настройку в 0. Это предотвратит разбиение узлов `Resize` во время генерации конвейера, позволяя им сохранить свою исходную структуру без деления на более мелкие узлы.
## mongodb_throw_on_unsupported_query {#mongodb_throw_on_unsupported_query} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "1"},{"label": "New setting."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "1"},{"label": "New setting."}]}]}/>

Если включено, таблицы MongoDB вернут ошибку, когда MongoDB-запрос не может быть построен. В противном случае ClickHouse считывает полную таблицу и обрабатывает ее локально. Эта опция не применяется, когда 'allow_experimental_analyzer=0'.
## move_all_conditions_to_prewhere {#move_all_conditions_to_prewhere} 



<SettingsInfoBlock type="Bool" default_value="1" />

Переместить все жизнеспособные условия из WHERE в PREWHERE.
## move_primary_key_columns_to_end_of_prewhere {#move_primary_key_columns_to_end_of_prewhere} 



<SettingsInfoBlock type="Bool" default_value="1" />

Переместить условия PREWHERE, содержащие столбцы первичного ключа, в конец цепочки AND. Вероятно, что эти условия учитываются во время анализа первичного ключа, и, таким образом, они не будут вносить большой вклад в фильтрацию PREWHERE.
## multiple_joins_try_to_keep_original_names {#multiple_joins_try_to_keep_original_names} 



<SettingsInfoBlock type="Bool" default_value="0" />

Не добавлять псевдонимы в верхний уровень списка выражений при переписывании нескольких соединений.
## mutations_execute_nondeterministic_on_initiator {#mutations_execute_nondeterministic_on_initiator} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если true, постоянные недетерминированные функции (например, функция `now()`) выполняются на инициаторе и заменяются на литералы в запросах `UPDATE` и `DELETE`. Это помогает поддерживать синхронизацию данных на репликах при выполнении мутаций с постоянными недетерминированными функциями. Значение по умолчанию: `false`.
## mutations_execute_subqueries_on_initiator {#mutations_execute_subqueries_on_initiator} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если true, скалярные подзапросы выполняются на инициаторе и заменяются на литералы в запросах `UPDATE` и `DELETE`. Значение по умолчанию: `false`.
## mutations_max_literal_size_to_replace {#mutations_max_literal_size_to_replace} 



<SettingsInfoBlock type="UInt64" default_value="16384" />

Максимальный размер сериализуемого литерала в байтах, который может быть заменен в запросах `UPDATE` и `DELETE`. Вступает в силу только если хотя бы одна из двух вышеуказанных настроек включена. Значение по умолчанию: 16384 (16 KiB).
## mutations_sync {#mutations_sync} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Позволяет выполнять запросы `ALTER TABLE ... UPDATE|DELETE|MATERIALIZE INDEX|MATERIALIZE PROJECTION|MATERIALIZE COLUMN|MATERIALIZE STATISTICS` ([мутации](../../sql-reference/statements/alter/index.md/#mutations)) синхронно.

Возможные значения:

| Значение | Описание                                                                                                                                           |
|-------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| `0`   | Мутации выполняются асинхронно.                                                                                                                     |
| `1`   | Запрос ждет завершения всех мутаций на текущем сервере.                                                                                  |
| `2`   | Запрос ждет завершения всех мутаций на всех репликах (если они существуют).                                                                        |
| `3`   | Запрос ждет только активных реплик. Поддерживается только для `SharedMergeTree`. Для `ReplicatedMergeTree` ведет себя так же, как `mutations_sync = 2`.|
## mysql_datatypes_support_level {#mysql_datatypes_support_level} 

Определяет, как типы MySQL преобразуются в соответствующие типы ClickHouse. Список, разделенный запятыми, в любой комбинации `decimal`, `datetime64`, `date2Date32` или `date2String`.
- `decimal`: преобразовать типы `NUMERIC` и `DECIMAL` в `Decimal`, когда это позволяет точность.
- `datetime64`: преобразовать типы `DATETIME` и `TIMESTAMP` в `DateTime64` вместо `DateTime`, когда точность не равна `0`.
- `date2Date32`: преобразовать `DATE` в `Date32` вместо `Date`. Имеет приоритет над `date2String`.
- `date2String`: преобразовать `DATE` в `String` вместо `Date`. Переопределен `datetime64`.
## mysql_map_fixed_string_to_text_in_show_columns {#mysql_map_fixed_string_to_text_in_show_columns} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Reduce the configuration effort to connect ClickHouse with BI tools."}]}]}/>

Если включено, тип данных ClickHouse [FixedString](../../sql-reference/data-types/fixedstring.md) будет отображаться как `TEXT` в [SHOW COLUMNS](../../sql-reference/statements/show.md/#show_columns).

Эта настройка имеет эффект только при подключении через протокол MySQL.

- 0 - Использовать `BLOB`.
- 1 - Использовать `TEXT`.
## mysql_map_string_to_text_in_show_columns {#mysql_map_string_to_text_in_show_columns} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Reduce the configuration effort to connect ClickHouse with BI tools."}]}]}/>

Если включено, тип данных ClickHouse [String](../../sql-reference/data-types/string.md) будет отображаться как `TEXT` в [SHOW COLUMNS](../../sql-reference/statements/show.md/#show_columns).

Эта настройка имеет эффект только при подключении через протокол MySQL.

- 0 - Использовать `BLOB`.
- 1 - Использовать `TEXT`.
## mysql_max_rows_to_insert {#mysql_max_rows_to_insert} 



<SettingsInfoBlock type="UInt64" default_value="65536" />

Максимальное количество строк при пакетной вставке MySQL движка хранения.
## network_compression_method {#network_compression_method} 



<SettingsInfoBlock type="String" default_value="LZ4" />

Кодек для сжатия клиент-серверной и сервер-серверной связи.

Возможные значения:

- `NONE` — без сжатия.
- `LZ4` — использовать кодек LZ4.
- `LZ4HC` — использовать кодек LZ4HC.
- `ZSTD` — использовать кодек ZSTD.

**См. также**

- [network_zstd_compression_level](#network_zstd_compression_level)
## network_zstd_compression_level {#network_zstd_compression_level} 



<SettingsInfoBlock type="Int64" default_value="1" />

Регулирует уровень сжатия ZSTD. Используется только когда [network_compression_method](#network_compression_method) установлен на `ZSTD`.

Возможные значения:

- Положительное целое число от 1 до 15.
## normalize_function_names {#normalize_function_names} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.3"},{"label": "1"},{"label": "Normalize function names to their canonical names, this was needed for projection query routing"}]}]}/>

Нормализовать имена функций до их канонических имен.
## number_of_mutations_to_delay {#number_of_mutations_to_delay} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Если изменяемая таблица содержит как минимум столько непринятых мутаций, искусственно замедлить мутации таблицы. 0 - отключено.
## number_of_mutations_to_throw {#number_of_mutations_to_throw} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Если изменяемая таблица содержит как минимум столько непринятых мутаций, выбросьте исключение 'Слишком много мутаций ...'. 0 - отключено.
## odbc_bridge_connection_pool_size {#odbc_bridge_connection_pool_size} 



<SettingsInfoBlock type="UInt64" default_value="16" />

Размер пула подключений для каждой строки настроек подключений в ODBC мосте.
## odbc_bridge_use_connection_pooling {#odbc_bridge_use_connection_pooling} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать пул подключений в ODBC мосте. Если установлено в false, новое подключение создается каждый раз.
## offset {#offset} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает количество строк, которые нужно пропустить перед тем, как начать возвращать строки из запроса. Это регулирует смещение, установленное оператором [OFFSET](/sql-reference/statements/select/offset), так что эти два значения суммируются.

Возможные значения:

- 0 — Не пропускается ни одна строка .
- Положительное целое число.

**Пример**

Входная таблица:

```sql
CREATE TABLE test (i UInt64) ENGINE = MergeTree() ORDER BY i;
INSERT INTO test SELECT number FROM numbers(500);
```

Запрос:

```sql
SET limit = 5;
SET offset = 7;
SELECT * FROM test LIMIT 10 OFFSET 100;
```
Результат:

```text
┌───i─┐
│ 107 │
│ 108 │
│ 109 │
└─────┘
```
## opentelemetry_start_trace_probability {#opentelemetry_start_trace_probability} 



<SettingsInfoBlock type="Float" default_value="0" />

Устанавливает вероятность того, что ClickHouse сможет начать трассировку для выполняемых запросов (если не предоставлен родительский [контекст трассировки](https://www.w3.org/TR/trace-context/)).

Возможные значения:

- 0 — Трассировка для всех выполняемых запросов отключена (если не предоставлен родительский контекст трассировки).
- Положительное число с плавающей запятой в диапазоне [0..1]. Например, если значение настройки равно `0,5`, ClickHouse может начать трассировку в среднем для половины запросов.
- 1 — Трассировка для всех выполняемых запросов включена.
## opentelemetry_trace_cpu_scheduling {#opentelemetry_trace_cpu_scheduling} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting to trace `cpu_slot_preemption` feature."}]}]}/>

Собирать OpenTelemetry спаны для предвосхищающего планирования CPU.
## opentelemetry_trace_processors {#opentelemetry_trace_processors} 



<SettingsInfoBlock type="Bool" default_value="0" />

Собирать OpenTelemetry спаны для процессоров.
## optimize_aggregation_in_order {#optimize_aggregation_in_order} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает оптимизацию [GROUP BY](/sql-reference/statements/select/group-by) в запросах [SELECT](../../sql-reference/statements/select/index.md) для агрегации данных в соответствующем порядке в таблицах [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md).

Возможные значения:

- 0 — Оптимизация `GROUP BY` отключена.
- 1 — Оптимизация `GROUP BY` включена.

**См. также**

- [Оптимизация GROUP BY](/sql-reference/statements/select/group-by#group-by-optimization-depending-on-table-sorting-key)
## optimize_aggregators_of_group_by_keys {#optimize_aggregators_of_group_by_keys} 



<SettingsInfoBlock type="Bool" default_value="1" />

Устраняет агрегаторы min/max/any/anyLast для ключей GROUP BY в разделе SELECT
## optimize_and_compare_chain {#optimize_and_compare_chain} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "A new setting"}]}]}/>

Заполняет постоянное сравнение в цепочках AND для улучшения возможностей фильтрации. Поддерживаются операторы `<`, `<=`, `>`, `>=`, `=` и их комбинации. Например, `(a < b) AND (b < c) AND (c < 5)` будет `(a < b) AND (b < c) AND (c < 5) AND (b < 5) AND (a < 5)`.
## optimize_append_index {#optimize_append_index} 



<SettingsInfoBlock type="Bool" default_value="0" />

Используйте [constraints](../../sql-reference/statements/create/table.md/#constraints) для добавления условия индекса. По умолчанию `false`.

Допустимые значения:

- true, false
## optimize_arithmetic_operations_in_aggregate_functions {#optimize_arithmetic_operations_in_aggregate_functions} 



<SettingsInfoBlock type="Bool" default_value="1" />

Переместите арифметические операции вне агрегатных функций
## optimize_count_from_files {#optimize_count_from_files} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает оптимизацию подсчета количества строк из файлов в различных входных форматах. Применяется к табличным функциям/движкам `file`/`s3`/`url`/`hdfs`/`azureBlobStorage`.

Допустимые значения:

- 0 — Оптимизация отключена.
- 1 — Оптимизация включена.
## optimize_distinct_in_order {#optimize_distinct_in_order} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию DISTINCT, если некоторые колонки в DISTINCT образуют префикс сортировки. Например, префикс ключа сортировки в merge tree или операторе ORDER BY
## optimize_distributed_group_by_sharding_key {#optimize_distributed_group_by_sharding_key} 



<SettingsInfoBlock type="Bool" default_value="1" />

Оптимизируйте запросы `GROUP BY sharding_key`, избегая затратной агрегации на инициирующем сервере (что уменьшит использование памяти для запроса на инициирующем сервере).

Поддерживаются следующие типы запросов (и все их комбинации):

- `SELECT DISTINCT [..., ]sharding_key[, ...] FROM dist`
- `SELECT ... FROM dist GROUP BY sharding_key[, ...]`
- `SELECT ... FROM dist GROUP BY sharding_key[, ...] ORDER BY x`
- `SELECT ... FROM dist GROUP BY sharding_key[, ...] LIMIT 1`
- `SELECT ... FROM dist GROUP BY sharding_key[, ...] LIMIT 1 BY x`

Следующие типы запросов не поддерживаются (поддержка некоторых из них может быть добавлена позже):

- `SELECT ... GROUP BY sharding_key[, ...] WITH TOTALS`
- `SELECT ... GROUP BY sharding_key[, ...] WITH ROLLUP`
- `SELECT ... GROUP BY sharding_key[, ...] WITH CUBE`
- `SELECT ... GROUP BY sharding_key[, ...] SETTINGS extremes=1`

Допустимые значения:

- 0 — Отключено.
- 1 — Включено.

Смотрите также:

- [distributed_group_by_no_merge](#distributed_group_by_no_merge)
- [distributed_push_down_limit](#distributed_push_down_limit)
- [optimize_skip_unused_shards](#optimize_skip_unused_shards)

:::note
В настоящее время это требует `optimize_skip_unused_shards` (причина заключается в том, что в будущем это может быть включено по умолчанию и будет работать корректно только в случае, если данные были вставлены через распределенную таблицу, т.е. данные распределены в соответствии с sharding_key).
:::
## optimize_empty_string_comparisons {#optimize_empty_string_comparisons} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "1"},{"label": "A new setting."}]}]}/>

Преобразует выражения, такие как col = '' или '' = col, в empty(col), а col != '' или '' != col в notEmpty(col),
только если col имеет тип String или FixedString.
## optimize_extract_common_expressions {#optimize_extract_common_expressions} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Optimize WHERE, PREWHERE, ON, HAVING and QUALIFY expressions by extracting common expressions out from disjunction of conjunctions."}]}, {"id": "row-2","items": [{"label": "24.12"},{"label": "0"},{"label": "Introduce setting to optimize WHERE, PREWHERE, ON, HAVING and QUALIFY expressions by extracting common expressions out from disjunction of conjunctions."}]}]}/>

Позволяет извлекать общие выражения из дизъюнкций в WHERE, PREWHERE, ON, HAVING и QUALIFY выражениях. Логическое выражение, такое как `(A AND B) OR (A AND C)`, можно переписать как `A AND (B OR C)`, что может помочь использовать:
- индексы в простых фильтрующих выражениях
- оптимизацию перехода к внутреннему соединению
## optimize_functions_to_subcolumns {#optimize_functions_to_subcolumns} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "1"},{"label": "Enabled settings by default"}]}]}/>

Включает или отключает оптимизацию путем преобразования некоторых функций к чтению подсоединков. Это сокращает объем данных для чтения.

Эти функции могут быть преобразованы:

- [length](/sql-reference/functions/array-functions#length) для чтения подколонки [size0](../../sql-reference/data-types/array.md/#array-size).
- [empty](/sql-reference/functions/array-functions#empty) для чтения подколонки [size0](../../sql-reference/data-types/array.md/#array-size).
- [notEmpty](/sql-reference/functions/array-functions#notEmpty) для чтения подколонки [size0](../../sql-reference/data-types/array.md/#array-size).
- [isNull](/sql-reference/functions/functions-for-nulls#isNull) для чтения подколонки [null](../../sql-reference/data-types/nullable.md/#finding-null).
- [isNotNull](/sql-reference/functions/functions-for-nulls#isNotNull) для чтения подколонки [null](../../sql-reference/data-types/nullable.md/#finding-null).
- [count](/sql-reference/aggregate-functions/reference/count) для чтения подколонки [null](../../sql-reference/data-types/nullable.md/#finding-null).
- [mapKeys](/sql-reference/functions/tuple-map-functions#mapkeys) для чтения подколонки [keys](/sql-reference/data-types/map#reading-subcolumns-of-map).
- [mapValues](/sql-reference/functions/tuple-map-functions#mapvalues) для чтения подколонки [values](/sql-reference/data-types/map#reading-subcolumns-of-map).

Допустимые значения:

- 0 — Оптимизация отключена.
- 1 — Оптимизация включена.
## optimize_group_by_constant_keys {#optimize_group_by_constant_keys} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.9"},{"label": "1"},{"label": "Optimize group by constant keys by default"}]}]}/>

Оптимизировать GROUP BY, когда все ключи в блоке являются постоянными
## optimize_group_by_function_keys {#optimize_group_by_function_keys} 



<SettingsInfoBlock type="Bool" default_value="1" />

Устраняет функции других ключей в разделе GROUP BY
## optimize_if_chain_to_multiif {#optimize_if_chain_to_multiif} 



<SettingsInfoBlock type="Bool" default_value="0" />

Заменяет цепочки if(cond1, then1, if(cond2, ...)) на multiIf. В данный момент это не полезно для числовых типов.
## optimize_if_transform_strings_to_enum {#optimize_if_transform_strings_to_enum} 



<SettingsInfoBlock type="Bool" default_value="0" />

Заменяет аргументы строкового типа в If и Transform на enum. Отключено по умолчанию, так как это может привести к несогласованному изменению в распределенном запросе, что может привести к его сбоям.
## optimize_injective_functions_in_group_by {#optimize_injective_functions_in_group_by} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "1"},{"label": "Replace injective functions by it's arguments in GROUP BY section in analyzer"}]}]}/>

Заменяет инъективные функции их аргументами в разделе GROUP BY
## optimize_injective_functions_inside_uniq {#optimize_injective_functions_inside_uniq} 



<SettingsInfoBlock type="Bool" default_value="1" />

Удаляет инъективные функции одного аргумента внутри функций uniq*().
## optimize_min_equality_disjunction_chain_length {#optimize_min_equality_disjunction_chain_length} 



<SettingsInfoBlock type="UInt64" default_value="3" />

Минимальная длина выражения `expr = x1 OR ... expr = xN` для оптимизации
## optimize_min_inequality_conjunction_chain_length {#optimize_min_inequality_conjunction_chain_length} 



<SettingsInfoBlock type="UInt64" default_value="3" />

Минимальная длина выражения `expr <> x1 AND ... expr <> xN` для оптимизации
## optimize_move_to_prewhere {#optimize_move_to_prewhere} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает автоматическую оптимизацию [PREWHERE](../../sql-reference/statements/select/prewhere.md) в запросах [SELECT](../../sql-reference/statements/select/index.md).

Работает только для таблиц [*MergeTree](../../engines/table-engines/mergetree-family/index.md).

Допустимые значения:

- 0 — Автоматическая оптимизация `PREWHERE` отключена.
- 1 — Автоматическая оптимизация `PREWHERE` включена.
## optimize_move_to_prewhere_if_final {#optimize_move_to_prewhere_if_final} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает автоматическую оптимизацию [PREWHERE](../../sql-reference/statements/select/prewhere.md) в запросах [SELECT](../../sql-reference/statements/select/index.md) с модификатором [FINAL](/sql-reference/statements/select/from#final-modifier).

Работает только для таблиц [*MergeTree](../../engines/table-engines/mergetree-family/index.md).

Допустимые значения:

- 0 — Автоматическая оптимизация `PREWHERE` в запросах `SELECT` с модификатором `FINAL` отключена.
- 1 — Автоматическая оптимизация `PREWHERE` в запросах `SELECT` с модификатором `FINAL` включена.

**Смотрите также**

- Настройка [optimize_move_to_prewhere](#optimize_move_to_prewhere)
## optimize_multiif_to_if {#optimize_multiif_to_if} 



<SettingsInfoBlock type="Bool" default_value="1" />

Заменяет 'multiIf' с единственным условием на 'if'.
## optimize_normalize_count_variants {#optimize_normalize_count_variants} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.3"},{"label": "1"},{"label": "Rewrite aggregate functions that semantically equals to count() as count() by default"}]}]}/>

Переписывает агрегатные функции, которые семантически эквивалентны count() как count().
## optimize_on_insert {#optimize_on_insert} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.1"},{"label": "1"},{"label": "Enable data optimization on INSERT by default for better user experience"}]}]}/>

Включает или отключает преобразование данных перед вставкой, так как если слияние было выполнено по этому блоку (в соответствии с движком таблицы).

Допустимые значения:

- 0 — Отключено.
- 1 — Включено.

**Пример**

Разница между включенным и отключенным:

Запрос:

```sql
SET optimize_on_insert = 1;

CREATE TABLE test1 (`FirstTable` UInt32) ENGINE = ReplacingMergeTree ORDER BY FirstTable;

INSERT INTO test1 SELECT number % 2 FROM numbers(5);

SELECT * FROM test1;

SET optimize_on_insert = 0;

CREATE TABLE test2 (`SecondTable` UInt32) ENGINE = ReplacingMergeTree ORDER BY SecondTable;

INSERT INTO test2 SELECT number % 2 FROM numbers(5);

SELECT * FROM test2;
```

Результат:

```text
┌─FirstTable─┐
│          0 │
│          1 │
└────────────┘

┌─SecondTable─┐
│           0 │
│           0 │
│           0 │
│           1 │
│           1 │
└─────────────┘
```

Обратите внимание, что эта настройка влияет на поведение [Материализованного представления](/sql-reference/statements/create/view#materialized-view).
## optimize_or_like_chain {#optimize_or_like_chain} 



<SettingsInfoBlock type="Bool" default_value="0" />

Оптимизирует несколько OR LIKE в multiMatchAny. Эта оптимизация не должна быть включена по умолчанию, так как она противоречит анализу индекса в некоторых случаях.
## optimize_qbit_distance_function_reads {#optimize_qbit_distance_function_reads} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "1"},{"label": "New setting"}]}]}/>

Заменяет функции расстояния для типа данных `QBit` на эквиваленты, которые читают только необходимые для вычисления колонки из хранилища.
## optimize_read_in_order {#optimize_read_in_order} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию [ORDER BY](/sql-reference/statements/select/order-by#optimization-of-data-reading) в запросах [SELECT](../../sql-reference/statements/select/index.md) для чтения данных из таблиц [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md).

Допустимые значения:

- 0 — Оптимизация `ORDER BY` отключена.
- 1 — Оптимизация `ORDER BY` включена.

**Смотрите также**

- [Пункт ORDER BY](/sql-reference/statements/select/order-by#optimization-of-data-reading)
## optimize_read_in_window_order {#optimize_read_in_window_order} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию ORDER BY в клаузе окна для чтения данных в соответствующем порядке в таблицах MergeTree.
## optimize_redundant_functions_in_order_by {#optimize_redundant_functions_in_order_by} 



<SettingsInfoBlock type="Bool" default_value="1" />

Удаляет функции из ORDER BY, если их аргумент также в ORDER BY
## optimize_respect_aliases {#optimize_respect_aliases} 



<SettingsInfoBlock type="Bool" default_value="1" />

Если установлено в true, будет уважать псевдонимы в WHERE/GROUP BY/ORDER BY, что поможет с обрезкой партиций/вторичными индексами/оптимизацией_агрегации_в_порядке/оптимизацией_чтения_в_порядке/оптимизацией_тривиального_подсчета
## optimize_rewrite_aggregate_function_with_if {#optimize_rewrite_aggregate_function_with_if} 



<SettingsInfoBlock type="Bool" default_value="1" />

Переписывает агрегатные функции с выражением if в качестве аргумента, когда логически эквивалентно.
Например, `avg(if(cond, col, null))` может быть переписано как `avgOrNullIf(cond, col)`. Это может улучшить производительность.

:::note
Поддерживается только с анализатором (`enable_analyzer = 1`).
:::
## optimize_rewrite_array_exists_to_has {#optimize_rewrite_array_exists_to_has} 



<SettingsInfoBlock type="Bool" default_value="0" />

Переписывает функции arrayExists() в has() при логической эквивалентности. Например, arrayExists(x -> x = 1, arr) может быть переписано как has(arr, 1)
## optimize_rewrite_regexp_functions {#optimize_rewrite_regexp_functions} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "1"},{"label": "A new setting"}]}]}/>

Переписывает функции регулярных выражений в более простые и эффективные формы
## optimize_rewrite_sum_if_to_count_if {#optimize_rewrite_sum_if_to_count_if} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "1"},{"label": "Only available for the analyzer, where it works correctly"}]}]}/>

Переписывает функции sumIf() и sum(if()) на функцию countIf() при логической эквивалентности
## optimize_skip_merged_partitions {#optimize_skip_merged_partitions} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает оптимизацию для запроса [OPTIMIZE TABLE ... FINAL](../../sql-reference/statements/optimize.md), если существует только одна часть с уровнем > 0 и она не имеет истекшего TTL.

- `OPTIMIZE TABLE ... FINAL SETTINGS optimize_skip_merged_partitions=1`

По умолчанию запрос `OPTIMIZE TABLE ... FINAL` перезаписывает одну часть, даже если есть только одна часть.

Допустимые значения:

- 1 - Включить оптимизацию.
- 0 - Отключить оптимизацию.
## optimize_skip_unused_shards {#optimize_skip_unused_shards} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает пропуск неиспользуемых шардов для запросов [SELECT](../../sql-reference/statements/select/index.md), которые имеют условие sharding key в `WHERE/PREWHERE` (предполагая, что данные распределены по sharding key, в противном случае запрос выдаст некорректный результат).

Допустимые значения:

- 0 — Отключено.
- 1 — Включено.
## optimize_skip_unused_shards_limit {#optimize_skip_unused_shards_limit} 



<SettingsInfoBlock type="UInt64" default_value="1000" />

Лимит на количество значений ключа шардирования, отключает `optimize_skip_unused_shards`, если лимит достигнут.

Слишком много значений может потребовать значительного объема для обработки, в то время как выгода сомнительна, поскольку если у вас огромная масса значений в `IN (...)`, то, скорее всего, запрос будет отправлен на все шардов в любом случае.
## optimize_skip_unused_shards_nesting {#optimize_skip_unused_shards_nesting} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Контролирует [`optimize_skip_unused_shards`](#optimize_skip_unused_shards) (поэтому все еще требует [`optimize_skip_unused_shards`](#optimize_skip_unused_shards)) в зависимости от уровня вложенности распределенного запроса (случай, когда у вас есть `Distributed` таблица, которая смотрит в другую `Distributed` таблицу).

Допустимые значения:

- 0 — Отключено, `optimize_skip_unused_shards` всегда работает.
- 1 — Включает `optimize_skip_unused_shards` только для первого уровня.
- 2 — Включает `optimize_skip_unused_shards` вплоть до второго уровня.
## optimize_skip_unused_shards_rewrite_in {#optimize_skip_unused_shards_rewrite_in} 



<SettingsInfoBlock type="Bool" default_value="1" />

Переписывает IN в запросе для удаленных шардов, чтобы исключить значения, которые не принадлежат шардy (требует optimize_skip_unused_shards).

Допустимые значения:

- 0 — Отключено.
- 1 — Включено.
## optimize_sorting_by_input_stream_properties {#optimize_sorting_by_input_stream_properties} 



<SettingsInfoBlock type="Bool" default_value="1" />

Оптимизация сортировки по свойствам входного потока
## optimize_substitute_columns {#optimize_substitute_columns} 



<SettingsInfoBlock type="Bool" default_value="0" />

Используйте [constraints](../../sql-reference/statements/create/table.md/#constraints) для замены колонок. По умолчанию `false`.

Допустимые значения:

- true, false
## optimize_syntax_fuse_functions {#optimize_syntax_fuse_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет объединять агрегатные функции с идентичным аргументом. Переписывает запрос, содержащий как минимум две агрегатные функции из [sum](/sql-reference/aggregate-functions/reference/sum), [count](/sql-reference/aggregate-functions/reference/count) или [avg](/sql-reference/aggregate-functions/reference/avg) с идентичным аргументом в [sumCount](/sql-reference/aggregate-functions/reference/sumcount).

Допустимые значения:

- 0 — Функции с идентичным аргументом не объединяются.
- 1 — Функции с идентичным аргументом объединяются.

**Пример**

Запрос:

```sql
CREATE TABLE fuse_tbl(a Int8, b Int8) Engine = Log;
SET optimize_syntax_fuse_functions = 1;
EXPLAIN SYNTAX SELECT sum(a), sum(b), count(b), avg(b) from fuse_tbl FORMAT TSV;
```

Результат:

```text
SELECT
    sum(a),
    sumCount(b).1,
    sumCount(b).2,
    (sumCount(b).1) / (sumCount(b).2)
FROM fuse_tbl
```
## optimize_throw_if_noop {#optimize_throw_if_noop} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает выброс исключения, если запрос [OPTIMIZE](../../sql-reference/statements/optimize.md) не выполнил слияние.

По умолчанию `OPTIMIZE` возвращает успешно, даже если не выполнил ничего. Эта настройка позволяет вам различать эти ситуации и получать причину в сообщении исключения.

Допустимые значения:

- 1 — Выброс исключения включен.
- 0 — Выброс исключения отключен.
## optimize_time_filter_with_preimage {#optimize_time_filter_with_preimage} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Оптимизация предикатов Date и DateTime, преобразуя функции в эквивалентные сравнения без преобразований (например, toYear(col) = 2023 -> col >= '2023-01-01' AND col <= '2023-12-31')"}]}]}/>

Оптимизация предикатов Date и DateTime, преобразуя функции в эквивалентные сравнения без преобразований (например, `toYear(col) = 2023 -> col >= '2023-01-01' AND col <= '2023-12-31'`)
## optimize_trivial_approximate_count_query {#optimize_trivial_approximate_count_query} 



<SettingsInfoBlock type="Bool" default_value="0" />

Использует приближенное значение для тривиальной оптимизации подсчета хранилищ, которые поддерживают такую оценку, например, EmbeddedRocksDB.

Допустимые значения:

   - 0 — Оптимизация отключена.
   - 1 — Оптимизация включена.
## optimize_trivial_count_query {#optimize_trivial_count_query} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает оптимизацию для тривиального запроса `SELECT count() FROM table` с использованием метаданных из MergeTree. Если вам нужно использовать безопасность на уровне строк, отключите эту настройку.

Допустимые значения:

   - 0 — Оптимизация отключена.
   - 1 — Оптимизация включена.

Смотрите также:

- [optimize_functions_to_subcolumns](#optimize_functions_to_subcolumns)
## optimize_trivial_insert_select {#optimize_trivial_insert_select} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "The optimization does not make sense in many cases."}]}]}/>

Оптимизация тривиального 'INSERT INTO table SELECT ... FROM TABLES' запроса
## optimize_uniq_to_count {#optimize_uniq_to_count} 



<SettingsInfoBlock type="Bool" default_value="1" />

Переписывает uniq и его варианты (кроме uniqUpTo) на count, если подзапрос имеет distinct или group by клаузу.
## optimize_use_implicit_projections {#optimize_use_implicit_projections} 



<SettingsInfoBlock type="Bool" default_value="1" />

Автоматически выбирает неявные проектции для выполнения запроса SELECT
## optimize_use_projection_filtering {#optimize_use_projection_filtering} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "1"},{"label": "New setting"}]}]}/>

Включает использование проекций для фильтрации диапазонов частей, даже когда проекции не выбраны для выполнения запроса SELECT.
## optimize_use_projections {#optimize_use_projections} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает оптимизацию [projection](../../engines/table-engines/mergetree-family/mergetree.md/#projections) при обработке запросов `SELECT`.

Допустимые значения:

- 0 — Оптимизация проекции отключена.
- 1 — Оптимизация проекции включена.
## optimize_using_constraints {#optimize_using_constraints} 



<SettingsInfoBlock type="Bool" default_value="0" />

Используйте [constraints](../../sql-reference/statements/create/table.md/#constraints) для оптимизации запросов. По умолчанию `false`.

Допустимые значения:

- true, false
## os_threads_nice_value_materialized_view {#os_threads_nice_value_materialized_view} 



<SettingsInfoBlock type="Int32" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting."}]}]}/>

Linux nice value для потоков материализованного представления. Более низкие значения означают более высокий приоритет CPU.

Требуется возможность CAP_SYS_NICE, в противном случае no-op.

Допустимые значения: от -20 до 19.
## os_threads_nice_value_query {#os_threads_nice_value_query} 



<SettingsInfoBlock type="Int32" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting."}]}]}/>

Linux nice value для потоков обработки запросов. Более низкие значения означают более высокий приоритет CPU.

Требуется возможность CAP_SYS_NICE, в противном случае no-op.

Допустимые значения: от -20 до 19.
## output_format_compression_level {#output_format_compression_level} 



<SettingsInfoBlock type="UInt64" default_value="3" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "3"},{"label": "Allow to change compression level in the query output"}]}]}/>

Уровень сжатия по умолчанию, если вывод запроса сжат. Настройка применяется, когда запрос `SELECT` имеет `INTO OUTFILE` или при записи в табличные функции `file`, `url`, `hdfs`, `s3` или `azureBlobStorage`.

Допустимые значения: от `1` до `22`
## output_format_compression_zstd_window_log {#output_format_compression_zstd_window_log} 



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Allow to change zstd window log in the query output when zstd compression is used"}]}]}/>

Может использоваться, когда метод сжатия выхода `zstd`. Если больше 0, эта настройка явно устанавливает размер окна сжатия (степень `2`) и включает режим долгосрочного сжатия для zstd. Это может помочь достичь лучшего коэффициента сжатия.

Допустимые значения: неотрицательные числа. Обратите внимание, что если значение слишком малое или слишком большое, `zstdlib` выдаст исключение. Типичные значения от `20` (размер окна = `1MB`) до `30` (размер окна = `1GB`).
## output_format_parallel_formatting {#output_format_parallel_formatting} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает параллельное форматирование форматов данных. Поддерживается только для форматов [TSV](../../interfaces/formats.md/#tabseparated), [TSKV](../../interfaces/formats.md/#tskv), [CSV](../../interfaces/formats.md/#csv) и [JSONEachRow](../../interfaces/formats.md/#jsoneachrow).

Допустимые значения:

- 1 — Включено.
- 0 — Отключено.
## page_cache_block_size {#page_cache_block_size} 



<SettingsInfoBlock type="UInt64" default_value="1048576" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1048576"},{"label": "Made this setting adjustable on a per-query level."}]}]}/>

Размер файловых фрагментов, хранящихся в кэше страниц пользовательского пространства, в байтах. Все чтения, проходящие через кэш, будут округлены до кратного этого размера.

Эту настройку можно корректировать на уровне каждого запроса, но записи кэша с различными размерами блоков не могут быть повторно использованы. Изменение этой настройки фактически делает существующие записи в кэше недействительными.

Большое значение, например 1 MiB, хорошо подходит для запросов с высокой пропускной способностью, а меньшее значение, например 64 KiB, хорошо подходит для точечных запросов с низкой задержкой.
## page_cache_inject_eviction {#page_cache_inject_eviction} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Added userspace page cache"}]}]}/>

Кэш страниц пользовательского пространства иногда будет недействительным для некоторых страниц случайным образом. Предназначено для тестирования.
## page_cache_lookahead_blocks {#page_cache_lookahead_blocks} 



<SettingsInfoBlock type="UInt64" default_value="16" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "16"},{"label": "Made this setting adjustable on a per-query level."}]}]}/>

При промахе кэша страниц пользовательского пространства прочитайте до этого количества последовательных блоков сразу из базового хранилища, если они также не находятся в кэше. Каждый блок составляет page_cache_block_size байт.

Большее значение хорошо подходит для запросов с высокой пропускной способностью, в то время как точечные запросы с низкой задержкой лучше работают без предвосхищения.
## parallel_distributed_insert_select {#parallel_distributed_insert_select} 



<SettingsInfoBlock type="UInt64" default_value="2" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "2"},{"label": "Enable parallel distributed insert select by default"}]}]}/>

Включает параллельный распределенный запрос `INSERT ... SELECT`.

Если мы выполняем запросы `INSERT INTO distributed_table_a SELECT ... FROM distributed_table_b`, и обе таблицы используют один и тот же кластер, и обе таблицы являются либо [реплицированными](../../engines/table-engines/mergetree-family/replication.md), либо нереплицированными, то этот запрос обрабатывается локально на каждом шарде.

Допустимые значения:

- `0` — Отключено.
- `1` — `SELECT` будет выполняться на каждом шарде из базовой таблицы распределенного движка.
- `2` — `SELECT` и `INSERT` будут выполняться на каждом шарде от/в базовую таблицу распределенного движка.

Установку `enable_parallel_replicas = 1` необходимо включить при использовании этой настройки.
## parallel_hash_join_threshold {#parallel_hash_join_threshold} 



<SettingsInfoBlock type="UInt64" default_value="100000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "100000"},{"label": "New setting"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "New setting"}]}, {"id": "row-3","items": [{"label": "25.3"},{"label": "0"},{"label": "New setting"}]}]}/>

Когда применяется алгоритм соединения на основе хеша, этот порог помогает решить, использовать ли `hash` или `parallel_hash` (только если доступна оценка размера правой таблицы).
Первый используется, когда мы знаем, что размер правой таблицы ниже порога.
## parallel_replica_offset {#parallel_replica_offset} 

<BetaBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />

Это внутренняя настройка, которую не следует использовать напрямую, и она представляет собой деталь реализации режима «параллельные реплики». Эта настройка будет автоматически настроена инициирующим сервером для распределенных запросов по индексу реплики, участвующей в обработке запроса среди параллельных реплик.
## parallel_replicas_allow_in_with_subquery {#parallel_replicas_allow_in_with_subquery} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "If true, subquery for IN will be executed on every follower replica"}]}]}/>

Если true, подзапрос для IN будет выполняться на каждой последующей реплике.
## parallel_replicas_connect_timeout_ms {#parallel_replicas_connect_timeout_ms} 

<BetaBadge/>



<SettingsInfoBlock type="Milliseconds" default_value="300" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "300"},{"label": "Separate connection timeout for parallel replicas queries"}]}]}/>

Тайм-аут в миллисекундах для подключения к удаленной реплике во время выполнения запроса с параллельными репликами. Если тайм-аут истек, соответствующие реплики не используются для выполнения запроса.
## parallel_replicas_count {#parallel_replicas_count} 

<BetaBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />

Это внутренняя настройка, которую не следует использовать напрямую, и она представляет собой деталь реализации режима «параллельные реплики». Эта настройка будет автоматически настроена инициирующим сервером для распределенных запросов на количество параллельных реплик, участвующих в обработке запроса.
## parallel_replicas_custom_key {#parallel_replicas_custom_key} 

<BetaBadge/>

Произвольное целое выражение, которое можно использовать для распределения работы между репликами для конкретной таблицы. Значение может быть любым целым выражением.

Предпочтительно использовать простые выражения с основными ключами.

Если настройка используется в кластере, состоящем из одного шарда с несколькими репликами, эти реплики будут преобразованы в виртуальные шардy. В противном случае она будет вести себя так же, как для ключа `SAMPLE`, используя несколько реплик каждого шарда.
## parallel_replicas_custom_key_range_lower {#parallel_replicas_custom_key_range_lower} 

<BetaBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Add settings to control the range filter when using parallel replicas with dynamic shards"}]}]}/>

Позволяет типу фильтра `range` равномерно распределять работу между репликами на основе пользовательского диапазона `[parallel_replicas_custom_key_range_lower, INT_MAX]`.

Когда используется в сочетании с [parallel_replicas_custom_key_range_upper](#parallel_replicas_custom_key_range_upper), это позволяет фильтру равномерно распределять работу между репликами для диапазона `[parallel_replicas_custom_key_range_lower, parallel_replicas_custom_key_range_upper]`.

Примечание: Эта настройка не приведет к тому, что во время обработки запроса будут отфильтрованы дополнительные данные, она изменяет лишь точки, в которых диапазон фильтра разделяет диапазон `[0, INT_MAX]` для параллельной обработки.
## parallel_replicas_custom_key_range_upper {#parallel_replicas_custom_key_range_upper} 

<BetaBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Add settings to control the range filter when using parallel replicas with dynamic shards. A value of 0 disables the upper limit"}]}]}/>

Позволяет типу фильтра `range` равномерно распределять работу между репликами на основе пользовательского диапазона `[0, parallel_replicas_custom_key_range_upper]`. Значение 0 отключает верхнюю границу, устанавливая ее на максимальное значение выражения пользовательского ключа.

Когда используется в сочетании с [parallel_replicas_custom_key_range_lower](#parallel_replicas_custom_key_range_lower), это позволяет фильтру равномерно распределять работу между репликами для диапазона `[parallel_replicas_custom_key_range_lower, parallel_replicas_custom_key_range_upper]`.

Примечание: Эта настройка не приведет к тому, что во время обработки запроса будут отфильтрованы дополнительные данные, она изменяет лишь точки, в которых диапазон фильтра разделяет диапазон `[0, INT_MAX]` для параллельной обработки.
## parallel_replicas_for_cluster_engines {#parallel_replicas_for_cluster_engines} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "1"},{"label": "New setting."}]}]}/>

Заменяет движки табличных функций на их -Cluster альтернативы
## parallel_replicas_for_non_replicated_merge_tree {#parallel_replicas_for_non_replicated_merge_tree} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Если true, ClickHouse будет использовать алгоритм параллельных реплик также для нереплицированных таблиц MergeTree
## parallel_replicas_index_analysis_only_on_coordinator {#parallel_replicas_index_analysis_only_on_coordinator} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "1"},{"label": "Index analysis done only on replica-coordinator and skipped on other replicas. Effective only with enabled parallel_replicas_local_plan"}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "1"},{"label": "Index analysis done only on replica-coordinator and skipped on other replicas. Effective only with enabled parallel_replicas_local_plan"}]}]}/>

Анализ индекса выполняется только на реплике-координаторе и пропускается на других репликах. Эффективно только с включенной parallel_replicas_local_plan.
## parallel_replicas_insert_select_local_pipeline {#parallel_replicas_insert_select_local_pipeline} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Use local pipeline during distributed INSERT SELECT with parallel replicas. Currently disabled due to performance issues"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "Use local pipeline during distributed INSERT SELECT with parallel replicas. Currently disabled due to performance issues"}]}]}/>

Используйте локальный конвейер во время распределенного INSERT SELECT с параллельными репликами
## parallel_replicas_local_plan {#parallel_replicas_local_plan} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Use local plan for local replica in a query with parallel replicas"}]}, {"id": "row-2","items": [{"label": "24.11"},{"label": "1"},{"label": "Use local plan for local replica in a query with parallel replicas"}]}, {"id": "row-3","items": [{"label": "24.10"},{"label": "1"},{"label": "Use local plan for local replica in a query with parallel replicas"}]}]}/>

Создайте локальный план для локальной реплики
## parallel_replicas_mark_segment_size {#parallel_replicas_mark_segment_size} 

<BetaBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Value for this setting now determined automatically"}]}, {"id": "row-2","items": [{"label": "24.1"},{"label": "128"},{"label": "Add new setting to control segment size in new parallel replicas coordinator implementation"}]}]}/>

Части виртуально разделяются на сегменты, которые распределяются между репликами для параллельного чтения. Эта настройка контролирует размер этих сегментов. Не рекомендуется изменять, пока вы абсолютно уверены в том, что делаете. Значение должно находиться в диапазоне [128; 16384]
## parallel_replicas_min_number_of_rows_per_replica {#parallel_replicas_min_number_of_rows_per_replica} 

<BetaBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает количество реплик, используемых в запросе, до (оценочное количество строк для чтения / min_number_of_rows_per_replica). Максимум по-прежнему ограничен значением 'max_parallel_replicas'
## parallel_replicas_mode {#parallel_replicas_mode} 

<BetaBadge/>



<SettingsInfoBlock type="ParallelReplicasMode" default_value="read_tasks" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "read_tasks"},{"label": "This setting was introduced as a part of making parallel replicas feature Beta"}]}]}/>

Тип фильтра, который следует использовать с пользовательским ключом для параллельных реплик. по умолчанию - использование операции по модулю на пользовательском ключе, диапазон - использовать фильтр диапазона на пользовательском ключе с использованием всех возможных значений для типа значения пользовательского ключа.
## parallel_replicas_only_with_analyzer {#parallel_replicas_only_with_analyzer} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Parallel replicas is supported only with analyzer enabled"}]}]}/>

Анализатор должен быть включен для использования параллельных реплик. При выключенном анализаторе выполнение запроса возвращается к локальному выполнению, даже если параллельное чтение из реплик включено. Использование параллельных реплик без включенного анализатора не поддерживается.
## parallel_replicas_prefer_local_join {#parallel_replicas_prefer_local_join} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "If true, and JOIN can be executed with parallel replicas algorithm, and all storages of right JOIN part are *MergeTree, local JOIN will be used instead of GLOBAL JOIN."}]}]}/>

Если true, и JOIN может быть выполнен с использованием алгоритма параллельных реплик, и все хранилища правой части JOIN являются *MergeTree, будет использоваться локальный JOIN вместо GLOBAL JOIN.
## parallel_replicas_support_projection {#parallel_replicas_support_projection} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "1"},{"label": "New setting. Optimization of projections can be applied in parallel replicas. Effective only with enabled parallel_replicas_local_plan and aggregation_in_order is inactive."}]}]}/>

Оптимизация проекций может применяться в параллельных репликах. Эффективно только при включенном parallel_replicas_local_plan и неактивной агрегации_в_порядке.
## parallel_view_processing {#parallel_view_processing} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает одновременную отправку прикрепленных представлений вместо последовательной.
## parallelize_output_from_storages {#parallelize_output_from_storages} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.5"},{"label": "1"},{"label": "Allow parallelism when executing queries that read from file/url/s3/etc. This may reorder rows."}]}]}/>

Параллелизует выходной шаг чтения из хранилища. Это позволяет параллелизовать обработку запросов сразу после чтения из хранилища, если это возможно.
## parsedatetime_e_requires_space_padding {#parsedatetime_e_requires_space_padding} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Improved compatibility with MySQL DATE_FORMAT/STR_TO_DATE"}]}]}/>

Форматировщик '%e' в функции 'parseDateTime' ожидает, что дни с одной цифрой будут дополнены пробелами, например, ' 2' принимается, но '2' вызовет ошибку.
## parsedatetime_parse_without_leading_zeros {#parsedatetime_parse_without_leading_zeros} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.11"},{"label": "1"},{"label": "Improved compatibility with MySQL DATE_FORMAT/STR_TO_DATE"}]}]}/>

Форматировщики '%c', '%l' и '%k' в функции 'parseDateTime' разбирают месяцы и часы без ведущих нулей.
## partial_merge_join_left_table_buffer_bytes {#partial_merge_join_left_table_buffer_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если не 0, группы блоков левой таблицы объединяются в более крупные блоки для левой стороны при частичном объединении. Используется до 2x указанной памяти на поток присоединения.
## partial_merge_join_rows_in_right_blocks {#partial_merge_join_rows_in_right_blocks} 

<SettingsInfoBlock type="UInt64" default_value="65536" />

Ограничивает размеры блоков данных правого соединения в алгоритме частичного объединения для запросов [JOIN](../../sql-reference/statements/select/join.md).

Сервер ClickHouse:

1.  Делит данные правого соединения на блоки с максимум указанным количеством строк.
2.  Индексирует каждый блок по его минимальным и максимальным значениям.
3.  Разгружает подготовленные блоки на диск, если это возможно.

Допустимые значения:

- Любое положительное целое число. Рекомендуемый диапазон значений: \[1000, 100000\].
## partial_result_on_first_cancel {#partial_result_on_first_cancel} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет запросу возвращать частичный результат после отмены.
## parts_to_delay_insert {#parts_to_delay_insert} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если в целевой таблице содержится как минимум столько активных частей в одной партиции, искусственно замедляет вставку в таблицу.
## parts_to_throw_insert {#parts_to_throw_insert} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если в одной партиции целевой таблицы больше этого числа активных частей, выбрасывает исключение 'Слишком много частей ...'.
## per_part_index_stats {#per_part_index_stats} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting."}]}]}/>

        Логирует статистику индекса по частям.
## periodic_live_view_refresh {#periodic_live_view_refresh} 

<SettingsInfoBlock type="Seconds" default_value="60" />

Интервал, после которого периодически обновляемое live-представление принудительно обновляется.
## poll_interval {#poll_interval} 

<SettingsInfoBlock type="UInt64" default_value="10" />

Блокировка в цикле ожидания запроса на сервере на указанное количество секунд.
## postgresql_connection_attempt_timeout {#postgresql_connection_attempt_timeout} 

<SettingsInfoBlock type="UInt64" default_value="2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "2"},{"label": "Allow to control 'connect_timeout' parameter of PostgreSQL connection."}]}]}/>

Тайм-аут подключения в секундах для одной попытки подключения к конечной точке PostgreSQL. Значение передается как параметр `connect_timeout` в URL подключения.
## postgresql_connection_pool_auto_close_connection {#postgresql_connection_pool_auto_close_connection} 

<SettingsInfoBlock type="Bool" default_value="0" />

Закрыть соединение перед возвратом соединения в пул.
## postgresql_connection_pool_retries {#postgresql_connection_pool_retries} 

<SettingsInfoBlock type="UInt64" default_value="2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "2"},{"label": "Allow to control the number of retries in PostgreSQL connection pool."}]}]}/>

Число попыток отправки/получения в пуле подключений для движка таблиц PostgreSQL и движка базы данных.
## postgresql_connection_pool_size {#postgresql_connection_pool_size} 

<SettingsInfoBlock type="UInt64" default_value="16" />

Размер пула соединений для движка таблиц PostgreSQL и движка базы данных.
## postgresql_connection_pool_wait_timeout {#postgresql_connection_pool_wait_timeout} 

<SettingsInfoBlock type="UInt64" default_value="5000" />

Тайм-аут ожидания соединения в пустом пуле для движка таблиц PostgreSQL и движка базы данных. По умолчанию он будет блокировать в пустом пуле.
## postgresql_fault_injection_probability {#postgresql_fault_injection_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "0"},{"label": "New setting"}]}]}/>

Приблизительная вероятность сбоя внутренних (для репликации) запросов PostgreSQL. Допустимое значение находится в интервале [0.0f, 1.0f].
## prefer_column_name_to_alias {#prefer_column_name_to_alias} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает использование оригинальных имен колонок вместо псевдонимов в выражениях и условиях запроса. Это особенно важно, когда псевдоним совпадает с именем колонки, см. [Псевдонимы выражений](/sql-reference/syntax#notes-on-usage). Включите эту настройку, чтобы сделать правила синтаксиса псевдонимов в ClickHouse более совместимыми с большинством других движков баз данных.

Допустимые значения:

- 0 — Имя колонки заменяется псевдонимом.
- 1 — Имя колонки не заменяется псевдонимом.

**Пример**

Различие между включенным и выключенным:

Запрос:

```sql
SET prefer_column_name_to_alias = 0;
SELECT avg(number) AS number, max(number) FROM numbers(10);
```

Результат:

```text
Received exception from server (version 21.5.1):
Code: 184. DB::Exception: Received from localhost:9000. DB::Exception: Aggregate function avg(number) is found inside another aggregate function in query: While processing avg(number) AS number.
```

Запрос:

```sql
SET prefer_column_name_to_alias = 1;
SELECT avg(number) AS number, max(number) FROM numbers(10);
```

Результат:

```text
┌─number─┬─max(number)─┐
│    4.5 │           9 │
└────────┴─────────────┘
```
## prefer_external_sort_block_bytes {#prefer_external_sort_block_bytes} 

<SettingsInfoBlock type="UInt64" default_value="16744704" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "16744704"},{"label": "Prefer maximum block bytes for external sort, reduce the memory usage during merging."}]}]}/>

Предпочитать максимальный размер блока для внешней сортировки, снизить использование памяти при слиянии.
## prefer_global_in_and_join {#prefer_global_in_and_join} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает замену операторов `IN`/`JOIN` на `GLOBAL IN`/`GLOBAL JOIN`.

Допустимые значения:

- 0 — Отключено. Операторы `IN`/`JOIN` не заменяются на `GLOBAL IN`/`GLOBAL JOIN`.
- 1 — Включено. Операторы `IN`/`JOIN` заменяются на `GLOBAL IN`/`GLOBAL JOIN`.

**Использование**

Хотя `SET distributed_product_mode=global` может изменить поведение запросов для распределенных таблиц, он не подходит для локальных таблиц или таблиц из внешних источников. Вот здесь и вступает в силу настройка `prefer_global_in_and_join`.

Например, у нас есть узлы, обслуживающие запросы, которые содержат локальные таблицы, которые не подходят для распределения. Нам нужно разбросать их данные на лету во время распределенной обработки с ключевым словом `GLOBAL` — `GLOBAL IN`/`GLOBAL JOIN`.

Другой случай использования `prefer_global_in_and_join` — доступ к таблицам, созданным внешними движками. Эта настройка помогает уменьшить количество вызовов к внешним источникам при объединении таких таблиц: только один вызов на запрос.

**Смотрите также:**

- [Распределенные подзапросы](/sql-reference/operators/in#distributed-subqueries) для получения дополнительной информации о том, как использовать `GLOBAL IN`/`GLOBAL JOIN`.
## prefer_localhost_replica {#prefer_localhost_replica} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает/выключает предпочтительное использование локальной реплики при обработке распределенных запросов.

Допустимые значения:

- 1 — ClickHouse всегда отправляет запрос к локальной реплике, если она существует.
- 0 — ClickHouse использует стратегию балансировки, указанную в настройке [load_balancing](#load_balancing).

:::note
Отключите эту настройку, если вы используете [max_parallel_replicas](#max_parallel_replicas) без [parallel_replicas_custom_key](#parallel_replicas_custom_key).
Если [parallel_replicas_custom_key](#parallel_replicas_custom_key) установлена, отключите эту настройку только если она используется в кластере с несколькими шардами, содержащими несколько реплик.
Если она используется в кластере с одним шардом и несколькими репликами, отключение этой настройки может иметь отрицательные последствия.
:::
## prefer_warmed_unmerged_parts_seconds {#prefer_warmed_unmerged_parts_seconds} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Int64" default_value="0" />

Эта настройка имеет эффект только в ClickHouse Cloud. Если объединенная часть менее чем на это количество секунд старая и не была предварительно разогрета (см. [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch)), но все ее исходные части доступны и предварительно разогреты, SELECT запросы будут считываться из этих частей. Только для Replicated-/SharedMergeTree. Обратите внимание, что это проверяет только, была ли часть обработана CacheWarmer; если часть была загружена в кэш чем-то другим, она всё равно будет считаться холодной, пока CacheWarmer не обработает её; если она была нагрета, а затем выгружена из кэша, она всё равно будет считаться тёплой.
## preferred_block_size_bytes {#preferred_block_size_bytes} 

<SettingsInfoBlock type="UInt64" default_value="1000000" />

Эта настройка настраивает размер блока данных для обработки запросов и представляет собой дополнительную тонкую настройку к более грубой настройке 'max_block_size'. Если колонки большие и с 'max_block_size' строками, то размер блока, вероятно, окажется больше указанного количества байт; его размер будет уменьшен для лучшей локальности кэша CPU.
## preferred_max_column_in_block_size_bytes {#preferred_max_column_in_block_size_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничение на максимальный размер колонки в блоке при чтении. Помогает уменьшить количество промахов в кэше. Должен быть близок к размеру кэша L2.
## preferred_optimize_projection_name {#preferred_optimize_projection_name} 

Если установлено в непростую строку, ClickHouse попробует применить указанную проекцию в запросе.

Допустимые значения:

- строка: имя предпочитаемой проекции.
## prefetch_buffer_size {#prefetch_buffer_size} 

<SettingsInfoBlock type="UInt64" default_value="1048576" />

Максимальный размер буфера предвыборки для чтения из файловой системы.
## print_pretty_type_names {#print_pretty_type_names} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "1"},{"label": "Better user experience."}]}]}/>

Позволяет выводить глубоко вложенные имена типов в красивом виде с отступами в запросе `DESCRIBE` и в функции `toTypeName()`.

Пример:

```sql
CREATE TABLE test (a Tuple(b String, c Tuple(d Nullable(UInt64), e Array(UInt32), f Array(Tuple(g String, h Map(String, Array(Tuple(i String, j UInt64))))), k Date), l Nullable(String))) ENGINE=Memory;
DESCRIBE TABLE test FORMAT TSVRaw SETTINGS print_pretty_type_names=1;
```

```
a   Tuple(
    b String,
    c Tuple(
        d Nullable(UInt64),
        e Array(UInt32),
        f Array(Tuple(
            g String,
            h Map(
                String,
                Array(Tuple(
                    i String,
                    j UInt64
                ))
            )
        )),
        k Date
    ),
    l Nullable(String)
)
```
## priority {#priority} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Приоритет запроса. 1 - самый высокий, более высокое значение - более низкий приоритет; 0 - не использовать приоритеты.
## promql_database {#promql_database} 

<ExperimentalBadge/>

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": ""},{"label": "New experimental setting"}]}]}/>

Указывает имя базы данных, используемой диалектом 'promql'. Пустая строка означает текущую базу данных.
## promql_evaluation_time {#promql_evaluation_time} 

<ExperimentalBadge/>

<SettingsInfoBlock type="FloatAuto" default_value="auto" />

Устанавливает время оценки, которое будет использоваться с диалектом promql. 'auto' означает текущее время.
## promql_table {#promql_table} 

<ExperimentalBadge/>

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": ""},{"label": "New experimental setting"}]}]}/>

Указывает имя таблицы TimeSeries, используемой диалектом 'promql'.
## push_external_roles_in_interserver_queries {#push_external_roles_in_interserver_queries} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "New setting."}]}]}/>

Включить передачу пользовательских ролей от инициатора к другим узлам при выполнении запроса.
## query_cache_compress_entries {#query_cache_compress_entries} 

<SettingsInfoBlock type="Bool" default_value="1" />

Сжимает записи в [кэше запросов](../query-cache.md). Уменьшает использование памяти кэша запросов за счет более медленных вставок в него / чтения из него.

Допустимые значения:

- 0 - Отключено
- 1 - Включено
## query_cache_max_entries {#query_cache_max_entries} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество результатов запросов, которые текущий пользователь может сохранить в [кэше запросов](../query-cache.md). 0 означает неограниченно.

Допустимые значения:

- Положительное целое число >= 0.
## query_cache_max_size_in_bytes {#query_cache_max_size_in_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество памяти (в байтах), которое текущий пользователь может выделить в [кэше запросов](../query-cache.md). 0 означает неограниченно.

Допустимые значения:

- Положительное целое число >= 0.
## query_cache_min_query_duration {#query_cache_min_query_duration} 

<SettingsInfoBlock type="Milliseconds" default_value="0" />

Минимальная продолжительность в миллисекундах, на которую запрос должен выполняться, чтобы его результат был сохранён в [кэше запросов](../query-cache.md).

Допустимые значения:

- Положительное целое число >= 0.
## query_cache_min_query_runs {#query_cache_min_query_runs} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальное число раз, которое `SELECT` запрос должен выполниться перед тем, как его результат будет сохранён в [кэше запросов](../query-cache.md).

Допустимые значения:

- Положительное целое число >= 0.
## query_cache_nondeterministic_function_handling {#query_cache_nondeterministic_function_handling} 

<SettingsInfoBlock type="QueryResultCacheNondeterministicFunctionHandling" default_value="throw" />

Контролирует, как [кэш запросов](../query-cache.md) обрабатывает `SELECT` запросы с недетерминированными функциями, такими как `rand()` или `now()`.

Допустимые значения:

- `'throw'` - Выбросить исключение и не кэшировать результат запроса.
- `'save'` - Кэшировать результат запроса.
- `'ignore'` - Не кэшировать результат запроса и не выбрасывать исключение.
## query_cache_share_between_users {#query_cache_share_between_users} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, результат `SELECT` запросов, кэшированных в [кэше запросов](../query-cache.md), может быть прочитан другими пользователями.
Не рекомендуется включать эту настройку по соображениям безопасности.

Допустимые значения:

- 0 - Отключено
- 1 - Включено
## query_cache_squash_partial_results {#query_cache_squash_partial_results} 

<SettingsInfoBlock type="Bool" default_value="1" />

Сжимает частичные результаты в блоки размером [max_block_size](#max_block_size). Уменьшает производительность вставок в [кэш запросов](../query-cache.md), но улучшает сжимаемость записей кэша (см. [query_cache_compress-entries](#query_cache_compress_entries)).

Допустимые значения:

- 0 - Отключено
- 1 - Включено
## query_cache_system_table_handling {#query_cache_system_table_handling} 

<SettingsInfoBlock type="QueryResultCacheSystemTableHandling" default_value="throw" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "throw"},{"label": "The query cache no longer caches results of queries against system tables"}]}]}/>

Контролирует, как [кэш запросов](../query-cache.md) обрабатывает `SELECT` запросы к системным таблицам, т.е. таблицам в базах данных `system.*` и `information_schema.*`.

Допустимые значения:

- `'throw'` - Выбросить исключение и не кэшировать результат запроса.
- `'save'` - Кэшировать результат запроса.
- `'ignore'` - Не кэшировать результат запроса и не выбрасывать исключение.
## query_cache_tag {#query_cache_tag} 

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": ""},{"label": "New setting for labeling query cache settings."}]}]}/>

Строка, которая служит меткой для записей [кэша запросов](../query-cache.md).
Один и тот же запрос с разными метками считается разным кэшем.

Допустимые значения:

- Любая строка.
## query_cache_ttl {#query_cache_ttl} 

<SettingsInfoBlock type="Seconds" default_value="60" />

После этого времени в секундах записи в [кэше запросов](../query-cache.md) становятся устаревшими.

Допустимые значения:

- Положительное целое число >= 0.
## query_condition_cache_store_conditions_as_plaintext {#query_condition_cache_store_conditions_as_plaintext} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "New setting"}]}]}/>

Сохраняет условие фильтра для [кэша условий запросов](/operations/query-condition-cache) в виде открытого текста.
Если включено, system.query_condition_cache показывает дословное условие фильтра, что облегчает отладку проблем с кэшем.
Отключено по умолчанию, потому что условия фильтра в открытом виде могут раскрыть чувствительную информацию.

Допустимые значения:

- 0 - Отключено
- 1 - Включено
## query_metric_log_interval {#query_metric_log_interval} 

<SettingsInfoBlock type="Int64" default_value="-1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "-1"},{"label": "New setting."}]}]}/>

Интервал в миллисекундах, с которым собираются [журнал метрик запросов](../../operations/system-tables/query_metric_log.md) для отдельных запросов.

Если установлено любое отрицательное значение, оно возьмет значение `collect_interval_milliseconds` из [настройки журнала метрик запросов](/operations/server-configuration-parameters/settings#query_metric_log) или по умолчанию 1000, если не указано.

Чтобы отключить сбор отдельного запроса, установите `query_metric_log_interval` в 0.

Значение по умолчанию: -1
## query_plan_aggregation_in_order {#query_plan_aggregation_in_order} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.12"},{"label": "1"},{"label": "Enable some refactoring around query plan"}]}]}/>

Переключает оптимизацию уровня плана запроса агрегации в порядке.
Эта опция вступает в силу только если настройка [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_convert_any_join_to_semi_or_anti_join {#query_plan_convert_any_join_to_semi_or_anti_join} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "1"},{"label": "New setting."}]}]}/>

Позволяет конвертировать ANY JOIN в SEMI или ANTI JOIN, если фильтр после JOIN всегда оценивается как ложный для несовпадающих или совпадающих строк.
## query_plan_convert_join_to_in {#query_plan_convert_join_to_in} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "New setting"}]}]}/>

Позволяет конвертировать `JOIN` в подзапрос с `IN`, если выходные колонки привязаны только к левой таблице. Может вызвать неверные результаты с не-ANY JOIN (например, ALL JOIN, что является значением по умолчанию).
## query_plan_convert_outer_join_to_inner_join {#query_plan_convert_outer_join_to_inner_join} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "1"},{"label": "Allow to convert OUTER JOIN to INNER JOIN if filter after JOIN always filters default values"}]}]}/>

Позволяет конвертировать `OUTER JOIN` в `INNER JOIN`, если фильтр после `JOIN` всегда фильтрует значения по умолчанию.
## query_plan_direct_read_from_text_index {#query_plan_direct_read_from_text_index} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "1"},{"label": "New setting."}]}]}/>

Позволяет выполнять фильтрацию полнотекстового поиска, используя только инвертированный индекс в плане запроса.
## query_plan_display_internal_aliases {#query_plan_display_internal_aliases} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting"}]}]}/>

Показывает внутренние псевдонимы (такие как __table1) в EXPLAIN PLAN вместо тех, что указаны в исходном запросе.
## query_plan_enable_multithreading_after_window_functions {#query_plan_enable_multithreading_after_window_functions} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает многопоточность после оценки оконных функций для обеспечения параллельной потоковой обработки.
## query_plan_enable_optimizations {#query_plan_enable_optimizations} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию запроса на уровне плана запроса.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить все оптимизации на уровне плана запроса.
- 1 - Включить оптимизации на уровне плана запроса (но отдельные оптимизации все еще могут быть отключены через их отдельные настройки).
## query_plan_execute_functions_after_sorting {#query_plan_execute_functions_after_sorting} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию на уровне плана запроса, которая перемещает выражения после шагов сортировки. Эта опция вступает в силу только, если настройка [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_filter_push_down {#query_plan_filter_push_down} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию на уровне плана запроса, которая перемещает фильтры вниз в плане выполнения. Эта опция вступает в силу только, если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_join_shard_by_pk_ranges {#query_plan_join_shard_by_pk_ranges} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "New setting"}]}]}/>

Применяет шардирование для JOIN, если ключи объединения содержат префикс ПЕРВИЧНОГО КЛЮЧА для обеих таблиц. Поддерживается для алгоритмов hash, parallel_hash и full_sorting_merge. Обычно не ускоряет запросы, но может снизить потребление памяти.
## query_plan_join_swap_table {#query_plan_join_swap_table} 

<SettingsInfoBlock type="BoolAuto" default_value="auto" />

    Определяет, какая сторона объединения должна быть таблицей сборки (также называемой внутренней, то есть той, которая вставляется в хеш-таблицу для хеш-объединения) в плане запроса. Эта настройка поддерживается только для строгих `ALL` join с предложением `JOIN ON`. Возможные значения:
    - 'auto': Позволить планировщику решить, какую таблицу использовать в качестве таблицы сборки.
    - 'false': Никогда не менять таблицы (правой таблицей является таблица сборки).
    - 'true': Всегда менять таблицы (левой таблицей является таблица сборки).
## query_plan_lift_up_array_join {#query_plan_lift_up_array_join} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию на уровне плана запроса, которая перемещает ARRAY JOIN вверх в плане выполнения. Эта опция вступает в силу только, если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_lift_up_union {#query_plan_lift_up_union} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию на уровне плана запроса, которая перемещает большие поддеревья плана запроса в объединение для включения дальнейших оптимизаций. Эта опция вступает в силу только, если настройка [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_max_limit_for_lazy_materialization {#query_plan_max_limit_for_lazy_materialization} 

<SettingsInfoBlock type="UInt64" default_value="10" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "10"},{"label": "Added new setting to control maximum limit value that allows to use query plan for lazy materialization optimisation. If zero, there is no limit"}]}]}/>

Контролирует максимальное ограничение, которое позволяет использовать план запроса для оптимизации ленивой материализации. Если 0, ограничений нет.
## query_plan_max_optimizations_to_apply {#query_plan_max_optimizations_to_apply} 

<SettingsInfoBlock type="UInt64" default_value="10000" />

Ограничивает общее количество оптимизаций, применяемых к плану запроса, см. настройку [query_plan_enable_optimizations](#query_plan_enable_optimizations).
Полезно для избежания длительного времени оптимизации для сложных запросов.
В запросе EXPLAIN PLAN прекращает применение оптимизаций после достижения этого лимита и возвращает план как есть.
Для обычного выполнения запроса, если фактическое количество оптимизаций превышает эту настройку, выбрасывается исключение.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::
## query_plan_max_step_description_length {#query_plan_max_step_description_length} 

<SettingsInfoBlock type="UInt64" default_value="500" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "500"},{"label": "New setting"}]}]}/>

Максимальная длина описания шага в EXPLAIN PLAN.
## query_plan_merge_expressions {#query_plan_merge_expressions} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию на уровне плана запроса, которая объединяет последовательные фильтры.
Эта опция вступает в силу только, если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_merge_filter_into_join_condition {#query_plan_merge_filter_into_join_condition} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "Added new setting to merge filter into join condition"}]}]}/>

Позволяет объединять фильтр в условие `JOIN` и конвертировать `CROSS JOIN` в `INNER`.
## query_plan_merge_filters {#query_plan_merge_filters} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Allow to merge filters in the query plan"}]}, {"id": "row-2","items": [{"label": "24.11"},{"label": "1"},{"label": "Allow to merge filters in the query plan. This is required to properly support filter-push-down with a new analyzer."}]}]}/>

Позволяет объединять фильтры в плане запроса.
## query_plan_optimize_join_order_limit {#query_plan_optimize_join_order_limit} 

<SettingsInfoBlock type="UInt64" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting"}]}]}/>

    Оптимизирует порядок объединений в пределах одного подзапроса. В настоящее время поддерживается только для очень ограниченных случаев.
    Значение - максимальное количество таблиц для оптимизации.
## query_plan_optimize_lazy_materialization {#query_plan_optimize_lazy_materialization} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "Added new setting to use query plan for lazy materialization optimisation"}]}]}/>

Использует план запроса для оптимизации ленивой материализации.
## query_plan_optimize_prewhere {#query_plan_optimize_prewhere} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Allow to push down filter to PREWHERE expression for supported storages"}]}]}/>

Позволяет перемещать фильтр в выражение PREWHERE для поддерживаемых хранилищ.
## query_plan_push_down_limit {#query_plan_push_down_limit} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию на уровне плана запроса, которая перемещает LIMIT вниз в плане выполнения.
Эта опция вступает в силу только, если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_read_in_order {#query_plan_read_in_order} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию на уровне плана запроса для чтения в порядке.
Эта опция вступает в силу только, если настройка [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_remove_redundant_distinct {#query_plan_remove_redundant_distinct} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.2"},{"label": "1"},{"label": "Remove redundant Distinct step in query plan"}]}]}/>

Переключает оптимизацию на уровне плана запроса, которая удаляет избыточные DISTINCT шаги.
Эта опция вступает в силу только, если настройка [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_remove_redundant_sorting {#query_plan_remove_redundant_sorting} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.1"},{"label": "1"},{"label": "Remove redundant sorting in query plan. For example, sorting steps related to ORDER BY clauses in subqueries"}]}]}/>

Переключает оптимизацию на уровне плана запроса, которая удаляет избыточные шаги сортировки, например, в подзапросах.
Эта опция вступает в силу только, если настройка [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_reuse_storage_ordering_for_window_functions {#query_plan_reuse_storage_ordering_for_window_functions} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию на уровне плана запроса, которая использует сортировку хранилища при сортировке для оконных функций.
Эта опция вступает в силу только, если настройка [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_split_filter {#query_plan_split_filter} 

<SettingsInfoBlock type="Bool" default_value="1" />

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Переключает оптимизацию на уровне плана запроса, которая разбивает фильтры на выражения.
Эта опция вступает в силу только, если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_try_use_vector_search {#query_plan_try_use_vector_search} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "New setting."}]}]}/>

Переключает оптимизацию на уровне плана запроса, которая пытается использовать индекс векторного сходства.
Эта опция вступает в силу только, если настройка [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка для экспертов, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимыми способами или быть удалена.
:::

Допустимые значения:

- 0 - Отключить
- 1 - Включить
## query_plan_use_new_logical_join_step {#query_plan_use_new_logical_join_step} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Enable new step"}]}, {"id": "row-2","items": [{"label": "25.1"},{"label": "0"},{"label": "New join step, internal change"}]}]}/>

Использует логический шаг объединения в плане запроса.
Примечание: настройка `query_plan_use_new_logical_join_step` устарела, используйте `query_plan_use_logical_join_step` вместо неё.
## query_profiler_cpu_time_period_ns {#query_profiler_cpu_time_period_ns} 

<SettingsInfoBlock type="UInt64" default_value="1000000000" />

Устанавливает период для таймера тактового времени CPU [профайлера запросов](../../operations/optimizing-performance/sampling-query-profiler.md). Этот таймер учитывает только время CPU.

Допустимые значения:

- Положительное целое число в наносекундах.

    Рекомендуемые значения:

            - 10000000 (100 раз в секунду) наносекунд и более для одиночных запросов.
            - 1000000000 (один раз в секунду) для профилирования по всему кластеру.

- 0 для отключения таймера.

**Временно отключено в ClickHouse Cloud.**

Смотрите также:

- Системная таблица [trace_log](/operations/system-tables/trace_log).
## query_profiler_real_time_period_ns {#query_profiler_real_time_period_ns} 

<SettingsInfoBlock type="UInt64" default_value="1000000000" />

Устанавливает период для таймера реального времени [профайлера запросов](../../operations/optimizing-performance/sampling-query-profiler.md). Таймер реального времени отслеживает время реальных часов.

Допустимые значения:

- Положительное целое число в наносекундах.

    Рекомендуемые значения:

            - 10000000 (100 раз в секунду) наносекунд и меньше для одиночных запросов.
            - 1000000000 (один раз в секунду) для профилирования по всему кластеру.

- 0 для отключения таймера.

**Временно отключено в ClickHouse Cloud.**

Смотрите также:

- Системная таблица [trace_log](/operations/system-tables/trace_log).
## queue_max_wait_ms {#queue_max_wait_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время ожидания в очереди запросов, если количество параллельных запросов превышает максимальное.
## rabbitmq_max_wait_ms {#rabbitmq_max_wait_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="5000" />

Время ожидания чтения из RabbitMQ перед повторной попыткой.
## read_backoff_max_throughput {#read_backoff_max_throughput} 

<SettingsInfoBlock type="UInt64" default_value="1048576" />

Настройки для уменьшения количества потоков в случае медленного чтения. Подсчет событий, когда полоса пропускания чтения менее чем на это количество байт в секунду.
## read_backoff_min_concurrency {#read_backoff_min_concurrency} 

<SettingsInfoBlock type="UInt64" default_value="1" />

Настройки для попытки удержания минимального количества потоков в случае медленного чтения.
## read_backoff_min_events {#read_backoff_min_events} 

<SettingsInfoBlock type="UInt64" default_value="2" />

Настройки для уменьшения количества потоков в случае медленного чтения. Количество событий, после которых количество потоков будет уменьшено.
## read_backoff_min_interval_between_events_ms {#read_backoff_min_interval_between_events_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="1000" />

Настройки для уменьшения количества потоков в случае медленного чтения. Не обращать внимания на событие, если предыдущее прошло менее чем через определенный промежуток времени.
## read_backoff_min_latency_ms {#read_backoff_min_latency_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="1000" />

Настройка для уменьшения количества потоков в случае медленного чтения. Обращать внимание только на чтения, которые заняли как минимум столько времени.
## read_from_distributed_cache_if_exists_otherwise_bypass_cache {#read_from_distributed_cache_if_exists_otherwise_bypass_cache} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "0"},{"label": "New setting"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. То же, что и read_from_filesystem_cache_if_exists_otherwise_bypass_cache, но для распределенного кэша.
## read_from_filesystem_cache_if_exists_otherwise_bypass_cache {#read_from_filesystem_cache_if_exists_otherwise_bypass_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает использовать файловый кэш в пассивном режиме — использовать существующие записи в кэше, но не добавлять больше записей в кэш. Если вы установите эту настройку для тяжелых ad-hoc запросов и оставите её отключенной для коротких запросов в реальном времени, это позволит избежать истощения кэша от слишком тяжелых запросов и улучшить общую эффективность системы.
## read_from_page_cache_if_exists_otherwise_bypass_cache {#read_from_page_cache_if_exists_otherwise_bypass_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Added userspace page cache"}]}]}/>

Использовать кэш страниц пользовательского пространства в пассивном режиме, аналогично read_from_filesystem_cache_if_exists_otherwise_bypass_cache.
## read_in_order_two_level_merge_threshold {#read_in_order_two_level_merge_threshold} 

<SettingsInfoBlock type="UInt64" default_value="100" />

Минимальное количество частей для чтения, чтобы выполнить предварительный шаг слияния во время многопоточного чтения в порядке первичного ключа.
## read_in_order_use_buffering {#read_in_order_use_buffering} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "1"},{"label": "Use buffering before merging while reading in order of primary key"}]}]}/>

Использовать буферизацию перед слиянием при чтении в порядке первичного ключа. Это увеличивает параллелизм выполнения запроса.
## read_in_order_use_virtual_row {#read_in_order_use_virtual_row} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Use virtual row while reading in order of primary key or its monotonic function fashion. It is useful when searching over multiple parts as only relevant ones are touched."}]}]}/>

Использовать виртуальную строку при чтении в порядке первичного ключа или его монотонной функции. Это полезно при поиске по нескольким частям, так как затрагиваются только соответствующие.
## read_overflow_mode {#read_overflow_mode} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Что делать, когда превышен лимит.
## read_overflow_mode_leaf {#read_overflow_mode_leaf} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, когда объем прочитанных данных превышает один из предельных лимитов.

Возможные варианты:
- `throw`: выбрасывать исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат.
## read_priority {#read_priority} 



<SettingsInfoBlock type="Int64" default_value="0" />

Приоритет для чтения данных из локальной файловой системы или удаленной файловой системы. Поддерживается только для метода 'pread_threadpool' для локальной файловой системы и для метода `threadpool` для удаленной файловой системы.
## read_through_distributed_cache {#read_through_distributed_cache} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Воздействие только в ClickHouse Cloud. Разрешить чтение из распределенного кэша.
## readonly {#readonly} 



<SettingsInfoBlock type="UInt64" default_value="0" />

0 - никаких ограничений на только чтение. 1 - только запросы на чтение, а также изменение явно разрешенных настроек. 2 - только запросы на чтение, а также изменение настроек, за исключением настройки 'readonly'.
## receive_data_timeout_ms {#receive_data_timeout_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="2000" />

Таймаут соединения для получения первого пакета данных или пакета с положительным прогрессом от реплики.
## receive_timeout {#receive_timeout} 



<SettingsInfoBlock type="Seconds" default_value="300" />

Таймаут для получения данных из сети в секундах. Если в этот интервал не были получены байты, выбрасывается исключение. Если вы установите эту настройку на клиенте, таймаут 'send_timeout' для сокета также будет установлен на соответствующем конце соединения на сервере.
## regexp_max_matches_per_row {#regexp_max_matches_per_row} 



<SettingsInfoBlock type="UInt64" default_value="1000" />

Устанавливает максимальное количество совпадений для одного регулярного выражения на строку. Используйте его для защиты от перегрузки памяти при использовании жадного регулярного выражения в функции [extractAllGroupsHorizontal](/sql-reference/functions/string-search-functions#extractallgroupshorizontal).

Возможные значения:

- Положительное целое число.
## reject_expensive_hyperscan_regexps {#reject_expensive_hyperscan_regexps} 



<SettingsInfoBlock type="Bool" default_value="1" />

Отклоняет шаблоны, которые, вероятно, будут дорогими для оценки с помощью hyperscan (из-за взрыва состояния NFA).
## remerge_sort_lowered_memory_bytes_ratio {#remerge_sort_lowered_memory_bytes_ratio} 



<SettingsInfoBlock type="Float" default_value="2" />

Если использование памяти после повторного слияния не уменьшилось в этом соотношении, повторное слияние будет отключено.
## remote_filesystem_read_method {#remote_filesystem_read_method} 



<SettingsInfoBlock type="String" default_value="threadpool" />

Метод чтения данных из удаленной файловой системы, один из: read, threadpool.
## remote_filesystem_read_prefetch {#remote_filesystem_read_prefetch} 



<SettingsInfoBlock type="Bool" default_value="1" />

Следует использовать предварительную выборку при чтении данных из удаленной файловой системы.
## remote_fs_read_backoff_max_tries {#remote_fs_read_backoff_max_tries} 



<SettingsInfoBlock type="UInt64" default_value="5" />

Максимальное количество попыток чтения с использованием отскока.
## remote_fs_read_max_backoff_ms {#remote_fs_read_max_backoff_ms} 



<SettingsInfoBlock type="UInt64" default_value="10000" />

Максимальное время ожидания при попытке прочитать данные для удаленного диска.
## remote_read_min_bytes_for_seek {#remote_read_min_bytes_for_seek} 



<SettingsInfoBlock type="UInt64" default_value="4194304" />

Минимальное количество байт, необходимых для удаленного чтения (url, s3), чтобы выполнить поиск, вместо чтения с игнорированием.
## rename_files_after_processing {#rename_files_after_processing} 

- **Тип:** Строка

- **Значение по умолчанию:** Пустая строка

Эта настройка позволяет указать шаблон переименования для файлов, обработанных функцией таблицы `file`. Когда опция установлена, все файлы, прочитанные функцией таблицы `file`, будут переименованы в соответствии с указанным шаблоном с заполнителями, только если обработка файлов была успешной.
### Заполнители

- `%a` — Полное оригинальное имя файла (например, "sample.csv").
- `%f` — Оригинальное имя файла без расширения (например, "sample").
- `%e` — Оригинальное расширение файла с точкой (например, ".csv").
- `%t` — Временная метка (в микросекундах).
- `%%` — Знак процента ("%").
### Пример
- Опция: `--rename_files_after_processing="processed_%f_%t%e"`

- Запрос: `SELECT * FROM file('sample.csv')`


Если чтение `sample.csv` прошло успешно, файл будет переименован в `processed_sample_1683473210851438.csv`.
## replace_running_query {#replace_running_query} 



<SettingsInfoBlock type="Bool" default_value="0" />

При использовании HTTP-интерфейса можно передать параметр 'query_id'. Это любая строка, которая служит идентификатором запроса.
Если в это время уже существует запрос от того же пользователя с тем же 'query_id', поведение зависит от параметра 'replace_running_query'.

`0` (по умолчанию) – Выбросить исключение (не разрешать выполнение запроса, если запрос с тем же 'query_id' уже выполняется).

`1` – Отменить старый запрос и начать выполнение нового.

Установите этот параметр в 1 для реализации предложений по условиям сегментации. После ввода следующего символа, если старый запрос еще не завершился, он должен быть отменен.
## replace_running_query_max_wait_ms {#replace_running_query_max_wait_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="5000" />

Время ожидания для завершения выполнения запроса с тем же `query_id`, когда активна настройка [replace_running_query](#replace_running_query).

Возможные значения:

- Положительное целое число.
- 0 — Выбрасывание исключения, которое не позволяет запустить новый запрос, если сервер уже выполняет запрос с тем же `query_id`.
## replication_wait_for_inactive_replica_timeout {#replication_wait_for_inactive_replica_timeout} 



<SettingsInfoBlock type="Int64" default_value="120" />

Указывает, как долго (в секундах) ждать неактивные реплики для выполнения запросов [`ALTER`](../../sql-reference/statements/alter/index.md), [`OPTIMIZE`](../../sql-reference/statements/optimize.md) или [`TRUNCATE`](../../sql-reference/statements/truncate.md).

Возможные значения:

- `0` — Не ждать.
- Отрицательное целое число — Ждать неограниченное время.
- Положительное целое число — Количество секунд ожидания.
## restore_replace_external_dictionary_source_to_null {#restore_replace_external_dictionary_source_to_null} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "New setting."}]}]}/>

Заменить источники внешних словарей на Null при восстановлении. Полезно для тестирования.
## restore_replace_external_engines_to_null {#restore_replace_external_engines_to_null} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "New setting."}]}]}/>

Для тестирования. Заменяет все внешние движки на Null, чтобы не инициировать внешние подключения.
## restore_replace_external_table_functions_to_null {#restore_replace_external_table_functions_to_null} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "New setting."}]}]}/>

Для тестирования. Заменяет все внешние функции таблиц на Null, чтобы не инициировать внешние подключения.
## restore_replicated_merge_tree_to_shared_merge_tree {#restore_replicated_merge_tree_to_shared_merge_tree} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "0"},{"label": "New setting."}]}]}/>

Заменить движок таблицы с Replicated*MergeTree -> Shared*MergeTree при ВОССТАНОВЛЕНИИ.
## result_overflow_mode {#result_overflow_mode} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Значение по умолчанию в облаке: `throw`

Устанавливает, что делать, если объем результата превышает один из лимитов.

Возможные значения:
- `throw`: выбрасывать исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат, как если бы
           исходные данные закончились.

Использование 'break' похоже на использование LIMIT. `Break` прерывает выполнение только на
уровне блока. Это означает, что количество возвращаемых строк больше чем
[`max_result_rows`](/operations/settings/settings#max_result_rows), является кратным [`max_block_size`](/operations/settings/settings#max_block_size)
и зависит от [`max_threads`](/operations/settings/settings#max_threads).

**Пример**

```sql title="Query"
SET max_threads = 3, max_block_size = 3333;
SET max_result_rows = 3334, result_overflow_mode = 'break';

SELECT *
FROM numbers_mt(100000)
FORMAT Null;
```

```text title="Result"
6666 rows in set. ...
```
## rewrite_count_distinct_if_with_count_distinct_implementation {#rewrite_count_distinct_if_with_count_distinct_implementation} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.8"},{"label": "1"},{"label": "Rewrite countDistinctIf with count_distinct_implementation configuration"}]}]}/>

Позволяет переписывать `countDistcintIf` с настройкой [count_distinct_implementation](#count_distinct_implementation).

Возможные значения:

- true — Разрешить.
- false — Запретить.
## rewrite_in_to_join {#rewrite_in_to_join} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.10"},{"label": "0"},{"label": "New experimental setting"}]}]}/>

Переписывает выражения, такие как 'x IN subquery' в JOIN. Это может быть полезно для оптимизации всего запроса с изменением порядка JOIN.
## s3_allow_multipart_copy {#s3_allow_multipart_copy} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "New setting."}]}]}/>

Разрешить многочастичное копирование в S3.
## s3_allow_parallel_part_upload {#s3_allow_parallel_part_upload} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать несколько потоков для многочастичной загрузки в S3. Это может привести к немного большему использованию памяти.
## s3_check_objects_after_upload {#s3_check_objects_after_upload} 



<SettingsInfoBlock type="Bool" default_value="0" />

Проверять каждый загруженный объект в S3 с помощью запроса head, чтобы убедиться, что загрузка прошла успешно.
## s3_connect_timeout_ms {#s3_connect_timeout_ms} 



<SettingsInfoBlock type="UInt64" default_value="1000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1000"},{"label": "Introduce new dedicated setting for s3 connection timeout"}]}]}/>

Таймаут соединения для хоста с дисков S3.
## s3_create_new_file_on_insert {#s3_create_new_file_on_insert} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает создание нового файла при каждой вставке в таблицы движка S3. Если включено, при каждом вставке будет создан новый объект S3 с ключом, аналогичным следующему шаблону:

initial: `data.Parquet.gz` -> `data.1.Parquet.gz` -> `data.2.Parquet.gz`, и т.д.

Возможные значения:
- 0 — Запрос `INSERT` создает новый файл или завершается с ошибкой, если файл существует и s3_truncate_on_insert не установлен.
- 1 — Запрос `INSERT` создает новый файл при каждом вставке, используя суффикс (с второго) если s3_truncate_on_insert не установлен.

Смотрите больше деталей [здесь](/integrations/s3#inserting-data).
## s3_disable_checksum {#s3_disable_checksum} 



<SettingsInfoBlock type="Bool" default_value="0" />

Не рассчитывать контрольную сумму при отправке файла в S3. Это ускоряет записи, избегая избыточных проходов обработки над файлом. Это в основном безопасно, поскольку данные таблиц MergeTree все равно проверяются ClickHouse, а при доступе к S3 через HTTPS уровень TLS уже обеспечивает целостность при передаче через сеть. Хотя дополнительные контрольные суммы на S3 обеспечивают дополнительную защиту.
## s3_ignore_file_doesnt_exist {#s3_ignore_file_doesnt_exist} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Allow to return 0 rows when the requested files don't exist instead of throwing an exception in S3 table engine"}]}]}/>

Игнорировать отсутствие файла, если он не существует при чтении определенных ключей.

Возможные значения:
- 1 — `SELECT` возвращает пустой результат.
- 0 — `SELECT` выбрасывает исключение.
## s3_list_object_keys_size {#s3_list_object_keys_size} 



<SettingsInfoBlock type="UInt64" default_value="1000" />

Максимальное количество файлов, которые могут быть возвращены в пакетном запросе ListObject.
## s3_max_connections {#s3_max_connections} 



<SettingsInfoBlock type="UInt64" default_value="1024" />

Максимальное количество соединений на сервер.
## s3_max_get_burst {#s3_max_get_burst} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество запросов, которые могут быть выданы одновременно, прежде чем будет достигнут лимит запросов в секунду. По умолчанию (0) равно `s3_max_get_rps`.
## s3_max_get_rps {#s3_max_get_rps} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Лимит на количество запросов S3 GET в секунду до ограничения. Ноль означает отсутствие ограничений.
## s3_max_inflight_parts_for_one_file {#s3_max_inflight_parts_for_one_file} 



<SettingsInfoBlock type="UInt64" default_value="20" />

Максимальное количество одновременно загружаемых частей в запросе многочастичной загрузки. 0 означает неограниченное количество.
## s3_max_part_number {#s3_max_part_number} 



<SettingsInfoBlock type="UInt64" default_value="10000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "10000"},{"label": "Maximum part number number for s3 upload part"}]}]}/>

Максимальный номер части для загрузки S3.
## s3_max_put_burst {#s3_max_put_burst} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество запросов, которые могут быть выданы одновременно, прежде чем будет достигнут лимит запросов в секунду. По умолчанию (0) равно `s3_max_put_rps`.
## s3_max_put_rps {#s3_max_put_rps} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Лимит на количество запросов S3 PUT в секунду до ограничения. Ноль означает отсутствие ограничений.
## s3_max_single_operation_copy_size {#s3_max_single_operation_copy_size} 



<SettingsInfoBlock type="UInt64" default_value="33554432" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "33554432"},{"label": "Maximum size for a single copy operation in s3"}]}]}/>

Максимальный размер для копирования в одной операции в S3. Эта настройка используется только в случае, если s3_allow_multipart_copy истинно.
## s3_max_single_part_upload_size {#s3_max_single_part_upload_size} 



<SettingsInfoBlock type="UInt64" default_value="33554432" />

Максимальный размер объекта для загрузки с использованием одной части в S3.
## s3_max_single_read_retries {#s3_max_single_read_retries} 



<SettingsInfoBlock type="UInt64" default_value="4" />

Максимальное количество повторных попыток при одном чтении из S3.
## s3_max_unexpected_write_error_retries {#s3_max_unexpected_write_error_retries} 



<SettingsInfoBlock type="UInt64" default_value="4" />

Максимальное количество повторных попыток в случае неожиданных ошибок при записи в S3.
## s3_max_upload_part_size {#s3_max_upload_part_size} 



<SettingsInfoBlock type="UInt64" default_value="5368709120" />

Максимальный размер части для загрузки во время многочастичной загрузки в S3.
## s3_min_upload_part_size {#s3_min_upload_part_size} 



<SettingsInfoBlock type="UInt64" default_value="16777216" />

Минимальный размер части для загрузки во время многочастичной загрузки в S3.
## s3_request_timeout_ms {#s3_request_timeout_ms} 



<SettingsInfoBlock type="UInt64" default_value="30000" />

Таймаут простоя для отправки и получения данных в/из S3. Сбой, если один вызов чтения или записи TCP блокирует так долго.
## s3_skip_empty_files {#s3_skip_empty_files} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "We hope it will provide better UX"}]}]}/>

Включает или отключает пропуск пустых файлов в таблицах движка [S3](../../engines/table-engines/integrations/s3.md).

Возможные значения:
- 0 — `SELECT` выбрасывает исключение, если пустой файл не совместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.
## s3_slow_all_threads_after_network_error {#s3_slow_all_threads_after_network_error} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "New setting"}]}]}/>

При установке в `true` все потоки, выполняющие запросы S3 к одной и той же конечной точке резервного копирования, замедляются
после того, как любой отдельный запрос S3 столкнется с повторяемой сетевой ошибкой, такой как таймаут сокета.
При установке в `false` каждый поток обрабатывает отскок запроса S3 независимо от других.
## s3_slow_all_threads_after_retryable_error {#s3_slow_all_threads_after_retryable_error} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "Added an alias for setting `backup_slow_all_threads_after_retryable_s3_error`"}]}, {"id": "row-2","items": [{"label": "25.8"},{"label": "0"},{"label": "Added an alias for setting `backup_slow_all_threads_after_retryable_s3_error`"}]}, {"id": "row-3","items": [{"label": "25.6"},{"label": "0"},{"label": "Added an alias for setting `backup_slow_all_threads_after_retryable_s3_error`"}]}, {"id": "row-4","items": [{"label": "25.10"},{"label": "0"},{"label": "Disable the setting by default"}]}]}/>

При установке в `true` все потоки, выполняющие запросы S3 к одной и той же конечной точке, замедляются
после того, как любой отдельный запрос S3 столкнется с повторяемой ошибкой S3, такой как 'Slow Down'.
При установке в `false` каждый поток обрабатывает отскок запроса S3 независимо от других.
## s3_strict_upload_part_size {#s3_strict_upload_part_size} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Точный размер части для загрузки во время многочастичной загрузки в S3 (некоторые реализации не поддерживают части переменного размера).
## s3_throw_on_zero_files_match {#s3_throw_on_zero_files_match} 



<SettingsInfoBlock type="Bool" default_value="0" />

Выбросить ошибку, когда запрос ListObjects не может сопоставить ни один файл.
## s3_truncate_on_insert {#s3_truncate_on_insert} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает обрезку перед вставками в таблицы движка S3. Если отключено, будет выброшено исключение при попытках вставки, если объект S3 уже существует.

Возможные значения:
- 0 — Запрос `INSERT` создает новый файл или завершается с ошибкой, если файл существует и s3_create_new_file_on_insert не установлен.
- 1 — Запрос `INSERT` заменяет существующее содержимое файла новыми данными.

Смотрите больше деталей [здесь](/integrations/s3#inserting-data).
## s3_upload_part_size_multiply_factor {#s3_upload_part_size_multiply_factor} 



<SettingsInfoBlock type="UInt64" default_value="2" />

Увеличивать s3_min_upload_part_size на этот коэффициент каждый раз, когда s3_multiply_parts_count_threshold части загружены с одного запроса на запись в S3.
## s3_upload_part_size_multiply_parts_count_threshold {#s3_upload_part_size_multiply_parts_count_threshold} 



<SettingsInfoBlock type="UInt64" default_value="500" />

Каждый раз, когда это количество частей загружено в S3, s3_min_upload_part_size умножается на s3_upload_part_size_multiply_factor.
## s3_use_adaptive_timeouts {#s3_use_adaptive_timeouts} 



<SettingsInfoBlock type="Bool" default_value="1" />

При установке в `true` для всех запросов S3 первые две попытки производятся с низкими таймаутами отправки и получения.
При установке в `false` все попытки производятся с идентичными таймаутами.
## s3_validate_request_settings {#s3_validate_request_settings} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Allow to disable S3 request settings validation"}]}]}/>

Включает проверку настроек запроса S3.
Возможные значения:
- 1 — проверять настройки.
- 0 — не проверять настройки.
## s3queue_default_zookeeper_path {#s3queue_default_zookeeper_path} 



<SettingsInfoBlock type="String" default_value="/clickhouse/s3queue/" />

Префикс пути по умолчанию для zookeeper для движка S3Queue.
## s3queue_enable_logging_to_s3queue_log {#s3queue_enable_logging_to_s3queue_log} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включить запись в system.s3queue_log. Значение может быть переопределено для таблицы с помощью настроек таблицы.
## s3queue_migrate_old_metadata_to_buckets {#s3queue_migrate_old_metadata_to_buckets} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "New setting."}]}]}/>

Миграция старой структуры метаданных таблицы S3Queue в новую.
## schema_inference_cache_require_modification_time_for_url {#schema_inference_cache_require_modification_time_for_url} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать схему из кэша для URL с проверкой времени последнего изменения (для URL с заголовком Last-Modified).
## schema_inference_use_cache_for_azure {#schema_inference_use_cache_for_azure} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кэш в выводе схемы при использовании функции таблицы azure.
## schema_inference_use_cache_for_file {#schema_inference_use_cache_for_file} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кэш в выводе схемы при использовании функции таблицы file.
## schema_inference_use_cache_for_hdfs {#schema_inference_use_cache_for_hdfs} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кэш в выводе схемы при использовании функции таблицы hdfs.
## schema_inference_use_cache_for_s3 {#schema_inference_use_cache_for_s3} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кэш в выводе схемы при использовании функции таблицы s3.
## schema_inference_use_cache_for_url {#schema_inference_use_cache_for_url} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кэш в выводе схемы при использовании функции таблицы url.
## secondary_indices_enable_bulk_filtering {#secondary_indices_enable_bulk_filtering} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "A new algorithm for filtering by data skipping indices"}]}]}/>

Включить алгоритм пакетной фильтрации для индексов. Ожидается, что он будет всегда лучше, но у нас есть эта настройка для совместимости и контроля.
## select_sequential_consistency {#select_sequential_consistency} 



<SettingsInfoBlock type="UInt64" default_value="0" />

:::note
Эта настройка отличается по поведению между SharedMergeTree и ReplicatedMergeTree, смотрите [Консистенция SharedMergeTree](/cloud/reference/shared-merge-tree#consistency) для получения дополнительной информации о поведении `select_sequential_consistency` в SharedMergeTree.
:::

Включает или отключает последовательную консистентность для запросов `SELECT`. Требует отключения `insert_quorum_parallel` (включен по умолчанию).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

Использование

Когда последовательная консистентность включена, ClickHouse позволяет клиенту выполнять запрос `SELECT` только для тех реплик, которые содержат данные от всех предыдущих `INSERT` запросов, выполненных с использованием `insert_quorum`. Если клиент ссылается на частичную реплику, ClickHouse сгенерирует исключение. Запрос SELECT не будет включать данные, которые еще не были записаны в кворум реплик.

Когда `insert_quorum_parallel` включен (по умолчанию), тогда `select_sequential_consistency` не работает. Это связано с тем, что параллельные `INSERT` запросы могут быть записаны в различные наборы реплик кворума, так что нет гарантии, что одна реплика получит все записи.

Смотрите также:

- [insert_quorum](#insert_quorum)
- [insert_quorum_timeout](#insert_quorum_timeout)
- [insert_quorum_parallel](#insert_quorum_parallel)
## send_logs_level {#send_logs_level} 



<SettingsInfoBlock type="LogsLevel" default_value="fatal" />

Отправлять текстовые логи сервера с указанным минимальным уровнем клиенту. Допустимые значения: 'trace', 'debug', 'information', 'warning', 'error', 'fatal', 'none'.
## send_logs_source_regexp {#send_logs_source_regexp} 

Отправлять текстовые логи сервера с указанным регулярным выражением для сопоставления имени источника лога. Пустое значение означает все источники.
## send_progress_in_http_headers {#send_progress_in_http_headers} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает заголовки HTTP-ответа `X-ClickHouse-Progress` в ответах `clickhouse-server`.

Для получения дополнительной информации, смотрите описание [HTTP интерфейса](../../interfaces/http.md).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
## send_timeout {#send_timeout} 



<SettingsInfoBlock type="Seconds" default_value="300" />

Таймаут для отправки данных в сеть в секундах. Если клиенту необходимо отправить некоторые данные, но он не может отправить байты в этом интервале, выбрасывается исключение. Если вы установите эту настройку на клиенте, таймаут 'receive_timeout' для сокета также будет установлен на соответствующем конце соединения на сервере.
## serialize_query_plan {#serialize_query_plan} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "NewSetting"}]}]}/>

Сериализовать план запроса для распределенной обработки.
## session_timezone {#session_timezone} 

<BetaBadge/>

Устанавливает неявный часовой пояс текущей сессии или запроса.
Неявный часовой пояс — это часовой пояс, применяемый к значениям типа DateTime/DateTime64, у которых не указан явно часовой пояс.
Эта настройка имеет приоритет над глобально настроенным (на уровне сервера) неявным часовым поясом.
Значение '' (пустая строка) означает, что неявный часовой пояс текущей сессии или запроса равен [часовому поясу сервера](../server-configuration-parameters/settings.md/#timezone).

Вы можете использовать функции `timeZone()` и `serverTimeZone()`, чтобы получить часовой пояс сессии и часовой пояс сервера.

Возможные значения:

- Любое имя часового пояса из `system.time_zones`, например, `Europe/Berlin`, `UTC` или `Zulu`.

Примеры:

```sql
SELECT timeZone(), serverTimeZone() FORMAT CSV

"Europe/Berlin","Europe/Berlin"
```

```sql
SELECT timeZone(), serverTimeZone() SETTINGS session_timezone = 'Asia/Novosibirsk' FORMAT CSV

"Asia/Novosibirsk","Europe/Berlin"
```

Назначьте часовую зону сессии 'America/Denver' внутреннему DateTime без явно указанного часового пояса:

```sql
SELECT toDateTime64(toDateTime64('1999-12-12 23:23:23.123', 3), 3, 'Europe/Zurich') SETTINGS session_timezone = 'America/Denver' FORMAT TSV

1999-12-13 07:23:23.123
```

:::warning
Не все функции, которые разбирают DateTime/DateTime64, учитывают `session_timezone`. Это может привести к тонким ошибкам.
Смотрите следующий пример и объяснение.
:::

```sql
CREATE TABLE test_tz (`d` DateTime('UTC')) ENGINE = Memory AS SELECT toDateTime('2000-01-01 00:00:00', 'UTC');

SELECT *, timeZone() FROM test_tz WHERE d = toDateTime('2000-01-01 00:00:00') SETTINGS session_timezone = 'Asia/Novosibirsk'
0 rows in set.

SELECT *, timeZone() FROM test_tz WHERE d = '2000-01-01 00:00:00' SETTINGS session_timezone = 'Asia/Novosibirsk'
┌───────────────────d─┬─timeZone()───────┐
│ 2000-01-01 00:00:00 │ Asia/Novosibirsk │
└─────────────────────┴──────────────────┘
```

Это происходит из-за различных конвейеров разбора:

- `toDateTime()` без явно заданного часового пояса, использованного в первом запросе `SELECT`, учитывает настройку `session_timezone` и глобальный часовой пояс.
- Во втором запросе DateTime разбирается из строки и наследует тип и часовой пояс существующей колонки `d`. Таким образом, установка `session_timezone` и глобального часового пояса не учитывается.

**Смотрите также**

- [timezone](../server-configuration-parameters/settings.md/#timezone).
## set_overflow_mode {#set_overflow_mode} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, когда количество данных превышает один из лимитов.

Возможные значения:
- `throw`: выбрасывать исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат, как если бы
исходные данные закончились.
## shared_merge_tree_sync_parts_on_partition_operations {#shared_merge_tree_sync_parts_on_partition_operations} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "1"},{"label": "New setting. By default parts are always synchronized"}]}]}/>

Автоматическая синхронизация набора частей данных после операций MOVE|REPLACE|ATTACH на партициях в таблицах SMT. Только для облака.
## short_circuit_function_evaluation {#short_circuit_function_evaluation} 



<SettingsInfoBlock type="ShortCircuitFunctionEvaluation" default_value="enable" />

Позволяет вычислять функции [if](../../sql-reference/functions/conditional-functions.md/#if), [multiIf](../../sql-reference/functions/conditional-functions.md/#multiIf), [and](/sql-reference/functions/logical-functions#and) и [or](/sql-reference/functions/logical-functions#or) согласно [схеме короткого замыкания](https://en.wikipedia.org/wiki/Short-circuit_evaluation). Это помогает оптимизировать выполнение сложных выражений в этих функциях и предотвращает возможные исключения (такие как деление на ноль, когда это не ожидается).

Возможные значения:

- `enable` — Включает вычисление функций с коротким замыканием для подходящих функций (может выбрасывать исключение или требовать значительных вычислений).
- `force_enable` — Включает вычисление функций с коротким замыканием для всех функций.
- `disable` — Отключает вычисление функций с коротким замыканием.
## short_circuit_function_evaluation_for_nulls {#short_circuit_function_evaluation_for_nulls} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Allow to execute functions with Nullable arguments only on rows with non-NULL values in all arguments"}]}]}/>

Оптимизирует выполнение функций, которые возвращают NULL, когда любой аргумент равен NULL. Когда процент NULL значений в аргументах функции превышает short_circuit_function_evaluation_for_nulls_threshold, система пропускает выполнение функции построчно. Вместо этого она сразу возвращает NULL для всех строк, избегая ненужных вычислений.
## short_circuit_function_evaluation_for_nulls_threshold {#short_circuit_function_evaluation_for_nulls_threshold} 



<SettingsInfoBlock type="Double" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Ratio threshold of NULL values to execute functions with Nullable arguments only on rows with non-NULL values in all arguments. Applies when setting short_circuit_function_evaluation_for_nulls is enabled."}]}]}/>

Порог соотношения NULL значений для выполнения функций с Nullable аргументами только по строкам с ненулевыми значениями во всех аргументах. Применяется, когда настройка short_circuit_function_evaluation_for_nulls включена.
Когда соотношение строк, содержащих NULL значения, к общему количеству строк превышает этот порог, строки, содержащие NULL значения, не будут оцениваться.
## show_data_lake_catalogs_in_system_tables {#show_data_lake_catalogs_in_system_tables} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "1"},{"label": "New setting"}]}]}/>

Включает отображение каталогов ДатаЛэйка в системных таблицах.
## show_table_uuid_in_table_create_query_if_not_nil {#show_table_uuid_in_table_create_query_if_not_nil} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "20.7"},{"label": "0"},{"label": "Stop showing  UID of the table in its CREATE query for Engine=Atomic"}]}]}/>

Устанавливает отображение запроса `SHOW TABLE`.

Возможные значения:

- 0 — Запрос будет отображен без UUID таблицы.
- 1 — Запрос будет отображен с UUID таблицы.
## single_join_prefer_left_table {#single_join_prefer_left_table} 



<SettingsInfoBlock type="Bool" default_value="1" />

Для одного JOIN в случае неоднозначности идентификатора предпочитать левую таблицу.
## skip_redundant_aliases_in_udf {#skip_redundant_aliases_in_udf} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "0"},{"label": "When enabled, this allows you to use the same user defined function several times for several materialized columns in the same table."}]}]}/>

Избыточные псевдонимы не используются (заменяются) в пользовательских функциях для упрощения их использования.

Возможные значения:

- 1 — Псевдонимы пропускаются (заменяются) в UDF.
- 0 — Псевдонимы не пропускаются (заменяются) в UDF.

**Пример**

Разница между включенным и отключенным:

Запрос:

```sql
SET skip_redundant_aliases_in_udf = 0;
CREATE FUNCTION IF NOT EXISTS test_03274 AS ( x ) -> ((x + 1 as y, y + 2));

EXPLAIN SYNTAX SELECT test_03274(4 + 2);
```

Результат:

```text
SELECT ((4 + 2) + 1 AS y, y + 2)
```

Запрос:

```sql
SET skip_redundant_aliases_in_udf = 1;
CREATE FUNCTION IF NOT EXISTS test_03274 AS ( x ) -> ((x + 1 as y, y + 2));

EXPLAIN SYNTAX SELECT test_03274(4 + 2);
```

Результат:

```text
SELECT ((4 + 2) + 1, ((4 + 2) + 1) + 2)
```
## skip_unavailable_shards {#skip_unavailable_shards} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает тихое пропускание недоступных шардов.

Шард считается недоступным, если все его реплики недоступны. Реплика недоступна в следующих случаях:

- ClickHouse не может подключиться к реплике по любой причине.

    При подключении к реплике ClickHouse выполняет несколько попыток. Если все эти попытки неудачны, реплика считается недоступной.

- Реплика не может быть разрешена через DNS.

    Если имя хоста реплики не может быть разрешено через DNS, это может указывать на следующие ситуации:

    - У хоста реплики нет DNS-записи. Это может произойти в системах с динамическим DNS, например, [Kubernetes](https://kubernetes.io), где узлы могут быть неразрешимы во время простоя, и это не ошибка.

    - Ошибка конфигурации. Конфигурационный файл ClickHouse содержит неверное имя хоста.

Возможные значения:

- 1 — пропуск разрешен.

    Если шард недоступен, ClickHouse возвращает результат на основе частичных данных и не сообщает о проблемах с доступностью узла.

- 0 — пропуск отключен.

    Если шард недоступен, ClickHouse выбрасывает исключение.
## sleep_after_receiving_query_ms {#sleep_after_receiving_query_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время ожидания после получения запроса в TCPHandler.
## sleep_in_send_data_ms {#sleep_in_send_data_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время ожидания при отправке данных в TCPHandler.
## sleep_in_send_tables_status_ms {#sleep_in_send_tables_status_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время ожидания при отправке ответа со статусом таблиц в TCPHandler.
## sort_overflow_mode {#sort_overflow_mode} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, если количество строк, полученных перед сортировкой, превышает один из лимитов.

Возможные значения:
- `throw`: выбрасывать исключение.
- `break`: остановить выполнение запроса и вернуть частичный результат.
## split_intersecting_parts_ranges_into_layers_final {#split_intersecting_parts_ranges_into_layers_final} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Allow to split intersecting parts ranges into layers during FINAL optimization"}]}, {"id": "row-2","items": [{"label": "24.1"},{"label": "1"},{"label": "Allow to split intersecting parts ranges into layers during FINAL optimization"}]}]}/>

Разделить пересекающиеся диапазоны частей на слои во время окончательной оптимизации.
## split_parts_ranges_into_intersecting_and_non_intersecting_final {#split_parts_ranges_into_intersecting_and_non_intersecting_final} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Allow to split parts ranges into intersecting and non intersecting during FINAL optimization"}]}, {"id": "row-2","items": [{"label": "24.1"},{"label": "1"},{"label": "Allow to split parts ranges into intersecting and non intersecting during FINAL optimization"}]}]}/>

Разделить диапазоны частей на пересекающиеся и непересекающиеся во время окончательной оптимизации.
## splitby_max_substrings_includes_remaining_string {#splitby_max_substrings_includes_remaining_string} 



<SettingsInfoBlock type="Bool" default_value="0" />

Управляет тем, включает ли функция [splitBy*()](../../sql-reference/functions/splitting-merging-functions.md) с аргументом `max_substrings` > 0 остаток строки в последний элемент результирующего массива.

Возможные значения:

- `0` - Остаток строки не будет включен в последний элемент результирующего массива.
- `1` - Остаток строки будет включен в последний элемент результирующего массива. Это поведение функции Spark [`split()`](https://spark.apache.org/docs/3.1.2/api/python/reference/api/pyspark.sql.functions.split.html) и метода Python ['string.split()'](https://docs.python.org/3/library/stdtypes.html#str.split).
## stop_refreshable_materialized_views_on_startup {#stop_refreshable_materialized_views_on_startup} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

При запуске сервера предотвращает планирование обновляемых материализованных представлений, как если бы с SYSTEM STOP VIEWS. Вы можете вручную запустить их с помощью `SYSTEM START VIEWS` или `SYSTEM START VIEW <name>` позже. Также применяется к вновь созданным представлениям. Не влияет на не обновляемые материализованные представления.
## storage_file_read_method {#storage_file_read_method} 



<SettingsInfoBlock type="LocalFSReadMethod" default_value="pread" />

Метод чтения данных из файла хранилища, один из: `read`, `pread`, `mmap`. Метод mmap не применяется к clickhouse-server (предназначен для clickhouse-local).
## storage_system_stack_trace_pipe_read_timeout_ms {#storage_system_stack_trace_pipe_read_timeout_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="100" />

Максимальное время чтения из трубы для получения информации от потоков при запросе таблицы `system.stack_trace`. Эта настройка используется для тестирования и не предназначена для изменения пользователями.
## stream_flush_interval_ms {#stream_flush_interval_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="7500" />

Работает для таблиц с потоковой передачей в случае таймаута или когда поток генерирует [max_insert_block_size](#max_insert_block_size) строк.

Значение по умолчанию — 7500.

Чем меньше значение, тем чаще данные сбрасываются в таблицу. Установка значения слишком низким приводит к снижению производительности.
## stream_like_engine_allow_direct_select {#stream_like_engine_allow_direct_select} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.12"},{"label": "0"},{"label": "Do not allow direct select for Kafka/RabbitMQ/FileLog by default"}]}]}/>

Разрешить прямой SELECT запрос для движков Kafka, RabbitMQ, FileLog, Redis Streams и NATS. В случае, если имеются прикрепленные материализованные представления, запрос SELECT не разрешается, даже если эта настройка включена.
## stream_like_engine_insert_queue {#stream_like_engine_insert_queue} 

Когда движок, похожий на поток, считывает из нескольких очередей, пользователю необходимо выбрать одну очередь для вставки при записи. Используется Redis Streams и NATS.
## stream_poll_timeout_ms {#stream_poll_timeout_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="500" />

Таймаут для опроса данных из/в потоковые хранилища.
## system_events_show_zero_values {#system_events_show_zero_values} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет выбирать события с нулевыми значениями из [`system.events`](../../operations/system-tables/events.md).

Некоторые системы мониторинга требуют передачи всех значений метрик для каждой точки контроля, даже если значение метрики равно нулю.

Допустимые значения:

- 0 — Отключено.
- 1 — Включено.

**Примеры**

Запрос

```sql
SELECT * FROM system.events WHERE event='QueryMemoryLimitExceeded';
```

Результат

```text
Ok.
```

Запрос
```sql
SET system_events_show_zero_values = 1;
SELECT * FROM system.events WHERE event='QueryMemoryLimitExceeded';
```

Результат

```text
┌─event────────────────────┬─value─┬─description───────────────────────────────────────────┐
│ QueryMemoryLimitExceeded │     0 │ Number of times when memory limit exceeded for query. │
└──────────────────────────┴───────┴───────────────────────────────────────────────────────┘
```
## table_engine_read_through_distributed_cache {#table_engine_read_through_distributed_cache} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "0"},{"label": "New setting"}]}]}/>

Действует только в ClickHouse Cloud. Позволяет читать из распределенного кэша через движки таблиц / табличные функции (s3, azure и т.д.)
## table_function_remote_max_addresses {#table_function_remote_max_addresses} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Устанавливает максимальное число адресов, генерируемых из шаблонов для функции [remote](../../sql-reference/table-functions/remote.md).

Возможные значения:

- Положительное целое число.
## tcp_keep_alive_timeout {#tcp_keep_alive_timeout} 

<SettingsInfoBlock type="Seconds" default_value="290" />

Время в секундах, в течение которого соединение должно оставаться неактивным, прежде чем TCP начнет отправлять сообщения keepalive.
## temporary_data_in_cache_reserve_space_wait_lock_timeout_milliseconds {#temporary_data_in_cache_reserve_space_wait_lock_timeout_milliseconds} 

<SettingsInfoBlock type="UInt64" default_value="600000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "600000"},{"label": "Wait time to lock cache for space reservation in temporary data in filesystem cache"}]}]}/>

Время ожидания для блокировки кэша с целью резервирования пространства для временных данных в кэше файловой системы.
## temporary_files_codec {#temporary_files_codec} 

<SettingsInfoBlock type="String" default_value="LZ4" />

Устанавливает кодек сжатия для временных файлов, используемых в операциях сортировки и объединения на диске.

Возможные значения:

- LZ4 — применяется сжатие [LZ4](https://en.wikipedia.org/wiki/LZ4_(compression_algorithm)).
- NONE — сжатие не применяется.
## text_index_use_bloom_filter {#text_index_use_bloom_filter} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "1"},{"label": "New setting."}]}]}/>

Для тестирования, включает или отключает использование фильтра Блума в текстовом индексе.
## throw_if_deduplication_in_dependent_materialized_views_enabled_with_async_insert {#throw_if_deduplication_in_dependent_materialized_views_enabled_with_async_insert} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Deduplication in dependent materialized view cannot work together with async inserts."}]}]}/>

Выбрасывает исключение при выполнении запроса INSERT, когда настройка `deduplicate_blocks_in_dependent_materialized_views` включена вместе с `async_insert`. Это гарантирует корректность, поскольку эти функции не могут работать вместе.
## throw_if_no_data_to_insert {#throw_if_no_data_to_insert} 

<SettingsInfoBlock type="Bool" default_value="1" />

Позволяет или запрещает пустые INSERT-запросы, включено по умолчанию (выбрасывает ошибку при пустом вставке). Применяется только к INSERT-запросам, использующим [`clickhouse-client`](/interfaces/cli) или [gRPC интерфейс](/interfaces/grpc).
## throw_on_error_from_cache_on_write_operations {#throw_on_error_from_cache_on_write_operations} 

<SettingsInfoBlock type="Bool" default_value="0" />

Игнорировать ошибку из кэша при кэшировании операций записи (INSERT, слияния).
## throw_on_max_partitions_per_insert_block {#throw_on_max_partitions_per_insert_block} 

<SettingsInfoBlock type="Bool" default_value="1" />

Позволяет контролировать поведение при достижении `max_partitions_per_insert_block`.

Возможные значения:
- `true`  - Когда блок вставки достигает `max_partitions_per_insert_block`, возникает исключение.
- `false` - Логирует предупреждение, когда достигается `max_partitions_per_insert_block`.

:::tip
Это может быть полезно, если вы пытаетесь понять влияние на пользователей при изменении [`max_partitions_per_insert_block`](/operations/settings/settings#max_partitions_per_insert_block).
:::
## throw_on_unsupported_query_inside_transaction {#throw_on_unsupported_query_inside_transaction} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

Выбрасывает исключение, если неподдерживаемый запрос используется внутри транзакции.
## timeout_before_checking_execution_speed {#timeout_before_checking_execution_speed} 

<SettingsInfoBlock type="Seconds" default_value="10" />

Проверяет, что скорость выполнения не слишком медленная (не меньше `min_execution_speed`),
после истечения указанного времени в секундах.
## timeout_overflow_mode {#timeout_overflow_mode} 

Устанавливает, что делать, если запрос выполняется дольше, чем `max_execution_time` или
предполагаемое время выполнения превышает `max_estimated_execution_time`.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат, как если бы
исходные данные закончились.
## timeout_overflow_mode_leaf {#timeout_overflow_mode_leaf} 

<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, когда запрос в узле-листве выполняется дольше, чем `max_execution_time_leaf`.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат, как если бы
исходные данные закончились.
## totals_auto_threshold {#totals_auto_threshold} 

<SettingsInfoBlock type="Float" default_value="0.5" />

Порог для `totals_mode = 'auto'`.
Смотрите раздел "WITH TOTALS модификатор".
## totals_mode {#totals_mode} 

Как вычислять TOTALS, когда присутствует HAVING, а также когда действуют max_rows_to_group_by и group_by_overflow_mode = 'any'.
Смотрите раздел "WITH TOTALS модификатор".
## trace_profile_events {#trace_profile_events} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает сбор трассировок стека при каждом обновлении событий профиля вместе с именем события профиля и значением инкремента и отправкой их в [trace_log](/operations/system-tables/trace_log).

Возможные значения:

- 1 — Сбор данных профиля включен.
- 0 — Сбор данных профиля отключен.
## transfer_overflow_mode {#transfer_overflow_mode} 

Устанавливает, что происходит, когда объем данных превышает один из лимитов.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат, как если бы
исходные данные закончились.
## transform_null_in {#transform_null_in} 

Включает равенство значений [NULL](/sql-reference/syntax#null) для оператора [IN](../../sql-reference/operators/in.md).

По умолчанию значения `NULL` не могут быть сравнены, поскольку `NULL` означает неопределенное значение. Таким образом, сравнение `expr = NULL` всегда должно возвращать `false`. С этой настройкой `NULL = NULL` возвращает `true` для оператора `IN`.

Возможные значения:

- 0 — Сравнение значений `NULL` в операторе `IN` возвращает `false`.
- 1 — Сравнение значений `NULL` в операторе `IN` возвращает `true`.

**Пример**

Рассмотрим таблицу `null_in`:

```text
┌──idx─┬─────i─┐
│    1 │     1 │
│    2 │  NULL │
│    3 │     3 │
└──────┴───────┘
```

Запрос:

```sql
SELECT idx, i FROM null_in WHERE i IN (1, NULL) SETTINGS transform_null_in = 0;
```

Результат:

```text
┌──idx─┬────i─┐
│    1 │    1 │
└──────┴──────┘
```

Запрос:

```sql
SELECT idx, i FROM null_in WHERE i IN (1, NULL) SETTINGS transform_null_in = 1;
```

Результат:

```text
┌──idx─┬─────i─┐
│    1 │     1 │
│    2 │  NULL │
└──────┴───────┘
```

**См. также**

- [Обработка NULL в операторах IN](/sql-reference/operators/in#null-processing)
## traverse_shadow_remote_data_paths {#traverse_shadow_remote_data_paths} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Traverse shadow directory when query system.remote_data_paths."}]}]}/>

Перебирать замороженные данные (теневая директория) в дополнение к фактическим данным таблицы при запросе system.remote_data_paths.
## union_default_mode {#union_default_mode} 

Устанавливает режим для объединения результатов запроса `SELECT`. Настройка используется только при использовании [UNION](../../sql-reference/statements/select/union.md) без явно указания `UNION ALL` или `UNION DISTINCT`.

Возможные значения:

- `'DISTINCT'` — ClickHouse выводит строки в результате комбинирования запросов, исключая дублирующиеся строки.
- `'ALL'` — ClickHouse выводит все строки в результате комбинирования запросов, включая дублирующиеся строки.
- `''` — ClickHouse генерирует исключение при использовании с `UNION`.

Смотрите примеры в [UNION](../../sql-reference/statements/select/union.md).
## unknown_packet_in_send_data {#unknown_packet_in_send_data} 

Отправить неизвестный пакет вместо N-го пакета данных.
## update_parallel_mode {#update_parallel_mode} 

<SettingsInfoBlock type="UpdateParallelMode" default_value="auto" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "auto"},{"label": "A new setting"}]}]}/>

Определяет поведение параллельных обновляющих запросов.

Возможные значения:
- `sync` - выполнять последовательно все запросы `UPDATE`.
- `auto` - выполнять последовательно только запросы `UPDATE` с зависимостями между колонками, обновленными в одном запросе и колонками, использованными в выражениях другого запроса.
- `async` - не синхронизировать обновляющие запросы.
## update_sequential_consistency {#update_sequential_consistency} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "A new setting"}]}]}/>

Если значение истинно, набор частей обновляется до последней версии перед выполнением обновления.
## use_async_executor_for_materialized_views {#use_async_executor_for_materialized_views} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "0"},{"label": "New setting."}]}]}/>

Использовать асинхронное и потенциально многопоточное выполнение запроса материализованного представления, что может ускорить обработку представлений во время INSERT, но также потребует больше памяти.
## use_cache_for_count_from_files {#use_cache_for_count_from_files} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает кэширование числа строк при подсчете из файлов в табличных функциях `file`/`s3`/`url`/`hdfs`/`azureBlobStorage`.

Включено по умолчанию.
## use_client_time_zone {#use_client_time_zone} 

Использовать часовой пояс клиента для интерпретации значений строковых DateTime, вместо принятия часового пояса сервера.
## use_compact_format_in_distributed_parts_names {#use_compact_format_in_distributed_parts_names} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.1"},{"label": "1"},{"label": "Use compact format for async INSERT into Distributed tables by default"}]}]}/>

Использует компактный формат для хранения блоков для фоновой вставки (`distributed_foreground_insert`) в таблицы с движком `Distributed`.

Возможные значения:

- 0 — Использует формат директории `user[:password]@host:port#default_database`.
- 1 — Использует формат директории `[shard{shard_index}[_replica{replica_index}]]`.

:::note
- с `use_compact_format_in_distributed_parts_names=0` изменения из определения кластера не будут применены для фоновой вставки.
- с `use_compact_format_in_distributed_parts_names=1` изменение порядка узлов в определении кластера изменит `shard_index`/`replica_index`, поэтому будьте внимательны.
:::
## use_concurrency_control {#use_concurrency_control} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "1"},{"label": "Enable concurrency control by default"}]}]}/>

Учитывать контроль параллелизма сервера (см. глобальные настройки сервера `concurrent_threads_soft_limit_num` и `concurrent_threads_soft_limit_ratio_to_cores`). Если отключено, позволяет использовать большее количество потоков, даже если сервер перегружен (не рекомендуется для обычного использования и необходимо в основном для тестов).
## use_hedged_requests {#use_hedged_requests} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.9"},{"label": "1"},{"label": "Enable Hedged Requests feature by default"}]}]}/>

Включает логику хеджирования запросов для удаленных запросов. Это позволяет устанавливать несколько соединений с различными репликами для запроса.
Новое соединение устанавливается в случае, если существующие соединения с репликами не были установлены в течение `hedged_connection_timeout` или данные не были получены в течение `receive_data_timeout`. Запрос использует первое соединение, которое отправляет непустой пакет прогресса (или пакет данных, если `allow_changing_replica_until_first_data_packet`); другие соединения отменяются. Поддерживаются запросы с `max_parallel_replicas > 1`.

Включено по умолчанию.

Значение по умолчанию в облаке: `1`
## use_hive_partitioning {#use_hive_partitioning} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Enabled the setting by default."}]}, {"id": "row-2","items": [{"label": "24.8"},{"label": "0"},{"label": "Allows to use hive partitioning for File, URL, S3, AzureBlobStorage and HDFS engines."}]}]}/>

При включении ClickHouse будет обнаруживать разбиение в стиле Hive в пути (`/name=value/`) в табличных движках [File](/sql-reference/table-functions/file#hive-style-partitioning)/[S3](/sql-reference/table-functions/s3#hive-style-partitioning)/[URL](/sql-reference/table-functions/url#hive-style-partitioning)/[HDFS](/sql-reference/table-functions/hdfs#hive-style-partitioning)/[AzureBlobStorage](/sql-reference/table-functions/azureBlobStorage#hive-style-partitioning) и позволит использовать колонки разбиения в качестве виртуальных колонок в запросе. Эти виртуальные колонки будут иметь такие же имена, как и в разбиении, но с начальным знаком `_`.
## use_iceberg_metadata_files_cache {#use_iceberg_metadata_files_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "New setting"}]}]}/>

Если включено, функция табличного iceberg и хранилище iceberg могут использовать кэш файлов метаданных iceberg.

Возможные значения:

- 0 - Отключено
- 1 - Включено
## use_iceberg_partition_pruning {#use_iceberg_partition_pruning} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "1"},{"label": "Enable Iceberg partition pruning by default."}]}, {"id": "row-2","items": [{"label": "25.1"},{"label": "0"},{"label": "New setting for Iceberg partition pruning."}]}]}/>

Использовать обрезку разбиений Iceberg для таблиц Iceberg.
## use_index_for_in_with_subqueries {#use_index_for_in_with_subqueries} 

<SettingsInfoBlock type="Bool" default_value="1" />

Попробовать использовать индекс, если есть подзапрос или табличное выражение с правой стороны оператора IN.
## use_index_for_in_with_subqueries_max_values {#use_index_for_in_with_subqueries_max_values} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный размер набора с правой стороны оператора IN, для использования табличного индекса для фильтрации. Это позволяет избежать ухудшения производительности и более высокого использования памяти из-за подготовки дополнительных структур данных для больших запросов. Ноль означает отсутствие ограничения.
## use_join_disjunctions_push_down {#use_join_disjunctions_push_down} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включите опускание частей условий JOIN, соединенных оператором OR, вниз к соответствующим входным сторонам ("частичное опускание").
Это позволяет движкам хранения фильтровать раньше, что может снизить объем читаемых данных.
Оптимизация сохраняет семантику и применяется только в том случае, если каждое верхнее ветвление OR вносит хотя бы одно детерминированное
предикат для целевой стороны.
## use_json_alias_for_old_object_type {#use_json_alias_for_old_object_type} 

<SettingsInfoBlock type="Bool" default_value="0" />

При включении будет использоваться псевдоним типа `JSON` для создания старого типа [Object('json')](../../sql-reference/data-types/json.md) вместо нового типа [JSON](../../sql-reference/data-types/newjson.md).
## use_legacy_to_time {#use_legacy_to_time} 

<SettingsInfoBlock type="Bool" default_value="1" />

При включении позволяет использовать устаревшую функцию toTime, которая преобразует дату с временем в определенную фиксированную дату, сохраняя время.
В противном случае используется новая функция toTime, которая преобразует разные типы данных в тип Time.
Старая устаревшая функция также безусловно доступна как toTimeWithFixedDate.
## use_page_cache_for_disks_without_file_cache {#use_page_cache_for_disks_without_file_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использовать кэш страниц пользователя для удаленных дисков, на которых не включен файловый кэш.
## use_page_cache_with_distributed_cache {#use_page_cache_with_distributed_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использовать кэш страниц пользователя, когда используется распределенный кэш.
## use_query_cache {#use_query_cache} 

Если включено, запросы `SELECT` могут использовать [кэш запросов](../query-cache.md). Параметры [enable_reads_from_query_cache](#enable_reads_from_query_cache)
и [enable_writes_to_query_cache](#enable_writes_to_query_cache) более подробно контролируют использование кэша.

Возможные значения:

- 0 - Отключено
- 1 - Включено
## use_query_condition_cache {#use_query_condition_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включить [кэш условий запроса](/operations/query-condition-cache). Кэш хранит диапазоны гранул в частях данных, которые не удовлетворяют условию в предложении `WHERE`,
и использует эту информацию в качестве эфемерного индекса для последующих запросов.

Возможные значения:

- 0 - Отключено
- 1 - Включено
## use_roaring_bitmap_iceberg_positional_deletes {#use_roaring_bitmap_iceberg_positional_deletes} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использовать рикошетный битовый массив для позиционных удалений iceberg.
## use_skip_indexes {#use_skip_indexes} 

Использовать индексы пропуска данных во время выполнения запроса.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
## use_skip_indexes_if_final {#use_skip_indexes_if_final} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "1"},{"label": "Change in default value of setting"}]}]}/>

Контролирует, используются ли индексы пропуска при выполнении запроса с модификатором FINAL.

Индексы пропуска могут исключить строки (гранулы), содержащие последние данные, что может привести к некорректным результатам от запроса с модификатором FINAL. Когда эта настройка включена, индексы пропуска применяются даже с модификатором FINAL, потенциально улучшая производительность, но с риском пропуска недавних обновлений. Эта настройка должна быть включена синхронно с настройкой use_skip_indexes_if_final_exact_mode (по умолчанию включена).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
## use_skip_indexes_if_final_exact_mode {#use_skip_indexes_if_final_exact_mode} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.6"},{"label": "1"},{"label": "Change in default value of setting"}]}, {"id": "row-2","items": [{"label": "25.5"},{"label": "0"},{"label": "This setting was introduced to help FINAL query return correct results with skip indexes"}]}]}/>

Контролирует, развертываются ли гранулы, возвращенные индексом пропуска, в более новых частях для возврата правильных результатов при выполнении запроса с модификатором FINAL.

Использование индексов пропуска может исключить строки (гранулы), содержащие последние данные, что может привести к некорректным результатам. Эта настройка может гарантировать, что правильные результаты возвращаются путем сканирования более новых частей, которые пересекаются с диапазонами, возвращенными индексом пропуска. Эта настройка должна быть отключена только в том случае, если приближенные результаты, основанные на обращении к индексу пропуска, приемлемы для приложения.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
## use_skip_indexes_on_data_read {#use_skip_indexes_on_data_read} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.9"},{"label": "0"},{"label": "New setting"}]}, {"id": "row-2","items": [{"label": "25.10"},{"label": "1"},{"label": "Enabled skip index usage in read phase by default"}]}]}/>

Включите использование индексов пропуска данных во время чтения данных.

Когда включено, индексы пропуска оцениваются динамически в момент чтения каждой гранулы данных, а не анализируются заранее перед началом выполнения запроса. Это может снизить задержку старта запроса.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
## use_structure_from_insertion_table_in_table_functions {#use_structure_from_insertion_table_in_table_functions} 

<SettingsInfoBlock type="UInt64" default_value="2" />

Использовать структуру из таблицы вставки вместо вывода схемы на основе данных. Возможные значения: 0 - отключено, 1 - включено, 2 - авто.
## use_uncompressed_cache {#use_uncompressed_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использовать ли кэш не сжатых блоков. Принимает 0 или 1. По умолчанию 0 (отключено).
Использование кэша несжатых данных (только для таблиц семейства MergeTree) может значительно сократить задержку и увеличить пропускную способность при работе с большим количеством коротких запросов. Включите эту настройку для пользователей, которые часто отправляют короткие запросы. Также обратите внимание на параметр конфигурации [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) (устанавливается только в конфигурационном файле) – размер кэша несжатых блоков. По умолчанию 8 ГиБ. Кэш несжатых данных заполняется по мере необходимости, и наименее используемые данные автоматически удаляются.

Для запросов, которые читают хотя бы достаточно большой объем данных (миллион строк или более), кэш несжатых данных автоматически отключается, чтобы освободить место для действительно маленьких запросов. Это означает, что вы можете всегда оставлять настройку 'use_uncompressed_cache' установленной на 1.
## use_variant_as_common_type {#use_variant_as_common_type} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Allow to use Variant in if/multiIf if there is no common type"}]}]}/>

Позволяет использовать тип `Variant` в качестве результирующего типа для функций [if](../../sql-reference/functions/conditional-functions.md/#if)/[multiIf](../../sql-reference/functions/conditional-functions.md/#multiIf)/[array](../../sql-reference/functions/array-functions.md)/[map](../../sql-reference/functions/tuple-map-functions.md), когда для типов аргументов нет общего типа.

Пример:

```sql
SET use_variant_as_common_type = 1;
SELECT toTypeName(if(number % 2, number, range(number))) as variant_type FROM numbers(1);
SELECT if(number % 2, number, range(number)) as variant FROM numbers(5);
```

```text
┌─variant_type───────────────────┐
│ Variant(Array(UInt64), UInt64) │
└────────────────────────────────┘
┌─variant───┐
│ []        │
│ 1         │
│ [0,1]     │
│ 3         │
│ [0,1,2,3] │
└───────────┘
```

```sql
SET use_variant_as_common_type = 1;
SELECT toTypeName(multiIf((number % 4) = 0, 42, (number % 4) = 1, [1, 2, 3], (number % 4) = 2, 'Hello, World!', NULL)) AS variant_type FROM numbers(1);
SELECT multiIf((number % 4) = 0, 42, (number % 4) = 1, [1, 2, 3], (number % 4) = 2, 'Hello, World!', NULL) AS variant FROM numbers(4);
```

```text
─variant_type─────────────────────────┐
│ Variant(Array(UInt8), String, UInt8) │
└──────────────────────────────────────┘

┌─variant───────┐
│ 42            │
│ [1,2,3]       │
│ Hello, World! │
│ ᴺᵁᴸᴸ          │
└───────────────┘
```

```sql
SET use_variant_as_common_type = 1;
SELECT toTypeName(array(range(number), number, 'str_' || toString(number))) as array_of_variants_type from numbers(1);
SELECT array(range(number), number, 'str_' || toString(number)) as array_of_variants FROM numbers(3);
```

```text
┌─array_of_variants_type────────────────────────┐
│ Array(Variant(Array(UInt64), String, UInt64)) │
└───────────────────────────────────────────────┘

┌─array_of_variants─┐
│ [[],0,'str_0']    │
│ [[0],1,'str_1']   │
│ [[0,1],2,'str_2'] │
└───────────────────┘
```

```sql
SET use_variant_as_common_type = 1;
SELECT toTypeName(map('a', range(number), 'b', number, 'c', 'str_' || toString(number))) as map_of_variants_type from numbers(1);
SELECT map('a', range(number), 'b', number, 'c', 'str_' || toString(number)) as map_of_variants FROM numbers(3);
```

```text
┌─map_of_variants_type────────────────────────────────┐
│ Map(String, Variant(Array(UInt64), String, UInt64)) │
└─────────────────────────────────────────────────────┘

┌─map_of_variants───────────────┐
│ {'a':[],'b':0,'c':'str_0'}    │
│ {'a':[0],'b':1,'c':'str_1'}   │
│ {'a':[0,1],'b':2,'c':'str_2'} │
└───────────────────────────────┘
```
## use_with_fill_by_sorting_prefix {#use_with_fill_by_sorting_prefix} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.5"},{"label": "1"},{"label": "Columns preceding WITH FILL columns in ORDER BY clause form sorting prefix. Rows with different values in sorting prefix are filled independently"}]}]}/>

Колонки, предшествующие колонкам WITH FILL в операторе ORDER BY, формируют префикс сортировки. Строки с различными значениями в префиксе сортировки заполняются независимо.
## validate_enum_literals_in_operators {#validate_enum_literals_in_operators} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "A new setting"}]}]}/>

Если включено, проверяются литералы перечислений в операторах, таких как `IN`, `NOT IN`, `==`, `!=`, на соответствие типу перечисления и выбрасывается исключение, если литерал не является допустимым значением перечисления.
## validate_mutation_query {#validate_mutation_query} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "New setting to validate mutation queries by default."}]}]}/>

Проверять запросы на мутации перед их принятием. Мутации выполняются в фоне, и выполнение недопустимого запроса приведет к застреванию мутаций, требуя ручного вмешательства.

Изменяйте эту настройку только в том случае, если вы сталкиваетесь с несовместимой с обратной совместимостью ошибкой.
## validate_polygons {#validate_polygons} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает выброс исключения в функции [pointInPolygon](/sql-reference/functions/geo/coordinates#pointinpolygon), если многоугольник самопересекается или имеет самосоприкосновение.

Возможные значения:

- 0 — Выброс исключения отключен. `pointInPolygon` принимает недопустимые многоугольники и возвращает возможно неправильные результаты для них.
- 1 — Выброс исключения включен.
## vector_search_filter_strategy {#vector_search_filter_strategy} 

<SettingsInfoBlock type="VectorSearchFilterStrategy" default_value="auto" />

Если запрос векторного поиска имеет предложение WHERE, эта настройка определяет, будет ли оно оцениваться первым (предварительная фильтрация) ИЛИ будет ли сначала проверяться индекс векторного сходства (постфильтрация). Возможные значения:
- 'auto' - Постфильтрация (точная семантика может измениться в будущем).
- 'postfilter' - Используйте индекс векторного сходства для идентификации ближайших соседей, затем применяйте другие фильтры.
- 'prefilter' - Сначала оцените другие фильтры, затем выполните поиск в грубом режиме для идентификации соседей.
## vector_search_index_fetch_multiplier {#vector_search_index_fetch_multiplier} 

<SettingsInfoBlock type="Float" default_value="1" />

Умножает количество извлеченных ближайших соседей из индекса векторного сходства на это число. Применяется только для постфильтрации с другими предикатами или если настройка 'vector_search_with_rescoring = 1'.
## vector_search_with_rescoring {#vector_search_with_rescoring} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если ClickHouse выполняет перерасчет для запросов, использующих индекс векторного сходства.
Без перерасчета индекс векторного сходства возвращает строки, содержащие наилучшие совпадения, напрямую.
С перерасчетом строки экстраполируются до уровня гранул и все строки в грануле проверяются снова.
В большинстве ситуаций перерасчет помогает только незначительно с точностью, но значительно ухудшает производительность запросов на векторный поиск.
Примечание: Запрос, выполненный без перерасчета и с включенными параллельными репликами, может вернуться к перерасчету.
## wait_changes_become_visible_after_commit_mode {#wait_changes_become_visible_after_commit_mode} 

<ExperimentalBadge/>

<SettingsInfoBlock type="TransactionsWaitCSNMode" default_value="wait_unknown" />

Ожидать, пока коммитированные изменения станут фактически видимыми в последнем снимке.
## wait_for_async_insert {#wait_for_async_insert} 

Если значение истинно, ждать обработки асинхронной вставки.
## wait_for_async_insert_timeout {#wait_for_async_insert_timeout} 

Тайм-аут ожидания обработки асинхронной вставки.
## wait_for_window_view_fire_signal_timeout {#wait_for_window_view_fire_signal_timeout} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Seconds" default_value="10" />

Тайм-аут ожидания сигнала активации окна представления при обработке в реальном времени.
## window_view_clean_interval {#window_view_clean_interval} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Seconds" default_value="60" />

Интервал очистки окна представления в секундах для освобождения устаревших данных.
## window_view_heartbeat_interval {#window_view_heartbeat_interval} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Seconds" default_value="15" />

Интервал heartbeat в секундах для индикации активности наблюдаемого запроса.
## workload {#workload} 

<SettingsInfoBlock type="String" default_value="default" />

Имя рабочей нагрузки, которое будет использоваться для доступа к ресурсам.
## write_full_path_in_iceberg_metadata {#write_full_path_in_iceberg_metadata} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.8"},{"label": "0"},{"label": "New setting."}]}]}/>

Записывать полные пути (включая s3://) в файлы метаданных iceberg.
## write_through_distributed_cache {#write_through_distributed_cache} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "A setting for ClickHouse Cloud"}]}]}/>

Действует только в ClickHouse Cloud. Позволяет записывать в распределенный кэш (запись в s3 также будет выполняться через распределенный кэш).
## write_through_distributed_cache_buffer_size {#write_through_distributed_cache_buffer_size} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.7"},{"label": "0"},{"label": "New cloud setting"}]}]}/>

Действует только в ClickHouse Cloud. Устанавливает размер буфера для записи через распределенный кэш. Если 0, будет использоваться размер буфера, который использовался бы, если бы не было распределенного кэша.
## zstd_window_log_max {#zstd_window_log_max} 

Позволяет установить максимальный лог окна ZSTD (не будет использоваться для семейства MergeTree).
---
title: 'Настройки Сессии'
sidebar_label: 'Настройки Сессии'
slug: /operations/settings/settings
toc_max_heading_level: 2
description: 'Настройки, которые находятся в таблице ``system.settings``.'
---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import BetaBadge from '@theme/badges/BetaBadge';
import CloudOnlyBadge from '@theme/badges/CloudOnlyBadge';
import SettingsInfoBlock from '@theme/SettingsInfoBlock/SettingsInfoBlock';
import VersionHistory from '@theme/VersionHistory/VersionHistory';

<!-- Autogenerated -->
Все нижеприведенные настройки также доступны в таблице [system.settings](/docs/operations/system-tables/settings). Эти настройки автоматически генерируются из [source](https://github.com/ClickHouse/ClickHouse/blob/master/src/Core/Settings.cpp).
## add_http_cors_header {#add_http_cors_header} 



<SettingsInfoBlock type="Bool" default_value="0" />

Добавить заголовок http CORS.
## additional_result_filter {#additional_result_filter} 

Дополнительное выражение фильтра для применения к результату запроса `SELECT`.
Эта настройка не применяется к подзапросам.

**Пример**

```sql
INSERT INTO table_1 VALUES (1, 'a'), (2, 'bb'), (3, 'ccc'), (4, 'dddd');
SElECT * FROM table_1;
```
```response
┌─x─┬─y────┐
│ 1 │ a    │
│ 2 │ bb   │
│ 3 │ ccc  │
│ 4 │ dddd │
└───┴──────┘
```
```sql
SELECT *
FROM table_1
SETTINGS additional_result_filter = 'x != 2'
```
```response
┌─x─┬─y────┐
│ 1 │ a    │
│ 3 │ ccc  │
│ 4 │ dddd │
└───┴──────┘
```
## additional_table_filters {#additional_table_filters} 



<SettingsInfoBlock type="Map" default_value="{}" />

Дополнительное выражение фильтра, которое применяется после чтения
из указанной таблицы.

**Пример**

```sql
INSERT INTO table_1 VALUES (1, 'a'), (2, 'bb'), (3, 'ccc'), (4, 'dddd');
SELECT * FROM table_1;
```
```response
┌─x─┬─y────┐
│ 1 │ a    │
│ 2 │ bb   │
│ 3 │ ccc  │
│ 4 │ dddd │
└───┴──────┘
```
```sql
SELECT *
FROM table_1
SETTINGS additional_table_filters = {'table_1': 'x != 2'}
```
```response
┌─x─┬─y────┐
│ 1 │ a    │
│ 3 │ ccc  │
│ 4 │ dddd │
└───┴──────┘
```
## aggregate_functions_null_for_empty {#aggregate_functions_null_for_empty} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает переписывание всех агрегатных функций в запросе, добавляя суффикс [-OrNull](/sql-reference/aggregate-functions/combinators#-ornull) к ним. Включите это для совместимости со стандартом SQL.
Это реализовано через переписывание запроса (аналогично настройке [count_distinct_implementation](#count_distinct_implementation)), чтобы получить согласованные результаты для распределенных запросов.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

**Пример**

Рассмотрим следующий запрос с агрегатными функциями:
```sql
SELECT SUM(-1), MAX(0) FROM system.one WHERE 0;
```

С `aggregate_functions_null_for_empty = 0` он даст:
```text
┌─SUM(-1)─┬─MAX(0)─┐
│       0 │      0 │
└─────────┴────────┘
```

С `aggregate_functions_null_for_empty = 1` результат будет:
```text
┌─SUMOrNull(-1)─┬─MAXOrNull(0)─┐
│          NULL │         NULL │
└───────────────┴──────────────┘
```
## aggregation_in_order_max_block_bytes {#aggregation_in_order_max_block_bytes} 



<SettingsInfoBlock type="UInt64" default_value="50000000" />

Максимальный размер блока в байтах, накопленных во время агрегации в порядке первичного ключа. Меньший размер блока позволяет параллелизовать более позднюю стадию финального слияния агрегации.
## aggregation_memory_efficient_merge_threads {#aggregation_memory_efficient_merge_threads} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Количество потоков, используемых для слияния промежуточных результатов агрегации в режиме эффективного использования памяти. Чем больше значение, тем больше потребляется памяти. 0 означает — то же самое, что и 'max_threads'.
## allow_aggregate_partitions_independently {#allow_aggregate_partitions_independently} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включить независимую агрегацию партиций в отдельных потоках, когда ключ партиционирования соответствует ключу группировки. Полезно, когда количество партиций близко к количеству ядер, а партиции имеют примерно одинаковый размер.
## allow_archive_path_syntax {#allow_archive_path_syntax} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "1"},{"label": "Добавлена новая настройка для разрешения отключения синтаксиса архива."}]}, {"id": "row-2","items": [{"label": "24.5"},{"label": "1"},{"label": "Добавлена новая настройка для разрешения отключения синтаксиса архива."}]}]}/>

Файлы/движки S3/табличная функция будут разбирать пути с '::' как `<archive> :: <file>`, если архив имеет правильное расширение.
## allow_asynchronous_read_from_io_pool_for_merge_tree {#allow_asynchronous_read_from_io_pool_for_merge_tree} 



<SettingsInfoBlock type="Bool" default_value="0" />

Использовать пул фонового ввода-вывода для чтения из таблиц MergeTree. Эта настройка может увеличить производительность для запросов, зависящих от ввода-вывода.
## allow_changing_replica_until_first_data_packet {#allow_changing_replica_until_first_data_packet} 



<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, в хеджированных запросах мы можем начать новое соединение до получения первого пакета данных, даже если мы уже сделали некоторые успехи
(но прогресс не был обновлен в течение времени `receive_data_timeout`), в противном случае мы отключаем изменение реплики после того, как впервые достигли прогресса.
## allow_create_index_without_type {#allow_create_index_without_type} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить запрос CREATE INDEX без TYPE. Запрос будет игнорироваться. Сделано для тестов совместимости SQL.
## allow_custom_error_code_in_throwif {#allow_custom_error_code_in_throwif} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включить пользовательский код ошибки в функции throwIf(). Если это истинно, выброшенные исключения могут иметь неожиданные коды ошибок.
## allow_ddl {#allow_ddl} 



<SettingsInfoBlock type="Bool" default_value="1" />

Если установка установлена на истину, пользователю разрешается выполнять DDL запросы.
## allow_deprecated_database_ordinary {#allow_deprecated_database_ordinary} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить создание баз данных с устаревшим обычным движком.
## allow_deprecated_error_prone_window_functions {#allow_deprecated_error_prone_window_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "0"},{"label": "Разрешить использование устаревших оконных функций, подверженных ошибкам (neighbor, runningAccumulate, runningDifferenceStartingWithFirstValue, runningDifference)"}]}]}/>

Разрешить использование устаревших оконных функций, подверженных ошибкам (neighbor, runningAccumulate, runningDifferenceStartingWithFirstValue, runningDifference).
## allow_deprecated_snowflake_conversion_functions {#allow_deprecated_snowflake_conversion_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Отключены устаревшие функции snowflakeToDateTime[64] и dateTime[64]ToSnowflake."}]}]}/>

Функции `snowflakeToDateTime`, `snowflakeToDateTime64`, `dateTimeToSnowflake` и `dateTime64ToSnowflake` устарели и по умолчанию отключены.
Пожалуйста, используйте функции `snowflakeIDToDateTime`, `snowflakeIDToDateTime64`, `dateTimeToSnowflakeID` и `dateTime64ToSnowflakeID` вместо них.

Чтобы повторно включить устаревшие функции (например, в переходный период), установите эту настройку в `true`.
## allow_deprecated_syntax_for_merge_tree {#allow_deprecated_syntax_for_merge_tree} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить создание *MergeTree таблиц с устаревшим синтаксисом определения движка.
## allow_distributed_ddl {#allow_distributed_ddl} 



<SettingsInfoBlock type="Bool" default_value="1" />

Если установка установлена на истину, пользователю разрешается выполнять распределенные DDL запросы.
## allow_drop_detached {#allow_drop_detached} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить запросы ALTER TABLE ... DROP DETACHED PART[ITION] ...
## allow_execute_multiif_columnar {#allow_execute_multiif_columnar} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить выполнение функции multiIf в столбцовом формате.
## allow_experimental_analyzer {#allow_experimental_analyzer} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Включить анализатор и планировщик по умолчанию."}]}]}/>

Разрешить новый анализатор запросов.
## allow_experimental_codecs {#allow_experimental_codecs} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Если установка установлена на истину, разрешите указывать экспериментальные кодеки сжатия (но у нас их еще нет, и эта опция ничего не делает).
## allow_experimental_correlated_subqueries {#allow_experimental_correlated_subqueries} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Добавлена новая настройка для разрешения выполнения коррелированных подзапросов."}]}]}/>

Разрешить выполнение коррелированных подзапросов.
## allow_experimental_database_glue_catalog {#allow_experimental_database_glue_catalog} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "0"},{"label": "Разрешить экспериментальный движок базы данных DataLakeCatalog с catalog_type = 'glue'"}]}]}/>

Разрешить экспериментальный движок базы данных DataLakeCatalog с catalog_type = 'glue'.
## allow_experimental_database_hms_catalog {#allow_experimental_database_hms_catalog} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Разрешить экспериментальный движок базы данных DataLakeCatalog с catalog_type = 'hive'"}]}]}/>

Разрешить экспериментальный движок базы данных DataLakeCatalog с catalog_type = 'hms'.
## allow_experimental_database_iceberg {#allow_experimental_database_iceberg} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Разрешить экспериментальный движок базы данных DataLakeCatalog с catalog_type = 'iceberg'.
## allow_experimental_database_materialized_postgresql {#allow_experimental_database_materialized_postgresql} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить создание базы данных с Engine=MaterializedPostgreSQL(...).
## allow_experimental_database_unity_catalog {#allow_experimental_database_unity_catalog} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "0"},{"label": "Разрешить экспериментальный движок базы данных DataLakeCatalog с catalog_type = 'unity'"}]}]}/>

Разрешить экспериментальный движок базы данных DataLakeCatalog с catalog_type = 'unity'.
## allow_experimental_delta_kernel_rs {#allow_experimental_delta_kernel_rs} 

<BetaBadge/>



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Разрешить экспериментальную реализацию delta-kernel-rs.
## allow_experimental_dynamic_type {#allow_experimental_dynamic_type} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "1"},{"label": "Динамический тип данных готов к производству"}]}, {"id": "row-2","items": [{"label": "24.5"},{"label": "0"},{"label": "Добавить новый экспериментальный динамический тип"}]}]}/>

Разрешает создание [Dynamic](../../sql-reference/data-types/dynamic.md) типа данных.
## allow_experimental_full_text_index {#allow_experimental_full_text_index} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Включить экспериментальный полнотекстовый индекс"}]}]}/>

Если это установлено на истину, разрешить использовать экспериментальный полнотекстовый индекс.
## allow_experimental_funnel_functions {#allow_experimental_funnel_functions} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Включить экспериментальные функции для анализа воронок.
## allow_experimental_hash_functions {#allow_experimental_hash_functions} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Включить экспериментальные хеш-функции.
## allow_experimental_inverted_index {#allow_experimental_inverted_index} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Если это установлено на истину, разрешить использовать экспериментальный разреженный индекс.
## allow_experimental_join_condition {#allow_experimental_join_condition} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "0"},{"label": "Поддержка соединения с неравенствующими условиями, которые включают столбцы из обеих таблиц слева и справа. например, `t1.y < t2.y`."}]}]}/>

Поддержка соединения с неравенствующими условиями, которые включают столбцы из обеих таблиц слева и справа. например, `t1.y < t2.y`.
## allow_experimental_join_right_table_sorting {#allow_experimental_join_right_table_sorting} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Если это установлено на истину, и условия `join_to_sort_minimum_perkey_rows` и `join_to_sort_maximum_table_rows` выполнены, изменить порядок правой таблицы по ключу для улучшения производительности в левых или внутренних хэш-соединениях."}]}]}/>

Если это установлено на истину, и условия `join_to_sort_minimum_perkey_rows` и `join_to_sort_maximum_table_rows` выполнены, изменить порядок правой таблицы по ключу для улучшения производительности в левых или внутренних хэш-соединениях.
## allow_experimental_json_type {#allow_experimental_json_type} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "1"},{"label": "Тип данных JSON готов к производству"}]}, {"id": "row-2","items": [{"label": "24.8"},{"label": "0"},{"label": "Добавить новый экспериментальный тип JSON"}]}]}/>

Разрешает создание [JSON](../../sql-reference/data-types/newjson.md) типа данных.
## allow_experimental_kafka_offsets_storage_in_keeper {#allow_experimental_kafka_offsets_storage_in_keeper} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "Разрешить использование экспериментального движка Kafka, который хранит зафиксированные смещения в ClickHouse Keeper."}]}]}/>

Разрешить экспериментальную функцию хранения смещений, связанных с Kafka, в ClickHouse Keeper. При включении можно указать путь ClickHouse Keeper и имя реплики для движка таблицы Kafka. В результате вместо обычного движка Kafka будет использоваться новый тип движка хранения, который в первую очередь хранит зафиксированные смещения в ClickHouse Keeper.
## allow_experimental_kusto_dialect {#allow_experimental_kusto_dialect} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Включить язык запросов Kusto (KQL) - альтернативу SQL.
## allow_experimental_lightweight_update {#allow_experimental_lightweight_update} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Разрешить использовать легковесные обновления.
## allow_experimental_live_view {#allow_experimental_live_view} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает создание устаревшего LIVE VIEW.

Возможные значения:

- 0 — Работы с live-представлениями отключены.
- 1 — Работы с live-представлениями включены.
## allow_experimental_materialized_postgresql_table {#allow_experimental_materialized_postgresql_table} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает использовать движок таблицы MaterializedPostgreSQL. Отключено по умолчанию, так как эта функция является экспериментальной.
## allow_experimental_nlp_functions {#allow_experimental_nlp_functions} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Включить экспериментальные функции для обработки естественного языка.
## allow_experimental_object_type {#allow_experimental_object_type} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить устаревший тип данных Object.
## allow_experimental_parallel_reading_from_replicas {#allow_experimental_parallel_reading_from_replicas} 

<BetaBadge/>



<SettingsInfoBlock type="UInt64" default_value="0" />

Использовать до `max_parallel_replicas` количество реплик из каждой шард для выполнения запроса SELECT. Чтение будет параллелизировано и координировано динамически. 0 - отключено, 1 - включено, безмолвно отключите в случае ошибки, 2 - включено, выбросить исключение в случае ошибки.
## allow_experimental_prql_dialect {#allow_experimental_prql_dialect} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Включить PRQL - альтернативу SQL.
## allow_experimental_query_deduplication {#allow_experimental_query_deduplication} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Экспериментальная дедупликация данных для запросов SELECT на основе UUID частей.
## allow_experimental_statistics {#allow_experimental_statistics} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Настройка была переименована. Предыдущее название - `allow_experimental_statistic`."}]}]}/>

Позволяет определять столбцы с [статистикой](../../engines/table-engines/mergetree-family/mergetree.md/#table_engine-mergetree-creating-a-table) и [управлять статистикой](../../engines/table-engines/mergetree-family/mergetree.md/#column-statistics).
## allow_experimental_time_series_table {#allow_experimental_time_series_table} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "Добавлена новая настройка для разрешения движка таблицы TimeSeries"}]}]}/>

Разрешает создание таблиц с движком таблицы [TimeSeries](../../engines/table-engines/integrations/time-series.md). Возможные значения:
- 0 — движок таблицы [TimeSeries](../../engines/table-engines/integrations/time-series.md) отключен.
- 1 — движок таблицы [TimeSeries](../../engines/table-engines/integrations/time-series.md) включен.
## allow_experimental_ts_to_grid_aggregate_function {#allow_experimental_ts_to_grid_aggregate_function} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Только для облака"}]}]}/>

Экспериментальная агрегатная функция tsToGrid для повторной выборки временных рядов, подобно Prometheus. Только для облака.
## allow_experimental_variant_type {#allow_experimental_variant_type} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "1"},{"label": "Тип данных Variant готов к производству"}]}, {"id": "row-2","items": [{"label": "24.1"},{"label": "0"},{"label": "Добавить новый экспериментальный тип Variant"}]}]}/>

Разрешает создание [Variant](../../sql-reference/data-types/variant.md) типа данных.
## allow_experimental_vector_similarity_index {#allow_experimental_vector_similarity_index} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "Добавлена новая настройка для разрешения экспериментальных индексов векторного сходства"}]}]}/>

Разрешить экспериментальный индекс векторного сходства.
## allow_experimental_window_view {#allow_experimental_window_view} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />

Включить VIEW ОКНА. Недостаточно зрелый.
## allow_general_join_planning {#allow_general_join_planning} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Разрешить более общий алгоритм планирования соединений, когда включен алгоритм хэш-соединения."}]}]}/>

Позволяет более общий алгоритм планирования соединений, который может обрабатывать более сложные условия, но работает только с хэш-соединениями. Если хэш-соединение не включено, используется обычный алгоритм планирования соединений, независимо от значения этой настройки.
## allow_get_client_http_header {#allow_get_client_http_header} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Введена новая функция."}]}]}/>

Разрешить использовать функцию `getClientHTTPHeader`, которая позволяет получить значение заголовка текущего HTTP-запроса. Он по умолчанию не включен по соображениям безопасности, так как некоторые заголовки, такие как `Cookie`, могут содержать конфиденциальную информацию. Обратите внимание, что заголовки `X-ClickHouse-*` и `Authentication` всегда ограничены и не могут быть получены с помощью этой функции.
## allow_hyperscan {#allow_hyperscan} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить функции, использующие библиотеку Hyperscan. Отключите, чтобы избежать потенциально длительного времени компиляции и чрезмерного использования ресурсов.
## allow_introspection_functions {#allow_introspection_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает [функции интроспекции](../../sql-reference/functions/introspection.md) для профилирования запросов.

Возможные значения:

- 1 — функции интроспекции включены.
- 0 — функции интроспекции отключены.

**См. также**

- [Профилировщик запросов с выборкой](../../operations/optimizing-performance/sampling-query-profiler.md)
- Системная таблица [trace_log](/operations/system-tables/trace_log)
## allow_materialized_view_with_bad_select {#allow_materialized_view_with_bad_select} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Не разрешать создание MVs, ссылающихся на несуществующие столбцы или таблицы"}]}, {"id": "row-2","items": [{"label": "24.9"},{"label": "1"},{"label": "Поддержка (но еще не включена) более строгой проверки в CREATE MATERIALIZED VIEW"}]}]}/>

Разрешить CREATE MATERIALIZED VIEW с запросом SELECT, который ссылается на несуществующие таблицы или столбцы. Он все равно должен быть синтаксически корректным. Не применяется к обновляемым MV. Не применяется, если схему MV необходимо выдвинуть из запроса SELECT (т.е. если CREATE не содержит списка столбцов и не содержит TO таблицы). Может использоваться для создания MV до ее исходной таблицы.
## allow_named_collection_override_by_default {#allow_named_collection_override_by_default} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить переопределение полей именованных коллекций по умолчанию.
## allow_non_metadata_alters {#allow_non_metadata_alters} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить выполнять изменения, которые влияют не только на метаданные таблиц, но и на данные на диске.
## allow_nonconst_timezone_arguments {#allow_nonconst_timezone_arguments} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "0"},{"label": "Разрешить неконстантные аргументы временной зоны в определенных временных функциях, таких как toTimeZone(), fromUnixTimestamp*(), snowflakeToDateTime*()."}]}]}/>

Разрешить неконстантные аргументы временной зоны в определенных временных функциях, таких как toTimeZone(), fromUnixTimestamp*(), snowflakeToDateTime*().
## allow_nondeterministic_mutations {#allow_nondeterministic_mutations} 



<SettingsInfoBlock type="Bool" default_value="0" />

Настройка на уровне пользователя, которая позволяет мутациям в реплицируемых таблицах использовать нерешающие функции, такие как `dictGet`.

Поскольку, например, словари могут быть не синхронизированы между узлами, мутации, которые получают значения из них, по умолчанию не разрешены в реплицируемых таблицах. Включение этой настройки позволяет это поведение, делая ответственность пользователя обеспечением того, чтобы данные, используемые, были синхронизированы на всех узлах.

**Пример**

```xml
<profiles>
    <default>
        <allow_nondeterministic_mutations>1</allow_nondeterministic_mutations>

        <!-- ... -->
    </default>

    <!-- ... -->

</profiles>
```
## allow_nondeterministic_optimize_skip_unused_shards {#allow_nondeterministic_optimize_skip_unused_shards} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить нерешающие (такие как `rand` или `dictGet`, поскольку позже у последней есть некоторые подвохи с обновлениями) функции в ключе шардирования.

Возможные значения:

- 0 — Запрещено.
- 1 — Разрешено.
## allow_not_comparable_types_in_comparison_functions {#allow_not_comparable_types_in_comparison_functions} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Не разрешать несравнимые типы в функциях сравнения по умолчанию"}]}]}/>

Разрешает или ограничивает использование несравнимых типов (таких как JSON/Object/AggregateFunction) в функциях сравнения `equal/less/greater/etc`.
## allow_not_comparable_types_in_order_by {#allow_not_comparable_types_in_order_by} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Не разрешать несравнимые типы в ORDER BY по умолчанию"}]}]}/>

Разрешает или ограничивает использование несравнимых типов (таких как JSON/Object/AggregateFunction) в ключах ORDER BY.
## allow_prefetched_read_pool_for_local_filesystem {#allow_prefetched_read_pool_for_local_filesystem} 



<SettingsInfoBlock type="Bool" default_value="0" />

Предпочитать предварительно загруженный пул потоков, если все части находятся на локальной файловой системе.
## allow_prefetched_read_pool_for_remote_filesystem {#allow_prefetched_read_pool_for_remote_filesystem} 



<SettingsInfoBlock type="Bool" default_value="1" />

Предпочитать предварительно загруженный пул потоков, если все части находятся на удаленной файловой системе.
## allow_push_predicate_ast_for_distributed_subqueries {#allow_push_predicate_ast_for_distributed_subqueries} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Разрешить применение предиката на уровне AST для распределенных подзапросов с включенным анализатором.
## allow_push_predicate_when_subquery_contains_with {#allow_push_predicate_when_subquery_contains_with} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить применение предиката, когда подзапрос содержит оператор WITH.
## allow_reorder_prewhere_conditions {#allow_reorder_prewhere_conditions} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

При перемещении условий из WHERE в PREWHERE разрешить их переупорядочение для оптимизации фильтрации.
## allow_settings_after_format_in_insert {#allow_settings_after_format_in_insert} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.4"},{"label": "0"},{"label": "Не разрешать SETTINGS после FORMAT для INSERT запросов, поскольку ClickHouse интерпретирует SETTINGS как некоторые значения, что является вводящим в заблуждение"}]}]}/>

Контролировать, разрешены ли `SETTINGS` после `FORMAT` в `INSERT` запросах или нет. Не рекомендуется использовать это, так как это может интерпретировать часть `SETTINGS` как значения.

Пример:

```sql
INSERT INTO FUNCTION null('foo String') SETTINGS max_threads=1 VALUES ('bar');
```

Но следующий запрос будет работать только с `allow_settings_after_format_in_insert`:

```sql
SET allow_settings_after_format_in_insert=1;
INSERT INTO FUNCTION null('foo String') VALUES ('bar') SETTINGS max_threads=1;
```

Возможные значения:

- 0 — Запрещено.
- 1 — Разрешено.

:::note
Используйте эту настройку только для обеспечения обратной совместимости, если ваши случаи использования зависят от старого синтаксиса.
:::
## allow_simdjson {#allow_simdjson} 



<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить использование библиотеки simdjson в функциях 'JSON*', если доступны инструкции AVX2. Если отключено, будет использован rapidjson.
## allow_statistics_optimize {#allow_statistics_optimize} 

<ExperimentalBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Настройка была переименована. Предыдущее название - `allow_statistic_optimize`."}]}]}/>

Позволяет использовать статистику для оптимизации запросов.
## allow_suspicious_codecs {#allow_suspicious_codecs} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "20.5"},{"label": "0"},{"label": "Не разрешать указывать незначимые кодеки сжатия"}]}]}/>

Если это установлено на истину, разрешить указывать незначимые кодеки сжатия.
## allow_suspicious_fixed_string_types {#allow_suspicious_fixed_string_types} 



<SettingsInfoBlock type="Bool" default_value="0" />

В операторе CREATE TABLE позволяет создавать столбцы типа FixedString(n) с n > 256. FixedString с длиной >= 256 является подозрительным и, скорее всего, указывает на неправильное использование.
## allow_suspicious_indices {#allow_suspicious_indices} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "0"},{"label": "Если установлено в True, индексы могут быть определены с идентичными выражениями"}]}]}/>

Отклонять первичные/вторичные индексы и ключи сортировки с идентичными выражениями.
## allow_suspicious_low_cardinality_types {#allow_suspicious_low_cardinality_types} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет или ограничивает использование [LowCardinality](../../sql-reference/data-types/lowcardinality.md) с типами данных фиксированного размера 8 байт или меньше: числовыми типами данных и `FixedString(8_bytes_or_less)`.

Для небольших фиксированных значений использование `LowCardinality` обычно неэффективно, поскольку ClickHouse хранит числовой индекс для каждой строки. В результате:

- Использование дискового пространства может возрасти.
- Потребление ОЗУ может быть выше, в зависимости от размера словаря.
- Некоторые функции могут работать медленнее из-за дополнительных операций кодирования/декодирования.

Время слияния в таблицах с движком [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) может увеличиваться по всем указанным выше причинам.

Возможные значения:

- 1 — Использование `LowCardinality` не ограничено.
- 0 — Использование `LowCardinality` ограничено.

## allow_suspicious_primary_key {#allow_suspicious_primary_key} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Заблокировать подозрительные PRIMARY KEY/ORDER BY для MergeTree (т.е. SimpleAggregateFunction)"}]}]}/>

Разрешить подозрительные `PRIMARY KEY`/`ORDER BY` для MergeTree (т.е. SimpleAggregateFunction).

## allow_suspicious_ttl_expressions {#allow_suspicious_ttl_expressions} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.12"},{"label": "0"},{"label": "Это новая настройка, и в предыдущих версиях поведение соответствовало разрешению."}]}]}/>

Отклонить TTL-выражения, которые не зависят от каких-либо столбцов таблицы. Это чаще всего указывает на ошибку пользователя.

## allow_suspicious_types_in_group_by {#allow_suspicious_types_in_group_by} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Не разрешать типы Variant/Dynamic в GROUP BY по умолчанию"}]}]}/>

Позволяет или ограничивает использование [Variant](../../sql-reference/data-types/variant.md) и [Dynamic](../../sql-reference/data-types/dynamic.md) типов в ключах GROUP BY.

## allow_suspicious_types_in_order_by {#allow_suspicious_types_in_order_by} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Не разрешать типы Variant/Dynamic в ORDER BY по умолчанию"}]}]}/>

Позволяет или ограничивает использование [Variant](../../sql-reference/data-types/variant.md) и [Dynamic](../../sql-reference/data-types/dynamic.md) типов в ключах ORDER BY.

## allow_suspicious_variant_types {#allow_suspicious_variant_types} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "0"},{"label": "Не разрешать создание типа Variant с подозрительными вариантами по умолчанию"}]}]}/>

В операциях CREATE TABLE разрешает указывать тип Variant с аналогичными вариантами типов (например, с различными числовыми или датами). Включение этой настройки может привести к некоторой неоднозначности при работе с значениями схожих типов.

## allow_unrestricted_reads_from_keeper {#allow_unrestricted_reads_from_keeper} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет неограниченные (без условия на путь) чтения из системной таблицы zookeeper, что может быть удобно, но не безопасно для zookeeper.

## alter_move_to_space_execute_async {#alter_move_to_space_execute_async} 

<SettingsInfoBlock type="Bool" default_value="0" />

Выполнять ALTER TABLE MOVE ... TO [DISK|VOLUME] асинхронно.

## alter_partition_verbose_result {#alter_partition_verbose_result} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает отображение информации о частях, к которым успешно применены операции манипуляции с партициями и частями.
Применимо к [ATTACH PARTITION|PART](/sql-reference/statements/alter/partition#attach-partitionpart) и к [FREEZE PARTITION](/sql-reference/statements/alter/partition#freeze-partition).

Возможные значения:

- 0 — отключить подробный вывод.
- 1 — включить подробный вывод.

**Пример**

```sql
CREATE TABLE test(a Int64, d Date, s String) ENGINE = MergeTree PARTITION BY toYYYYMDECLARE(d) ORDER BY a;
INSERT INTO test VALUES(1, '2021-01-01', '');
INSERT INTO test VALUES(1, '2021-01-01', '');
ALTER TABLE test DETACH PARTITION ID '202101';

ALTER TABLE test ATTACH PARTITION ID '202101' SETTINGS alter_partition_verbose_result = 1;

┌─command_type─────┬─partition_id─┬─part_name────┬─old_part_name─┐
│ ATTACH PARTITION │ 202101       │ 202101_7_7_0 │ 202101_5_5_0  │
│ ATTACH PARTITION │ 202101       │ 202101_8_8_0 │ 202101_6_6_0  │
└──────────────────┴──────────────┴──────────────┴───────────────┘

ALTER TABLE test FREEZE SETTINGS alter_partition_verbose_result = 1;

┌─command_type─┬─partition_id─┬─part_name────┬─backup_name─┬─backup_path───────────────────┬─part_backup_path────────────────────────────────────────────┐
│ FREEZE ALL   │ 202101       │ 202101_7_7_0 │ 8           │ /var/lib/clickhouse/shadow/8/ │ /var/lib/clickhouse/shadow/8/data/default/test/202101_7_7_0 │
│ FREEZE ALL   │ 202101       │ 202101_8_8_0 │ 8           │ /var/lib/clickhouse/shadow/8/ │ /var/lib/clickhouse/shadow/8/data/default/test/202101_8_8_0 │
└──────────────┴──────────────┴──────────────┴─────────────┴───────────────────────────────┴─────────────────────────────────────────────────────────────┘
```

## alter_sync {#alter_sync} 

<SettingsInfoBlock type="UInt64" default_value="1" />

Позволяет настраивать ожидание выполнения действий на репликах с помощью [ALTER](../../sql-reference/statements/alter/index.md), [OPTIMIZE](../../sql-reference/statements/optimize.md) или [TRUNCATE](../../sql-reference/statements/truncate.md) запросов.

Возможные значения:

- 0 — Не ждать.
- 1 — Ждать своего выполнения.
- 2 — Ждать всех.

Облачное значение по умолчанию: `0`.

:::note
`alter_sync` применим только к `Replicated` таблицам, он ничего не делает для изменений не `Replicated` таблиц.
:::

## alter_update_mode {#alter_update_mode} 

<SettingsInfoBlock type="AlterUpdateMode" default_value="heavy" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "heavy"},{"label": "Новая настройка"}]}]}/>

Режим для `ALTER` запросов, которые имеют команды `UPDATE`.

Возможные значения:
- `heavy` - запуск регулярной мутации.
- `lightweight` - запуск легковесного обновления, если это возможно, иначе запуск регулярной мутации.
- `lightweight_force` - запуск легковесного обновления, если это возможно, в противном случае выбросить ошибку.

## analyze_index_with_space_filling_curves {#analyze_index_with_space_filling_curves} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если таблица имеет кривую заполнения пространства в своем индексе, например, `ORDER BY mortonEncode(x, y)` или `ORDER BY hilbertEncode(x, y)`, и запрос имеет условия по его аргументам, например, `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30`, использовать кривую заполнения пространства для анализа индекса.

## analyzer_compatibility_join_using_top_level_identifier {#analyzer_compatibility_join_using_top_level_identifier} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Принудительно разрешать идентификатор в JOIN USING из проекции"}]}]}/>

Принудительно разрешать идентификатор в JOIN USING из проекции (например, в `SELECT a + 1 AS b FROM t1 JOIN t2 USING (b)` соединение будет выполнено по `t1.a + 1 = t2.b`, а не `t1.b = t2.b`).

## any_join_distinct_right_table_keys {#any_join_distinct_right_table_keys} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "19.14"},{"label": "0"},{"label": "Отключить ANY RIGHT и ANY FULL JOIN по умолчанию для избежания несоответствия"}]}]}/>

Включает поведение устаревшего сервера ClickHouse в операциях `ANY INNER|LEFT JOIN`.

:::note
Используйте эту настройку только для обратной совместимости, если ваши сценарии зависят от устаревшего поведения `JOIN`.
:::

Когда устаревшее поведение включено:

- Результаты операций `t1 ANY LEFT JOIN t2` и `t2 ANY RIGHT JOIN t1` не равны, поскольку ClickHouse использует логику с отображением ключей таблиц от многих к одному слева направо. 
- Результаты операций `ANY INNER JOIN` содержат все строки из левой таблицы, как и операции `SEMI LEFT JOIN`.

Когда устаревшее поведение отключено:

- Результаты операций `t1 ANY LEFT JOIN t2` и `t2 ANY RIGHT JOIN t1` равны, поскольку ClickHouse использует логику, которая обеспечивает отображение ключей от одного к многим в операциях `ANY RIGHT JOIN`.
- Результаты операций `ANY INNER JOIN` содержат одну строку на ключ из обеих левых и правых таблиц.

Возможные значения:

- 0 — Устаревшее поведение отключено.
- 1 — Устаревшее поведение включено.

См. также:

- [Строгость JOIN](/sql-reference/statements/select/join#settings).

## apply_deleted_mask {#apply_deleted_mask} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает фильтрацию строк, удаленных с помощью легковесного DELETE. Если отключено, запрос сможет читать эти строки. Это полезно для отладки и сценариев «восстановления».

## apply_mutations_on_fly {#apply_mutations_on_fly} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если истинно, мутации (UPDATE и DELETE), которые не материализованы в части данных, будут применяться к SELECT.

## apply_patch_parts {#apply_patch_parts} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Если истинно, части патчей (представляющие легковесные обновления) применяются к SELECT.

## apply_settings_from_server {#apply_settings_from_server} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Клиентский код (например, парсинг входных данных INSERT и форматирование результатов запроса) будет использовать те же настройки, что и сервер, включая настройки из конфигурации сервера."}]}]}/>

Должен ли клиент принимать настройки с сервера.

Это влияет только на операции, выполняемые на стороне клиента, в частности, на парсинг входных данных INSERT и форматирование результата запроса. Большинство выполнения запросов происходит на сервере и не подвержено влиянию этой настройки.

Обычно эту настройку следует устанавливать в профиле пользователя (users.xml или запросы типа `ALTER USER`), а не через клиент (аргументы командной строки клиента, запрос `SET` или раздел `SETTINGS` запроса `SELECT`). Через клиент она может быть изменена на false, но не может быть изменена на true (поскольку сервер не отправит настройки, если в профиле пользователя установлено `apply_settings_from_server = false`).

Обратите внимание, что изначально (24.12) существовала серверная настройка (`send_settings_to_client`), но позднее она была заменена этой настройкой клиента для лучшей удобства.

## asterisk_include_alias_columns {#asterisk_include_alias_columns} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включить [ALIAS](../../sql-reference/statements/create/table.md/#alias) колонки для запроса с подстановочным знаком (`SELECT *`).

Возможные значения:

- 0 - отключено
- 1 - включено

## asterisk_include_materialized_columns {#asterisk_include_materialized_columns} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включить [MATERIALIZED](/sql-reference/statements/create/view#materialized-view) колонки для запроса с подстановочным знаком (`SELECT *`).

Возможные значения:

- 0 - отключено
- 1 - включено

## async_insert {#async_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если истинно, данные из запроса INSERT хранятся в очереди, а затем сбрасываются в таблицу в фоновом режиме. Если wait_for_async_insert ложна, запрос INSERT обрабатывается почти мгновенно, в противном случае клиент будет ждать, пока данные не будут сброшены в таблицу.

## async_insert_busy_timeout_decrease_rate {#async_insert_busy_timeout_decrease_rate} 

<SettingsInfoBlock type="Double" default_value="0.2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "0.2"},{"label": "Экспоненциальная скорость уменьшения, с которой уменьшает время ожидания асинхронных вставок"}]}]}/>

Экспоненциальная скорость уменьшения, с которой уменьшается время ожидания асинхронных вставок.

## async_insert_busy_timeout_increase_rate {#async_insert_busy_timeout_increase_rate} 

<SettingsInfoBlock type="Double" default_value="0.2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "0.2"},{"label": "Экспоненциальная скорость увеличения, с которой увеличивается время ожидания асинхронных вставок"}]}]}/>

Экспоненциальная скорость увеличения, с которой увеличивается время ожидания асинхронных вставок.

## async_insert_busy_timeout_max_ms {#async_insert_busy_timeout_max_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="200" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "200"},{"label": "Минимальное значение времени ожидания асинхронной вставки в миллисекундах; async_insert_busy_timeout_ms является псевдонимом для async_insert_busy_timeout_max_ms"}]}]}/>

Максимальное время ожидания перед выгрузкой собранных данных за запрос с момента появления первых данных.

## async_insert_busy_timeout_min_ms {#async_insert_busy_timeout_min_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="50" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "50"},{"label": "Минимальное значение времени ожидания асинхронной вставки в миллисекундах; оно также служит в качестве начального значения, которое может быть увеличено позже адаптивным алгоритмом"}]}]}/>

Если автонастройка включена через async_insert_use_adaptive_busy_timeout, минимальное время ожидания перед выгрузкой собранных данных за запрос с момента появления первых данных. Оно также служит в качестве начального значения для адаптивного алгоритма.

## async_insert_deduplicate {#async_insert_deduplicate} 

<SettingsInfoBlock type="Bool" default_value="0" />

Для асинхронных запросов INSERT в реплицируемую таблицу указывает, что должна быть выполнена дедупликация вставляемых блоков.

## async_insert_max_data_size {#async_insert_max_data_size} 

<SettingsInfoBlock type="UInt64" default_value="10485760" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "10485760"},{"label": "Предыдущее значение оказалось слишком маленьким."}]}]}/>

Максимальный размер в байтах непарсенных данных, собранных за запрос перед вставкой.

## async_insert_max_query_number {#async_insert_max_query_number} 

<SettingsInfoBlock type="UInt64" default_value="450" />

Максимальное количество запросов вставки перед вставкой.

## async_insert_poll_timeout_ms {#async_insert_poll_timeout_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="10" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "10"},{"label": "Таймаут в миллисекундах для опроса данных из очереди асинхронной вставки"}]}]}/>

Таймаут для опроса данных из очереди асинхронной вставки.

## async_insert_use_adaptive_busy_timeout {#async_insert_use_adaptive_busy_timeout} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Использовать адаптивный тайм-аут для асинхронных вставок"}]}]}/>

Если установлено в true, использовать адаптивный тайм-аут для асинхронных вставок.

## async_query_sending_for_remote {#async_query_sending_for_remote} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.3"},{"label": "1"},{"label": "Создавать соединения и отправлять запрос асинхронно через шард"}]}]}/>

Включает создание асинхронных соединений и отправку запросов при выполнении удаленного запроса.

Включено по умолчанию.

## async_socket_for_remote {#async_socket_for_remote} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.5"},{"label": "1"},{"label": "Исправить все проблемы и снова включить асинхронные чтения из сокета для удаленных запросов по умолчанию"}]}, {"id": "row-2","items": [{"label": "21.3"},{"label": "0"},{"label": "Выключить асинхронные чтения из сокета для удаленных запросов из-за некоторых проблем"}]}]}/>

Включает асинхронное чтение из сокета при выполнении удаленного запроса.

Включено по умолчанию.

## azure_allow_parallel_part_upload {#azure_allow_parallel_part_upload} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "true"},{"label": "Использовать несколько потоков для многослойной загрузки в Azure."}]}]}/>

Использовать несколько потоков для многослойной загрузки в Azure.

## azure_check_objects_after_upload {#azure_check_objects_after_upload} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Проверять каждый загруженный объект в Azure Blob Storage, чтобы убедиться, что загрузка была успешной"}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "0"},{"label": "Проверять каждый загруженный объект в Azure Blob Storage, чтобы убедиться, что загрузка была успешной"}]}]}/>

Проверять каждый загруженный объект в Azure Blob Storage, чтобы убедиться, что загрузка была успешной.

## azure_create_new_file_on_insert {#azure_create_new_file_on_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает создание нового файла при каждом вставлении в таблицы движка Azure.

## azure_ignore_file_doesnt_exist {#azure_ignore_file_doesnt_exist} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Разрешить возвращать 0 строк, когда запрашиваемые файлы не существуют, вместо генерации исключения в движке AzureBlobStorage"}]}]}/>

Игнорировать отсутствие файла, если он не существует при чтении определенных ключей.

Возможные значения:
- 1 — `SELECT` возвращает пустой результат.
- 0 — `SELECT` выбрасывает исключение.

## azure_list_object_keys_size {#azure_list_object_keys_size} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Максимальное количество файлов, которые могут быть возвращены в пакете по запросу ListObject.

## azure_max_blocks_in_multipart_upload {#azure_max_blocks_in_multipart_upload} 

<SettingsInfoBlock type="UInt64" default_value="50000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "50000"},{"label": "Максимальное количество блоков в многослойной загрузке для Azure."}]}]}/>

Максимальное количество блоков в многослойной загрузке для Azure.

## azure_max_inflight_parts_for_one_file {#azure_max_inflight_parts_for_one_file} 

<SettingsInfoBlock type="UInt64" default_value="20" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "20"},{"label": "Максимальное количество одновременно загруженных частей в запросе многослойной загрузки. 0 означает неограниченно."}]}]}/>

Максимальное количество одновременно загруженных частей в запросе многослойной загрузки. 0 означает неограниченно.

## azure_max_single_part_copy_size {#azure_max_single_part_copy_size} 

<SettingsInfoBlock type="UInt64" default_value="268435456" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "268435456"},{"label": "Максимальный размер объекта для копирования с использованием одномоментного копирования в Azure Blob Storage."}]}]}/>

Максимальный размер объекта для копирования с использованием одномоментного копирования в Azure Blob Storage.

## azure_max_single_part_upload_size {#azure_max_single_part_upload_size} 

<SettingsInfoBlock type="UInt64" default_value="104857600" />

Максимальный размер объекта для загрузки с использованием одномоментной загрузки в Azure Blob Storage.

## azure_max_single_read_retries {#azure_max_single_read_retries} 

<SettingsInfoBlock type="UInt64" default_value="4" />

Максимальное количество повторных попыток во время единичного считывания из Azure Blob Storage.

## azure_max_unexpected_write_error_retries {#azure_max_unexpected_write_error_retries} 

<SettingsInfoBlock type="UInt64" default_value="4" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "4"},{"label": "Максимальное количество повторных попыток в случае неожиданных ошибок во время записи в Azure Blob Storage"}]}]}/>

Максимальное количество повторных попыток в случае неожиданных ошибок во время записи в Azure Blob Storage.

## azure_max_upload_part_size {#azure_max_upload_part_size} 

<SettingsInfoBlock type="UInt64" default_value="5368709120" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "5368709120"},{"label": "Максимальный размер части для загрузки во время многослойной загрузки в Azure Blob Storage."}]}]}/>

Максимальный размер части для загрузки во время многослойной загрузки в Azure Blob Storage.

## azure_min_upload_part_size {#azure_min_upload_part_size} 

<SettingsInfoBlock type="UInt64" default_value="16777216" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "16777216"},{"label": "Минимальный размер части для загрузки во время многослойной загрузки в Azure Blob Storage."}]}]}/>

Минимальный размер части для загрузки во время многослойной загрузки в Azure Blob Storage.

## azure_sdk_max_retries {#azure_sdk_max_retries} 

<SettingsInfoBlock type="UInt64" default_value="10" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "10"},{"label": "Максимальное количество повторных попыток в Azure SDK"}]}]}/>

Максимальное количество повторных попыток в Azure SDK.

## azure_sdk_retry_initial_backoff_ms {#azure_sdk_retry_initial_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="10" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "10"},{"label": "Минимальная задержка между повторными попытками в Azure SDK"}]}]}/>

Минимальная задержка между повторными попытками в Azure SDK.

## azure_sdk_retry_max_backoff_ms {#azure_sdk_retry_max_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "1000"},{"label": "Максимальная задержка между повторными попытками в Azure SDK"}]}]}/>

Максимальная задержка между повторными попытками в Azure SDK.

## azure_skip_empty_files {#azure_skip_empty_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Разрешить пропускать пустые файлы в движке таблицы Azure"}]}]}/>

Включает или отключает пропуск пустых файлов в движке S3.

Возможные значения:
- 0 — `SELECT` выбрасывает исключение, если пустой файл не совместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.

## azure_strict_upload_part_size {#azure_strict_upload_part_size} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Точный размер части для загрузки во время многослойной загрузки в Azure Blob Storage."}]}]}/>

Точный размер части для загрузки во время многослойной загрузки в Azure Blob Storage.

## azure_throw_on_zero_files_match {#azure_throw_on_zero_files_match} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Разрешить выбрасывать ошибку, когда запрос ListObjects не может сопоставить файлы в движке AzureBlobStorage вместо пустого результата запроса"}]}]}/>

Выбросить ошибку, если совпадает ноль файлов согласно правилам расширения glob.

Возможные значения:
- 1 — `SELECT` выбрасывает исключение.
- 0 — `SELECT` возвращает пустой результат.

## azure_truncate_on_insert {#azure_truncate_on_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает обрезку перед вставкой в таблицы движка Azure.

## azure_upload_part_size_multiply_factor {#azure_upload_part_size_multiply_factor} 

<SettingsInfoBlock type="UInt64" default_value="2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "2"},{"label": "Умножить azure_min_upload_part_size на этот множитель каждый раз, когда azure_multiply_parts_count_threshold частей была загружена из одного запроса к Azure Blob Storage."}]}]}/>

Умножить azure_min_upload_part_size на этот множитель каждый раз, когда azure_multiply_parts_count_threshold частей была загружена из одного запроса к Azure Blob Storage.

## azure_upload_part_size_multiply_parts_count_threshold {#azure_upload_part_size_multiply_parts_count_threshold} 

<SettingsInfoBlock type="UInt64" default_value="500" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "500"},{"label": "Каждый раз, когда это число частей было загружено в Azure Blob Storage, azure_min_upload_part_size умножается на azure_upload_part_size_multiply_factor."}]}]}/>

Каждый раз, когда это число частей было загружено в Azure Blob Storage, azure_min_upload_part_size умножается на azure_upload_part_size_multiply_factor.

## backup_restore_batch_size_for_keeper_multi {#backup_restore_batch_size_for_keeper_multi} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Максимальный размер пакета для многократного запроса к [Zoo]Keeper во время резервного копирования или восстановления.

## backup_restore_batch_size_for_keeper_multiread {#backup_restore_batch_size_for_keeper_multiread} 

<SettingsInfoBlock type="UInt64" default_value="10000" />

Максимальный размер пакета для многократного чтения из [Zoo]Keeper во время резервного копирования или восстановления.

## backup_restore_failure_after_host_disconnected_for_seconds {#backup_restore_failure_after_host_disconnected_for_seconds} 

<SettingsInfoBlock type="UInt64" default_value="3600" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "3600"},{"label": "Новая настройка."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "3600"},{"label": "Новая настройка."}]}]}/>

Если хост во время операции BACKUP ON CLUSTER или RESTORE ON CLUSTER не воссоздает свой эфемерный узел 'alive' в ZooKeeper в течение этого времени, то вся операция резервного копирования или восстановления считается неудачной.
Это значение должно быть больше любого разумного времени, необходимого хосту для переподключения к ZooKeeper после сбоя.
Ноль означает неограниченно.

## backup_restore_finish_timeout_after_error_sec {#backup_restore_finish_timeout_after_error_sec} 

<SettingsInfoBlock type="UInt64" default_value="180" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "180"},{"label": "Новая настройка."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "180"},{"label": "Новая настройка."}]}]}/>

Сколько времени инициатор должен ждать, чтобы другие хосты отреагировали на узел 'error' и остановили свою работу по текущей операции BACKUP ON CLUSTER или RESTORE ON CLUSTER.

## backup_restore_keeper_fault_injection_probability {#backup_restore_keeper_fault_injection_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

Приблизительная вероятность сбоя для запроса к Keeper во время резервного копирования или восстановления. Допустимое значение находится в интервале [0.0f, 1.0f].

## backup_restore_keeper_fault_injection_seed {#backup_restore_keeper_fault_injection_seed} 

<SettingsInfoBlock type="UInt64" default_value="0" />

0 - случайный семя, в противном случае значение настройки.

## backup_restore_keeper_max_retries {#backup_restore_keeper_max_retries} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1000"},{"label": "Должно быть достаточно большим, чтобы вся операция BACKUP или RESTORE не завершилась неудачей из-за временной ошибки [Zoo]Keeper во время ее выполнения."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "1000"},{"label": "Должно быть достаточно большим, чтобы вся операция BACKUP или RESTORE не завершилась неудачей из-за временной ошибки [Zoo]Keeper во время ее выполнения."}]}]}/>

Максимальное количество повторных попыток для операций [Zoo]Keeper во время выполнения операции BACKUP или RESTORE.
Должно быть достаточно большим, чтобы вся операция не завершилась неудачей из-за временной ошибки [Zoo]Keeper.

## backup_restore_keeper_max_retries_while_handling_error {#backup_restore_keeper_max_retries_while_handling_error} 

<SettingsInfoBlock type="UInt64" default_value="20" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "20"},{"label": "Новая настройка."}]}, {"id": "row-2","items": [{"label": "24.10","items": [{"label": "20"},{"label": "Новая настройка."}]}]}]}/>

Максимальное количество повторных попыток для операций [Zoo]Keeper во время обработки ошибки операции BACKUP ON CLUSTER или RESTORE ON CLUSTER.

## backup_restore_keeper_max_retries_while_initializing {#backup_restore_keeper_max_retries_while_initializing} 

<SettingsInfoBlock type="UInt64" default_value="20" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "20"},{"label": "Новая настройка."}]}, {"id": "row-2","items": [{"label": "24.10","items": [{"label": "20"},{"label": "Новая настройка."}]}]}]}/>

Максимальное количество повторных попыток для операций [Zoo]Keeper во время инициализации операции BACKUP ON CLUSTER или RESTORE ON CLUSTER.

## backup_restore_keeper_retry_initial_backoff_ms {#backup_restore_keeper_retry_initial_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="100" />

Начальная задержка для операций [Zoo]Keeper во время резервного копирования или восстановления.

## backup_restore_keeper_retry_max_backoff_ms {#backup_restore_keeper_retry_max_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="5000" />

Максимальная задержка для операций [Zoo]Keeper во время резервного копирования или восстановления.

## backup_restore_keeper_value_max_size {#backup_restore_keeper_value_max_size} 

<SettingsInfoBlock type="UInt64" default_value="1048576" />

Максимальный размер данных узла [Zoo]Keeper во время резервного копирования.

## backup_restore_s3_retry_attempts {#backup_restore_s3_retry_attempts} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "1000"},{"label": "Настройка для Aws::Client::RetryStrategy, Aws::Client делает повторные попытки самостоятельно, 0 означает отсутствие повторных попыток. Это происходит только для резервного копирования/восстановления."}]}]}/>

Настройка для Aws::Client::RetryStrategy, Aws::Client делает повторные попытки самостоятельно, 0 означает отсутствие повторных попыток. Это происходит только для резервного копирования/восстановления.
```yaml
title: 'Настройки ClickHouse'
sidebar_label: 'Настройки ClickHouse'
keywords: ['clickhouse', 'настройки', 'база данных']
description: 'Настройки и параметры конфигурации ClickHouse.'
```

## cache_warmer_threads {#cache_warmer_threads} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="4" />

Имеет эффект только в ClickHouse Cloud. Количество фоновых потоков для спекулятивной загрузки новых частей данных в кэш файлов, когда включен [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch). Ноль для отключения.

## calculate_text_stack_trace {#calculate_text_stack_trace} 

<SettingsInfoBlock type="Bool" default_value="1" />

Вычислять текстовый стек вызовов в случае исключений во время выполнения запроса. Это значение по умолчанию. Это требует поиска символов, что может замедлить тесты на случайные ошибки, когда выполняется огромное количество неверных запросов. В обычных случаях вам не следует отключать эту опцию.

## cancel_http_readonly_queries_on_client_close {#cancel_http_readonly_queries_on_client_close} 

<SettingsInfoBlock type="Bool" default_value="0" />

Отменяет HTTP-запросы только для чтения (например, SELECT), когда клиент закрывает соединение, не дождавшись ответа.

Значение по умолчанию в облаке: `1`.

## cast_ipv4_ipv6_default_on_conversion_error {#cast_ipv4_ipv6_default_on_conversion_error} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.3"},{"label": "0"},{"label": "Сделать функции cast(value, 'IPv4') и cast(value, 'IPv6') вести себя так же, как функции toIPv4 и toIPv6"}]}]}/>

Оператор CAST для IPv4, оператор CAST для типа IPV6, функции toIPv4, toIPv6 будут возвращать значение по умолчанию вместо выбрасывания исключения при ошибке преобразования.

## cast_keep_nullable {#cast_keep_nullable} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает сохранение типа данных `Nullable` в операциях [CAST](/sql-reference/functions/type-conversion-functions#cast).

Когда настройка включена и аргумент функции `CAST` является `Nullable`, результат также преобразуется в тип `Nullable`. Когда настройка отключена, результат всегда имеет точно указанный целевой тип.

Возможные значения:

- 0 — Результат `CAST` имеет именно указанный целевой тип.
- 1 — Если аргумент типа `Nullable`, результат `CAST` преобразуется в `Nullable(DestinationDataType)`.

**Примеры**

Следующий запрос возвращает точно указанный целевой тип данных:

```sql
SET cast_keep_nullable = 0;
SELECT CAST(toNullable(toInt32(0)) AS Int32) as x, toTypeName(x);
```

Результат:

```text
┌─x─┬─toTypeName(CAST(toNullable(toInt32(0)), 'Int32'))─┐
│ 0 │ Int32                                             │
└───┴───────────────────────────────────────────────────┘
```

Следующий запрос возвращает модификацию `Nullable` для целевого типа данных:

```sql
SET cast_keep_nullable = 1;
SELECT CAST(toNullable(toInt32(0)) AS Int32) as x, toTypeName(x);
```

Результат:

```text
┌─x─┬─toTypeName(CAST(toNullable(toInt32(0)), 'Int32'))─┐
│ 0 │ Nullable(Int32)                                   │
└───┴───────────────────────────────────────────────────┘
```

**См. Также**

- [CAST](/sql-reference/functions/type-conversion-functions#cast) функция

## cast_string_to_dynamic_use_inference {#cast_string_to_dynamic_use_inference} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "0"},{"label": "Добавить настройку, позволяющую преобразовывать строку в динамический тип через парсинг"}]}]}/>

Использовать вывод типов во время преобразования строки в динамический тип.

## cast_string_to_variant_use_inference {#cast_string_to_variant_use_inference} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "Новая настройка для включения/отключения вывода типов при преобразовании из строки в вариант"}]}]}/>

Использовать вывод типов во время преобразования строки в вариант.

## check_query_single_value_result {#check_query_single_value_result} 

<SettingsInfoBlock type="Bool" default_value="1" />

Определяет уровень детализации результата запроса [CHECK TABLE](/sql-reference/statements/check-table) для движков семейства `MergeTree`.

Возможные значения:

- 0 — запрос показывает статус проверки для каждой отдельной части данных таблицы.
- 1 — запрос показывает общий статус проверки таблицы.

## check_referential_table_dependencies {#check_referential_table_dependencies} 

<SettingsInfoBlock type="Bool" default_value="0" />

Проверяет, что DDL-запрос (например, DROP TABLE или RENAME) не нарушит ссылочные зависимости.

## check_table_dependencies {#check_table_dependencies} 

<SettingsInfoBlock type="Bool" default_value="1" />

Проверяет, что DDL-запрос (например, DROP TABLE или RENAME) не нарушит зависимости.

## checksum_on_read {#checksum_on_read} 

<SettingsInfoBlock type="Bool" default_value="1" />

Проверка контрольных сумм при чтении. Это включено по умолчанию и всегда должно быть включено в производстве. Пожалуйста, не ожидайте никаких выигрышей от отключения этой настройки. Она может быть использована только для экспериментов и бенчмарков. Настройка применима только для таблиц семейства MergeTree. Контрольные суммы всегда проверяются для других движков таблиц и при получении данных по сети.

## cloud_mode {#cloud_mode} 

<SettingsInfoBlock type="Bool" default_value="0" />

Режим облака.

## cloud_mode_database_engine {#cloud_mode_database_engine} 

<SettingsInfoBlock type="UInt64" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Движок базы данных, разрешенный в облаке. 1 — переписывать DDL для использования реплицированной базы данных, 2 — переписывать DDL для использования общей базы данных.

## cloud_mode_engine {#cloud_mode_engine} 

<SettingsInfoBlock type="UInt64" default_value="1" />

Семейство движков, разрешенное в облаке.

- 0 — разрешить всё
- 1 — переписывать DDL для использования *ReplicatedMergeTree
- 2 — переписывать DDL для использования SharedMergeTree
- 3 — переписывать DDL для использования SharedMergeTree, если явно не указан удаленный диск

UInt64 для минимизации публичной части.

## cluster_for_parallel_replicas {#cluster_for_parallel_replicas} 

<BetaBadge/>

Кластер для шардирования, в котором расположен текущий сервер.

## collect_hash_table_stats_during_aggregation {#collect_hash_table_stats_during_aggregation} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает сбор статистики хеш-таблицы для оптимизации распределения памяти.

## collect_hash_table_stats_during_joins {#collect_hash_table_stats_during_joins} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "1"},{"label": "Новая настройка."}]}]}/>

Включает сбор статистики хеш-таблицы для оптимизации распределения памяти.

## compatibility {#compatibility} 

Настройка `compatibility` заставляет ClickHouse использовать настройки по умолчанию предыдущей версии ClickHouse, где предыдущая версия указывается как настройка.

Если настройки установлены на не-значения по умолчанию, то эти настройки учитываются (только настройки, которые не были изменены, подлежат воздействию настройки `compatibility`).

Эта настройка принимает номер версии ClickHouse в виде строки, например `22.3`, `22.8`. Пустое значение означает, что эта настройка отключена.

Отключено по умолчанию.

:::note
В ClickHouse Cloud настройка совместимости должна быть установлена поддержкой ClickHouse Cloud. Пожалуйста, [откройте запрос](https://clickhouse.cloud/support) для ее установки.
:::

## compatibility_ignore_auto_increment_in_create_table {#compatibility_ignore_auto_increment_in_create_table} 

<SettingsInfoBlock type="Bool" default_value="0" />

Игнорировать ключевое слово AUTO_INCREMENT в объявлении колонки, если true, иначе возвращать ошибку. Это упрощает миграцию с MySQL.

## compatibility_ignore_collation_in_create_table {#compatibility_ignore_collation_in_create_table} 

<SettingsInfoBlock type="Bool" default_value="1" />

Совместимость игнорирует сортировку при создании таблицы.

## compile_aggregate_expressions {#compile_aggregate_expressions} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает JIT-компиляцию агрегатных функций в нативный код. Включение этой настройки может улучшить производительность.

Возможные значения:

- 0 — Агегация выполняется без JIT-компиляции.
- 1 — Агрегация выполняется с использованием JIT-компиляции.

**См. Также**

- [min_count_to_compile_aggregate_expression](#min_count_to_compile_aggregate_expression)

## compile_expressions {#compile_expressions} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Мы считаем, что инфраструктура LLVM, лежащая в основе JIT-компилятора, достаточно стабильна, чтобы включить эту настройку по умолчанию."}]}]}/>

Компилирует некоторые скалярные функции и операторы в нативный код.

## compile_sort_description {#compile_sort_description} 

<SettingsInfoBlock type="Bool" default_value="1" />

Компилирует описание сортировки в нативный код.

## connect_timeout {#connect_timeout} 

<SettingsInfoBlock type="Seconds" default_value="10" />

Тайм-аут подключения, если нет реплик.

## connect_timeout_with_failover_ms {#connect_timeout_with_failover_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "1000"},{"label": "Увеличить тайм-аут подключения по умолчанию из-за асинхронного подключения"}]}]}/>

Тайм-аут в миллисекундах для подключения к удаленному серверу для движка распределенной таблицы, если в определении кластера используются секции 'shard' и 'replica'. Если неудачно, несколько попыток производятся для подключения к различным репликам.

## connect_timeout_with_failover_secure_ms {#connect_timeout_with_failover_secure_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "1000"},{"label": "Увеличить тайм-аут безопасного подключения по умолчанию из-за асинхронного подключения"}]}]}/>

Тайм-аут подключения для выбора первой здоровой реплики (для безопасных соединений).

## connection_pool_max_wait_ms {#connection_pool_max_wait_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время ожидания в миллисекундах для подключения, когда пул подключений полон.

Возможные значения:

- Положительное целое число.
- 0 — Бессрочный тайм-аут.

## connections_with_failover_max_tries {#connections_with_failover_max_tries} 

<SettingsInfoBlock type="UInt64" default_value="3" />

Максимальное количество попыток подключения с каждой репликой для движка распределенной таблицы.

## convert_query_to_cnf {#convert_query_to_cnf} 

<SettingsInfoBlock type="Bool" default_value="0" />

Когда установлено в `true`, запрос `SELECT` будет преобразован в конъюнктивную нормальную форму (CNF). Существуют сценарии, в которых переписывание запроса в CNF может выполняться быстрее (посмотрите эту [проблему на Github](https://github.com/ClickHouse/ClickHouse/issues/11749) для объяснения).

Например, обратите внимание, как следующий запрос `SELECT` не изменен (дефолтное поведение):

```sql
EXPLAIN SYNTAX
SELECT *
FROM
(
    SELECT number AS x
    FROM numbers(20)
) AS a
WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))
SETTINGS convert_query_to_cnf = false;
```

Результат:

```response
┌─explain────────────────────────────────────────────────────────┐
│ SELECT x                                                       │
│ FROM                                                           │
│ (                                                              │
│     SELECT number AS x                                         │
│     FROM numbers(20)                                           │
│     WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15)) │
│ ) AS a                                                         │
│ WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))     │
│ SETTINGS convert_query_to_cnf = 0                              │
└────────────────────────────────────────────────────────────────┘
```

Давайте установим `convert_query_to_cnf` в `true` и посмотрим, что изменится:

```sql
EXPLAIN SYNTAX
SELECT *
FROM
(
    SELECT number AS x
    FROM numbers(20)
) AS a
WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))
SETTINGS convert_query_to_cnf = true;
```

Обратите внимание, что оператор `WHERE` переписан в CNF, но набор результатов идентичен — логика булева условия осталась без изменений:

```response
┌─explain───────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ SELECT x                                                                                                              │
│ FROM                                                                                                                  │
│ (                                                                                                                     │
│     SELECT number AS x                                                                                                │
│     FROM numbers(20)                                                                                                  │
│     WHERE ((x <= 15) OR (x <= 5)) AND ((x <= 15) OR (x >= 1)) AND ((x >= 10) OR (x <= 5)) AND ((x >= 10) OR (x >= 1)) │
│ ) AS a                                                                                                                │
│ WHERE ((x >= 10) OR (x >= 1)) AND ((x >= 10) OR (x <= 5)) AND ((x <= 15) OR (x >= 1)) AND ((x <= 15) OR (x <= 5))     │
│ SETTINGS convert_query_to_cnf = 1                                                                                     │
└───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

Возможные значения: true, false.

## count_distinct_implementation {#count_distinct_implementation} 

<SettingsInfoBlock type="String" default_value="uniqExact" />

Указывает, какая из функций `uniq*` должна использоваться для выполнения конструкции [COUNT(DISTINCT ...)](/sql-reference/aggregate-functions/reference/count).

Возможные значения:

- [uniq](/sql-reference/aggregate-functions/reference/uniq)
- [uniqCombined](/sql-reference/aggregate-functions/reference/uniqcombined)
- [uniqCombined64](/sql-reference/aggregate-functions/reference/uniqcombined64)
- [uniqHLL12](/sql-reference/aggregate-functions/reference/uniqhll12)
- [uniqExact](/sql-reference/aggregate-functions/reference/uniqexact)

## count_distinct_optimization {#count_distinct_optimization} 

<SettingsInfoBlock type="Bool" default_value="0" />

Переписывает count distinct в подзапрос по группировке.

## create_if_not_exists {#create_if_not_exists} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Включает `IF NOT EXISTS` для оператора `CREATE` по умолчанию. Если эта настройка или `IF NOT EXISTS` указана, и таблица с указанным именем уже существует, исключение не будет выброшено.

## create_index_ignore_unique {#create_index_ignore_unique} 

<SettingsInfoBlock type="Bool" default_value="0" />

Игнорировать ключевое слово UNIQUE при создании уникального индекса. Сделано для тестов совместимости SQL.

## create_replicated_merge_tree_fault_injection_probability {#create_replicated_merge_tree_fault_injection_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

Вероятность ошибки инъекции при создании таблицы после создания метаданных в ZooKeeper.

## create_table_empty_primary_key_by_default {#create_table_empty_primary_key_by_default} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить создание *MergeTree таблиц с пустым первичным ключом, когда ORDER BY и PRIMARY KEY не указаны.

## cross_join_min_bytes_to_compress {#cross_join_min_bytes_to_compress} 

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "1073741824"},{"label": "Минимальный размер блока для сжатия в CROSS JOIN. Нулевое значение отключает этот порог. Этот блок сжимается, когда достигается один из двух порогов (по строкам или по байтам)."}]}]}/>

Минимальный размер блока для сжатия в CROSS JOIN. Нулевое значение отключает этот порог. Этот блок сжимается, когда достигается один из двух порогов (по строкам или по байтам).

## cross_join_min_rows_to_compress {#cross_join_min_rows_to_compress} 

<SettingsInfoBlock type="UInt64" default_value="10000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "10000000"},{"label": "Минимальное количество строк для сжатия блока в CROSS JOIN. Нулевое значение отключает этот порог. Этот блок сжимается, когда достигается один из двух порогов (по строкам или по байтам)."}]}]}/>

Минимальное количество строк для сжатия блока в CROSS JOIN. Нулевое значение отключает этот порог. Этот блок сжимается, когда достигается один из двух порогов (по строкам или по байтам).

## data_type_default_nullable {#data_type_default_nullable} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет типам данных без явных модификаторов [NULL или NOT NULL](/sql-reference/statements/create/table#null-or-not-null-modifiers) в определении колонки быть [Nullable](/sql-reference/data-types/nullable).

Возможные значения:

- 1 — Типы данных в определениях столбцов по умолчанию устанавливаются как `Nullable`.
- 0 — Типы данных в определениях столбцов по умолчанию устанавливаются как не `Nullable`.

## database_atomic_wait_for_drop_and_detach_synchronously {#database_atomic_wait_for_drop_and_detach_synchronously} 

<SettingsInfoBlock type="Bool" default_value="0" />

Добавляет модификатор `SYNC` к всем запросам `DROP` и `DETACH`.

Возможные значения:

- 0 — Запросы будут выполняться с задержкой.
- 1 — Запросы будут выполняться без задержки.

## database_replicated_allow_explicit_uuid {#database_replicated_allow_explicit_uuid} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Добавлена новая настройка, чтобы запретить явное указание UUID таблицы"}]}]}/>

0 - Не разрешать явно указывать UUID для таблиц в реплицированных базах данных. 1 - Разрешить. 2 - Разрешить, но игнорировать указанный UUID и вместо этого генерировать случайный.

## database_replicated_allow_heavy_create {#database_replicated_allow_heavy_create} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Долговременные DDL запросы (CREATE AS SELECT и POPULATE) для движка реплицированной базы данных были запрещены"}]}]}/>

Разрешить долго выполняющиеся DDL запросы (CREATE AS SELECT и POPULATE) в реплицированном движке базы данных. Обратите внимание, что это может блокировать очередь DDL на длительное время.

## database_replicated_allow_only_replicated_engine {#database_replicated_allow_only_replicated_engine} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить создание только реплицированных таблиц в базе данных с движком Replicated.

## database_replicated_allow_replicated_engine_arguments {#database_replicated_allow_replicated_engine_arguments} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Не разрешать явные аргументы по умолчанию"}]}]}/>

0 - Не разрешать явно указывать путь ZooKeeper и имя реплики для *MergeTree таблиц в реплицированных базах данных. 1 - Разрешить. 2 - Разрешить, но игнорировать указанный путь и использовать вместо этого путь по умолчанию. 3 - Разрешить и не записывать предупреждение в журнал.

## database_replicated_always_detach_permanently {#database_replicated_always_detach_permanently} 

<SettingsInfoBlock type="Bool" default_value="0" />

Выполнять DETACH TABLE как DETACH TABLE PERMANENTLY, если движок базы данных — Replicated.

## database_replicated_enforce_synchronous_settings {#database_replicated_enforce_synchronous_settings} 

<SettingsInfoBlock type="Bool" default_value="0" />

Принудительно дожидаться некоторых запросов (также см. database_atomic_wait_for_drop_and_detach_synchronously, mutations_sync, alter_sync). Не рекомендуется включать эти настройки.

## database_replicated_initial_query_timeout_sec {#database_replicated_initial_query_timeout_sec} 

<SettingsInfoBlock type="UInt64" default_value="300" />

Устанавливает, как долго начальный DDL-запрос должен ждать, чтобы реплицированная база данных обработала предыдущие записи в очереди DDL в секундах.

Возможные значения:

- Положительное целое число.
- 0 — Неограниченно.

## decimal_check_overflow {#decimal_check_overflow} 

<SettingsInfoBlock type="Bool" default_value="1" />

Проверка переполнения десятичных арифметических/сравнительных операций.

## deduplicate_blocks_in_dependent_materialized_views {#deduplicate_blocks_in_dependent_materialized_views} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает проверку дедупликации для материализованных представлений, которые получают данные из таблиц типа Replicated*.

Возможные значения:

      0 — Отключено.
      1 — Включено.

Использование

По умолчанию дедупликация не выполняется для материализованных представлений, но выполняется на верхнем уровне, в исходной таблице.
Если вставленный блок пропускается из-за дедупликации в исходной таблице, вставка в прикрепленные материализованные представления не произойдет. Это поведение существует, чтобы разрешить вставку сильно агрегированных данных в материализованные представления, в случаях, когда вставленные блоки одинаковы после агрегации в материализованном представлении, но происходят из разных вставок в исходную таблицу.
В то же время, это поведение "ломает" идемпотентность `INSERT`. Если `INSERT` в основную таблицу был успешен, а `INSERT` в материализованное представление не удался (например, из-за сбоя связи с ClickHouse Keeper), клиент получит ошибку и может повторить операцию. Однако материализованное представление не получит второй вставки, потому что она будет отклонена дедупликацией в главной (исходной) таблице. Настройка `deduplicate_blocks_in_dependent_materialized_views` позволяет изменить это поведение. При повторной попытке материализованное представление получит повторную вставку и выполнит проверку дедупликации самостоятельно, игнорируя результат проверки для исходной таблицы и вставляя строки, потерянные из-за первого сбоя.

## default_materialized_view_sql_security {#default_materialized_view_sql_security} 

<SettingsInfoBlock type="SQLSecurityType" default_value="DEFINER" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "DEFINER"},{"label": "Позволяет установить значение по умолчанию для параметра SQL SECURITY при создании материализованного представления"}]}]}/>

Позволяет установить значение по умолчанию для параметра SQL SECURITY при создании материализованного представления. [Подробнее о безопасности SQL](../../sql-reference/statements/create/view.md/#sql_security).

Значение по умолчанию — `DEFINER`.

## default_max_bytes_in_join {#default_max_bytes_in_join} 

<SettingsInfoBlock type="UInt64" default_value="1000000000" />

Максимальный размер правой таблицы, если требуется ограничение, но `max_bytes_in_join` не установлен.

## default_normal_view_sql_security {#default_normal_view_sql_security} 

<SettingsInfoBlock type="SQLSecurityType" default_value="INVOKER" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "INVOKER"},{"label": "Позволяет установить значение по умолчанию для параметра `SQL SECURITY` при создании обычного представления"}]}]}/>

Позволяет установить значение по умолчанию для параметра `SQL SECURITY` при создании обычного представления. [Подробнее о безопасности SQL](../../sql-reference/statements/create/view.md/#sql_security).

Значение по умолчанию — `INVOKER`.

## default_reader_bucket_count {#default_reader_bucket_count} 

<ExperimentalBadge/>

<SettingsInfoBlock type="UInt64" default_value="8" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "8"},{"label": "Новая экспериментальная настройка."}]}]}/>

Число задач для параллельного чтения в распределенном запросе по умолчанию. Задачи распределяются между репликами.

## default_shuffle_join_bucket_count {#default_shuffle_join_bucket_count} 

<ExperimentalBadge/>

<SettingsInfoBlock type="UInt64" default_value="8" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "8"},{"label": "Новая экспериментальная настройка."}]}]}/>

Число ведер для распределенного shuffle-hash-join по умолчанию.

## default_table_engine {#default_table_engine} 

<SettingsInfoBlock type="DefaultTableEngine" default_value="MergeTree" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "MergeTree"},{"label": "Установить движок таблицы по умолчанию для MergeTree для лучшей удобства"}]}]}/>

Движок таблицы по умолчанию, который будет использоваться, когда `ENGINE` не установлен в операторе `CREATE`.

Возможные значения:

- строка, представляющая любое допустимое имя движка таблицы.

Значение по умолчанию в облаке: `SharedMergeTree`.

**Пример**

Запрос:

```sql
SET default_table_engine = 'Log';

SELECT name, value, changed FROM system.settings WHERE name = 'default_table_engine';
```

Результат:

```response
┌─name─────────────────┬─value─┬─changed─┐
│ default_table_engine │ Log   │       1 │
└──────────────────────┴───────┴─────────┘
```

В этом примере любая новая таблица, которая не указывает `Engine`, будет использовать движок таблицы `Log`:

Запрос:

```sql
CREATE TABLE my_table (
    x UInt32,
    y UInt32
);

SHOW CREATE TABLE my_table;
```

Результат:

```response
┌─statement────────────────────────────────────────────────────────────────┐
│ CREATE TABLE default.my_table
(
    `x` UInt32,
    `y` UInt32
)
ENGINE = Log
└──────────────────────────────────────────────────────────────────────────┘
```

## default_temporary_table_engine {#default_temporary_table_engine} 

<SettingsInfoBlock type="DefaultTableEngine" default_value="Memory" />

То же, что и [default_table_engine](#default_table_engine), но для временных таблиц.

В этом примере любая новая временная таблица, которая не указывает `Engine`, будет использовать движок таблицы `Log`:

Запрос:

```sql
SET default_temporary_table_engine = 'Log';

CREATE TEMPORARY TABLE my_table (
    x UInt32,
    y UInt32
);

SHOW CREATE TEMPORARY TABLE my_table;
```

Результат:

```response
┌─statement────────────────────────────────────────────────────────────────┐
│ CREATE TEMPORARY TABLE default.my_table
(
    `x` UInt32,
    `y` UInt32
)
ENGINE = Log
└──────────────────────────────────────────────────────────────────────────┘
```

## default_view_definer {#default_view_definer} 

<SettingsInfoBlock type="String" default_value="CURRENT_USER" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "CURRENT_USER"},{"label": "Позволяет установить значение по умолчанию для параметра `DEFINER` при создании представления"}]}]}/>

Позволяет установить значение по умолчанию для параметра `DEFINER` при создании представления. [Подробнее о безопасности SQL](../../sql-reference/statements/create/view.md/#sql_security).

Значение по умолчанию — `CURRENT_USER`.

## describe_compact_output {#describe_compact_output} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если true, включает только имена колонок и типы в результате запроса DESCRIBE.

## describe_extend_object_types {#describe_extend_object_types} 

<SettingsInfoBlock type="Bool" default_value="0" />

Выводит конкретный тип колонок типа Object в запросе DESCRIBE.

## describe_include_subcolumns {#describe_include_subcolumns} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает описание подколонок для запроса [DESCRIBE](../../sql-reference/statements/describe-table.md). Например, члены [Tuple](../../sql-reference/data-types/tuple.md) или подколонки типа [Map](/sql-reference/data-types/map#reading-subcolumns-of-map), [Nullable](../../sql-reference/data-types/nullable.md/#finding-null) или [Array](../../sql-reference/data-types/array.md/#array-size).

Возможные значения:

- 0 — Подколонки не включены в запросы `DESCRIBE`.
- 1 — Подколонки включены в запросы `DESCRIBE`.

**Пример**

Смотрите пример для оператора [DESCRIBE](../../sql-reference/statements/describe-table.md).

## describe_include_virtual_columns {#describe_include_virtual_columns} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если true, виртуальные колонки таблицы будут включены в результат запроса DESCRIBE.

## dialect {#dialect} 

<SettingsInfoBlock type="Dialect" default_value="clickhouse" />

Какой диалект будет использован для разбора запроса.

## dictionary_validate_primary_key_type {#dictionary_validate_primary_key_type} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Проверка типа первичного ключа для словарей. По умолчанию тип id для простых компоновок будет неявно преобразован в UInt64."}]}]}/>

Проверка типа первичного ключа для словарей. По умолчанию тип id для простых компоновок будет неявно преобразован в UInt64.

## distinct_overflow_mode {#distinct_overflow_mode} 

<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, когда объем данных превышает один из лимитов.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат, как если бы исходные данные закончились.

## distributed_aggregation_memory_efficient {#distributed_aggregation_memory_efficient} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включен ли режим экономии памяти для распределенной агрегации.

## distributed_background_insert_batch {#distributed_background_insert_batch} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает/выключает отправку вставленных данных в пакетах.

Когда включена отправка пакетами, движок таблицы [Distributed](../../engines/table-engines/special/distributed.md) пытается отправить несколько файлов вставленных данных в одной операции вместо отправки их отдельно. Пакетная отправка улучшает производительность кластера за счет лучшего использования ресурсов сервера и сети.

Возможные значения:

- 1 — Включено.
- 0 — Отключено.

## distributed_background_insert_max_sleep_time_ms {#distributed_background_insert_max_sleep_time_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="30000" />

Максимальный интервал для движка таблицы [Distributed](../../engines/table-engines/special/distributed.md), чтобы отправить данные. Ограничивает экспоненциальный прирост интервала, установленного в настройке [distributed_background_insert_sleep_time_ms](#distributed_background_insert_sleep_time_ms).

Возможные значения:

- Положительное целое число миллисекунд.
## distributed_background_insert_sleep_time_ms {#distributed_background_insert_sleep_time_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="100" />

Базовый интервал для движка таблицы [Distributed](../../engines/table-engines/special/distributed.md) для отправки данных. Фактический интервал растет экспоненциально в случае ошибок.

Возможные значения:

- Положительное целое число миллисекунд.
## distributed_background_insert_split_batch_on_failure {#distributed_background_insert_split_batch_on_failure} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает/выключает разделение партий при сбоях.

Иногда отправка конкретной партии на удаленный шард может потерпеть неудачу из-за некоторой сложной цепочки после (т.е. `MATERIALIZED VIEW` с `GROUP BY`) из-за `Memory limit exceeded` или аналогичных ошибок. В этом случае повторная попытка не поможет (и это заблокирует распределенные отправки для таблицы), но отправка файлов из этой партии один за другим может успешно завершить INSERT.

Таким образом, установка этой настройки в `1` отключит пакетирование для таких партий (т.е. временно отключает `distributed_background_insert_batch` для неудачных партий).

Возможные значения:

- 1 — Включено.
- 0 — Выключено.

:::note
Эта настройка также влияет на поврежденные партии (которые могут возникнуть из-за ненормального завершения сервера (машины) и отсутствия `fsync_after_insert`/`fsync_directories` для движка таблицы [Distributed](../../engines/table-engines/special/distributed.md)).
:::

:::note
Не следует полагаться на автоматическое разделение партий, так как это может ухудшить производительность.
:::
## distributed_background_insert_timeout {#distributed_background_insert_timeout} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Таймаут для вставки запроса в распределенной базе данных. Настройка используется только с включенной опцией insert_distributed_sync. Нулевое значение означает отсутствие таймаута.
## distributed_cache_bypass_connection_pool {#distributed_cache_bypass_connection_pool} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Позволяет обходить пул соединений к распределенному кэшу.
## distributed_cache_connect_max_tries {#distributed_cache_connect_max_tries} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="20" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "20"},{"label": "Только для облака"}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "20"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Количество попыток подключения к распределенному кэшу в случае неудачи.
## distributed_cache_data_packet_ack_window {#distributed_cache_data_packet_ack_window} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="5" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "5"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Окно для отправки ACK для последовательности DataPacket в одном запросе чтения распределенного кэша.
## distributed_cache_discard_connection_if_unread_data {#distributed_cache_discard_connection_if_unread_data} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Новая настройка"}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Отклоняет соединение, если некоторые данные не прочитаны.
## distributed_cache_fetch_metrics_only_from_current_az {#distributed_cache_fetch_metrics_only_from_current_az} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Получает метрики только из текущей зоны доступности в system.distributed_cache_metrics, system.distributed_cache_events.
## distributed_cache_log_mode {#distributed_cache_log_mode} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="DistributedCacheLogMode" default_value="on_error" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "on_error"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Режим записи в system.distributed_cache_log.
## distributed_cache_max_unacked_inflight_packets {#distributed_cache_max_unacked_inflight_packets} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="10" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "10"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Максимальное количество неподтвержденных пакетов, находящихся в пути, в одном запросе чтения распределенного кэша.
## distributed_cache_min_bytes_for_seek {#distributed_cache_min_bytes_for_seek} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Новая приватная настройка."}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Минимальное количество байт для выполнения поиска в распределенном кэше.
## distributed_cache_pool_behaviour_on_limit {#distributed_cache_pool_behaviour_on_limit} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="DistributedCachePoolBehaviourOnLimit" default_value="wait" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "wait"},{"label": "Только для облака"}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "allocate_bypassing_pool"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Определяет поведение соединения к распределенному кэшу при достижении лимита пула.
## distributed_cache_read_alignment {#distributed_cache_read_alignment} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Настройка для тестирования, не изменяйте ее.
## distributed_cache_read_only_from_current_az {#distributed_cache_read_only_from_current_az} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Разрешает читать только из текущей зоны доступности. Если отключено, будет произведено чтение со всех серверов кэша во всех зонах доступности.
## distributed_cache_read_request_max_tries {#distributed_cache_read_request_max_tries} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="20" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "20"},{"label": "Новая настройка"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Количество попыток выполнения запроса к распределенному кэшу в случае неудачи.
## distributed_cache_receive_response_wait_milliseconds {#distributed_cache_receive_response_wait_milliseconds} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="60000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "60000"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Время ожидания в миллисекундах для получения данных по запросу от распределенного кэша.
## distributed_cache_receive_timeout_milliseconds {#distributed_cache_receive_timeout_milliseconds} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="10000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "10000"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Время ожидания в миллисекундах для получения любого рода ответа от распределенного кэша.
## distributed_cache_throw_on_error {#distributed_cache_throw_on_error} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Пробрасывает исключение, произошедшее во время общения с распределенным кэшем, или исключение, полученное от распределенного кэша. В противном случае возврат к пропуску распределенного кэша при ошибке.
## distributed_cache_wait_connection_from_pool_milliseconds {#distributed_cache_wait_connection_from_pool_milliseconds} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="100" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "100"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Время ожидания в миллисекундах для получения соединения из пула соединений, если distributed_cache_pool_behaviour_on_limit равно wait.
## distributed_connections_pool_size {#distributed_connections_pool_size} 

<SettingsInfoBlock type="UInt64" default_value="1024" />

Максимальное количество одновременных соединений с удаленными серверами для распределенной обработки всех запросов к одной таблице Distributed. Рекомендуется устанавливать значение не меньше количества серверов в кластере.
## distributed_ddl_entry_format_version {#distributed_ddl_entry_format_version} 

<SettingsInfoBlock type="UInt64" default_value="5" />

Совместимость версии распределенных DDL (ON CLUSTER) запросов.
## distributed_ddl_output_mode {#distributed_ddl_output_mode} 

<SettingsInfoBlock type="DistributedDDLOutputMode" default_value="throw" />

Устанавливает формат результата запроса распределенного DDL.

Возможные значения:

- `throw` — Возвращает набор результатов с состоянием выполнения запроса для всех хостов, где запрос завершен. Если запрос завершился с ошибкой на некоторых хостах, то будет повторным выбросом первого исключения. Если запрос еще не завершен на некоторых хостах, и [distributed_ddl_task_timeout](#distributed_ddl_task_timeout) превышен, тогда он выбросит исключение `TIMEOUT_EXCEEDED`.
- `none` — Похоже на throw, но запрос распределенного DDL не возвращает набор результатов.
- `null_status_on_timeout` — Возвращает `NULL` в качестве статуса выполнения в некоторых строках набора результатов вместо выброса `TIMEOUT_EXCEEDED`, если запрос не завершен на соответствующих хостах.
- `never_throw` — Не выбрасывать `TIMEOUT_EXCEEDED` и не повторно выбрасывать исключения, если запрос завершился с ошибкой на некоторых хостах.
- `none_only_active` - похоже на `none`, но не ожидает неактивные реплики базы данных `Replicated`. Примечание: с этим режимом невозможно определить, что запрос не был выполнен на некоторой реплике и будет выполнен в фоновом режиме.
- `null_status_on_timeout_only_active` — похоже на `null_status_on_timeout`, но не ожидает неактивные реплики базы данных `Replicated`.
- `throw_only_active` — похоже на `throw`, но не ожидает неактивные реплики базы данных `Replicated`.

Облачное значение по умолчанию: `none`.
## distributed_ddl_task_timeout {#distributed_ddl_task_timeout} 

<SettingsInfoBlock type="Int64" default_value="180" />

Устанавливает таймаут для ответов на DDL запросы со всех хостов в кластере. Если DDL запрос не был выполнен на всех хостах, ответ будет содержать ошибку таймаута, и запрос будет выполнен в асинхронном режиме. Отрицательное значение означает бесконечный таймаут.

Возможные значения:

- Положительное целое число.
- 0 — Асинхронный режим.
- Отрицательное целое число — бесконечный таймаут.
## distributed_foreground_insert {#distributed_foreground_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает синхронную вставку данных в таблицу [Distributed](/engines/table-engines/special/distributed).

По умолчанию, при вставке данных в таблицу `Distributed`, сервер ClickHouse отправляет данные на узлы кластера в фоновом режиме. Когда `distributed_foreground_insert=1`, данные обрабатываются синхронно, и операция `INSERT` завершается успешно только после того, как все данные будут сохранены на всех шарах (по крайней мере одна реплика для каждого шара, если `internal_replication` истинно).

Возможные значения:

- 0 — Данные вставляются в фоновом режиме.
- 1 — Данные вставляются в синхронном режиме.

Облачное значение по умолчанию: `1`.

**См. также**

- [Distributed Table Engine](/engines/table-engines/special/distributed)
- [Управление распределенными таблицами](/sql-reference/statements/system#managing-distributed-tables)
## distributed_group_by_no_merge {#distributed_group_by_no_merge} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Не объединять состояния агрегации с разных серверов для распределенной обработки запроса, можно использовать это, если точно известно, что ключи разные на разных шарах.

Возможные значения:

- `0` — Отключено (финальная обработка запроса выполняется на узле инициатора).
- `1` - Не объединять состояния агрегации с разных серверов для распределенной обработки запроса (запрос полностью обрабатывается на шаре, инициатор только проксирует данные), можно использовать в случае если точно известно, что ключи разные на разных шарах.
- `2` - То же самое, что и `1`, но применяет `ORDER BY` и `LIMIT` (это невозможно, когда запрос полностью обрабатывается на удаленном узле, как для `distributed_group_by_no_merge=1`) на инициаторе (можно использовать для запросов с `ORDER BY` и/или `LIMIT`).

**Пример**

```sql
SELECT *
FROM remote('127.0.0.{2,3}', system.one)
GROUP BY dummy
LIMIT 1
SETTINGS distributed_group_by_no_merge = 1
FORMAT PrettyCompactMonoBlock

┌─dummy─┐
│     0 │
│     0 │
└───────┘
```

```sql
SELECT *
FROM remote('127.0.0.{2,3}', system.one)
GROUP BY dummy
LIMIT 1
SETTINGS distributed_group_by_no_merge = 2
FORMAT PrettyCompactMonoBlock

┌─dummy─┐
│     0 │
└───────┘
```
## distributed_insert_skip_read_only_replicas {#distributed_insert_skip_read_only_replicas} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Если включено, INSERT в Distributed будет пропускать только для чтения реплики"}]}]}/>

Включает пропуск реплик только для чтения для запросов INSERT в Distributed.

Возможные значения:

- 0 — INSERT выполнялся как обычно, если он попадет на только для чтения реплику, он завершится с ошибкой.
- 1 — Инициатор пропустит только для чтения реплики перед отправкой данных на шарды.
## distributed_product_mode {#distributed_product_mode} 

<SettingsInfoBlock type="DistributedProductMode" default_value="deny" />

Изменяет поведение [распределенных подзапросов](../../sql-reference/operators/in.md).

ClickHouse применяет эту настройку, когда запрос содержит произведение распределенных таблиц, т.е. когда запрос для распределенной таблицы содержит не-GLOBAL подзапрос для распределенной таблицы.

Ограничения:

- Применяется только для подзапросов IN и JOIN.
- Только если секция FROM использует распределенную таблицу, содержащую более одного шара.
- Если подзапрос касается распределенной таблицы, содержащей более одного шара.
- Не используется для функции табличного типа [remote](../../sql-reference/table-functions/remote.md).

Возможные значения:

- `deny` — Значение по умолчанию. Запрещает использование таких типов подзапросов (возвращает исключение "Double-distributed in/JOIN subqueries is denied").
- `local` — Заменяет базу данных и таблицу в подзапросе на локальные для целевого сервера (шара), оставляя нормальный `IN`/`JOIN`.
- `global` — Заменяет запрос `IN`/`JOIN` на `GLOBAL IN`/`GLOBAL JOIN`.
- `allow` — Разрешает использование таких типов подзапросов.
## distributed_push_down_limit {#distributed_push_down_limit} 

<SettingsInfoBlock type="UInt64" default_value="1" />

Включает или отключает применение [LIMIT](#limit) на каждом шаре отдельно.

Это позволит избежать:
- Отправки лишних строк по сети;
- Обработки строк после лимита на инициаторе.

Начиная с версии 21.9, вы больше не можете получить неточные результаты, так как `distributed_push_down_limit` изменяет выполнение запроса только если выполнено хотя бы одно из условий:
- [distributed_group_by_no_merge](#distributed_group_by_no_merge) > 0.
- Запрос **не содержит** `GROUP BY`/`DISTINCT`/`LIMIT BY`, но имеет `ORDER BY`/`LIMIT`.
- Запрос **содержит** `GROUP BY`/`DISTINCT`/`LIMIT BY` с `ORDER BY`/`LIMIT` и:
    - [optimize_skip_unused_shards](#optimize_skip_unused_shards) включен.
    - [optimize_distributed_group_by_sharding_key](#optimize_distributed_group_by_sharding_key) включен.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

Смотрите также:

- [distributed_group_by_no_merge](#distributed_group_by_no_merge)
- [optimize_skip_unused_shards](#optimize_skip_unused_shards)
- [optimize_distributed_group_by_sharding_key](#optimize_distributed_group_by_sharding_key)
## distributed_replica_error_cap {#distributed_replica_error_cap} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

- Тип: неотрицательное целое число
- Значение по умолчанию: 1000

Количество ошибок каждой реплики ограничено этим значением, предотвращая накопление слишком большого количества ошибок в одной реплике.

Смотрите также:

- [load_balancing](#load_balancing-round_robin)
- [Движок таблицы Distributed](../../engines/table-engines/special/distributed.md)
- [distributed_replica_error_half_life](#distributed_replica_error_half_life)
- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)
## distributed_replica_error_half_life {#distributed_replica_error_half_life} 

<SettingsInfoBlock type="Seconds" default_value="60" />

- Тип: секунды
- Значение по умолчанию: 60 секунд

Контролирует, насколько быстро ошибки в распределенных таблицах обнуляются. Если реплика недоступна в течение некоторого времени, накапливает 5 ошибок, и `distributed_replica_error_half_life` установлен на 1 секунду, то реплика считается нормальной через 3 секунды после последней ошибки.

Смотрите также:

- [load_balancing](#load_balancing-round_robin)
- [Движок таблицы Distributed](../../engines/table-engines/special/distributed.md)
- [distributed_replica_error_cap](#distributed_replica_error_cap)
- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)
## distributed_replica_max_ignored_errors {#distributed_replica_max_ignored_errors} 

<SettingsInfoBlock type="UInt64" default_value="0" />

- Тип: неотрицательное целое число
- Значение по умолчанию: 0

Количество ошибок, которые будут проигнорированы при выборе реплик (в соответствии с алгоритмом `load_balancing`).

Смотрите также:

- [load_balancing](#load_balancing-round_robin)
- [Движок таблицы Distributed](../../engines/table-engines/special/distributed.md)
- [distributed_replica_error_cap](#distributed_replica_error_cap)
- [distributed_replica_error_half_life](#distributed_replica_error_half_life)
## do_not_merge_across_partitions_select_final {#do_not_merge_across_partitions_select_final} 

<SettingsInfoBlock type="Bool" default_value="0" />

Объединять части только в одной партиции при select final.
## empty_result_for_aggregation_by_constant_keys_on_empty_set {#empty_result_for_aggregation_by_constant_keys_on_empty_set} 

<SettingsInfoBlock type="Bool" default_value="1" />

Возвращает пустой результат при агрегировании по постоянным ключам на пустом наборе.
## empty_result_for_aggregation_by_empty_set {#empty_result_for_aggregation_by_empty_set} 

<SettingsInfoBlock type="Bool" default_value="0" />

Возвращает пустой результат при агрегировании без ключей на пустом наборе.
## enable_adaptive_memory_spill_scheduler {#enable_adaptive_memory_spill_scheduler} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "0"},{"label": "Новая настройка. Включить сброс данных в память в внешнее хранилище адаптивно."}]}]}/>

Запускает процессор для сброса данных в внешнее хранилище адаптивно. Поддерживается grace join в настоящее время.
## enable_blob_storage_log {#enable_blob_storage_log} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Записывает информацию о операциях с блоб-хранилищем в таблицу system.blob_storage_log"}]}]}/>

Записывает информацию о операциях с блоб-хранилищем в таблицу system.blob_storage_log.
## enable_deflate_qpl_codec {#enable_deflate_qpl_codec} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, кодек DEFLATE_QPL может быть использован для сжатия колонок.
## enable_early_constant_folding {#enable_early_constant_folding} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию запросов, где мы анализируем результаты функций и подзапросов и переписываем запрос, если в них есть константы.
## enable_extended_results_for_datetime_functions {#enable_extended_results_for_datetime_functions} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает возврат результатов типа:
- `Date32` с расширенным диапазоном (по сравнению с типом `Date`) для функций [toStartOfYear](../../sql-reference/functions/date-time-functions.md/#tostartofyear), [toStartOfISOYear](../../sql-reference/functions/date-time-functions.md/#tostartofisoyear), [toStartOfQuarter](../../sql-reference/functions/date-time-functions.md/#tostartofquarter), [toStartOfMonth](../../sql-reference/functions/date-time-functions.md/#tostartofmonth), [toLastDayOfMonth](../../sql-reference/functions/date-time-functions.md/#tolastdayofmonth), [toStartOfWeek](../../sql-reference/functions/date-time-functions.md/#tostartofweek), [toLastDayOfWeek](../../sql-reference/functions/date-time-functions.md/#tolastdayofweek) и [toMonday](../../sql-reference/functions/date-time-functions.md/#tomonday).
- `DateTime64` с расширенным диапазоном (по сравнению с типом `DateTime`) для функций [toStartOfDay](../../sql-reference/functions/date-time-functions.md/#tostartofday), [toStartOfHour](../../sql-reference/functions/date-time-functions.md/#tostartofhour), [toStartOfMinute](../../sql-reference/functions/date-time-functions.md/#tostartofminute), [toStartOfFiveMinutes](../../sql-reference/functions/date-time-functions.md/#tostartoffiveminutes), [toStartOfTenMinutes](../../sql-reference/functions/date-time-functions.md/#tostartoftenminutes), [toStartOfFifteenMinutes](../../sql-reference/functions/date-time-functions.md/#tostartoffifteenminutes) и [timeSlot](../../sql-reference/functions/date-time-functions.md/#timeslot).

Возможные значения:

- 0 — Функции возвращают `Date` или `DateTime` для всех типов аргументов.
- 1 — Функции возвращают `Date32` или `DateTime64` для аргументов `Date32` или `DateTime64` и `Date` или `DateTime` в противном случае.
## enable_filesystem_cache {#enable_filesystem_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кэш для удаленной файловой системы. Эта настройка не включает/не отключает кэш для дисков (это должно быть сделано через конфигурацию диска), но позволяет обойти кэш для некоторых запросов, если это необходимо.
## enable_filesystem_cache_log {#enable_filesystem_cache_log} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет записывать журнал кэширования файловой системы для каждого запроса.
## enable_filesystem_cache_on_write_operations {#enable_filesystem_cache_on_write_operations} 

<SettingsInfoBlock type="Bool" default_value="0" />

Записывать в кэш во время операций записи. Для того чтобы эта настройка работала, она также должна быть добавлена в конфигурацию диска.
## enable_filesystem_read_prefetches_log {#enable_filesystem_read_prefetches_log} 

<SettingsInfoBlock type="Bool" default_value="0" />

Записывать в журнал system.filesystem предзагрузку во время запроса. Следует использовать только для тестирования или отладки, не рекомендуется включать по умолчанию.
## enable_global_with_statement {#enable_global_with_statement} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.2"},{"label": "1"},{"label": "По умолчанию распространять WITH операторы на запросы UNION и все подзапросы"}]}]}/>

Распространять WITH операторы на запросы UNION и все подзапросы.
## enable_hdfs_pread {#enable_hdfs_pread} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "Новая настройка."}]}]}/>

Включает или отключает pread для файлов HDFS. По умолчанию используется `hdfsPread`. Если отключено, будут использоваться `hdfsRead` и `hdfsSeek` для чтения файлов hdfs.
## enable_http_compression {#enable_http_compression} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает сжатие данных в ответе на HTTP-запрос.

Для получения дополнительной информации читайте описание [HTTP интерфейса](../../interfaces/http.md).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
## enable_job_stack_trace {#enable_job_stack_trace} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Включить по умолчанию сбор стек-трейсов от планировщика задач."}]}]}/>

Выводить стек трейс создателя задачи, когда задача завершилась с исключением.
## enable_lightweight_delete {#enable_lightweight_delete} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включить легковесные мутации удаления для таблиц mergetree.
## enable_memory_bound_merging_of_aggregation_results {#enable_memory_bound_merging_of_aggregation_results} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включить стратегию слияния, ограниченную памятью, для агрегирования.
## enable_multiple_prewhere_read_steps {#enable_multiple_prewhere_read_steps} 

<SettingsInfoBlock type="Bool" default_value="1" />

Перевести больше условий из WHERE в PREWHERE и выполнять чтения с диска и фильтрацию в нескольких этапах, если есть несколько условий, объединенных с AND.
## enable_named_columns_in_function_tuple {#enable_named_columns_in_function_tuple} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Генерировать именованные кортежи в функции tuple(), когда все имена уникальны и могут рассматриваться как нецитируемые идентификаторы."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "0"},{"label": "Отключено в ожидании улучшений удобства использования"}]}]}/>

Генерировать именованные кортежи в функции tuple() когда все имена уникальны и могут рассматриваться как нецитируемые идентификаторы.
## enable_optimize_predicate_expression {#enable_optimize_predicate_expression} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "18.12.17"},{"label": "1"},{"label": "Оптимизировать предикаты в подзапросы по умолчанию"}]}]}/>

Включает продвижение предикатов в запросах `SELECT`.

Продвижение предикатов может значительно снизить сетевой трафик для распределенных запросов.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

Использование

Рассмотрим следующие запросы:

1.  `SELECT count() FROM test_table WHERE date = '2018-10-10'`
2.  `SELECT count() FROM (SELECT * FROM test_table) WHERE date = '2018-10-10'`

Если `enable_optimize_predicate_expression = 1`, то время выполнения этих запросов будет одинаковым, так как ClickHouse применяет `WHERE` к подзапросу при его обработке.

Если `enable_optimize_predicate_expression = 0`, то время выполнения второго запроса будет значительно больше, так как условие `WHERE` применяется ко всем данным после завершения подзапроса.
## enable_optimize_predicate_expression_to_final_subquery {#enable_optimize_predicate_expression_to_final_subquery} 

<SettingsInfoBlock type="Bool" default_value="1" />

Разрешить продвигать предикаты в финальный подзапрос.
## enable_order_by_all {#enable_order_by_all} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает сортировку с помощью синтаксиса `ORDER BY ALL`, см. [ORDER BY](../../sql-reference/statements/select/order-by.md).

Возможные значения:

- 0 — Отключить ORDER BY ALL.
- 1 — Включить ORDER BY ALL.

**Пример**

Запрос:

```sql
CREATE TABLE TAB(C1 Int, C2 Int, ALL Int) ENGINE=Memory();

INSERT INTO TAB VALUES (10, 20, 30), (20, 20, 10), (30, 10, 20);

SELECT * FROM TAB ORDER BY ALL; -- возвращает ошибку, что ALL неоднозначно

SELECT * FROM TAB ORDER BY ALL SETTINGS enable_order_by_all = 0;
```

Результат:

```text
┌─C1─┬─C2─┬─ALL─┐
│ 20 │ 20 │  10 │
│ 30 │ 10 │  20 │
│ 10 │ 20 │  30 │
└────┴────┴─────┘
```
## enable_parsing_to_custom_serialization {#enable_parsing_to_custom_serialization} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Если включено, данные могут быть разобраны напрямую в колонки с пользовательским сериализацией (например, Sparse) в соответствии с подсказками для сериализации, полученными из таблицы.
## enable_positional_arguments {#enable_positional_arguments} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.7"},{"label": "1"},{"label": "Включить поддержку позиционных аргументов по умолчанию"}]}]}/>

Включает или отключает поддержку позиционных аргументов для операторов [GROUP BY](/sql-reference/statements/select/group-by), [LIMIT BY](../../sql-reference/statements/select/limit-by.md), [ORDER BY](../../sql-reference/statements/select/order-by.md).

Возможные значения:

- 0 — Позиционные аргументы не поддерживаются.
- 1 — Позиционные аргументы поддерживаются: номера колонок могут использоваться вместо имен колонок.

**Пример**

Запрос:

```sql
CREATE TABLE positional_arguments(one Int, two Int, three Int) ENGINE=Memory();

INSERT INTO positional_arguments VALUES (10, 20, 30), (20, 20, 10), (30, 10, 20);

SELECT * FROM positional_arguments ORDER BY 2,3;
```

Результат:

```text
┌─one─┬─two─┬─three─┐
│  30 │  10 │   20  │
│  20 │  20 │   10  │
│  10 │  20 │   30  │
└─────┴─────┴───────┘
```
```yaml
title: 'Настройки ClickHouse'
sidebar_label: 'Настройки ClickHouse'
keywords: ['настройки', 'ClickHouse']
description: 'Описание настроек ClickHouse.'
```

## enable_reads_from_query_cache {#enable_reads_from_query_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если установлено в true, результаты запросов `SELECT` извлекаются из [кэша запросов](../query-cache.md).

Возможные значения:

- 0 - Отключено
- 1 - Включено

## enable_s3_requests_logging {#enable_s3_requests_logging} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включите явное логирование запросов S3. Имеет смысл только для отладки.

## enable_scalar_subquery_optimization {#enable_scalar_subquery_optimization} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "19.18"},{"label": "1"},{"label": "Предотвращение сериализации/десериализации больших скалярных значений в скалярных подзапросах и возможное избежание выполнения одного и того же подзапроса более одного раза"}]}]}/>

Если установлено в true, предотвращает сериализацию/десериализацию больших скалярных значений в скалярных подзапросах и возможно избегает повторного выполнения одного и того же подзапроса.

## enable_sharing_sets_for_mutations {#enable_sharing_sets_for_mutations} 

<SettingsInfoBlock type="Bool" default_value="1" />

Разрешает совместное использование объектов множества, созданных для подзапросов IN, между разными задачами одной мутации. Это снижает использование памяти и загрузку CPU.

## enable_software_prefetch_in_aggregation {#enable_software_prefetch_in_aggregation} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает использование программного предзагрузки в агрегации.

## enable_unaligned_array_join {#enable_unaligned_array_join} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает ARRAY JOIN с несколькими массивами, которые имеют разный размер. Когда эта настройка включена, массивы будут изменены на размер самого длинного.

## enable_url_encoding {#enable_url_encoding} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Изменено значение по умолчанию для существующей настройки"}]}]}/>

Разрешает включение/отключение декодирования/кодирования пути в uri в таблицах с движком [URL](../../engines/table-engines/special/url.md).

Отключено по умолчанию.

## enable_vertical_final {#enable_vertical_final} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Снова включите вертикальный FINАЛ по умолчанию после исправления ошибки"}]}, {"id": "row-2","items": [{"label": "24.1"},{"label": "1"},{"label": "Используйте вертикальный FINАЛ по умолчанию"}]}]}/>

Если включено, удаляет дублированные строки во время FINАL, помечая строки как удаленные и фильтруя их позже, вместо объединения строк.

## enable_writes_to_query_cache {#enable_writes_to_query_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если включено, результаты запросов `SELECT` сохраняются в [кэше запросов](../query-cache.md).

Возможные значения:

- 0 - Отключено
- 1 - Включено

## enable_zstd_qat_codec {#enable_zstd_qat_codec} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Добавлен новый кодек ZSTD_QAT"}]}]}/>

Если включено, кодек ZSTD_QAT может использоваться для сжатия колонок.

## enforce_strict_identifier_format {#enforce_strict_identifier_format} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Если включено, разрешаются только идентификаторы, содержащие алфавитно-цифровые символы и символы подчеркивания.

## engine_file_allow_create_multiple_files {#engine_file_allow_create_multiple_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает или запрещает создание нового файла при каждой вставке в таблицы с файловым движком, если формат имеет суффикс (`JSON`, `ORC`, `Parquet` и т. д.). Если включено, при каждой вставке будет создан новый файл с именем, соответствующим этому шаблону:

`data.Parquet` -> `data.1.Parquet` -> `data.2.Parquet` и т. д.

Возможные значения:
- 0 — запрос `INSERT` добавляет новые данные в конец файла.
- 1 — запрос `INSERT` создает новый файл.

## engine_file_empty_if_not_exists {#engine_file_empty_if_not_exists} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет выбирать данные из таблицы с файловым движком без файла.

Возможные значения:
- 0 — `SELECT` вызывает исключение.
- 1 — `SELECT` возвращает пустой результат.

## engine_file_skip_empty_files {#engine_file_skip_empty_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает или запрещает пропуск пустых файлов в таблицах с движком [File](../../engines/table-engines/special/file.md).

Возможные значения:
- 0 — `SELECT` вызывает исключение, если пустой файл несовместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.

## engine_file_truncate_on_insert {#engine_file_truncate_on_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает или запрещает усечение перед вставкой в таблицы с движком [File](../../engines/table-engines/special/file.md).

Возможные значения:
- 0 — запрос `INSERT` добавляет новые данные в конец файла.
- 1 — запрос `INSERT` заменяет существующее содержимое файла новыми данными.

## engine_url_skip_empty_files {#engine_url_skip_empty_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

Разрешает или запрещает пропуск пустых файлов в таблицах с движком [URL](../../engines/table-engines/special/url.md).

Возможные значения:
- 0 — `SELECT` вызывает исключение, если пустой файл несовместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.

## except_default_mode {#except_default_mode} 

<SettingsInfoBlock type="SetOperationMode" default_value="ALL" />

Установите режим по умолчанию в запросе EXCEPT. Возможные значения: пустая строка, 'ALL', 'DISTINCT'. Если пустая, запрос без режима вызовет исключение.

## execute_distributed_plan_locally {#execute_distributed_plan_locally} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Новая экспериментальная настройка."}]}]}/>

Запускает все задачи плана распределенного запроса локально. Полезно для тестирования и отладки.

## external_storage_connect_timeout_sec {#external_storage_connect_timeout_sec} 

<SettingsInfoBlock type="UInt64" default_value="10" />

Таймаут подключения в секундах. В настоящее время поддерживается только для MySQL.

## external_storage_max_read_bytes {#external_storage_max_read_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает максимальное количество байт, когда таблица с внешним движком должна сбрасывать исторические данные. В настоящее время поддерживается только для движка таблиц MySQL, движка базы данных и словаря. Если равно 0, эта настройка отключена.

## external_storage_max_read_rows {#external_storage_max_read_rows} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает максимальное количество строк, когда таблица с внешним движком должна сбрасывать исторические данные. В настоящее время поддерживается только для движка таблиц MySQL, движка базы данных и словаря. Если равно 0, эта настройка отключена.

## external_storage_rw_timeout_sec {#external_storage_rw_timeout_sec} 

<SettingsInfoBlock type="UInt64" default_value="300" />

Таймаут чтения/записи в секундах. В настоящее время поддерживается только для MySQL.

## external_table_functions_use_nulls {#external_table_functions_use_nulls} 

<SettingsInfoBlock type="Bool" default_value="1" />

Определяет, как функции [mysql](../../sql-reference/table-functions/mysql.md), [postgresql](../../sql-reference/table-functions/postgresql.md) и [odbc](../../sql-reference/table-functions/odbc.md) обрабатывают Nullable колонки.

Возможные значения:

- 0 — Табличная функция явно использует Nullable колонки.
- 1 — Табличная функция неявно использует Nullable колонки.

**Использование**

Если настройка установлена в `0`, табличная функция не создает Nullable колонки и вставляет значения по умолчанию вместо NULL. Это также относится к значению NULL внутри массивов.

## external_table_strict_query {#external_table_strict_query} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если установлено в true, запрещает преобразование выражений в локальные фильтры для запросов к внешним таблицам.

## extract_key_value_pairs_max_pairs_per_row {#extract_key_value_pairs_max_pairs_per_row} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "0"},{"label": "Максимальное количество пар, которые может производить функция `extractKeyValuePairs`. Используется как предохранитель для предотвращения чрезмерного потребления памяти."}]}]}/>

Максимальное количество пар, которые может производить функция `extractKeyValuePairs`. Используется как предохранитель для предотвращения чрезмерного потребления памяти.

## extremes {#extremes} 

<SettingsInfoBlock type="Bool" default_value="0" />

Указывает, следует ли подсчитывать крайние значения (минимумы и максимумы в столбцах результата запроса). Принимает 0 или 1. По умолчанию 0 (отключено). Более подробную информацию см. в разделе "Крайние значения".

## fallback_to_stale_replicas_for_distributed_queries {#fallback_to_stale_replicas_for_distributed_queries} 

<SettingsInfoBlock type="Bool" default_value="1" />

Принуждает запрос к устаревшей реплике, если обновленные данные недоступны. См. [Репликация](../../engines/table-engines/mergetree-family/replication.md).

ClickHouse выбирает наиболее подходящую из устаревших реплик таблицы.

Используется при выполнении `SELECT` из распределенной таблицы, которая указывает на реплицированные таблицы.

По умолчанию 1 (включено).

## filesystem_cache_boundary_alignment {#filesystem_cache_boundary_alignment} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Выравнивание границы кэша файловой системы. Эта настройка применяется только к чтению, не связанному с диском (например, для кэша удаленных движков таблиц / табличных функций, но не для конфигурации хранения таблиц MergeTree). Значение 0 означает, что выравнивания нет.

## filesystem_cache_enable_background_download_during_fetch {#filesystem_cache_enable_background_download_during_fetch} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Имеет эффект только в ClickHouse Cloud. Время ожидания, чтобы заблокировать кэш для резервирования пространства в кэше файловой системы.

## filesystem_cache_enable_background_download_for_metadata_files_in_packed_storage {#filesystem_cache_enable_background_download_for_metadata_files_in_packed_storage} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Имеет эффект только в ClickHouse Cloud. Время ожидания, чтобы заблокировать кэш для резервирования пространства в кэше файловой системы.

## filesystem_cache_max_download_size {#filesystem_cache_max_download_size} 

<SettingsInfoBlock type="UInt64" default_value="137438953472" />

Максимальный размер кэша удаленной файловой системы, который может быть загружен одним запросом.

## filesystem_cache_name {#filesystem_cache_name} 

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": ""},{"label": "Имя кэша файловой системы, используемое для статeless движков таблиц или озер данных"}]}]}/>

Имя кэша файловой системы, используемое для статeless движков таблиц или озер данных.

## filesystem_cache_prefer_bigger_buffer_size {#filesystem_cache_prefer_bigger_buffer_size} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Предпочитается больший размер буфера, если кэш файловой системы включен, чтобы избежать записи небольших сегментов файлов, что ухудшает производительность кэша. С другой стороны, включение этой настройки может увеличить использование памяти.

## filesystem_cache_reserve_space_wait_lock_timeout_milliseconds {#filesystem_cache_reserve_space_wait_lock_timeout_milliseconds} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1000"},{"label": "Время ожидания, чтобы заблокировать кэш для резервирования пространства в кэше файловой системы"}]}]}/>

Время ожидания, чтобы заблокировать кэш для резервирования пространства в кэше файловой системы.

## filesystem_cache_segments_batch_size {#filesystem_cache_segments_batch_size} 

<SettingsInfoBlock type="UInt64" default_value="20" />

Ограничение на размер одной партии сегментов файлов, которые буфер чтения может запросить из кэша. Слишком маленькое значение приведет к чрезмерному количеству запросов к кэшу, слишком большое может замедлить вытеснение из кэша.

## filesystem_cache_skip_download_if_exceeds_per_query_cache_write_limit {#filesystem_cache_skip_download_if_exceeds_per_query_cache_write_limit} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Переименование настройки skip_download_if_exceeds_query_cache_limit"}]}]}/>

Пропуск загрузки из удаленной файловой системы, если превышен размер кэша запросов.

## filesystem_prefetch_max_memory_usage {#filesystem_prefetch_max_memory_usage} 

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

Максимальное использование памяти для предзагрузок.

## filesystem_prefetch_step_bytes {#filesystem_prefetch_step_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Предзагрузка шага в байтах. Ноль означает `auto` — приблизительно лучший шаг предзагрузки будет автоматически выведен, но это может не быть на 100% самым лучшим. Фактическое значение может отличаться из-за настройки filesystem_prefetch_min_bytes_for_single_read_task.

## filesystem_prefetch_step_marks {#filesystem_prefetch_step_marks} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Предзагрузка шага в метках. Ноль означает `auto` — приблизительно лучший шаг предзагрузки будет автоматически выведен, но это может не быть на 100% самым лучшим. Фактическое значение может отличаться из-за настройки filesystem_prefetch_min_bytes_for_single_read_task.

## filesystem_prefetches_limit {#filesystem_prefetches_limit} 

<SettingsInfoBlock type="UInt64" default_value="200" />

Максимальное количество предзагрузок. Ноль означает неограниченное количество. Настройка `filesystem_prefetches_max_memory_usage` более рекомендуемая, если вы хотите ограничить количество предзагрузок.

## final {#final} 

<SettingsInfoBlock type="Bool" default_value="0" />

Автоматически применяет модификатор [FINAL](../../sql-reference/statements/select/from.md/#final-modifier) ко всем таблицам в запросе, к таблицам, где [FINAL](../../sql-reference/statements/select/from.md/#final-modifier) применим, включая объединенные таблицы и таблицы в подзапросах, и распределенные таблицы.

Возможные значения:

- 0 - отключено
- 1 - включено

Пример:

```sql
CREATE TABLE test
(
    key Int64,
    some String
)
ENGINE = ReplacingMergeTree
ORDER BY key;

INSERT INTO test FORMAT Values (1, 'first');
INSERT INTO test FORMAT Values (1, 'second');

SELECT * FROM test;
┌─key─┬─some───┐
│   1 │ second │
└─────┴────────┘
┌─key─┬─some──┐
│   1 │ first │
└─────┴───────┘

SELECT * FROM test SETTINGS final = 1;
┌─key─┬─some───┐
│   1 │ second │
└─────┴────────┘

SET final = 1;
SELECT * FROM test;
┌─key─┬─some───┐
│   1 │ second │
└─────┴────────┘
```

## flatten_nested {#flatten_nested} 

<SettingsInfoBlock type="Bool" default_value="1" />

Устанавливает формат данных вложенных ([nested](../../sql-reference/data-types/nested-data-structures/index.md)) колонок.

Возможные значения:

- 1 — Вложенная колонка упрощается в отдельные массивы.
- 0 — Вложенная колонка остается единым массивом кортежей.

**Использование**

Если настройка установлена в `0`, можно использовать произвольный уровень вложенности.

**Примеры**

Запрос:

```sql
SET flatten_nested = 1;
CREATE TABLE t_nest (`n` Nested(a UInt32, b UInt32)) ENGINE = MergeTree ORDER BY tuple();

SHOW CREATE TABLE t_nest;
```

Результат:

```text
┌─statement───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ CREATE TABLE default.t_nest
(
    `n.a` Array(UInt32),
    `n.b` Array(UInt32)
)
ENGINE = MergeTree
ORDER BY tuple()
SETTINGS index_granularity = 8192 │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

Запрос:

```sql
SET flatten_nested = 0;

CREATE TABLE t_nest (`n` Nested(a UInt32, b UInt32)) ENGINE = MergeTree ORDER BY tuple();

SHOW CREATE TABLE t_nest;
```

Результат:

```text
┌─statement──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ CREATE TABLE default.t_nest
(
    `n` Nested(a UInt32, b UInt32)
)
ENGINE = MergeTree
ORDER BY tuple()
SETTINGS index_granularity = 8192 │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

## force_aggregate_partitions_independently {#force_aggregate_partitions_independently} 

<SettingsInfoBlock type="Bool" default_value="0" />

Принуждает использовать оптимизацию, когда это применимо, но эвристика решила не использовать ее.

## force_aggregation_in_order {#force_aggregation_in_order} 

<SettingsInfoBlock type="Bool" default_value="0" />

Эта настройка используется самим сервером для поддержки распределенных запросов. Не изменяйте ее вручную, так как это нарушит нормальное функционирование. (Принуждает использовать агрегацию в порядке на удаленных узлах во время распределенной агрегации).

## force_data_skipping_indices {#force_data_skipping_indices} 

Отключает выполнение запросов, если переданные индексы пропуска данных не были использованы.

Рассмотрим следующий пример:

```sql
CREATE TABLE data
(
    key Int,
    d1 Int,
    d1_null Nullable(Int),
    INDEX d1_idx d1 TYPE minmax GRANULARITY 1,
    INDEX d1_null_idx assumeNotNull(d1_null) TYPE minmax GRANULARITY 1
)
Engine=MergeTree()
ORDER BY key;

SELECT * FROM data_01515;
SELECT * FROM data_01515 SETTINGS force_data_skipping_indices=''; -- запрос вызовет ошибку CANNOT_PARSE_TEXT.
SELECT * FROM data_01515 SETTINGS force_data_skipping_indices='d1_idx'; -- запрос вызовет ошибку INDEX_NOT_USED.
SELECT * FROM data_01515 WHERE d1 = 0 SETTINGS force_data_skipping_indices='d1_idx'; -- Ок.
SELECT * FROM data_01515 WHERE d1 = 0 SETTINGS force_data_skipping_indices='`d1_idx`'; -- Ок (пример полного парсера).
SELECT * FROM data_01515 WHERE d1 = 0 AND assumeNotNull(d1_null) = 0 SETTINGS force_data_skipping_indices='`d1_idx`, d1_null_idx'; -- Ок.
```

## force_exchange_kind {#force_exchange_kind} 

<ExperimentalBadge/>

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": ""},{"label": "Новая экспериментальная настройка."}]}]}/>

Принуждает указанный вид операторов обмена между этапами распределенного запроса.

Возможные значения:

 - '' - не принуждать никакой вид операторов обмена, позвольте оптимизатору выбрать,
 - 'Persisted' - использовать временные файлы в объектном хранилище,
 - 'Streaming' - потоковый обмен данными по сети.

## force_grouping_standard_compatibility {#force_grouping_standard_compatibility} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.9"},{"label": "1"},{"label": "Сделать так, чтобы функция GROUPING возвращала 1, когда аргумент не используется как ключ агрегации"}]}]}/>

Заставляет функцию GROUPING возвращать 1, если аргумент не используется в качестве ключа агрегации.

## force_index_by_date {#force_index_by_date} 

<SettingsInfoBlock type="Bool" default_value="0" />

Отключает выполнение запросов, если индекс не может быть использован по дате.

Работает с таблицами семейства MergeTree.

Если `force_index_by_date=1`, ClickHouse проверяет наличие условия по ключу даты в запросе, которое можно использовать для ограничения диапазонов данных. Если нет подходящего условия, вызывается исключение. Однако он не проверяет, сокращает ли условие объем данных для чтения. Например, условие `Date != ' 2000-01-01 '` допустимо, даже если оно совпадает со всеми данными в таблице (т.е. выполнение запроса требует полного сканирования). Более подробную информацию о диапазонах данных в таблицах MergeTree см. в [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md).

## force_optimize_projection {#force_optimize_projection} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает обязательное использование [проекций](../../engines/table-engines/mergetree-family/mergetree.md/#projections) в запросах `SELECT`, когда оптимизация проекций включена (см. настройку [optimize_use_projections](#optimize_use_projections)).

Возможные значения:

- 0 — Оптимизация проекций не является обязательной.
- 1 — Оптимизация проекций является обязательной.

## force_optimize_projection_name {#force_optimize_projection_name} 

Если установлено в непустую строку, проверить, что эта проекция используется в запросе хотя бы раз.

Возможные значения:

- строка: имя проекции, используемой в запросе.

## force_optimize_skip_unused_shards {#force_optimize_skip_unused_shards} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Включает или отключает выполнение запросов, если [optimize_skip_unused_shards](#optimize_skip_unused_shards) включен и пропуск неиспользуемых шардов невозможен. Если пропуск невозможен и настройка включена, будет вызвано исключение.

Возможные значения:

- 0 — Отключено. ClickHouse не вызывает исключение.
- 1 — Включено. Выполнение запроса отключено, только если таблица имеет ключ шардирования.
- 2 — Включено. Выполнение запроса отключено вне зависимости от того, определен ли ключ шардирования для таблицы.

## force_optimize_skip_unused_shards_nesting {#force_optimize_skip_unused_shards_nesting} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Контролирует [`force_optimize_skip_unused_shards`](#force_optimize_skip_unused_shards) (соответственно все еще требует [`force_optimize_skip_unused_shards`](#force_optimize_skip_unused_shards)) в зависимости от уровня вложенности распределенного запроса (случай, когда у вас есть `Distributed` таблица, которая смотрит на другую `Distributed` таблицу).

Возможные значения:

- 0 - Отключено, `force_optimize_skip_unused_shards` всегда работает.
- 1 — Включает `force_optimize_skip_unused_shards` только для первого уровня.
- 2 — Включает `force_optimize_skip_unused_shards` до второго уровня.

## force_primary_key {#force_primary_key} 

<SettingsInfoBlock type="Bool" default_value="0" />

Отключает выполнение запросов, если индексирование по первичному ключу невозможно.

Работает с таблицами семейства MergeTree.

Если `force_primary_key=1`, ClickHouse проверяет, имеет ли запрос условие первичного ключа, которое можно использовать для ограничения диапазонов данных. Если нет подходящего условия, вызывается исключение. Однако он не проверяет, сокращает ли условие объем данных для чтения. Более подробную информацию о диапазонах данных в таблицах MergeTree см. в [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md).

## force_remove_data_recursively_on_drop {#force_remove_data_recursively_on_drop} 

<SettingsInfoBlock type="Bool" default_value="0" />

Рекурсивно удаляет данные при выполнении запроса DROP. Избегает ошибки 'Каталог не пуст', но может тихо удалить отсоединенные данные.

## formatdatetime_e_with_space_padding {#formatdatetime_e_with_space_padding} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Улучшенная совместимость с MySQL DATE_FORMAT/STR_TO_DATE"}]}]}/>

Форматировщик '%e' в функции 'formatDateTime' печатает однозначные дни с ведущим пробелом, например ' 2' вместо '2'.

## formatdatetime_f_prints_scale_number_of_digits {#formatdatetime_f_prints_scale_number_of_digits} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Форматировщик '%f' в функции 'formatDateTime' печатает только количество знаков масштаба для DateTime64 вместо фиксированных 6 цифр.

## formatdatetime_f_prints_single_zero {#formatdatetime_f_prints_single_zero} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "0"},{"label": "Улучшенная совместимость с MySQL DATE_FORMAT()/STR_TO_DATE()"}]}]}/>

Форматировщик '%f' в функции 'formatDateTime' печатает единственный ноль вместо шести нулей, если отформатированное значение не имеет дробных секунд.

## formatdatetime_format_without_leading_zeros {#formatdatetime_format_without_leading_zeros} 

<SettingsInfoBlock type="Bool" default_value="0" />

Форматировщики '%c', '%l' и '%k' в функции 'formatDateTime' печатают месяцы и часы без ведущих нулей.

## formatdatetime_parsedatetime_m_is_month_name {#formatdatetime_parsedatetime_m_is_month_name} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "1"},{"label": "Улучшенная совместимость с MySQL DATE_FORMAT/STR_TO_DATE"}]}]}/>

Форматировщик '%M' в функциях 'formatDateTime' и 'parseDateTime' печатает/анализирует название месяца вместо минут.

## fsync_metadata {#fsync_metadata} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает [fsync](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html) при записи файлов `.sql`. Включено по умолчанию.

Имеет смысл отключить, если у сервера есть миллионы маленьких таблиц, которые постоянно создаются и удаляются.

## function_implementation {#function_implementation} 

Выберите реализацию функции для определенной цели или варианта (экспериментальный). Если пусто, включите все из них.

## function_json_value_return_type_allow_complex {#function_json_value_return_type_allow_complex} 

<SettingsInfoBlock type="Bool" default_value="0" />

Контролирует, разрешать ли возвращать сложный тип (например, структура, массив, map) для функции json_value.

```sql
SELECT JSON_VALUE('{"hello":{"world":"!"}}', '$.hello') settings function_json_value_return_type_allow_complex=true

┌─JSON_VALUE('{"hello":{"world":"!"}}', '$.hello')─┐
│ {"world":"!"}                                    │
└──────────────────────────────────────────────────┘

1 строка в наборе. Затраченное время: 0.001 сек.
```

Возможные значения:

- true — Разрешить.
- false — Запретить.

## function_json_value_return_type_allow_nullable {#function_json_value_return_type_allow_nullable} 

<SettingsInfoBlock type="Bool" default_value="0" />

Контролирует, разрешать ли возвращать `NULL`, когда значение не существует для функции JSON_VALUE.

```sql
SELECT JSON_VALUE('{"hello":"world"}', '$.b') settings function_json_value_return_type_allow_nullable=true;

┌─JSON_VALUE('{"hello":"world"}', '$.b')─┐
│ ᴺᵁᴸᴸ                                   │
└────────────────────────────────────────┘

1 строка в наборе. Затраченное время: 0.001 сек.
```

Возможные значения:

- true — Разрешить.
- false — Запретить.

## function_locate_has_mysql_compatible_argument_order {#function_locate_has_mysql_compatible_argument_order} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Увеличение совместимости с функцией locate в MySQL."}]}]}/>

Контролирует порядок аргументов в функции [locate](../../sql-reference/functions/string-search-functions.md/#locate).

Возможные значения:

- 0 — Функция `locate` принимает аргументы `(haystack, needle[, start_pos])`.
- 1 — Функция `locate` принимает аргументы `(needle, haystack[, start_pos])` (совместимое с MySQL поведение).

## function_range_max_elements_in_block {#function_range_max_elements_in_block} 

<SettingsInfoBlock type="UInt64" default_value="500000000" />

Устанавливает предельный порог для объема данных, генерируемых функцией [range](/sql-reference/functions/array-functions#rangeend-rangestart--end--step). Определяет максимальное количество значений, генерируемых функцией на блок данных (сумма размеров массивов для каждой строки в блоке).

Возможные значения:

- Положительное целое число.

**См. также**

- [max_block_size](#max_block_size)
- [min_insert_block_size_rows](#min_insert_block_size_rows)

## function_sleep_max_microseconds_per_block {#function_sleep_max_microseconds_per_block} 

<SettingsInfoBlock type="UInt64" default_value="3000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.7"},{"label": "3000000"},{"label": "В предыдущих версиях максимальное время сна в 3 секунды применялось только для `sleep`, но не для функции `sleepEachRow`. В новой версии мы вводим эту настройку. Если вы установите совместимость с предыдущими версиями, мы полностью отключим лимит."}]}]}/>

Максимальное количество микросекунд, которое функция `sleep` может спать для каждого блока. Если пользователь вызывает ее с большим значением, она вызывает исключение. Это порог безопасности.

## function_visible_width_behavior {#function_visible_width_behavior} 

<SettingsInfoBlock type="UInt64" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "1"},{"label": "Мы изменили поведение по умолчанию для `visibleWidth`, чтобы оно было более точным"}]}]}/>

Версия поведения `visibleWidth`. 0 - только считайте количество кодовых точек; 1 - правильно считайте нулевую ширину и комбинирующие символы, считайте полноширинные символы за два, оцените ширину табуляции, считайте символы удаления.

## geo_distance_returns_float64_on_float64_arguments {#geo_distance_returns_float64_on_float64_arguments} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Увеличьте точность по умолчанию."}]}]}/>

Если все четыре аргумента для функций `geoDistance`, `greatCircleDistance`, `greatCircleAngle` являются Float64, возвращайте Float64 и используйте двойную точность для внутренних вычислений. В предыдущих версиях ClickHouse эти функции всегда возвращали Float32.

```yaml
title: 'Порядок ввода lon и lat для geoToH3'
sidebar_label: 'Порядок ввода lon и lat'
keywords: ['geoToH3', 'порядок ввода']
description: 'Функция geoToH3 принимает (lon, lat), если это значение истинно, иначе (lat, lon).'
```
## geotoh3_lon_lat_input_order {#geotoh3_lon_lat_input_order} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Новая настройка для обеспечения совместимости с устаревшим поведением для установки порядка lon и lat"}]}]}/>

Функция 'geoToH3' принимает (lon, lat), если это верно, иначе (lat, lon).
```yaml
title: 'Максимальное количество допустимых адресов'
sidebar_label: 'Максимальное количество элементов в glob-расширении'
keywords: ['glob_expansion_max_elements', 'максимальное количество адресов']
description: 'Максимальное количество допустимых адресов (для внешних хранилищ, табличных функций и т.д.).'
```
## glob_expansion_max_elements {#glob_expansion_max_elements} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Максимальное количество допустимых адресов (для внешних хранилищ, табличных функций и т.д.).
```yaml
title: 'Начальное количество бакетов для grace hash join'
sidebar_label: 'Начальные бакеты для grace hash join'
keywords: ['grace_hash_join_initial_buckets', 'бакеты']
description: 'Начальное количество бакетов для grace hash join.'
```
## grace_hash_join_initial_buckets {#grace_hash_join_initial_buckets} 

<ExperimentalBadge/>

<SettingsInfoBlock type="NonZeroUInt64" default_value="1" />

Начальное количество бакетов для grace hash join.
```yaml
title: 'Максимальное количество бакетов для grace hash join'
sidebar_label: 'Максимальные бакеты для grace hash join'
keywords: ['grace_hash_join_max_buckets', 'максимальное количество бакетов']
description: 'Лимит на количество бакетов для grace hash join.'
```
## grace_hash_join_max_buckets {#grace_hash_join_max_buckets} 

<ExperimentalBadge/>

<SettingsInfoBlock type="NonZeroUInt64" default_value="1024" />

Лимит на количество бакетов для grace hash join.
```yaml
title: 'Режим переполнения для GROUP BY'
sidebar_label: 'Режим переполнения GROUP BY'
keywords: ['group_by_overflow_mode', 'переполнение']
description: 'Устанавливает, что происходит, когда количество уникальных ключей для агрегации превышает лимит.'
```
## group_by_overflow_mode {#group_by_overflow_mode} 

<SettingsInfoBlock type="OverflowModeGroupBy" default_value="throw" />

Устанавливает, что происходит, когда количество уникальных ключей для агрегации превышает лимит:
- `throw`: генерировать исключение
- `break`: остановить выполнение запроса и вернуть частичный результат
- `any`: продолжать агрегацию для ключей, которые попали в набор, но не добавлять новые ключи в набор.

Использование значения 'any' позволяет запустить приближенную версию GROUP BY. Качество
этой аппроксимации зависит от статистической природы данных.
```yaml
title: 'Порог для двухуровневой агрегации по количеству ключей'
sidebar_label: 'Порог двухуровневой агрегации по ключам'
keywords: ['group_by_two_level_threshold', 'двухуровневая агрегация']
description: 'С какого количества ключей начинается двухуровневая агрегация.'
```
## group_by_two_level_threshold {#group_by_two_level_threshold} 

<SettingsInfoBlock type="UInt64" default_value="100000" />

С какого количества ключей начинается двухуровневая агрегация. 0 - порог не установлен.
```yaml
title: 'Порог для двухуровневой агрегации по размеру в байтах'
sidebar_label: 'Порог двухуровневой агрегации по байтам'
keywords: ['group_by_two_level_threshold_bytes', 'агрегация']
description: 'С какого размера состояния агрегации в байтах начинается двухуровневая агрегация.'
```
## group_by_two_level_threshold_bytes {#group_by_two_level_threshold_bytes} 

<SettingsInfoBlock type="UInt64" default_value="50000000" />

С какого размера состояния агрегации в байтах начинается двухуровневая агрегация. 0 - порог не установлен. Двухуровневая агрегация используется, когда хотя бы один из порогов срабатывает.
```yaml
title: 'Использовать NULL в GROUP BY'
sidebar_label: 'Использование NULL в GROUP BY'
keywords: ['group_by_use_nulls', 'NULL']
description: 'Изменяет способ, которым [GROUP BY clause](/sql-reference/statements/select/group-by) обрабатывает типы агрегирующих ключей.'
```
## group_by_use_nulls {#group_by_use_nulls} 

<SettingsInfoBlock type="Bool" default_value="0" />

Изменяет способ, которым [GROUP BY clause](/sql-reference/statements/select/group-by) обрабатывает типы агрегирующих ключей.
Когда используются спецификаторы `ROLLUP`, `CUBE` или `GROUPING SETS`, некоторые ключи агрегации могут не использоваться для получения некоторых строк результата.
Столбцы для этих ключей заполняются либо значением по умолчанию, либо `NULL` в соответствующих строках в зависимости от этой настройки.

Возможные значения:

- 0 — для типа ключа агрегации используется значение по умолчанию для получения недостающих значений.
- 1 — ClickHouse выполняет `GROUP BY` так же, как это описывается в SQL стандарте. Типы ключей агрегации преобразуются в [Nullable](/sql-reference/data-types/nullable). Столбцы для соответствующих ключей агрегации заполняются [NULL](/sql-reference/syntax#null) для строк, которые его не использовали.

См. также:

- [GROUP BY clause](/sql-reference/statements/select/group-by)
```yaml
title: 'Порядок результата для h3ToGeo'
sidebar_label: 'Порядок результата h3ToGeo'
keywords: ['h3togeo_lon_lat_result_order', 'порядок результата']
description: 'Функция h3ToGeo возвращает (lon, lat), если это верно, иначе (lat, lon).'
```
## h3togeo_lon_lat_result_order {#h3togeo_lon_lat_result_order} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Функция 'h3ToGeo' возвращает (lon, lat), если это верно, иначе (lat, lon).
```yaml
title: 'Тайм-аут рукопожатия в миллисекундах'
sidebar_label: 'Тайм-аут рукопожатия'
keywords: ['handshake_timeout_ms', 'тайм-аут']
description: 'Тайм-аут в миллисекундах для получения пакета Hello от реплик во время рукопожатия.'
```
## handshake_timeout_ms {#handshake_timeout_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="10000" />

Тайм-аут в миллисекундах для получения пакета Hello от реплик во время рукопожатия.
```yaml
title: 'Создать новый файл при вставке в HDFS'
sidebar_label: 'Создание нового файла при вставке'
keywords: ['hdfs_create_new_file_on_insert', 'HDFS']
description: 'Включает или отключает создание нового файла при каждой вставке в таблицы HDFS.'
```
## hdfs_create_new_file_on_insert {#hdfs_create_new_file_on_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает создание нового файла при каждой вставке в таблицы HDFS. Если включено, при каждой вставке будет создан новый HDFS файл с именем, аналогичным следующему шаблону:

initial: `data.Parquet.gz` -> `data.1.Parquet.gz` -> `data.2.Parquet.gz` и т.д.

Возможные значения:
- 0 — запрос `INSERT` добавляет новые данные в конец файла.
- 1 — запрос `INSERT` создает новый файл.
```yaml
title: 'Игнорировать файл, если он не существует'
sidebar_label: 'Игнорировать отсутствие файла'
keywords: ['hdfs_ignore_file_doesnt_exist', 'игнорировать файл']
description: 'Игнорировать отсутствие файла, если он не существует при чтении определенных ключей.'
```
## hdfs_ignore_file_doesnt_exist {#hdfs_ignore_file_doesnt_exist} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Разрешить возвращать 0 строк, когда запрашиваемые файлы не существуют, вместо генерации исключения в HDFS таблице"}]}]}/>

Игнорировать отсутствие файла, если он не существует при чтении определенных ключей.

Возможные значения:
- 1 — `SELECT` возвращает пустой результат.
- 0 — `SELECT` генерирует исключение.
```yaml
title: 'Репликация в HDFS'
sidebar_label: 'Репликация HDFS'
keywords: ['hdfs_replication', 'репликация']
description: 'Фактическое количество репликаций можно указать при создании hdfs файла.'
```
## hdfs_replication {#hdfs_replication} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Фактическое количество репликаций можно указать при создании hdfs файла.
```yaml
title: 'Пропустить пустые файлы в HDFS'
sidebar_label: 'Пропуск пустых файлов'
keywords: ['hdfs_skip_empty_files', 'пустые файлы']
description: 'Включает или отключает пропуск пустых файлов в таблицах HDFS.'
```
## hdfs_skip_empty_files {#hdfs_skip_empty_files} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает пропуск пустых файлов в [HDFS](../../engines/table-engines/integrations/hdfs.md) таблицах.

Возможные значения:
- 0 — `SELECT` генерирует исключение, если пустой файл несовместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.
```yaml
title: 'Генерировать ошибку при совпадении нулевых файлов'
sidebar_label: 'Ошибка при нулевых файлах'
keywords: ['hdfs_throw_on_zero_files_match', 'ноль файлов']
description: 'Генерировать ошибку, если совпадает ноль файлов согласно правилам glob-расширения.'
```
## hdfs_throw_on_zero_files_match {#hdfs_throw_on_zero_files_match} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Разрешить генерацию ошибки, когда запрос ListObjects не может сопоставить файлы в HDFS вместо пустого результата запроса"}]}]}/>

Генерировать ошибку, если совпадает ноль файлов согласно правилам glob-расширения.

Возможные значения:
- 1 — `SELECT` генерирует исключение.
- 0 — `SELECT` возвращает пустой результат.
```yaml
title: 'Обрезка при вставке в HDFS'
sidebar_label: 'Обрезка при вставке'
keywords: ['hdfs_truncate_on_insert', 'обрезка']
description: 'Включает или отключает обрезку перед вставкой в таблицы hdfs.'
```
## hdfs_truncate_on_insert {#hdfs_truncate_on_insert} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает обрезку перед вставкой в таблицы hdfs. Если отключено, будет сгенерировано исключение при попытке вставить, если файл в HDFS уже существует.

Возможные значения:
- 0 — запрос `INSERT` добавляет новые данные в конец файла.
- 1 — запрос `INSERT` заменяет существующее содержимое файла новыми данными.
```yaml
title: 'Тайм-аут соединения для запроса с хеджированием в миллисекундах'
sidebar_label: 'Тайм-аут соединения при хеджировании'
keywords: ['hedged_connection_timeout_ms', 'тайм-аут']
description: 'Тайм-аут соединения для установки соединения с репликой для запросов с хеджированием.'
```
## hedged_connection_timeout_ms {#hedged_connection_timeout_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="50" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.4"},{"label": "50"},{"label": "Начать новое соединение в хеджируемых запросах через 50 мс вместо 100, чтобы соответствовать предыдущему тайм-ауту подключения"}]}]}/>

Тайм-аут соединения для установки соединения с репликой для хеджируемых запросов.
```yaml
title: 'Размер списка кандидатов для поиска HNSW'
sidebar_label: 'Кандидаты для поиска HNSW'
keywords: ['hnsw_candidate_list_size_for_search', 'HNSW']
description: 'Размер динамического списка кандидатов при поиске в индексе векторной схожести.'
```
## hnsw_candidate_list_size_for_search {#hnsw_candidate_list_size_for_search} 

<BetaBadge/>

<SettingsInfoBlock type="UInt64" default_value="256" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "256"},{"label": "Новая настройка. Ранее значение задавалось в CREATE INDEX и по умолчанию равно 64."}]}]}/>

Размер динамического списка кандидатов при поиске в индексе векторной схожести, также известным как 'ef_search'.
```yaml
title: 'Максимальный возраст HSTS'
sidebar_label: 'Максимальный возраст HSTS'
keywords: ['hsts_max_age', 'HSTS']
description: 'Срок действия для HSTS. 0 означает отключение HSTS.'
```
## hsts_max_age {#hsts_max_age} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Срок действия для HSTS. 0 означает отключение HSTS.
```yaml
title: 'Тайм-аут для HTTP соединения'
sidebar_label: 'Тайм-аут HTTP соединения'
keywords: ['http_connection_timeout', 'HTTP']
description: 'Тайм-аут HTTP соединения в секундах.'
```
## http_connection_timeout {#http_connection_timeout} 

<SettingsInfoBlock type="Seconds" default_value="1" />

Тайм-аут HTTP соединения (в секундах).

Возможные значения:

- Любое положительное целое число.
- 0 - Отключено (бесконечный тайм-аут).
```yaml
title: 'Интервал прогресса HTTP заголовков в миллисекундах'
sidebar_label: 'Интервал HTTP заголовков'
keywords: ['http_headers_progress_interval_ms', 'интервал прогресса']
description: 'Не отправлять HTTP заголовки X-ClickHouse-Progress более часто, чем на каждом указанном интервале.'
```
## http_headers_progress_interval_ms {#http_headers_progress_interval_ms} 

<SettingsInfoBlock type="UInt64" default_value="100" />

Не отправлять HTTP заголовки X-ClickHouse-Progress более часто, чем на каждом указанном интервале.
```yaml
title: 'Сделать HEAD запрос при чтении'
sidebar_label: 'HEAD запросы'
keywords: ['http_make_head_request', 'HEAD']
description: 'Настройка http_make_head_request позволяет выполнять запрос HEAD при чтении данных с HTTP для получения информации о файле для чтения.'
```
## http_make_head_request {#http_make_head_request} 

<SettingsInfoBlock type="Bool" default_value="1" />

Настройка `http_make_head_request` позволяет выполнять запрос `HEAD` при чтении данных с HTTP для получения информации о файле для чтения, такой как его размер. Поскольку это включено по умолчанию, может быть целесообразно отключить эту настройку в тех случаях, когда сервер не поддерживает запросы `HEAD`.
```yaml
title: 'Максимальный размер имени поля в HTTP заголовке'
sidebar_label: 'Размер имени поля'
keywords: ['http_max_field_name_size', 'имя поля']
description: 'Максимальная длина имени поля в HTTP заголовке.'
```
## http_max_field_name_size {#http_max_field_name_size} 

<SettingsInfoBlock type="UInt64" default_value="131072" />

Максимальная длина имени поля в HTTP заголовке.
```yaml
title: 'Максимальный размер значения поля в HTTP заголовке'
sidebar_label: 'Размер значения поля'
keywords: ['http_max_field_value_size', 'значение поля']
description: 'Максимальная длина значения поля в HTTP заголовке.'
```
## http_max_field_value_size {#http_max_field_value_size} 

<SettingsInfoBlock type="UInt64" default_value="131072" />

Максимальная длина значения поля в HTTP заголовке.
```yaml
title: 'Максимальное количество полей в HTTP заголовке'
sidebar_label: 'Количество полей'
keywords: ['http_max_fields', 'поля']
description: 'Максимальное количество полей в HTTP заголовке.'
```
## http_max_fields {#http_max_fields} 

<SettingsInfoBlock type="UInt64" default_value="1000000" />

Максимальное количество полей в HTTP заголовке.
```yaml
title: 'Максимальный размер multipart/form-data'
sidebar_label: 'Размер multipart/form-data'
keywords: ['http_max_multipart_form_data_size', 'multipart']
description: 'Лимит на размер содержимого multipart/form-data.'
```
## http_max_multipart_form_data_size {#http_max_multipart_form_data_size} 

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

Лимит на размер содержимого multipart/form-data. Эта настройка не может быть разобрана из параметров URL и должна быть установлена в пользовательском профиле. Обратите внимание, что содержимое разбирается, и внешние таблицы создаются в памяти перед началом выполнения запроса. И это единственный лимит, который влияет на этот этап (лимиты на максимальное использование памяти и максимальное время выполнения не влияют при чтении данных формы HTTP).
```yaml
title: 'Максимальный размер параметров запроса'
sidebar_label: 'Размер параметров запроса'
keywords: ['http_max_request_param_data_size', 'параметры запроса']
description: 'Лимит на размер данных запроса, используемого в качестве параметра запроса в предопределенных HTTP запросах.'
```
## http_max_request_param_data_size {#http_max_request_param_data_size} 

<SettingsInfoBlock type="UInt64" default_value="10485760" />

Лимит на размер данных запроса, используемого в качестве параметра запроса в предопределенных HTTP запросах.
```yaml
title: 'Максимальное число попыток чтения через HTTP'
sidebar_label: 'Число попыток чтения'
keywords: ['http_max_tries', 'попытки']
description: 'Максимальное количество попыток чтения через HTTP.'
```
## http_max_tries {#http_max_tries} 

<SettingsInfoBlock type="UInt64" default_value="10" />

Максимальное количество попыток чтения через HTTP.
```yaml
title: 'Максимальный размер URI в HTTP запросе'
sidebar_label: 'Размер URI'
keywords: ['http_max_uri_size', 'URI']
description: 'Устанавливает максимальную длину URI в HTTP запросе.'
```
## http_max_uri_size {#http_max_uri_size} 

<SettingsInfoBlock type="UInt64" default_value="1048576" />

Устанавливает максимальную длину URI в HTTP запросе.

Возможные значения:

- Положительное целое число.
```yaml
title: 'Отключить проверку контрольной суммы при декомпрессии'
sidebar_label: 'Проверка контрольной суммы'
keywords: ['http_native_compression_disable_checksumming_on_decompress', 'контрольная сумма']
description: 'Включает или отключает проверку контрольной суммы при декомпрессии данных POST HTTP от клиента.'
```
## http_native_compression_disable_checksumming_on_decompress {#http_native_compression_disable_checksumming_on_decompress} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает проверку контрольной суммы при декомпрессии данных POST HTTP от клиента. Используется только для родного формата сжатия ClickHouse (не используется с `gzip` или `deflate`).

Для получения дополнительной информации прочитайте [описание HTTP интерфейса](../../interfaces/http.md).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.
```yaml
title: 'Тайм-аут получения данных по HTTP'
sidebar_label: 'Тайм-аут получения'
keywords: ['http_receive_timeout', 'HTTP']
description: 'Тайм-аут получения данных по HTTP (в секундах).'
```
## http_receive_timeout {#http_receive_timeout} 

<SettingsInfoBlock type="Seconds" default_value="30" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.6"},{"label": "30"},{"label": "См. http_send_timeout."}]}]}/>

Тайм-аут получения данных по HTTP (в секундах).

Возможные значения:

- Любое положительное целое число.
- 0 - Отключено (бесконечный тайм-аут).
```yaml
title: 'Размер буфера HTTP ответа'
sidebar_label: 'Буфер HTTP ответа'
keywords: ['http_response_buffer_size', 'буфер']
description: 'Количество байт для буфера в памяти сервера перед отправкой HTTP ответа клиенту или сбросом на диск (когда http_wait_end_of_query включен).'
```
## http_response_buffer_size {#http_response_buffer_size} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Количество байт для буфера в памяти сервера перед отправкой HTTP ответа клиенту или сбросом на диск (когда http_wait_end_of_query включен).
```yaml
title: 'HTTP заголовки ответа'
sidebar_label: 'Заголовки ответа'
keywords: ['http_response_headers', 'заголовки']
description: 'Разрешает добавлять или переопределять HTTP заголовки, которые сервер вернет в ответе с успешным результатом запроса.'
```
## http_response_headers {#http_response_headers} 

<SettingsInfoBlock type="Map" default_value="{}" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": ""},{"label": "Новая настройка."}]}]}/>

Позволяет добавлять или переопределять HTTP заголовки, которые сервер вернет в ответе с успешным результатом запроса. Это влияет только на HTTP интерфейс.

Если заголовок уже установлен по умолчанию, предоставленное значение переопределит его.
Если заголовок не был установлен по умолчанию, он будет добавлен в список заголовков.
Заголовки, установленные сервером по умолчанию и не переопределенные этой настройкой, останутся.

Настройка позволяет установить заголовок на постоянное значение. В настоящее время нет способа установить заголовок на динамически вычисляемое значение.

Ни имена, ни значения не могут содержать управляющие символы ASCII.

Если вы реализуете UI приложение, которое позволяет пользователям изменять настройки, но в то же время принимает решения на основе возвращенных заголовков, рекомендуется ограничить эту настройку только для чтения.

Пример: `SET http_response_headers = '{"Content-Type": "image/png"}'`
```yaml
title: 'Начальное время ожидания для повторной попытки в миллисекундах'
sidebar_label: 'Время ожидания повторной попытки'
keywords: ['http_retry_initial_backoff_ms', 'время ожидания']
description: 'Минимальные миллисекунды для времени ожидания при повторной попытке чтения через HTTP'
```
## http_retry_initial_backoff_ms {#http_retry_initial_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="100" />

Минимальные миллисекунды для времени ожидания при повторной попытке чтения через HTTP.
```yaml
title: 'Максимальное время ожидания для повторной попытки в миллисекундах'
sidebar_label: 'Максимальное время ожидания'
keywords: ['http_retry_max_backoff_ms', 'максимальное время']
description: 'Максимальные миллисекунды для времени ожидания при повторной попытке чтения через HTTP'
```
## http_retry_max_backoff_ms {#http_retry_max_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="10000" />

Максимальные миллисекунды для времени ожидания при повторной попытке чтения через HTTP.
```yaml
title: 'Тайм-аут отправки HTTP запроса'
sidebar_label: 'Тайм-аут отправки'
keywords: ['http_send_timeout', 'HTTP']
description: 'Тайм-аут отправки HTTP запроса (в секундах).'
```
## http_send_timeout {#http_send_timeout} 

<SettingsInfoBlock type="Seconds" default_value="30" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.6"},{"label": "30"},{"label": "3 минуты кажется слишком долгим. Обратите внимание, что это тайм-аут для одного сетевого вызова записи, а не для всей операции загрузки."}]}]}/>

Тайм-аут отправки HTTP запроса (в секундах).

Возможные значения:

- Любое положительное целое число.
- 0 - Отключено (бесконечный тайм-аут).

:::note
Это применимо только к профилю по умолчанию. Требуется перезагрузка сервера, чтобы изменения вступили в силу.
:::
```yaml
title: 'Пропускать отсутствующие URL для glob'
sidebar_label: 'Пропуск отсутствующих URL'
keywords: ['http_skip_not_found_url_for_globs', 'отсутствующие URL']
description: 'Пропускать URL для glob с ошибкой HTTP_NOT_FOUND'
```
## http_skip_not_found_url_for_globs {#http_skip_not_found_url_for_globs} 

<SettingsInfoBlock type="Bool" default_value="1" />

Пропускать URL для glob с ошибкой HTTP_NOT_FOUND.
```yaml
title: 'Ожидать завершения запроса'
sidebar_label: 'Ожидание завершения'
keywords: ['http_wait_end_of_query', 'завершение']
description: 'Включить буферизацию HTTP ответа на стороне сервера.'
```
## http_wait_end_of_query {#http_wait_end_of_query} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включить буферизацию HTTP ответа на стороне сервера.
```yaml
title: 'Записать исключение в формате вывода'
sidebar_label: 'Исключение в формате вывода'
keywords: ['http_write_exception_in_output_format', 'исключение']
description: 'Записать исключение в формате вывода для получения корректного результата. Работает с форматами JSON и XML.'
```
## http_write_exception_in_output_format {#http_write_exception_in_output_format} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.9"},{"label": "1"},{"label": "Вывод корректного JSON/XML при исключении в HTTP потоковой передаче."}]}]}/>

Записать исключение в формате вывода для получения корректного результата. Работает с форматами JSON и XML.
```yaml
title: 'Уровень сжатия zlib для HTTP'
sidebar_label: 'Уровень сжатия HTTP'
keywords: ['http_zlib_compression_level', 'сжатие']
description: 'Устанавливает уровень сжатия данных в ответе на HTTP запрос, если [enable_http_compression = 1](#enable_http_compression).'
```
## http_zlib_compression_level {#http_zlib_compression_level} 

<SettingsInfoBlock type="Int64" default_value="3" />

Устанавливает уровень сжатия данных в ответе на HTTP запрос, если [enable_http_compression = 1](#enable_http_compression).

Возможные значения: Числа от 1 до 9.
```yaml
title: 'Идентификатор снимка Iceberg'
sidebar_label: 'Снимок Iceberg'
keywords: ['iceberg_snapshot_id', 'снимок']
description: 'Запрос таблицы Iceberg, используя конкретный идентификатор снимка.'
```
## iceberg_snapshot_id {#iceberg_snapshot_id} 

<SettingsInfoBlock type="Int64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Запрос таблицы Iceberg, используя конкретный идентификатор снимка.
```yaml
title: 'Временная метка Iceberg'
sidebar_label: 'Временная метка Iceberg'
keywords: ['iceberg_timestamp_ms', 'временная метка']
description: 'Запрос таблицы Iceberg, используя снимок, который был актуален в конкретный момент времени.'
```
## iceberg_timestamp_ms {#iceberg_timestamp_ms} 

<SettingsInfoBlock type="Int64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Запрос таблицы Iceberg, используя снимок, который был актуален в конкретный момент времени.
```yaml
title: 'Тайм-аут для неактивных соединений'
sidebar_label: 'Тайм-аут неактивных соединений'
keywords: ['idle_connection_timeout', 'неактивные соединения']
description: 'Тайм-аут закрытия неактивных TCP соединений после указанного количества секунд.'
```
## idle_connection_timeout {#idle_connection_timeout} 

<SettingsInfoBlock type="UInt64" default_value="3600" />

Тайм-аут закрытия неактивных TCP соединений после указанного количества секунд.

Возможные значения:

- Положительное целое число (0 - закрыть немедленно, через 0 секунд).
```yaml
title: 'Игнорировать холодные части данных'
sidebar_label: 'Игнорировать холодные части'
keywords: ['ignore_cold_parts_seconds', 'холодные части']
description: 'Имеет значение только в ClickHouse Cloud. Исключает новые части данных из SELECT запросов, пока они не будут предварительно разогреты или не станут старше указанного количества секунд.'
```
## ignore_cold_parts_seconds {#ignore_cold_parts_seconds} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Int64" default_value="0" />

Имеет значение только в ClickHouse Cloud. Исключает новые части данных из SELECT запросов, пока они не будут предварительно разогреты (см. [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch)) или не станут старше указанного количества секунд. Только для Replicated-/SharedMergeTree.
```yaml
title: 'Игнорировать индексы пропуска данных'
sidebar_label: 'Игнорировать индексы'
keywords: ['ignore_data_skipping_indices', 'игнорировать индексы']
description: 'Игнорирует индексы пропуска, указанные, если они используются в запросе.'
```
## ignore_data_skipping_indices {#ignore_data_skipping_indices} 

Игнорирует индексы пропуска, указанные, если они используются в запросе.

Рассмотрим следующий пример:

```sql
CREATE TABLE data
(
    key Int,
    x Int,
    y Int,
    INDEX x_idx x TYPE minmax GRANULARITY 1,
    INDEX y_idx y TYPE minmax GRANULARITY 1,
    INDEX xy_idx (x,y) TYPE minmax GRANULARITY 1
)
Engine=MergeTree()
ORDER BY key;

INSERT INTO data VALUES (1, 2, 3);

SELECT * FROM data;
SELECT * FROM data SETTINGS ignore_data_skipping_indices=''; -- запрос приведет к ошибке CANNOT_PARSE_TEXT.
SELECT * FROM data SETTINGS ignore_data_skipping_indices='x_idx'; -- Ок.
SELECT * FROM data SETTINGS ignore_data_skipping_indices='na_idx'; -- Ок.

SELECT * FROM data WHERE x = 1 AND y = 1 SETTINGS ignore_data_skipping_indices='xy_idx',force_data_skipping_indices='xy_idx' ; -- запрос приведет к ошибке INDEX_NOT_USED, так как xy_idx явно игнорируется.
SELECT * FROM data WHERE x = 1 AND y = 2 SETTINGS ignore_data_skipping_indices='xy_idx';
```

Запрос без игнорирования каких-либо индексов:
```sql
EXPLAIN indexes = 1 SELECT * FROM data WHERE x = 1 AND y = 2;

Expression ((Projection + Before ORDER BY))
  Filter (WHERE)
    ReadFromMergeTree (default.data)
    Indexes:
      PrimaryKey
        Condition: true
        Parts: 1/1
        Granules: 1/1
      Skip
        Name: x_idx
        Description: minmax GRANULARITY 1
        Parts: 0/1
        Granules: 0/1
      Skip
        Name: y_idx
        Description: minmax GRANULARITY 1
        Parts: 0/0
        Granules: 0/0
      Skip
        Name: xy_idx
        Description: minmax GRANULARITY 1
        Parts: 0/0
        Granules: 0/0
```

Игнорирование индекса `xy_idx`:
```sql
EXPLAIN indexes = 1 SELECT * FROM data WHERE x = 1 AND y = 2 SETTINGS ignore_data_skipping_indices='xy_idx';

Expression ((Projection + Before ORDER BY))
  Filter (WHERE)
    ReadFromMergeTree (default.data)
    Indexes:
      PrimaryKey
        Condition: true
        Parts: 1/1
        Granules: 1/1
      Skip
        Name: x_idx
        Description: minmax GRANULARITY 1
        Parts: 0/1
        Granules: 0/1
      Skip
        Name: y_idx
        Description: minmax GRANULARITY 1
        Parts: 0/0
        Granules: 0/0
```

Работает с таблицами семейства MergeTree.
```yaml
title: 'Игнорировать DROP запросы с вероятностью'
sidebar_label: 'Игнорировать DROP запросы'
keywords: ['ignore_drop_queries_probability', 'DROP запросы']
description: 'Если включено, сервер будет игнорировать все запросы DROP таблиц с заданной вероятностью (для Memory и JOIN движков это заменит DROP на TRUNCATE). Используется в тестовых целях.'
```
## ignore_drop_queries_probability {#ignore_drop_queries_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "0"},{"label": "Разрешить игнорирование DROP запросов на сервере с заданной вероятностью в тестовых целях"}]}]}/>

Если включено, сервер будет игнорировать все запросы DROP таблиц с заданной вероятностью (для Memory и JOIN движков это заменит DROP на TRUNCATE). Используется в тестовых целях.
```yaml
title: 'Игнорировать материализованные представления с удаленной целевой таблицей'
sidebar_label: 'Игнорировать материализованные представления'
keywords: ['ignore_materialized_views_with_dropped_target_table', 'материализованные представления']
description: 'Игнорировать МП с удаленной целевой таблицей во время вставки в представления.'
```
## ignore_materialized_views_with_dropped_target_table {#ignore_materialized_views_with_dropped_target_table} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Добавить новую настройку, чтобы игнорировать материализованные представления с удаленной целевой таблицей"}]}]}/>

Игнорировать МП с удаленной целевой таблицей во время вставки в представления.
```yaml
title: 'Игнорировать ON CLUSTER для запросов на управление реплицируемыми сущностями'
sidebar_label: 'Игнорировать ON CLUSTER'
keywords: ['ignore_on_cluster_for_replicated_access_entities_queries', 'реплицируемые сущности']
description: 'Игнорировать клаузы ON CLUSTER для запросов управления реплицируемыми сущностями.'
```
## ignore_on_cluster_for_replicated_access_entities_queries {#ignore_on_cluster_for_replicated_access_entities_queries} 

<SettingsInfoBlock type="Bool" default_value="0" />

Игнорировать ON CLUSTER клаузу для запросов управления реплицируемыми сущностями.
```yaml
title: 'Игнорировать ON CLUSTER для запросов на управление реплицируемыми именованными коллекциями'
sidebar_label: 'Игнорировать ON CLUSTER для именованных коллекций'
keywords: ['ignore_on_cluster_for_replicated_named_collections_queries', 'именованные коллекции']
description: 'Игнорировать ON CLUSTER клаузу для запросов управления реплицируемыми именованными коллекциями.'
```
## ignore_on_cluster_for_replicated_named_collections_queries {#ignore_on_cluster_for_replicated_named_collections_queries} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Игнорировать ON CLUSTER клаузу для запросов управления реплицируемыми именованными коллекциями."}]}]}/>

Игнорировать ON CLUSTER клаузу для запросов управления реплицируемыми именованными коллекциями.
```yaml
title: 'Игнорировать ON CLUSTER для запросов UDF'
sidebar_label: 'Игнорировать ON CLUSTER для UDF'
keywords: ['ignore_on_cluster_for_replicated_udf_queries', 'UDF']
description: 'Игнорировать ON CLUSTER клаузу для запросов управления реплицируемыми пользовательскими функциями.'
```
## ignore_on_cluster_for_replicated_udf_queries {#ignore_on_cluster_for_replicated_udf_queries} 

<SettingsInfoBlock type="Bool" default_value="0" />

Игнорировать ON CLUSTER клаузу для запросов управления реплицируемыми UDF.
```yaml
title: 'Неявный SELECT'
sidebar_label: 'Неявный SELECT'
keywords: ['implicit_select', 'неявный']
description: 'Разрешить написание простых SELECT запросов без ведущего ключевого слова SELECT.'
```
## implicit_select {#implicit_select} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Разрешить написание простых SELECT запросов без ведущего ключевого слова SELECT, что делает это простым для использования в калькуляторном стиле, например, `1 + 2` становится допустимым запросом.

В `clickhouse-local` это включено по умолчанию и может быть явно отключено.
```yaml
title: 'Неявная таблица на верхнем уровне'
sidebar_label: 'Неявная таблица'
keywords: ['implicit_table_at_top_level', 'верхний уровень']
description: 'Если не пусто, запросы без FROM на верхнем уровне будут считываться из этой таблицы вместо system.one.'
```
## implicit_table_at_top_level {#implicit_table_at_top_level} 

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": ""},{"label": "Новая настройка, используемая в clickhouse-local"}]}]}/>

Если не пусто, запросы без FROM на верхнем уровне будут считываться из этой таблицы вместо system.one.

Это используется в clickhouse-local для обработки входных данных.
Настройка может быть явно задана пользователем, но не предназначена для этого типа использования.

Подзапросы не затрагиваются этой настройкой (ни скалярные, ни FROM, ни IN подзапросы).
SELECT на верхнем уровне объединений, пересечений, исключений обрабатываются одинаково и затрагиваются этой настройкой, независимо от их группировки в скобках.
Не указано, как эта настройка влияет на представления и распределенные запросы.

Настройка принимает имя таблицы (тогда таблица разрешается из текущей базы данных) или квалифицированное имя в форме 'database.table'.
Имена базы данных и таблиц должны быть без кавычек - разрешены только простые идентификаторы.
```yaml
title: 'Неявная транзакция'
sidebar_label: 'Неявная транзакция'
keywords: ['implicit_transaction', 'транзакция']
description: 'Если включено и еще не внутри транзакции, оборачивает запрос внутри полной транзакции (begin + commit или rollback).'
```
## implicit_transaction {#implicit_transaction} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

Если включено и еще не внутри транзакции, оборачивает запрос внутри полной транзакции (begin + commit или rollback).
```yaml
title: 'Параллельный анализ формата ввода'
sidebar_label: 'Параллельный анализ'
keywords: ['input_format_parallel_parsing', 'параллельный анализ']
description: 'Включает или отключает параллельный анализ форматов данных с сохранением порядка.'
```
## input_format_parallel_parsing {#input_format_parallel_parsing} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает порядок-сохраняющий параллельный анализ форматов данных. Поддерживается только для [TSV](../../interfaces/formats.md/#tabseparated), [TSKV](../../interfaces/formats.md/#tskv), [CSV](../../interfaces/formats.md/#csv) и [JSONEachRow](../../interfaces/formats.md/#jsoneachrow) форматов.

Возможные значения:

- 1 — Включено.
- 0 — Отключено.
```yaml
title: 'Разрешить материализованные колонки в INSERT'
sidebar_label: 'Материализованные колонки в INSERT'
keywords: ['insert_allow_materialized_columns', 'материализованные колонки']
description: 'Если настройка включена, разрешает использование материализованных колонок в INSERT.'
```
## insert_allow_materialized_columns {#insert_allow_materialized_columns} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если настройка включена, разрешает использование материализованных колонок в INSERT.
```yaml
title: 'Дедупликация вставок'
sidebar_label: 'Дедупликация вставок'
keywords: ['insert_deduplicate', 'дедупликация']
description: 'Включает или отключает дедупликацию блоков INSERT (для таблиц Replicated*).'
```
## insert_deduplicate {#insert_deduplicate} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает блоковую дедупликацию для `INSERT` (для таблиц Replicated*).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

По умолчанию блоки, вставляемые в реплицируемые таблицы с помощью оператора `INSERT`, являются дедуплицированными (см. [Репликация данных](../../engines/table-engines/mergetree-family/replication.md)).
Для реплицируемых таблиц по умолчанию дедуплицируются только 100 самых последних блоков для каждой партиции (см. [replicated_deduplication_window](merge-tree-settings.md/#replicated_deduplication_window), [replicated_deduplication_window_seconds](merge-tree-settings.md/#replicated_deduplication_window_seconds)).
Для не реплицируемых таблиц см. [non_replicated_deduplication_window](merge-tree-settings.md/#non_replicated_deduplication_window).
```yaml
title: 'Токен дедупликации вставки'
sidebar_label: 'Токен дедупликации'
keywords: ['insert_deduplication_token', 'токен']
description: 'Настройка позволяет пользователю предоставить собственную семантику дедупликации в MergeTree/ReplicatedMergeTree.'
```
## insert_deduplication_token {#insert_deduplication_token} 

Настройка позволяет пользователю предоставить собственную семантику дедупликации в MergeTree/ReplicatedMergeTree.
Например, предоставив уникальное значение для настройки в каждой операции INSERT, пользователь может избежать дедупликации одинаковых вставленных данных.

Возможные значения:

- Любая строка

`insert_deduplication_token` используется для дедупликации _только_ когда не пусто.

Для реплицируемых таблиц по умолчанию дедуплицируются только 100 самых последних вставок для каждой партиции (см. [replicated_deduplication_window](merge-tree-settings.md/#replicated_deduplication_window), [replicated_deduplication_window_seconds](merge-tree-settings.md/#replicated_deduplication_window_seconds)).
Для не реплицируемых таблиц см. [non_replicated_deduplication_window](merge-tree-settings.md/#non_replicated_deduplication_window).

:::note
`insert_deduplication_token` работает на уровне партиции (так же как `insert_deduplication` контрольная сумма). У нескольких партиций может быть одинаковый `insert_deduplication_token`.
:::

Пример:

```sql
CREATE TABLE test_table
( A Int64 )
ENGINE = MergeTree
ORDER BY A
SETTINGS non_replicated_deduplication_window = 100;

INSERT INTO test_table SETTINGS insert_deduplication_token = 'test' VALUES (1);

-- следующая вставка не будет дедуплицирована, потому что insert_deduplication_token другой
INSERT INTO test_table SETTINGS insert_deduplication_token = 'test1' VALUES (1);

-- следующая вставка будет дедуплицирована, потому что insert_deduplication_token
-- такой же, как один из предыдущих
INSERT INTO test_table SETTINGS insert_deduplication_token = 'test' VALUES (2);

SELECT * FROM test_table

┌─A─┐
│ 1 │
└───┘
┌─A─┐
│ 1 │
└───┘
```
```yaml
title: 'Вероятность ошибки при вставке Keeper'
sidebar_label: 'Вероятность ошибки Keeper'
keywords: ['insert_keeper_fault_injection_probability', 'ошибка Keeper']
description: 'Приблизительная вероятность ошибки для запроса Keeper во время вставки. Допустимое значение находится в интервале [0.0f, 1.0f]'
```
## insert_keeper_fault_injection_probability {#insert_keeper_fault_injection_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

Приблизительная вероятность ошибки для запроса Keeper во время вставки. Допустимое значение находится в интервале [0.0f, 1.0f].
```yaml
title: 'Начальный сид для ошибки Keeper'
sidebar_label: 'Сид ошибок Keeper'
keywords: ['insert_keeper_fault_injection_seed', 'сид']
description: '0 - случайный сид, иначе значение настройки.'
```
## insert_keeper_fault_injection_seed {#insert_keeper_fault_injection_seed} 

<SettingsInfoBlock type="UInt64" default_value="0" />

0 - случайный сид, иначе значение настройки.
```yaml
title: 'Максимальное количество повторных попыток для Keeper'
sidebar_label: 'Повторные попытки Keeper'
keywords: ['insert_keeper_max_retries', 'повторные попытки']
description: 'Настройка устанавливает максимальное количество повторных попыток для запросов ClickHouse Keeper (или ZooKeeper) во время вставки в реплицируемый MergeTree.'
```
## insert_keeper_max_retries {#insert_keeper_max_retries} 

<SettingsInfoBlock type="UInt64" default_value="20" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.2"},{"label": "20"},{"label": "Включить повторные подключения к Keeper при вставке, улучшить надежность"}]}]}/>

Настройка устанавливает максимальное количество повторных попыток для запросов ClickHouse Keeper (или ZooKeeper) во время вставки в реплицируемый MergeTree. Учитываются только запросы Keeper, которые не удались из-за сетевой ошибки, таймаута сессии Keeper или таймаута запроса.

Возможные значения:

- Положительное целое число.
- 0 — Повторные попытки отключены.

Значение по умолчанию для Cloud: `20`.

Повторные попытки запросов Keeper выполняются после определенного таймаута. Таймаут контролируется следующими настройками: `insert_keeper_retry_initial_backoff_ms`, `insert_keeper_retry_max_backoff_ms`.
Первая повторная попытка выполняется после таймаута `insert_keeper_retry_initial_backoff_ms`. Последующие таймауты рассчитываются следующим образом:
```
timeout = min(insert_keeper_retry_max_backoff_ms, latest_timeout * 2)
```

Например, если `insert_keeper_retry_initial_backoff_ms=100`, `insert_keeper_retry_max_backoff_ms=10000` и `insert_keeper_max_retries=8`, то таймауты будут равны `100, 200, 400, 800, 1600, 3200, 6400, 10000`.

Кроме отказоустойчивости, повторные попытки нацелены на предоставление лучшего пользовательского опыта - они позволяют избежать возвращения ошибки во время выполнения INSERT, если Keeper был перезапущен, например, из-за обновления.
```yaml
title: 'Начальный тайм-аут для повторных попыток Keeper в миллисекундах'
sidebar_label: 'Тайм-аут повторной попытки Keeper'
keywords: ['insert_keeper_retry_initial_backoff_ms', 'тайм-аут']
description: 'Начальный тайм-аут (в миллисекундах) для повторной попытки запроса Keeper, который завершился неудачно во время выполнения INSERT.'
```
## insert_keeper_retry_initial_backoff_ms {#insert_keeper_retry_initial_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="100" />

Начальный тайм-аут (в миллисекундах) для повторной попытки запроса Keeper, который завершился неудачно во время выполнения INSERT.

Возможные значения:

- Положительное целое число.
- 0 — Без тайм-аута.
```yaml
title: 'Максимальный тайм-аут для повторной попытки Keeper в миллисекундах'
sidebar_label: 'Максимальный тайм-аут повторной попытки Keeper'
keywords: ['insert_keeper_retry_max_backoff_ms', 'максимальный тайм-аут']
description: 'Максимальный тайм-аут (в миллисекундах) для повторной попытки запроса Keeper, который завершился неудачно во время выполнения INSERT.'
```
## insert_keeper_retry_max_backoff_ms {#insert_keeper_retry_max_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="10000" />

Максимальный тайм-аут (в миллисекундах) для повторной попытки запроса Keeper, который завершился неудачно во время выполнения INSERT.

Возможные значения:

- Положительное целое число.
- 0 — Максимальный тайм-аут не ограничен.
```yaml
title: 'Вставка NULL как значение по умолчанию'
sidebar_label: 'NULL как значение по умолчанию'
keywords: ['insert_null_as_default', 'значение по умолчанию']
description: 'Включает или отключает вставку [значений по умолчанию](/sql-reference/statements/create/table#default_values) вместо [NULL](/sql-reference/syntax#null) в столбцы с не [nullable](/sql-reference/data-types/nullable) типами данных.'
```
## insert_null_as_default {#insert_null_as_default} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает вставку [значений по умолчанию](/sql-reference/statements/create/table#default_values) вместо [NULL](/sql-reference/syntax#null) в столбцы с не [nullable](/sql-reference/data-types/nullable) типами данных.
Если тип столбца не является nullable и эта настройка отключена, то вставка `NULL` вызывает исключение. Если тип столбца является nullable, то значения `NULL` вставляются как есть, независимо от этой настройки.

Эта настройка применима к запросам [INSERT ... SELECT](../../sql-reference/statements/insert-into.md/#inserting-the-results-of-select). Обратите внимание, что подзапросы `SELECT` могут быть объединены с помощью оператора `UNION ALL`.

Возможные значения:

- 0 — Вставка `NULL` в неналично допускающий столбец приводит к исключению.
- 1 — Вместо `NULL` вставляется значение по умолчанию для столбца.
```yaml
title: 'Кворум вставок'
sidebar_label: 'Кворум'
keywords: ['insert_quorum', 'кворум']
description: 'Включает записи с кворумом.'
```
## insert_quorum {#insert_quorum} 

<SettingsInfoBlock type="UInt64Auto" default_value="0" />

:::note
Эта настройка не применяется к SharedMergeTree, см. [Консистентность SharedMergeTree](/cloud/reference/shared-merge-tree#consistency) для получения дополнительной информации.
:::

Включает записи с кворумом.

- Если `insert_quorum < 2`, записи с кворумом отключены.
- Если `insert_quorum >= 2`, записи с кворумом включены.
- Если `insert_quorum = 'auto'`, использовать число большинства (`number_of_replicas / 2 + 1`) как количество кворума.

Записи с кворумом

`INSERT` удается только тогда, когда ClickHouse удается корректно записать данные на `insert_quorum` реплик в течение `insert_quorum_timeout`. Если по какой-либо причине количество реплик с успешными записями не достигает `insert_quorum`, запись считается неудачной, и ClickHouse удалит вставленный блок из всех реплик, где данные уже были записаны.

Когда `insert_quorum_parallel` отключен, все реплики в кворуме являются согласованными, т.е. они содержат данные от всех предыдущих `INSERT` запросов (последовательность `INSERT` линейирована). При чтении данных, записанных с использованием `insert_quorum`, и `insert_quorum_parallel` отключен, вы можете включить последовательную согласованность для `SELECT` запросов с помощью [select_sequential_consistency](#select_sequential_consistency).

ClickHouse генерирует исключение:

- Если количество доступных реплик в момент выполнения запроса меньше, чем `insert_quorum`.
- Когда `insert_quorum_parallel` отключен, и делается попытка записать данные, когда предыдущий блок еще не был вставлен в `insert_quorum` реплик. Эта ситуация может возникнуть, если пользователь пытается выполнить другой `INSERT` запрос в ту же таблицу до завершения предыдущего запроса с `insert_quorum`.

См. также:

- [insert_quorum_timeout](#insert_quorum_timeout)
- [insert_quorum_parallel](#insert_quorum_parallel)
- [select_sequential_consistency](#select_sequential_consistency)
```
```yaml
title: 'Параллельные вставки с квором'
sidebar_label: 'Параллельные вставки с квором'
keywords: ['параллельные вставки', 'кворум']
description: 'Настройки для параллельных вставок и коммутативных функций в ClickHouse.'
```

## insert_quorum_parallel {#insert_quorum_parallel} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.1"},{"label": "1"},{"label": "Используйте параллельные вставки с кворумом по умолчанию. Это значительно удобнее, чем последовательные вставки с кворумом"}]}]}/>

:::note
Эта настройка не применяется к SharedMergeTree, см. [унификация SharedMergeTree](/cloud/reference/shared-merge-tree#consistency) для получения более подробной информации.
:::

Включает или отключает параллелизм для запросов `INSERT` с кворумом. Если включено, дополнительные запросы `INSERT` могут быть отправлены, пока предыдущие запросы еще не завершились. Если отключено, дополнительные записи в ту же таблицу будут отклонены.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

См. также:

- [insert_quorum](#insert_quorum)
- [insert_quorum_timeout](#insert_quorum_timeout)
- [select_sequential_consistency](#select_sequential_consistency)

## insert_quorum_timeout {#insert_quorum_timeout} 

<SettingsInfoBlock type="Milliseconds" default_value="600000" />

Время ожидания записи кворума в миллисекундах. Если время ожидания истекло и запись еще не произошла, ClickHouse создаст исключение, и клиент должен повторить запрос, чтобы записать тот же блок в ту же или любую другую реплику.

См. также:

- [insert_quorum](#insert_quorum)
- [insert_quorum_parallel](#insert_quorum_parallel)
- [select_sequential_consistency](#select_sequential_consistency)

## insert_shard_id {#insert_shard_id} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если не `0`, указывает шард [Distributed](/engines/table-engines/special/distributed) таблицы, в который данные будут вставлены синхронно.

Если значение `insert_shard_id` неверно, сервер выбросит исключение.

Чтобы получить количество шардов на `requested_cluster`, вы можете проверить конфигурацию сервера или использовать этот запрос:

```sql
SELECT uniq(shard_num) FROM system.clusters WHERE cluster = 'requested_cluster';
```

Возможные значения:

- 0 — Отключено.
- Любое число от `1` до `shards_num` соответствующей [Distributed](/engines/table-engines/special/distributed) таблицы.

**Пример**

Запрос:

```sql
CREATE TABLE x AS system.numbers ENGINE = MergeTree ORDER BY number;
CREATE TABLE x_dist AS x ENGINE = Distributed('test_cluster_two_shards_localhost', currentDatabase(), x);
INSERT INTO x_dist SELECT * FROM numbers(5) SETTINGS insert_shard_id = 1;
SELECT * FROM x_dist ORDER BY number ASC;
```

Результат:

```text
┌─number─┐
│      0 │
│      0 │
│      1 │
│      1 │
│      2 │
│      2 │
│      3 │
│      3 │
│      4 │
│      4 │
└────────┘
```

## interactive_delay {#interactive_delay} 

<SettingsInfoBlock type="UInt64" default_value="100000" />

Интервал в микросекундах для проверки того, было ли отменено выполнение запроса, и отправка информации о прогрессе.

## intersect_default_mode {#intersect_default_mode} 

<SettingsInfoBlock type="SetOperationMode" default_value="ALL" />

Устанавливает режим по умолчанию в запросе INTERSECT. Возможные значения: пустая строка, 'ALL', 'DISTINCT'. Если пустая строка, запрос без режима вызовет исключение.

## join_algorithm {#join_algorithm} 

<SettingsInfoBlock type="JoinAlgorithm" default_value="direct,parallel_hash,hash" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "direct,parallel_hash,hash"},{"label": "'default' устарел в пользу явно заданных алгоритмов соединения, также parallel_hash теперь предпочтителен перед hash"}]}]}/>

Указывает, какой алгоритм [JOIN](../../sql-reference/statements/select/join.md) используется.

Можно указать несколько алгоритмов, и для конкретного запроса будет выбран доступный, исходя из типа/строгости и движка таблицы.

Возможные значения:

- grace_hash

 [Grace hash join](https://en.wikipedia.org/wiki/Hash_join#Grace_hash_join) используется. Grace hash предоставляет вариант алгоритма, который обеспечивает производительность сложных соединений, ограничивая при этом использование памяти.

 Первая фаза соединения grace читает правую таблицу и разбивает ее на N ведер в зависимости от хеш-значения ключевых колонок (в начале N равно `grace_hash_join_initial_buckets`). Это делается таким образом, чтобы гарантировать, что каждое ведро может обрабатываться независимо. Строки из первого ведра добавляются в хеш-таблицу в памяти, в то время как остальные сохраняются на диске. Если хеш-таблица превышает лимит памяти (например, как задано в [`max_bytes_in_join`](/operations/settings/settings#max_bytes_in_join)), количество ведер увеличивается, и назначенное ведро для каждой строки меняется. Любые строки, которые не принадлежат текущему ведру, сбрасываются и переназначаются.

 Поддерживает `INNER/LEFT/RIGHT/FULL ALL/ANY JOIN`.

- hash

 Используется [алгоритм хеш-соединения](https://en.wikipedia.org/wiki/Hash_join). Наиболее общая реализация, которая поддерживает все комбинации типа и строгости и несколько ключей соединения, которые объединяются с помощью `OR` в разделе `JOIN ON`.

 При использовании алгоритма `hash` правая часть `JOIN` загружается в оперативную память.

- parallel_hash

 Вариация `hash` соединения, которая разбивает данные на ведра и строит несколько хеш-таблиц одновременно, чтобы ускорить этот процесс.

 При использовании алгоритма `parallel_hash` правая часть `JOIN` загружается в оперативную память.

- partial_merge

 Вариация [сортировочного алгоритма слияния](https://en.wikipedia.org/wiki/Sort-merge_join), где только правая таблица полностью отсортирована.

 `RIGHT JOIN` и `FULL JOIN` поддерживаются только с `ALL` строгостью (`SEMI`, `ANTI`, `ANY` и `ASOF` не поддерживаются).

 При использовании алгоритма `partial_merge` ClickHouse сортирует данные и сбрасывает их на диск. Алгоритм `partial_merge` в ClickHouse немного отличается от классической реализации. Сначала ClickHouse сортирует правую таблицу по ключам соединения в блоках и создает минимальный-максимальный индекс для отсортированных блоков. Затем он сортирует части левой таблицы по `join key` и соединяет их с правой таблицей. Минимально-максимальный индекс также используется для пропуска ненужных блоков правой таблицы.

- direct

 Этот алгоритм можно применить, когда хранилище для правой таблицы поддерживает запросы ключ-значение.

 Алгоритм `direct` выполняет поиск в правой таблице, используя строки из левой таблицы в качестве ключей. Он поддерживается только специальным хранилищем, таким как [Dictionary](/engines/table-engines/special/dictionary) или [EmbeddedRocksDB](../../engines/table-engines/integrations/embedded-rocksdb.md) и только для `LEFT` и `INNER` JOIN.

- auto

 При установке `auto`, сначала пробуется `hash` соединение, и алгоритм переключается на лету на другой алгоритм, если нарушен лимит памяти.

- full_sorting_merge

 [Алгоритм сортировочного слияния](https://en.wikipedia.org/wiki/Sort-merge_join) с полной сортировкой объединённых таблиц перед соединением.

- prefer_partial_merge

 ClickHouse всегда пытается использовать `partial_merge` соединение, если это возможно, в противном случае используется `hash`. *Устарело*, аналогично `partial_merge,hash`.

- default (устаревший)

 Устаревшее значение, пожалуйста, больше не используйте. Аналогично `direct,hash`, т.е. старайтесь использовать прямое соединение и хеш-соединение (в этом порядке).

## join_any_take_last_row {#join_any_take_last_row} 

<SettingsInfoBlock type="Bool" default_value="0" />

Изменяет поведение операций соединения с `ANY` строгой.

:::note
Эта настройка применяется только к `JOIN` операциям с таблицами [Join](../../engines/table-engines/special/join.md) движков.
:::

Возможные значения:

- 0 — Если правая таблица имеет более одной подходящей строки, соединяется только первая найденная.
- 1 — Если правая таблица имеет более одной подходящей строки, соединяется только последняя найденная.

См. также:

- [Клаузула JOIN](/sql-reference/statements/select/join)
- [Движок таблицы Join](../../engines/table-engines/special/join.md)
- [join_default_strictness](#join_default_strictness)

## join_default_strictness {#join_default_strictness} 

<SettingsInfoBlock type="JoinStrictness" default_value="ALL" />

Устанавливает строгую по умолчанию для [JOIN клаузул](/sql-reference/statements/select/join).

Возможные значения:

- `ALL` — Если у правой таблицы несколько подходящих строк, ClickHouse создает [декартово произведение](https://en.wikipedia.org/wiki/Cartesian_product) подходящих строк. Это обычное поведение `JOIN` в стандартном SQL.
- `ANY` — Если у правой таблицы несколько подходящих строк, соединяется только первая найденная. Если у правой таблицы только одна подходящая строка, результаты `ANY` и `ALL` одинаковы.
- `ASOF` — Для соединения последовательностей с неопределённым совпадением.
- `Пустая строка` — Если `ALL` или `ANY` не указаны в запросе, ClickHouse выбрасывает исключение.

## join_on_disk_max_files_to_merge {#join_on_disk_max_files_to_merge} 

<SettingsInfoBlock type="UInt64" default_value="64" />

Ограничивает количество файлов, разрешённых для параллельной сортировки в MergeJoin операциях, когда они выполняются на диске.

Чем больше значение настройки, тем больше памяти используется и тем меньше требуется ввод-вывод диска.

Возможные значения:

- Любое положительное целое число, начиная с 2.

## join_output_by_rowlist_perkey_rows_threshold {#join_output_by_rowlist_perkey_rows_threshold} 

<SettingsInfoBlock type="UInt64" default_value="5" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "5"},{"label": "Нижний предел среднего количества строк по ключу в правой таблице, чтобы определить, следует ли выводить по списку строк в хеш-соединении."}]}]}/>

Нижний предел среднего количества строк по ключу в правой таблице, чтобы определить, следует ли выводить по списку строк в хеш-соединении.

## join_overflow_mode {#join_overflow_mode} 

<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Определяет, какое действие ClickHouse выполняет, когда одно из следующих ограничений соединения достигается:

- [max_bytes_in_join](/operations/settings/settings#max_bytes_in_join)
- [max_rows_in_join](/operations/settings/settings#max_rows_in_join)

Возможные значения:

- `THROW` — ClickHouse выбрасывает исключение и прерывает операцию.
- `BREAK` — ClickHouse прерывает операцию и не выбрасывает исключение.

Значение по умолчанию: `THROW`.

**См. также**

- [Клаузула JOIN](/sql-reference/statements/select/join)
- [Движок таблицы Join](/engines/table-engines/special/join)

## join_to_sort_maximum_table_rows {#join_to_sort_maximum_table_rows} 

<ExperimentalBadge/>

<SettingsInfoBlock type="UInt64" default_value="10000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "10000"},{"label": "Максимальное количество строк в правой таблице для определения, следует ли переставить правую таблицу по ключу в левом или внутреннем соединении"}]}]}/>

Максимальное количество строк в правой таблице для определения, следует ли переставить правую таблицу по ключу в левом или внутреннем соединении.

## join_to_sort_minimum_perkey_rows {#join_to_sort_minimum_perkey_rows} 

<ExperimentalBadge/>

<SettingsInfoBlock type="UInt64" default_value="40" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "40"},{"label": "Нижний предел среднего количества строк по ключу в правой таблице для определения, следует ли переставить правую таблицу по ключу в левом или внутреннем соединении. Эта настройка обеспечивает то, что оптимизация не применяется для разреженных ключей таблицы"}]}]}/>

Нижний предел среднего количества строк по ключу в правой таблице для определения, следует ли переставить правую таблицу по ключу в левом или внутреннем соединении. Эта настройка обеспечивает то, что оптимизация не применяется для разреженных ключей таблицы.

## join_use_nulls {#join_use_nulls} 

<SettingsInfoBlock type="Bool" default_value="0" />

Устанавливает тип поведения [JOIN](../../sql-reference/statements/select/join.md). При объединении таблиц могут появляться пустые ячейки. ClickHouse заполняет их по-разному в зависимости от этой настройки.

Возможные значения:

- 0 — Пустые ячейки заполняются значением по умолчанию соответствующего типа поля.
- 1 — `JOIN` ведет себя так же, как в стандартном SQL. Тип соответствующего поля конвертируется в [Nullable](/sql-reference/data-types/nullable), и пустые ячейки заполняются [NULL](/sql-reference/syntax).

## joined_subquery_requires_alias {#joined_subquery_requires_alias} 

<SettingsInfoBlock type="Bool" default_value="1" />

Принуждает объединенные подзапросы и табличные функции иметь псевдонимы для корректной квалификации имен.

## kafka_disable_num_consumers_limit {#kafka_disable_num_consumers_limit} 

<SettingsInfoBlock type="Bool" default_value="0" />

Отключить лимит на kafka_num_consumers, который зависит от числа доступных ядер CPU.

## kafka_max_wait_ms {#kafka_max_wait_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="5000" />

Время ожидания в миллисекундах для чтения сообщений из [Kafka](/engines/table-engines/integrations/kafka) перед повторной попыткой.

Возможные значения:

- Положительное целое число.
- 0 — Бесконечное время ожидания.

См. также:

- [Apache Kafka](https://kafka.apache.org/)

## keeper_map_strict_mode {#keeper_map_strict_mode} 

<SettingsInfoBlock type="Bool" default_value="0" />

Принуждает к дополнительным проверкам во время операций на KeeperMap. Например, выбрасывает исключение при вставке уже существующего ключа.

## keeper_max_retries {#keeper_max_retries} 

<SettingsInfoBlock type="UInt64" default_value="10" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "10"},{"label": "Максимальное количество повторных попыток для общих операций keeper"}]}]}/>

Максимальное количество повторных попыток для общих операций keeper.

## keeper_retry_initial_backoff_ms {#keeper_retry_initial_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="100" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "100"},{"label": "Начальное время ожидания для общих операций keeper"}]}]}/>

Начальное время ожидания для общих операций keeper.

## keeper_retry_max_backoff_ms {#keeper_retry_max_backoff_ms} 

<SettingsInfoBlock type="UInt64" default_value="5000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "5000"},{"label": "Максимальное время ожидания для общих операций keeper"}]}]}/>

Максимальное время ожидания для общих операций keeper.

## least_greatest_legacy_null_behavior {#least_greatest_legacy_null_behavior} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Если включено, функции 'least' и 'greatest' возвращают NULL, если один из их аргументов равен NULL.

## legacy_column_name_of_tuple_literal {#legacy_column_name_of_tuple_literal} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.7"},{"label": "0"},{"label": "Добавьте эту настройку только по причинам совместимости. Имеет смысл установить на 'true', пока выполняется поэтапное обновление кластера с версии ниже 21.7 до более высокой"}]}]}/>

Список всех имен элементов больших литералов кортежей в их именах колонок вместо хешей. Эта настройка существует только по причинам совместимости. Имеет смысл установить на 'true', пока выполняется поэтапное обновление кластера с версии ниже 21.7 до более высокой.

## lightweight_delete_mode {#lightweight_delete_mode} 

<SettingsInfoBlock type="LightweightDeleteMode" default_value="alter_update" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "alter_update"},{"label": "Новая настройка"}]}]}/>

Режим внутреннего запроса на обновление, который выполняется как часть легковесного удаления.

Возможные значения:
- `alter_update` - выполнить запрос `ALTER UPDATE`, который создаёт тяжёлую мутацию.
- `lightweight_update` - выполнить легковесное обновление, если это возможно, в противном случае выполнить `ALTER UPDATE`.
- `lightweight_update_force` - выполнить легковесное обновление, если это возможно, в противном случае выбросить исключение.

## lightweight_deletes_sync {#lightweight_deletes_sync} 

<SettingsInfoBlock type="UInt64" default_value="2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "2"},{"label": "То же, что и 'mutation_sync', но контролирует только выполнение легковесных удалений"}]}]}/>

То же, что и [`mutations_sync`](#mutations_sync), но контролирует только выполнение легковесных удалений.

Возможные значения:

- 0 - Мутации выполняются асинхронно.
- 1 - Запрос ждет завершения легковесных удалений на текущем сервере.
- 2 - Запрос ждет завершения легковесных удалений на всех репликах (если они существуют).

**См. также**

- [Синхронность запросов ALTER](../../sql-reference/statements/alter/index.md/#synchronicity-of-alter-queries)
- [Мутации](../../sql-reference/statements/alter/index.md/#mutations)

## limit {#limit} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает максимальное количество строк, которые необходимо получить из результата запроса. Это значение корректирует значение, установленное клаузулой [LIMIT](/sql-reference/statements/select/limit), так что лимит, указанный в запросе, не может превышать лимит, установленный этой настройкой.

Возможные значения:

- 0 — Количество строк не ограничено.
- Положительное целое число.

## live_view_heartbeat_interval {#live_view_heartbeat_interval} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Seconds" default_value="15" />

Интервал отправки сигнала о «живом» запросе в секундах, чтобы указать, что запрос активен.

## load_balancing {#load_balancing} 

<SettingsInfoBlock type="LoadBalancing" default_value="random" />

Указывает алгоритм выбора реплик, который используется для распределенной обработки запросов.

ClickHouse поддерживает следующие алгоритмы выбора реплик:

- [Случайный](#load_balancing-random) (по умолчанию)
- [Ближайшее имя хоста](#load_balancing-nearest_hostname)
- [Расстояние Левенштейна имени хоста](#load_balancing-hostname_levenshtein_distance)
- [По порядку](#load_balancing-in_order)
- [Первый или случайный](#load_balancing-first_or_random)
- [По кругу](#load_balancing-round_robin)

См. также:

- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)

### Случайный (по умолчанию) {#load_balancing-random}

```sql
load_balancing = random
```

Количество ошибок учитывается для каждой реплики. Запрос отправляется на реплику с наименьшим количеством ошибок, и если их несколько, на любую из них. 

Недостатки: Близость сервера не учитывается; если у реплик разные данные, вы также получите разные данные.

### Ближайшее имя хоста {#load_balancing-nearest_hostname}

```sql
load_balancing = nearest_hostname
```

Количество ошибок учитывается для каждой реплики. Каждые 5 минут количество ошибок делится на 2. Таким образом, количество ошибок подсчитывается за недавний период с экспоненциальным сглаживанием. Если существует одна реплика с минимальным количеством ошибок (т.е. ошибки произошли недавно на других репликах), запрос отправляется на неё. Если есть несколько реплик с одинаковым минимальным количеством ошибок, запрос отправляется на реплику с именем хоста, наиболее похожим на имя хоста сервера в конфигурационном файле (по количеству различных символов в идентичных позициях, до минимальной длины обоих имён хостов).

Например, example01-01-1 и example01-01-2 отличаются в одной позиции, в то время как example01-01-1 и example01-02-2 различаются в двух местах.
Этот метод может показаться примитивным, но он не требует внешних данных о топологии сети и не сравнивает IP-адреса, что было бы сложно для наших IPv6 адресов.

Таким образом, если есть эквивалентные реплики, предпочтение отдается ближайшей по имени.
Мы также можем предположить, что при отправке запроса на один и тот же сервер, при отсутствии сбоев, распределенный запрос также будет обращаться к одним и тем же серверам. Так что даже если на репликах находятся разные данные, запрос, как правило, вернет одни и те же результаты.

### Расстояние Левенштейна имени хоста {#load_balancing-hostname_levenshtein_distance}

```sql
load_balancing = hostname_levenshtein_distance
```

Точно так же, как `nearest_hostname`, но сравнивает имя хоста на основе [расстояния Левенштейна](https://en.wikipedia.org/wiki/Levenshtein_distance). Например:

```text
example-clickhouse-0-0 ample-clickhouse-0-0
1

example-clickhouse-0-0 example-clickhouse-1-10
2

example-clickhouse-0-0 example-clickhouse-12-0
3
```

### По порядку {#load_balancing-in_order}

```sql
load_balancing = in_order
```

Реплики с одинаковым количеством ошибок используется в том порядке, в котором они указаны в конфигурации.
Этот метод подходит, когда точно известно, какая реплика предпочтительнее.

### Первый или случайный {#load_balancing-first_or_random}

```sql
load_balancing = first_or_random
```

Этот алгоритм выбирает первую реплику в наборе или случайную реплику, если первая недоступна. Он эффективен в конфигурациях с перекрестной репликацией, но бесполезен в других конфигурациях.

Алгоритм `first_or_random` решает проблему алгоритма `in_order`. С `in_order` при отказе одной реплики следующая получает двойную нагрузку, в то время как остальные реплики обрабатывают обычное количество трафика. При использовании алгоритма `first_or_random` нагрузка равномерно распределяется между остающимися доступными репликами.

Можно явно определить, какая реплика будет первой, с помощью настройки `load_balancing_first_offset`. Это обеспечивает больший контроль за балансировкой нагрузки от запросов между репликами.

### По кругу {#load_balancing-round_robin}

```sql
load_balancing = round_robin
```

Этот алгоритм использует политику круговой балансировки между репликами с одинаковым количеством ошибок (учитываются только запросы с политикой `round_robin`).

## load_balancing_first_offset {#load_balancing_first_offset} 

<SettingsInfoBlock type="UInt64" default_value="0" />

На какую реплику предпочтительно отправить запрос, когда используется стратегия балансировки нагрузки FIRST_OR_RANDOM.

## load_marks_asynchronously {#load_marks_asynchronously} 

<SettingsInfoBlock type="Bool" default_value="0" />

Асинхронно загружать метки MergeTree.

## local_filesystem_read_method {#local_filesystem_read_method} 

<SettingsInfoBlock type="String" default_value="pread_threadpool" />

Метод чтения данных с локальной файловой системы, один из: read, pread, mmap, io_uring, pread_threadpool.

Метод 'io_uring' является экспериментальным и не работает для Log, TinyLog, StripeLog, File, Set и Join, а также других таблиц с добавляемыми файлами при наличии конкурентных операций чтения и записи.
Если вы читаете различные статьи о 'io_uring' в Интернете, не поддавайтесь на их обман. Это не лучший метод чтения файлов, за исключением случая большого количества мелких запросов ввода-вывода, чего нет в ClickHouse. Нет причин включать 'io_uring'.

## local_filesystem_read_prefetch {#local_filesystem_read_prefetch} 

<SettingsInfoBlock type="Bool" default_value="0" />

Следует ли использовать предварительную выборку при чтении данных с локальной файловой системы.

## lock_acquire_timeout {#lock_acquire_timeout} 

<SettingsInfoBlock type="Seconds" default_value="120" />

Определяет, сколько секунд запрос на блокировку ждет перед тем, как завершиться неудачей.

Время ожидания блокировки используется для защиты от взаимных блокировок при выполнении операций чтения/записи с таблицами. Когда время ожидания истекает и запрос на блокировку завершается неудачей, сервер ClickHouse выбрасывает исключение "Попытка блокировки превышена! Возможная взаимная блокировка предотвращена. Клиент должен повторить попытку." с кодом ошибки `DEADLOCK_AVOIDED`.

Возможные значения:

- Положительное целое число (в секундах).
- 0 — Нет времени ожидания блокировки.

## log_comment {#log_comment} 

Указывает значение для поля `log_comment` таблицы [system.query_log](../system-tables/query_log.md) и текст комментария для журнала сервера.

Это может быть использовано для улучшения читаемости журналов сервера. Кроме того, это помогает выбрать запросы, относящиеся к тесту, из `system.query_log` после выполнения [clickhouse-test](../../development/tests.md).

Возможные значения:

- Произвольная строка длиной не более [max_query_size](#max_query_size). Если слишком превышен max_query_size, сервер выбрасывает исключение.

**Пример**

Запрос:

```sql
SET log_comment = 'log_comment test', log_queries = 1;
SELECT 1;
SYSTEM FLUSH LOGS;
SELECT type, query FROM system.query_log WHERE log_comment = 'log_comment test' AND event_date >= yesterday() ORDER BY event_time DESC LIMIT 2;
```

Результат:

```text
┌─type────────┬─query─────┐
│ QueryStart  │ SELECT 1; │
│ QueryFinish │ SELECT 1; │
└─────────────┴───────────┘
```

## log_formatted_queries {#log_formatted_queries} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет записывать отформатированные запросы в системную таблицу [system.query_log](../../operations/system-tables/query_log.md) (заполняет колонку `formatted_query` в [system.query_log](../../operations/system-tables/query_log.md)).

Возможные значения:

- 0 — Отформатированные запросы не записываются в системную таблицу.
- 1 — Отформатированные запросы записываются в системную таблицу.

## log_processors_profiles {#log_processors_profiles} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Включено по умолчанию"}]}]}/>

Записывать время, которое процессор провел во время выполнения/ожидания данных в таблицу `system.processors_profile_log`.

См. также:

- [`system.processors_profile_log`](../../operations/system-tables/processors_profile_log.md)
- [`EXPLAIN PIPELINE`](../../sql-reference/statements/explain.md/#explain-pipeline)

## log_profile_events {#log_profile_events} 

<SettingsInfoBlock type="Bool" default_value="1" />

Записывать статистику производительности запросов в `query_log`, `query_thread_log` и `query_views_log`.

## log_queries {#log_queries} 

<SettingsInfoBlock type="Bool" default_value="1" />

Настройка ведения журнала запросов.

Запросы, отправленные в ClickHouse с этой настройкой, записываются в соответствии с правилами конфигурационного параметра сервера [query_log](../../operations/server-configuration-parameters/settings.md/#query_log).

Пример:

```text
log_queries=1
```

## log_queries_cut_to_length {#log_queries_cut_to_length} 

<SettingsInfoBlock type="UInt64" default_value="100000" />

Если длина запроса превышает заданный предел (в байтах), то обрезать запрос при записи в журнaл запросов. Также ограничить длину напечатанного запроса в обычном текстовом журнале.

## log_queries_min_query_duration_ms {#log_queries_min_query_duration_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="0" />

Если включено (не нулевое), запросы быстрее, чем значение этой настройки, не будут записываться в журнал (вы можете подумать об этом как о `long_query_time` для [журнала медленных запросов MySQL](https://dev.mysql.com/doc/refman/5.7/slow-query-log.html)), и это, в основном, означает, что вы не найдете их в следующих таблицах:

- `system.query_log`
- `system.query_thread_log`

Только запросы следующего типа попадут в журнал:

- `QUERY_FINISH`
- `EXCEPTION_WHILE_PROCESSING`

- Тип: миллисекунды
- Значение по умолчанию: 0 (любой запрос)

## log_queries_min_type {#log_queries_min_type} 

<SettingsInfoBlock type="LogQueriesType" default_value="QUERY_START" />

Минимальный тип для записи в `query_log`.

Возможные значения:
- `QUERY_START` (`=1`)
- `QUERY_FINISH` (`=2`)
- `EXCEPTION_BEFORE_START` (`=3`)
- `EXCEPTION_WHILE_PROCESSING` (`=4`)

Можно использовать для ограничения того, какие сущности будут попадать в `query_log`, например, если вас интересуют только ошибки, тогда можно использовать `EXCEPTION_WHILE_PROCESSING`:

```text
log_queries_min_type='EXCEPTION_WHILE_PROCESSING'
```

## log_queries_probability {#log_queries_probability} 

<SettingsInfoBlock type="Float" default_value="1" />

Позволяет пользователю записывать в системы таблицы [query_log](../../operations/system-tables/query_log.md), [query_thread_log](../../operations/system-tables/query_thread_log.md) и [query_views_log](../../operations/system-tables/query_views_log.md) только выборку запросов, выбранных случайным образом, с заданной вероятностью. Это помогает уменьшить нагрузку при большом объеме запросов за секунду.

Возможные значения:

- 0 — Запросы не записываются в системные таблицы.
- Положительное число с плавающей точкой в диапазоне [0..1]. Например, если значение настройки равно `0.5`, примерно половина запросов будет записываться в системные таблицы.
- 1 — Все запросы записываются в системные таблицы.

## log_query_settings {#log_query_settings} 

<SettingsInfoBlock type="Bool" default_value="1" />

Записывать настройки запросов в `query_log` и журнал спана OpenTelemetry.

## log_query_threads {#log_query_threads} 

<SettingsInfoBlock type="Bool" default_value="0" />

Настройка ведения журнала потоков запросов.

Потоки запросов записываются в таблицу [system.query_thread_log](../../operations/system-tables/query_thread_log.md). Эта настройка действует только тогда, когда [log_queries](#log_queries) истинно. Потоки запросов, выполняемые ClickHouse с этой настройкой, записываются в соответствии с правилами конфигурационного параметра сервера [query_thread_log](/operations/server-configuration-parameters/settings#query_thread_log).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

**Пример**

```text
log_query_threads=1
```

## log_query_views {#log_query_views} 

<SettingsInfoBlock type="Bool" default_value="1" />

Настройка ведения журнала представлений запросов.

Когда запрос, выполняемый ClickHouse с этой настройкой, имеет связанные представления (материализованные или live-представления), они записываются в конфигурационный параметр сервера [query_views_log](/operations/server-configuration-parameters/settings#query_views_log).

Пример:

```text
log_query_views=1
```

## low_cardinality_allow_in_native_format {#low_cardinality_allow_in_native_format} 

<SettingsInfoBlock type="Bool" default_value="1" />

Разрешает или ограничивает использование типа данных [LowCardinality](../../sql-reference/data-types/lowcardinality.md) с форматом [Native](../../interfaces/formats.md/#native).

Если использование `LowCardinality` ограничено, сервер ClickHouse конвертирует колонки типа `LowCardinality` в обычные для запросов `SELECT`, и конвертирует обычные колонки в колонки типа `LowCardinality` для запросов `INSERT`.

Эта настройка необходима в основном для сторонних клиентов, которые не поддерживают тип данных `LowCardinality`.

Возможные значения:

- 1 — Использование `LowCardinality` не ограничено.
- 0 — Использование `LowCardinality` ограничено.

```yaml
title: 'Параметры конфигурации ClickHouse'
sidebar_label: 'Параметры настройки'
keywords: ['ClickHouse', 'параметры настройки', 'конфигурация']
description: 'Настройки конфигурации ClickHouse для управления производительностью и поведением базы данных.'
```

## low_cardinality_max_dictionary_size {#low_cardinality_max_dictionary_size} 

<SettingsInfoBlock type="UInt64" default_value="8192" />

Устанавливает максимальный размер в строках разделяемого глобального словаря для типа данных [LowCardinality](../../sql-reference/data-types/lowcardinality.md), который может быть записан в файловую систему хранения. Эта настройка предотвращает проблемы с оперативной памятью в случае неограниченного роста словаря. Все данные, которые не могут быть закодированы из-за ограничения максимального размера словаря, ClickHouse записывает обычным способом.

Возможные значения:

- Любое положительное целое число.
## low_cardinality_use_single_dictionary_for_part {#low_cardinality_use_single_dictionary_for_part} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает использование единого словаря для части данных.

По умолчанию сервер ClickHouse отслеживает размер словарей, и если словарь переполняется, сервер начинает записывать следующий. Чтобы запретить создание нескольких словарей, установите `low_cardinality_use_single_dictionary_for_part = 1`.

Возможные значения:

- 1 — Запрещает создание нескольких словарей для части данных.
- 0 — Создание нескольких словарей для части данных не запрещено.
## low_priority_query_wait_time_ms {#low_priority_query_wait_time_ms} 

<BetaBadge/>

<SettingsInfoBlock type="Milliseconds" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1000"},{"label": "Новая настройка."}]}]}/>

Когда механизм приоритизации запросов используется (см. настройку `priority`), запросы с низким приоритетом ждут завершения более приоритетных запросов. Эта настройка указывает продолжительность ожидания.
## make_distributed_plan {#make_distributed_plan} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Новая экспериментальная настройка."}]}]}/>

Создаёт распределённый план запроса.
## materialize_skip_indexes_on_insert {#materialize_skip_indexes_on_insert} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Добавлена новая настройка для отключения материализации индексов пропуска при вставке"}]}]}/>

Если INSERT создаёт и сохраняет индексы пропуска. Если отключено, индексы пропуска будут созданы и сохранены во время слияний или явного MATERIALIZE INDEX.
## materialize_statistics_on_insert {#materialize_statistics_on_insert} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Добавлена новая настройка для отключения материализации статистики при вставке"}]}]}/>

Если INSERT создаёт и вставляет статистику. Если отключено, статистика будет построена и сохранена во время слияний или явного MATERIALIZE STATISTICS.
## materialize_ttl_after_modify {#materialize_ttl_after_modify} 

<SettingsInfoBlock type="Bool" default_value="1" />

Применяет TTL для старых данных после запроса ALTER MODIFY TTL.
## materialized_views_ignore_errors {#materialized_views_ignore_errors} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет игнорировать ошибки для MATERIALIZED VIEW и передавать оригинальный блок в таблицу независимо от MVs.
## max_analyze_depth {#max_analyze_depth} 

<SettingsInfoBlock type="UInt64" default_value="5000" />

Максимальное количество анализов, выполняемых интерпретатором.
## max_ast_depth {#max_ast_depth} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Максимальная глубина вложенности синтаксического дерева запроса. При превышении выбрасывается исключение.

:::note
На данный момент это не проверяется во время парсинга, а только после парсинга запроса.
Это означает, что слишком глубокое синтаксическое дерево может быть создано во время парсинга,
но запрос завершится с ошибкой.
:::
## max_ast_elements {#max_ast_elements} 

<SettingsInfoBlock type="UInt64" default_value="50000" />

Максимальное количество элементов в синтаксическом дереве запроса. При превышении выбрасывается исключение.

:::note
На данный момент это не проверяется во время парсинга, а только после парсинга запроса.
Это означает, что слишком глубокое синтаксическое дерево может быть создано во время парсинга,
но запрос завершится с ошибкой.
:::
## max_autoincrement_series {#max_autoincrement_series} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1000"},{"label": "Новая настройка"}]}]}/>

Ограничение на количество серий, создаваемых функцией `generateSeriesID`.

Поскольку каждая серия представляет собой узел в Keeper, рекомендуется не иметь более нескольких миллионов из них.
## max_backup_bandwidth {#max_backup_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость чтения в байтах в секунду для конкретной резервной копии на сервере. Ноль означает неограниченное.
## max_block_size {#max_block_size} 

<SettingsInfoBlock type="NonZeroUInt64" default_value="65409" />

В ClickHouse данные обрабатываются блоками, которые представляют собой наборы частей колонок. Внутренние циклы обработки для одного блока эффективны, но затраты при обработке каждого блока заметны.

Настройка `max_block_size` указывает рекомендуемое максимальное количество строк, которое следует включить в один блок при загрузке данных из таблиц. Блоки размером `max_block_size` не всегда загружаются из таблицы: если ClickHouse определяет, что нужно извлечь меньше данных, обрабатывается меньший блок.

Размер блока не должен быть слишком маленьким, чтобы избежать заметных затрат при обработке каждого блока. Он также не должен быть слишком большим, чтобы обеспечить быструю реализацию запросов с LIMIT после обработки первого блока. При установке `max_block_size` цель должна заключаться в том, чтобы избежать чрезмерного потребления памяти при извлечении большого количества колонок в нескольких потоках и сохранить хотя бы некоторую локальность кэша.
## max_bytes_before_external_group_by {#max_bytes_before_external_group_by} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Облачное значение по умолчанию: половина объема памяти на реплику.

Включает или отключает выполнение операторов `GROUP BY` в внешней памяти.
(См. [GROUP BY в внешней памяти](/sql-reference/statements/select/group-by#group-by-in-external-memory))

Возможные значения:

- Максимальный объем ОЗУ (в байтах), который может быть использован для одной операции [GROUP BY](/sql-reference/statements/select/group-by).
- `0` — `GROUP BY` в внешней памяти отключен.

:::note
Если использование памяти во время операций GROUP BY превышает этот порог в байтах,
активируйте режим 'внешней агрегации' (spill data to disk).

Рекомендуемое значение — половина доступной системной памяти.
:::
## max_bytes_before_external_sort {#max_bytes_before_external_sort} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Облачное значение по умолчанию: половина объема памяти на реплику.

Включает или отключает выполнение операторов `ORDER BY` в внешней памяти. См. [Подробности реализации ORDER BY](../../sql-reference/statements/select/order-by.md#implementation-details).
Если использование памяти во время операции ORDER BY превышает этот порог в байтах, активируется режим 'внешней сортировки' (spill data to disk).

Возможные значения:

- Максимальный объем ОЗУ (в байтах), который может быть использован для одной операции [ORDER BY](../../sql-reference/statements/select/order-by).
  Рекомендуемое значение — половина доступной системной памяти.
- `0` — `ORDER BY` в внешней памяти отключен.
## max_bytes_before_remerge_sort {#max_bytes_before_remerge_sort} 

<SettingsInfoBlock type="UInt64" default_value="1000000000" />

В случае ORDER BY с LIMIT, когда использование памяти выше указанного порога, выполняются дополнительные шаги слияния блоков перед финальным слиянием, чтобы сохранить только верхние строки LIMIT.
## max_bytes_in_distinct {#max_bytes_in_distinct} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт состояния (в распакованных байтах) в памяти, которое используется хеш-таблицей при использовании DISTINCT.
## max_bytes_in_join {#max_bytes_in_join} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный размер в байтах хеш-таблицы, используемой при соединении таблиц.

Эта настройка применяется к операциям [SELECT ... JOIN](/sql-reference/statements/select/join) и [Join table engine](/engines/table-engines/special/join).

Если запрос содержит соединения, ClickHouse проверяет эту настройку для каждого промежуточного результата.

ClickHouse может предпринять различные действия, когда предел достигается. Используйте настройки [join_overflow_mode](/operations/settings/settings#join_overflow_mode), чтобы выбрать действие.

Возможные значения:

- Положительное целое число.
- 0 — Контроль памяти отключен.
## max_bytes_in_set {#max_bytes_in_set} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт (незапакованных данных), используемое множеством в операторе IN, созданным из подзапроса.
## max_bytes_ratio_before_external_group_by {#max_bytes_ratio_before_external_group_by} 

<SettingsInfoBlock type="Double" default_value="0.5" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0.5"},{"label": "Включает автоматическое сбрасывание на диск по умолчанию."}]}, {"id": "row-2","items": [{"label": "24.12"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Соотношение доступной памяти, разрешенное для `GROUP BY`. После достижения этого порога
используется внешняя память для агрегации.

Например, если установлено значение `0.6`, `GROUP BY` разрешит использовать 60% доступной памяти
(для сервера/пользователя/слияний) в начале выполнения, после чего начнётся внешняя агрегация.
## max_bytes_ratio_before_external_sort {#max_bytes_ratio_before_external_sort} 

<SettingsInfoBlock type="Double" default_value="0.5" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0.5"},{"label": "Включает автоматическое сбрасывание на диск по умолчанию."}]}, {"id": "row-2","items": [{"label": "24.12"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Соотношение доступной памяти, разрешенное для `ORDER BY`. После достижения этого порога
используется внешняя сортировка.

Например, если установлено значение `0.6`, `ORDER BY` разрешит использовать `60%` доступной памяти
(для сервера/пользователя/слияний) в начале выполнения, после чего начнётся внешняя сортировка.
## max_bytes_to_read {#max_bytes_to_read} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт (незапакованных данных), которые могут быть прочитаны из таблицы при выполнении запроса.
Ограничение проверяется для каждого обработанного блока данных, применяется только к
самому глубокому выражению таблицы и при чтении с удаленного сервера, проверяется только на
удалённом сервере.
## max_bytes_to_read_leaf {#max_bytes_to_read_leaf} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт (незапакованных данных), которые могут быть прочитаны из локальной
таблицы на узле-листе при выполнении распределённого запроса. В то время как распределенные запросы
могут выдавать несколько подзапросов каждому шард (листьев) - этот лимит будет
проверяться только на этапе чтения на узлах-листах и будет игнорироваться на
этапе слияния результатов на корневом узле.

Например, если кластер состоит из 2 шардов, и каждый шард содержит таблицу с
100 байт данных. Распределённый запрос, который предполагает читать все данные
из обеих таблиц с настройкой `max_bytes_to_read=150`, потерпит неудачу, так как в общем это
будет 200 байт. Запрос с `max_bytes_to_read_leaf=150` будет успешным, так как
узлы-листья прочитают максимум 100 байт.

Ограничение проверяется для каждого обработанного блока данных.

:::note
Эта настройка нестабильна с `prefer_localhost_replica=1`.
:::
## max_bytes_to_sort {#max_bytes_to_sort} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт перед сортировкой. Если необходимо обработать больше указанного
количества незапакованных байтов для операции ORDER BY, поведение будет
определяться параметром `sort_overflow_mode`, который по умолчанию установлен в `throw`.
## max_bytes_to_transfer {#max_bytes_to_transfer} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество байт (незапакованных данных), которые могут быть переданы удалённому
серверу или сохранены во временной таблице, когда выполняется секция GLOBAL IN/JOIN.
## max_columns_to_read {#max_columns_to_read} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество колонок, которые могут быть прочитаны из таблицы в одном запросе.
Если запрос требует чтения большего количества колонок, выбрасывается исключение.

:::tip
Эта настройка полезна для предотвращения слишком сложных запросов.
:::

Значение `0` означает неограниченное количество.
## max_compress_block_size {#max_compress_block_size} 

<SettingsInfoBlock type="UInt64" default_value="1048576" />

Максимальный размер блоков незапакованных данных перед сжатием для записи в таблицу. По умолчанию — 1,048,576 (1 МБ). Указание меньшего размера блока обычно приводит к слегка снижению коэффициента сжатия, скорость сжатия и распаковки немного увеличивается из-за локальности кэша, а потребление памяти уменьшается.

:::note
Это настройка уровня эксперта, и вам не следует её изменять, если вы только начинаете работать с ClickHouse.
:::

Не путайте блоки для сжатия (кучу памяти, состоящую из байтов) с блоками для обработки запросов (набор строк из таблицы).
## max_concurrent_queries_for_all_users {#max_concurrent_queries_for_all_users} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Бросает исключение, если значение этой настройки меньше или равно текущему количеству одновременно обрабатываемых запросов.

Пример: `max_concurrent_queries_for_all_users` можно установить на 99 для всех пользователей, а администратор базы данных может установить его на 100 для себя, чтобы выполнять запросы для расследования даже когда сервер перегружен.

Изменение настройки для одного запроса или пользователя не затрагивает другие запросы.

Возможные значения:

- Положительное целое число.
- 0 — Без ограничений.

**Пример**

```xml
<max_concurrent_queries_for_all_users>99</max_concurrent_queries_for_all_users>
```

**См. Также**

- [max_concurrent_queries](/operations/server-configuration-parameters/settings#max_concurrent_queries)
## max_concurrent_queries_for_user {#max_concurrent_queries_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество одновременно обрабатываемых запросов на пользователя.

Возможные значения:

- Положительное целое число.
- 0 — Без ограничений.

**Пример**

```xml
<max_concurrent_queries_for_user>5</max_concurrent_queries_for_user>
```
## max_distributed_connections {#max_distributed_connections} 

<SettingsInfoBlock type="UInt64" default_value="1024" />

Максимальное количество одновременных соединений с удаленными серверами для распределенной обработки одного запроса к одной распределенной таблице. Рекомендуется устанавливать значение не меньше числа серверов в кластере.

Следующие параметры используются только при создании распределенных таблиц (и при запуске сервера), поэтому нет необходимости изменять их во время выполнения.
## max_distributed_depth {#max_distributed_depth} 

<SettingsInfoBlock type="UInt64" default_value="5" />

Ограничивает максимальную глубину рекурсивных запросов для таблиц [Distributed](../../engines/table-engines/special/distributed.md).

Если значение превышено, сервер выбрасывает исключение.

Возможные значения:

- Положительное целое число.
- 0 — Неограниченная глубина.
## max_download_buffer_size {#max_download_buffer_size} 

<SettingsInfoBlock type="UInt64" default_value="10485760" />

Максимальный размер буфера для параллельной загрузки (например, для URL engine) на каждый поток.
## max_download_threads {#max_download_threads} 

<SettingsInfoBlock type="MaxThreads" default_value="4" />

Максимальное количество потоков для загрузки данных (например, для URL engine).
## max_estimated_execution_time {#max_estimated_execution_time} 

<SettingsInfoBlock type="Seconds" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Разделены max_execution_time и max_estimated_execution_time"}]}]}/>

Максимальное предполагаемое время выполнения запроса в секундах. Проверяется для каждого блока данных, когда истекает [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed).
## max_execution_speed {#max_execution_speed} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество выполняемых строк в секунду. Проверяется для каждого блока данных, когда
[`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)
истекает. Если скорость выполнения высокая, скорость выполнения будет снижена.
## max_execution_speed_bytes {#max_execution_speed_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество выполняемых байтов в секунду. Проверяется для каждого блока данных, когда
[`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)
истекает. Если скорость выполнения высокая, скорость выполнения будет снижена.
## max_execution_time {#max_execution_time} 

<SettingsInfoBlock type="Seconds" default_value="0" />

Максимальное время выполнения запроса в секундах.

Параметр `max_execution_time` может быть немного сложным для понимания.
Он работает на основе интерполяции относительно текущей скорости выполнения запроса
(это поведение контролируется [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)).

ClickHouse прерывает запрос, если предполагаемое время выполнения превышает
указанное `max_execution_time`. По умолчанию `timeout_before_checking_execution_speed`
установлен в 10 секунд. Это означает, что после 10 секунд выполнения запроса ClickHouse
начнёт оценивать общее время выполнения. Если, например, `max_execution_time`
установлен на 3600 секунд (1 час), ClickHouse завершит запрос, если предполагаемое
время превысит этот лимит в 3600 секунд. Если вы установите `timeout_before_checking_execution_speed`
в 0, ClickHouse будет использовать реальное время как основу для `max_execution_time`.

Если время выполнения запроса превышает указанное количество секунд, поведение будет
определяться режимом 'timeout_overflow_mode', который по умолчанию установлен в `throw`.

:::note
Тайм-аут проверяется, и запрос может остановиться только в обозначенных местах во время обработки данных.
В настоящее время он не может остановиться во время слияния состояний агрегации или во время анализа запроса,
и фактическое время выполнения будет выше значения этой настройки.
:::
## max_execution_time_leaf {#max_execution_time_leaf} 

<SettingsInfoBlock type="Seconds" default_value="0" />

Семантически аналогично [`max_execution_time`](#max_execution_time), но применяется только
на узлах-листах для распределённых или удалённых запросов.

Например, если мы хотим ограничить время выполнения на узле-листе до `10s`, но
не хотим ограничений на начальном узле, вместо того чтобы иметь `max_execution_time` в
настройках вложенного подзапроса:

```sql
SELECT count()
FROM cluster(cluster, view(SELECT * FROM t SETTINGS max_execution_time = 10));
```

Мы можем использовать `max_execution_time_leaf` как настройки запроса:

```sql
SELECT count()
FROM cluster(cluster, view(SELECT * FROM t)) SETTINGS max_execution_time_leaf = 10;
```
## max_expanded_ast_elements {#max_expanded_ast_elements} 

<SettingsInfoBlock type="UInt64" default_value="500000" />

Максимальный размер синтаксического дерева запроса в количестве узлов после расширения алиасов и звёздочки.
## max_fetch_partition_retries_count {#max_fetch_partition_retries_count} 

<SettingsInfoBlock type="UInt64" default_value="5" />

Количество попыток при извлечении партиции с другого хоста.
## max_final_threads {#max_final_threads} 

<SettingsInfoBlock type="MaxThreads" default_value="'auto(N)'" />

Устанавливает максимальное количество параллельных потоков для фазы чтения данных запроса `SELECT` с модификатором [FINAL](/sql-reference/statements/select/from#final-modifier).

Возможные значения:

- Положительное целое число.
- 0 или 1 — Отключено. Запросы `SELECT` выполняются в одном потоке.
## max_http_get_redirects {#max_http_get_redirects} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество разрешённых пересылок HTTP GET. Обеспечивает дополнительные меры безопасности, предотвращающие возможность перенаправления вашего запроса на неожиданные сервисы зловредным сервером.

Это происходит, когда внешний сервер перенаправляет на другой адрес, но этот адрес походит на внутренний адрес инфраструктуры компании, и, послав HTTP-запрос к внутреннему серверу, вы можете запросить внутренний API из внутренней сети, минуя аутентификацию, или даже запросить другие сервисы, такие как Redis или Memcached. Когда у вас нет внутренней инфраструктуры (включая что-то, работащее на вашем локальном хосте) или вы доверяете серверу, безопасно позволить пересылки. Хотя имейте в виду, что если URL использует HTTP вместо HTTPS, вам придется доверять не только удалённому серверу, но и вашему интернет-провайдеру и каждой сети посередине.
## max_hyperscan_regexp_length {#max_hyperscan_regexp_length} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Определяет максимальную длину каждого регулярного выражения в [гиперсканирующих функциях множественного совпадения](/sql-reference/functions/string-search-functions#multimatchany).

Возможные значения:

- Положительное целое число.
- 0 - Длина не ограничена.

**Пример**

Запрос:

```sql
SELECT multiMatchAny('abcd', ['ab','bcd','c','d']) SETTINGS max_hyperscan_regexp_length = 3;
```

Результат:

```text
┌─multiMatchAny('abcd', ['ab', 'bcd', 'c', 'd'])─┐
│                                              1 │
└────────────────────────────────────────────────┘
```

Запрос:

```sql
SELECT multiMatchAny('abcd', ['ab','bcd','c','d']) SETTINGS max_hyperscan_regexp_length = 2;
```

Результат:

```text
Exception: Длина регулярного выражения слишком велика.
```

**См. Также**

- [max_hyperscan_regexp_total_length](#max_hyperscan_regexp_total_length)
## max_hyperscan_regexp_total_length {#max_hyperscan_regexp_total_length} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает максимальную общую длину всех регулярных выражений в каждой [гиперсканирующей функции множественного совпадения](/sql-reference/functions/string-search-functions#multimatchany).

Возможные значения:

- Положительное целое число.
- 0 - Длина не ограничена.

**Пример**

Запрос:

```sql
SELECT multiMatchAny('abcd', ['a','b','c','d']) SETTINGS max_hyperscan_regexp_total_length = 5;
```

Результат:

```text
┌─multiMatchAny('abcd', ['a', 'b', 'c', 'd'])─┐
│                                           1 │
└─────────────────────────────────────────────┘
```

Запрос:

```sql
SELECT multiMatchAny('abcd', ['ab','bc','c','d']) SETTINGS max_hyperscan_regexp_total_length = 5;
```

Результат:

```text
Exception: Общая длина регулярных выражений слишком велика.
```

**См. Также**

- [max_hyperscan_regexp_length](#max_hyperscan_regexp_length)
## max_insert_block_size {#max_insert_block_size} 

<SettingsInfoBlock type="UInt64" default_value="1048449" />

Размер блоков (в количестве строк), формируемых для вставки в таблицу.
Эта настройка применяется только в случаях, когда сервер формирует блоки.
Например, для INSERT через HTTP интерфейс сервер разбирает формат данных и формирует блоки указанного размера.
Но при использовании clickhouse-client клиент разбирает данные самостоятельно, и настройка 'max_insert_block_size' на сервере не влияет на размер вставляемых блоков.
Эта настройка также не имеет назначения при использовании INSERT SELECT, так как данные вставляются с использованием тех же блоков, которые формируются после SELECT.

По умолчанию немного больше, чем `max_block_size`. Причина в том, что определённые движки таблиц (`*MergeTree`) формируют часть данных на диске для каждого вставленного блока, что является довольно крупной сущностью. Аналогично, таблицы `*MergeTree` сортируют данные во время вставки, и достаточно большой размер блока позволяет сортировать больше данных в ОЗУ.
## max_insert_delayed_streams_for_parallel_write {#max_insert_delayed_streams_for_parallel_write} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество потоков (колонок) для задержки окончательной выгрузки части. По умолчанию - авто (100 в случае, если основной хранилище поддерживает параллельную запись, например S3 и отключено в противном случае).
## max_insert_threads {#max_insert_threads} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество потоков для выполнения запроса `INSERT SELECT`.

Возможные значения:

- 0 (или 1) — `INSERT SELECT` без параллельного выполнения.
- Положительное целое число. Больше 1.

Облачное значение по умолчанию: от `2` до `4`, в зависимости от размера сервиса.

Параллельный `INSERT SELECT` имеет эффект только если часть `SELECT` выполняется параллельно, см. настройку [max_threads](#max_threads). Более высокие значения приведут к большему использованию памяти.
## max_joined_block_size_rows {#max_joined_block_size_rows} 

<SettingsInfoBlock type="UInt64" default_value="65409" />

Максимальный размер блока для результата JOIN (если алгоритм соединения поддерживает это). 0 означает неограниченное.
## max_limit_for_vector_search_queries {#max_limit_for_vector_search_queries} 

<BetaBadge/>

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1000"},{"label": "Новая настройка"}]}]}/>

Запросы SELECT с LIMIT, превышающим эту настройку, не могут использовать векторные индексы схожести. Это помогает предотвращать переполнение памяти в векторных индексах схожести.
## max_live_view_insert_blocks_before_refresh {#max_live_view_insert_blocks_before_refresh} 

<ExperimentalBadge/>

<SettingsInfoBlock type="UInt64" default_value="64" />

Ограничивает максимальное количество вставленных блоков, после чего сливаемые блоки удаляются и запрос повторно выполняется.
## max_local_read_bandwidth {#max_local_read_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость локальных чтений в байтах в секунду.
## max_local_write_bandwidth {#max_local_write_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость локальных записей в байтах в секунду.
## max_memory_usage {#max_memory_usage} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Облачное значение по умолчанию: зависит от объема ОЗУ на реплике.

Максимальное количество RAM, которое можно использовать для выполнения запроса на одном сервере.
Значение `0` означает неограниченное.

Эта настройка не учитывает объем доступной памяти или общий объем
памяти на машине. Ограничение применяется к одному запросу в пределах
одного сервера.

Вы можете использовать `SHOW PROCESSLIST`, чтобы увидеть текущее потребление памяти для каждого запроса.
Пиковое потребление памяти отслеживается для каждого запроса и записывается в лог.

Использование памяти полностью не отслеживается для состояний следующих агрегатных функций
с аргументами `String` и `Array`:
- `min`
- `max`
- `any`
- `anyLast`
- `argMin`
- `argMax`

Потребление памяти также ограничено параметрами [`max_memory_usage_for_user`](/operations/settings/settings#max_memory_usage_for_user)
и [`max_server_memory_usage`](/operations/server-configuration-parameters/settings#max_server_memory_usage).
## max_memory_usage_for_user {#max_memory_usage_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество RAM, которое можно использовать для выполнения запросов пользователя на одном сервере. Ноль означает неограниченное.

По умолчанию объем не ограничен (`max_memory_usage_for_user = 0`).

Также смотрите описание [`max_memory_usage`](/operations/settings/settings#max_memory_usage).

Например, если вы хотите установить `max_memory_usage_for_user` на 1000 байт для пользователя с именем `clickhouse_read`, вы можете использовать команду

```sql
ALTER USER clickhouse_read SETTINGS max_memory_usage_for_user = 1000;
```

Вы можете проверить, что это сработало, выйдя из своей клиентской сессии, войдя снова, а затем используя функцию `getSetting`:

```sql
SELECT getSetting('max_memory_usage_for_user');
```
## max_network_bandwidth {#max_network_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает скорость обмена данными по сети в байтах в секунду. Эта настройка применяется к каждому запросу.

Возможные значения:

- Положительное целое число.
- 0 — Контроль пропускной способности отключен.
## max_network_bandwidth_for_all_users {#max_network_bandwidth_for_all_users} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает скорость обмена данными по сети в байтах в секунду. Эта настройка применяется ко всем одновременно выполняемым запросам на сервере.

Возможные значения:

- Положительное целое число.
- 0 — Контроль скорости обмена отключен.
## max_network_bandwidth_for_user {#max_network_bandwidth_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает скорость обмена данными по сети в байтах в секунду. Эта настройка применяется ко всем одновременно выполняемым запросам, выполняемым одним пользователем.

Возможные значения:

- Положительное целое число.
- 0 — Контроль скорости обмена отключен.
## max_network_bytes {#max_network_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает объем данных (в байтах), который принимается или передается по сети при выполнении запроса. Эта настройка применяется к каждому отдельному запросу.

Возможные значения:

- Положительное целое число.
- 0 — Контроль объема данных отключен.
## max_number_of_partitions_for_independent_aggregation {#max_number_of_partitions_for_independent_aggregation} 

<SettingsInfoBlock type="UInt64" default_value="128" />

Максимальное количество партиций в таблице для применения оптимизации.
## max_os_cpu_wait_time_ratio_to_throw {#max_os_cpu_wait_time_ratio_to_throw} 

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Значения настройки были изменены и возвращены в 25.4"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Максимальное соотношение между временем ожидания CPU ОС (метрика OSCPUWaitMicroseconds) и занятым временем (метрика OSCPUVirtualTimeMicroseconds), чтобы рассмотреть возможность отклонения запросов. Линейная интерполяция между минимальным и максимальным соотношением используется для вычисления вероятности, при этом вероятность равна 1 в этой точке.

```yaml
title: 'max_parallel_replicas'
sidebar_label: 'max_parallel_replicas'
keywords: ['max_parallel_replicas', 'параллельные реплики', 'настройки']
description: 'Максимальное количество параллельных реплик для каждого шарда при выполнении запроса.'
```

## max_parallel_replicas {#max_parallel_replicas} 

<SettingsInfoBlock type="NonZeroUInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1000"},{"label": "Используйте до 1000 параллельных реплик по умолчанию."}]}]} />

Максимальное количество реплик для каждого шарда при выполнении запроса.

Допустимые значения:

- Положительное целое число.

**Дополнительная информация**

Эта опция будет давать разные результаты в зависимости от использованных настроек.

:::note
Эта настройка будет приводить к некорректным результатам, если участвуют соединения или подзапросы, и не все таблицы соответствуют определённым требованиям. См. [Распределенные подзапросы и max_parallel_replicas](/operations/settings/settings#max_parallel_replicas) для получения дополнительных сведений.
:::

### Параллельная обработка с использованием `SAMPLE` ключа

Запрос может обрабатываться быстрее, если он выполняется на нескольких серверах параллельно. Однако производительность запроса может ухудшиться в следующих случаях:

- Позиция ключа выборки в ключе партиционирования не позволяет эффективно сканировать диапазоны.
- Добавление ключа выборки в таблицу делает фильтрацию по другим колонкам менее эффективной.
- Ключ выборки является выражением, вычисление которого требует значительных затрат.
- Распределение латентности кластера имеет длинный хвост, из-за чего выполнение запроса на большем количестве серверов увеличивает общую латентность запроса.

### Параллельная обработка с использованием [parallel_replicas_custom_key](#parallel_replicas_custom_key)

Эта настройка полезна для любых реплицируемых таблиц.

## max_parser_backtracks {#max_parser_backtracks} 

<SettingsInfoBlock type="UInt64" default_value="1000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1000000"},{"label": "Ограничение сложности разбора"}]}]} />

Максимальное количество обратных переходов парсера (сколько раз он пробует различные альтернативы в процессе рекурсивного спуска).

## max_parser_depth {#max_parser_depth} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Ограничивает максимальную глубину рекурсии в парсере рекурсивного спуска. Позволяет контролировать размер стека.

Допустимые значения:

- Положительное целое число.
- 0 — Глубина рекурсии не ограничена.

## max_parsing_threads {#max_parsing_threads} 

<SettingsInfoBlock type="MaxThreads" default_value="'auto(N)'" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "0"},{"label": "Добавить отдельную настройку для управления числом потоков в параллельном разборе из файлов"}]}]} />

Максимальное количество потоков для разбора данных в форматах ввода, которые поддерживают параллельный разбор. По умолчанию оно определяется автоматически.

## max_partition_size_to_drop {#max_partition_size_to_drop} 

<SettingsInfoBlock type="UInt64" default_value="50000000000" />

Ограничение на удаление партиций во время выполнения запроса. Значение 0 означает, что вы можете удалять партиции без каких-либо ограничений.

Облачное значение по умолчанию: 1 ТБ.

:::note
Эта настройка запроса перекрывает её эквивалент серверной настройки, см. [max_partition_size_to_drop](/operations/server-configuration-parameters/settings#max_partition_size_to_drop)
:::

## max_partitions_per_insert_block {#max_partitions_per_insert_block} 

<SettingsInfoBlock type="UInt64" default_value="100" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "19.5"},{"label": "100"},{"label": "Добавить лимит для количества партиций в одном блоке"}]}]} />

Ограничивает максимальное количество партиций в одном вставляемом блоке и выбрасывает исключение, если блок содержит слишком много партиций.

- Положительное целое число.
- `0` — Неограниченное количество партиций.

**Подробности**

При вставке данных ClickHouse вычисляет количество партиций в вставляемом блоке. Если количество партиций превышает
`max_partitions_per_insert_block`, ClickHouse либо записывает предупреждение, либо выбрасывает исключение в зависимости от `throw_on_max_partitions_per_insert_block`. Исключения имеют следующий текст:

> "Слишком много партиций для одного INSERT блока (`partitions_count` партиций, лимит " + toString(max_partitions) + ").
  Лимит контролируется настройкой 'max_partitions_per_insert_block'.
  Большое количество партиций — это распространенное недоразумение. Это приведет к значительному
  негативному влиянию на производительность, включая медленное время запуска сервера, медленные запросы INSERT
  и медленные запросы SELECT. Рекомендуемое общее количество партиций для таблицы — это
  менее 1000..10000. Обратите внимание, что партиционирование не предназначено для ускорения
  запросов SELECT (ORDER BY ключа достаточно, чтобы сделать диапазонные запросы быстрыми).
  Партиции предназначены для манипуляций с данными (DROP PARTITION и т. д.)."

:::note
Эта настройка является предохранительным порогом, так как использование большого количества партиций является распространенным недоразумением.
:::

## max_partitions_to_read {#max_partitions_to_read} 

<SettingsInfoBlock type="Int64" default_value="-1" />

Ограничивает максимальное количество партиций, которые могут быть доступны в одном запросе.

Значение настройки, указанное при создании таблицы, может быть переопределено через настройку уровня запроса.

Допустимые значения:

- Положительное целое число
- `-1` - неограниченное (по умолчанию)

:::note
Вы также можете указать настройку MergeTree [`max_partitions_to_read`](/operations/settings/settings#max_partitions_to_read) в настройках таблиц.
:::

## max_parts_to_move {#max_parts_to_move} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "1000"},{"label": "Новая настройка"}]}]} />

Ограничивает количество частей, которые могут быть перемещены в одном запросе. Ноль означает неограниченное количество.

## max_query_size {#max_query_size} 

<SettingsInfoBlock type="UInt64" default_value="262144" />

Максимальное количество байт в строке запроса, которое может быть обработано парсером SQL.
Данные в операторе VALUES запросов INSERT обрабатываются отдельным парсером потоков (который использует O(1) ОЗУ) и не подвержены этому ограничению.

:::note
`max_query_size` не может быть установлен в рамках SQL-запроса (например, `SELECT now() SETTINGS max_query_size=10000`), потому что ClickHouse необходимо выделить буфер для разбора запроса, и размер этого буфера определяется настройкой `max_query_size`, которая должна быть настроена до выполнения запроса.
:::

## max_read_buffer_size {#max_read_buffer_size} 

<SettingsInfoBlock type="NonZeroUInt64" default_value="1048576" />

Максимальный размер буфера для чтения из файловой системы.

## max_read_buffer_size_local_fs {#max_read_buffer_size_local_fs} 

<SettingsInfoBlock type="UInt64" default_value="131072" />

Максимальный размер буфера для чтения из локальной файловой системы. Если установить 0, то будет использоваться max_read_buffer_size.

## max_read_buffer_size_remote_fs {#max_read_buffer_size_remote_fs} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный размер буфера для чтения из удалённой файловой системы. Если установить 0, то будет использоваться max_read_buffer_size.

## max_recursive_cte_evaluation_depth {#max_recursive_cte_evaluation_depth} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "1000"},{"label": "Максимальный лимит на глубину оценки рекурсивных CTE"}]}]} />

Максимальный лимит на глубину оценки рекурсивных CTE.

## max_remote_read_network_bandwidth {#max_remote_read_network_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость обмена данными по сети в байтах в секунду для чтения.

## max_remote_write_network_bandwidth {#max_remote_write_network_bandwidth} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальная скорость обмена данными по сети в байтах в секунду для записи.

## max_replica_delay_for_distributed_queries {#max_replica_delay_for_distributed_queries} 

<SettingsInfoBlock type="UInt64" default_value="300" />

Отключает отстающие реплики для распределенных запросов. См. [Репликация](../../engines/table-engines/mergetree-family/replication.md).

Устанавливает время в секундах. Если задержка реплики больше или равна заданному значению, эта реплика не используется.

Допустимые значения:

- Положительное целое число.
- 0 — Задержки реплик не проверяются.

Чтобы предотвратить использование любой реплики с ненулевой задержкой, установите этот параметр в 1.

Используется при выполнении `SELECT` из распределенной таблицы, указывающей на реплицируемые таблицы.

## max_result_bytes {#max_result_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает размер результата в байтах (несжатый). Запрос остановится после обработки блока данных, если порог будет достигнут,
но он не обрежет последний блок результата, поэтому размер результата может быть больше порога.

**Замечания**

Размер результата в памяти учитывается для этого порога.
Даже если размер результата мал, он может ссылаться на более крупные структуры данных в памяти,
представляющие словари колонок LowCardinality и Arenas колонок AggregateFunction,
поэтому порог может быть превышен, несмотря на малый размер результата.

:::warning
Настройка является достаточно низким уровнем и должна использоваться с осторожностью.
:::

## max_result_rows {#max_result_rows} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Облачное значение по умолчанию: `0`.

Ограничивает количество строк в результате. Также проверяется для подзапросов и на удаленных серверах при выполнении частей распределённого запроса.
Нет лимита, когда значение равно `0`.

Запрос остановится после обработки блока данных, если порог будет достигнут, но
он не обрежет последний блок результата, поэтому размер результата может быть больше порога.

## max_rows_in_distinct {#max_rows_in_distinct} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество различных строк при использовании DISTINCT.

## max_rows_in_join {#max_rows_in_join} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает количество строк в хеш-таблице, используемой при соединении таблиц.

Эта настройка применяется к операциям [SELECT ... JOIN](/sql-reference/statements/select/join)
и движку таблиц [Join](/engines/table-engines/special/join).

Если запрос содержит несколько соединений, ClickHouse проверяет эту настройку для каждого промежуточного результата.

ClickHouse может проводить различные действия, когда лимит достигнут. Используйте
[`join_overflow_mode`](/operations/settings/settings#join_overflow_mode) настройку, чтобы выбрать действие.

Допустимые значения:

- Положительное целое число.
- `0` — Неограниченное количество строк.

## max_rows_in_set {#max_rows_in_set} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк для набора данных в операторе IN, созданном из подзапроса.

## max_rows_in_set_to_optimize_join {#max_rows_in_set_to_optimize_join} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Отключение оптимизации соединения, так как это мешает оптимизации чтения в порядке"}]}]} />

Максимальный размер набора для фильтрации соединённых таблиц по наборам строк друг друга перед соединением.

Допустимые значения:

- 0 — Отключено.
- Любое положительное целое число.

## max_rows_to_group_by {#max_rows_to_group_by} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество уникальных ключей, полученных из агрегации. Эта настройка позволяет
ограничить потребление памяти при агрегации.

Если агрегация во время GROUP BY генерирует более указанного количества
строк (уникальных ключей GROUP BY), поведение будет определено
настройкой 'group_by_overflow_mode', которая по умолчанию равна `throw`, но также может быть переключена
в режим приблизительной агрегации GROUP BY.

## max_rows_to_read {#max_rows_to_read} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк, которые могут быть прочитаны из таблицы при выполнении запроса.
Ограничение проверяется для каждого обработанного фрагмента данных, применяется только к
глубочайшему выражению таблицы и при чтении с удалённого сервера проверяется только на
удалённом сервере.

## max_rows_to_read_leaf {#max_rows_to_read_leaf} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк, которые могут быть прочитаны из локальной таблицы на узле-листе при
выполнении распределенного запроса. Хотя распределённые запросы могут выдавать несколько подзапросов
каждому шард (листьев) — этот лимит будет проверяться только на стадии чтения на
листовых узлах и игнорироваться на стадии объединения результатов на корневом узле.

Например, кластер состоит из 2 шардов, и каждый шард содержит таблицу с
100 строками. Распределённый запрос, который предполагает чтение всех данных из обоих
таблиц с настройкой `max_rows_to_read=150`, потерпит неудачу, так как в общей сложности будет
200 строк. Запрос с `max_rows_to_read_leaf=150` будет успешным, так как листовые узлы
подустят максимум 100 строк.

Ограничение проверяется для каждого обработанного фрагмента данных.

:::note
Эта настройка нестабильна с `prefer_localhost_replica=1`.
:::

## max_rows_to_sort {#max_rows_to_sort} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество строк перед сортировкой. Это позволяет ограничить потребление памяти во время сортировки.
Если необходимо обработать больше указанного количества записей для операции ORDER BY,
поведение будет определено настройкой `sort_overflow_mode`, которая по умолчанию установлена на `throw`.

## max_rows_to_transfer {#max_rows_to_transfer} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный размер (в строках), который может быть передан на удалённый сервер или сохранён в
временной таблице, когда выполняется секция GLOBAL IN/JOIN.
## max_sessions_for_user {#max_sessions_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество одновременных сессий для каждого аутентифицированного пользователя на сервере ClickHouse.

Пример:

```xml
<profiles>
    <single_session_profile>
        <max_sessions_for_user>1</max_sessions_for_user>
    </single_session_profile>
    <two_sessions_profile>
        <max_sessions_for_user>2</max_sessions_for_user>
    </two_sessions_profile>
    <unlimited_sessions_profile>
        <max_sessions_for_user>0</max_sessions_for_user>
    </unlimited_sessions_profile>
</profiles>
<users>
    <!-- Пользователь Алиса может подключиться к серверу ClickHouse не более одного раза одновременно. -->
    <Alice>
        <profile>single_session_user</profile>
    </Alice>
    <!-- Пользователь Боб может использовать 2 одновременные сессии. -->
    <Bob>
        <profile>two_sessions_profile</profile>
    </Bob>
    <!-- Пользователь Чарльз может использовать произвольное количество одновременных сессий. -->
    <Charles>
        <profile>unlimited_sessions_profile</profile>
    </Charles>
</users>
```

Допустимые значения:
- Положительное целое число
- `0` - бесконечное количество одновременных сессий (по умолчанию)

## max_size_to_preallocate_for_aggregation {#max_size_to_preallocate_for_aggregation} 

<SettingsInfoBlock type="UInt64" default_value="1000000000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "1000000000000"},{"label": "Включить оптимизацию для больших таблиц."}]}, {"id": "row-2","items": [{"label": "22.12"},{"label": "100000000"},{"label": "Это оптимизирует производительность"}]}]} />

На сколько элементов разрешено предварительно выделить место во всех хеш-таблицах в общей сложности перед агрегацией.

## max_size_to_preallocate_for_joins {#max_size_to_preallocate_for_joins} 

<SettingsInfoBlock type="UInt64" default_value="1000000000000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "100000000"},{"label": "Новая настройка."}]}, {"id": "row-2","items": [{"label": "24.12"},{"label": "1000000000000"},{"label": "Включить оптимизацию для больших таблиц."}]}]} />

На сколько элементов разрешено предварительно выделить место во всех хеш-таблицах в общей сложности перед соединением.

## max_streams_for_merge_tree_reading {#max_streams_for_merge_tree_reading} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если не равен нулю, ограничьте количество потоков чтения для таблицы MergeTree.

## max_streams_multiplier_for_merge_tables {#max_streams_multiplier_for_merge_tables} 

<SettingsInfoBlock type="Float" default_value="5" />

Запрашивать больше потоков при чтении из таблицы Merge. Потоки будут распределены по таблицам, которые таблица Merge будет использовать. Это позволяет более равномерно распределить работу по потокам и особенно полезно, когда объединяемые таблицы различаются по размеру.

## max_streams_to_max_threads_ratio {#max_streams_to_max_threads_ratio} 

<SettingsInfoBlock type="Float" default_value="1" />

Позволяет использовать больше источников, чем число потоков, чтобы более равномерно распределить работу по потокам. Предполагается, что это временное решение, поскольку в будущем будет возможно сделать количество источников равным количеству потоков, но для каждого источника динамически выбирать доступную работу для себя.

## max_subquery_depth {#max_subquery_depth} 

<SettingsInfoBlock type="UInt64" default_value="100" />

Если запрос содержит больше указанного числа вложенных подзапросов, выдает исключение.

:::tip
Это позволяет провести проверку разумности, чтобы защитить пользователей вашего кластера от написания чрезмерно сложных запросов.
:::

## max_table_size_to_drop {#max_table_size_to_drop} 

<SettingsInfoBlock type="UInt64" default_value="50000000000" />

Ограничение на удаление таблиц во время выполнения запроса. Значение 0 означает, что вы можете удалять все таблицы без каких-либо ограничений.

Облачное значение по умолчанию: 1 ТБ.

:::note
Эта настройка запроса перекрывает её эквивалент серверной настройки, см. [max_table_size_to_drop](/operations/server-configuration-parameters/settings#max_table_size_to_drop)
:::

## max_temporary_columns {#max_temporary_columns} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество временных колонок, которые должны храниться в ОЗУ одновременно
при выполнении запроса, включая постоянные колонки. Если запрос генерирует более
указанного количества временных колонок в памяти в результате промежуточного
вычисления, то выбрасывается исключение.

:::tip
Эта настройка полезна для предотвращения чрезмерно сложных запросов.
:::

Значение `0` означает неограниченное количество.

## max_temporary_data_on_disk_size_for_query {#max_temporary_data_on_disk_size_for_query} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество данных, занимаемых временными файлами на диске в байтах для всех
одновременно выполняемых запросов.

Допустимые значения:

- Положительное целое число.
- `0` — неограниченное (по умолчанию).

## max_temporary_data_on_disk_size_for_user {#max_temporary_data_on_disk_size_for_user} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество данных, занимаемых временными файлами на диске в байтах для всех
одновременно выполняемых запросов пользователя.

Допустимые значения:

- Положительное целое число.
- `0` — неограниченное (по умолчанию).

## max_temporary_non_const_columns {#max_temporary_non_const_columns} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Как и `max_temporary_columns`, максимальное количество временных колонок, которые должны
храниться в ОЗУ одновременно при выполнении запроса, но без учета постоянных
колонок.

:::note
Постоянные колонки формируются довольно часто при выполнении запроса, но они требуют
приблизительно нулевых вычислительных ресурсов.
:::

## max_threads {#max_threads} 

<SettingsInfoBlock type="MaxThreads" default_value="'auto(N)'" />

Максимальное количество потоков для обработки запросов, исключая потоки для извлечения данных из удалённых серверов (см. параметр 'max_distributed_connections').

Этот параметр применяется к потокам, которые выполняют одни и те же этапы обработки запроса параллельно.
Например, при чтении из таблицы, если есть возможность оценивать выражения с функциями, фильтровать с помощью WHERE и предварительно агрегировать для GROUP BY параллельно с использованием как минимум 'max_threads' числа потоков, то используются 'max_threads'.

Для запросов, которые завершаются быстро из-за LIMIT, вы можете установить более низкое значение 'max_threads'. Например, если необходимое количество записей находится в каждом блоке и max_threads = 8, то будет извлечено 8 блоков, хотя было бы достаточно прочитать лишь один.

Чем меньше значение `max_threads`, тем меньше памяти потребляется.

## max_threads_for_indexes {#max_threads_for_indexes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество потоков для обработки индексов.

## max_untracked_memory {#max_untracked_memory} 

<SettingsInfoBlock type="UInt64" default_value="4194304" />

Небольшие выделения и освобождения группируются в локальную переменную потока и отслеживаются или профилируются только тогда, когда сумма (по абсолютному значению) становится больше указанного значения. Если значение больше чем 'memory_profiler_step', оно эффективно будет снижено до 'memory_profiler_step'.

## memory_overcommit_ratio_denominator {#memory_overcommit_ratio_denominator} 

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.5"},{"label": "1073741824"},{"label": "Включить функцию перерасчёта памяти по умолчанию"}]}]} />

Это представляет собой мягкий предел памяти, когда жесткий предел достигнут на глобальном уровне.
Это значение используется для вычисления коэффициента перерасчёта для запроса.
Ноль означает пропуск запроса.
Узнайте больше о [перерасчете памяти](memory-overcommit.md).

## memory_overcommit_ratio_denominator_for_user {#memory_overcommit_ratio_denominator_for_user} 

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.5"},{"label": "1073741824"},{"label": "Включить функцию перерасчёта памяти по умолчанию"}]}]} />

Это представляет собой мягкий предел памяти, когда жесткий предел достигнут на уровне пользователя.
Это значение используется для вычисления коэффициента перерасчёта для запроса.
Ноль означает пропуск запроса.
Узнайте больше о [перерасчете памяти](memory-overcommit.md).

## memory_profiler_sample_max_allocation_size {#memory_profiler_sample_max_allocation_size} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Собирает случайные выделения размером меньше или равно указанному значению с вероятностью, равной `memory_profiler_sample_probability`. 0 означает отключение. Вы можете установить 'max_untracked_memory' в 0, чтобы ожидать, что этот порог будет работать как ожидалось.

## memory_profiler_sample_min_allocation_size {#memory_profiler_sample_min_allocation_size} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Собирает случайные выделения размером больше или равно указанному значению с вероятностью, равной `memory_profiler_sample_probability`. 0 означает отключение. Вы можете установить 'max_untracked_memory' в 0, чтобы ожидать, что этот порог будет работать как ожидалось.

## memory_profiler_sample_probability {#memory_profiler_sample_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

Собирает случайные выделения и освобождения и записывает их в system.trace_log с трассировкой 'MemorySample'. Вероятность для каждого выделения/освобождения независимо от размера выделения (может быть изменена с помощью `memory_profiler_sample_min_allocation_size` и `memory_profiler_sample_max_allocation_size`). Обратите внимание, что выборка происходит только тогда, когда количество неотслеживаемой памяти превышает 'max_untracked_memory'. Вы можете установить 'max_untracked_memory' в 0 для более детальной выборки.

## memory_profiler_step {#memory_profiler_step} 

<SettingsInfoBlock type="UInt64" default_value="4194304" />

Устанавливает шаг профилировщика памяти. Когда использование памяти запросом становится больше, чем каждый следующий шаг в байтах, профилировщик памяти будет собирать трассировку выделения и запишет её в [trace_log](/operations/system-tables/trace_log).

Допустимые значения:

- Положительное целое число в байтах.

- 0 для отключения профилировщика памяти.

## memory_tracker_fault_probability {#memory_tracker_fault_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

Для тестирования `безопасности исключений` - выбрасывать исключение каждый раз, когда вы выделяете память с указанной вероятностью.

## memory_usage_overcommit_max_wait_microseconds {#memory_usage_overcommit_max_wait_microseconds} 

<SettingsInfoBlock type="UInt64" default_value="5000000" />

Максимальное время, в течение которого поток будет ждать освобождения памяти в случае перерасчёта памяти на уровне пользователя.
Если время ожидания исчерпано и память не освобождена, выбрасывается исключение.
Узнайте больше о [перерасчете памяти](memory-overcommit.md).

## merge_table_max_tables_to_look_for_schema_inference {#merge_table_max_tables_to_look_for_schema_inference} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1000"},{"label": "Новая настройка"}]}]} />

При создании таблицы `Merge` без явной схемы или при использовании табличной функции `merge`, выведите схему как объединение не более указанного числа совпадающих таблиц.
Если таблиц больше, схема будет выведена из первых указанных таблиц.

## merge_tree_coarse_index_granularity {#merge_tree_coarse_index_granularity} 

<SettingsInfoBlock type="UInt64" default_value="8" />

При поиске данных ClickHouse проверяет метки данных в файле индекса. Если ClickHouse обнаружит, что необходимые ключи находятся в некотором диапазоне, он делит этот диапазон на `merge_tree_coarse_index_granularity` поддиапазонов и рекурсивно ищет необходимые ключи там.

Допустимые значения:

- Любое положительное четное целое число.

## merge_tree_compact_parts_min_granules_to_multibuffer_read {#merge_tree_compact_parts_min_granules_to_multibuffer_read} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="UInt64" default_value="16" />

Эта настройка влияет только на ClickHouse Cloud. Число гранул в полосе компактной части таблиц MergeTree, для которых используется многобуферный считыватель, который поддерживает параллельное считывание и предзагрузку. В случае чтения из удалённой файловой системы использование многобуферного считывателя увеличивает количество запросов на чтение.

## merge_tree_determine_task_size_by_prewhere_columns {#merge_tree_determine_task_size_by_prewhere_columns} 

<SettingsInfoBlock type="Bool" default_value="1" />

Использовать только размер колонок prewhere, чтобы определить размер задачи чтения.

## merge_tree_max_bytes_to_use_cache {#merge_tree_max_bytes_to_use_cache} 

<SettingsInfoBlock type="UInt64" default_value="2013265920" />

Если ClickHouse должен читать более `merge_tree_max_bytes_to_use_cache` байт в одном запросе, он не использует кэш несжатых блоков.

Кэш несжатых блоков хранит данные, извлечённые для запросов. ClickHouse использует этот кэш для ускорения ответов на повторяющиеся небольшие запросы. Эта настройка защищает кэш от разрушения запросами, которые читают большой объём данных. Настройка сервера [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) определяет размер кэша несжатых блоков.

Допустимые значения:

- Любое положительное целое число.

## merge_tree_max_rows_to_use_cache {#merge_tree_max_rows_to_use_cache} 

<SettingsInfoBlock type="UInt64" default_value="1048576" />

Если ClickHouse должен читать более `merge_tree_max_rows_to_use_cache` строк в одном запросе, он не использует кэш несжатых блоков.

Кэш несжатых блоков хранит данные, извлечённые для запросов. ClickHouse использует этот кэш для ускорения ответов на повторяющиеся небольшие запросы. Эта настройка защищает кэш от разрушения запросами, которые читают большой объём данных. Настройка сервера [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) определяет размер кэша несжатых блоков.

Допустимые значения:

- Любое положительное целое число.

## merge_tree_min_bytes_for_concurrent_read {#merge_tree_min_bytes_for_concurrent_read} 

<SettingsInfoBlock type="UInt64" default_value="251658240" />

Если количество байт, читаемых из одного файла таблицы с движком [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md), превышает `merge_tree_min_bytes_for_concurrent_read`, то ClickHouse пытается читать этот файл параллельно в несколько потоков.

Допустимые значения:

- Положительное целое число.

## merge_tree_min_bytes_for_concurrent_read_for_remote_filesystem {#merge_tree_min_bytes_for_concurrent_read_for_remote_filesystem} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Настройка устарела"}]}]} />

Минимальное количество байт, которое нужно прочитать из одного файла, прежде чем движок [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) сможет параллелизовать чтение, при чтении из удалённой файловой системы. Мы не рекомендуем использовать эту настройку.

Допустимые значения:

- Положительное целое число.

## merge_tree_min_bytes_for_seek {#merge_tree_min_bytes_for_seek} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если расстояние между двумя блоками данных, которые нужно прочитать в одном файле, меньше чем `merge_tree_min_bytes_for_seek` байт, тогда ClickHouse последовательно читает диапазон файла, содержащий оба блока, тем самым избегая дополнительного поиска.

Допустимые значения:

- Любое положительное целое число.

## merge_tree_min_bytes_per_task_for_remote_reading {#merge_tree_min_bytes_per_task_for_remote_reading} 

<SettingsInfoBlock type="UInt64" default_value="2097152" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "2097152"},{"label": "Значение унифицировано с `filesystem_prefetch_min_bytes_for_single_read_task`"}]}]} />

Минимальное количество байт для чтения за задачу.

## merge_tree_min_read_task_size {#merge_tree_min_read_task_size} 

<SettingsInfoBlock type="UInt64" default_value="8" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "8"},{"label": "Новая настройка"}]}]} />

Жесткий нижний предел размера задачи (даже когда количество гранул низкое и количество доступных потоков высокое, мы не выделим меньшие задачи).

## merge_tree_min_rows_for_concurrent_read {#merge_tree_min_rows_for_concurrent_read} 

<SettingsInfoBlock type="UInt64" default_value="163840" />

Если количество строк, которые нужно прочитать из файла таблицы с движком [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md), превышает `merge_tree_min_rows_for_concurrent_read`, то ClickHouse пытается выполнить параллельное чтение этого файла в несколько потоков.

Допустимые значения:

- Положительное целое число.
```
```yaml
title: 'merge_tree_min_rows_for_concurrent_read_for_remote_filesystem'
sidebar_label: 'merge_tree_min_rows_for_concurrent_read_for_remote_filesystem'
keywords: ['конкурентное чтение', 'MergeTree']
description: 'Минимальное количество строк для чтения из одного файла перед параллельным чтением в MergeTree.'
```

## merge_tree_min_rows_for_concurrent_read_for_remote_filesystem {#merge_tree_min_rows_for_concurrent_read_for_remote_filesystem}

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Настройка устарела"}]}]}/>

Минимальное количество строк для чтения из одного файла перед тем, как движок [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) может параллелизировать чтение при чтении из удаленной файловой системы. Мы не рекомендуем использовать эту настройку.

Возможные значения:

- Положительное целое число.
## merge_tree_min_rows_for_seek {#merge_tree_min_rows_for_seek}

<SettingsInfoBlock type="UInt64" default_value="0" />

Если расстояние между двумя блоками данных для чтения в одном файле меньше `merge_tree_min_rows_for_seek` строк, то ClickHouse не ищет в файле, а читает данные последовательно.

Возможные значения:

- Любое положительное целое число.
## merge_tree_read_split_ranges_into_intersecting_and_non_intersecting_injection_probability {#merge_tree_read_split_ranges_into_intersecting_and_non_intersecting_injection_probability}

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Для тестирования `PartsSplitter` - разбивайте диапазоны чтения на пересекающиеся и непересекающиеся каждый раз, когда вы читаете из MergeTree с заданной вероятностью."}]}]}/>

Для тестирования `PartsSplitter` - разбивайте диапазоны чтения на пересекающиеся и непересекающиеся каждый раз, когда вы читаете из MergeTree с заданной вероятностью.
## merge_tree_use_const_size_tasks_for_remote_reading {#merge_tree_use_const_size_tasks_for_remote_reading}

<SettingsInfoBlock type="Bool" default_value="1" />

Использовать ли задачи фиксированного размера для чтения из удаленной таблицы.
## merge_tree_use_deserialization_prefixes_cache {#merge_tree_use_deserialization_prefixes_cache}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Новая настройка для управления использованием кеша префиксов десериализации в MergeTree"}]}]}/>

Разрешает кэширование метаданных колонок из префиксов файла во время чтения из широких частей в MergeTree.
## merge_tree_use_prefixes_deserialization_thread_pool {#merge_tree_use_prefixes_deserialization_thread_pool}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Новая настройка управления использованием пула потоков для параллельной десериализации префиксов в MergeTree"}]}]}/>

Разрешает использование пула потоков для параллельного чтения префиксов в широких частях в MergeTree. Размер этого пула потоков контролируется серверной настройкой `max_prefixes_deserialization_thread_pool_size`.
## merge_tree_use_v1_object_and_dynamic_serialization {#merge_tree_use_v1_object_and_dynamic_serialization}

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Добавить новую версию сериализации V2 для типов JSON и Dynamic"}]}]}/>

При включении будет использоваться версия сериализации V1 для типов JSON и Dynamic в MergeTree вместо V2. Изменение этой настройки вступает в силу только после перезапуска сервера.
## metrics_perf_events_enabled {#metrics_perf_events_enabled}

<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, некоторые события производительности будут измеряться во время выполнения запросов.
## metrics_perf_events_list {#metrics_perf_events_list}

Список показателей производительности, разделенный запятыми, которые будут измеряться во время выполнения запросов. Пустой означает все события. См. PerfEventInfo в источниках для доступных событий.
## min_bytes_to_use_direct_io {#min_bytes_to_use_direct_io}

<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальный объем данных, необходимый для использования прямого доступа I/O к диску хранения.

ClickHouse использует эту настройку при чтении данных из таблиц. Если общий объем хранения всех данных, которые необходимо прочитать, превышает `min_bytes_to_use_direct_io` байт, то ClickHouse читает данные с диска хранения с опцией `O_DIRECT`.

Возможные значения:

- 0 — Прямой доступ I/O отключен.
- Положительное целое число.
## min_bytes_to_use_mmap_io {#min_bytes_to_use_mmap_io}

<SettingsInfoBlock type="UInt64" default_value="0" />

Это экспериментальная настройка. Устанавливает минимальное количество памяти для чтения больших файлов без копирования данных из ядра в пространство пользователя. Рекомендуемый порог составляет около 64 МБ, так как [mmap/munmap](https://en.wikipedia.org/wiki/Mmap) медленны. Имеет смысл только для больших файлов и помогает только если данные находятся в кэше страниц.

Возможные значения:

- Положительное целое число.
- 0 — Большие файлы читаются только с копированием данных из ядра в пространство пользователя.
## min_chunk_bytes_for_parallel_parsing {#min_chunk_bytes_for_parallel_parsing}

<SettingsInfoBlock type="NonZeroUInt64" default_value="10485760" />

- Тип: неотрицательное целое число
- Значение по умолчанию: 1 МБ

Минимальный размер блока в байтах, который каждый поток будет парсить параллельно.
## min_compress_block_size {#min_compress_block_size}

<SettingsInfoBlock type="UInt64" default_value="65536" />

Для [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) таблиц. С целью уменьшения задержки при обработке запросов блок сжимается при записи следующей метки, если его размер составляет не менее `min_compress_block_size`. По умолчанию 65,536.

Фактический размер блока, если несжатые данные меньше `max_compress_block_size`, не меньше этого значения и не меньше объема данных для одной метки.

Рассмотрим пример. Допустим, что `index_granularity` был установлен на 8192 во время создания таблицы.

Мы записываем колонку типа UInt32 (4 байта на значение). При записи 8192 строк, в сумме получится 32 КБ данных. Поскольку min_compress_block_size = 65,536, сжатый блок будет сформирован для каждых двух меток.

Мы записываем колонку URL с типом String (средний размер 60 байт на значение). При записи 8192 строк, в среднем получится чуть меньше 500 КБ данных. Поскольку это больше чем 65,536, сжатый блок будет сформирован для каждой метки. В этом случае, при чтении данных с диска в диапазоне одной метки, лишние данные не будут распакованы.

:::note
Это настройка экспертного уровня, и вам не следует изменять ее, если вы только начинаете работать с ClickHouse.
:::
## min_count_to_compile_aggregate_expression {#min_count_to_compile_aggregate_expression}

<SettingsInfoBlock type="UInt64" default_value="3" />

Минимальное количество идентичных агрегатных выражений для начала JIT-компиляции. Работает только если включена настройка [compile_aggregate_expressions](#compile_aggregate_expressions).

Возможные значения:

- Положительное целое число.
- 0 — Идентичные агрегатные выражения всегда JIT-компилируются.
## min_count_to_compile_expression {#min_count_to_compile_expression}

<SettingsInfoBlock type="UInt64" default_value="3" />

Минимальное количество выполнения одного и того же выражения перед его компиляцией.
## min_count_to_compile_sort_description {#min_count_to_compile_sort_description}

<SettingsInfoBlock type="UInt64" default_value="3" />

Количество идентичных описаний сортировки перед их JIT-компиляцией.
## min_execution_speed {#min_execution_speed}

<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальная скорость выполнения в строках в секунду. Проверяется на каждом блоке данных, когда истекает [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed). Если скорость выполнения ниже, выбрасывается исключение.
## min_execution_speed_bytes {#min_execution_speed_bytes}

<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальное количество байт выполнения в секунду. Проверяется на каждом блоке данных, когда истекает [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed). Если скорость выполнения ниже, выбрасывается исключение.
## min_external_sort_block_bytes {#min_external_sort_block_bytes}

<SettingsInfoBlock type="UInt64" default_value="104857600" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "104857600"},{"label": "Новая настройка."}]}]}/>

Минимальный размер блока в байтах для внешней сортировки, который будет записан на диск, чтобы избежать слишком большого количества файлов.
## min_external_table_block_size_bytes {#min_external_table_block_size_bytes}

<SettingsInfoBlock type="UInt64" default_value="268402944" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "268402944"},{"label": "Сжимать блоки, переданные во внешнюю таблицу, до указанного размера в байтах, если блоки недостаточно большие."}]}]}/>

Сжимать блоки, переданные во внешнюю таблицу, до указанного размера в байтах, если блоки недостаточно большие.
## min_external_table_block_size_rows {#min_external_table_block_size_rows}

<SettingsInfoBlock type="UInt64" default_value="1048449" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1048449"},{"label": "Сжимать блоки, переданные во внешнюю таблицу, до указанного размера в строках, если блоки недостаточно большие."}]}]}/>

Сжимать блоки, переданные во внешнюю таблицу, до указанного размера в строках, если блоки недостаточно большие.
## min_free_disk_bytes_to_perform_insert {#min_free_disk_bytes_to_perform_insert}

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Сохранять некоторый объем свободного дискового пространства при вставках, позволяя при этом временные записи."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Минимальное количество свободного дискового пространства для выполнения вставки.
## min_free_disk_ratio_to_perform_insert {#min_free_disk_ratio_to_perform_insert}

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Сохранять некоторый объем свободного дискового пространства, выраженный в отношении к общему дисковому пространству при вставках, позволяя при этом временные записи."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Минимальное соотношение свободного дискового пространства для выполнения вставки.
## min_free_disk_space_for_temporary_data {#min_free_disk_space_for_temporary_data}

<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальное дисковое пространство, которое необходимо сохранить во время записи временных данных, используемых в внешней сортировке и агрегации.
## min_hit_rate_to_use_consecutive_keys_optimization {#min_hit_rate_to_use_consecutive_keys_optimization}

<SettingsInfoBlock type="Float" default_value="0.5" />

Минимальная скорость попадания кеша, которая используется для оптимизации последовательных ключей при агрегации, чтобы она оставалась включенной.
## min_insert_block_size_bytes {#min_insert_block_size_bytes}

<SettingsInfoBlock type="UInt64" default_value="268402944" />

Устанавливает минимальное количество байт в блоке, которое может быть вставлено в таблицу с помощью запроса `INSERT`. Блоки меньшего размера объединяются в более крупные.

Возможные значения:

- Положительное целое число.
- 0 — Объединение отключено.
## min_insert_block_size_bytes_for_materialized_views {#min_insert_block_size_bytes_for_materialized_views}

<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает минимальное количество байт в блоке, который может быть вставлен в таблицу с помощью запроса `INSERT`. Блоки меньшего размера объединяются в более крупные. Эта настройка применяется только для блоков, вставляемых в [материализованное представление](../../sql-reference/statements/create/view.md). Настраивая эту настройку, вы контролируете объединение блоков при записи в материализованное представление и избегаете чрезмерного использования памяти.

Возможные значения:

- Любое положительное целое число.
- 0 — Объединение отключено.

**См. также**

- [min_insert_block_size_bytes](#min_insert_block_size_bytes)
## min_insert_block_size_rows {#min_insert_block_size_rows}

<SettingsInfoBlock type="UInt64" default_value="1048449" />

Устанавливает минимальное количество строк в блоке, который может быть вставлен в таблицу с помощью запроса `INSERT`. Блоки меньшего размера объединяются в более крупные.

Возможные значения:

- Положительное целое число.
- 0 — Объединение отключено.
## min_insert_block_size_rows_for_materialized_views {#min_insert_block_size_rows_for_materialized_views}

<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает минимальное количество строк в блоке, который может быть вставлен в таблицу с помощью запроса `INSERT`. Блоки меньшего размера объединяются в более крупные. Эта настройка применяется только для блоков, вставляемых в [материализованное представление](../../sql-reference/statements/create/view.md). Настраивая эту настройку, вы контролируете объединение блоков при записи в материализованное представление и избегаете чрезмерного использования памяти.

Возможные значения:

- Любое положительное целое число.
- 0 — Объединение отключено.

**См. также**

- [min_insert_block_size_rows](#min_insert_block_size_rows)
## min_joined_block_size_bytes {#min_joined_block_size_bytes}

<SettingsInfoBlock type="UInt64" default_value="524288" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "524288"},{"label": "Новая настройка."}]}]}/>

Минимальный размер блока для результата JOIN (если алгоритм соединения поддерживает это). 0 означает неограниченный.
## min_os_cpu_wait_time_ratio_to_throw {#min_os_cpu_wait_time_ratio_to_throw}

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Значения настройки были изменены и перенесены в 25.4"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Минимальное соотношение между временем ожидания CPU ОС (метрика OSCPUWaitMicroseconds) и временем занятости (метрика OSCPUVirtualTimeMicroseconds) для принятия решения о необходимости отклонения запросов. Линейная интерполяция между минимальным и максимальным соотношением используется для вычисления вероятности, вероятность на этом этапе равна 0.
## mongodb_throw_on_unsupported_query {#mongodb_throw_on_unsupported_query}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "1"},{"label": "Новая настройка."}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "1"},{"label": "Новая настройка."}]}]}/>

Если включено, таблицы MongoDB будут возвращать ошибку, когда запрос MongoDB не может быть построен. В противном случае ClickHouse читает всю таблицу и обрабатывает ее локально. Эта опция не применяется, когда 'allow_experimental_analyzer=0'.
## move_all_conditions_to_prewhere {#move_all_conditions_to_prewhere}

<SettingsInfoBlock type="Bool" default_value="1" />

Переместить все жизнеспособные условия из WHERE в PREWHERE.
## move_primary_key_columns_to_end_of_prewhere {#move_primary_key_columns_to_end_of_prewhere}

<SettingsInfoBlock type="Bool" default_value="1" />

Переместить условия PREWHERE, содержащие колонки первичного ключа, в конец цепочки AND. Скорее всего, эти условия учитываются при анализе первичного ключа и, таким образом, не будут добавлять много к фильтрации PREWHERE.
## multiple_joins_try_to_keep_original_names {#multiple_joins_try_to_keep_original_names}

<SettingsInfoBlock type="Bool" default_value="0" />

Не добавлять псевдонимы в список выражений верхнего уровня при переписывании нескольких соединений.
## mutations_execute_nondeterministic_on_initiator {#mutations_execute_nondeterministic_on_initiator}

<SettingsInfoBlock type="Bool" default_value="0" />

Если истинно, постоянные ненаправленные функции (например, функция `now()`) выполняются на инициаторе и заменяются литеральными значениями в запросах `UPDATE` и `DELETE`. Это помогает сохранять данные синхронизированными на репликах при выполнении мутаций с постоянными ненаправленными функциями. Значение по умолчанию: `false`.
## mutations_execute_subqueries_on_initiator {#mutations_execute_subqueries_on_initiator}

<SettingsInfoBlock type="Bool" default_value="0" />

Если истинно, скалярные подзапросы выполняются на инициаторе и заменяются литеральными значениями в запросах `UPDATE` и `DELETE`. Значение по умолчанию: `false`.
## mutations_max_literal_size_to_replace {#mutations_max_literal_size_to_replace}

<SettingsInfoBlock type="UInt64" default_value="16384" />

Максимальный размер сериализованной литералы в байтах для замены в запросах `UPDATE` и `DELETE`. Применяется только в том случае, если хотя бы одна из двух настроек выше включена. Значение по умолчанию: 16384 (16 КБ).
## mutations_sync {#mutations_sync}

<SettingsInfoBlock type="UInt64" default_value="0" />

Позволяет выполнять запросы `ALTER TABLE ... UPDATE|DELETE|MATERIALIZE INDEX|MATERIALIZE PROJECTION|MATERIALIZE COLUMN|MATERIALIZE STATISTICS` ([мутации](../../sql-reference/statements/alter/index.md/#mutations)) синхронно.

Возможные значения:

- 0 - Мутации выполняются асинхронно.
- 1 - Запрос ожидает завершения всех мутаций на текущем сервере.
- 2 - Запрос ожидает завершения всех мутаций на всех репликах (если они существуют).
## mysql_datatypes_support_level {#mysql_datatypes_support_level}

Определяет, как типы MySQL преобразуются в соответствующие типы ClickHouse. Список, разделенный запятыми, в любом сочетании `decimal`, `datetime64`, `date2Date32` или `date2String`.
- `decimal`: преобразовывать `NUMERIC` и `DECIMAL` типы в `Decimal`, когда точность это позволяет.
- `datetime64`: преобразовывать `DATETIME` и `TIMESTAMP` типы в `DateTime64`, а не в `DateTime`, когда точность не равна `0`.
- `date2Date32`: преобразовывать `DATE` в `Date32`, а не в `Date`. Имеет приоритет над `date2String`.
- `date2String`: преобразовывать `DATE` в `String`, а не в `Date`. Переопределяется `datetime64`.
## mysql_map_fixed_string_to_text_in_show_columns {#mysql_map_fixed_string_to_text_in_show_columns}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Уменьшить усилия по конфигурации для подключения ClickHouse к BI-инструментам."}]}]}/>

При включении, тип данных [FixedString](../../sql-reference/data-types/fixedstring.md) ClickHouse будет отображаться как `TEXT` в [SHOW COLUMNS](../../sql-reference/statements/show.md/#show_columns).

Действует только при подключении через MySQL протокол.

- 0 - Использовать `BLOB`.
- 1 - Использовать `TEXT`.
## mysql_map_string_to_text_in_show_columns {#mysql_map_string_to_text_in_show_columns}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Уменьшить усилия по конфигурации для подключения ClickHouse к BI-инструментам."}]}]}/>

При включении, тип данных [String](../../sql-reference/data-types/string.md) ClickHouse будет отображаться как `TEXT` в [SHOW COLUMNS](../../sql-reference/statements/show.md/#show_columns).

Действует только при подключении через MySQL протокол.

- 0 - Использовать `BLOB`.
- 1 - Использовать `TEXT`.
## mysql_max_rows_to_insert {#mysql_max_rows_to_insert}

<SettingsInfoBlock type="UInt64" default_value="65536" />

Максимальное количество строк в пакетной вставке MySQL для движка хранения MySQL.
## network_compression_method {#network_compression_method}

<SettingsInfoBlock type="String" default_value="LZ4" />

Устанавливает метод сжатия данных, используемый для связи между серверами и между сервером и [clickhouse-client](../../interfaces/cli.md).

Возможные значения:

- `LZ4` — устанавливает метод сжатия LZ4.
- `ZSTD` — устанавливает метод сжатия ZSTD.

**См. также**

- [network_zstd_compression_level](#network_zstd_compression_level)
## network_zstd_compression_level {#network_zstd_compression_level}

<SettingsInfoBlock type="Int64" default_value="1" />

Настраивает уровень сжатия ZSTD. Используется только когда [network_compression_method](#network_compression_method) установлен на `ZSTD`.

Возможные значения:

- Положительное целое число от 1 до 15.
## normalize_function_names {#normalize_function_names}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.3"},{"label": "1"},{"label": "Нормализовать имена функций до их канонических имен, это было необходимо для маршрутизации запросов проекции"}]}]}/>

Нормализовать имена функций до их канонических имен.
## number_of_mutations_to_delay {#number_of_mutations_to_delay}

<SettingsInfoBlock type="UInt64" default_value="0" />

Если измененная таблица содержит хотя бы столько же незаконченных мутаций, искусственно замедлить мутации таблицы. 0 - отключено.
## number_of_mutations_to_throw {#number_of_mutations_to_throw}

<SettingsInfoBlock type="UInt64" default_value="0" />

Если измененная таблица содержит хотя бы столько же незаконченных мутаций, выбрасывается исключение 'Слишком много мутаций ...'. 0 - отключено.
## odbc_bridge_connection_pool_size {#odbc_bridge_connection_pool_size}

<SettingsInfoBlock type="UInt64" default_value="16" />

Размер пула соединений для каждой строки настроек соединения в ODBC мосту.
## odbc_bridge_use_connection_pooling {#odbc_bridge_use_connection_pooling}

<SettingsInfoBlock type="Bool" default_value="1" />

Использовать пул соединений в ODBC мосту. Если установить в false, новое соединение создается каждый раз.
## offset {#offset}

<SettingsInfoBlock type="UInt64" default_value="0" />

Устанавливает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса. Это корректирует описание смещения, установленное с помощью [OFFSET](/sql-reference/statements/select/offset), так что эти два значения суммируются.

Возможные значения:

- 0 — Не пропускаются строки.
- Положительное целое число.

**Пример**

Входная таблица:

```sql
CREATE TABLE test (i UInt64) ENGINE = MergeTree() ORDER BY i;
INSERT INTO test SELECT number FROM numbers(500);
```

Запрос:

```sql
SET limit = 5;
SET offset = 7;
SELECT * FROM test LIMIT 10 OFFSET 100;
```
Результат:

```text
┌───i─┐
│ 107 │
│ 108 │
│ 109 │
└─────┘
```
## opentelemetry_start_trace_probability {#opentelemetry_start_trace_probability}

<SettingsInfoBlock type="Float" default_value="0" />

Устанавливает вероятность, что ClickHouse может начать трассировку для выполняемых запросов (если не предоставлен родительский [контекст трассировки](https://www.w3.org/TR/trace-context/)).

Возможные значения:

- 0 — Трассировка для всех выполняемых запросов отключена (если не предоставлен родительский контекст трассировки).
- Положительное дробное число в диапазоне [0..1]. Например, если значение настройки равно `0,5`, ClickHouse может начинать трассировку в среднем для половины запросов.
- 1 — Трассировка для всех выполняемых запросов включена.
## opentelemetry_trace_processors {#opentelemetry_trace_processors}

<SettingsInfoBlock type="Bool" default_value="0" />

Собирать спаны OpenTelemetry для процессоров.
## optimize_aggregation_in_order {#optimize_aggregation_in_order}

<SettingsInfoBlock type="Bool" default_value="0" />

Включает оптимизацию [GROUP BY](/sql-reference/statements/select/group-by) в запросах [SELECT](../../sql-reference/statements/select/index.md) для агрегации данных в соответствующем порядке в таблицах [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md).

Возможные значения:

- 0 — Оптимизация `GROUP BY` отключена.
- 1 — Оптимизация `GROUP BY` включена.

**См. также**

- [Оптимизация GROUP BY](/sql-reference/statements/select/group-by#group-by-optimization-depending-on-table-sorting-key)
## optimize_aggregators_of_group_by_keys {#optimize_aggregators_of_group_by_keys}

<SettingsInfoBlock type="Bool" default_value="1" />

Устраняет агрегаторы min/max/any/anyLast для ключей GROUP BY в разделе SELECT.
## optimize_and_compare_chain {#optimize_and_compare_chain}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Пополняет постоянное сравнение в цепочках AND, чтобы улучшить возможность фильтрации. Поддерживает операторы `<`, `<=`, `>`, `>=`, `=` и их сочетания. Например, `(a < b) AND (b < c) AND (c < 5)` будет `(a < b) AND (b < c) AND (c < 5) AND (b < 5) AND (a < 5)`.
## optimize_append_index {#optimize_append_index}

<SettingsInfoBlock type="Bool" default_value="0" />

Использовать [ограничения](../../sql-reference/statements/create/table.md/#constraints) для добавления условия индекса. Значение по умолчанию — `false`.

Возможные значения:

- true, false
## optimize_arithmetic_operations_in_aggregate_functions {#optimize_arithmetic_operations_in_aggregate_functions}

<SettingsInfoBlock type="Bool" default_value="1" />

Переместить арифметические операции за пределы агрегатных функций.
## optimize_count_from_files {#optimize_count_from_files}

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает оптимизацию подсчета числа строк из файлов в различных входных форматах. Применяется к табличным функциям/движкам `file`/`s3`/`url`/`hdfs`/`azureBlobStorage`.

Возможные значения:

- 0 — Оптимизация отключена.
- 1 — Оптимизация включена.
## optimize_distinct_in_order {#optimize_distinct_in_order}

<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию DISTINCT, если некоторые колонки в DISTINCT образуют префикс сортировки. Например, префикс сортировочного ключа в Merge Tree или операторе ORDER BY.
## optimize_distributed_group_by_sharding_key {#optimize_distributed_group_by_sharding_key}

<SettingsInfoBlock type="Bool" default_value="1" />

Оптимизация запросов `GROUP BY sharding_key`, избегая затратной агрегации на сервере инициаторе (что снизит использование памяти для запроса на сервере инициаторе).

Поддерживаются следующие типы запросов (и все их комбинации):

- `SELECT DISTINCT [..., ]sharding_key[, ...] FROM dist`
- `SELECT ... FROM dist GROUP BY sharding_key[, ...]`
- `SELECT ... FROM dist GROUP BY sharding_key[, ...] ORDER BY x`
- `SELECT ... FROM dist GROUP BY sharding_key[, ...] LIMIT 1`
- `SELECT ... FROM dist GROUP BY sharding_key[, ...] LIMIT 1 BY x`

Следующие типы запросов не поддерживаются (поддержка некоторых из них может быть добавлена позже):

- `SELECT ... GROUP BY sharding_key[, ...] WITH TOTALS`
- `SELECT ... GROUP BY sharding_key[, ...] WITH ROLLUP`
- `SELECT ... GROUP BY sharding_key[, ...] WITH CUBE`
- `SELECT ... GROUP BY sharding_key[, ...] SETTINGS extremes=1`

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

См. также:

- [distributed_group_by_no_merge](#distributed_group_by_no_merge)
- [distributed_push_down_limit](#distributed_push_down_limit)
- [optimize_skip_unused_shards](#optimize_skip_unused_shards)

:::note
На данный момент это требует `optimize_skip_unused_shards` (причина в том, что когда-нибудь это может быть включено по умолчанию, и оно будет работать корректно только если данные были вставлены через распределенную таблицу, т.е. данные распределены в соответствии с ключом шардирования).
:::
## optimize_exchanges {#optimize_exchanges}

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Новая экспериментальная настройка."}]}]}/>

Удаляет ненужные обмены в плане распределенного запроса. Отключите ее для отладки.
## optimize_extract_common_expressions {#optimize_extract_common_expressions}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Оптимизация выражений WHERE, PREWHERE, ON, HAVING и QUALIFY путем извлечения общих выражений из дизъюнкции конъюнкций."}]}, {"id": "row-2","items": [{"label": "24.12"},{"label": "0"},{"label": "Введение настройки для оптимизации выражений WHERE, PREWHERE, ON, HAVING и QUALIFY путем извлечения общих выражений из дизъюнкции конъюнкций."}]}]}/>

Позволяет извлечение общих выражений из дизъюнкций в выражениях WHERE, PREWHERE, ON, HAVING и QUALIFY. Логическое выражение вроде `(A AND B) OR (A AND C)` может быть переписано в `A AND (B OR C)`, что может помочь использовать:
- индексы в простых фильтрующих выражениях
- оптимизацию соединения cross to inner join.
## optimize_functions_to_subcolumns {#optimize_functions_to_subcolumns}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "1"},{"label": "Новые настройки по умолчанию"}]}]}/>

Включает или отключает оптимизацию, преобразуя некоторые функции в чтение подколонок. Это уменьшает объем данных для чтения.

Эти функции могут быть преобразованы:

- [length](/sql-reference/functions/array-functions#length) для чтения подколонки [size0](../../sql-reference/data-types/array.md/#array-size).
- [empty](/sql-reference/functions/array-functions#empty) для чтения подколонки [size0](../../sql-reference/data-types/array.md/#array-size).
- [notEmpty](/sql-reference/functions/array-functions#notempty) для чтения подколонки [size0](../../sql-reference/data-types/array.md/#array-size).
- [isNull](/sql-reference/functions/functions-for-nulls#isnull) для чтения подколонки [null](../../sql-reference/data-types/nullable.md/#finding-null).
- [isNotNull](/sql-reference/functions/functions-for-nulls#isnotnull) для чтения подколонки [null](../../sql-reference/data-types/nullable.md/#finding-null).
- [count](/sql-reference/aggregate-functions/reference/count) для чтения подколонки [null](../../sql-reference/data-types/nullable.md/#finding-null).
- [mapKeys](/sql-reference/functions/tuple-map-functions#mapkeys) для чтения подколонки [keys](/sql-reference/data-types/map#reading-subcolumns-of-map).
- [mapValues](/sql-reference/functions/tuple-map-functions#mapvalues) для чтения подколонки [values](/sql-reference/data-types/map#reading-subcolumns-of-map).

Возможные значения:

- 0 — Оптимизация отключена.
- 1 — Оптимизация включена.
## optimize_group_by_constant_keys {#optimize_group_by_constant_keys}

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.9"},{"label": "1"},{"label": "Оптимизация GROUP BY по умолчанию для постоянных ключей"}]}]}/>

Оптимизация GROUP BY, когда все ключи в блоке постоянные.
## optimize_group_by_function_keys {#optimize_group_by_function_keys}

<SettingsInfoBlock type="Bool" default_value="1" />

Устраняет функции других ключей в разделе GROUP BY.
```
```yaml
title: 'Оптимизации ClickHouse'
sidebar_label: 'Оптимизации'
keywords: ['оптимизация', 'ClickHouse', 'параллельные реплики']
description: 'Документация о настройках оптимизации ClickHouse'
```

## optimize_if_chain_to_multiif {#optimize_if_chain_to_multiif} 

<SettingsInfoBlock type="Bool" default_value="0" />

Заменяет цепочки `if(cond1, then1, if(cond2, ...))` на `multiIf`. В данный момент это не дает преимущества для числовых типов.

## optimize_if_transform_strings_to_enum {#optimize_if_transform_strings_to_enum} 

<SettingsInfoBlock type="Bool" default_value="0" />

Заменяет аргументы строкового типа в `If` и `Transform` на `enum`. Отключено по умолчанию, поскольку это может привести к несогласованным изменениям в распределенном запросе, что может привести к его сбою.

## optimize_injective_functions_in_group_by {#optimize_injective_functions_in_group_by} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "1"},{"label": "Заменяет инъективные функции на их аргументы в разделе GROUP BY в анализаторе"}]}]}/>

Заменяет инъективные функции на их аргументы в разделе GROUP BY.

## optimize_injective_functions_inside_uniq {#optimize_injective_functions_inside_uniq} 

<SettingsInfoBlock type="Bool" default_value="1" />

Удаляет инъективные функции с одним аргументом внутри функций `uniq*()`.

## optimize_min_equality_disjunction_chain_length {#optimize_min_equality_disjunction_chain_length} 

<SettingsInfoBlock type="UInt64" default_value="3" />

Минимальная длина выражения `expr = x1 OR ... expr = xN` для оптимизации.

## optimize_min_inequality_conjunction_chain_length {#optimize_min_inequality_conjunction_chain_length} 

<SettingsInfoBlock type="UInt64" default_value="3" />

Минимальная длина выражения `expr <> x1 AND ... expr <> xN` для оптимизации.

## optimize_move_to_prewhere {#optimize_move_to_prewhere} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает автоматическую оптимизацию [PREWHERE](../../sql-reference/statements/select/prewhere.md) в запросах [SELECT](../../sql-reference/statements/select/index.md).

Работает только для таблиц [*MergeTree](../../engines/table-engines/mergetree-family/index.md).

Возможные значения:

- 0 — Автоматическая оптимизация `PREWHERE` отключена.
- 1 — Автоматическая оптимизация `PREWHERE` включена.

## optimize_move_to_prewhere_if_final {#optimize_move_to_prewhere_if_final} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает автоматическую оптимизацию [PREWHERE](../../sql-reference/statements/select/prewhere.md) в запросах [SELECT](../../sql-reference/statements/select/index.md) с модификатором [FINAL](/sql-reference/statements/select/from#final-modifier).

Работает только для таблиц [*MergeTree](../../engines/table-engines/mergetree-family/index.md).

Возможные значения:

- 0 — Автоматическая оптимизация `PREWHERE` в запросах `SELECT` с модификатором `FINAL` отключена.
- 1 — Автоматическая оптимизация `PREWHERE` в запросах `SELECT` с модификатором `FINAL` включена.

**См. также**

- Настройка [optimize_move_to_prewhere](#optimize_move_to_prewhere).

## optimize_multiif_to_if {#optimize_multiif_to_if} 

<SettingsInfoBlock type="Bool" default_value="1" />

Заменяет `multiIf` с единственным условием на `if`.

## optimize_normalize_count_variants {#optimize_normalize_count_variants} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.3"},{"label": "1"},{"label": "Переписывание агрегатных функций, которые семантически равны count() как count() по умолчанию"}]}]}/>

Переписывание агрегатных функций, которые семантически равны count() как count().

## optimize_on_insert {#optimize_on_insert} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.1"},{"label": "1"},{"label": "Включение оптимизации данных при вставке по умолчанию для улучшения пользовательского опыта"}]}]}/>

Включает или отключает преобразование данных перед вставкой, как если бы слияние было выполнено над этим блоком (в соответствии с движком таблицы).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

**Пример**

Разница между включенной и отключенной оптимизацией:

Запрос:

```sql
SET optimize_on_insert = 1;

CREATE TABLE test1 (`FirstTable` UInt32) ENGINE = ReplacingMergeTree ORDER BY FirstTable;

INSERT INTO test1 SELECT number % 2 FROM numbers(5);

SELECT * FROM test1;

SET optimize_on_insert = 0;

CREATE TABLE test2 (`SecondTable` UInt32) ENGINE = ReplacingMergeTree ORDER BY SecondTable;

INSERT INTO test2 SELECT number % 2 FROM numbers(5);

SELECT * FROM test2;
```

Результат:

```text
┌─FirstTable─┐
│          0 │
│          1 │
└────────────┘

┌─SecondTable─┐
│           0 │
│           0 │
│           0 │
│           1 │
│           1 │
└─────────────┘
```

Обратите внимание, что эта настройка влияет на поведение [материализованных представлений](/sql-reference/statements/create/view#materialized-view).

## optimize_or_like_chain {#optimize_or_like_chain} 

<SettingsInfoBlock type="Bool" default_value="0" />

Оптимизирует множественные `OR LIKE` в `multiMatchAny`. Эта оптимизация не должна быть включена по умолчанию, поскольку она может нарушать анализ индексов в некоторых случаях.

## optimize_read_in_order {#optimize_read_in_order} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию [ORDER BY](/sql-reference/statements/select/order-by#optimization-of-data-reading) в запросах [SELECT](../../sql-reference/statements/select/index.md) для чтения данных из таблиц [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md).

Возможные значения:

- 0 — Оптимизация `ORDER BY` отключена.
- 1 — Оптимизация `ORDER BY` включена.

**См. также**

- [Клаузула ORDER BY](/sql-reference/statements/select/order-by#optimization-of-data-reading).

## optimize_read_in_window_order {#optimize_read_in_window_order} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию `ORDER BY` в оконной клаузе для чтения данных в соответствующем порядке в таблицах MergeTree.

## optimize_redundant_functions_in_order_by {#optimize_redundant_functions_in_order_by} 

<SettingsInfoBlock type="Bool" default_value="1" />

Удаляет функции из `ORDER BY`, если их аргументы также присутствуют в `ORDER BY`.

## optimize_respect_aliases {#optimize_respect_aliases} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если установлено в true, будет уважаться псевдонимы в `WHERE/GROUP BY/ORDER BY`, что поможет с обрезкой партиций/вторичными индексами/оптимизацией агрегации в `ORDER BY`/оптимизацией чтения в порядке/оптимизацией тривиального подсчета.

## optimize_rewrite_aggregate_function_with_if {#optimize_rewrite_aggregate_function_with_if} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переписывание агрегатных функций с выражением `if` в качестве аргумента, когда логически эквивалентно.
Например, `avg(if(cond, col, null))` можно переписать как `avgOrNullIf(cond, col)`. Это может улучшить производительность.

:::note
Поддерживается только с анализатором (`enable_analyzer = 1`).
:::

## optimize_rewrite_array_exists_to_has {#optimize_rewrite_array_exists_to_has} 

<SettingsInfoBlock type="Bool" default_value="0" />

Переписывание функций `arrayExists()` в `has()`, когда логически эквивалентно. Например, `arrayExists(x -> x = 1, arr)` можно переписать как `has(arr, 1)`.

## optimize_rewrite_sum_if_to_count_if {#optimize_rewrite_sum_if_to_count_if} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "1"},{"label": "Доступно только для анализатора, где оно работает корректно"}]}]}/>

Переписывает функции `sumIf()` и `sum(if())` в функцию `countIf()`, когда логически эквивалентно.

## optimize_skip_merged_partitions {#optimize_skip_merged_partitions} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает оптимизацию для запроса [OPTIMIZE TABLE ... FINAL](../../sql-reference/statements/optimize.md), если есть только одна часть с уровнем > 0 и она не имеет истекшего TTL.

- `OPTIMIZE TABLE ... FINAL SETTINGS optimize_skip_merged_partitions=1`

По умолчанию запрос `OPTIMIZE TABLE ... FINAL` переписывает одну часть, даже если есть только одна часть.

Возможные значения:

- 1 — Включить оптимизацию.
- 0 — Отключить оптимизацию.

## optimize_skip_unused_shards {#optimize_skip_unused_shards} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает пропуск неиспользуемых шардов для запросов [SELECT](../../sql-reference/statements/select/index.md), которые имеют условие ключа шардирования в `WHERE/PREWHERE` (при условии, что данные распределены по ключу шардирования, в противном случае запрос дает некорректный результат).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

## optimize_skip_unused_shards_limit {#optimize_skip_unused_shards_limit} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Лимит для количества значений ключа шардирования, отключает `optimize_skip_unused_shards`, если лимит достигнут.

Слишком много значений может потребовать значительное количество ресурсов для обработки, в то время как польза сомнительна, поскольку если у вас огромный номер значений в `IN (...)`, то, скорее всего, запрос будет отправлен ко всем шартам в любом случае.

## optimize_skip_unused_shards_nesting {#optimize_skip_unused_shards_nesting} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Контролирует [`optimize_skip_unused_shards`](#optimize_skip_unused_shards) (поэтому все еще требует [`optimize_skip_unused_shards`](#optimize_skip_unused_shards)) в зависимости от уровня вложенности распределенного запроса (случай, когда у вас есть `Distributed` таблица, которая смотрит на другую `Distributed` таблицу).

Возможные значения:

- 0 — Отключено, `optimize_skip_unused_shards` всегда работает.
- 1 — Включает `optimize_skip_unused_shards` только для первого уровня.
- 2 — Включает `optimize_skip_unused_shards` до второго уровня.

## optimize_skip_unused_shards_rewrite_in {#optimize_skip_unused_shards_rewrite_in} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переписывает `IN` в запросе для удаленных шардов, чтобы исключить значения, которые не принадлежат шару (требует `optimize_skip_unused_shards`).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

## optimize_sorting_by_input_stream_properties {#optimize_sorting_by_input_stream_properties} 

<SettingsInfoBlock type="Bool" default_value="1" />

Оптимизирует сортировку по свойствам сортировки входного потока.

## optimize_substitute_columns {#optimize_substitute_columns} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использует [ограничения](../../sql-reference/statements/create/table.md/#constraints) для замены колонок. По умолчанию `false`.

Возможные значения:

- true, false.

## optimize_syntax_fuse_functions {#optimize_syntax_fuse_functions} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает объединение агрегатных функций с идентичным аргументом. Переписывает запрос, содержащий как минимум две агрегатные функции из [sum](/sql-reference/aggregate-functions/reference/sum), [count](/sql-reference/aggregate-functions/reference/count) или [avg](/sql-reference/aggregate-functions/reference/avg) с идентичным аргументом в [sumCount](/sql-reference/aggregate-functions/reference/sumcount).

Возможные значения:

- 0 — Функции с идентичным аргументом не объединяются.
- 1 — Функции с идентичным аргументом объединяются.

**Пример**

Запрос:

```sql
CREATE TABLE fuse_tbl(a Int8, b Int8) Engine = Log;
SET optimize_syntax_fuse_functions = 1;
EXPLAIN SYNTAX SELECT sum(a), sum(b), count(b), avg(b) from fuse_tbl FORMAT TSV;
```

Результат:

```text
SELECT
    sum(a),
    sumCount(b).1,
    sumCount(b).2,
    (sumCount(b).1) / (sumCount(b).2)
FROM fuse_tbl
```

## optimize_throw_if_noop {#optimize_throw_if_noop} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает выброс исключения, если запрос [OPTIMIZE](../../sql-reference/statements/optimize.md) не выполнил слияние.

По умолчанию `OPTIMIZE` возвращает успешно, даже если ничего не было сделано. Эта настройка позволяет различать эти ситуации и получать причину в сообщении об исключении.

Возможные значения:

- 1 — Выброс исключения включен.
- 0 — Выброс исключения отключен.

## optimize_time_filter_with_preimage {#optimize_time_filter_with_preimage} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Оптимизация предикатов Date и DateTime путем преобразования функций в эквивалентные сравнения без преобразований (например, toYear(col) = 2023 -> col >= '2023-01-01' AND col <= '2023-12-31')"}]}]}/>

Оптимизация предикатов Date и DateTime путем преобразования функций в эквивалентные сравнения без преобразований (например, `toYear(col) = 2023 -> col >= '2023-01-01' AND col <= '2023-12-31'`).

## optimize_trivial_approximate_count_query {#optimize_trivial_approximate_count_query} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использует приблизительное значение для тривиальных запросов подсчета для хранилищ, которые поддерживают такую оценку, например, EmbeddedRocksDB.

Возможные значения:

- 0 — Оптимизация отключена.
- 1 — Оптимизация включена.

## optimize_trivial_count_query {#optimize_trivial_count_query} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает оптимизацию для тривиального запроса `SELECT count() FROM table` с использованием метаданных из MergeTree. Если вам нужно использовать безопасность на уровне строк, отключите эту настройку.

Возможные значения:

- 0 — Оптимизация отключена.
- 1 — Оптимизация включена.

См. также:

- [optimize_functions_to_subcolumns](#optimize_functions_to_subcolumns).

## optimize_trivial_insert_select {#optimize_trivial_insert_select} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Оптимизация не имеет смысла во многих случаях."}]}]}/>

Оптимизация тривиального запроса 'INSERT INTO table SELECT ... FROM TABLES'.

## optimize_uniq_to_count {#optimize_uniq_to_count} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переписывает `uniq` и его варианты (кроме `uniqUpTo`) в `count`, если подзапрос имеет distinct или group by клаузу.

## optimize_use_implicit_projections {#optimize_use_implicit_projections} 

<SettingsInfoBlock type="Bool" default_value="1" />

Автоматически выбирает неявные проекции для выполнения запроса SELECT.

## optimize_use_projections {#optimize_use_projections} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает оптимизацию [проекций](../../engines/table-engines/mergetree-family/mergetree.md/#projections) при обработке запросов `SELECT`.

Возможные значения:

- 0 — Оптимизация проекций отключена.
- 1 — Оптимизация проекций включена.

## optimize_using_constraints {#optimize_using_constraints} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использует [ограничения](../../sql-reference/statements/create/table.md/#constraints) для оптимизации запроса. По умолчанию `false`.

Возможные значения:

- true, false.

## os_thread_priority {#os_thread_priority} 

<SettingsInfoBlock type="Int64" default_value="0" />

Устанавливает приоритет ( [nice](https://en.wikipedia.org/wiki/Nice_(Unix)) ) для потоков, выполняющих запросы. Планировщик ОС учитывает этот приоритет при выборе следующего потока для выполнения на каждом доступном ядре CPU.

:::note
Чтобы использовать эту настройку, вам необходимо установить возможность `CAP_SYS_NICE`. Пакет `clickhouse-server` настраивает это во время установки. Некоторые виртуальные среды не позволяют устанавливать возможность `CAP_SYS_NICE`. В этом случае `clickhouse-server` выдает о этом сообщение в начале работы.
:::

Возможные значения:

- Вы можете задать значения в диапазоне `[-20, 19]`.

Низкие значения означают более высокий приоритет. Потоки с низкими значениями приоритета `nice` выполняются чаще, чем потоки с высокими значениями. Высокие значения предпочтительны для длительных неинтерактивных запросов, поскольку это позволяет им быстро отказаться от ресурсов в пользу коротких интерактивных запросов, когда они приходят.

## output_format_compression_level {#output_format_compression_level} 

<SettingsInfoBlock type="UInt64" default_value="3" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "3"},{"label": "Разрешает изменять уровень сжатия в выводе запроса"}]}]}/>

Уровень сжатия по умолчанию, если вывод запроса сжат. Настройка применяется, когда запрос `SELECT` имеет `INTO OUTFILE` или при записи в табличные функции `file`, `url`, `hdfs`, `s3` или `azureBlobStorage`.

Возможные значения: от `1` до `22`.

## output_format_compression_zstd_window_log {#output_format_compression_zstd_window_log} 

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Разрешает изменять окно сжатия zstd в выводе запроса, когда используется сжатие zstd"}]}]}/>

Может быть использовано, когда методом сжатия выходных данных является `zstd`. Если больше `0`, эта настройка явно устанавливает размер окна сжатия (степень `2`) и включает режим длительного сжатия для zstd. Это может помочь достичь лучшего коэффициента сжатия.

Возможные значения: неотрицательные числа. Обратите внимание, что если значение слишком мало или слишком велико, `zstdlib` вызовет исключение. Типичные значения составляют от `20` (размер окна = `1MB`) до `30` (размер окна = `1GB`).

## output_format_parallel_formatting {#output_format_parallel_formatting} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает или отключает параллельное форматирование данных. Поддерживается только для форматов [TSV](../../interfaces/formats.md/#tabseparated), [TSKV](../../interfaces/formats.md/#tskv), [CSV](../../interfaces/formats.md/#csv) и [JSONEachRow](../../interfaces/formats.md/#jsoneachrow).

Возможные значения:

- 1 — Включено.
- 0 — Отключено.

## page_cache_block_size {#page_cache_block_size} 

<SettingsInfoBlock type="UInt64" default_value="1048576" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1048576"},{"label": "Настройка, которую можно изменять на уровне запроса."}]}]}/>

Размер файловых блоков, которые необходимо хранить в кэше страниц пользовательского пространства, в байтах. Все чтения, которые проходят через кэш, будут округлены до кратного этого размера.

Эта настройка может быть настроена на уровне каждого запроса, но записи кэша с разными размерами блоков не могут быть повторно использованы. Изменение этой настройки фактически аннулирует существующие записи в кэше.

Большее значение, например, 1 MiB, подходит для высокопроизводительных запросов, а меньшее значение, например, 64 KiB, подходит для запросов с низкой задержкой.

## page_cache_inject_eviction {#page_cache_inject_eviction} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Добавлен кэш страниц пользовательского пространства"}]}]}/>

Кэш страниц пользовательского пространства иногда будет случайным образом аннулировать некоторые страницы. Предназначено для тестирования.

## page_cache_lookahead_blocks {#page_cache_lookahead_blocks} 

<SettingsInfoBlock type="UInt64" default_value="16" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "16"},{"label": "Настройка, которую можно изменять на уровне запроса."}]}]}/>

При пропуске кэша страниц пользовательского пространства прочитать до этого количества последовательных блоков сразу из базового хранилища, если они также не находятся в кэше. Каждый блок является `page_cache_block_size` байт.

Большее значение хорошо подходит для высокопроизводительных запросов, в то время как запросы с низкой задержкой будут работать лучше без предзагрузки.

## parallel_distributed_insert_select {#parallel_distributed_insert_select} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Включает параллельный распределенный запрос `INSERT ... SELECT`.

Если мы выполняем запросы `INSERT INTO distributed_table_a SELECT ... FROM distributed_table_b` и обе таблицы используют один и тот же кластер и обе таблицы являются либо [реплицированными](../../engines/table-engines/mergetree-family/replication.md), либо нереплицированными, то этот запрос обрабатывается локально на каждом шарде.

Возможные значения:

- 0 — Отключено.
- 1 — `SELECT` будет выполнен на каждом шарде из базовой таблицы распределенного движка.
- 2 — `SELECT` и `INSERT` будут выполнены на каждом шарде из/в базовую таблицу распределенного движка.

## parallel_hash_join_threshold {#parallel_hash_join_threshold} 

<SettingsInfoBlock type="UInt64" default_value="100000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "100000"},{"label": "Новая настройка"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка"}]}, {"id": "row-3","items": [{"label": "25.3","label": "0"},{"label": "Новая настройка"}]}]}/>

Когда применяется алгоритм соединения на основе хеширования, этот порог помогает решить, использовать `hash` или `parallel_hash` (только в случае, если оценка размера правой таблицы доступна).
Первый используется, когда мы знаем, что размер правой таблицы ниже порога.

## parallel_replica_offset {#parallel_replica_offset} 

<BetaBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

Это внутренняя настройка, которая не должна использоваться напрямую и представляет собой деталь реализации режима "параллельные реплики". Эта настройка будет автоматически настроена сервером-инициатором для распределенных запросов к индексу реплики, участвующей в обработке запроса среди параллельных реплик.

## parallel_replicas_allow_in_with_subquery {#parallel_replicas_allow_in_with_subquery} 

<BetaBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Если true, подзапрос для IN будет выполняться на каждой последовательной реплике"}]}]}/>

Если true, подзапрос для IN будет выполняться на каждой последовательной реплике.

## parallel_replicas_count {#parallel_replicas_count} 

<BetaBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

Это внутренняя настройка, которая не должна использоваться напрямую и представляет собой деталь реализации режима "параллельные реплики". Эта настройка будет автоматически настроена сервером-инициатором для распределенных запросов к количеству параллельных реплик, участвующих в обработке запроса.

## parallel_replicas_custom_key {#parallel_replicas_custom_key} 

<BetaBadge/>

Произвольное целочисленное выражение, которое можно использовать для разделения работы между репликами для конкретной таблицы. Значение может быть любым целочисленным выражением.

Предпочтительны простые выражения с использованием первичных ключей.

Если эта настройка используется в кластере, состоящем из одного шара с несколькими репликами, эти реплики будут преобразованы в виртуальные шарды. В противном случае она будет работать так же, как для ключа `SAMPLE`, будет использовать несколько реплик каждого шара.

## parallel_replicas_custom_key_range_lower {#parallel_replicas_custom_key_range_lower} 

<BetaBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Добавить настройки для управления диапазоном фильтра при использовании параллельных реплик с динамическими шарами"}]}]}/>

Позволяет типу фильтра `range` равномерно распределять работу между репликами на основе настраиваемого диапазона `[parallel_replicas_custom_key_range_lower, INT_MAX]`.

При использовании совместно с [parallel_replicas_custom_key_range_upper](#parallel_replicas_custom_key_range_upper) это позволяет фильтру равномерно делить работу над репликами для диапазона `[parallel_replicas_custom_key_range_lower, parallel_replicas_custom_key_range_upper]`.

Примечание: Эта настройка не приведет к дополнительному фильтрации данных во время обработки запроса, скорее она меняет точки, в которых диапазон фильтра разбивает диапазон `[0, INT_MAX]` для параллельной обработки.

## parallel_replicas_custom_key_range_upper {#parallel_replicas_custom_key_range_upper} 

<BetaBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Добавить настройки для управления диапазоном фильтра при использовании параллельных реплик с динамическими шарами. Значение 0 отключает верхний предел"}]}]}/>

Позволяет типу фильтра `range` равномерно распределять работу между репликами на основе настраиваемого диапазона `[0, parallel_replicas_custom_key_range_upper]`. Значение 0 отключает верхний предел, устанавливая его на максимальное значение выражения настраиваемого ключа.

При использовании совместно с [parallel_replicas_custom_key_range_lower](#parallel_replicas_custom_key_range_lower) это позволяет фильтру равномерно делить работу над репликами для диапазона `[parallel_replicas_custom_key_range_lower, parallel_replicas_custom_key_range_upper]`.

Примечание: Эта настройка не приведет к дополнительной фильтрации данных во время обработки запроса, скорее она меняет точки, в которых диапазон фильтра разбивает диапазон `[0, INT_MAX]` для параллельной обработки.

## parallel_replicas_for_cluster_engines {#parallel_replicas_for_cluster_engines} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "1"},{"label": "Новая настройка."}]}]}/>

Заменяет движки табличных функций на альтернативы с кластером.

## parallel_replicas_for_non_replicated_merge_tree {#parallel_replicas_for_non_replicated_merge_tree} 

<BetaBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

Если true, ClickHouse будет использовать алгоритм параллельных реплик также для нереплицированных таблиц MergeTree.

## parallel_replicas_index_analysis_only_on_coordinator {#parallel_replicas_index_analysis_only_on_coordinator} 

<BetaBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "1"},{"label": "Анализ индексов выполняется только на реплике-координаторе и пропускается на других репликах. Эффективно только при включенном parallel_replicas_local_plan"}]}, {"id": "row-2","items": [{"label": "24.10"},{"label": "1"},{"label": "Анализ индексов выполняется только на реплике-координаторе и пропускается на других репликах. Эффективно только при включенном parallel_replicas_local_plan"}]}]}/>

Анализ индексов выполняется только на реплике-координаторе и пропускается на других репликах. Эффективно только при включенном parallel_replicas_local_plan.

## parallel_replicas_insert_select_local_pipeline {#parallel_replicas_insert_select_local_pipeline} 

<BetaBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Использовать локальный конвейер во время распределенного INSERT SELECT с параллельными репликами. В настоящее время отключено из-за проблем с производительностью"}]}, {"id": "row-2","items": [{"label": "25.4"},{"label": "0"},{"label": "Использовать локальный конвейер во время распределенного INSERT SELECT с параллельными репликами. В настоящее время отключено из-за проблем с производительностью"}]}]}/>

Использовать локальный конвейер во время распределенного INSERT SELECT с параллельными репликами.

## parallel_replicas_local_plan {#parallel_replicas_local_plan} 

<BetaBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Использовать локальный план для локальной реплики в запросе с параллельными репликами"}]}, {"id": "row-2","items": [{"label": "24.11"},{"label": "1"},{"label": "Использовать локальный план для локальной реплики в запросе с параллельными репликами"}]}, {"id": "row-3","items": [{"label": "24.10"},{"label": "1"},{"label": "Использовать локальный план для локальной реплики в запросе с параллельными репликами"}]}]}/>

Создать локальный план для локальной реплики.

## parallel_replicas_mark_segment_size {#parallel_replicas_mark_segment_size} 

<BetaBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.9"},{"label": "0"},{"label": "Значение для этой настройки теперь определяется автоматически"}]}, {"id": "row-2","items": [{"label": "24.1","label": "128"},{"label": "Добавить новую настройку для управления размером сегмента в новой реализации координатора параллельных реплик"}]}]}/>

Части виртуально разделены на сегменты, которые будут распределены между репликами для параллельного чтения. Эта настройка контролирует размер этих сегментов. Не рекомендуется изменять, пока вы не будете абсолютно уверены в том, что делаете. Значение должно быть в диапазоне [128; 16384].

## parallel_replicas_min_number_of_rows_per_replica {#parallel_replicas_min_number_of_rows_per_replica} 

<BetaBadge/>

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничивает количество реплик, используемых в запросе, до (предполагаемые строки для чтения / min_number_of_rows_per_replica). Максимум по-прежнему ограничен параметром 'max_parallel_replicas'.

## parallel_replicas_mode {#parallel_replicas_mode} 

<BetaBadge/>

<SettingsInfoBlock type="ParallelReplicasMode" default_value="read_tasks" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "read_tasks"},{"label": "Эта настройка была введена как часть реализации функции параллельных реплик в режиме Beta"}]}]}/>

Тип фильтра, который следует использовать с настраиваемым ключом для параллельных реплик. По умолчанию — использовать операцию модуля на настраиваемом ключе, диапазон — использовать диапазонный фильтр на настраиваемом ключе, используя все возможные значения для типа значения настраиваемого ключа.

## parallel_replicas_only_with_analyzer {#parallel_replicas_only_with_analyzer} 

<BetaBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Параллельные реплики поддерживаются только при включенном анализаторе"}]}]}/>

Анализатор должен быть включен для использования параллельных реплик. При отключенном анализаторе выполнение запроса переходит к локальному выполнению, даже если включено параллельное чтение из реплик. Использование параллельных реплик без включенного анализатора не поддерживается.

## parallel_replicas_prefer_local_join {#parallel_replicas_prefer_local_join} 

<BetaBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Если true, и JOIN может быть выполнен с алгоритмом параллельных реплик, и все хранилища правой части JOIN являются *MergeTree, будет использоваться локальный JOIN вместо GLOBAL JOIN."}]}]}/>

Если true, и JOIN может быть выполнен с алгоритмом параллельных реплик, и все хранилища правой стороны JOIN являются *MergeTree, будет использоваться локальный JOIN вместо GLOBAL JOIN.

## parallel_view_processing {#parallel_view_processing} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает одновременную отправку к связанным представлениям вместо последовательной.
```yaml
title: 'Параметры конфигурации ClickHouse'
sidebar_label: 'Параметры конфигурации'
keywords: ['clickhouse', 'настройки', 'конфигурация']
description: 'Документация по параметрам конфигурации ClickHouse.'
```

## parallelize_output_from_storages {#parallelize_output_from_storages} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.5"},{"label": "1"},{"label": "Разрешить параллелизм при выполнении запросов, читающих из файла/url/s3 и т.д. Это может изменить порядок строк."}]}]}/>

Параллелизация вывода для шага чтения из хранилища. Она позволяет параллелизовать обработку запроса сразу после чтения из хранилища, если это возможно.

## parsedatetime_e_requires_space_padding {#parsedatetime_e_requires_space_padding} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Улучшена совместимость с MySQL DATE_FORMAT/STR_TO_DATE"}]}]}/>

Форматировщик '%e' в функции 'parseDateTime' ожидает, что дни с одной цифрой будут дополнены пробелом, например, ' 2' принимается, а '2' вызывает ошибку.

## parsedatetime_parse_without_leading_zeros {#parsedatetime_parse_without_leading_zeros} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.11"},{"label": "1"},{"label": "Улучшена совместимость с MySQL DATE_FORMAT/STR_TO_DATE"}]}]}/>

Форматировщики '%c', '%l' и '%k' в функции 'parseDateTime' обрабатывают месяцы и часы без начальных нулей.

## partial_merge_join_left_table_buffer_bytes {#partial_merge_join_left_table_buffer_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если не 0, группировать блоки левой таблицы в более крупные для левой стороны в алгоритме частичного соединения. Использует до 2x указанной памяти на поток соединения.

## partial_merge_join_rows_in_right_blocks {#partial_merge_join_rows_in_right_blocks} 

<SettingsInfoBlock type="UInt64" default_value="65536" />

Ограничивает размеры блоков данных правого соединения в алгоритме частичного соединения для запросов [JOIN](../../sql-reference/statements/select/join.md).

Сервер ClickHouse:

1.  Разделяет данные правого соединения на блоки с количеством строк до указанного значения.
2.  Индексирует каждый блок по его минимальным и максимальным значениям.
3.  Выгружает подготовленные блоки на диск, если это возможно.

Возможные значения:

- Любое положительное целое. Рекомендуемый диапазон значений: \[1000, 100000\].

## partial_result_on_first_cancel {#partial_result_on_first_cancel} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет запросу вернуть частичный результат после отмены.

## parts_to_delay_insert {#parts_to_delay_insert} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если целевая таблица содержит хотя бы столько активных частей в одной партиции, искусственно замедлить вставку в таблицу.

## parts_to_throw_insert {#parts_to_throw_insert} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Если больше, чем это число активных частей в одной партиции целевой таблицы, выбросить исключение 'Слишком много частей ...'.

## periodic_live_view_refresh {#periodic_live_view_refresh} 

<SettingsInfoBlock type="Seconds" default_value="60" />

Интервал, по истечении которого периодически обновляемый live-представление принудительно обновляется.

## poll_interval {#poll_interval} 

<SettingsInfoBlock type="UInt64" default_value="10" />

Блокировать на сервере в цикле ожидания запроса в течение указанного количества секунд.

## postgresql_connection_attempt_timeout {#postgresql_connection_attempt_timeout} 

<SettingsInfoBlock type="UInt64" default_value="2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "2"},{"label": "Позволяет управлять параметром 'connect_timeout' соединения PostgreSQL."}]}]}/>

Тайм-аут соединения в секундах для одной попытки подключения к конечной точке PostgreSQL. Значение передается как параметр `connect_timeout` URL подключения.

## postgresql_connection_pool_auto_close_connection {#postgresql_connection_pool_auto_close_connection} 

<SettingsInfoBlock type="Bool" default_value="0" />

Закрывать соединение перед возвратом его в пул.

## postgresql_connection_pool_retries {#postgresql_connection_pool_retries} 

<SettingsInfoBlock type="UInt64" default_value="2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "2"},{"label": "Позволяет управлять количеством повторных попыток в пуле соединений PostgreSQL."}]}]}/>

Количество попыток push/pop для пула соединений PostgreSQL и движка таблицы.

## postgresql_connection_pool_size {#postgresql_connection_pool_size} 

<SettingsInfoBlock type="UInt64" default_value="16" />

Размер пула соединений для движка таблицы PostgreSQL и движка базы данных.

## postgresql_connection_pool_wait_timeout {#postgresql_connection_pool_wait_timeout} 

<SettingsInfoBlock type="UInt64" default_value="5000" />

Тайм-аут push/pop в пуле соединений на пустом пуле для движка таблицы PostgreSQL и движка базы данных. По умолчанию он заблокирует на пустом пуле.

## postgresql_fault_injection_probability {#postgresql_fault_injection_probability} 

<SettingsInfoBlock type="Float" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Приблизительная вероятность сбоя внутренних (для репликации) запросов PostgreSQL. Допустимое значение находится в интервале [0.0f, 1.0f].

## prefer_column_name_to_alias {#prefer_column_name_to_alias} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает использование оригинальных имён колонок вместо псевдонимов в выражениях и частях запросов. Это особенно важно, когда псевдоним совпадает с именем колонки, см. [Псевдонимы выражений](/sql-reference/syntax#notes-on-usage). Включите эту настройку, чтобы сделать правила синтаксиса псевдонимов в ClickHouse более совместимыми с большинством других движков баз данных.

Возможные значения:

- 0 — Имя колонки заменяется псевдонимом.
- 1 — Имя колонки не заменяется псевдонимом.

**Пример**

Разница между включенным и выключенным:

Запрос:

```sql
SET prefer_column_name_to_alias = 0;
SELECT avg(number) AS number, max(number) FROM numbers(10);
```

Результат:

```text
Получена ошибка от сервера (версия 21.5.1):
Код: 184. DB::Exception: Получено от localhost:9000. DB::Exception: Агрегатная функция avg(number) найдена внутри другой агрегатной функции в запросе: Во время обработки avg(number) AS number.
```

Запрос:

```sql
SET prefer_column_name_to_alias = 1;
SELECT avg(number) AS number, max(number) FROM numbers(10);
```

Результат:

```text
┌─number─┬─max(number)─┐
│    4.5 │           9 │
└────────┴─────────────┘
```

## prefer_external_sort_block_bytes {#prefer_external_sort_block_bytes} 

<SettingsInfoBlock type="UInt64" default_value="16744704" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.5"},{"label": "16744704"},{"label": "Предпочитать максимальный размер блока для внешней сортировки, уменьшить использование памяти во время слияния."}]}]}/>

Предпочитать максимальный размер блока для внешней сортировки, уменьшить использование памяти во время слияния.

## prefer_global_in_and_join {#prefer_global_in_and_join} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает замену операторов `IN`/`JOIN` на `GLOBAL IN`/`GLOBAL JOIN`.

Возможные значения:

- 0 — Отключено. Операторы `IN`/`JOIN` не заменяются на `GLOBAL IN`/`GLOBAL JOIN`.
- 1 — Включено. Операторы `IN`/`JOIN` заменяются на `GLOBAL IN`/`GLOBAL JOIN`.

**Использование**

Хотя `SET distributed_product_mode=global` может изменить поведение запросов для распределенных таблиц, он не подходит для локальных таблиц или таблиц из внешних ресурсов. Здесь в игру вступает настройка `prefer_global_in_and_join`.

Например, у нас есть узлы, обслуживающие запросы, которые содержат локальные таблицы, не подходящие для распределения. Нам нужно распределить их данные на лету во время распределенной обработки с использованием ключевого слова `GLOBAL` — `GLOBAL IN`/`GLOBAL JOIN`.

Другим случаем использования `prefer_global_in_and_join` является доступ к таблицам, созданным внешними движками. Эта настройка помогает сократить количество вызовов во внешние источники при соединении таких таблиц: всего один вызов на запрос.

**Смотрите также:**

- [Распределённые подзапросы](/sql-reference/operators/in#distributed-subqueries) для получения дополнительной информации о том, как использовать `GLOBAL IN`/`GLOBAL JOIN`.

## prefer_localhost_replica {#prefer_localhost_replica} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает/отключает предпочтительное использование localhost реплики при обработке распределенных запросов.

Возможные значения:

- 1 — ClickHouse всегда отправляет запрос на localhost реплику, если она существует.
- 0 — ClickHouse использует стратегию баланса, указанную в настройке [load_balancing](#load_balancing).

:::note
Отключите эту настройку, если вы используете [max_parallel_replicas](#max_parallel_replicas) без [parallel_replicas_custom_key](#parallel_replicas_custom_key).
Если [parallel_replicas_custom_key](#parallel_replicas_custom_key) установлен, отключите эту настройку только если она используется на кластере с несколькими шардированными частями, содержащими несколько реплик.
Если она используется на кластере с одной шардой и несколькими репликами, отключение этой настройки даст негативные результаты.
:::

## prefer_warmed_unmerged_parts_seconds {#prefer_warmed_unmerged_parts_seconds} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Int64" default_value="0" />

Эта настройка имеет эффект только в ClickHouse Cloud. Если объединённая часть меньше этого количества секунд и не была предварительно разогрета (см. [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch)), но все её исходные части доступны и предварительно разогреты, SELECT запросы будут читать из этих частей вместо этого. Только для Replicated-/SharedMergeTree. Обратите внимание, что эта проверка лишь удостоверяется в том, что CacheWarmer обработал часть; если часть была извлечена в кэш чем-то другим, она всё равно будет считаться холодной, пока CacheWarmer не доберётся до неё; если она была разогрета и затем исключена из кэша, она всё равно будет считаться разогретой.

## preferred_block_size_bytes {#preferred_block_size_bytes} 

<SettingsInfoBlock type="UInt64" default_value="1000000" />

Эта настройка корректирует размер блока данных для обработки запросов и представляет собой дополнительную тонкую настройку для более грубой настройки 'max_block_size'. Если колонки большие и с 'max_block_size' строк размер блока, вероятно, будет больше указанного значения в байтах, его размер будет уменьшен для лучшей локальности кэша CPU.

## preferred_max_column_in_block_size_bytes {#preferred_max_column_in_block_size_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Ограничение на максимальный размер колонки в блоке при считывании. Помогает снизить количество промахов кэша. Должен быть близок к размеру кэша L2.

## preferred_optimize_projection_name {#preferred_optimize_projection_name} 

Если установлено в непустую строку, ClickHouse будет пытаться применить указанную проекцию в запросе.

Возможные значения:

- строка: имя предпочтительной проекции.

## prefetch_buffer_size {#prefetch_buffer_size} 

<SettingsInfoBlock type="UInt64" default_value="1048576" />

Максимальный размер буфера предварительной выборки для чтения из файловой системы.

## print_pretty_type_names {#print_pretty_type_names} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "1"},{"label": "Лучший пользовательский опыт."}]}]}/>

Позволяет красиво выводить имена глубоко вложенных типов с отступами в запросе `DESCRIBE` и в функции `toTypeName()`.

Пример:

```sql
CREATE TABLE test (a Tuple(b String, c Tuple(d Nullable(UInt64), e Array(UInt32), f Array(Tuple(g String, h Map(String, Array(Tuple(i String, j UInt64))))), k Date), l Nullable(String))) ENGINE=Memory;
DESCRIBE TABLE test FORMAT TSVRaw SETTINGS print_pretty_type_names=1;
```

```
a   Tuple(
    b String,
    c Tuple(
        d Nullable(UInt64),
        e Array(UInt32),
        f Array(Tuple(
            g String,
            h Map(
                String,
                Array(Tuple(
                    i String,
                    j UInt64
                ))
            )
        )),
        k Date
    ),
    l Nullable(String)
)
```

## priority {#priority} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Приоритет запроса. 1 - самый высокий, более высокое значение - более низкий приоритет; 0 - не использовать приоритеты.

## push_external_roles_in_interserver_queries {#push_external_roles_in_interserver_queries} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Новая настройка."}]}]}/>

Включить передачу пользовательских ролей от инициатора к другим узлам во время выполнения запроса.

## query_cache_compress_entries {#query_cache_compress_entries} 

<SettingsInfoBlock type="Bool" default_value="1" />

Сжимать записи в [кэше запросов](../query-cache.md). Уменьшает использование памяти кэша запросов за счет медленнее вставок в него / чтения из него.

Возможные значения:

- 0 - Отключено
- 1 - Включено

## query_cache_max_entries {#query_cache_max_entries} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество результатов запросов, которые текущий пользователь может хранить в [кэше запросов](../query-cache.md). 0 означает неограниченно.

Возможные значения:

- Положительное целое число >= 0.

## query_cache_max_size_in_bytes {#query_cache_max_size_in_bytes} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество памяти (в байтах), которую текущий пользователь может выделить в [кэше запросов](../query-cache.md). 0 означает неограниченно.

Возможные значения:

- Положительное целое число >= 0.

## query_cache_min_query_duration {#query_cache_min_query_duration} 

<SettingsInfoBlock type="Milliseconds" default_value="0" />

Минимальная продолжительность в миллисекундах, в течение которой запрос должен выполняться, чтобы его результат хранился в [кэше запросов](../query-cache.md).

Возможные значения:

- Положительное целое число >= 0.

## query_cache_min_query_runs {#query_cache_min_query_runs} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Минимальное количество раз, которое `SELECT` запрос должен быть выполнен, прежде чем его результат будет сохранен в [кэше запросов](../query-cache.md).

Возможные значения:

- Положительное целое число >= 0.

## query_cache_nondeterministic_function_handling {#query_cache_nondeterministic_function_handling} 

<SettingsInfoBlock type="QueryResultCacheNondeterministicFunctionHandling" default_value="throw" />

Управляет тем, как [кэш запросов](../query-cache.md) обрабатывает `SELECT` запросы с недетерминированными функциями, такими как `rand()` или `now()`.

Возможные значения:

- `'throw'` - Создавать исключение и не кэшировать результат запроса.
- `'save'` - Кэшировать результат запроса.
- `'ignore'` - Не кэшировать результат запроса и не создавать исключение.

## query_cache_share_between_users {#query_cache_share_between_users} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, результат `SELECT` запросов, кэшируемых в [кэше запросов](../query-cache.md), может быть прочитан другими пользователями. Рекомендуется не включать эту настройку по соображениям безопасности.

Возможные значения:

- 0 - Отключено
- 1 - Включено

## query_cache_squash_partial_results {#query_cache_squash_partial_results} 

<SettingsInfoBlock type="Bool" default_value="1" />

Сжимать блоки частичных результатов в блоки размером [max_block_size](#max_block_size). Уменьшает производительность вставок в [кэш запросов](../query-cache.md), но улучшает сжимаемость записей кэша (см. [query_cache_compress_entries](#query_cache_compress_entries)).

Возможные значения:

- 0 - Отключено
- 1 - Включено

## query_cache_system_table_handling {#query_cache_system_table_handling} 

<SettingsInfoBlock type="QueryResultCacheSystemTableHandling" default_value="throw" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "throw"},{"label": "Кэш запросов больше не кэширует результаты запросов к системным таблицам"}]}]}/>

Управляет тем, как [кэш запросов](../query-cache.md) обрабатывает `SELECT` запросы к системным таблицам, т.е. таблицам в базах данных `system.*` и `information_schema.*`.

Возможные значения:

- `'throw'` - Создавать исключение и не кэшировать результат запроса.
- `'save'` - Кэшировать результат запроса.
- `'ignore'` - Не кэшировать результат запроса и не создавать исключение.

## query_cache_tag {#query_cache_tag} 

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": ""},{"label": "Новая настройка для маркировки параметров кэша запросов."}]}]}/>

Строка, которая выступает в качестве метки для записей [кэша запросов](../query-cache.md). Одни и те же запросы с разными метками считаются разными кэшем запросов.

Возможные значения:

- Любая строка.

## query_cache_ttl {#query_cache_ttl} 

<SettingsInfoBlock type="Seconds" default_value="60" />

После этого времени в секундах записи в [кэше запросов](../query-cache.md) становятся устаревшими.

Возможные значения:

- Положительное целое число >= 0.

## query_condition_cache_store_conditions_as_plaintext {#query_condition_cache_store_conditions_as_plaintext} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Сохраняет фильтрационное условие для [кэша условий запросов](/operations/query-condition-cache) в открытом виде. Если включено, system.query_condition_cache показывает вербальное фильтрационное условие, что облегчает отладку проблем с кэшем. Отключено по умолчанию, так как открытые фильтрационные условия могут раскрыть конфиденциальную информацию.

Возможные значения:

- 0 - Отключено
- 1 - Включено

## query_metric_log_interval {#query_metric_log_interval} 

<SettingsInfoBlock type="Int64" default_value="-1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "-1"},{"label": "Новая настройка."}]}]}/>

Интервал в миллисекундах, через который собирается [query_metric_log](../../operations/system-tables/query_metric_log.md) для отдельных запросов.

Если установить в любое отрицательное значение, оно примет значение `collect_interval_milliseconds` из настройки [query_metric_log](/operations/server-configuration-parameters/settings#query_metric_log) или по умолчанию составит 1000, если не установлено.

Чтобы отключить сбор для отдельного запроса, установите `query_metric_log_interval` в 0.

Значение по умолчанию: -1.

## query_plan_aggregation_in_order {#query_plan_aggregation_in_order} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.12"},{"label": "1"},{"label": "Включить некоторые изменения вокруг плана запроса"}]}]}/>

Включает оптимизацию уровня плана запроса агрегации в порядке.

Эта настройка вступает в силу только если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка уровня эксперта, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимым образом или быть удалена.
:::

Возможные значения:

- 0 - Отключить
- 1 - Включить

## query_plan_convert_join_to_in {#query_plan_convert_join_to_in} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Разрешает преобразование JOIN в подзапрос с IN, если выходные колонки привязаны только к левой таблице.

## query_plan_convert_outer_join_to_inner_join {#query_plan_convert_outer_join_to_inner_join} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "1"},{"label": "Разрешить преобразование OUTER JOIN в INNER JOIN, если фильтр после JOIN всегда фильтрует значения по умолчанию"}]}]}/>

Разрешить преобразование OUTER JOIN в INNER JOIN, если фильтр после JOIN всегда фильтрует значения по умолчанию.

## query_plan_enable_multithreading_after_window_functions {#query_plan_enable_multithreading_after_window_functions} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает многопоточность после оценки оконных функций для поддержки параллельной потоковой обработки.

## query_plan_enable_optimizations {#query_plan_enable_optimizations} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию запросов на уровне плана запроса.

:::note
Это настройка уровня эксперта, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимым образом или быть удалена.
:::

Возможные значения:

- 0 - Отключить все оптимизации на уровне плана запроса.
- 1 - Включить оптимизации на уровне плана запроса (но отдельные оптимизации все еще могут быть отключены через их индивидуальные настройки).

## query_plan_execute_functions_after_sorting {#query_plan_execute_functions_after_sorting} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию уровня плана запроса, которая перемещает выражения после шагов сортировки. Эта настройка вступает в силу только если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка уровня эксперта, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимым образом или быть удалена.
:::

Возможные значения:

- 0 - Отключить
- 1 - Включить

## query_plan_filter_push_down {#query_plan_filter_push_down} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию уровня плана запроса, которая перемещает фильтры вниз в плане выполнения. Эта настройка вступает в силу только если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка уровня эксперта, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимым образом или быть удалена.
:::

Возможные значения:

- 0 - Отключить
- 1 - Включить

## query_plan_join_shard_by_pk_ranges {#query_plan_join_shard_by_pk_ranges} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Применяет шардирование для JOIN, если ключи соединения содержат префикс ПЕРВИЧНОГО КЛЮЧА для обеих таблиц. Поддерживается для алгоритмов hash, parallel_hash и full_sorting_merge.

## query_plan_join_swap_table {#query_plan_join_swap_table} 

<SettingsInfoBlock type="BoolAuto" default_value="auto" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "auto"},{"label": "Новая настройка. Правая таблица всегда выбиралась раньше."}]}]}/>

Определяет, какая сторона соединения должна быть таблицей-строителем (также называемой внутренней, той, которая вставляется в хеш-таблицу для хеш-соединения) в плане запроса. Эта настройка поддерживается только для строгих соединений `ALL` с предложением `JOIN ON`. Возможные значения:

- 'auto': Позволить планировщику решить, какую таблицу использовать в качестве таблицы-строителя.
- 'false': Никогда не менять таблицы (правая таблица — это таблица-строитель).
- 'true': Всегда менять таблицы (левая таблица — это таблица-строитель).

## query_plan_lift_up_array_join {#query_plan_lift_up_array_join} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию уровня плана запроса, которая перемещает ARRAY JOIN выше в плане выполнения. Эта настройка вступает в силу только если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка уровня эксперта, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимым образом или быть удалена.
:::

Возможные значения:

- 0 - Отключить
- 1 - Включить

## query_plan_lift_up_union {#query_plan_lift_up_union} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию уровня плана запроса, которая перемещает большие поддеревья плана запроса в объединение для включения дальнейших оптимизаций. Эта настройка вступает в силу только если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка уровня эксперта, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимым образом или быть удалена.
:::

Возможные значения:

- 0 - Отключить
- 1 - Включить

## query_plan_max_limit_for_lazy_materialization {#query_plan_max_limit_for_lazy_materialization} 

<SettingsInfoBlock type="UInt64" default_value="10" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "10"},{"label": "Добавлена новая настройка для управления максимальным лимитом, позволяющим использовать план запроса для оптимизации ленивой материализации. Если 0, лимита нет."}]}]}/>

Управляет максимальным лимитом, позволяющим использовать план запроса для оптимизации ленивой материализации. Если 0, лимита нет.

## query_plan_max_optimizations_to_apply {#query_plan_max_optimizations_to_apply} 

<SettingsInfoBlock type="UInt64" default_value="10000" />

Ограничивает общее количество оптимизаций, применяемых к плану запроса, см. настройку [query_plan_enable_optimizations](#query_plan_enable_optimizations).
Полезно для избежания долгого времени оптимизации для сложных запросов.
В запросе EXPLAIN PLAN прекратите применение оптимизаций после достижения этого лимита и верните план таким, каким он есть.
Для обычного выполнения запроса, если фактическое количество оптимизаций превышает эту настройку, будет выброшено исключение.

:::note
Это настройка уровня эксперта, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимым образом или быть удалена.
:::

## query_plan_merge_expressions {#query_plan_merge_expressions} 

<SettingsInfoBlock type="Bool" default_value="1" />

Переключает оптимизацию уровня плана запроса, которая объединяет последовательные фильтры. Эта настройка вступает в силу только если настройка [query_plan_enable_optimizations](#query_plan_enable_optimizations) равна 1.

:::note
Это настройка уровня эксперта, которая должна использоваться только для отладки разработчиками. Настройка может измениться в будущем несовместимым образом или быть удалена.
:::

Возможные значения:

- 0 - Отключить
- 1 - Включить

## query_plan_merge_filter_into_join_condition {#query_plan_merge_filter_into_join_condition} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "Добавлена новая настройка для объединения фильтров в условие соединения"}]}]}/>

Позволить объединение фильтра в условие JOIN и преобразование CROSS JOIN в INNER.

## query_plan_merge_filters {#query_plan_merge_filters} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "0"},{"label": "Позволить объединять фильтры в плане запроса"}]}, {"id": "row-2","items": [{"label": "24.11"},{"label": "1"},{"label": "Позволить объединять фильтры в плане запроса. Это необходимо для корректной поддержки переноса фильтров с новым анализатором."}]}]}/>

Позволять объединять фильтры в плане запроса.
```yaml
title: 'Использование порядка хранения для повторного использования плана запроса для оконных функций'
sidebar_label: 'Использование порядка хранения для оконных функций'
keywords: ['использование', 'порядок', 'хранение', 'повторное использование', 'план запроса', 'оконные функции']
description: 'Оптимизация плана запроса, использующая порядок хранения при сортировке для оконных функций.'
```

## query_plan_reuse_storage_ordering_for_window_functions {#query_plan_reuse_storage_ordering_for_window_functions} 



<SettingsInfoBlock type="Bool" default_value="1" />

Включает оптимизацию на уровне плана запроса, которая использует сортировку хранения при сортировке для оконных функций. 
Эта настройка вступает в силу только в том случае, если параметр [query_plan_enable_optimizations](#query_plan_enable_optimizations) равен 1.

:::note
Эта настройка предназначена для экспертов и должна использоваться только для отладки разработчиками. Настройка может измениться в будущем с несовместимыми изменениями или быть удалена.
:::

Возможные значения:

- 0 - Отключить
- 1 - Включить
## query_plan_split_filter {#query_plan_split_filter} 



<SettingsInfoBlock type="Bool" default_value="1" />

:::note
Эта настройка предназначена для экспертов и должна использоваться только для отладки разработчиками. Настройка может измениться в будущем с несовместимыми изменениями или быть удалена.
:::

Включает оптимизацию на уровне плана запроса, которая разделяет фильтры на выражения.
Эта настройка вступает в силу только в том случае, если параметр [query_plan_enable_optimizations](#query_plan_enable_optimizations) равен 1.

Возможные значения:

- 0 - Отключить
- 1 - Включить
## query_plan_try_use_vector_search {#query_plan_try_use_vector_search} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Новая настройка."}]}]}/>

Включает оптимизацию на уровне плана запроса, которая пытается использовать индекс векторного сходства. 
Эта настройка вступает в силу только в том случае, если параметр [query_plan_enable_optimizations](#query_plan_enable_optimizations) равен 1.

:::note
Эта настройка предназначена для экспертов и должна использоваться только для отладки разработчиками. Настройка может измениться в будущем с несовместимыми изменениями или быть удалена.
:::

Возможные значения:

- 0 - Отключить
- 1 - Включить
## query_plan_use_new_logical_join_step {#query_plan_use_new_logical_join_step} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Включить новый шаг"}]}, {"id": "row-2","items": [{"label": "25.1"},{"label": "0"},{"label": "Новый шаг соединения, внутреннее изменение"}]}]}/>

Использовать новый логический шаг соединения в плане запроса
## query_profiler_cpu_time_period_ns {#query_profiler_cpu_time_period_ns} 



<SettingsInfoBlock type="UInt64" default_value="1000000000" />

Устанавливает период для таймера тактового синхронизатора CPU профайлера запросов [query profiler](../../operations/optimizing-performance/sampling-query-profiler.md). Этот таймер учитывает только время CPU.

Возможные значения:

- Положительное целое число в наносекундах.

    Рекомендуемые значения:

            - 10000000 (100 раз в секунду) наносекунд и больше для единичных запросов.
            - 1000000000 (один раз в секунду) для профилирования на уровне кластера.

- 0 для отключения таймера.

**Временно отключено в ClickHouse Cloud.**

См. также:

- Системная таблица [trace_log](/operations/system-tables/trace_log)
## query_profiler_real_time_period_ns {#query_profiler_real_time_period_ns} 



<SettingsInfoBlock type="UInt64" default_value="1000000000" />

Устанавливает период для реального таймера профайлера запросов [query profiler](../../operations/optimizing-performance/sampling-query-profiler.md). Реальный таймер учитывает время по часам.

Возможные значения:

- Положительное целое число в наносекундах.

    Рекомендуемые значения:

            - 10000000 (100 раз в секунду) наносекунд и меньше для единичных запросов.
            - 1000000000 (один раз в секунду) для профилирования на уровне кластера.

- 0 для отключения таймера.

**Временно отключено в ClickHouse Cloud.**

См. также:

- Системная таблица [trace_log](/operations/system-tables/trace_log)
## queue_max_wait_ms {#queue_max_wait_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время ожидания в очереди запросов, если количество одновременно выполняемых запросов превышает максимальное.
## rabbitmq_max_wait_ms {#rabbitmq_max_wait_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="5000" />

Время ожидания для чтения из RabbitMQ перед повторной попыткой.
## read_backoff_max_throughput {#read_backoff_max_throughput} 



<SettingsInfoBlock type="UInt64" default_value="1048576" />

Настройки для уменьшения числа потоков в случае медленных операций чтения. Учитывает события, когда пропускная способность чтения оказывается меньше указанного количества байт в секунду.
## read_backoff_min_concurrency {#read_backoff_min_concurrency} 



<SettingsInfoBlock type="UInt64" default_value="1" />

Настройки для поддержки минимального количества потоков в случае медленных операций чтения.
## read_backoff_min_events {#read_backoff_min_events} 



<SettingsInfoBlock type="UInt64" default_value="2" />

Настройки для уменьшения числа потоков в случае медленных операций чтения. Указывает количество событий, после которых число потоков будет уменьшено.
## read_backoff_min_interval_between_events_ms {#read_backoff_min_interval_between_events_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="1000" />

Настройки для уменьшения числа потоков в случае медленных операций чтения. Игнорировать событие, если предыдущее событие прошло менее указанного времени.
## read_backoff_min_latency_ms {#read_backoff_min_latency_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="1000" />

Настройка для уменьшения числа потоков в случае медленных операций чтения. Учитывать только чтения, которые заняли не менее указанного времени.
## read_from_filesystem_cache_if_exists_otherwise_bypass_cache {#read_from_filesystem_cache_if_exists_otherwise_bypass_cache} 



<SettingsInfoBlock type="Bool" default_value="0" />

Разрешить использование кеша файловой системы в пассивном режиме - использовать существующие записи кеша, но не добавлять новые записи в кеш. Если вы установите эту настройку для тяжелых ad-hoc запросов и оставите ее отключенной для коротких запросов в реальном времени, это позволит избежать колебаний кеша из-за слишком тяжелых запросов и улучшить общую эффективность системы.
## read_from_page_cache_if_exists_otherwise_bypass_cache {#read_from_page_cache_if_exists_otherwise_bypass_cache} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Добавлено кеширование страниц в пользовательском пространстве"}]}]}/>

Использовать кеш страниц в пользовательском пространстве в пассивном режиме, аналогично read_from_filesystem_cache_if_exists_otherwise_bypass_cache.
## read_in_order_two_level_merge_threshold {#read_in_order_two_level_merge_threshold} 



<SettingsInfoBlock type="UInt64" default_value="100" />

Минимальное количество частей для чтения, чтобы выполнить предварительный этап слияния при многопоточном чтении в порядке первичного ключа.
## read_in_order_use_buffering {#read_in_order_use_buffering} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.7"},{"label": "1"},{"label": "Использовать буферизацию перед слиянием при чтении в порядке первичного ключа"}]}]}/>

Использовать буферизацию перед слиянием при чтении в порядке первичного ключа. Это увеличивает параллелизм выполнения запросов.
## read_in_order_use_virtual_row {#read_in_order_use_virtual_row} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "0"},{"label": "Использовать виртуальную строку при чтении в порядке первичного ключа или его монотонной функции. Это полезно, когда поиск ведется по нескольким частям, так как касаются только релевантных."}]}]}/>

Использовать виртуальную строку при чтении в порядке первичного ключа или его монотонной функции. Это полезно, когда поиск ведется по нескольким частям, так как касаются только релевантных.
## read_overflow_mode {#read_overflow_mode} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Что делать, когда предел превышен.
## read_overflow_mode_leaf {#read_overflow_mode_leaf} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, когда объем прочитанных данных превышает один из предельных значений.

Возможные варианты:
- `throw`: выбросить исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат.
## read_priority {#read_priority} 



<SettingsInfoBlock type="Int64" default_value="0" />

Приоритет для чтения данных из локальной файловой системы или удаленной файловой системы. Поддерживается только для метода 'pread_threadpool' для локальной файловой системы и для метода `threadpool` для удаленной файловой системы.
## read_through_distributed_cache {#read_through_distributed_cache} 

<CloudOnlyBadge/>



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Эта настройка имеет эффект только в ClickHouse Cloud. Разрешить чтение из распределенного кеша.
## readonly {#readonly} 



<SettingsInfoBlock type="UInt64" default_value="0" />

0 - нет ограничений на чтение. 1 - только запросы на чтение, а также изменение явно разрешенных настроек. 2 - только запросы на чтение, а также изменение настроек, кроме настройки 'readonly'.
## receive_data_timeout_ms {#receive_data_timeout_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="2000" />

Таймаут соединения для получения первого пакета данных или пакета с положительным прогрессом от реплики.
## receive_timeout {#receive_timeout} 



<SettingsInfoBlock type="Seconds" default_value="300" />

Таймаут для получения данных из сети, в секундах. Если байты не были получены в этом интервале, выбрасывается исключение. Если вы установите эту настройку на клиенте, таймаут 'send_timeout' для сокета также будет установлен на соответствующем конечном соединении на сервере.
## regexp_max_matches_per_row {#regexp_max_matches_per_row} 



<SettingsInfoBlock type="UInt64" default_value="1000" />

Устанавливает максимальное количество совпадений для одного регулярного выражения на строку. Используйте это для защиты от перегрузки памяти при использовании жадного регулярного выражения в функции [extractAllGroupsHorizontal](/sql-reference/functions/string-search-functions#extractallgroupshorizontal).

Возможные значения:

- Положительное целое число.
## reject_expensive_hyperscan_regexps {#reject_expensive_hyperscan_regexps} 



<SettingsInfoBlock type="Bool" default_value="1" />

Отклонять шаблоны, которые, вероятно, будут дорогими для оценки с помощью hyperscan (из-за взрыва состояния NFA).
## remerge_sort_lowered_memory_bytes_ratio {#remerge_sort_lowered_memory_bytes_ratio} 



<SettingsInfoBlock type="Float" default_value="2" />

Если использование памяти после повторного слияния не снизится на это соотношение, повторное слияние будет отключено.
## remote_filesystem_read_method {#remote_filesystem_read_method} 



<SettingsInfoBlock type="String" default_value="threadpool" />

Метод чтения данных из удаленной файловой системы, один из: read, threadpool.
## remote_filesystem_read_prefetch {#remote_filesystem_read_prefetch} 



<SettingsInfoBlock type="Bool" default_value="1" />

Следует использовать предварительное чтение при чтении данных из удаленной файловой системы.
## remote_fs_read_backoff_max_tries {#remote_fs_read_backoff_max_tries} 



<SettingsInfoBlock type="UInt64" default_value="5" />

Максимальное количество попыток чтения с применением отката.
## remote_fs_read_max_backoff_ms {#remote_fs_read_max_backoff_ms} 



<SettingsInfoBlock type="UInt64" default_value="10000" />

Максимальное время ожидания при попытке чтения данных с удаленного диска.
## remote_read_min_bytes_for_seek {#remote_read_min_bytes_for_seek} 



<SettingsInfoBlock type="UInt64" default_value="4194304" />

Минимальное количество байтов, необходимых для удаленного чтения (url, s3), чтобы осуществить переход, вместо чтения с игнорированием.
## rename_files_after_processing {#rename_files_after_processing} 

- **Тип:** String

- **Значение по умолчанию:** Пустая строка

Эта настройка позволяет указать шаблон переименования для файлов, обработанных с помощью функции таблицы `file`. Когда параметр установлен, все файлы, прочитанные функцией таблицы `file`, будут переименованы в соответствии с указанным шаблоном с заполнителями, только если обработка файлов была успешной.
### Заполнители

- `%a` — Полное оригинальное имя файла (например, "sample.csv").
- `%f` — Оригинальное имя файла без расширения (например, "sample").
- `%e` — Оригинальное расширение файла с точкой (например, ".csv").
- `%t` — Временная метка (в микросекундах).
- `%%` — Символ процента ("%").
### Пример
- Параметр: `--rename_files_after_processing="processed_%f_%t%e"`

- Запрос: `SELECT * FROM file('sample.csv')`

Если чтение `sample.csv` прошло успешно, файл будет переименован в `processed_sample_1683473210851438.csv`.
## replace_running_query {#replace_running_query} 



<SettingsInfoBlock type="Bool" default_value="0" />

При использовании HTTP интерфейса можно передать параметр 'query_id'. Это любая строка, которая служит идентификатором запроса. 
Если в это время уже существует запрос от того же пользователя с тем же 'query_id', поведение зависит от параметра 'replace_running_query'.

`0` (по умолчанию) – Выбросить исключение (не позволять выполнять запрос, если запрос с тем же 'query_id' уже выполняется).

`1` – Отменить старый запрос и начать выполнять новый.

Установите этот параметр в 1 для реализации предложений об условиях сегментации. После ввода следующего символа, если старый запрос еще не завершен, он должен быть отменен.
## replace_running_query_max_wait_ms {#replace_running_query_max_wait_ms} 



<SettingsInfoBlock type="Milliseconds" default_value="5000" />

Время ожидания завершения запроса с тем же `query_id`, когда активна настройка [replace_running_query](#replace_running_query).

Возможные значения:

- Положительное целое число.
- 0 — Выбрасывание исключения, которое не позволяет запустить новый запрос, если сервер уже выполняет запрос с тем же `query_id`.
## replication_wait_for_inactive_replica_timeout {#replication_wait_for_inactive_replica_timeout} 



<SettingsInfoBlock type="Int64" default_value="120" />

Указывает, как долго (в секундах) ждать, пока неактивные реплики выполнят запросы [ALTER](../../sql-reference/statements/alter/index.md), [OPTIMIZE](../../sql-reference/statements/optimize.md) или [TRUNCATE](../../sql-reference/statements/truncate.md).

Возможные значения:

- 0 — Не ждать.
- Отрицательное целое число — Ждать неограниченное время.
- Положительное целое число — количество секунд ожидания.
## restore_replace_external_dictionary_source_to_null {#restore_replace_external_dictionary_source_to_null} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Заменить источники внешнего словаря на Null при восстановлении. Полезно для тестирования.
## restore_replace_external_engines_to_null {#restore_replace_external_engines_to_null} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Для тестирования. Заменяет все внешние движки на Null, чтобы не инициировать внешние соединения.
## restore_replace_external_table_functions_to_null {#restore_replace_external_table_functions_to_null} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Для тестирования. Заменяет все внешние табличные функции на Null, чтобы не инициировать внешние соединения.
## restore_replicated_merge_tree_to_shared_merge_tree {#restore_replicated_merge_tree_to_shared_merge_tree} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Заменить движок таблицы с Replicated*MergeTree -> Shared*MergeTree во время ВОССТАНОВЛЕНИЯ.
## result_overflow_mode {#result_overflow_mode} 



<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Значение по умолчанию для облака: `throw`

Устанавливает, что делать, если объем результата превышает одно из предельных значений.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: остановить выполнение запроса и вернуть частичный результат, как если бы
           исходные данные закончились.

Использование 'break' аналогично использованию LIMIT. `Break` прерывает выполнение только на уровне блока. Это означает, что количество возвращаемых строк больше чем 
[`max_result_rows`](/operations/settings/settings#max_result_rows), кратное [`max_block_size`](/operations/settings/settings#max_block_size)
и зависит от [`max_threads`](/operations/settings/settings#max_threads).

**Пример**

```sql title="Запрос"
SET max_threads = 3, max_block_size = 3333;
SET max_result_rows = 3334, result_overflow_mode = 'break';

SELECT *
FROM numbers_mt(100000)
FORMAT Null;
```

```text title="Результат"
6666 строк в наборе. ...
```
## rewrite_count_distinct_if_with_count_distinct_implementation {#rewrite_count_distinct_if_with_count_distinct_implementation} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.8"},{"label": "1"},{"label": "Переопределить countDistinctIf с настройкой count_distinct_implementation"}]}]}/>

Позволяет переписать `countDistinctIf` с помощью настройки [count_distinct_implementation](#count_distinct_implementation).

Возможные значения:

- true — Разрешить.
- false — Запретить.
## s3_allow_multipart_copy {#s3_allow_multipart_copy} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.2"},{"label": "1"},{"label": "Новая настройка."}]}]}/>

Разрешить многочастичное копирование в S3.
## s3_allow_parallel_part_upload {#s3_allow_parallel_part_upload} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать несколько потоков для многочастичной загрузки в s3. Это может привести к немного большему использованию памяти.
## s3_check_objects_after_upload {#s3_check_objects_after_upload} 



<SettingsInfoBlock type="Bool" default_value="0" />

Проверять каждый загруженный объект в S3 с помощью запроса head, чтобы убедиться, что загрузка прошла успешно.
## s3_connect_timeout_ms {#s3_connect_timeout_ms} 



<SettingsInfoBlock type="UInt64" default_value="1000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1000"},{"label": "Введена новая специализированная настройка для таймаута соединения S3"}]}]}/>

Таймаут соединения для хоста с дисков S3.
## s3_create_new_file_on_insert {#s3_create_new_file_on_insert} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает создание нового файла при каждой вставке в таблицы движка s3. Если включено, при каждой вставке создается новый объект S3 с ключом, аналогично следующему шаблону:

начальный: `data.Parquet.gz` -> `data.1.Parquet.gz` -> `data.2.Parquet.gz`, и т.д.

Возможные значения:
- 0 — запрос `INSERT` создает новый файл или завершается, если файл существует и s3_truncate_on_insert не установлен.
- 1 — запрос `INSERT` создает новый файл при каждой вставке, используя суффикс (со второго) если s3_truncate_on_insert не установлен.

Смотрите дополнительные детали [здесь](/integrations/s3#inserting-data).
## s3_disable_checksum {#s3_disable_checksum} 



<SettingsInfoBlock type="Bool" default_value="0" />

Не рассчитывать контрольную сумму при отправке файла в S3. Это ускоряет запись, избегая чрезмерной обработки файла. Это в основном безопасно, так как данные таблиц MergeTree проверяются ClickHouse, и когда S3 доступен через HTTPS, уровень TLS уже обеспечивает целостность при передаче по сети. В то время как дополнительные контрольные суммы в S3 дают дополнительный уровень защиты.
## s3_ignore_file_doesnt_exist {#s3_ignore_file_doesnt_exist} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "0"},{"label": "Разрешить вернуть 0 строк, когда запрашиваемые файлы не существуют, вместо выброса исключения в движке таблицы S3"}]}]}/>

Игнорировать отсутствие файла, если он не существует при чтении определенных ключей.

Возможные значения:
- 1 — `SELECT` возвращает пустой результат.
- 0 — `SELECT` выбрасывает исключение.
## s3_list_object_keys_size {#s3_list_object_keys_size} 



<SettingsInfoBlock type="UInt64" default_value="1000" />

Максимальное количество файлов, которые могут быть возвращены в пакете запросом ListObject.
## s3_max_connections {#s3_max_connections} 



<SettingsInfoBlock type="UInt64" default_value="1024" />

Максимальное количество соединений на сервер.
## s3_max_get_burst {#s3_max_get_burst} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество запросов, которые могут быть выданы одновременно, прежде чем будет достигнут лимит запросов в секунду. По умолчанию (0) равно `s3_max_get_rps`.
## s3_max_get_rps {#s3_max_get_rps} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Лимит на количество запросов S3 GET в секунду перед ограничением. Ноль означает неограниченно.
## s3_max_inflight_parts_for_one_file {#s3_max_inflight_parts_for_one_file} 



<SettingsInfoBlock type="UInt64" default_value="20" />

Максимальное количество одновременно загруженных частей в запросе многочастичной загрузки. 0 означает неограниченно.
## s3_max_part_number {#s3_max_part_number} 



<SettingsInfoBlock type="UInt64" default_value="10000" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "10000"},{"label": "Максимальный номер части для загрузки части S3"}]}]}/>

Максимальный номер части для загрузки в S3.
## s3_max_put_burst {#s3_max_put_burst} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальное количество запросов, которые могут быть выданы одновременно, прежде чем будет достигнут лимит запросов в секунду. По умолчанию (0) равно `s3_max_put_rps`.
## s3_max_put_rps {#s3_max_put_rps} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Лимит на количество запросов S3 PUT в секунду перед ограничением. Ноль означает неограниченно.
## s3_max_redirects {#s3_max_redirects} 



<SettingsInfoBlock type="UInt64" default_value="10" />

Максимальное количество разрешенных переходов S3.
## s3_max_single_operation_copy_size {#s3_max_single_operation_copy_size} 



<SettingsInfoBlock type="UInt64" default_value="33554432" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "33554432"},{"label": "Максимальный размер для одной операции копирования в S3"}]}]}/>

Максимальный размер для копирования в одной операции в S3. Эта настройка используется только если s3_allow_multipart_copy установлена в true.
## s3_max_single_part_upload_size {#s3_max_single_part_upload_size} 



<SettingsInfoBlock type="UInt64" default_value="33554432" />

Максимальный размер объекта для загрузки с помощью единой части загрузки в S3.
## s3_max_single_read_retries {#s3_max_single_read_retries} 



<SettingsInfoBlock type="UInt64" default_value="4" />

Максимальное количество попыток во время одного чтения S3.
## s3_max_unexpected_write_error_retries {#s3_max_unexpected_write_error_retries} 



<SettingsInfoBlock type="UInt64" default_value="4" />

Максимальное количество попыток в случае неожиданных ошибок во время записи в S3.
## s3_max_upload_part_size {#s3_max_upload_part_size} 



<SettingsInfoBlock type="UInt64" default_value="5368709120" />

Максимальный размер части для загрузки во время многочастичной загрузки в S3.
## s3_min_upload_part_size {#s3_min_upload_part_size} 



<SettingsInfoBlock type="UInt64" default_value="16777216" />

Минимальный размер части для загрузки во время многочастичной загрузки в S3.
## s3_request_timeout_ms {#s3_request_timeout_ms} 



<SettingsInfoBlock type="UInt64" default_value="30000" />

Время ожидания для отправки и приема данных в S3. Ошибка, если один TCP вызов чтения или записи блокирует на это время.
## s3_retry_attempts {#s3_retry_attempts} 



<SettingsInfoBlock type="UInt64" default_value="100" />

Настройка для Aws::Client::RetryStrategy, Aws::Client выполняет повторы самостоятельно, 0 означает отсутствие повторов.
## s3_skip_empty_files {#s3_skip_empty_files} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Мы надеемся, что это обеспечит лучший пользовательский опыт"}]}]}/>

Включает или отключает пропуск пустых файлов в таблицах движка [S3](../../engines/table-engines/integrations/s3.md).

Возможные значения:
- 0 — `SELECT` выбрасывает исключение, если пустой файл несовместим с запрашиваемым форматом.
- 1 — `SELECT` возвращает пустой результат для пустого файла.
## s3_slow_all_threads_after_network_error {#s3_slow_all_threads_after_network_error} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Если установлено значение `true`, то все потоки, выполняющие запросы S3 к одной и той же конечной точке, замедляются на некоторое время после того, как один запрос S3 завершится с ошибкой сети, подлежащей повторной попытке.
Если установлено значение `false`, то каждый поток, выполняющий запрос S3, использует независимый набор откатов при ошибках сети.
## s3_strict_upload_part_size {#s3_strict_upload_part_size} 



<SettingsInfoBlock type="UInt64" default_value="0" />

Точный размер части для загрузки во время многочастичной загрузки в S3 (некоторые реализации не поддерживают переменные размеры частей).
## s3_throw_on_zero_files_match {#s3_throw_on_zero_files_match} 



<SettingsInfoBlock type="Bool" default_value="0" />

Выбросить ошибку, когда запрос ListObjects не может сопоставить ни один файл.
## s3_truncate_on_insert {#s3_truncate_on_insert} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает обрезку перед вставками в таблицы движка S3. Если отключено, выбросится исключение при попытках вставки, если объект S3 уже существует.

Возможные значения:
- 0 — запрос `INSERT` создает новый файл или завершается, если файл существует и s3_create_new_file_on_insert не установлен.
- 1 — запрос `INSERT` заменяет существующее содержимое файла новыми данными.

Смотрите дополнительные детали [здесь](/integrations/s3#inserting-data).
## s3_upload_part_size_multiply_factor {#s3_upload_part_size_multiply_factor} 



<SettingsInfoBlock type="UInt64" default_value="2" />

Умножать s3_min_upload_part_size на этот коэффициент каждый раз, когда s3_multiply_parts_count_threshold части были загружены из одной записи в S3.
## s3_upload_part_size_multiply_parts_count_threshold {#s3_upload_part_size_multiply_parts_count_threshold} 



<SettingsInfoBlock type="UInt64" default_value="500" />

Каждый раз, когда это количество частей было загружено в S3, s3_min_upload_part_size умножается на s3_upload_part_size_multiply_factor.
## s3_use_adaptive_timeouts {#s3_use_adaptive_timeouts} 



<SettingsInfoBlock type="Bool" default_value="1" />

Если установлено значение `true`, для всех запросов S3 первые две попытки выполняются с низкими тайм-аутами отправки и получения.
Если установлено значение `false`, все попытки выполняются с одинаковыми тайм-аутами.
## s3_validate_request_settings {#s3_validate_request_settings} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.6"},{"label": "1"},{"label": "Разрешить отключение проверки настроек запроса S3"}]}]}/>

Включает проверку настроек запроса S3.

Возможные значения:
- 1 — валидировать настройки.
- 0 — не валидировать настройки.
## s3queue_default_zookeeper_path {#s3queue_default_zookeeper_path} 



<SettingsInfoBlock type="String" default_value="/clickhouse/s3queue/" />

Префикс пути zookeeper по умолчанию для движка S3Queue.
## s3queue_enable_logging_to_s3queue_log {#s3queue_enable_logging_to_s3queue_log} 



<SettingsInfoBlock type="Bool" default_value="0" />

Включить запись в system.s3queue_log. Значение может быть переопределено для таблицы с помощью настроек таблицы.
## s3queue_migrate_old_metadata_to_buckets {#s3queue_migrate_old_metadata_to_buckets} 



<SettingsInfoBlock type="Bool" default_value="0" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Перенос старой структуры метаданных таблицы S3Queue в новую.
## schema_inference_cache_require_modification_time_for_url {#schema_inference_cache_require_modification_time_for_url} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать схему из кеша с проверкой времени последнего изменения для URL с заголовком Last-Modified.
## schema_inference_use_cache_for_azure {#schema_inference_use_cache_for_azure} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кеш в выводе схемы при использовании функции таблицы azure.
## schema_inference_use_cache_for_file {#schema_inference_use_cache_for_file} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кеш в выводе схемы при использовании функции таблицы file.
## schema_inference_use_cache_for_hdfs {#schema_inference_use_cache_for_hdfs} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кеш в выводе схемы при использовании функции таблицы hdfs.
## schema_inference_use_cache_for_s3 {#schema_inference_use_cache_for_s3} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кеш в выводе схемы при использовании функции таблицы s3.
## schema_inference_use_cache_for_url {#schema_inference_use_cache_for_url} 



<SettingsInfoBlock type="Bool" default_value="1" />

Использовать кеш в выводе схемы при использовании функции таблицы url.
## secondary_indices_enable_bulk_filtering {#secondary_indices_enable_bulk_filtering} 



<SettingsInfoBlock type="Bool" default_value="1" />



<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Новый алгоритм фильтрации по индексам пропуска данных"}]}]}/>

Включить алгоритм массовой фильтрации для индексов. Ожидается, что он всегда будет более эффективным, но у нас есть эта настройка для совместимости и контроля.
```yaml
title: 'Настройки ClickHouse'
sidebar_label: 'Настройки'
keywords: ['настройки', 'ClickHouse', 'базы данных']
description: 'Подробности о настройках ClickHouse и их функциональности.'
```

## select_sequential_consistency {#select_sequential_consistency} 

<SettingsInfoBlock type="UInt64" default_value="0" />

:::note
Это настройка имеет разные поведения для SharedMergeTree и ReplicatedMergeTree, смотрите [консистентность SharedMergeTree](/cloud/reference/shared-merge-tree#consistency) для получения дополнительной информации о поведении `select_sequential_consistency` в SharedMergeTree.
:::

Включает или отключает последовательную консистентность для запросов `SELECT`. Требуется, чтобы `insert_quorum_parallel` был отключен (включен по умолчанию).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

Использование

Когда последовательная консистентность включена, ClickHouse позволяет клиенту выполнять запрос `SELECT` только для тех реплик, которые содержат данные из всех предыдущих запросов `INSERT`, выполненных с `insert_quorum`. Если клиент ссылается на частичную реплику, ClickHouse сгенерирует исключение. Запрос `SELECT` не будет включать данные, которые еще не были записаны в кворум реплик.

Когда `insert_quorum_parallel` включен (по умолчанию), `select_sequential_consistency` не работает. Это связано с тем, что параллельные запросы `INSERT` могут записываться в разные наборы кворум-реплик, поэтому нет гарантии, что одна реплика получит все записи.

Смотрите также:

- [insert_quorum](#insert_quorum)
- [insert_quorum_timeout](#insert_quorum_timeout)
- [insert_quorum_parallel](#insert_quorum_parallel)

## send_logs_level {#send_logs_level} 

<SettingsInfoBlock type="LogsLevel" default_value="fatal" />

Отправляет текстовые логи сервера с указанным минимальным уровнем клиенту. Доступные значения: 'trace', 'debug', 'information', 'warning', 'error', 'fatal', 'none'.

## send_logs_source_regexp {#send_logs_source_regexp} 

Отправляет текстовые логи сервера с указанным регулярным выражением для сопоставления имени источника лога. Пустое значение означает все источники.

## send_progress_in_http_headers {#send_progress_in_http_headers} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает заголовки HTTP-ответов `X-ClickHouse-Progress` в ответах `clickhouse-server`.

Для получения дополнительной информации читайте [описание HTTP интерфейса](../../interfaces/http.md).

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

## send_timeout {#send_timeout} 

<SettingsInfoBlock type="Seconds" default_value="300" />

Таймаут для отправки данных в сеть, в секундах. Если клиенту нужно отправить какие-либо данные, но он не может отправить ни одного байта в этот интервал, выбрасывается исключение. Если вы установите эту настройку на клиенте, 'receive_timeout' для сокета также будет установлен на соответствующей стороне соединения на сервере.

## serialize_query_plan {#serialize_query_plan} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Сериализует план запроса для распределенной обработки.

## session_timezone {#session_timezone} 

<BetaBadge/>

Устанавливает неявный часовой пояс текущей сессии или запроса.
Неявный часовой пояс применяется к значениям типа DateTime/DateTime64, для которых не указан явно часовой пояс.
Эта настройка имеет приоритет над глобально настроенным (уровень сервера) неявным часовым поясом.
Пустое значение '' (пустая строка) означает, что неявный часовой пояс текущей сессии или запроса равен [часовому поясу сервера](../server-configuration-parameters/settings.md/#timezone).

Вы можете использовать функции `timeZone()` и `serverTimeZone()`, чтобы получить часовой пояс сессии и часовой пояс сервера.

Возможные значения:

-    Любое имя часового пояса из `system.time_zones`, например, `Europe/Berlin`, `UTC` или `Zulu`.

Примеры:

```sql
SELECT timeZone(), serverTimeZone() FORMAT CSV

"Europe/Berlin","Europe/Berlin"
```

```sql
SELECT timeZone(), serverTimeZone() SETTINGS session_timezone = 'Asia/Novosibirsk' FORMAT CSV

"Asia/Novosibirsk","Europe/Berlin"
```

Назначьте часовой пояс сессии 'America/Denver' для внутреннего DateTime без явно указанного часового пояса:

```sql
SELECT toDateTime64(toDateTime64('1999-12-12 23:23:23.123', 3), 3, 'Europe/Zurich') SETTINGS session_timezone = 'America/Denver' FORMAT TSV

1999-12-13 07:23:23.123
```

:::warning
Не все функции, которые разбирают DateTime/DateTime64, учитывают `session_timezone`. Это может привести к тонким ошибкам.
Смотрите следующий пример и объяснение.
:::

```sql
CREATE TABLE test_tz (`d` DateTime('UTC')) ENGINE = Memory AS SELECT toDateTime('2000-01-01 00:00:00', 'UTC');

SELECT *, timeZone() FROM test_tz WHERE d = toDateTime('2000-01-01 00:00:00') SETTINGS session_timezone = 'Asia/Novosibirsk'
0 rows in set.

SELECT *, timeZone() FROM test_tz WHERE d = '2000-01-01 00:00:00' SETTINGS session_timezone = 'Asia/Novosibirsk'
┌───────────────────d─┬─timeZone()───────┐
│ 2000-01-01 00:00:00 │ Asia/Novosибирск │
└─────────────────────┴──────────────────┘
```

Это происходит из-за разных конвейеров разбора:

- `toDateTime()` без явно указанного часового пояса, использованная в первом запросе `SELECT`, учитывает настройку `session_timezone` и глобальный часовой пояс.
- Во втором запросе DateTime разбирается из строки и наследует тип и часовой пояс существующей колонки `d`. Таким образом, настройки `session_timezone` и глобальный часовой пояс не учитываются.

**Смотрите также**

- [timezone](../server-configuration-parameters/settings.md/#timezone)

## set_overflow_mode {#set_overflow_mode} 

<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, когда количество данных превышает один из лимитов.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: прекратить выполнение запроса и вернуть частичный результат, как если бы исходные данные закончились.

## shared_merge_tree_sync_parts_on_partition_operations {#shared_merge_tree_sync_parts_on_partition_operations} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "1"},{"label": "Новая настройка. По умолчанию части всегда синхронизированы"}]}]}/>

Автоматически синхронизирует набор частей данных после операций MOVE|REPLACE|ATTACH в таблицах SMT. Только для облака.

## short_circuit_function_evaluation {#short_circuit_function_evaluation} 

<SettingsInfoBlock type="ShortCircuitFunctionEvaluation" default_value="enable" />

Позволяет вычислять функции [if](../../sql-reference/functions/conditional-functions.md/#if), [multiIf](../../sql-reference/functions/conditional-functions.md/#multiif), [and](/sql-reference/functions/logical-functions#and) и [or](/sql-reference/functions/logical-functions#or) согласно [схеме короткого замыкания](https://en.wikipedia.org/wiki/Short-circuit_evaluation). Это помогает оптимизировать выполнение сложных выражений в этих функциях и предотвращает возможные исключения (например, деление на ноль, когда это не ожидается).

Возможные значения:

- `enable` — Включает вычисление функций с коротким замыканием для функций, которые подходят для этого (могут выбросить исключение или являются вычислительно сложными).
- `force_enable` — Включает вычисление функций с коротким замыканием для всех функций.
- `disable` — Отключает вычисление функций с коротким замыканием.

## short_circuit_function_evaluation_for_nulls {#short_circuit_function_evaluation_for_nulls} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Разрешает выполнять функции с Nullable аргументами только для строк с ненулевыми значениями во всех аргументах"}]}]}/>

Оптимизирует оценку функций, которые возвращают NULL, когда любой аргумент равен NULL. Когда процент значений NULL в аргументах функции превышает `short_circuit_function_evaluation_for_nulls_threshold`, система пропускает оценку функции построчно. Вместо этого она немедленно возвращает NULL для всех строк, избегая ненужных вычислений.

## short_circuit_function_evaluation_for_nulls_threshold {#short_circuit_function_evaluation_for_nulls_threshold} 

<SettingsInfoBlock type="Double" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Порог соотношения значений NULL для выполнения функций с Nullable аргументами только для строк с ненулевыми значениями во всех аргументах. Применяется, когда настройка `short_circuit_function_evaluation_for_nulls` включена."}]}]}/>

Порог соотношения значений NULL для выполнения функций с Nullable аргументами только для строк с ненулевыми значениями во всех аргументах. Применяется, когда настройка `short_circuit_function_evaluation_for_nulls` включена. 
Когда соотношение строк, содержащих значения NULL, к общему количеству строк превышает этот порог, эти строки, содержащие значения NULL, не будут оцениваться.

## show_table_uuid_in_table_create_query_if_not_nil {#show_table_uuid_in_table_create_query_if_not_nil} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "20.7"},{"label": "0"},{"label": "Остановить отображение UID таблицы в запросе CREATE для Engine=Atomic"}]}]}/>

Устанавливает отображение запроса `SHOW TABLE`.

Возможные значения:

- 0 — Запрос будет отображаться без UUID таблицы.
- 1 — Запрос будет отображаться с UUID таблицы.

## single_join_prefer_left_table {#single_join_prefer_left_table} 

<SettingsInfoBlock type="Bool" default_value="1" />

Для единственного JOIN в случае неясности идентификатора предпочитайте левую таблицу.

## skip_redundant_aliases_in_udf {#skip_redundant_aliases_in_udf} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "0"},{"label": "При включении это позволяет использовать одну и ту же пользовательскую функцию несколько раз для нескольких материализованных столбцов в одной таблице."}]}]}/>

Избыточные псевдонимы не используются (заменяются) в пользовательских функциях, чтобы упростить их использование.

Возможные значения:

- 1 — Псевдонимы пропускаются (заменяются) в UDF.
- 0 — Псевдонимы не пропускаются (заменяются) в UDF.

**Пример**

Различие между включением и отключением:

Запрос:

```sql
SET skip_redundant_aliases_in_udf = 0;
CREATE FUNCTION IF NOT EXISTS test_03274 AS ( x ) -> ((x + 1 as y, y + 2));

EXPLAIN SYNTAX SELECT test_03274(4 + 2);
```

Результат:

```text
SELECT ((4 + 2) + 1 AS y, y + 2)
```

Запрос:

```sql
SET skip_redundant_aliases_in_udf = 1;
CREATE FUNCTION IF NOT EXISTS test_03274 AS ( x ) -> ((x + 1 as y, y + 2));

EXPLAIN SYNTAX SELECT test_03274(4 + 2);
```

Результат:

```text
SELECT ((4 + 2) + 1, ((4 + 2) + 1) + 2)
```

## skip_unavailable_shards {#skip_unavailable_shards} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает бесшумное пропускание недоступных шардов.

Шард считается недоступным, если все его реплики недоступны. Реплика недоступна в следующих случаях:

- ClickHouse не может подключиться к реплике по какой-либо причине.

    При подключении к реплике ClickHouse выполняет несколько попыток. Если все эти попытки не удались, реплика считается недоступной.

- Реплика не может быть разрешена через DNS.

    Если имя хоста реплики не может быть разрешено через DNS, это может указывать на следующие ситуации:

    - У хоста реплики нет DNS-записи. Это может произойти в системах с динамическим DNS, например, [Kubernetes](https://kubernetes.io), где узлы могут быть нерешаемыми во время простоя, и это не является ошибкой.

    - Ошибка конфигурации. Файл конфигурации ClickHouse содержит неправильное имя хоста.

Возможные значения:

- 1 — пропуск включен.

    Если шард недоступен, ClickHouse возвращает результат на основе частичных данных и не сообщает об ошибках доступности узлов.

- 0 — пропуск отключен.

    Если шард недоступен, ClickHouse выбрасывает исключение.

## sleep_after_receiving_query_ms {#sleep_after_receiving_query_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время для паузы после получения запроса в TCPHandler.

## sleep_in_send_data_ms {#sleep_in_send_data_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время для паузы при отправке данных в TCPHandler.

## sleep_in_send_tables_status_ms {#sleep_in_send_tables_status_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="0" />

Время для паузы при отправке статуса таблиц в ответе TCPHandler.

## sort_overflow_mode {#sort_overflow_mode} 

<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, если количество строк, полученных до сортировки, превышает один из лимитов.

Возможные значения:
- `throw`: выбросить исключение.
- `break`: прекратить выполнение запроса и вернуть частичный результат.

## split_intersecting_parts_ranges_into_layers_final {#split_intersecting_parts_ranges_into_layers_final} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Разрешает разбивать пересекающиеся диапазоны частей на слои во время окончательной оптимизации"}]}, {"id": "row-2","items": [{"label": "24.1"},{"label": "1"},{"label": "Разрешает разбивать пересекающиеся диапазоны частей на слои во время окончательной оптимизации"}]}]}/>

Разбивает пересекающиеся диапазоны частей на слои во время окончательной оптимизации.

## split_parts_ranges_into_intersecting_and_non_intersecting_final {#split_parts_ranges_into_intersecting_and_non_intersecting_final} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.2"},{"label": "1"},{"label": "Разрешает разбивать диапазоны частей на пересекающиеся и непересекающиеся во время окончательной оптимизации"}]}, {"id": "row-2","items": [{"label": "24.1"},{"label": "1"},{"label": "Разрешает разбивать диапазоны частей на пересекающиеся и непересекающиеся во время окончательной оптимизации"}]}]}/>

Разбивает диапазоны частей на пересекающиеся и непересекающиеся во время окончательной оптимизации.

## splitby_max_substrings_includes_remaining_string {#splitby_max_substrings_includes_remaining_string} 

<SettingsInfoBlock type="Bool" default_value="0" />

Управляет, будет ли функция [splitBy*()](../../sql-reference/functions/splitting-merging-functions.md) с аргументом `max_substrings` > 0 включать оставшуюся строку в последний элемент результирующего массива.

Возможные значения:

- `0` - Оставшаяся строка не будет включена в последний элемент результирующего массива.
- `1` - Оставшаяся строка будет включена в последний элемент результирующего массива. Это поведение функции Spark [`split()`](https://spark.apache.org/docs/3.1.2/api/python/reference/api/pyspark.sql.functions.split.html) и метода Python ['string.split()'](https://docs.python.org/3/library/stdtypes.html#str.split).

## stop_refreshable_materialized_views_on_startup {#stop_refreshable_materialized_views_on_startup} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

При запуске сервера предотвращает планирование обновляемых материализованных представлений, как если бы с помощью SYSTEM STOP VIEWS. Вы можете вручную запустить их с помощью `SYSTEM START VIEWS` или `SYSTEM START VIEW <name>` после этого. Также применяется к новым представлениям. Не влияет на не обновляемые материализованные представления.

## storage_file_read_method {#storage_file_read_method} 

<SettingsInfoBlock type="LocalFSReadMethod" default_value="pread" />

Метод чтения данных из файла хранения, один из: `read`, `pread`, `mmap`. Метод mmap не применяется для clickhouse-server (он предназначен для clickhouse-local).

## storage_system_stack_trace_pipe_read_timeout_ms {#storage_system_stack_trace_pipe_read_timeout_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="100" />

Максимальное время для чтения из трубки для получения информации от потоков при запросе таблицы `system.stack_trace`. Эта настройка используется в тестовых целях и не предназначена для изменения пользователями.

## stream_flush_interval_ms {#stream_flush_interval_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="7500" />

Работает для таблиц с потоковой передачей в случае тайм-аута или когда поток генерирует [max_insert_block_size](#max_insert_block_size) строк.

Значение по умолчанию — 7500.

Чем меньше значение, тем чаще данные сбрасываются в таблицу. Установка слишком низкого значения приводит к низкой производительности.

## stream_like_engine_allow_direct_select {#stream_like_engine_allow_direct_select} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.12"},{"label": "0"},{"label": "Не разрешать прямой выбор для Kafka/RabbitMQ/FileLog по умолчанию"}]}]}/>

Разрешить прямой запрос SELECT для движков Kafka, RabbitMQ, FileLog, Redis Streams и NATS. В случае наличия прикрепленных материализованных представлений запрос SELECT не разрешается, даже если эта настройка включена.

## stream_like_engine_insert_queue {#stream_like_engine_insert_queue} 

Когда потокоподобный движок читает из нескольких очередей, пользователю нужно выбрать одну очередь для вставки при записи. Используется в Redis Streams и NATS.

## stream_poll_timeout_ms {#stream_poll_timeout_ms} 

<SettingsInfoBlock type="Milliseconds" default_value="500" />

Таймаут для опроса данных от/в потоковые хранилища.

## system_events_show_zero_values {#system_events_show_zero_values} 

<SettingsInfoBlock type="Bool" default_value="0" />

Позволяет выбирать события с нулевыми значениями из [`system.events`](../../operations/system-tables/events.md).

Некоторые системы мониторинга требуют передачи всех значений метрик для каждой контрольной точки, даже если значение метрики равно нулю.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

**Примеры**

Запрос

```sql
SELECT * FROM system.events WHERE event='QueryMemoryLimitExceeded';
```

Результат

```text
Ok.
```

Запрос
```sql
SET system_events_show_zero_values = 1;
SELECT * FROM system.events WHERE event='QueryMemoryLimitExceeded';
```

Результат

```text
┌─event────────────────────┬─value─┬─description───────────────────────────────────────────┐
│ QueryMemoryLimitExceeded │     0 │ Количество случаев, когда превышен лимит памяти для запроса. │
└──────────────────────────┴───────┴───────────────────────────────────────────────────────┘
```

## table_function_remote_max_addresses {#table_function_remote_max_addresses} 

<SettingsInfoBlock type="UInt64" default_value="1000" />

Устанавливает максимальное количество адресов, сгенерированных по шаблонам для функции [remote](../../sql-reference/table-functions/remote.md).

Возможные значения:

- Положительное целое число.

## tcp_keep_alive_timeout {#tcp_keep_alive_timeout} 

<SettingsInfoBlock type="Seconds" default_value="290" />

Время в секундах, в течение которого соединение должно оставаться неактивным, прежде чем TCP начнет отправлять пакеты keepalive.

## temporary_data_in_cache_reserve_space_wait_lock_timeout_milliseconds {#temporary_data_in_cache_reserve_space_wait_lock_timeout_milliseconds} 

<SettingsInfoBlock type="UInt64" default_value="600000" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.4"},{"label": "600000"},{"label": "Время ожидания блокировки кеша для резервирования пространства данных во временном файле в кэше файловой системы"}]}]}/>

Время ожидания блокировки кеша для резервирования пространства для временных данных в кэше файловой системы.

## temporary_files_codec {#temporary_files_codec} 

<SettingsInfoBlock type="String" default_value="LZ4" />

Устанавливает кодек сжатия для временных файлов, используемых в операциях сортировки и соединения на диске.

Возможные значения:

- LZ4 — применяется сжатие [LZ4](https://en.wikipedia.org/wiki/LZ4_(compression_algorithm)).
- NONE — сжатие не применяется.

## throw_if_deduplication_in_dependent_materialized_views_enabled_with_async_insert {#throw_if_deduplication_in_dependent_materialized_views_enabled_with_async_insert} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "1"},{"label": "Дедупликация в зависимом материализованном представлении не может работать вместе с асинхронными вставками."}]}]}/>

Выбрасывать исключение при запросе INSERT, когда настройка `deduplicate_blocks_in_dependent_materialized_views` включена вместе с `async_insert`. Это гарантирует корректность, так как эти функции не могут работать вместе.

## throw_if_no_data_to_insert {#throw_if_no_data_to_insert} 

<SettingsInfoBlock type="Bool" default_value="1" />

Разрешает или запрещает пустые INSERT-запросы, включено по умолчанию (выбрасывает ошибку при пустом вставке). Применяется только к INSERT-запросам с использованием [`clickhouse-client`](/interfaces/cli) или использованию интерфейса [gRPC](/interfaces/grpc).

## throw_on_error_from_cache_on_write_operations {#throw_on_error_from_cache_on_write_operations} 

<SettingsInfoBlock type="Bool" default_value="0" />

Игнорировать ошибки от кеша при записи операций (INSERT, объединения).

## throw_on_max_partitions_per_insert_block {#throw_on_max_partitions_per_insert_block} 

<SettingsInfoBlock type="Bool" default_value="1" />

Позволяет контролировать поведение при достижении `max_partitions_per_insert_block`.

Возможные значения:
- `true`  - Когда блок вставки достигает `max_partitions_per_insert_block`, выбрасывается исключение.
- `false` - Логи предупреждают, когда достигнут `max_partitions_per_insert_block`.

:::tip
Это может быть полезным, если вы пытаетесь понять влияние на пользователей при изменении [`max_partitions_per_insert_block`](/operations/settings/settings#max_partitions_per_insert_block).
:::

## throw_on_unsupported_query_inside_transaction {#throw_on_unsupported_query_inside_transaction} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Bool" default_value="1" />

Выбрасывать исключение, если внутри транзакции используется неподдерживаемый запрос.

## timeout_before_checking_execution_speed {#timeout_before_checking_execution_speed} 

<SettingsInfoBlock type="Seconds" default_value="10" />

Проверяет, что скорость выполнения не слишком медленная (не менее `min_execution_speed`), после истечения указанного времени в секундах.

## timeout_overflow_mode {#timeout_overflow_mode} 

<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что делать, если запрос выполняется дольше, чем `max_execution_time` или предполагаемое время выполнения превышает `max_estimated_execution_time`.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: прекратить выполнение запроса и вернуть частичный результат, как если бы исходные данные закончились.

## timeout_overflow_mode_leaf {#timeout_overflow_mode_leaf} 

<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, когда запрос в листовом узле выполняется дольше, чем `max_execution_time_leaf`.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: прекратить выполнение запроса и вернуть частичный результат, как если бы исходные данные закончились.

## totals_auto_threshold {#totals_auto_threshold} 

<SettingsInfoBlock type="Float" default_value="0.5" />

Порог для `totals_mode = 'auto'`.
Смотрите раздел "Модификатор WITH TOTALS".

## totals_mode {#totals_mode} 

<SettingsInfoBlock type="TotalsMode" default_value="after_having_exclusive" />

Как вычислять TOTALS, когда HAVING присутствует, а также когда max_rows_to_group_by и group_by_overflow_mode = 'any' присутствуют.
Смотрите раздел "Модификатор WITH TOTALS".

## trace_profile_events {#trace_profile_events} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает или отключает сбор стек-трассировок при каждом обновлении событий профилирования вместе с именем профилируемого события и значением инкремента, и отправляет их в [trace_log](/operations/system-tables/trace_log).

Возможные значения:

- 1 — Включен трейсинг событий профилирования.
- 0 — Трейсинг событий профилирования отключен.

## transfer_overflow_mode {#transfer_overflow_mode} 

<SettingsInfoBlock type="OverflowMode" default_value="throw" />

Устанавливает, что происходит, когда количество данных превышает один из лимитов.

Возможные значения:
- `throw`: выбросить исключение (по умолчанию).
- `break`: прекратить выполнение запроса и вернуть частичный результат, как если бы исходные данные закончились.

## transform_null_in {#transform_null_in} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включает равенство значений [NULL](/sql-reference/syntax#null) для оператора [IN](../../sql-reference/operators/in.md).

По умолчанию значения `NULL` не могут быть сравнены, так как `NULL` означает не определенное значение. Таким образом, сравнение `expr = NULL` всегда должно возвращать `false`. С этой настройкой `NULL = NULL` возвращает `true` для оператора IN.

Возможные значения:

- 0 — Сравнение значений `NULL` в операторе `IN` возвращает `false`.
- 1 — Сравнение значений `NULL` в операторе `IN` возвращает `true`.

**Пример**

Рассмотрим таблицу `null_in`:

```text
┌──idx─┬─────i─┐
│    1 │     1 │
│    2 │  NULL │
│    3 │     3 │
└──────┴───────┘
```

Запрос:

```sql
SELECT idx, i FROM null_in WHERE i IN (1, NULL) SETTINGS transform_null_in = 0;
```

Результат:

```text
┌──idx─┬────i─┐
│    1 │    1 │
└──────┴──────┘
```

Запрос:

```sql
SELECT idx, i FROM null_in WHERE i IN (1, NULL) SETTINGS transform_null_in = 1;
```

Результат:

```text
┌──idx─┬─────i─┐
│    1 │     1 │
│    2 │  NULL │
└──────┴───────┘
```

**Смотрите также**

- [Проблема с NULL в операторах IN](/sql-reference/operators/in#null-processing)

## traverse_shadow_remote_data_paths {#traverse_shadow_remote_data_paths} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Перебирать скрытый каталог при запросе system.remote_data_paths."}]}]}/>

Перебирать замороженные данные (скрытый каталог) в дополнение к фактическим данным таблицы при запросе system.remote_data_paths.

## union_default_mode {#union_default_mode} 

Устанавливает режим для объединения результатов запросов `SELECT`. Настройка используется только при совместном использовании с [UNION](../../sql-reference/statements/select/union.md) без явного указания `UNION ALL` или `UNION DISTINCT`.

Возможные значения:

- `'DISTINCT'` — ClickHouse выводит строки в результате объединения запросов, удаляя дубликаты.
- `'ALL'` — ClickHouse выводит все строки в результате объединения запросов, включая дубликаты.
- `''` — ClickHouse выдает исключение при использовании с `UNION`.

Смотрите примеры в [UNION](../../sql-reference/statements/select/union.md).

## unknown_packet_in_send_data {#unknown_packet_in_send_data} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Отправить неизвестный пакет вместо N-го пакета данных.

## update_parallel_mode {#update_parallel_mode} 

<SettingsInfoBlock type="UpdateParallelMode" default_value="auto" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "auto"},{"label": "Новая настройка"}]}]}/>

Определяет поведение параллельных запросов обновления.

Возможные значения:
- `sync` - запускать последовательно все запросы `UPDATE`.
- `auto` - запускать последовательно только запросы обновления с зависимостями между столбцами, обновляемыми в одном запросе, и столбцами, используемыми в выражениях другого запроса.
- `async` - не синхронизировать запросы обновления.

## update_sequential_consistency {#update_sequential_consistency} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Если true, набор частей обновляется до последней версии перед выполнением обновления.

## use_async_executor_for_materialized_views {#use_async_executor_for_materialized_views} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Использовать асинхронное и потенциально многопоточное выполнение запроса материализованного представления, что может ускорить обработку представлений во время INSERT, но также потреблять больше памяти.

## use_cache_for_count_from_files {#use_cache_for_count_from_files} 

<SettingsInfoBlock type="Bool" default_value="1" />

Включает кеширование количества строк при подсчете из файлов в табличных функциях `file`/`s3`/`url`/`hdfs`/`azureBlobStorage`.

Включено по умолчанию.

## use_client_time_zone {#use_client_time_zone} 

<SettingsInfoBlock type="Bool" default_value="0" />

Использовать часовой пояс клиента для интерпретации строковых значений DateTime, вместо использования часового пояса сервера.

## use_compact_format_in_distributed_parts_names {#use_compact_format_in_distributed_parts_names} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.1"},{"label": "1"},{"label": "Использовать компактный формат для асинхронного INSERT в распределенные таблицы по умолчанию"}]}]}/>

Использует компактный формат для хранения блоков для фонового (`distributed_foreground_insert`) INSERT в таблицы с движком `Distributed`.

Возможные значения:

- 0 — Использует формат `user[:password]@host:port#default_database`.
- 1 — Использует формат директории `[shard{shard_index}[_replica{replica_index}]]`.

:::note
- при `use_compact_format_in_distributed_parts_names=0` изменения из определения кластера не будут применены для фонового INSERT.
- при `use_compact_format_in_distributed_parts_names=1` изменение порядка узлов в определении кластера будет изменять `shard_index`/`replica_index`, так что будьте внимательны.
:::

## use_concurrency_control {#use_concurrency_control} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.12"},{"label": "1"},{"label": "Включить контроль параллелизма по умолчанию"}]}]}/>

Учитывайте контроль параллелизма сервера (см. глобальные настройки сервера `concurrent_threads_soft_limit_num` и `concurrent_threads_soft_limit_ratio_to_cores`). Если отключено, это позволяет использовать большее количество потоков, даже если сервер перегружен (не рекомендуется для нормального использования и в основном нужно для тестов).
```
```yaml
title: 'Использование параметров настройки ClickHouse'
sidebar_label: 'Параметры настройки'
keywords: ['ClickHouse', 'настройки', 'база данных']
description: 'Эта статья описывает различные параметры настройки ClickHouse и их значения.'
```

## use_hedged_requests {#use_hedged_requests} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "21.9"},{"label": "1"},{"label": "Включить функцию хеджирования запросов по умолчанию"}]}]}/>

Включает логику хеджирования запросов для удаленных запросов. Это позволяет устанавливать множество соединений с различными репликами для запроса. Новое соединение устанавливается в случае, если существующие соединения с репликами не были установлены в течение `hedged_connection_timeout` или если данные не были получены в течение `receive_data_timeout`. Запрос использует первое соединение, которое отправляет непустой пакет прогресса (или пакет данных, если `allow_changing_replica_until_first_data_packet`); другие соединения отменяются. Запросы с `max_parallel_replicas > 1` поддерживаются.

По умолчанию включено.

По умолчанию отключено в Cloud.

## use_hive_partitioning {#use_hive_partitioning} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "1"},{"label": "Включена настройка по умолчанию."}]}, {"id": "row-2","items": [{"label": "24.8"},{"label": "0"},{"label": "Позволяет использовать разбиение на разделы Hive для движков File, URL, S3, AzureBlobStorage и HDFS."}]}]}/>

При включении ClickHouse будет обнаруживать разбиение на разделы в стиле Hive в пути (`/name=value/`) в таблицах, подобных файлам [File](/sql-reference/table-functions/file#hive-style-partitioning)/[S3](/sql-reference/table-functions/s3#hive-style-partitioning)/[URL](/sql-reference/table-functions/url#hive-style-partitioning)/[HDFS](/sql-reference/table-functions/hdfs#hive-style-partitioning)/[AzureBlobStorage](/sql-reference/table-functions/azureBlobStorage#hive-style-partitioning) и позволит использовать колонки-разделы как виртуальные колонки в запросе. Эти виртуальные колонки будут иметь те же имена, что и в разбиенном пути, но начинаться с `_`.

## use_iceberg_metadata_files_cache {#use_iceberg_metadata_files_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Если включено, функция таблицы iceberg и хранилище iceberg могут использовать кэш файлов метаданных iceberg.

Возможные значения:

- 0 - Отключено
- 1 - Включено

## use_iceberg_partition_pruning {#use_iceberg_partition_pruning} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Использовать обрезку разбиений Iceberg для таблиц Iceberg.

## use_index_for_in_with_subqueries {#use_index_for_in_with_subqueries} 

<SettingsInfoBlock type="Bool" default_value="1" />

Попробуйте использовать индекс, если есть подзапрос или табличное выражение на правой стороне оператора IN.

## use_index_for_in_with_subqueries_max_values {#use_index_for_in_with_subqueries_max_values} 

<SettingsInfoBlock type="UInt64" default_value="0" />

Максимальный размер множества на правой стороне оператора IN для использования табличного индекса для фильтрации. Это позволяет избежать ухудшения производительности и увеличенного использования памяти из-за подготовки дополнительных структур данных для крупных запросов. Ноль означает отсутствие лимита.

## use_json_alias_for_old_object_type {#use_json_alias_for_old_object_type} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.8"},{"label": "0"},{"label": "Используйте псевдоним типа JSON для создания нового типа JSON"}]}]}/>

При включении будет использоваться псевдоним типа `JSON` для создания старого типа [Object('json')](../../sql-reference/data-types/json.md) вместо нового типа [JSON](../../sql-reference/data-types/newjson.md).

## use_legacy_to_time {#use_legacy_to_time} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Новая настройка. Позволяет пользователю использовать старую логику функции toTime, которая работает как toTimeWithFixedDate."}]}]}/>

При включении позволяет использовать устаревшую функцию toTime, которая конвертирует дату с временем в определенную фиксированную дату, сохраняя время. В противном случае используется новая функция toTime, которая конвертирует различные типы данных в тип Time. Старая устаревшая функция также доступна без условий как toTimeWithFixedDate.

## use_page_cache_for_disks_without_file_cache {#use_page_cache_for_disks_without_file_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.3"},{"label": "0"},{"label": "Добавлен кэш страниц пользовательского пространства"}]}]}/>

Используйте кэш страниц пользовательского пространства для удаленных дисков, на которых кэш файловой системы отключен.

## use_page_cache_with_distributed_cache {#use_page_cache_with_distributed_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.3"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Используйте кэш страниц пользовательского пространства, когда используется распределенный кэш.

## use_query_cache {#use_query_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

Если включено, запросы `SELECT` могут использовать [кэш запросов](../query-cache.md). Параметры [enable_reads_from_query_cache](#enable_reads_from_query_cache) и [enable_writes_to_query_cache](#enable_writes_to_query_cache) более детально контролируют, как используется кэш.

Возможные значения:

- 0 - Отключено
- 1 - Включено

## use_query_condition_cache {#use_query_condition_cache} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.4"},{"label": "1"},{"label": "Новая оптимизация"}]}, {"id": "row-2","items": [{"label": "25.3"},{"label": "0"},{"label": "Новая настройка."}]}]}/>

Включить [кэш условий запроса](/operations/query-condition-cache). Кэш хранит диапазоны гранул в частях данных, которые не удовлетворяют условию в операторе `WHERE`, и повторно использует эту информацию в качестве эпhemerального индекса для последующих запросов.

Возможные значения:

- 0 - Отключено
- 1 - Включено

## use_skip_indexes {#use_skip_indexes} 

<SettingsInfoBlock type="Bool" default_value="1" />

Используйте индексы пропуска данных во время выполнения запроса.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

## use_skip_indexes_if_final {#use_skip_indexes_if_final} 

<SettingsInfoBlock type="Bool" default_value="0" />

Контролирует, используются ли индексы пропуска при выполнении запроса с модификатором FINAL.

По умолчанию эта настройка отключена, поскольку индексы пропуска могут исключить строки (гранулы), содержащие последние данные, что может привести к неправильным результатам. Когда включено, индексы пропуска применяются даже с модификатором FINAL, что потенциально улучшает производительность, но с риском упустить недавние обновления.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

## use_skip_indexes_if_final_exact_mode {#use_skip_indexes_if_final_exact_mode} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "0"},{"label": "Эта настройка была введена, чтобы помочь запросу FINAL вернуть правильные результаты с индексами пропуска"}]}]}/>

Контролирует, расширяются ли гранулы, возвращаемые индексом пропуска, в новых частях, чтобы вернуть правильные результаты при выполнении запроса с модификатором FINAL.

Использование индексов пропуска может исключить строки (гранулы), содержащие последние данные, что может привести к неправильным результатам. Эта настройка может гарантировать, что правильные результаты будут возвращены путем сканирования новых частей, которые имеют пересечение с диапазонами, возвращенными индексом пропуска.

Возможные значения:

- 0 — Отключено.
- 1 — Включено.

## use_structure_from_insertion_table_in_table_functions {#use_structure_from_insertion_table_in_table_functions} 

<SettingsInfoBlock type="UInt64" default_value="2" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "22.11"},{"label": "2"},{"label": "Улучшение использования структуры из таблицы вставки в табличных функциях"}]}]}/>

Используйте структуру из таблицы вставки вместо вывода схемы из данных. Возможные значения: 0 - отключено, 1 - включено, 2 - авто.

## use_uncompressed_cache {#use_uncompressed_cache} 

<SettingsInfoBlock type="Bool" default_value="0" />

Включать ли кэш нежатых блоков. Принимает 0 или 1. По умолчанию 0 (отключено). Использование кэша нежатых блоков (только для таблиц в семье MergeTree) может значительно снизить задержку и увеличить пропускную способность при работе с большим количеством коротких запросов. Включите эту настройку для пользователей, которые отправляют частые короткие запросы. Обратите внимание на параметр конфигурации [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) (настраивается только в файле конфигурации) – размер нежатых кэшированных блоков. По умолчанию 8 GiB. Нежатый кэш заполняется по мере необходимости, и наименее используемые данные автоматически удаляются.

Для запросов, которые читают хотя бы в каком-то большом объеме данных (миллион строк или более), нежатый кэш автоматически отключается, чтобы сэкономить место для действительно небольших запросов. Это означает, что вы можете всегда оставлять настройку 'use_uncompressed_cache' установленной на 1.

## use_variant_as_common_type {#use_variant_as_common_type} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.1"},{"label": "0"},{"label": "Разрешить использовать тип Variant в if/multiIf, если нет общего типа"}]}]}/>

Позволяет использовать тип `Variant` в качестве результирующего типа для функций [if](../../sql-reference/functions/conditional-functions.md/#if)/[multiIf](../../sql-reference/functions/conditional-functions.md/#multiif)/[array](../../sql-reference/functions/array-functions.md)/[map](../../sql-reference/functions/tuple-map-functions.md), когда нет общего типа для типов аргументов.

Пример:

```sql
SET use_variant_as_common_type = 1;
SELECT toTypeName(if(number % 2, number, range(number))) as variant_type FROM numbers(1);
SELECT if(number % 2, number, range(number)) as variant FROM numbers(5);
```

```text
┌─variant_type───────────────────┐
│ Variant(Array(UInt64), UInt64) │
└────────────────────────────────┘
┌─variant───┐
│ []        │
│ 1         │
│ [0,1]     │
│ 3         │
│ [0,1,2,3] │
└───────────┘
```

```sql
SET use_variant_as_common_type = 1;
SELECT toTypeName(multiIf((number % 4) = 0, 42, (number % 4) = 1, [1, 2, 3], (number % 4) = 2, 'Hello, World!', NULL)) AS variant_type FROM numbers(1);
SELECT multiIf((number % 4) = 0, 42, (number % 4) = 1, [1, 2, 3], (number % 4) = 2, 'Hello, World!', NULL) AS variant FROM numbers(4);
```

```text
─variant_type─────────────────────────┐
│ Variant(Array(UInt8), String, UInt8) │
└──────────────────────────────────────┘

┌─variant───────┐
│ 42            │
│ [1,2,3]       │
│ Hello, World! │
│ ᴺᵁᴸᴸ          │
└───────────────┘
```

```sql
SET use_variant_as_common_type = 1;
SELECT toTypeName(array(range(number), number, 'str_' || toString(number))) as array_of_variants_type from numbers(1);
SELECT array(range(number), number, 'str_' || toString(number)) as array_of_variants FROM numbers(3);
```

```text
┌─array_of_variants_type────────────────────────┐
│ Array(Variant(Array(UInt64), String, UInt64)) │
└───────────────────────────────────────────────┘

┌─array_of_variants─┐
│ [[],0,'str_0']    │
│ [[0],1,'str_1']   │
│ [[0,1],2,'str_2'] │
└───────────────────┘
```

```sql
SET use_variant_as_common_type = 1;
SELECT toTypeName(map('a', range(number), 'b', number, 'c', 'str_' || toString(number))) as map_of_variants_type from numbers(1);
SELECT map('a', range(number), 'b', number, 'c', 'str_' || toString(number)) as map_of_variants FROM numbers(3);
```

```text
┌─map_of_variants_type────────────────────────────────┐
│ Map(String, Variant(Array(UInt64), String, UInt64)) │
└─────────────────────────────────────────────────────┘

┌─map_of_variants───────────────┐
│ {'a':[],'b':0,'c':'str_0'}    │
│ {'a':[0],'b':1,'c':'str_1'}   │
│ {'a':[0,1],'b':2,'c':'str_2'} │
└───────────────────────────────┘
```

## use_with_fill_by_sorting_prefix {#use_with_fill_by_sorting_prefix} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "23.5"},{"label": "1"},{"label": "Колонки перед WITH FILL в ORDER BY формируют префикс сортировки. Строки с разными значениями в префиксе сортировки заполняются независимо"}]}]}/>

Колонки, предшествующие колонкам WITH FILL в ORDER BY, формируют префикс сортировки. Строки с разными значениями в префиксе сортировки заполняются независимо.

## validate_enum_literals_in_operators {#validate_enum_literals_in_operators} 

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.1"},{"label": "0"},{"label": "Новая настройка"}]}]}/>

Если включено, проверяются литералы перечислений в операторах, таких как `IN`, `NOT IN`, `==`, `!=`, на соответствие типу перечисления и выбрасывается исключение, если литерал не является допустимым значением перечисления.

## validate_mutation_query {#validate_mutation_query} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.11"},{"label": "1"},{"label": "Новая настройка для валидации запросов мутации по умолчанию."}]}]}/>

Валидация запросов мутации перед их принятием. Мутации выполняются в фоновом режиме, и выполнение недействительного запроса приведет к зависанию мутаций, требуя ручного вмешательства.

Изменяйте эту настройку только в случае возникновения несовместимой ошибки.

## validate_polygons {#validate_polygons} 

<SettingsInfoBlock type="Bool" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "20.4"},{"label": "1"},{"label": "Выбрасывать исключение, если многоугольник является недействительным в функции pointInPolygon по умолчанию вместо возврата возможно неверных результатов"}]}]}/>

Включает или отключает выбрасывание исключения в функции [pointInPolygon](/sql-reference/functions/geo/coordinates#pointinpolygon), если многоугольник самопересекается или самотангентен.

Возможные значения:

- 0 — Выброс исключения отключен. `pointInPolygon` принимает недействительные многоугольники и возвращает возможно неправильные результаты для них.
- 1 — Выброс исключения включен.

## vector_search_filter_strategy {#vector_search_filter_strategy} 

<BetaBadge/>

<SettingsInfoBlock type="VectorSearchFilterStrategy" default_value="auto" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "auto"},{"label": "Новая настройка"}]}]}/>

Если запрос векторного поиска содержит условие WHERE, эта настройка определяет, будет ли оно оцениваться сначала (предварительная фильтрация) ИЛИ будет ли сначала проверяться индекс векторного сходства (постфильтрация). Возможные значения:
- 'auto' - Постфильтрация (точная семантика может измениться в будущем).
- 'postfilter' - Использовать индекс векторного сходства для определения ближайших соседей, затем применить другие фильтры.
- 'prefilter' - Сначала оценить другие фильтры, затем выполнить поиск методом грубой силы для определения соседей.

## vector_search_postfilter_multiplier {#vector_search_postfilter_multiplier} 

<BetaBadge/>

<SettingsInfoBlock type="Float" default_value="1" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "25.5"},{"label": "1"},{"label": "Новая настройка"}]}]}/>

Умножает извлеченные ближайшие соседи из индекса векторного сходства на это число перед выполнением постфильтрации по другим предикатам.

## wait_changes_become_visible_after_commit_mode {#wait_changes_become_visible_after_commit_mode} 

<ExperimentalBadge/>

<SettingsInfoBlock type="TransactionsWaitCSNMode" default_value="wait_unknown" />

Ожидание, когда подтвержденные изменения станут фактически видимыми в последнем снимке.

## wait_for_async_insert {#wait_for_async_insert} 

<SettingsInfoBlock type="Bool" default_value="1" />

Если true, ожидать обработки асинхронной вставки.

## wait_for_async_insert_timeout {#wait_for_async_insert_timeout} 

<SettingsInfoBlock type="Seconds" default_value="120" />

Тайм-аут ожидания обработки асинхронной вставки.

## wait_for_window_view_fire_signal_timeout {#wait_for_window_view_fire_signal_timeout} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Seconds" default_value="10" />

Тайм-аут ожидания сигнала срабатывания окна представления в обработке временных событий.

## window_view_clean_interval {#window_view_clean_interval} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Seconds" default_value="60" />

Интервал очистки окна представления в секундах для освобождения устаревших данных.

## window_view_heartbeat_interval {#window_view_heartbeat_interval} 

<ExperimentalBadge/>

<SettingsInfoBlock type="Seconds" default_value="15" />

Интервал опроса в секундах для указания того, что запрос на наблюдение активен.

## workload {#workload} 

<SettingsInfoBlock type="String" default_value="default" />

Имя рабочей нагрузки, используемое для доступа к ресурсам.

## write_through_distributed_cache {#write_through_distributed_cache} 

<CloudOnlyBadge/>

<SettingsInfoBlock type="Bool" default_value="0" />

<VersionHistory rows={[{"id": "row-1","items": [{"label": "24.10"},{"label": "0"},{"label": "Настройка для ClickHouse Cloud"}]}]}/>

Имеет эффект только в ClickHouse Cloud. Позволяет запись в распределенный кэш (запись в s3 также будет выполнена посредством распределенного кэша).

## zstd_window_log_max {#zstd_window_log_max} 

<SettingsInfoBlock type="Int64" default_value="0" />

Позволяет выбрать максимальный размер окна журнала ZSTD (не будет использован для семейства MergeTree).

---
slug: /sql-reference/statements/optimize
sidebar_position: 47
sidebar_label: OPTIMIZE
title: "Команда OPTIMIZE"
---

Этот запрос пытается инициировать несогласовываемое слияние частей данных для таблиц. Обратите внимание, что мы обычно не рекомендуем использовать `OPTIMIZE TABLE ... FINAL` (см. эти [документы](/optimize/avoidoptimizefinal)), поскольку его область применения предназначена для администрирования, а не для повседневной работы.

:::note
`OPTIMIZE` не может исправить ошибку `Слишком много частей`.
:::

**Синтаксис**

``` sql
OPTIMIZE TABLE [db.]name [ON CLUSTER cluster] [PARTITION partition | PARTITION ID 'partition_id'] [FINAL | FORCE] [DEDUPLICATE [BY expression]]
```

Запрос `OPTIMIZE` поддерживается для семейства [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) (включая [материализованные представления](/sql-reference/statements/create/view#materialized-view)) и [Buffer](../../engines/table-engines/special/buffer.md). Другие движки таблиц не поддерживаются.

Когда `OPTIMIZE` используется с семейством движков таблиц [ReplicatedMergeTree](../../engines/table-engines/mergetree-family/replication.md), ClickHouse создает задачу для слияния и ожидает выполнения на всех репликах (если настройка [alter_sync](/operations/settings/settings#alter_sync) установлена на `2`) или на текущей реплике (если настройка [alter_sync](/operations/settings/settings#alter_sync) установлена на `1`).

- Если `OPTIMIZE` не выполняет слияние по какой-либо причине, он не уведомляет клиента. Чтобы включить уведомления, используйте настройку [optimize_throw_if_noop](/operations/settings/settings#optimize_throw_if_noop).
- Если вы укажете `PARTITION`, только указанная партиция будет оптимизирована. [Как установить выражение партиции](alter/partition.md#how-to-set-partition-expression).
- Если вы укажете `FINAL` или `FORCE`, оптимизация будет выполнена даже тогда, когда все данные уже находятся в одной части. Вы можете контролировать это поведение с помощью [optimize_skip_merged_partitions](/operations/settings/settings#optimize_skip_merged_partitions). Также слияние является принудительным, даже если выполняются параллельные слияния.
- Если вы укажете `DEDUPLICATE`, то полностью идентичные строки (если не указано выражение by) будут удалены (все колонки сравниваются), это имеет смысл только для движка MergeTree.

Вы можете указать, сколько времени (в секундах) ждать неактивные реплики для выполнения запросов `OPTIMIZE` с помощью настройки [replication_wait_for_inactive_replica_timeout](/operations/settings/settings#replication_wait_for_inactive_replica_timeout).

:::note    
Если `alter_sync` установлен в `2` и некоторые реплики не активны более времени, указанного в настройке `replication_wait_for_inactive_replica_timeout`, то выбрасывается исключение `UNFINISHED`.
:::

## BY expression {#by-expression}

Если вы хотите выполнить дедупликацию по собственному набору колонок, а не по всем, вы можете явно указать список колонок или использовать любую комбинацию [`*`](../../sql-reference/statements/select/index.md#asterisk), [`COLUMNS`](/sql-reference/statements/select#select-clause) или [`EXCEPT`](/sql-reference/statements/select#except) выражений. Явно написанный или неявно расширенный список колонок должен включать все колонки, указанные в выражении упорядочивания строк (как первичные, так и сортировочные ключи) и в выражении партиционирования (ключ партиционирования).

:::note    
Обратите внимание, что `*` ведет себя так же, как в `SELECT`: колонки [MATERIALIZED](/sql-reference/statements/create/view#materialized-view) и [ALIAS](../../sql-reference/statements/create/table.md#alias) не используются для расширения.

Также возникает ошибка, если указать пустой список колонок или написать выражение, которое приводит к пустому списку колонок, или проводить дедупликацию по колонке `ALIAS`.
:::

**Синтаксис**

``` sql
OPTIMIZE TABLE table DEDUPLICATE; -- все колонки
OPTIMIZE TABLE table DEDUPLICATE BY *; -- исключает MATERIALIZED и ALIAS колонки
OPTIMIZE TABLE table DEDUPLICATE BY colX,colY,colZ;
OPTIMIZE TABLE table DEDUPLICATE BY * EXCEPT colX;
OPTIMIZE TABLE table DEDUPLICATE BY * EXCEPT (colX, colY);
OPTIMIZE TABLE table DEDUPLICATE BY COLUMNS('column-matched-by-regex');
OPTIMIZE TABLE table DEDUPLICATE BY COLUMNS('column-matched-by-regex') EXCEPT colX;
OPTIMIZE TABLE table DEDUPLICATE BY COLUMNS('column-matched-by-regex') EXCEPT (colX, colY);
```

**Примеры**

Рассмотрим таблицу:

``` sql
CREATE TABLE example (
    первичный_ключ Int32,
    вторичный_ключ Int32,
    значение UInt32,
    ключ_партиции UInt32,
    материализированное_значение UInt32 MATERIALIZED 12345,
    алиасированное_значение UInt32 ALIAS 2,
    PRIMARY KEY первичный_ключ
) ENGINE=MergeTree
PARTITION BY ключ_партиции
ORDER BY (первичный_ключ, вторичный_ключ);
```

``` sql
INSERT INTO example (первичный_ключ, вторичный_ключ, значение, ключ_партиции)
VALUES (0, 0, 0, 0), (0, 0, 0, 0), (1, 1, 2, 2), (1, 1, 2, 3), (1, 1, 3, 3);
```

``` sql
SELECT * FROM example;
```
Результат:

```sql

┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           0 │             0 │     0 │             0 │
│           0 │             0 │     0 │             0 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             2 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             3 │
│           1 │             1 │     3 │             3 │
└─────────────┴───────────────┴───────┴───────────────┘
```

Все следующие примеры выполняются против этого состояния с 5 строками.

#### `DEDUPLICATE` {#deduplicate}
Когда колонки для дедупликации не указаны, принимаются все из них. Строка удаляется только в том случае, если все значения во всех колонках равны соответствующим значениям в предыдущей строке:

``` sql
OPTIMIZE TABLE example FINAL DEDUPLICATE;
```

``` sql
SELECT * FROM example;
```

Результат:

```response
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             2 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           0 │             0 │     0 │             0 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             3 │
│           1 │             1 │     3 │             3 │
└─────────────┴───────────────┴───────┴───────────────┘
```

#### `DEDUPLICATE BY *` {#deduplicate-by-}

Когда колонки указаны неявно, таблица будет дедуплицирована по всем колонкам, которые не являются `ALIAS` или `MATERIALIZED`. Учитывая таблицу выше, это колонки `первичный_ключ`, `вторичный_ключ`, `значение` и `ключ_партиции`:

```sql
OPTIMIZE TABLE example FINAL DEDUPLICATE BY *;
```

``` sql
SELECT * FROM example;
```

Результат:

```response
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             2 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           0 │             0 │     0 │             0 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             3 │
│           1 │             1 │     3 │             3 │
└─────────────┴───────────────┴───────┴───────────────┘
```

#### `DEDUPLICATE BY * EXCEPT` {#deduplicate-by--except}
Дедупликация по всем колонкам, которые не являются `ALIAS` или `MATERIALIZED`, и явно не являются `значение`: колонки `первичный_ключ`, `вторичный_ключ` и `ключ_партиции`.

``` sql
OPTIMIZE TABLE example FINAL DEDUPLICATE BY * EXCEPT значение;
```

``` sql
SELECT * FROM example;
```

Результат:

```response
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             2 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           0 │             0 │     0 │             0 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             3 │
└─────────────┴───────────────┴───────┴───────────────┘
```

#### `DEDUPLICATE BY <список колонок>` {#deduplicate-by-list-of-columns}

Явная дедупликация по колонкам `первичный_ключ`, `вторичный_ключ` и `ключ_партиции`:

```sql
OPTIMIZE TABLE example FINAL DEDUPLICATE BY первичный_ключ, вторичный_ключ, ключ_партиции;
```

``` sql
SELECT * FROM example;
```
Результат:

```response
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             2 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           0 │             0 │     0 │             0 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             3 │
└─────────────┴───────────────┴───────┴───────────────┘
```

#### `DEDUPLICATE BY COLUMNS(<regex>)` {#deduplicate-by-columnsregex}

Дедупликация по всем колонкам, соответствующим регулярному выражению: колонки `первичный_ключ`, `вторичный_ключ` и `ключ_партиции`:

```sql
OPTIMIZE TABLE example FINAL DEDUPLICATE BY COLUMNS('.*_key');
```

``` sql
SELECT * FROM example;
```

Результат:

```response
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           0 │             0 │     0 │             0 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             2 │
└─────────────┴───────────────┴───────┴───────────────┘
┌─первичный_ключ─┬─вторичный_ключ─┬─значение─┬─ключ_партиции─┐
│           1 │             1 │     2 │             3 │
└─────────────┴───────────────┴───────┴───────────────┘
```

---
description: 'Документация по запросу SELECT'
sidebar_label: 'SELECT'
sidebar_position: 32
slug: /sql-reference/statements/select/
title: 'Запрос SELECT'
doc_type: 'reference'
---

# Запрос SELECT

Запросы `SELECT` выполняют выборку данных. По умолчанию запрошенные данные возвращаются клиенту, а в сочетании с [INSERT INTO](../../../sql-reference/statements/insert-into.md) они могут быть перенаправлены в другую таблицу.

## Синтаксис

```sql
[WITH expr_list(subquery)]
SELECT [DISTINCT [ON (column1, column2, ...)]] expr_list
[FROM [db.]table | (subquery) | table_function] [FINAL]
[SAMPLE sample_coeff]
[ARRAY JOIN ...]
[GLOBAL] [ANY|ALL|ASOF] [INNER|LEFT|RIGHT|FULL|CROSS] [OUTER|SEMI|ANTI] JOIN (subquery)|table [(alias1 [, alias2 ...])] (ON <expr_list>)|(USING <column_list>)
[PREWHERE expr]
[WHERE expr]
[GROUP BY expr_list] [WITH ROLLUP|WITH CUBE] [WITH TOTALS]
[HAVING expr]
[WINDOW window_expr_list]
[QUALIFY expr]
[ORDER BY expr_list] [WITH FILL] [FROM expr] [TO expr] [STEP expr] [INTERPOLATE [(expr_list)]]
[LIMIT [offset_value, ]n BY columns]
[LIMIT [n, ]m] [WITH TIES]
[SETTINGS ...]
[UNION  ...]
[INTO OUTFILE filename [TRUNCATE] [COMPRESSION type [LEVEL level]] ]
[FORMAT format]
```

Все предложения являются необязательными, кроме обязательного списка выражений сразу после `SELECT`, который подробно рассмотрен [ниже](#select-clause).

Каждое необязательное предложение описано в отдельном разделе, разделы перечислены в том же порядке, в котором предложения выполняются:

* [Предложение WITH](../../../sql-reference/statements/select/with.md)
* [Предложение SELECT](#select-clause)
* [Предложение DISTINCT](../../../sql-reference/statements/select/distinct.md)
* [Предложение FROM](../../../sql-reference/statements/select/from.md)
* [Предложение SAMPLE](../../../sql-reference/statements/select/sample.md)
* [Предложение JOIN](../../../sql-reference/statements/select/join.md)
* [Предложение PREWHERE](../../../sql-reference/statements/select/prewhere.md)
* [Предложение WHERE](../../../sql-reference/statements/select/where.md)
* [Предложение WINDOW](../../../sql-reference/window-functions/index.md)
* [Предложение GROUP BY](/sql-reference/statements/select/group-by)
* [Предложение LIMIT BY](../../../sql-reference/statements/select/limit-by.md)
* [Предложение HAVING](../../../sql-reference/statements/select/having.md)
* [Предложение QUALIFY](../../../sql-reference/statements/select/qualify.md)
* [Предложение LIMIT](../../../sql-reference/statements/select/limit.md)
* [Предложение OFFSET](../../../sql-reference/statements/select/offset.md)
* [Предложение UNION](../../../sql-reference/statements/select/union.md)
* [Предложение INTERSECT](../../../sql-reference/statements/select/intersect.md)
* [Предложение EXCEPT](../../../sql-reference/statements/select/except.md)
* [Предложение INTO OUTFILE](../../../sql-reference/statements/select/into-outfile.md)
* [Предложение FORMAT](../../../sql-reference/statements/select/format.md)


## Предложение SELECT \{#select-clause\}

[Выражения](/sql-reference/syntax#expressions), указанные в предложении `SELECT`, вычисляются после завершения всех операций в описанных выше предложениях. Эти выражения работают так, как если бы они применялись к отдельным строкам результирующего набора. Если выражения в предложении `SELECT` содержат агрегатные функции, то ClickHouse обрабатывает агрегатные функции и выражения, используемые в качестве их аргументов, на этапе агрегации [GROUP BY](/sql-reference/statements/select/group-by).

Если вы хотите включить в результат все столбцы, используйте символ звёздочки (`*`). Например, `SELECT * FROM ...`.

### Динамический выбор столбцов

Динамический выбор столбцов (также известный как выражение COLUMNS) позволяет сопоставлять некоторые столбцы результата с регулярным выражением [re2](https://en.wikipedia.org/wiki/RE2_\(software\)).

```sql
COLUMNS('regexp')
```

Например, рассмотрим следующую таблицу:

```sql
CREATE TABLE default.col_names (aa Int8, ab Int8, bc Int8) ENGINE = TinyLog
```

Следующий запрос выбирает данные из всех столбцов, имя которых содержит символ `a`.

```sql
SELECT COLUMNS('a') FROM col_names
```

```text
┌─aa─┬─ab─┐
│  1 │  1 │
└────┴────┘
```

Выбранные столбцы возвращаются не в алфавитном порядке.

Вы можете использовать в запросе несколько выражений `COLUMNS` и применять к ним функции.

Например:

```sql
SELECT COLUMNS('a'), COLUMNS('c'), toTypeName(COLUMNS('c')) FROM col_names
```

```text
┌─aa─┬─ab─┬─bc─┬─toTypeName(bc)─┐
│  1 │  1 │  1 │ Int8           │
└────┴────┴────┴────────────────┘
```

Каждый столбец, возвращаемый выражением `COLUMNS`, передаётся в функцию как отдельный аргумент. Кроме того, вы можете передавать функции и другие аргументы, если она их поддерживает. Будьте осторожны при использовании функций. Если функция не поддерживает переданное ей количество аргументов, ClickHouse сгенерирует исключение.

Например:

```sql
SELECT COLUMNS('a') + COLUMNS('c') FROM col_names
```

```text
Получено исключение от сервера (версия 19.14.1):
Код: 42. DB::Exception: Получено от localhost:9000. DB::Exception: Число аргументов функции plus не соответствует ожидаемому: передано 3, ожидается 2.
```

В этом примере `COLUMNS('a')` возвращает два столбца: `aa` и `ab`. `COLUMNS('c')` возвращает столбец `bc`. Оператор `+` не может применяться к трём аргументам, поэтому ClickHouse генерирует исключение с соответствующим сообщением.

Столбцы, подпадающие под выражение `COLUMNS`, могут иметь разные типы данных. Если `COLUMNS` не соответствует ни одному столбцу и является единственным выражением в `SELECT`, ClickHouse генерирует исключение.


### Звёздочка \{#asterisk\}

Вы можете использовать звёздочку в любой части запроса вместо выражения. При анализе запроса звёздочка разворачивается в список всех столбцов таблицы (за исключением столбцов `MATERIALIZED` и `ALIAS`). Использование звёздочки оправдано лишь в нескольких случаях:

- При создании дампа таблицы.
- Для таблиц, содержащих всего несколько столбцов, например системных.
- Для получения информации о том, какие столбцы есть в таблице. В этом случае установите `LIMIT 1`. Но лучше использовать запрос `DESC TABLE`.
- Когда выполняется сильная фильтрация по небольшому числу столбцов с помощью `PREWHERE`.
- В подзапросах (так как столбцы, которые не нужны внешнему запросу, исключаются из подзапросов).

Во всех остальных случаях мы не рекомендуем использовать звёздочку, так как это даёт вам только недостатки колоночной СУБД вместо её преимуществ. Иными словами, использование звёздочки не рекомендуется.

### Экстремальные значения \{#extreme-values\}

Помимо результатов, вы можете также получить минимальные и максимальные значения для столбцов результата. Для этого установите настройку **extremes** в 1. Минимальные и максимальные значения вычисляются для числовых типов, дат и дат со временем. Для остальных столбцов выводятся значения по умолчанию.

Дополнительно вычисляются две строки – минимальные и максимальные значения соответственно. Эти две дополнительные строки выводятся в форматах `XML`, `JSON*`, `TabSeparated*`, `CSV*`, `Vertical`, `Template` и `Pretty*` [форматах](../../../interfaces/formats.md) отдельно от остальных строк. Для других форматов они не выводятся.

В форматах `JSON*` и `XML` экстремальные значения выводятся в отдельном поле `extremes`. В форматах `TabSeparated*`, `CSV*` и `Vertical` эти строки следуют после основного результата и после `totals`, если он задан. Им предшествует пустая строка (после остальных данных). В форматах `Pretty*` эти строки выводятся в виде отдельной таблицы после основного результата и после `totals`, если он задан. В формате `Template` экстремальные значения выводятся в соответствии с указанным шаблоном.

Экстремальные значения вычисляются для строк до применения `LIMIT`, но после `LIMIT BY`. Однако при использовании `LIMIT offset, size` строки до `offset` включаются в `extremes`. В потоковых запросах результат также может включать небольшое количество строк, которые прошли через `LIMIT`.

### Примечания \{#notes\}

Вы можете использовать синонимы (алиасы с `AS`) в любой части запроса.

Операторы `GROUP BY`, `ORDER BY` и `LIMIT BY` могут принимать позиционные аргументы. Чтобы включить их использование, активируйте настройку [enable_positional_arguments](/operations/settings/settings#enable_positional_arguments). После этого, например, выражение `ORDER BY 1,2` будет сортировать строки в таблице сначала по первому, а затем по второму столбцу.

## Детали реализации \{#implementation-details\}

Если в запросе отсутствуют конструкции `DISTINCT`, `GROUP BY` и `ORDER BY`, а также подзапросы `IN` и `JOIN`, запрос будет полностью обрабатываться потоковым образом, используя O(1) объём оперативной памяти. В противном случае запрос может потреблять много оперативной памяти, если не заданы соответствующие ограничения:

- `max_memory_usage`
- `max_rows_to_group_by`
- `max_rows_to_sort`
- `max_rows_in_distinct`
- `max_bytes_in_distinct`
- `max_rows_in_set`
- `max_bytes_in_set`
- `max_rows_in_join`
- `max_bytes_in_join`
- `max_bytes_before_external_sort`
- `max_bytes_ratio_before_external_sort`
- `max_bytes_before_external_group_by`
- `max_bytes_ratio_before_external_group_by`

Для получения дополнительной информации см. раздел «Settings». Можно использовать внешнюю сортировку (с сохранением временных таблиц на диске) и внешнюю агрегацию.

## Модификаторы SELECT \{#select-modifiers\}

Вы можете использовать следующие модификаторы в запросах `SELECT`.

| Модификатор                        | Описание                                                                                                                                                                                                                                                                                                                                                                                 |
|------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`APPLY`](./apply_modifier.md)     | Позволяет вызывать произвольную функцию для каждой строки, возвращаемой внешним табличным выражением запроса.                                                                                                                                                                                                                                                                            |
| [`EXCEPT`](./except_modifier.md)   | Указывает имена одного или нескольких столбцов, которые нужно исключить из результата. Все совпадающие имена столбцов не выводятся.                                                                                                                                                                                                                                                     |
| [`REPLACE`](./replace_modifier.md) | Указывает один или несколько [псевдонимов выражений](/sql-reference/syntax#expression-aliases). Каждый псевдоним должен совпадать с именем столбца в запросе `SELECT *`. В выходном списке столбцов столбец, соответствующий псевдониму, заменяется выражением из этого `REPLACE`. Этот модификатор не изменяет имена или порядок столбцов, однако может изменить значение и его тип данных. |

### Комбинации модификаторов

Вы можете использовать каждый модификатор отдельно или в сочетании с другими.

**Примеры:**

Использование одного и того же модификатора несколько раз.

```sql
SELECT COLUMNS('[jk]') APPLY(toString) APPLY(length) APPLY(max) FROM columns_transformers;
```

```response
┌─max(length(toString(j)))─┬─max(length(toString(k)))─┐
│                        2 │                        3 │
└──────────────────────────┴──────────────────────────┘
```

Использование нескольких модификаторов в одном запросе

```sql
SELECT * REPLACE(i + 1 AS i) EXCEPT (j) APPLY(sum) from columns_transformers;
```

```response
┌─sum(plus(i, 1))─┬─sum(k)─┐
│             222 │    347 │
└─────────────────┴────────┘
```


## SETTINGS в запросе SELECT

Необходимые настройки можно задать непосредственно в запросе `SELECT`. Значение настройки применяется только к этому запросу и после его выполнения сбрасывается на значение по умолчанию или предыдущее значение.

Другие способы настройки смотрите [здесь](/operations/settings/overview).

Для булевых настроек, устанавливаемых в true, можно использовать краткий синтаксис, опуская указание значения. Если указано только имя настройки, она автоматически принимает значение `1` (true).

**Пример**

```sql
SELECT * FROM some_table SETTINGS optimize_read_in_order=1, cast_keep_nullable=1;
```

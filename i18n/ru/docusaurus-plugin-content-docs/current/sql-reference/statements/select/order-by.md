---
slug: /sql-reference/statements/select/order-by
sidebar_label: ORDER BY
---


# Клауза ORDER BY

Клауза `ORDER BY` содержит

- список выражений, например, `ORDER BY visits, search_phrase`,
- список чисел, указывающих на колонки в клаузе `SELECT`, например, `ORDER BY 2, 1`, или
- `ALL`, что означает все колонки клаузы `SELECT`, например, `ORDER BY ALL`.

Чтобы отключить сортировку по номерам колонок, установите настройку [enable_positional_arguments](/operations/settings/settings#enable_positional_arguments) = 0. Чтобы отключить сортировку по `ALL`, установите настройку [enable_order_by_all](/operations/settings/settings#enable_order_by_all) = 0.

Клауза `ORDER BY` может быть атрибутирована модификатором `DESC` (по убыванию) или `ASC` (по возрастанию), который определяет направление сортировки. Если явный порядок сортировки не указан, по умолчанию используется `ASC`. Направление сортировки применяется к одному выражению, а не ко всему списку, например, `ORDER BY Visits DESC, SearchPhrase`. Также сортировка выполняется с учетом регистра.

Строки с идентичными значениями для выражений сортировки возвращаются в произвольном и недетерминированном порядке. Если клаузу `ORDER BY` опустить в операторе `SELECT`, порядок строк также будет произвольным и недетерминированным.

## Сортировка специальных значений {#sorting-of-special-values}

Существуют два подхода к порядку сортировки `NaN` и `NULL`:

- По умолчанию или с модификатором `NULLS LAST`: сначала значения, затем `NaN`, затем `NULL`.
- С модификатором `NULLS FIRST`: сначала `NULL`, затем `NaN`, затем другие значения.

### Пример {#example}

Для таблицы

``` text
┌─x─┬────y─┐
│ 1 │ ᴺᵁᴸᴸ │
│ 2 │    2 │
│ 1 │  nan │
│ 2 │    2 │
│ 3 │    4 │
│ 5 │    6 │
│ 6 │  nan │
│ 7 │ ᴺᵁᴸᴸ │
│ 6 │    7 │
│ 8 │    9 │
└───┴──────┘
```

Выполните запрос `SELECT * FROM t_null_nan ORDER BY y NULLS FIRST`, чтобы получить:

``` text
┌─x─┬────y─┐
│ 1 │ ᴺᵁᴸᴸ │
│ 7 │ ᴺᵁᴸᴸ │
│ 1 │  nan │
│ 6 │  nan │
│ 2 │    2 │
│ 2 │    2 │
│ 3 │    4 │
│ 5 │    6 │
│ 6 │    7 │
│ 8 │    9 │
└───┴──────┘
```

Когда числа с плавающей запятой сортируются, NaN отделяются от других значений. Независимо от порядка сортировки, NaN помещаются в конце. Другими словами, для сортировки по возрастанию они располагаются так, как будто они больше всех остальных чисел, в то время как для сортировки по убыванию они располагаются так, как будто они меньше остальных.

## Поддержка коллации {#collation-support}

При сортировке по значениям [String](../../../sql-reference/data-types/string.md) вы можете указать коллацию (сравнение). Пример: `ORDER BY SearchPhrase COLLATE 'tr'` - для сортировки по ключевому слову в порядке возрастания, используя турецкий алфавит, игнорируя регистр, предполагая, что строки закодированы в UTF-8. `COLLATE` можно указать или не указывать для каждого выражения в ORDER BY независимо. Если указан `ASC` или `DESC`, `COLLATE` указывается после него. При использовании `COLLATE` сортировка всегда выполняется без учета регистра.

Поддержка коллации имеется в [LowCardinality](../../../sql-reference/data-types/lowcardinality.md), [Nullable](../../../sql-reference/data-types/nullable.md), [Array](../../../sql-reference/data-types/array.md) и [Tuple](../../../sql-reference/data-types/tuple.md).

Мы рекомендуем использовать `COLLATE` только для окончательной сортировки небольшого количества строк, так как сортировка с использованием `COLLATE` менее эффективна, чем обычная сортировка по байтам.

## Примеры коллации {#collation-examples}

Пример только с значениями [String](../../../sql-reference/data-types/string.md):

Входная таблица:

``` text
┌─x─┬─s────┐
│ 1 │ bca  │
│ 2 │ ABC  │
│ 3 │ 123a │
│ 4 │ abc  │
│ 5 │ BCA  │
└───┴──────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

``` text
┌─x─┬─s────┐
│ 3 │ 123a │
│ 4 │ abc  │
│ 2 │ ABC  │
│ 1 │ bca  │
│ 5 │ BCA  │
└───┴──────┘
```

Пример с [Nullable](../../../sql-reference/data-types/nullable.md):

Входная таблица:

``` text
┌─x─┬─s────┐
│ 1 │ bca  │
│ 2 │ ᴺᵁᴸᴸ │
│ 3 │ ABC  │
│ 4 │ 123a │
│ 5 │ abc  │
│ 6 │ ᴺᵁᴸᴸ │
│ 7 │ BCA  │
└───┴──────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

``` text
┌─x─┬─s────┐
│ 4 │ 123a │
│ 5 │ abc  │
│ 3 │ ABC  │
│ 1 │ bca  │
│ 7 │ BCA  │
│ 6 │ ᴺᵁᴸᴸ │
│ 2 │ ᴺᵁᴸᴸ │
└───┴──────┘
```

Пример с [Array](../../../sql-reference/data-types/array.md):

Входная таблица:

``` text
┌─x─┬─s─────────────┐
│ 1 │ ['Z']         │
│ 2 │ ['z']         │
│ 3 │ ['a']         │
│ 4 │ ['A']         │
│ 5 │ ['z','a']     │
│ 6 │ ['z','a','a'] │
│ 7 │ ['']          │
└───┴───────────────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

``` text
┌─x─┬─s─────────────┐
│ 7 │ ['']          │
│ 3 │ ['a']         │
│ 4 │ ['A']         │
│ 2 │ ['z']         │
│ 5 │ ['z','a']     │
│ 6 │ ['z','a','a'] │
│ 1 │ ['Z']         │
└───┴───────────────┘
```

Пример со строками [LowCardinality](../../../sql-reference/data-types/lowcardinality.md):

Входная таблица:

```response
┌─x─┬─s───┐
│ 1 │ Z   │
│ 2 │ z   │
│ 3 │ a   │
│ 4 │ A   │
│ 5 │ za  │
│ 6 │ zaa │
│ 7 │     │
└───┴─────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```response
┌─x─┬─s───┐
│ 7 │     │
│ 3 │ a   │
│ 4 │ A   │
│ 2 │ z   │
│ 1 │ Z   │
│ 5 │ za  │
│ 6 │ zaa │
└───┴─────┘
```

Пример с [Tuple](../../../sql-reference/data-types/tuple.md):

```response
┌─x─┬─s───────┐
│ 1 │ (1,'Z') │
│ 2 │ (1,'z') │
│ 3 │ (1,'a') │
│ 4 │ (2,'z') │
│ 5 │ (1,'A') │
│ 6 │ (2,'Z') │
│ 7 │ (2,'A') │
└───┴─────────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```response
┌─x─┬─s───────┐
│ 3 │ (1,'a') │
│ 5 │ (1,'A') │
│ 2 │ (1,'z') │
│ 1 │ (1,'Z') │
│ 7 │ (2,'A') │
│ 4 │ (2,'z') │
│ 6 │ (2,'Z') │
└───┴─────────┘
```

## Подробности реализации {#implementation-details}

Используется меньше оперативной памяти, если указан достаточно небольшой [LIMIT](../../../sql-reference/statements/select/limit.md) вместе с `ORDER BY`. В противном случае количество используемой памяти пропорционально объему данных для сортировки. Для распределенной обработки запросов, если клауза [GROUP BY](/sql-reference/statements/select/group-by) опущена, сортировка частично выполняется на удаленных серверах, а результаты объединяются на сервере запрашивающем данные. Это означает, что для распределенной сортировки объем данных для сортировки может превышать объем памяти на одном сервере.

Если оперативной памяти недостаточно, возможно выполнить сортировку во внешней памяти (создавая временные файлы на диске). Используйте настройку `max_bytes_before_external_sort` для этой цели. Если она установлена на 0 (по умолчанию), внешняя сортировка отключена. Если она включена, когда объем данных для сортировки достигает указанного количества байт, собранные данные сортируются и сбрасываются во временный файл. После чтения всех данных все отсортированные файлы объединяются, и результаты выдаются. Файлы записываются в директорию `/var/lib/clickhouse/tmp/` в конфигурации (по умолчанию, но вы можете использовать параметр `tmp_path` для изменения этой настройки).

Выполнение запроса может использовать больше памяти, чем `max_bytes_before_external_sort`. По этой причине это значение должно быть значительно меньше `max_memory_usage`. Например, если ваш сервер имеет 128 ГБ ОЗУ и вам нужно выполнить один запрос, установите `max_memory_usage` на 100 ГБ, а `max_bytes_before_external_sort` на 80 ГБ.

Внешняя сортировка работает значительно менее эффективно, чем сортировка в ОЗУ.

## Оптимизация чтения данных {#optimization-of-data-reading}

Если выражение `ORDER BY` имеет префикс, который совпадает с ключом сортировки таблицы, вы можете оптимизировать запрос, используя настройку [optimize_read_in_order](../../../operations/settings/settings.md#optimize_read_in_order).

Когда настройка `optimize_read_in_order` включена, сервер ClickHouse использует индекс таблицы и читает данные в порядке ключа `ORDER BY`. Это позволяет избежать чтения всех данных в случае указанного [LIMIT](../../../sql-reference/statements/select/limit.md). Таким образом, запросы на больших объемах данных с небольшими лимитами обрабатываются быстрее.

Оптимизация работает как для `ASC`, так и для `DESC` и не работает вместе с клаузой [GROUP BY](/sql-reference/statements/select/group-by) и модификатором [FINAL](/sql-reference/statements/select/from#final-modifier).

Когда настройка `optimize_read_in_order` отключена, сервер ClickHouse не использует индекс таблицы при обработке запросов `SELECT`.

Рекомендуется отключать `optimize_read_in_order` вручную, когда выполняются запросы, содержащие клаузу `ORDER BY`, большой `LIMIT` и условие [WHERE](../../../sql-reference/statements/select/where.md), которое требует чтения огромного количества записей перед тем, как будут найдены запрашиваемые данные.

Оптимизация поддерживается в следующих движках таблиц:

- [MergeTree](../../../engines/table-engines/mergetree-family/mergetree.md) (включая [материализованные представления](/sql-reference/statements/create/view#materialized-view)),
- [Merge](../../../engines/table-engines/special/merge.md),
- [Buffer](../../../engines/table-engines/special/buffer.md)

В таблицах с движком `MaterializedView` оптимизация работает с представлениями, такими как `SELECT ... FROM merge_tree_table ORDER BY pk`. Но она не поддерживается в запросах, подобных `SELECT ... FROM view ORDER BY pk`, если запрос представления не имеет клаузу `ORDER BY`.

## Модификатор ORDER BY Expr WITH FILL {#order-by-expr-with-fill-modifier}

Этот модификатор также может быть объединен с [LIMIT ... WITH TIES модификатором](/sql-reference/statements/select/limit#limit--with-ties-modifier).

Модификатор `WITH FILL` может быть установлен после `ORDER BY expr` с необязательными параметрами `FROM expr`, `TO expr` и `STEP expr`. Все пропущенные значения колонки `expr` будут заполнены последовательно, а другие колонки будут заполнены по умолчанию.

Чтобы заполнить несколько колонок, добавьте модификатор `WITH FILL` с необязательными параметрами после каждого имени поля в разделе `ORDER BY`.

``` sql
ORDER BY expr [WITH FILL] [FROM const_expr] [TO const_expr] [STEP const_numeric_expr] [STALENESS const_numeric_expr], ... exprN [WITH FILL] [FROM expr] [TO expr] [STEP numeric_expr] [STALENESS numeric_expr]
[INTERPOLATE [(col [AS expr], ... colN [AS exprN])]]
```

`WITH FILL` может быть применен для полей с числовыми (всеми видами плавающей запятой, десятичными, целыми) или типами Date/DateTime. При применении для полей `String` пропущенные значения заполняются пустыми строками. 

Когда `FROM const_expr` не определен, последовательность заполнения использует минимальное значение поля `expr` из `ORDER BY`. Когда `TO const_expr` не определен, последовательность заполнения использует максимальное значение поля `expr` из `ORDER BY`. Когда `STEP const_numeric_expr` определен, тогда `const_numeric_expr` интерпретируется как таковой для числовых типов, как `days` для типа Date, как `seconds` для типа DateTime. Это также поддерживает тип данных [INTERVAL](/sql-reference/data-types/special-data-types/interval/), представляющий временные и датированные интервалы. Когда `STEP const_numeric_expr` пропущен, последовательность заполнения использует `1.0` для числового типа, `1 день` для типа Date и `1 секунда` для типа DateTime. Когда `STALENESS const_numeric_expr` определен, запрос сгенерирует строки, пока разница с предыдущей строкой в оригинальных данных не превысит `const_numeric_expr`. 

`INTERPOLATE` можно применить к колонкам, которые не участвуют в `ORDER BY WITH FILL`. Такие колонки заполняются на основе значений предыдущих полей с применением `expr`. Если `expr` отсутствует, будет повторено предыдущее значение. Пропущенный список приведет к включению всех разрешенных колонок.

Пример запроса без `WITH FILL`:

``` sql
SELECT n, source FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n;
```

Результат:

``` text
┌─n─┬─source───┐
│ 1 │ original │
│ 4 │ original │
│ 7 │ original │
└───┴──────────┘
```

Тот же запрос после применения модификатора `WITH FILL`:

``` sql
SELECT n, source FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5;
```

Результат:

``` text
┌───n─┬─source───┐
│   0 │          │
│ 0.5 │          │
│   1 │ original │
│ 1.5 │          │
│   2 │          │
│ 2.5 │          │
│   3 │          │
│ 3.5 │          │
│   4 │ original │
│ 4.5 │          │
│   5 │          │
│ 5.5 │          │
│   7 │ original │
└─────┴──────────┘
```

В случае с несколькими полями `ORDER BY field2 WITH FILL, field1 WITH FILL` порядок заполнения будет соответствовать порядку полей в клаузе `ORDER BY`.

Пример:

``` sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d2 WITH FILL,
    d1 WITH FILL STEP 5;
```

Результат:

``` text
┌───d1───────┬───d2───────┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-01 │ 1970-01-03 │          │
│ 1970-01-01 │ 1970-01-04 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
│ 1970-01-01 │ 1970-01-06 │          │
│ 1970-01-01 │ 1970-01-07 │          │
│ 1970-03-12 │ 1970-01-08 │ original │
└────────────┴────────────┴──────────┘
```

Поле `d1` не заполняется и используется значение по умолчанию, так как у нас нет повторяющихся значений для `d2`, и последовательность для `d1` не может быть правильно вычислена.

Следующий запрос с измененным полем в `ORDER BY`:

``` sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d1 WITH FILL STEP 5,
    d2 WITH FILL;
```

Результат:

``` text
┌───d1───────┬───d2───────┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-16 │ 1970-01-01 │          │
│ 1970-01-21 │ 1970-01-01 │          │
│ 1970-01-26 │ 1970-01-01 │          │
│ 1970-01-31 │ 1970-01-01 │          │
│ 1970-02-05 │ 1970-01-01 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
│ 1970-02-15 │ 1970-01-01 │          │
│ 1970-02-20 │ 1970-01-01 │          │
│ 1970-02-25 │ 1970-01-01 │          │
│ 1970-03-02 │ 1970-01-01 │          │
│ 1970-03-07 │ 1970-01-01 │          │
│ 1970-03-12 │ 1970-01-08 │ original │
└────────────┴────────────┴──────────┘
```

Следующий запрос использует тип данных `INTERVAL` в 1 день для каждого значения, заполненного в колонке `d1`:

``` sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d1 WITH FILL STEP INTERVAL 1 DAY,
    d2 WITH FILL;
```

Результат:
```response
┌─────────d1─┬─────────d2─┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-12 │ 1970-01-01 │          │
│ 1970-01-13 │ 1970-01-01 │          │
│ 1970-01-14 │ 1970-01-01 │          │
│ 1970-01-15 │ 1970-01-01 │          │
│ 1970-01-16 │ 1970-01-01 │          │
│ 1970-01-17 │ 1970-01-01 │          │
│ 1970-01-18 │ 1970-01-01 │          │
│ 1970-01-19 │ 1970-01-01 │          │
│ 1970-01-20 │ 1970-01-01 │          │
│ 1970-01-21 │ 1970-01-01 │          │
│ 1970-01-22 │ 1970-01-01 │          │
│ 1970-01-23 │ 1970-01-01 │          │
│ 1970-01-24 │ 1970-01-01 │          │
│ 1970-01-25 │ 1970-01-01 │          │
│ 1970-01-26 │ 1970-01-01 │          │
│ 1970-01-27 │ 1970-01-01 │          │
│ 1970-01-28 │ 1970-01-01 │          │
│ 1970-01-29 │ 1970-01-01 │          │
│ 1970-01-30 │ 1970-01-01 │          │
│ 1970-01-31 │ 1970-01-01 │          │
│ 1970-02-01 │ 1970-01-01 │          │
│ 1970-02-02 │ 1970-01-01 │          │
│ 1970-02-03 │ 1970-01-01 │          │
│ 1970-02-04 │ 1970-01-01 │          │
│ 1970-02-05 │ 1970-01-01 │          │
│ 1970-02-06 │ 1970-01-01 │          │
│ 1970-02-07 │ 1970-01-01 │          │
│ 1970-02-08 │ 1970-01-01 │          │
│ 1970-02-09 │ 1970-01-01 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
└────────────┴────────────┴──────────┘
```

Пример запроса без `STALENESS`:

``` sql
SELECT number as key, 5 * number value, 'original' AS source
FROM numbers(16) WHERE key % 5 == 0
ORDER BY key WITH FILL;
```

Результат:

``` text
    ┌─key─┬─value─┬─source───┐
 1. │   0 │     0 │ original │
 2. │   1 │     0 │          │
 3. │   2 │     0 │          │
 4. │   3 │     0 │          │
 5. │   4 │     0 │          │
 6. │   5 │    25 │ original │
 7. │   6 │     0 │          │
 8. │   7 │     0 │          │
 9. │   8 │     0 │          │
10. │   9 │     0 │          │
11. │  10 │    50 │ original │
12. │  11 │     0 │          │
13. │  12 │     0 │          │
14. │  13 │     0 │          │
15. │  14 │     0 │          │
16. │  15 │    75 │ original │
    └─────┴───────┴──────────┘
```

Тот же запрос после применения `STALENESS 3`:

``` sql
SELECT number as key, 5 * number value, 'original' AS source
FROM numbers(16) WHERE key % 5 == 0
ORDER BY key WITH FILL STALENESS 3;
```

Результат:

``` text
    ┌─key─┬─value─┬─source───┐
 1. │   0 │     0 │ original │
 2. │   1 │     0 │          │
 3. │   2 │     0 │          │
 4. │   5 │    25 │ original │
 5. │   6 │     0 │          │
 6. │   7 │     0 │          │
 7. │  10 │    50 │ original │
 8. │  11 │     0 │          │
 9. │  12 │     0 │          │
10. │  15 │    75 │ original │
11. │  16 │     0 │          │
12. │  17 │     0 │          │
    └─────┴───────┴──────────┘
```

Пример запроса без `INTERPOLATE`:

``` sql
SELECT n, source, inter FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5;
```

Результат:

``` text
┌───n─┬─source───┬─inter─┐
│   0 │          │     0 │
│ 0.5 │          │     0 │
│   1 │ original │     1 │
│ 1.5 │          │     0 │
│   2 │          │     0 │
│ 2.5 │          │     0 │
│   3 │          │     0 │
│ 3.5 │          │     0 │
│   4 │ original │     4 │
│ 4.5 │          │     0 │
│   5 │          │     0 │
│ 5.5 │          │     0 │
│   7 │ original │     7 │
└─────┴──────────┴───────┘
```

Тот же запрос после применения `INTERPOLATE`:

``` sql
SELECT n, source, inter FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5 INTERPOLATE (inter AS inter + 1);
```

Результат:

``` text
┌───n─┬─source───┬─inter─┐
│   0 │          │     0 │
│ 0.5 │          │     0 │
│   1 │ original │     1 │
│ 1.5 │          │     2 │
│   2 │          │     3 │
│ 2.5 │          │     4 │
│   3 │          │     5 │
│ 3.5 │          │     6 │
│   4 │ original │     4 │
│ 4.5 │          │     5 │
│   5 │          │     6 │
│ 5.5 │          │     7 │
│   7 │ original │     7 │
└─────┴──────────┴───────┘
```

## Заполнение, сгруппированное по префиксу сортировки {#filling-grouped-by-sorting-prefix}

Заполнение строк, которые имеют одинаковые значения в определенных колонках независимо, может быть полезным - хороший пример - заполнение пропущенных значений во временных рядах. Предположим, что существует следующая таблица временных рядов:
``` sql
CREATE TABLE timeseries
(
    `sensor_id` UInt64,
    `timestamp` DateTime64(3, 'UTC'),
    `value` Float64
)
ENGINE = Memory;

SELECT * FROM timeseries;

┌─sensor_id─┬───────────────timestamp─┬─value─┐
│       234 │ 2021-12-01 00:00:03.000 │     3 │
│       432 │ 2021-12-01 00:00:01.000 │     1 │
│       234 │ 2021-12-01 00:00:07.000 │     7 │
│       432 │ 2021-12-01 00:00:05.000 │     5 │
└───────────┴─────────────────────────┴───────┘
```
И мы хотели бы заполнить пропущенные значения для каждого сенсора независимо с интервалом в 1 секунду. Способом достижения этого является использование колонки `sensor_id` в качестве префикса сортировки для заполнения колонки `timestamp`:
```sql
SELECT *
FROM timeseries
ORDER BY
    sensor_id,
    timestamp WITH FILL
INTERPOLATE ( value AS 9999 );

┌─sensor_id─┬───────────────timestamp─┬─value─┐
│       234 │ 2021-12-01 00:00:03.000 │     3 │
│       234 │ 2021-12-01 00:00:04.000 │  9999 │
│       234 │ 2021-12-01 00:00:05.000 │  9999 │
│       234 │ 2021-12-01 00:00:06.000 │  9999 │
│       234 │ 2021-12-01 00:00:07.000 │     7 │
│       432 │ 2021-12-01 00:00:01.000 │     1 │
│       432 │ 2021-12-01 00:00:02.000 │  9999 │
│       432 │ 2021-12-01 00:00:03.000 │  9999 │
│       432 │ 2021-12-01 00:00:04.000 │  9999 │
│       432 │ 2021-12-01 00:00:05.000 │     5 │
└───────────┴─────────────────────────┴───────┘
```
Здесь колонка `value` была интерполирована значением `9999`, просто чтобы заполненные строки были более заметными. Это поведение контролируется настройкой `use_with_fill_by_sorting_prefix` (включена по умолчанию).

## Связанное содержание {#related-content}

- Блог: [Работа с данными временных рядов в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)

---
slug: '/sql-reference/statements/select/order-by'
sidebar_label: 'ORDER BY'
description: 'Документация по ORDER BY Clause'
title: 'Оператор ORDER BY'
doc_type: reference
---
# Клаузула ORDER BY

Клаузула `ORDER BY` содержит

- список выражений, например, `ORDER BY visits, search_phrase`,
- список чисел, указывающих на колонки в клаузуле `SELECT`, например, `ORDER BY 2, 1`, или
- `ALL`, что означает все колонки из клаузулы `SELECT`, например, `ORDER BY ALL`.

Чтобы отключить сортировку по номерам колонок, установите настройку [enable_positional_arguments](/operations/settings/settings#enable_positional_arguments) = 0. Чтобы отключить сортировку по `ALL`, установите настройку [enable_order_by_all](/operations/settings/settings#enable_order_by_all) = 0.

Клаузула `ORDER BY` может быть атрибутирована модификатором `DESC` (по убыванию) или `ASC` (по возрастанию), который определяет направление сортировки. Если явный порядок сортировки не указан, по умолчанию используется `ASC`. Направление сортировки применяется к одному выражению, а не ко всему списку, например, `ORDER BY Visits DESC, SearchPhrase`. Также сортировка выполняется с учетом регистра символов.

Строки с одинаковыми значениями для выражений сортировки возвращаются в произвольном и недетерминированном порядке. Если клаузула `ORDER BY` опущена в операторе `SELECT`, порядок строк также произвольный и недетерминированный.

## Сортировка специальных значений {#sorting-of-special-values}

Существует два подхода к порядку сортировки `NaN` и `NULL`:

- По умолчанию или с модификатором `NULLS LAST`: сначала значения, затем `NaN`, затем `NULL`.
- С модификатором `NULLS FIRST`: сначала `NULL`, затем `NaN`, затем другие значения.

### Пример {#example}

Для таблицы

```text
┌─x─┬────y─┐
│ 1 │ ᴺᵁᴸᴸ │
│ 2 │    2 │
│ 1 │  nan │
│ 2 │    2 │
│ 3 │    4 │
│ 5 │    6 │
│ 6 │  nan │
│ 7 │ ᴺᵁᴸᴸ │
│ 6 │    7 │
│ 8 │    9 │
└───┴──────┘
```

Выполните запрос `SELECT * FROM t_null_nan ORDER BY y NULLS FIRST`, чтобы получить:

```text
┌─x─┬────y─┐
│ 1 │ ᴺᵁᴸᴸ │
│ 7 │ ᴺᵁᴸᴸ │
│ 1 │  nan │
│ 6 │  nan │
│ 2 │    2 │
│ 2 │    2 │
│ 3 │    4 │
│ 5 │    6 │
│ 6 │    7 │
│ 8 │    9 │
└───┴──────┘
```

Когда числа с плавающей точкой сортируются, NaN отделены от других значений. Независимо от порядка сортировки, NaN располагаются в конце. Другими словами, при сортировке по возрастанию они размещаются, как если бы они были больше всех остальных чисел, а при сортировке по убыванию - как если бы они были меньше остальных.

## Поддержка коллации {#collation-support}

Для сортировки по значениям [String](../../../sql-reference/data-types/string.md) вы можете указать коллацию (сравнение). Пример: `ORDER BY SearchPhrase COLLATE 'tr'` - для сортировки по ключевому слову в порядке возрастания, с использованием турецкого алфавита, без учета регистра, предполагая, что строки закодированы в UTF-8. `COLLATE` может быть указан или не указан для каждого выражения в `ORDER BY` независимо. Если указаны `ASC` или `DESC`, `COLLATE` указывается после этого. При использовании `COLLATE` сортировка всегда нечувствительна к регистру.

Поддержка коллации есть в [LowCardinality](../../../sql-reference/data-types/lowcardinality.md), [Nullable](../../../sql-reference/data-types/nullable.md), [Array](../../../sql-reference/data-types/array.md) и [Tuple](../../../sql-reference/data-types/tuple.md).

Рекомендуется использовать `COLLATE` только для окончательной сортировки небольшого количества строк, так как сортировка с `COLLATE` менее эффективна, чем обычная сортировка по байтам.

## Примеры коллации {#collation-examples}

Пример только с [String](../../../sql-reference/data-types/string.md) значениями:

Входная таблица:

```text
┌─x─┬─s────┐
│ 1 │ bca  │
│ 2 │ ABC  │
│ 3 │ 123a │
│ 4 │ abc  │
│ 5 │ BCA  │
└───┴──────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```text
┌─x─┬─s────┐
│ 3 │ 123a │
│ 4 │ abc  │
│ 2 │ ABC  │
│ 1 │ bca  │
│ 5 │ BCA  │
└───┴──────┘
```

Пример с [Nullable](../../../sql-reference/data-types/nullable.md):

Входная таблица:

```text
┌─x─┬─s────┐
│ 1 │ bca  │
│ 2 │ ᴺᵁᴸᴸ │
│ 3 │ ABC  │
│ 4 │ 123a │
│ 5 │ abc  │
│ 6 │ ᴺᵁᴸᴸ │
│ 7 │ BCA  │
└───┴──────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```text
┌─x─┬─s────┐
│ 4 │ 123a │
│ 5 │ abc  │
│ 3 │ ABC  │
│ 1 │ bca  │
│ 7 │ BCA  │
│ 6 │ ᴺᵁᴸᴸ │
│ 2 │ ᴺᵁᴸᴸ │
└───┴──────┘
```

Пример с [Array](../../../sql-reference/data-types/array.md):

Входная таблица:

```text
┌─x─┬─s─────────────┐
│ 1 │ ['Z']         │
│ 2 │ ['z']         │
│ 3 │ ['a']         │
│ 4 │ ['A']         │
│ 5 │ ['z','a']     │
│ 6 │ ['z','a','a'] │
│ 7 │ ['']          │
└───┴───────────────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```text
┌─x─┬─s─────────────┐
│ 7 │ ['']          │
│ 3 │ ['a']         │
│ 4 │ ['A']         │
│ 2 │ ['z']         │
│ 5 │ ['z','a']     │
│ 6 │ ['z','a','a'] │
│ 1 │ ['Z']         │
└───┴───────────────┘
```

Пример со строкой [LowCardinality](../../../sql-reference/data-types/lowcardinality.md):

Входная таблица:

```response
┌─x─┬─s───┐
│ 1 │ Z   │
│ 2 │ z   │
│ 3 │ a   │
│ 4 │ A   │
│ 5 │ za  │
│ 6 │ zaa │
│ 7 │     │
└───┴─────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```response
┌─x─┬─s───┐
│ 7 │     │
│ 3 │ a   │
│ 4 │ A   │
│ 2 │ z   │
│ 1 │ Z   │
│ 5 │ za  │
│ 6 │ zaa │
└───┴─────┘
```

Пример с [Tuple](../../../sql-reference/data-types/tuple.md):

```response
┌─x─┬─s───────┐
│ 1 │ (1,'Z') │
│ 2 │ (1,'z') │
│ 3 │ (1,'a') │
│ 4 │ (2,'z') │
│ 5 │ (1,'A') │
│ 6 │ (2,'Z') │
│ 7 │ (2,'A') │
└───┴─────────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```response
┌─x─┬─s───────┐
│ 3 │ (1,'a') │
│ 5 │ (1,'A') │
│ 2 │ (1,'z') │
│ 1 │ (1,'Z') │
│ 7 │ (2,'A') │
│ 4 │ (2,'z') │
│ 6 │ (2,'Z') │
└───┴─────────┘
```

## Подробности реализации {#implementation-details}

Используется меньше RAM, если дополнительно к `ORDER BY` указан достаточно малый [LIMIT](../../../sql-reference/statements/select/limit.md). В противном случае объем потребляемой памяти пропорционален объему данных для сортировки. Для распределенной обработки запросов, если [GROUP BY](/sql-reference/statements/select/group-by) опущен, сортировка частично выполняется на удаленных серверах, а результаты сливаются на сервере, который запросил данные. Это означает, что для распределенной сортировки объем данных для сортировки может превышать объем памяти на одном сервере.

Если не хватает RAM, сортировку можно выполнить во внешней памяти (создание временных файлов на диске). Для этой цели используйте настройку `max_bytes_before_external_sort`. Если она установлена на 0 (по умолчанию), внешняя сортировка отключена. Если она включена, когда объем данных для сортировки достигает указанного числа байтов, собранные данные сортируются и сбрасываются во временный файл. После того, как все данные будут прочитаны, все отсортированные файлы объединяются, и результаты выводятся. Файлы записываются в директорию `/var/lib/clickhouse/tmp/` в конфигурации (по умолчанию, но вы можете использовать параметр `tmp_path`, чтобы изменить эту настройку). Вы также можете использовать сброс на диск только в случае, если запрос превышает лимиты памяти, т.е. `max_bytes_ratio_before_external_sort=0.6` позволит сбрасывать на диск только после достижения 60% лимита памяти (пользователь/сервер).

Выполнение запроса может использовать больше памяти, чем `max_bytes_before_external_sort`. По этой причине эта настройка должна иметь значение значительно меньше, чем `max_memory_usage`. Например, если ваш сервер имеет 128 ГБ оперативной памяти, и вам нужно выполнить один запрос, установите `max_memory_usage` на 100 ГБ, а `max_bytes_before_external_sort` на 80 ГБ.

Внешняя сортировка работает гораздо менее эффективно, чем сортировка в RAM.

## Оптимизация чтения данных {#optimization-of-data-reading}

Если выражение `ORDER BY` имеет префикс, совпадающий с ключом сортировки таблицы, вы можете оптимизировать запрос, используя настройку [optimize_read_in_order](../../../operations/settings/settings.md#optimize_read_in_order).

Когда настройка `optimize_read_in_order` включена, сервер ClickHouse использует индекс таблицы и читает данные в порядке ключа `ORDER BY`. Это позволяет избежать чтения всех данных в случае указанного [LIMIT](../../../sql-reference/statements/select/limit.md). Таким образом, запросы на большие объемы данных с небольшим лимитом обрабатываются быстрее.

Оптимизация работает как с `ASC`, так и с `DESC` и не работает вместе с клаузулой [GROUP BY](/sql-reference/statements/select/group-by) и модификатором [FINAL](/sql-reference/statements/select/from#final-modifier).

Когда настройка `optimize_read_in_order` отключена, сервер ClickHouse не использует индекс таблицы при обработке запросов `SELECT`.

Рекомендуется отключить `optimize_read_in_order` вручную при выполнении запросов, которые содержат клаузулу `ORDER BY`, большой `LIMIT` и условие [WHERE](../../../sql-reference/statements/select/where.md), требующее чтения огромного количества записей до нахождения запрашиваемых данных.

Оптимизация поддерживается в следующих движках таблиц:

- [MergeTree](../../../engines/table-engines/mergetree-family/mergetree.md) (включая [материализованные представления](/sql-reference/statements/create/view#materialized-view)),
- [Merge](../../../engines/table-engines/special/merge.md),
- [Buffer](../../../engines/table-engines/special/buffer.md)

В таблицах движка `MaterializedView` оптимизация работает с представлениями, такими как `SELECT ... FROM merge_tree_table ORDER BY pk`. Но она не поддерживается в запросах типа `SELECT ... FROM view ORDER BY pk`, если запрос представления не содержит клаузу `ORDER BY`.

## Модификатор ORDER BY Expr WITH FILL {#order-by-expr-with-fill-modifier}

Этот модификатор также может быть объединён с модификатором [LIMIT ... WITH TIES](/sql-reference/statements/select/limit#limit--with-ties-modifier).

Модификатор `WITH FILL` может быть установлен после `ORDER BY expr` с необязательными параметрами `FROM expr`, `TO expr` и `STEP expr`. Все пропущенные значения колонки `expr` будут заполнены последовательно, а другие колонки будут заполнены по умолчанию.

Чтобы заполнить несколько колонок, добавьте модификатор `WITH FILL` с необязательными параметрами после каждого имени поля в секции `ORDER BY`.

```sql
ORDER BY expr [WITH FILL] [FROM const_expr] [TO const_expr] [STEP const_numeric_expr] [STALENESS const_numeric_expr], ... exprN [WITH FILL] [FROM expr] [TO expr] [STEP numeric_expr] [STALENESS numeric_expr]
[INTERPOLATE [(col [AS expr], ... colN [AS exprN])]]
```

`WITH FILL` может быть применён для полей с числовыми (все виды float, decimal, int) или Date/DateTime типами. Когда применяется к полям `String`, пропущенные значения заполняются пустыми строками. Когда `FROM const_expr` не определено, последовательность заполнения использует минимальное значение поля `expr` из `ORDER BY`. Когда `TO const_expr` не определено, последовательность заполнения использует максимальное значение поля `expr` из `ORDER BY`. Когда `STEP const_numeric_expr` определён, то `const_numeric_expr` интерпретируется как есть для числовых типов, как дни для типа Date, как секунды для типа DateTime. Он также поддерживает тип данных [INTERVAL](/sql-reference/data-types/special-data-types/interval/), представляющий временные и датированные интервалы. Когда `STEP const_numeric_expr` опущен, последовательность заполнения использует `1.0` для числового типа, `1 day` для типа Date и `1 second` для типа DateTime. Когда `STALENESS const_numeric_expr` определён, запрос будет генерировать строки, пока разница от предыдущей строки в оригинальных данных не превысит `const_numeric_expr`. `INTERPOLATE` может быть применён к колонкам, не участвующим в `ORDER BY WITH FILL`. Такие колонки заполняются на основе значений предыдущих полей, применяя `expr`. Если `expr` отсутствует, будет повторено предыдущее значение. Ожидаемый список приведёт к включению всех разрешённых колонок.

Пример запроса без `WITH FILL`:

```sql
SELECT n, source FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n;
```

Результат:

```text
┌─n─┬─source───┐
│ 1 │ original │
│ 4 │ original │
│ 7 │ original │
└───┴──────────┘
```

Тот же запрос после применения модификатора `WITH FILL`:

```sql
SELECT n, source FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5;
```

Результат:

```text
┌───n─┬─source───┐
│   0 │          │
│ 0.5 │          │
│   1 │ original │
│ 1.5 │          │
│   2 │          │
│ 2.5 │          │
│   3 │          │
│ 3.5 │          │
│   4 │ original │
│ 4.5 │          │
│   5 │          │
│ 5.5 │          │
│   7 │ original │
└─────┴──────────┘
```

В случае с несколькими полями `ORDER BY field2 WITH FILL, field1 WITH FILL` порядок заполнения будет следовать порядку полей в клаузе `ORDER BY`.

Пример:

```sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d2 WITH FILL,
    d1 WITH FILL STEP 5;
```

Результат:

```text
┌───d1───────┬───d2───────┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-01 │ 1970-01-03 │          │
│ 1970-01-01 │ 1970-01-04 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
│ 1970-01-01 │ 1970-01-06 │          │
│ 1970-01-01 │ 1970-01-07 │          │
│ 1970-03-12 │ 1970-01-08 │ original │
└────────────┴────────────┴──────────┘
```

Поле `d1` не заполняется и использует значение по умолчанию, так как у нас нет повторяющихся значений для значения `d2`, и последовательность для `d1` не может быть правильно вычислена.

Следующий запрос с изменённым полем в `ORDER BY`:

```sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d1 WITH FILL STEP 5,
    d2 WITH FILL;
```

Результат:

```text
┌───d1───────┬───d2───────┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-16 │ 1970-01-01 │          │
│ 1970-01-21 │ 1970-01-01 │          │
│ 1970-01-26 │ 1970-01-01 │          │
│ 1970-01-31 │ 1970-01-01 │          │
│ 1970-02-05 │ 1970-01-01 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
│ 1970-02-15 │ 1970-01-01 │          │
│ 1970-02-20 │ 1970-01-01 │          │
│ 1970-02-25 │ 1970-01-01 │          │
│ 1970-03-02 │ 1970-01-01 │          │
│ 1970-03-07 │ 1970-01-01 │          │
│ 1970-03-12 │ 1970-01-08 │ original │
└────────────┴────────────┴──────────┘
```

Следующий запрос использует тип данных `INTERVAL` в 1 день для каждого заполненного значения в колонке `d1`:

```sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d1 WITH FILL STEP INTERVAL 1 DAY,
    d2 WITH FILL;
```

Результат:
```response
┌─────────d1─┬─────────d2─┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-12 │ 1970-01-01 │          │
│ 1970-01-13 │ 1970-01-01 │          │
│ 1970-01-14 │ 1970-01-01 │          │
│ 1970-01-15 │ 1970-01-01 │          │
│ 1970-01-16 │ 1970-01-01 │          │
│ 1970-01-17 │ 1970-01-01 │          │
│ 1970-01-18 │ 1970-01-01 │          │
│ 1970-01-19 │ 1970-01-01 │          │
│ 1970-01-20 │ 1970-01-01 │          │
│ 1970-01-21 │ 1970-01-01 │          │
│ 1970-01-22 │ 1970-01-01 │          │
│ 1970-01-23 │ 1970-01-01 │          │
│ 1970-01-24 │ 1970-01-01 │          │
│ 1970-01-25 │ 1970-01-01 │          │
│ 1970-01-26 │ 1970-01-01 │          │
│ 1970-01-27 │ 1970-01-01 │          │
│ 1970-01-28 │ 1970-01-01 │          │
│ 1970-01-29 │ 1970-01-01 │          │
│ 1970-01-30 │ 1970-01-01 │          │
│ 1970-01-31 │ 1970-01-01 │          │
│ 1970-02-01 │ 1970-01-01 │          │
│ 1970-02-02 │ 1970-01-01 │          │
│ 1970-02-03 │ 1970-01-01 │          │
│ 1970-02-04 │ 1970-01-01 │          │
│ 1970-02-05 │ 1970-01-01 │          │
│ 1970-02-06 │ 1970-01-01 │          │
│ 1970-02-07 │ 1970-01-01 │          │
│ 1970-02-08 │ 1970-01-01 │          │
│ 1970-02-09 │ 1970-01-01 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
│ 1970-02-11 │ 1970-01-01 │          │
│ 1970-02-12 │ 1970-01-01 │          │
│ 1970-02-13 │ 1970-01-01 │          │
│ 1970-02-14 │ 1970-01-01 │          │
│ 1970-02-15 │ 1970-01-01 │          │
│ 1970-02-16 │ 1970-01-01 │          │
│ 1970-02-17 │ 1970-01-01 │          │
│ 1970-02-18 │ 1970-01-01 │          │
│ 1970-02-19 │ 1970-01-01 │          │
│ 1970-02-20 │ 1970-01-01 │          │
│ 1970-02-21 │ 1970-01-01 │          │
│ 1970-02-22 │ 1970-01-01 │          │
│ 1970-02-23 │ 1970-01-01 │          │
│ 1970-02-24 │ 1970-01-01 │          │
│ 1970-02-25 │ 1970-01-01 │          │
│ 1970-02-26 │ 1970-01-01 │          │
│ 1970-02-27 │ 1970-01-01 │          │
│ 1970-02-28 │ 1970-01-01 │          │
│ 1970-03-01 │ 1970-01-01 │          │
│ 1970-03-02 │ 1970-01-01 │          │
│ 1970-03-03 │ 1970-01-01 │          │
│ 1970-03-04 │ 1970-01-01 │          │
│ 1970-03-05 │ 1970-01-01 │          │
│ 1970-03-06 │ 1970-01-01 │          │
│ 1970-03-07 │ 1970-01-01 │          │
│ 1970-03-08 │ 1970-01-01 │          │
│ 1970-03-09 │ 1970-01-01 │          │
│ 1970-03-10 │ 1970-01-01 │          │
│ 1970-03-11 │ 1970-01-01 │          │
│ 1970-03-12 │ 1970-01-08 │ original │
└────────────┴────────────┴──────────┘
```

Пример запроса без `STALENESS`:

```sql
SELECT number AS key, 5 * number value, 'original' AS source
FROM numbers(16) WHERE key % 5 == 0
ORDER BY key WITH FILL;
```

Результат:

```text
    ┌─key─┬─value─┬─source───┐
 1. │   0 │     0 │ original │
 2. │   1 │     0 │          │
 3. │   2 │     0 │          │
 4. │   3 │     0 │          │
 5. │   4 │     0 │          │
 6. │   5 │    25 │ original │
 7. │   6 │     0 │          │
 8. │   7 │     0 │          │
 9. │   8 │     0 │          │
10. │   9 │     0 │          │
11. │  10 │    50 │ original │
12. │  11 │     0 │          │
13. │  12 │     0 │          │
14. │  13 │     0 │          │
15. │  14 │     0 │          │
16. │  15 │    75 │ original │
    └─────┴───────┴──────────┘
```

Тот же запрос после применения `STALENESS 3`:

```sql
SELECT number AS key, 5 * number value, 'original' AS source
FROM numbers(16) WHERE key % 5 == 0
ORDER BY key WITH FILL STALENESS 3;
```

Результат:

```text
    ┌─key─┬─value─┬─source───┐
 1. │   0 │     0 │ original │
 2. │   1 │     0 │          │
 3. │   2 │     0 │          │
 4. │   5 │    25 │ original │
 5. │   6 │     0 │          │
 6. │   7 │     0 │          │
 7. │  10 │    50 │ original │
 8. │  11 │     0 │          │
 9. │  12 │     0 │          │
10. │  15 │    75 │ original │
11. │  16 │     0 │          │
12. │  17 │     0 │          │
    └─────┴───────┴──────────┘
```

Пример запроса без `INTERPOLATE`:

```sql
SELECT n, source, inter FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5;
```

Результат:

```text
┌───n─┬─source───┬─inter─┐
│   0 │          │     0 │
│ 0.5 │          │     0 │
│   1 │ original │     1 │
│ 1.5 │          │     0 │
│   2 │          │     0 │
│ 2.5 │          │     0 │
│   3 │          │     0 │
│ 3.5 │          │     0 │
│   4 │ original │     4 │
│ 4.5 │          │     0 │
│   5 │          │     0 │
│ 5.5 │          │     0 │
│   7 │ original │     7 │
└─────┴──────────┴───────┘
```

Тот же запрос после применения `INTERPOLATE`:

```sql
SELECT n, source, inter FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5 INTERPOLATE (inter AS inter + 1);
```

Результат:

```text
┌───n─┬─source───┬─inter─┐
│   0 │          │     0 │
│ 0.5 │          │     0 │
│   1 │ original │     1 │
│ 1.5 │          │     2 │
│   2 │          │     3 │
│ 2.5 │          │     4 │
│   3 │          │     5 │
│ 3.5 │          │     6 │
│   4 │ original │     4 │
│ 4.5 │          │     5 │
│   5 │          │     6 │
│ 5.5 │          │     7 │
│   7 │ original │     7 │
└─────┴──────────┴───────┘
```

## Заполнение группами по префиксу сортировки {#filling-grouped-by-sorting-prefix}

Полезно выполнять заполнение строк, у которых одинаковые значения в определённых колонках независимо, - хороший пример это заполнение недостающих значений во временных рядах. Предположим, есть следующая таблица временных рядов:
```sql
CREATE TABLE timeseries
(
    `sensor_id` UInt64,
    `timestamp` DateTime64(3, 'UTC'),
    `value` Float64
)
ENGINE = Memory;

SELECT * FROM timeseries;

┌─sensor_id─┬───────────────timestamp─┬─value─┐
│       234 │ 2021-12-01 00:00:03.000 │     3 │
│       432 │ 2021-12-01 00:00:01.000 │     1 │
│       234 │ 2021-12-01 00:00:07.000 │     7 │
│       432 │ 2021-12-01 00:00:05.000 │     5 │
└───────────┴─────────────────────────┴───────┘
```
И нам нужно заполнить недостающие значения для каждого датчика независимо с интервалом в 1 секунду. Способ достижения этого - использовать колонку `sensor_id` в качестве префикса сортировки для заполнения колонки `timestamp`:
```sql
SELECT *
FROM timeseries
ORDER BY
    sensor_id,
    timestamp WITH FILL
INTERPOLATE ( value AS 9999 )

┌─sensor_id─┬───────────────timestamp─┬─value─┐
│       234 │ 2021-12-01 00:00:03.000 │     3 │
│       234 │ 2021-12-01 00:00:04.000 │  9999 │
│       234 │ 2021-12-01 00:00:05.000 │  9999 │
│       234 │ 2021-12-01 00:00:06.000 │  9999 │
│       234 │ 2021-12-01 00:00:07.000 │     7 │
│       432 │ 2021-12-01 00:00:01.000 │     1 │
│       432 │ 2021-12-01 00:00:02.000 │  9999 │
│       432 │ 2021-12-01 00:00:03.000 │  9999 │
│       432 │ 2021-12-01 00:00:04.000 │  9999 │
│       432 │ 2021-12-01 00:00:05.000 │     5 │
└───────────┴─────────────────────────┴───────┘
```
Здесь колонка `value` была интерполирована с `9999`, чтобы сделать заполненные строки более заметными. Это поведение контролируется настройкой `use_with_fill_by_sorting_prefix` (включена по умолчанию).

## Связанный контент {#related-content}

- Блог: [Работа с данными временных рядов в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)
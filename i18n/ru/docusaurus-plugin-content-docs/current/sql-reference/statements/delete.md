---
description: 'Облегчённое удаление упрощает процесс удаления данных из базы данных.'
keywords: ['delete']
sidebar_label: 'DELETE'
sidebar_position: 36
slug: /sql-reference/statements/delete
title: 'Оператор облегчённого удаления DELETE'
doc_type: 'reference'
---

Облегчённый оператор `DELETE` удаляет строки из таблицы `[db.]table`, удовлетворяющие выражению `expr`. Он доступен только для *семейства движков таблиц MergeTree*.

```sql
DELETE FROM [db.]table [ON CLUSTER cluster] [IN PARTITION partition_expr] WHERE expr;
```

Он называется &quot;облегчённый `DELETE`&quot; в противоположность команде [ALTER TABLE ... DELETE](/sql-reference/statements/alter/delete), которая представляет собой ресурсоёмкую операцию.


## Примеры {#examples}

```sql
-- Удаляет все строки из таблицы `hits`, где столбец `Title` содержит текст `hello`
DELETE FROM hits WHERE Title LIKE '%hello%';
```


## Облегчённый `DELETE` не удаляет данные немедленно {#lightweight-delete-does-not-delete-data-immediately}

Облегчённый `DELETE` реализован как [мутация](/sql-reference/statements/alter#mutations), которая помечает строки как удалённые, но не удаляет их физически сразу же.

По умолчанию операторы `DELETE` ожидают завершения пометки строк как удалённых перед возвратом результата. Это может занять много времени при большом объёме данных. В качестве альтернативы можно выполнить операцию асинхронно в фоновом режиме, используя настройку [`lightweight_deletes_sync`](/operations/settings/settings#lightweight_deletes_sync). Если она отключена, оператор `DELETE` вернёт результат немедленно, но данные могут оставаться видимыми для запросов до завершения фоновой мутации.

Мутация не удаляет физически строки, помеченные как удалённые — это произойдёт только во время следующего слияния. В результате возможна ситуация, когда в течение неопределённого периода данные фактически не удалены из хранилища, а только помечены как удалённые.

Если необходимо гарантировать удаление данных из хранилища в предсказуемое время, рассмотрите возможность использования настройки таблицы [`min_age_to_force_merge_seconds`](/operations/settings/merge-tree-settings#min_age_to_force_merge_seconds). Также можно использовать команду [ALTER TABLE ... DELETE](/sql-reference/statements/alter/delete). Обратите внимание, что удаление данных с помощью `ALTER TABLE ... DELETE` может потреблять значительные ресурсы, так как пересоздаёт все затронутые части.


## Удаление больших объемов данных {#deleting-large-amounts-of-data}

Удаление больших объемов данных может негативно повлиять на производительность ClickHouse. Если необходимо удалить все строки из таблицы, рекомендуется использовать команду [`TRUNCATE TABLE`](/sql-reference/statements/truncate).

Если предполагаются частые удаления, рекомендуется использовать [пользовательский ключ партиционирования](/engines/table-engines/mergetree-family/custom-partitioning-key). В этом случае можно использовать команду [`ALTER TABLE ... DROP PARTITION`](/sql-reference/statements/alter/partition#drop-partitionpart) для быстрого удаления всех строк, связанных с данной партицией.


## Ограничения облегчённого `DELETE` {#limitations-of-lightweight-delete}

### Облегчённый `DELETE` с проекциями {#lightweight-deletes-with-projections}

По умолчанию `DELETE` не работает для таблиц с проекциями. Это связано с тем, что строки в проекции могут быть затронуты операцией `DELETE`. Однако для изменения этого поведения существует [настройка MergeTree](/operations/settings/merge-tree-settings) `lightweight_mutation_projection_mode`.


## Соображения по производительности при использовании облегчённого `DELETE` {#performance-considerations-when-using-lightweight-delete}

**Удаление больших объёмов данных с помощью облегчённого оператора `DELETE` может негативно повлиять на производительность запросов SELECT.**

Следующие факторы также могут негативно повлиять на производительность облегчённого `DELETE`:

- Сложное условие `WHERE` в запросе `DELETE`.
- Если очередь мутаций заполнена множеством других мутаций, это может привести к проблемам с производительностью, так как все мутации таблицы выполняются последовательно.
- Затрагиваемая таблица содержит очень большое количество кусков данных.
- Наличие большого количества данных в компактных кусках. В компактном куске все столбцы хранятся в одном файле.


## Права на удаление {#delete-permissions}

Для выполнения `DELETE` требуется привилегия `ALTER DELETE`. Чтобы разрешить выполнение операторов `DELETE` для определённой таблицы конкретному пользователю, выполните следующую команду:

```sql
GRANT ALTER DELETE ON db.table TO username;
```


## Как работают облегчённые DELETE внутри ClickHouse {#how-lightweight-deletes-work-internally-in-clickhouse}

1. **К затронутым строкам применяется «маска»**

   При выполнении запроса `DELETE FROM table ...` ClickHouse сохраняет маску, в которой каждая строка помечается как «существующая» или «удалённая». Эти «удалённые» строки пропускаются в последующих запросах. Однако фактическое удаление строк происходит позже при последующих слияниях. Запись этой маски является гораздо более лёгкой операцией по сравнению с тем, что выполняется запросом `ALTER TABLE ... DELETE`.

   Маска реализована в виде скрытого системного столбца `_row_exists`, который хранит значение `True` для всех видимых строк и `False` для удалённых. Этот столбец присутствует в куске только в том случае, если некоторые строки в куске были удалены. Этот столбец отсутствует, когда в куске все значения равны `True`.

2. **Запросы `SELECT` преобразуются для включения маски**

   Когда используется маска, запрос `SELECT ... FROM table WHERE condition` внутренне расширяется предикатом по `_row_exists` и преобразуется в:

   ```sql
   SELECT ... FROM table PREWHERE _row_exists WHERE condition
   ```

   Во время выполнения столбец `_row_exists` читается для определения того, какие строки не должны быть возвращены. Если удалённых строк много, ClickHouse может определить, какие гранулы можно полностью пропустить при чтении остальных столбцов.

3. **Запросы `DELETE` преобразуются в запросы `ALTER TABLE ... UPDATE`**

   Запрос `DELETE FROM table WHERE condition` транслируется в мутацию `ALTER TABLE table UPDATE _row_exists = 0 WHERE condition`.

   Внутренне эта мутация выполняется в два этапа:
   1. Для каждого отдельного куска выполняется команда `SELECT count() FROM table WHERE condition`, чтобы определить, затронут ли кусок.

   2. На основе приведённых выше команд затронутые куски затем мутируются, а для незатронутых кусков создаются жёсткие ссылки. В случае широких кусков столбец `_row_exists` для каждой строки обновляется, а файлы всех остальных столбцов связываются жёсткими ссылками. Для компактных кусков все столбцы перезаписываются, поскольку все они хранятся вместе в одном файле.

   Из приведённых выше шагов видно, что облегчённый `DELETE` с использованием техники маскирования улучшает производительность по сравнению с традиционным `ALTER TABLE ... DELETE`, поскольку он не перезаписывает файлы всех столбцов для затронутых кусков.


## Связанный контент {#related-content}

- Блог: [Обработка обновлений и удалений в ClickHouse](https://clickhouse.com/blog/handling-updates-and-deletes-in-clickhouse)

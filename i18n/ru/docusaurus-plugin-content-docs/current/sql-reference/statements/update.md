---
description: 'Легковесные обновления упрощают процесс обновления данных в базе данных с помощью патч-частей.'
keywords: ['update']
sidebar_label: 'UPDATE'
sidebar_position: 39
slug: /sql-reference/statements/update
title: 'Оператор легковесного UPDATE'
doc_type: 'reference'
---

import BetaBadge from '@theme/badges/BetaBadge';

<BetaBadge />

:::note
Легковесные обновления в настоящее время находятся на стадии бета-тестирования.
Если вы столкнётесь с проблемами, откройте обращение в [репозитории ClickHouse](https://github.com/clickhouse/clickhouse/issues).
:::

Легковесный оператор `UPDATE` обновляет строки в таблице `[db.]table`, которые удовлетворяют выражению `filter_expr`.
Он называется «легковесным обновлением», чтобы противопоставить его запросу [`ALTER TABLE ... UPDATE`](/sql-reference/statements/alter/update), который является ресурсоёмкой операцией и полностью перезаписывает столбцы в частях данных.
Он доступен только для семейства движков таблиц [`MergeTree`](/engines/table-engines/mergetree-family/mergetree).

```sql
UPDATE [db.]table [ON CLUSTER cluster] SET column1 = expr1 [, ...] [IN PARTITION partition_expr] WHERE filter_expr;
```

`filter_expr` должен иметь тип `UInt8`. Этот запрос обновляет значения указанных столбцов на значения соответствующих выражений в строках, в которых `filter_expr` принимает ненулевое значение.
Значения приводятся к типу столбца с помощью оператора `CAST`. Обновление столбцов, используемых при вычислении первичного ключа или ключа партиционирования, не поддерживается.


## Примеры {#examples}

```sql
UPDATE hits SET Title = 'Updated Title' WHERE EventDate = today();

UPDATE wikistat SET hits = hits + 1, time = now() WHERE path = 'ClickHouse';
```


## Легковесные обновления не изменяют данные немедленно {#lightweight-update-does-not-update-data-immediately}

Легковесный `UPDATE` реализован с использованием **частей-патчей** — специального типа частей данных, содержащих только обновлённые столбцы и строки.
Легковесный `UPDATE` создаёт части-патчи, но не изменяет исходные данные в хранилище физически сразу же.
Процесс обновления аналогичен запросу `INSERT ... SELECT ...`, но запрос `UPDATE` ожидает завершения создания части-патча перед возвратом управления.


Обновлённые значения:

- **Немедленно видны** в запросах `SELECT` благодаря применению патчей
- **Физически материализуются** только при последующих слияниях и мутациях
- **Автоматически удаляются** после материализации патчей во всех активных частях

## Требования к лёгким обновлениям {#lightweight-update-requirements}

Лёгкие обновления поддерживаются для движков [`MergeTree`](/engines/table-engines/mergetree-family/mergetree), [`ReplacingMergeTree`](/engines/table-engines/mergetree-family/replacingmergetree), [`CollapsingMergeTree`](/engines/table-engines/mergetree-family/collapsingmergetree), а также их версий [`Replicated`](/engines/table-engines/mergetree-family/replication.md) и [`Shared`](/cloud/reference/shared-merge-tree).

Для использования лёгких обновлений необходимо включить материализацию столбцов `_block_number` и `_block_offset` с помощью настроек таблицы [`enable_block_number_column`](/operations/settings/merge-tree-settings#enable_block_number_column) и [`enable_block_offset_column`](/operations/settings/merge-tree-settings#enable_block_offset_column).


## Облегчённые удаления {#lightweight-delete}

Запрос [облегчённого `DELETE`](/sql-reference/statements/delete) может выполняться как облегчённый `UPDATE` вместо мутации `ALTER UPDATE`. Реализация облегчённого `DELETE` контролируется настройкой [`lightweight_delete_mode`](/operations/settings/settings#lightweight_delete_mode).


## Соображения по производительности {#performance-considerations}

**Преимущества легковесных обновлений:**

- Задержка обновления сопоставима с задержкой запроса `INSERT ... SELECT ...`
- Записываются только обновляемые столбцы и значения, а не целые столбцы в кусках данных
- Нет необходимости ожидать завершения текущих слияний/мутаций, поэтому задержка обновления предсказуема
- Возможно параллельное выполнение легковесных обновлений

**Потенциальное влияние на производительность:**

- Добавляет накладные расходы к запросам `SELECT`, которым необходимо применять патчи
- [Индексы пропуска](/engines/table-engines/mergetree-family/mergetree.md#table_engine-mergetree-data_skipping-indexes) не будут использоваться для столбцов в кусках данных, к которым необходимо применить патчи. [Проекции](/engines/table-engines/mergetree-family/mergetree.md/#projections) не будут использоваться, если для таблицы существуют куски с патчами, включая куски данных, к которым не требуется применять патчи.
- Небольшие слишком частые обновления могут привести к ошибке «too many parts». Рекомендуется объединять несколько обновлений в один запрос, например, помещая идентификаторы для обновлений в одно условие `IN` в предложении `WHERE`
- Легковесные обновления предназначены для обновления небольшого количества строк (до примерно 10% таблицы). Если необходимо обновить большее количество строк, рекомендуется использовать мутацию [`ALTER TABLE ... UPDATE`](/sql-reference/statements/alter/update)


## Параллельные операции {#concurrent-operations}

Легковесные обновления не ожидают завершения выполняющихся в данный момент слияний/мутаций, в отличие от тяжелых мутаций.
Согласованность параллельных легковесных обновлений контролируется настройками [`update_sequential_consistency`](/operations/settings/settings#update_sequential_consistency) и [`update_parallel_mode`](/operations/settings/settings#update_parallel_mode).


## Права доступа для UPDATE {#update-permissions}

Для выполнения `UPDATE` требуется привилегия `ALTER UPDATE`. Чтобы разрешить выполнение операторов `UPDATE` на конкретной таблице для определённого пользователя, выполните:

```sql
GRANT ALTER UPDATE ON db.table TO username;
```


## Детали реализации {#details-of-the-implementation}

Патч-части аналогичны обычным частям, но содержат только обновлённые колонки и несколько системных колонок:

- `_part` — имя исходной части
- `_part_offset` — номер строки в исходной части
- `_block_number` — номер блока строки в исходной части
- `_block_offset` — смещение блока строки в исходной части
- `_data_version` — версия обновлённых данных (номер блока, выделенный для запроса `UPDATE`)

В среднем это составляет около 40 байт (несжатых данных) накладных расходов на каждую обновлённую строку в патч-частях.
Системные колонки помогают найти строки в исходной части, которые должны быть обновлены.
Системные колонки связаны с [виртуальными колонками](/engines/table-engines/mergetree-family/mergetree.md/#virtual-columns) в исходной части, которые добавляются для чтения при применении патч-частей.
Патч-части отсортированы по `_part` и `_part_offset`.

Патч-части принадлежат к другим партициям, отличным от исходной части.
Идентификатор партиции патч-части имеет вид `patch-<хеш имён колонок в патч-части>-<original_partition_id>`.
Таким образом, патч-части с различными колонками хранятся в разных партициях.
Например, три обновления `SET x = 1 WHERE <cond>`, `SET y = 1 WHERE <cond>` и `SET x = 1, y = 1 WHERE <cond>` создадут три патч-части в трёх разных партициях.

Патч-части могут объединяться между собой для уменьшения количества применяемых патчей при выполнении запросов `SELECT` и снижения накладных расходов. Слияние патч-частей использует алгоритм слияния [replacing](/engines/table-engines/mergetree-family/replacingmergetree) с `_data_version` в качестве колонки версии.
Таким образом, патч-части всегда хранят последнюю версию для каждой обновлённой строки в части.

Лёгкие обновления не ожидают завершения текущих слияний и мутаций и всегда используют текущий снимок частей данных для выполнения обновления и создания патч-части.
В связи с этим возможны два случая применения патч-частей.

Например, если мы читаем часть `A`, нам необходимо применить патч-часть `X`:

- если `X` содержит саму часть `A`. Это происходит, если `A` не участвовала в слиянии при выполнении `UPDATE`.
- если `X` содержит части `B` и `C`, которые покрываются частью `A`. Это происходит, если при выполнении `UPDATE` выполнялось слияние (`B`, `C`) -> `A`.

Для этих двух случаев существуют два способа применения патч-частей соответственно:

- Использование слияния по отсортированным колонкам `_part`, `_part_offset`.
- Использование соединения по колонкам `_block_number`, `_block_offset`.

Режим соединения медленнее и требует больше памяти, чем режим слияния, но используется реже.


## Связанный контент {#related-content}

- [`ALTER UPDATE`](/sql-reference/statements/alter/update) - Тяжёлые операции `UPDATE`
- [Lightweight `DELETE`](/sql-reference/statements/delete) - Облегчённые операции `DELETE`

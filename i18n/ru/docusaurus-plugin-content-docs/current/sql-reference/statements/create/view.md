---
slug: /sql-reference/statements/create/view
sidebar_position: 37
sidebar_label: VIEW
---
import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import DeprecatedBadge from '@theme/badges/DeprecatedBadge';
import CloudNotSupportedBadge from '@theme/badges/CloudNotSupportedBadge';


# СОЗДАТЬ VIEW

Создает новое представление. Представления могут быть [обычными](#normal-view), [материализованными](#materialized-view), [обновляемыми материализованными](#refreshable-materialized-view) и [окном](/sql-reference/statements/create/view#window-view) (обновляемые материализованные представления и оконные представления являются экспериментальными функциями).

## Обычное представление {#normal-view}

Синтаксис:

``` sql
CREATE [OR REPLACE] VIEW [IF NOT EXISTS] [db.]table_name [(alias1 [, alias2 ...])] [ON CLUSTER cluster_name]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | INVOKER | NONE }]
AS SELECT ...
[COMMENT 'комментарий']
```

Обычные представления не хранят данные. Они просто выполняют чтение из другой таблицы при каждом доступе. Иными словами, обычное представление не что иное, как сохраненный запрос. При чтении из представления этот сохраненный запрос используется в качестве подзапроса в [FROM](../../../sql-reference/statements/select/from.md) клаузе.

В качестве примера предположим, вы создали представление:

``` sql
CREATE VIEW view AS SELECT ...
```

и написали запрос:

``` sql
SELECT a, b, c FROM view
```

Этот запрос полностью эквивалентен использованию подзапроса:

``` sql
SELECT a, b, c FROM (SELECT ...)
```

## Параметризованное представление {#parameterized-view}

Параметризованные представления похожи на обычные представления, но могут быть созданы с параметрами, которые не разрешаются немедленно. Эти представления могут использоваться с табличными функциями, которые указывают имя представления как имя функции и значения параметров как ее аргументы.

``` sql
CREATE VIEW view AS SELECT * FROM TABLE WHERE Column1={column1:datatype1} and Column2={column2:datatype2} ...
```
Выше создается представление для таблицы, которое может использоваться как табличная функция, заменяя параметры, как показано ниже.

``` sql
SELECT * FROM view(column1=value1, column2=value2 ...)
```

## Материализованное представление {#materialized-view}

``` sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster_name] [TO[db.]name [(columns)]] [ENGINE = engine] [POPULATE]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | INVOKER | NONE }]
AS SELECT ...
[COMMENT 'комментарий']
```

:::tip
Вот пошаговое руководство по использованию [материализованных представлений](/guides/developer/cascading-materialized-views.md).
:::

Материализованные представления хранят данные, преобразованные соответствующим [SELECT](../../../sql-reference/statements/select/index.md) запросом.

При создании материализованного представления без `TO [db].[table]` вы должны указать `ENGINE` — механизм таблицы для хранения данных.

При создании материализованного представления с `TO [db].[table]` вы также не можете использовать `POPULATE`.

Материализованное представление реализуется следующим образом: при вставке данных в таблицу, указанную в `SELECT`, часть вставленных данных преобразуется этим запросом `SELECT`, и результат вставляется в представление.

:::note
Материализованные представления в ClickHouse используют **имена колонок** вместо порядка колонок при вставке в целевую таблицу. Если некоторые имена колонок отсутствуют в результате запроса `SELECT`, ClickHouse использует значение по умолчанию, даже если колонка не [Nullable](../../data-types/nullable.md). Безопасной практикой было бы добавлять псевдонимы для каждой колонки при использовании материализованных представлений.

Материализованные представления в ClickHouse реализуются больше как триггеры вставки. Если в запросе представления есть агрегация, она применяется только к партии свежевставленных данных. Любые изменения в существующих данных исходной таблицы (например, обновление, удаление, сброс партиции и т. д.) не изменяют материализованное представление.

Материализованные представления в ClickHouse не имеют детерминированного поведения в случае ошибок. Это означает, что блоки, которые были уже записаны, сохранятся в целевой таблице, но все блоки после ошибки не будут.

По умолчанию, если вставка в одно из представлений не удалась, запрос INSERT также потерпит неудачу, и некоторые блоки могут не быть записаны в целевую таблицу. Это можно изменить, установив параметр `materialized_views_ignore_errors` (вы должны установить его для запроса `INSERT`), если вы установите `materialized_views_ignore_errors=true`, тогда любые ошибки при вставке в представления будут игнорироваться, и все блоки будут записаны в целевую таблицу.

Также обратите внимание, что `materialized_views_ignore_errors` по умолчанию устанавливается в `true` для таблиц `system.*_log`.
:::

Если вы укажете `POPULATE`, существующие данные таблицы будут вставлены в представление при его создании, как если бы вы выполняли `CREATE TABLE ... AS SELECT ...`. В противном случае запрос будет содержать только данные, вставленные в таблицу после создания представления. Мы **не рекомендуем** использовать `POPULATE`, поскольку данные, вставленные в таблицу во время создания представления, не будут вставлены в него.

:::note
Учитывая, что `POPULATE` работает как `CREATE TABLE ... AS SELECT ...`, у него есть ограничения:
- Не поддерживается в реплицируемых базах данных
- Не поддерживается в ClickHouse cloud

Вместо этого можно использовать отдельный `INSERT ... SELECT`.
:::

Запрос `SELECT` может содержать `DISTINCT`, `GROUP BY`, `ORDER BY`, `LIMIT`. Обратите внимание, что соответствующие преобразования выполняются независимо на каждом блоке вставленных данных. Например, если установлен `GROUP BY`, данные агрегируются во время вставки, но только в пределах единого пакета вставленных данных. Данные не будут агрегированы далее. Исключение составляют случаи, когда используется `ENGINE`, который независимо выполняет агрегацию данных, такой как `SummingMergeTree`.

Выполнение запросов [ALTER](/sql-reference/statements/alter/view.md) на материализованных представлениях имеет ограничения, например, вы не можете обновить запрос `SELECT`, так что это может быть неудобно. Если материализованное представление использует конструкцию `TO [db.]name`, вы можете `DETACH` (отсоединить) представление, выполнить `ALTER` для целевой таблицы, а затем снова `ATTACH` (присоединить) ранее отсоединенное (`DETACH`) представление.

Обратите внимание, что на материализованное представление влияет настройка [optimize_on_insert](/operations/settings/settings#optimize_on_insert). Данные объединяются перед вставкой в представление.

Представления выглядят так же, как обычные таблицы. Например, они перечислены в результате запроса `SHOW TABLES`.

Чтобы удалить представление, используйте [DROP VIEW](../../../sql-reference/statements/drop.md#drop-view). Хотя `DROP TABLE` также работает для представлений.

## SQL безопасность {#sql_security}

`DEFINER` и `SQL SECURITY` позволяют указать, какого пользователя ClickHouse использовать при выполнении основного запроса представления.
`SQL SECURITY` имеет три допустимых значения: `DEFINER`, `INVOKER` или `NONE`. Вы можете указать любого существующего пользователя или `CURRENT_USER` в клаузе `DEFINER`.

В следующей таблице объясняется, какие права требуются для какого пользователя, чтобы выполнять запросы к представлению.
Обратите внимание, что независимо от параметра безопасности SQL в любом случае требуется иметь `GRANT SELECT ON <view>`, чтобы читать из него.

| Параметр безопасности SQL | Представление                                                          | Материализованное представление                                                                                                |
|---------------------------|-----------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| `DEFINER alice`           | `alice` должен иметь разрешение `SELECT` на источник таблицы представления. | `alice` должен иметь разрешение `SELECT` на источник таблицы представления и разрешение `INSERT` на целевую таблицу представления. |
| `INVOKER`                 | Пользователь должен иметь разрешение `SELECT` на источник таблицы представления.   | `SQL SECURITY INVOKER` нельзя указывать для материализованных представлений.                                                  |
| `NONE`                    | -                                                                     | -                                                                                                                             |

:::note
`SQL SECURITY NONE` - устаревший параметр. Любой пользователь, имеющий права на создание представлений с `SQL SECURITY NONE`, сможет выполнять любой произвольный запрос.
Таким образом, требуется иметь `GRANT ALLOW SQL SECURITY NONE TO <user>`, чтобы создать представление с этой опцией.
:::

Если `DEFINER`/`SQL SECURITY` не указаны, используются значения по умолчанию:
- `SQL SECURITY`: `INVOKER` для обычных представлений и `DEFINER` для материализованных представлений ([настраивается через параметры](../../../operations/settings/settings.md#default_normal_view_sql_security))
- `DEFINER`: `CURRENT_USER` ([настраивается через параметры](../../../operations/settings/settings.md#default_view_definer))

Если представление присоединяется без указания `DEFINER`/`SQL SECURITY`, значение по умолчанию - `SQL SECURITY NONE` для материализованного представления и `SQL SECURITY INVOKER` для обычного представления.

Чтобы изменить безопасность SQL для существующего представления, используйте
```sql
ALTER TABLE MODIFY SQL SECURITY { DEFINER | INVOKER | NONE } [DEFINER = { user | CURRENT_USER }]
```

### Примеры {#examples}
```sql
CREATE VIEW test_view
DEFINER = alice SQL SECURITY DEFINER
AS SELECT ...
```

```sql
CREATE VIEW test_view
SQL SECURITY INVOKER
AS SELECT ...
```

## Живое представление {#live-view}

<DeprecatedBadge/>

Эта функция устарела и будет удалена в будущем.

Для вашего удобства старая документация находится [здесь](https://pastila.nl/?00f32652/fdf07272a7b54bda7e13b919264e449f.md)

## Обновляемое материализованное представление {#refreshable-materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
REFRESH EVERY|AFTER interval [OFFSET interval]
[RANDOMIZE FOR interval]
[DEPENDS ON [db.]name [, [db.]name [, ...]]]
[SETTINGS name = value [, name = value [, ...]]]
[APPEND]
[TO[db.]name] [(columns)] [ENGINE = engine] 
[EMPTY]
AS SELECT ...
[COMMENT 'комментарий']
```
где `interval` является последовательностью простых интервалов:
```sql
number SECOND|MINUTE|HOUR|DAY|WEEK|MONTH|YEAR
```

Периодически выполняет соответствующий запрос и хранит его результат в таблице.
 * Если запрос говорит `APPEND`, каждое обновление вставляет строки в таблицу, не удаляя существующие строки. Вставка не является атомарной, как обычный INSERT SELECT.
 * В противном случае каждое обновление атомарно заменяет ранее содержимое таблицы.

Отличия от обычных не обновляемых материализованных представлений:
 * Нет триггера вставки. То есть, когда новые данные вставляются в таблицу, указанную в SELECT, они *не* автоматически передаются в обновляемое материализованное представление. Периодическое обновление запускает весь запрос.
 * Нет ограничений на запрос SELECT. Табличные функции (например, `url()`), представления, UNION, JOIN приветствуются.

:::note
Параметры в части запроса `REFRESH ... SETTINGS` являются настройками обновления (например, `refresh_retries`), отличными от обычных настроек (например, `max_threads`). Обычные настройки могут быть указаны с использованием `SETTINGS` в конце запроса.
:::

### График обновлений {#refresh-schedule}

Примеры графиков обновлений:
```sql
REFRESH EVERY 1 DAY -- каждый день, в полночь (UTC)
REFRESH EVERY 1 MONTH -- в первый день каждого месяца, в полночь
REFRESH EVERY 1 MONTH OFFSET 5 DAY 2 HOUR -- в шестой день каждого месяца, в 2:00 утра
REFRESH EVERY 2 WEEK OFFSET 5 DAY 15 HOUR 10 MINUTE -- каждую вторую субботу, в 15:10
REFRESH EVERY 30 MINUTE -- в 00:00, 00:30, 01:00, 01:30 и т.д.
REFRESH AFTER 30 MINUTE -- спустя 30 минут после завершения предыдущего обновления, не синхронизировано со временем суток
-- REFRESH AFTER 1 HOUR OFFSET 1 MINUTE -- синтаксическая ошибка, OFFSET не допускается с AFTER
REFRESH EVERY 1 WEEK 2 DAYS -- каждые 9 дней, не в какой-либо конкретный день недели или месяца;
                            -- а именно, когда номер дня (с 1969-12-29) делится на 9
REFRESH EVERY 5 MONTHS -- каждые 5 месяцев, разные месяцы каждый год (поскольку 12 не делится на 5);
                       -- а именно, когда номер месяца (с 1970-01) делится на 5
```

`RANDOMIZE FOR` случайным образом корректирует время каждого обновления, например:
```sql
REFRESH EVERY 1 DAY OFFSET 2 HOUR RANDOMIZE FOR 1 HOUR -- каждый день в случайное время между 01:30 и 02:30
```

Не более одного обновления может выполняться одновременно для данного представления. Например, если представление с `REFRESH EVERY 1 MINUTE` занимает 2 минуты на обновление, оно будет обновляться каждые 2 минуты. Если оно становится быстрее и начинает обновляться за 10 секунд, оно вернется к обновлению каждую минуту. (В частности, оно не будет обновляться каждые 10 секунд, чтобы догнать пропущенные обновления - такого запаса нет.)

Кроме того, обновление начинается немедленно после создания материализованного представления, если в запросе `CREATE` не указано `EMPTY`. Если указано `EMPTY`, первое обновление происходит согласно графику.

### В реплицированной БД {#in-replicated-db}

Если обновляемое материализованное представление находится в [реплицированной базе данных](../../../engines/database-engines/replicated.md), реплики координируют друг с другом так, что только одна реплика выполняет обновление в каждое запланированное время. Требуется механизм таблицы [ReplicatedMergeTree](../../../engines/table-engines/mergetree-family/replication.md), чтобы все реплики видели данные, произведенные в результате обновления.

В режиме `APPEND` координацию можно отключить с помощью настройки `SETTINGS all_replicas = 1`. Это заставляет реплики выполнять обновления независимо друг от друга. В этом случае `ReplicatedMergeTree` не требуется.

В режиме не `APPEND` поддерживается только согласованное обновление. Для несогласованного используйте атомарную базу данных и запрос `CREATE ... ON CLUSTER`, чтобы создать обновляемые материализованные представления на всех репликах.

Координация осуществляется через Keeper. Путь znode определяется настройкой сервера [default_replica_path](../../../operations/server-configuration-parameters/settings.md#default_replica_path).

### Зависимости {#refresh-dependencies}

`DEPENDS ON` синхронизирует обновления различных таблиц. В качестве примера предположим, что есть цепь из двух обновляемых материализованных представлений:
```sql
CREATE MATERIALIZED VIEW source REFRESH EVERY 1 DAY AS SELECT * FROM url(...)
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY AS SELECT ... FROM source
```
Без `DEPENDS ON` оба представления начнут обновление в полночь, и `destination` обычно увидит данные за вчерашний день в `source`. Если мы добавим зависимость:
```sql
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY DEPENDS ON source AS SELECT ... FROM source
```
то обновление `destination` начнется только после завершения обновления `source` в тот день, таким образом, `destination` будет основан на свежих данных.

Альтернативно, тот же результат можно добиться следующим образом:
```sql
CREATE MATERIALIZED VIEW destination REFRESH AFTER 1 HOUR DEPENDS ON source AS SELECT ... FROM source
```
где `1 HOUR` может быть любой период времени меньше, чем период обновления `source`. Зависимая таблица не будет обновляться чаще, чем любая из своих зависимостей. Это действительный способ настроить цепочку обновляемых представлений, не указывая реальный период обновления больше одного раза.

Еще несколько примеров:
 * `REFRESH EVERY 1 DAY OFFSET 10 MINUTE` (`destination`) зависит от `REFRESH EVERY 1 DAY` (`source`)<br/>
   Если обновление `source` занимает более 10 минут, `destination` будет ждать.
 * `REFRESH EVERY 1 DAY OFFSET 1 HOUR` зависит от `REFRESH EVERY 1 DAY OFFSET 23 HOUR`<br/>
   Похожий на предыдущий пример, даже если соответствующие обновления происходят в разные календарные дни.
   Обновление `destination` в день X+1 будет ждать обновления `source` в день X (если оно занимает более 2 часов).
 * `REFRESH EVERY 2 HOUR` зависит от `REFRESH EVERY 1 HOUR`<br/>
   Обновление каждые 2 часа происходит после обновления каждый час, например, после обновления в полночь
   и затем после обновления в 2 часа утра и т.д.
 * `REFRESH EVERY 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH AFTER 2 HOUR`<br/>
   `destination` обновляется один раз после каждого обновления `source`, т.е. каждые 2 часа. `1 MINUTE` фактически игнорируется.
 * `REFRESH AFTER 1 HOUR` зависит от `REFRESH AFTER 1 HOUR`<br/>
   В данный момент это не рекомендуется.

:::note
`DEPENDS ON` работает только между обновляемыми материализованными представлениями. Указание обычной таблицы в списке `DEPENDS ON` предотвратит обновление представления (зависимости можно удалить с помощью `ALTER`, см. ниже).
:::

### Настройки {#settings}

Доступные настройки обновления:
 * `refresh_retries` - Сколько раз повторно пытаться, если запрос обновления завершился с ошибкой. Если все повторные попытки не удаются, переходите к следующему запланированному времени обновления. 0 означает отсутствие повторных попыток, -1 означает бесконечные попытки. Значение по умолчанию: 0.
 * `refresh_retry_initial_backoff_ms` - Задержка перед первой повторной попыткой, если `refresh_retries` не равен нулю. Каждая последующая попытка удваивает задержку, до `refresh_retry_max_backoff_ms`. Значение по умолчанию: 100 мс.
 * `refresh_retry_max_backoff_ms` - Ограничение на экспоненциальный рост задержки между попытками обновления. Значение по умолчанию: 60000 мс (1 минута).

### Изменение параметров обновления {#changing-refresh-parameters}

Чтобы изменить параметры обновления:
```sql
ALTER TABLE [db.]name MODIFY REFRESH EVERY|AFTER ... [RANDOMIZE FOR ...] [DEPENDS ON ...] [SETTINGS ...]
```

:::note
Это заменяет *все* параметры обновления сразу: график, зависимости, настройки и режим APPEND. Например, если таблица имела `DEPENDS ON`, выполнение `MODIFY REFRESH` без `DEPENDS ON` удалит зависимости.
:::

### Другие операции {#other-operations}

Статус всех обновляемых материализованных представлений доступен в таблице [`system.view_refreshes`](../../../operations/system-tables/view_refreshes.md). В частности, она содержит прогресс обновления (если выполняется), время последнего и следующего обновления, сообщение об ошибке, если обновление не удалось.

Чтобы вручную остановить, запустить, инициировать или отменить обновления, используйте [`SYSTEM STOP|START|REFRESH|WAIT|CANCEL VIEW`](../system.md#refreshable-materialized-views).

Чтобы дождаться завершения обновления, используйте [`SYSTEM WAIT VIEW`](../system.md#refreshable-materialized-views). В частности, полезно для ожидания первого обновления после создания представления.

:::note
Забавный факт: запрос обновления может читать из представления, которое обновляется, видя версию данных до обновления. Это означает, что вы можете реализовать игру жизни Конвея: https://pastila.nl/?00021a4b/d6156ff819c83d490ad2dcec05676865#O0LGWTO7maUQIA4AcGUtlA==
:::

## Оконное представление {#window-view}

<ExperimentalBadge/>
<CloudNotSupportedBadge/>

:::info
Это экспериментальная функция, которая может измениться в несовместимые с предыдущими версиями изменения в будущих релизах. Включите использование оконных представлений и запрос `WATCH`, используя настройку [allow_experimental_window_view](/operations/settings/settings#allow_experimental_window_view). Введите команду `set allow_experimental_window_view = 1`.
:::

``` sql
CREATE WINDOW VIEW [IF NOT EXISTS] [db.]table_name [TO [db.]table_name] [INNER ENGINE engine] [ENGINE engine] [WATERMARK strategy] [ALLOWED_LATENESS interval_function] [POPULATE]
AS SELECT ...
GROUP BY time_window_function
[COMMENT 'комментарий']
```

Оконное представление может агрегировать данные по временным окнам и выводить результаты, когда окно готово к срабатыванию. Оно хранит промежуточные результаты агрегирования во внутренней (или указанной) таблице, чтобы снизить задержку, и может отправить результат обработки в указанную таблицу или отправить уведомления, используя запрос `WATCH`.

Создание оконного представления похоже на создание `MATERIALIZED VIEW`. Оконное представление требует внутреннего механизма хранения для хранения промежуточных данных. Внутреннее хранилище может быть указано с помощью клаузи `INNER ENGINE`, оконное представление будет использовать `AggregatingMergeTree` в качестве внутреннего механизма по умолчанию.

При создании оконного представления без `TO [db].[table]` вы должны указать `ENGINE` — механизм таблицы для хранения данных.

### Функции временного окна {#time-window-functions}

[Функции временного окна](../../functions/time-window-functions.md) используются для получения нижней и верхней границы окна записей. Оконное представление должно использоваться с функцией временного окна.

### ВРЕМЕННЫЕ АТРИБУТЫ {#time-attributes}

Оконное представление поддерживает **время обработки** и **время события**.

**Время обработки** позволяет оконному представлению производить результаты на основе времени локальной машины и используется по умолчанию. Это наиболее прямое понятие времени, но не предоставляет детерминизма. Атрибут времени обработки можно определить, установив `time_attr` функции временного окна в колонку таблицы или используя функцию `now()`. Следующий запрос создает оконное представление с временем обработки.

``` sql
CREATE WINDOW VIEW wv AS SELECT count(number), tumbleStart(w_id) as w_start from date GROUP BY tumble(now(), INTERVAL '5' SECOND) as w_id
```

**Время события** — это время, когда каждое отдельное событие произошло на своем устройстве-производителе. Это время обычно встраивается в записи, когда оно генерируется. Обработка времени события позволяет получать согласованные результаты, даже в случае несвоевременных событий или поздних событий. Оконное представление поддерживает обработку времени события, используя синтаксис `WATERMARK`.

Оконное представление предоставляет три стратегии вставки:

* `STRICTLY_ASCENDING`: Выводит метку времени максимального наблюдаемого временного штампа до сих пор. Строки, у которых временной штамп меньше максимального временного штампа, не считаются поздними.
* `ASCENDING`: Выводит метку времени максимального наблюдаемого временного штампа до сих пор минус 1. Строки, у которых временной штамп равен или меньше максимального временного штампа, не считаются поздними.
* `BOUNDED`: WATERMARK=INTERVAL. Выводит метки времени, которые представляют собой максимальный наблюдаемый временной штамп минус указанная задержка.

Следующие запросы являются примерами создания оконного представления с `WATERMARK`:

``` sql
CREATE WINDOW VIEW wv WATERMARK=STRICTLY_ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=INTERVAL '3' SECOND AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
```

По умолчанию окно будет срабатывать, когда приходит метка времени, и элементы, которые пришли после метки времени, будут отброшены. Оконное представление поддерживает обработку поздних событий, установив `ALLOWED_LATENESS=INTERVAL`. Пример обработки задержки:

``` sql
CREATE WINDOW VIEW test.wv TO test.dst WATERMARK=ASCENDING ALLOWED_LATENESS=INTERVAL '2' SECOND AS SELECT count(a) AS count, tumbleEnd(wid) AS w_end FROM test.mt GROUP BY tumble(timestamp, INTERVAL '5' SECOND) AS wid;
```

Обратите внимание, что элементы, выделенные поздним срабатыванием, должны рассматриваться как обновленные результаты предыдущих вычислений. Вместо того чтобы срабатывать в конце окон, оконное представление сработает немедленно, когда прибывает позднее событие. Таким образом, это приведет к нескольким выходам для одного и того же окна. Пользователи должны учитывать эти дублированные результаты или удалять дубликаты.

Вы можете изменить запрос `SELECT`, указанный в оконном представлении, используя оператор `ALTER TABLE ... MODIFY QUERY`. Структура данных, получающаяся в результате нового запроса `SELECT`, должна совпадать с оригинальным запросом `SELECT`, как с, так и без клаузи `TO [db.]name`. Обратите внимание, что данные в текущем окне будут потеряны, поскольку промежуточное состояние не может быть повторно использовано.

### Мониторинг новых окон {#monitoring-new-windows}

Оконное представление поддерживает запрос [WATCH](../../../sql-reference/statements/watch.md), чтобы отслеживать изменения или использовать синтаксис `TO`, чтобы выводить результаты в таблицу.

``` sql
WATCH [db.]window_view
[EVENTS]
[LIMIT n]
[FORMAT format]
```

Запрос `WATCH` работает аналогично в `LIVE VIEW`. Можно указать `LIMIT`, чтобы установить количество обновлений для получения перед завершением запроса. Клаузу `EVENTS` можно использовать для получения сокращенной версии запроса `WATCH`, где вместо результата запроса вы получите только последнюю метку времени запроса.

### Настройки {#settings-1}

- `window_view_clean_interval`: Интервал очистки оконного представления в секундах для освобождения устаревших данных. Система будет сохранять окна, которые не были полностью сработаны в соответствии со временем системы или конфигурацией `WATERMARK`, а другие данные будут удалены.
- `window_view_heartbeat_interval`: Интервал "сердцебиения" в секундах, чтобы указать, что запрос на просмотр активен.
- `wait_for_window_view_fire_signal_timeout`: Таймаут для ожидания сигнала срабатывания оконного представления в обработке событий времени.

### Пример {#example}

Предположим, нам нужно подсчитать количество записей кликов каждые 10 секунд в таблице журналов под названием `data`, и структура ее таблицы:

``` sql
CREATE TABLE data ( `id` UInt64, `timestamp` DateTime) ENGINE = Memory;
```

Сначала создаем оконное представление с тумблирующим окном интервала 10 секунд:

``` sql
CREATE WINDOW VIEW wv as select count(id), tumbleStart(w_id) as window_start from data group by tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Затем используем запрос `WATCH`, чтобы получить результаты.

``` sql
WATCH wv
```

Когда записи вставляются в таблицу `data`,

``` sql
INSERT INTO data VALUES(1,now())
```

Запрос `WATCH` должен вывести результаты следующим образом:

``` text
┌─count(id)─┬────────window_start─┐
│         1 │ 2020-01-14 16:56:40 │
└───────────┴─────────────────────┘
```

Альтернативно, мы можем прикрепить вывод к другой таблице, используя синтаксис `TO`.

``` sql
CREATE WINDOW VIEW wv TO dst AS SELECT count(id), tumbleStart(w_id) as window_start FROM data GROUP BY tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Дополнительные примеры можно найти среди тестов по состоянию ClickHouse (они называются `*window_view*` там).

### Использование оконного представления {#window-view-usage}

Оконное представление полезно в следующих сценариях:

* **Мониторинг**: Агрегировать и рассчитывать метрики журналов по времени и выводить результаты в целевую таблицу. Приборная панель может использовать целевую таблицу в качестве исходной таблицы.
* **Анализ**: Автоматически агрегировать и предварительно обрабатывать данные в временном окне. Это может быть полезно при анализе большого количества журналов. Предварительная обработка избавляет от повторных вычислений в нескольких запросах и снижает задержку запроса.

## Связанный контент {#related-content}

- Блог: [Работа с временными рядами данных в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)
- Блог: [Создание решения по наблюдаемости с ClickHouse - Часть 2 - Трейсы](https://clickhouse.com/blog/storing-traces-and-spans-open-telemetry-in-clickhouse)

---
description: 'Документация по оператору CREATE VIEW'
sidebar_label: 'VIEW'
sidebar_position: 37
slug: /sql-reference/statements/create/view
title: 'CREATE VIEW'
doc_type: 'reference'
---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import DeprecatedBadge from '@theme/badges/DeprecatedBadge';
import CloudNotSupportedBadge from '@theme/badges/CloudNotSupportedBadge';


# CREATE VIEW

Создаёт новое представление. Представления могут быть [обычными](#normal-view), [материализованными](#materialized-view), [обновляемыми материализованными](#refreshable-materialized-view) и [оконными](/sql-reference/statements/create/view#window-view).



## Обычное представление {#normal-view}

Синтаксис:

```sql
CREATE [OR REPLACE] VIEW [IF NOT EXISTS] [db.]table_name [(alias1 [, alias2 ...])] [ON CLUSTER cluster_name]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | INVOKER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

Обычные представления не хранят данные. Они выполняют чтение из другой таблицы при каждом обращении. Другими словами, обычное представление — это сохранённый запрос. При чтении из представления этот сохранённый запрос используется как подзапрос в секции [FROM](../../../sql-reference/statements/select/from.md).

Например, предположим, что вы создали представление:

```sql
CREATE VIEW view AS SELECT ...
```

и написали запрос:

```sql
SELECT a, b, c FROM view
```

Этот запрос полностью эквивалентен использованию подзапроса:

```sql
SELECT a, b, c FROM (SELECT ...)
```


## Параметризованное представление {#parameterized-view}

Параметризованные представления похожи на обычные представления, но могут создаваться с параметрами, которые не вычисляются сразу. Такие представления можно использовать как табличные функции, указывая имя представления в качестве имени функции, а значения параметров — в качестве аргументов.

```sql
CREATE VIEW view AS SELECT * FROM TABLE WHERE Column1={column1:datatype1} and Column2={column2:datatype2} ...
```

Приведённый выше запрос создаёт представление для таблицы, которое можно использовать как табличную функцию, подставляя значения параметров, как показано ниже.

```sql
SELECT * FROM view(column1=value1, column2=value2 ...)
```


## Материализованное представление {#materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster_name] [TO[db.]name [(columns)]] [ENGINE = engine] [POPULATE]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

:::tip
Пошаговое руководство по использованию [материализованных представлений](/guides/developer/cascading-materialized-views.md).
:::

Материализованные представления хранят данные, преобразованные соответствующим запросом [SELECT](../../../sql-reference/statements/select/index.md).

При создании материализованного представления без `TO [db].[table]` необходимо указать `ENGINE` — движок таблицы для хранения данных.

При создании материализованного представления с `TO [db].[table]` нельзя использовать `POPULATE`.

Материализованное представление работает следующим образом: при вставке данных в таблицу, указанную в `SELECT`, часть вставляемых данных преобразуется этим запросом `SELECT`, и результат вставляется в представление.

:::note
Материализованные представления в ClickHouse используют **имена столбцов**, а не порядок столбцов при вставке в целевую таблицу. Если некоторые имена столбцов отсутствуют в результате запроса `SELECT`, ClickHouse использует значение по умолчанию, даже если столбец не является [Nullable](../../data-types/nullable.md). Рекомендуется добавлять псевдонимы для каждого столбца при использовании материализованных представлений.

Материализованные представления в ClickHouse реализованы скорее как триггеры вставки. Если в запросе представления есть агрегация, она применяется только к пакету свежевставленных данных. Любые изменения существующих данных исходной таблицы (такие как обновление, удаление, удаление партиции и т. д.) не изменяют материализованное представление.

Материализованные представления в ClickHouse не имеют детерминированного поведения в случае ошибок. Это означает, что блоки, которые уже были записаны, сохранятся в целевой таблице, но все блоки после ошибки записаны не будут.

По умолчанию, если запись в одно из представлений завершается неудачей, то запрос INSERT также завершится неудачей, и некоторые блоки могут не быть записаны в целевую таблицу. Это можно изменить с помощью настройки `materialized_views_ignore_errors` (её следует установить для запроса `INSERT`). Если установить `materialized_views_ignore_errors=true`, то любые ошибки при записи в представления будут игнорироваться, и все блоки будут записаны в целевую таблицу.

Также обратите внимание, что `materialized_views_ignore_errors` по умолчанию установлен в `true` для таблиц `system.*_log`.
:::

Если указан `POPULATE`, существующие данные таблицы вставляются в представление при его создании, как при выполнении `CREATE TABLE ... AS SELECT ...`. В противном случае запрос содержит только данные, вставленные в таблицу после создания представления. Мы **не рекомендуем** использовать `POPULATE`, поскольку данные, вставленные в таблицу во время создания представления, не будут вставлены в него.

:::note
Учитывая, что `POPULATE` работает как `CREATE TABLE ... AS SELECT ...`, он имеет ограничения:

- Не поддерживается с реплицируемой базой данных
- Не поддерживается в ClickHouse Cloud

Вместо этого можно использовать отдельный `INSERT ... SELECT`.
:::

Запрос `SELECT` может содержать `DISTINCT`, `GROUP BY`, `ORDER BY`, `LIMIT`. Обратите внимание, что соответствующие преобразования выполняются независимо для каждого блока вставляемых данных. Например, если указан `GROUP BY`, данные агрегируются во время вставки, но только в пределах одного пакета вставляемых данных. Дальнейшая агрегация данных не производится. Исключением является использование `ENGINE`, который самостоятельно выполняет агрегацию данных, например `SummingMergeTree`.

Выполнение запросов [ALTER](/sql-reference/statements/alter/view.md) для материализованных представлений имеет ограничения, например, нельзя обновить запрос `SELECT`, что может быть неудобно. Если материализованное представление использует конструкцию `TO [db.]name`, можно выполнить `DETACH` представления, запустить `ALTER` для целевой таблицы, а затем выполнить `ATTACH` ранее отсоединённого (`DETACH`) представления.

Обратите внимание, что на материализованное представление влияет настройка [optimize_on_insert](/operations/settings/settings#optimize_on_insert). Данные объединяются перед вставкой в представление.

Представления выглядят так же, как обычные таблицы. Например, они перечислены в результате запроса `SHOW TABLES`.

Для удаления представления используйте [DROP VIEW](../../../sql-reference/statements/drop.md#drop-view). Хотя `DROP TABLE` также работает для представлений (VIEW).


## Безопасность SQL {#sql_security}

`DEFINER` и `SQL SECURITY` позволяют указать, от имени какого пользователя ClickHouse будет выполняться базовый запрос представления.
`SQL SECURITY` может принимать три допустимых значения: `DEFINER`, `INVOKER` или `NONE`. В предложении `DEFINER` можно указать любого существующего пользователя или `CURRENT_USER`.

В следующей таблице показано, какие права требуются для какого пользователя, чтобы выполнить выборку из представления.
Обратите внимание, что независимо от параметра безопасности SQL, в любом случае для чтения из представления необходимо иметь `GRANT SELECT ON <view>`.

| Параметр SQL security | Представление                                                            | Материализованное представление                                                                                                 |
| ------------------- | --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `DEFINER alice`     | У `alice` должно быть право `SELECT` на исходную таблицу представления. | У `alice` должно быть право `SELECT` на исходную таблицу представления и право `INSERT` на целевую таблицу представления. |
| `INVOKER`           | У пользователя должно быть право `SELECT` на исходную таблицу представления.    | `SQL SECURITY INVOKER` нельзя указать для материализованных представлений.                                                 |
| `NONE`              | -                                                               | -                                                                                                                 |

:::note
`SQL SECURITY NONE` — устаревший параметр. Любой пользователь с правами на создание представлений с `SQL SECURITY NONE` сможет выполнить любой произвольный запрос.
Поэтому для создания представления с этим параметром необходимо иметь `GRANT ALLOW SQL SECURITY NONE TO <user>`.
:::

Если `DEFINER`/`SQL SECURITY` не указаны, используются значения по умолчанию:

- `SQL SECURITY`: `INVOKER` для обычных представлений и `DEFINER` для материализованных представлений ([настраивается через параметры](../../../operations/settings/settings.md#default_normal_view_sql_security))
- `DEFINER`: `CURRENT_USER` ([настраивается через параметры](../../../operations/settings/settings.md#default_view_definer))

Если представление подключается без указания `DEFINER`/`SQL SECURITY`, значением по умолчанию является `SQL SECURITY NONE` для материализованного представления и `SQL SECURITY INVOKER` для обычного представления.

Чтобы изменить параметры безопасности SQL для существующего представления, используйте

```sql
ALTER TABLE MODIFY SQL SECURITY { DEFINER | INVOKER | NONE } [DEFINER = { user | CURRENT_USER }]
```

### Примеры {#examples}

```sql
CREATE VIEW test_view
DEFINER = alice SQL SECURITY DEFINER
AS SELECT ...
```

```sql
CREATE VIEW test_view
SQL SECURITY INVOKER
AS SELECT ...
```


## Live View {#live-view}

<DeprecatedBadge />

Эта функция устарела и будет удалена в будущем.

Для удобства старая документация доступна [здесь](https://pastila.nl/?00f32652/fdf07272a7b54bda7e13b919264e449f.md)


## Обновляемое материализованное представление {#refreshable-materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
REFRESH EVERY|AFTER interval [OFFSET interval]
[RANDOMIZE FOR interval]
[DEPENDS ON [db.]name [, [db.]name [, ...]]]
[SETTINGS name = value [, name = value [, ...]]]
[APPEND]
[TO[db.]name] [(columns)] [ENGINE = engine]
[EMPTY]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

где `interval` — это последовательность простых интервалов:

```sql
number SECOND|MINUTE|HOUR|DAY|WEEK|MONTH|YEAR
```

Периодически выполняет соответствующий запрос и сохраняет его результат в таблицу.

- Если в запросе указано `APPEND`, каждое обновление добавляет строки в таблицу без удаления существующих строк. Вставка не является атомарной, как и обычный INSERT SELECT.
- В противном случае каждое обновление атомарно заменяет предыдущее содержимое таблицы.
  Отличия от обычных необновляемых материализованных представлений:
- Отсутствует триггер вставки. То есть при вставке новых данных в таблицу, указанную в SELECT, они _не_ автоматически попадают в обновляемое материализованное представление. Периодическое обновление выполняет весь запрос целиком. \* Отсутствуют ограничения на запрос SELECT. Табличные функции (например, `url()`), представления, UNION, JOIN — всё это разрешено.

:::note
Настройки в части запроса `REFRESH ... SETTINGS` являются настройками обновления (например, `refresh_retries`) и отличаются от обычных настроек (например, `max_threads`). Обычные настройки можно указать с помощью `SETTINGS` в конце запроса.
:::

### Расписание обновления {#refresh-schedule}

Примеры расписаний обновления:

```sql
REFRESH EVERY 1 DAY -- каждый день в полночь (UTC)
REFRESH EVERY 1 MONTH -- 1-го числа каждого месяца в полночь
REFRESH EVERY 1 MONTH OFFSET 5 DAY 2 HOUR -- 6-го числа каждого месяца в 2:00
REFRESH EVERY 2 WEEK OFFSET 5 DAY 15 HOUR 10 MINUTE -- каждую вторую субботу в 15:10
REFRESH EVERY 30 MINUTE -- в 00:00, 00:30, 01:00, 01:30 и т. д.
REFRESH AFTER 30 MINUTE -- через 30 минут после завершения предыдущего обновления, без привязки ко времени суток
-- REFRESH AFTER 1 HOUR OFFSET 1 MINUTE -- синтаксическая ошибка, OFFSET не допускается с AFTER
REFRESH EVERY 1 WEEK 2 DAYS -- каждые 9 дней, не в какой-то конкретный день недели или месяца;
                            -- а именно, когда номер дня (с 1969-12-29) делится на 9
REFRESH EVERY 5 MONTHS -- каждые 5 месяцев, разные месяцы каждый год (так как 12 не делится на 5);
                       -- а именно, когда номер месяца (с 1970-01) делится на 5
```

`RANDOMIZE FOR` случайным образом корректирует время каждого обновления, например:

```sql
REFRESH EVERY 1 DAY OFFSET 2 HOUR RANDOMIZE FOR 1 HOUR -- каждый день в случайное время между 01:30 и 02:30
```

Для данного представления одновременно может выполняться не более одного обновления. Например, если представление с `REFRESH EVERY 1 MINUTE` обновляется 2 минуты, оно будет обновляться каждые 2 минуты. Если затем оно станет быстрее и начнёт обновляться за 10 секунд, оно вернётся к обновлению каждую минуту. (В частности, оно не будет обновляться каждые 10 секунд, чтобы наверстать пропущенные обновления — такого отставания не существует.)

Кроме того, обновление запускается сразу после создания материализованного представления, если в запросе `CREATE` не указано `EMPTY`. Если указано `EMPTY`, первое обновление происходит согласно расписанию.

### В реплицируемой БД {#in-replicated-db}

Если обновляемое материализованное представление находится в [реплицируемой базе данных](../../../engines/database-engines/replicated.md), реплики координируются друг с другом таким образом, что только одна реплика выполняет обновление в каждое запланированное время. Требуется движок таблиц [ReplicatedMergeTree](../../../engines/table-engines/mergetree-family/replication.md), чтобы все реплики видели данные, созданные при обновлении.

В режиме `APPEND` координацию можно отключить с помощью `SETTINGS all_replicas = 1`. Это позволяет репликам выполнять обновления независимо друг от друга. В этом случае ReplicatedMergeTree не требуется.


В режиме, отличном от `APPEND`, поддерживается только координированное обновление. Для некоординированного обновления используйте базу данных `Atomic` и запрос `CREATE ... ON CLUSTER` для создания обновляемых материализованных представлений на всех репликах.

Координация осуществляется через Keeper. Путь znode определяется серверной настройкой [default_replica_path](../../../operations/server-configuration-parameters/settings.md#default_replica_path).

### Зависимости {#refresh-dependencies}

`DEPENDS ON` синхронизирует обновления различных таблиц. Рассмотрим пример с цепочкой из двух обновляемых материализованных представлений:

```sql
CREATE MATERIALIZED VIEW source REFRESH EVERY 1 DAY AS SELECT * FROM url(...)
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY AS SELECT ... FROM source
```

Без `DEPENDS ON` оба представления начнут обновление в полночь, и `destination` обычно будет видеть вчерашние данные в `source`. Если добавить зависимость:

```sql
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY DEPENDS ON source AS SELECT ... FROM source
```

то обновление `destination` начнется только после завершения обновления `source` за этот день, и `destination` будет основано на свежих данных.

Альтернативно, того же результата можно достичь с помощью:

```sql
CREATE MATERIALIZED VIEW destination REFRESH AFTER 1 HOUR DEPENDS ON source AS SELECT ... FROM source
```

где `1 HOUR` может быть любой длительностью меньше периода обновления `source`. Зависимая таблица не будет обновляться чаще, чем любая из её зависимостей. Это корректный способ настройки цепочки обновляемых представлений без необходимости указывать реальный период обновления более одного раза.

Несколько дополнительных примеров:

- `REFRESH EVERY 1 DAY OFFSET 10 MINUTE` (`destination`) зависит от `REFRESH EVERY 1 DAY` (`source`)<br/>
  Если обновление `source` занимает более 10 минут, `destination` будет ожидать его завершения.
- `REFRESH EVERY 1 DAY OFFSET 1 HOUR` зависит от `REFRESH EVERY 1 DAY OFFSET 23 HOUR`<br/>
  Аналогично предыдущему, хотя соответствующие обновления происходят в разные календарные дни.
  Обновление `destination` в день X+1 будет ожидать обновления `source` в день X (если оно занимает более 2 часов).
- `REFRESH EVERY 2 HOUR` зависит от `REFRESH EVERY 1 HOUR`<br/>
  Обновление каждые 2 часа происходит после обновления каждый час через один час, например, после полуночного
  обновления, затем после обновления в 2 часа ночи и т. д.
- `REFRESH EVERY 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
  `REFRESH AFTER 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
  `REFRESH AFTER 1 MINUTE` зависит от `REFRESH AFTER 2 HOUR`<br/>
  `destination` обновляется один раз после каждого обновления `source`, т. е. каждые 2 часа. Значение `1 MINUTE` фактически игнорируется.
- `REFRESH AFTER 1 HOUR` зависит от `REFRESH AFTER 1 HOUR`<br/>
  В настоящее время это не рекомендуется.

:::note
`DEPENDS ON` работает только между обновляемыми материализованными представлениями. Указание обычной таблицы в списке `DEPENDS ON` предотвратит обновление представления (зависимости можно удалить с помощью `ALTER`, см. ниже).
:::

### Настройки {#settings}

Доступные настройки обновления:

- `refresh_retries` — количество повторных попыток при сбое запроса обновления с исключением. Если все повторные попытки не удаются, происходит переход к следующему запланированному времени обновления. 0 означает отсутствие повторных попыток, -1 означает бесконечные повторные попытки. По умолчанию: 0.
- `refresh_retry_initial_backoff_ms` — задержка перед первой повторной попыткой, если `refresh_retries` не равно нулю. Каждая последующая повторная попытка удваивает задержку до значения `refresh_retry_max_backoff_ms`. По умолчанию: 100 мс.
- `refresh_retry_max_backoff_ms` — ограничение экспоненциального роста задержки между попытками обновления. По умолчанию: 60000 мс (1 минута).

### Изменение параметров обновления {#changing-refresh-parameters}

Для изменения параметров обновления:

```sql
ALTER TABLE [db.]name MODIFY REFRESH EVERY|AFTER ... [RANDOMIZE FOR ...] [DEPENDS ON ...] [SETTINGS ...]
```

:::note
Эта команда заменяет _все_ параметры обновления одновременно: расписание, зависимости, настройки и режим APPEND. Например, если таблица имела `DEPENDS ON`, выполнение `MODIFY REFRESH` без `DEPENDS ON` удалит зависимости.
:::

### Другие операции {#other-operations}


Состояние всех обновляемых материализованных представлений доступно в таблице [`system.view_refreshes`](../../../operations/system-tables/view_refreshes.md). В частности, она содержит прогресс обновления (если оно выполняется), время последнего и следующего обновления, а также сообщение об исключении, если обновление завершилось с ошибкой.

Чтобы вручную остановить, запустить, принудительно инициировать или отменить обновления, используйте команду [`SYSTEM STOP|START|REFRESH|WAIT|CANCEL VIEW`](../system.md#refreshable-materialized-views).

Чтобы дождаться завершения обновления, используйте команду [`SYSTEM WAIT VIEW`](../system.md#refreshable-materialized-views). В частности, это полезно для ожидания первоначального обновления после создания представления.

:::note
Интересный факт: запрос обновления может читать данные из представления, которое обновляется, видя версию данных до обновления. Это означает, что вы можете реализовать игру «Жизнь» Конвея: https://pastila.nl/?00021a4b/d6156ff819c83d490ad2dcec05676865#O0LGWTO7maUQIA4AcGUtlA==
:::



## Оконное представление {#window-view}

<ExperimentalBadge />
<CloudNotSupportedBadge />

:::info
Это экспериментальная функция, которая может измениться несовместимым образом в будущих релизах. Включите использование оконных представлений и запроса `WATCH` с помощью настройки [allow_experimental_window_view](/operations/settings/settings#allow_experimental_window_view). Выполните команду `set allow_experimental_window_view = 1`.
:::

```sql
CREATE WINDOW VIEW [IF NOT EXISTS] [db.]table_name [TO [db.]table_name] [INNER ENGINE engine] [ENGINE engine] [WATERMARK strategy] [ALLOWED_LATENESS interval_function] [POPULATE]
AS SELECT ...
GROUP BY time_window_function
[COMMENT 'comment']
```

Оконное представление может агрегировать данные по временным окнам и выводить результаты, когда окно готово к срабатыванию. Оно сохраняет промежуточные результаты агрегации во внутренней (или указанной) таблице для снижения задержки и может отправлять результаты обработки в указанную таблицу или отправлять уведомления с помощью запроса WATCH.

Создание оконного представления аналогично созданию `MATERIALIZED VIEW`. Оконному представлению требуется внутренний движок хранения для сохранения промежуточных данных. Внутреннее хранилище можно указать с помощью конструкции `INNER ENGINE`; по умолчанию оконное представление использует `AggregatingMergeTree` в качестве внутреннего движка.

При создании оконного представления без `TO [db].[table]` необходимо указать `ENGINE` — движок таблицы для хранения данных.

### Функции временных окон {#time-window-functions}

[Функции временных окон](../../functions/time-window-functions.md) используются для получения нижней и верхней границ окна записей. Оконное представление должно использоваться совместно с функцией временного окна.

### Атрибуты времени {#time-attributes}

Оконное представление поддерживает обработку по **времени обработки** и **времени события**.

**Время обработки** позволяет оконному представлению формировать результаты на основе локального времени машины и используется по умолчанию. Это наиболее простое понятие времени, но оно не обеспечивает детерминированность. Атрибут времени обработки можно определить, установив параметр `time_attr` функции временного окна в столбец таблицы или используя функцию `now()`. Следующий запрос создает оконное представление с временем обработки.

```sql
CREATE WINDOW VIEW wv AS SELECT count(number), tumbleStart(w_id) as w_start from date GROUP BY tumble(now(), INTERVAL '5' SECOND) as w_id
```

**Время события** — это время, когда каждое отдельное событие произошло на устройстве, которое его создало. Это время обычно встраивается в записи при их генерации. Обработка по времени события обеспечивает согласованные результаты даже в случае событий, поступивших не по порядку, или запоздавших событий. Оконное представление поддерживает обработку по времени события с помощью синтаксиса `WATERMARK`.

Оконное представление предоставляет три стратегии водяных знаков:

- `STRICTLY_ASCENDING`: выдает водяной знак с максимальной наблюдаемой на данный момент временной меткой. Строки с временной меткой меньше максимальной не считаются запоздавшими.
- `ASCENDING`: выдает водяной знак с максимальной наблюдаемой на данный момент временной меткой минус 1. Строки с временной меткой, равной или меньшей максимальной, не считаются запоздавшими.
- `BOUNDED`: WATERMARK=INTERVAL. Выдает водяные знаки, которые представляют собой максимальную наблюдаемую временную метку минус указанная задержка.

Следующие запросы являются примерами создания оконного представления с `WATERMARK`:

```sql
CREATE WINDOW VIEW wv WATERMARK=STRICTLY_ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=INTERVAL '3' SECOND AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
```

По умолчанию окно срабатывает при поступлении водяного знака, а элементы, поступившие после водяного знака, отбрасываются. Оконное представление поддерживает обработку запоздавших событий путем установки `ALLOWED_LATENESS=INTERVAL`. Пример обработки запоздавших событий:

```sql
CREATE WINDOW VIEW test.wv TO test.dst WATERMARK=ASCENDING ALLOWED_LATENESS=INTERVAL '2' SECOND AS SELECT count(a) AS count, tumbleEnd(wid) AS w_end FROM test.mt GROUP BY tumble(timestamp, INTERVAL '5' SECOND) AS wid;
```

Обратите внимание, что элементы, выданные при запоздавшем срабатывании, следует рассматривать как обновленные результаты предыдущего вычисления. Вместо срабатывания в конце окна оконное представление срабатывает немедленно при поступлении запоздавшего события. Таким образом, это приведет к множественным выходным данным для одного и того же окна. Пользователям необходимо учитывать эти дублированные результаты или выполнять их дедупликацию.


Вы можете изменить запрос `SELECT`, указанный в оконном представлении, с помощью инструкции `ALTER TABLE ... MODIFY QUERY`. Структура данных, получаемая в результате нового запроса `SELECT`, должна совпадать со структурой исходного запроса `SELECT` как с предложением `TO [db.]name`, так и без него. Обратите внимание, что данные в текущем окне будут потеряны, так как промежуточное состояние не может быть использовано повторно.

### Мониторинг новых окон {#monitoring-new-windows}

Оконное представление поддерживает запрос [WATCH](../../../sql-reference/statements/watch.md) для мониторинга изменений, а также использование синтаксиса `TO` для вывода результатов в таблицу.

```sql
WATCH [db.]window_view
[EVENTS]
[LIMIT n]
[FORMAT format]
```

Можно указать `LIMIT` для установки количества обновлений, которые необходимо получить перед завершением запроса. Предложение `EVENTS` можно использовать для получения краткой формы запроса `WATCH`, где вместо результата запроса вы получите только последнюю временную метку запроса (watermark).

### Настройки {#settings-1}

- `window_view_clean_interval`: Интервал очистки оконного представления в секундах для освобождения устаревших данных. Система сохранит окна, которые не были полностью активированы в соответствии с системным временем или конфигурацией `WATERMARK`, а остальные данные будут удалены.
- `window_view_heartbeat_interval`: Интервал контрольного сигнала в секундах для индикации активности запроса watch.
- `wait_for_window_view_fire_signal_timeout`: Время ожидания сигнала активации оконного представления при обработке времени событий.

### Пример {#example}

Предположим, нам нужно подсчитать количество записей о кликах за каждые 10 секунд в таблице логов с именем `data`, структура которой следующая:

```sql
CREATE TABLE data ( `id` UInt64, `timestamp` DateTime) ENGINE = Memory;
```

Сначала создадим оконное представление с переворачивающимся окном (tumble window) с интервалом 10 секунд:

```sql
CREATE WINDOW VIEW wv as select count(id), tumbleStart(w_id) as window_start from data group by tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Затем используем запрос `WATCH` для получения результатов.

```sql
WATCH wv
```

Когда логи вставляются в таблицу `data`,

```sql
INSERT INTO data VALUES(1,now())
```

Запрос `WATCH` должен вывести результаты следующим образом:

```text
┌─count(id)─┬────────window_start─┐
│         1 │ 2020-01-14 16:56:40 │
└───────────┴─────────────────────┘
```

Альтернативно, мы можем направить вывод в другую таблицу, используя синтаксис `TO`.

```sql
CREATE WINDOW VIEW wv TO dst AS SELECT count(id), tumbleStart(w_id) as window_start FROM data GROUP BY tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Дополнительные примеры можно найти среди stateful-тестов ClickHouse (там они названы `*window_view*`).

### Использование оконных представлений {#window-view-usage}

Оконное представление полезно в следующих сценариях:

- **Мониторинг**: Агрегирование и вычисление метрик логов по времени с выводом результатов в целевую таблицу. Панель мониторинга может использовать целевую таблицу в качестве источника данных.
- **Анализ**: Автоматическое агрегирование и предварительная обработка данных во временном окне. Это может быть полезно при анализе большого количества логов. Предварительная обработка устраняет повторяющиеся вычисления в нескольких запросах и снижает задержку выполнения запросов.


## Связанный контент {#related-content}

- Блог: [Работа с данными временных рядов в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)
- Блог: [Построение решения для наблюдаемости с ClickHouse — Часть 2 — Трассировки](https://clickhouse.com/blog/storing-traces-and-spans-open-telemetry-in-clickhouse)


## Временные представления {#temporary-views}

ClickHouse поддерживает **временные представления** со следующими характеристиками (аналогичными временным таблицам, где применимо):

- **Время жизни сессии**
  Временное представление существует только в течение текущей сессии. Оно автоматически удаляется при завершении сессии.

- **Без базы данных**
  Вы **не можете** указать имя базы данных для временного представления. Оно существует вне баз данных (в пространстве имён сессии).

- **Не реплицируется / без ON CLUSTER**
  Временные объекты являются локальными для сессии и **не могут** быть созданы с `ON CLUSTER`.

- **Разрешение имён**
  Если временный объект (таблица или представление) имеет то же имя, что и постоянный объект, и запрос ссылается на имя **без** указания базы данных, используется **временный** объект.

- **Логический объект (без хранилища)**
  Временное представление хранит только текст своего запроса `SELECT` (внутренне использует движок `View`). Оно не сохраняет данные и не может принимать `INSERT`.

- **Указание движка**
  Вам **не нужно** указывать `ENGINE`; если указано `ENGINE = View`, это игнорируется и обрабатывается как то же логическое представление.

- **Безопасность / привилегии**
  Создание временного представления требует привилегии `CREATE TEMPORARY VIEW`, которая неявно предоставляется привилегией `CREATE VIEW`.

- **SHOW CREATE**
  Используйте `SHOW CREATE TEMPORARY VIEW view_name;` для вывода DDL временного представления.

### Синтаксис {#temporary-views-syntax}

```sql
CREATE TEMPORARY VIEW [IF NOT EXISTS] view_name AS <select_query>
```

`OR REPLACE` **не** поддерживается для временных представлений (для соответствия временным таблицам). Если вам нужно «заменить» временное представление, удалите его и создайте заново.

### Примеры {#temporary-views-examples}

Создайте временную исходную таблицу и временное представление поверх неё:

```sql
CREATE TEMPORARY TABLE t_src (id UInt32, val String);
INSERT INTO t_src VALUES (1, 'a'), (2, 'b');

CREATE TEMPORARY VIEW tview AS
SELECT id, upper(val) AS u
FROM t_src
WHERE id <= 2;

SELECT * FROM tview ORDER BY id;
```

Выведите её DDL:

```sql
SHOW CREATE TEMPORARY VIEW tview;
```

Удалите его:

```sql
DROP TEMPORARY VIEW IF EXISTS tview;  -- временные представления удаляются с синтаксисом TEMPORARY TABLE
```

### Запрещённые операции / ограничения {#temporary-views-limitations}

- `CREATE OR REPLACE TEMPORARY VIEW ...` → **не разрешено** (используйте `DROP` + `CREATE`).
- `CREATE TEMPORARY MATERIALIZED VIEW ...` / `WINDOW VIEW` → **не разрешено**.
- `CREATE TEMPORARY VIEW db.view AS ...` → **не разрешено** (без указания базы данных).
- `CREATE TEMPORARY VIEW view ON CLUSTER 'name' AS ...` → **не разрешено** (временные объекты локальны для сессии).
- `POPULATE`, `REFRESH`, `TO [db.table]`, внутренние движки и все специфичные для материализованных представлений конструкции → **не применимы** к временным представлениям.

### Примечания о распределённых запросах {#temporary-views-distributed-notes}

Временное **представление** — это просто определение; данных для передачи нет. Если ваше временное представление ссылается на временные **таблицы** (например, `Memory`), их данные могут быть переданы на удалённые серверы во время выполнения распределённого запроса так же, как работают временные таблицы.

#### Пример {#temporary-views-distributed-example}

```sql
-- Таблица в памяти с областью видимости сессии
CREATE TEMPORARY TABLE temp_ids (id UInt64) ENGINE = Memory;

INSERT INTO temp_ids VALUES (1), (5), (42);

-- Представление с областью видимости сессии поверх временной таблицы (чисто логическое)
CREATE TEMPORARY VIEW v_ids AS
SELECT id FROM temp_ids;

-- Замените 'test' на имя вашего кластера.
-- GLOBAL JOIN заставляет ClickHouse *передать* малую сторону соединения (temp_ids через v_ids)
-- на каждый удалённый сервер, который выполняет левую сторону.
SELECT count()
FROM cluster('test', system.numbers) AS n
GLOBAL ANY INNER JOIN v_ids USING (id)
WHERE n.number < 100;

```

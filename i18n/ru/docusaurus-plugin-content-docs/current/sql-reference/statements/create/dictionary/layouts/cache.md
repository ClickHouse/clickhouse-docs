---
slug: /sql-reference/statements/create/dictionary/layouts/cache
title: 'структура словаря cache'
sidebar_label: 'cache'
sidebar_position: 6
description: 'Хранение словаря в кэше фиксированного размера в оперативной памяти.'
doc_type: 'reference'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Тип размещения словаря `cached` хранит словарь в кэше с фиксированным количеством ячеек.
Эти ячейки содержат часто используемые элементы.

Ключ словаря имеет тип [UInt64](/sql-reference/data-types/int-uint.md).

При обращении к словарю сначала выполняется поиск в кэше. Для каждого блока данных все ключи, которые не найдены в кэше или устарели, запрашиваются из источника с помощью `SELECT attrs... FROM db.table WHERE id IN (k1, k2, ...)`. Полученные данные затем записываются в кэш.

Если ключи не найдены в словаре, создается задача обновления кэша и добавляется в очередь обновления. Свойства очереди обновления можно контролировать с помощью настроек `max_update_queue_size`, `update_queue_push_timeout_milliseconds`, `query_wait_timeout_milliseconds`, `max_threads_for_updates`.

Для кэшированных словарей может быть задан срок действия [lifetime](../lifetime.md) данных в кэше. Если с момента загрузки данных в ячейку прошло больше времени, чем `lifetime`, значение ячейки не используется, и ключ считается просроченным. Ключ запрашивается повторно при следующем обращении. Это поведение можно настроить с помощью параметра `allow_read_expired_keys`.

Это наименее эффективный из всех способов хранения словарей. Скорость работы кэша сильно зависит от корректных настроек и сценария использования. Словарь типа cache показывает хорошие результаты только при достаточно высоком уровне попаданий в кэш (рекомендуется 99% и выше). Вы можете просмотреть среднее значение hit rate в таблице [system.dictionaries](/operations/system-tables/dictionaries.md).

Если настройка `allow_read_expired_keys` установлена в 1 (по умолчанию 0), словарь может поддерживать асинхронные обновления. Если клиент запрашивает ключи, и все они находятся в кэше, но некоторые из них просрочены, словарь вернет клиенту просроченные ключи и асинхронно запросит их из источника.

Чтобы улучшить производительность кэша, используйте подзапрос с `LIMIT` и выносите вызов функции со словарем во внешний запрос.

Поддерживаются все типы источников.

Пример настроек:

<Tabs>
  <TabItem value="ddl" label="DDL" default>
    ```sql
    LAYOUT(CACHE(SIZE_IN_CELLS 1000000000))
    ```
  </TabItem>

  <TabItem value="xml" label="Configuration file">
    ```xml
    <layout>
        <cache>
            <!-- Размер кэша в количестве ячеек. Округляется вверх до степени двойки. -->
            <size_in_cells>1000000000</size_in_cells>
            <!-- Разрешить чтение просроченных ключей. -->
            <allow_read_expired_keys>0</allow_read_expired_keys>
            <!-- Максимальный размер очереди обновления. -->
            <max_update_queue_size>100000</max_update_queue_size>
            <!-- Максимальное время ожидания в миллисекундах для помещения задачи обновления в очередь. -->
            <update_queue_push_timeout_milliseconds>10</update_queue_push_timeout_milliseconds>
            <!-- Максимальное время ожидания в миллисекундах для завершения задачи обновления. -->
            <query_wait_timeout_milliseconds>60000</query_wait_timeout_milliseconds>
            <!-- Максимальное количество потоков для обновления кэшированного словаря. -->
            <max_threads_for_updates>4</max_threads_for_updates>
        </cache>
    </layout>
    ```
  </TabItem>
</Tabs>

<br />

Задайте достаточно большой размер кэша. Для выбора количества ячеек необходимо провести эксперименты:

1. Установите некоторое значение.
2. Запускайте запросы, пока кэш полностью не заполнится.
3. Оцените потребление памяти с помощью таблицы `system.dictionaries`.
4. Увеличивайте или уменьшайте количество ячеек, пока не будет достигнут требуемый объем потребляемой памяти.

:::note
Не рекомендуется использовать ClickHouse в качестве источника для этого типа размещения. Поиск в словаре требует случайных точечных чтений, что не соответствует шаблону доступа, под который ClickHouse оптимизирован.
:::

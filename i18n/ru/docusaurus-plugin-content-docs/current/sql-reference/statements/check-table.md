---
slug: /sql-reference/statements/check-table
sidebar_position: 41
sidebar_label: CHECK TABLE
title: 'CHECK TABLE Statement'
---

Запрос `CHECK TABLE` в ClickHouse используется для выполнения проверки валидации конкретной таблицы или её партиций. Он обеспечивает целостность данных, проверяя контрольные суммы и другие внутренние структуры данных.

В частности, он сравнивает фактические размеры файлов с ожидаемыми значениями, которые хранятся на сервере. Если размеры файлов не совпадают с сохранёнными значениями, это означает, что данные повреждены. Это может быть вызвано, например, сбоем системы во время выполнения запроса.

:::note
Запрос `CHECK TABLE` может считывать все данные в таблице и занимать ресурсы, что делает его ресурсоёмким. Учитывайте потенциальное влияние на производительность и использование ресурсов перед выполнением этого запроса.
:::

## Синтаксис {#syntax}

Основной синтаксис запроса выглядит следующим образом:

```sql
CHECK TABLE table_name [PARTITION partition_expression | PART part_name] [FORMAT format] [SETTINGS check_query_single_value_result = (0|1) [, other_settings]]
```

- `table_name`: Указывает имя таблицы, которую вы хотите проверить.
- `partition_expression`: (Необязательно) Если вы хотите проверить конкретную партицию таблицы, вы можете использовать это выражение для указания партиции.
- `part_name`: (Необязательно) Если вы хотите проверить конкретную часть таблицы, вы можете добавить строковый литерал для указания имени части.
- `FORMAT format`: (Необязательно) Позволяет указать формат вывода результата.
- `SETTINGS`: (Необязательно) Разрешает дополнительные настройки.
	- **`check_query_single_value_result`**: (Необязательно) Эта настройка позволяет вам переключаться между детализированным результатом (`0`) и сводным результатом (`1`).
	- Также могут быть применены другие настройки. Если вам не требуется детерминированный порядок для результатов, вы можете установить max_threads на значение больше одного для ускорения выполнения запроса.

Ответ на запрос зависит от значения настройки `check_query_single_value_result`. В случае `check_query_single_value_result = 1` возвращается только колонка `result` с одной строкой. Значение внутри этой строки равно `1`, если проверка целостности прошла, и `0`, если данные повреждены.

При `check_query_single_value_result = 0` запрос возвращает следующие колонки:
    - `part_path`: Указывает путь к части данных или имя файла.
    - `is_passed`: Возвращает 1, если проверка для этой части успешна, 0 в противном случае.
    - `message`: Любые дополнительные сообщения, связанные с проверкой, такие как ошибки или сообщения об успехе.

Запрос `CHECK TABLE` поддерживает следующие движки таблиц:

- [Log](../../engines/table-engines/log-family/log.md)
- [TinyLog](../../engines/table-engines/log-family/tinylog.md)
- [StripeLog](../../engines/table-engines/log-family/stripelog.md)
- [MergeTree family](../../engines/table-engines/mergetree-family/mergetree.md)

Выполнение проверки для таблиц с другими движками таблиц вызывает исключение `NOT_IMPLEMENTED`.

Движки из семьи `*Log` не предоставляют автоматического восстановления данных в случае сбоя. Используйте запрос `CHECK TABLE`, чтобы отслеживать потерю данных в своевременном порядке.

## Примеры {#examples}

По умолчанию запрос `CHECK TABLE` показывает общий статус проверки таблицы:

```sql
CHECK TABLE test_table;
```

```text
┌─result─┐
│      1 │
└────────┘
```

Если вы хотите увидеть статус проверки для каждой отдельной части данных, вы можете использовать настройку `check_query_single_value_result`.

Также, чтобы проверить конкретную партицию таблицы, вы можете использовать ключевое слово `PARTITION`.

```sql
CHECK TABLE t0 PARTITION ID '201003'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Вывод:

```text
┌─part_path────┬─is_passed─┬─message─┐
│ 201003_7_7_0 │         1 │         │
│ 201003_3_3_0 │         1 │         │
└──────────────┴───────────┴─────────┘
```

Аналогично, вы можете проверить конкретную часть таблицы, используя ключевое слово `PART`.

```sql
CHECK TABLE t0 PART '201003_7_7_0'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Вывод:

```text
┌─part_path────┬─is_passed─┬─message─┐
│ 201003_7_7_0 │         1 │         │
└──────────────┴───────────┴─────────┘
```

Обратите внимание, что когда часть не существует, запрос возвращает ошибку:

```sql
CHECK TABLE t0 PART '201003_111_222_0'
```

```text
DB::Exception: No such data part '201003_111_222_0' to check in table 'default.t0'. (NO_SUCH_DATA_PART)
```

### Получение результата 'Повреждено' {#receiving-a-corrupted-result}

:::warning
Отказ от ответственности: Описанная здесь процедура, включая ручное манипулирование или удаление файлов напрямую из каталога данных, предназначена только для экспериментальных или девелопментных окружений. Не пытайтесь сделать это на производственном сервере, так как это может привести к потере данных или другим непредвиденным последствиям.
:::

Удалите существующий файл контрольной суммы:

```bash
rm /var/lib/clickhouse-server/data/default/t0/201003_3_3_0/checksums.txt
```

```sql
CHECK TABLE t0 PARTITION ID '201003'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Вывод:

```text
┌─part_path────┬─is_passed─┬─message──────────────────────────────────┐
│ 201003_7_7_0 │         1 │                                          │
│ 201003_3_3_0 │         1 │ Checksums recounted and written to disk. │
└──────────────┴───────────┴──────────────────────────────────────────┘
```

Если файл checksums.txt отсутствует, его можно восстановить. Он будет пересчитан и переписан во время выполнения команды CHECK TABLE для конкретной партиции, и статус всё равно будет сообщен как 'is_passed = 1'.

Вы можете проверить все существующие `(Replicated)MergeTree` таблицы сразу, используя запрос `CHECK ALL TABLES`.

```sql
CHECK ALL TABLES
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

```text
┌─database─┬─table────┬─part_path───┬─is_passed─┬─message─┐
│ default  │ t2       │ all_1_95_3  │         1 │         │
│ db1      │ table_01 │ all_39_39_0 │         1 │         │
│ default  │ t1       │ all_39_39_0 │         1 │         │
│ db1      │ t1       │ all_39_39_0 │         1 │         │
│ db1      │ table_01 │ all_1_6_1   │         1 │         │
│ default  │ t1       │ all_1_6_1   │         1 │         │
│ db1      │ t1       │ all_1_6_1   │         1 │         │
│ db1      │ table_01 │ all_7_38_2  │         1 │         │
│ db1      │ t1       │ all_7_38_2  │         1 │         │
│ default  │ t1       │ all_7_38_2  │         1 │         │
└──────────┴──────────┴─────────────┴───────────┴─────────┘
```

## Если данные повреждены {#if-the-data-is-corrupted}

Если таблица повреждена, вы можете скопировать неповреждённые данные в другую таблицу. Для этого:

1.  Создайте новую таблицу с такой же структурой, как у повреждённой таблицы. Для этого выполните запрос `CREATE TABLE <new_table_name> AS <damaged_table_name>`.
2.  Установите значение `max_threads` равным 1, чтобы обработать следующий запрос в одном потоке. Для этого выполните запрос `SET max_threads = 1`.
3.  Выполните запрос `INSERT INTO <new_table_name> SELECT * FROM <damaged_table_name>`. Этот запрос копирует неповреждённые данные из повреждённой таблицы в другую таблицу. Будут скопированы только данные до повреждённой части.
4.  Перезапустите `clickhouse-client`, чтобы сбросить значение `max_threads`.

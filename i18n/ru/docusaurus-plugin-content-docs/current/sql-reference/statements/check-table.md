---
slug: '/sql-reference/statements/check-table'
sidebar_label: 'CHECK TABLE'
sidebar_position: 41
description: 'Документация для CHECK TABLE'
title: 'Оператор CHECK TABLE'
doc_type: reference
---
Запрос `CHECK TABLE` в ClickHouse используется для выполнения проверки данных на конкретной таблице или ее партициях. Он обеспечивает целостность данных, проверяя контрольные суммы и другие внутренние структуры данных.

В частности, он сравнивает фактические размеры файлов с ожидаемыми значениями, которые хранятся на сервере. Если размеры файлов не совпадают с сохраненными значениями, это означает, что данные повреждены. Это может произойти, например, из-за сбоя системы во время выполнения запроса.

:::warning
Запрос `CHECK TABLE` может читать все данные в таблице и использовать ресурсы, что делает его ресурсоемким.
Учитывайте потенциальное воздействие на производительность и использование ресурсов перед выполнением этого запроса.
Этот запрос не улучшит производительность системы, и не следует его выполнять, если вы не уверены в своих действиях.
:::

## Синтаксис {#syntax}

Базовый синтаксис запроса следующий:

```sql
CHECK TABLE table_name [PARTITION partition_expression | PART part_name] [FORMAT format] [SETTINGS check_query_single_value_result = (0|1) [, other_settings]]
```

- `table_name`: Указывает имя таблицы, которую вы хотите проверить.
- `partition_expression`: (Необязательно) Если вы хотите проверить конкретную партицию таблицы, вы можете использовать это выражение для её указания.
- `part_name`: (Необязательно) Если вы хотите проверить конкретную часть таблицы, вы можете добавить строковый литерал, чтобы указать имя части.
- `FORMAT format`: (Необязательно) Позволяет вам указать формат вывода результата.
- `SETTINGS`: (Необязательно) Позволяет дополнительные настройки.
  - **`check_query_single_value_result`**: (Необязательно) Эта настройка позволяет переключаться между подробным результатом (`0`) и сводным результатом (`1`).
  - Можно применять и другие настройки. Если вам не требуется детерминированный порядок для результатов, вы можете установить max_threads на значение больше одного, чтобы ускорить выполнение запроса.

Ответ на запрос зависит от значения настройки `check_query_single_value_result`.
В случае, если `check_query_single_value_result = 1`, возвращается только столбец `result` с одной строкой. Значение в этой строке равно `1`, если проверка целостности пройдена, и `0`, если данные повреждены.

При `check_query_single_value_result = 0` запрос возвращает следующие столбцы:
    - `part_path`: Указывает путь к части данных или имя файла.
    - `is_passed`: Возвращает 1, если проверка для этой части завершена успешно, и 0 в противном случае.
    - `message`: Любые дополнительные сообщения, касающиеся проверки, такие как ошибки или сообщения об успешном завершении.

Запрос `CHECK TABLE` поддерживает следующие движки таблиц:

- [Log](../../engines/table-engines/log-family/log.md)
- [TinyLog](../../engines/table-engines/log-family/tinylog.md)
- [StripeLog](../../engines/table-engines/log-family/stripelog.md)
- [MergeTree family](../../engines/table-engines/mergetree-family/mergetree.md)

Выполнение над таблицами с другими движками таблиц вызывает исключение `NOT_IMPLEMENTED`.

Движки из семейства `*Log` не обеспечивают автоматическое восстановление данных при сбое. Используйте запрос `CHECK TABLE`, чтобы своевременно отслеживать потерю данных.

## Примеры {#examples}

По умолчанию запрос `CHECK TABLE` показывает общий статус проверки таблицы:

```sql
CHECK TABLE test_table;
```

```text
┌─result─┐
│      1 │
└────────┘
```

Если вы хотите увидеть статус проверки для каждой отдельной части данных, вы можете использовать настройку `check_query_single_value_result`.

Кроме того, для проверки конкретной партиции таблицы вы можете использовать ключевое слово `PARTITION`.

```sql
CHECK TABLE t0 PARTITION ID '201003'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Вывод:

```text
┌─part_path────┬─is_passed─┬─message─┐
│ 201003_7_7_0 │         1 │         │
│ 201003_3_3_0 │         1 │         │
└──────────────┴───────────┴─────────┘
```

Аналогично, вы можете проверить конкретную часть таблицы, используя ключевое слово `PART`.

```sql
CHECK TABLE t0 PART '201003_7_7_0'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Вывод:

```text
┌─part_path────┬─is_passed─┬─message─┐
│ 201003_7_7_0 │         1 │         │
└──────────────┴───────────┴─────────┘
```

Обратите внимание, что когда часть не существует, запрос возвращает ошибку:

```sql
CHECK TABLE t0 PART '201003_111_222_0'
```

```text
DB::Exception: No such data part '201003_111_222_0' to check in table 'default.t0'. (NO_SUCH_DATA_PART)
```

### Получение результата 'Corrupted' {#receiving-a-corrupted-result}

:::warning
Отказ от ответственности: Описанная здесь процедура, включая ручное манипулирование или удаление файлов непосредственно из каталога данных, предназначена только для экспериментальных или развивающихся сред. Не пытайтесь это делать на производственном сервере, так как это может привести к потере данных или другим непредвиденным последствиям.
:::

Удалите существующий файл контрольной суммы:

```bash
rm /var/lib/clickhouse-server/data/default/t0/201003_3_3_0/checksums.txt
```

```sql
CHECK TABLE t0 PARTITION ID '201003'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0


Output:

```text
┌─part_path────┬─is_passed─┬─message──────────────────────────────────┐
│ 201003_7_7_0 │         1 │                                          │
│ 201003_3_3_0 │         1 │ Checksums recounted and written to disk. │
└──────────────┴───────────┴──────────────────────────────────────────┘
```

Если файл checksums.txt отсутствует, его можно восстановить. Он будет пересчитан и перезаписан во время выполнения команды CHECK TABLE для конкретной партиции, и статус по-прежнему будет сообщаться как 'is_passed = 1'.

Вы можете проверить все существующие `(Replicated)MergeTree` таблицы сразу, используя запрос `CHECK ALL TABLES`.

```sql
CHECK ALL TABLES
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

```text
┌─database─┬─table────┬─part_path───┬─is_passed─┬─message─┐
│ default  │ t2       │ all_1_95_3  │         1 │         │
│ db1      │ table_01 │ all_39_39_0 │         1 │         │
│ default  │ t1       │ all_39_39_0 │         1 │         │
│ db1      │ t1       │ all_39_39_0 │         1 │         │
│ db1      │ table_01 │ all_1_6_1   │         1 │         │
│ default  │ t1       │ all_1_6_1   │         1 │         │
│ db1      │ t1       │ all_1_6_1   │         1 │         │
│ db1      │ table_01 │ all_7_38_2  │         1 │         │
│ db1      │ t1       │ all_7_38_2  │         1 │         │
│ default  │ t1       │ all_7_38_2  │         1 │         │
└──────────┴──────────┴─────────────┴───────────┴─────────┘
```

## Если данные повреждены {#if-the-data-is-corrupted}

Если таблица повреждена, вы можете скопировать неповрежденные данные в другую таблицу. Для этого:

1.  Создайте новую таблицу с такой же структурой, как у поврежденной таблицы. Для этого выполните запрос `CREATE TABLE <new_table_name> AS <damaged_table_name>`.
2.  Установите значение `max_threads` равным 1, чтобы обработать следующий запрос в одном потоке. Для этого выполните запрос `SET max_threads = 1`.
3.  Выполните запрос `INSERT INTO <new_table_name> SELECT * FROM <damaged_table_name>`. Этот запрос копирует неповрежденные данные из поврежденной таблицы в другую таблицу. Скопированы будут только данные до поврежденной части.
4.  Перезапустите `clickhouse-client`, чтобы сбросить значение `max_threads`.
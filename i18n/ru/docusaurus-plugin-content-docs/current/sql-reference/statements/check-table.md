---
description: 'Документация по CHECK TABLE'
sidebar_label: 'CHECK TABLE'
sidebar_position: 41
slug: /sql-reference/statements/check-table
title: 'Оператор CHECK TABLE'
doc_type: 'reference'
---

Запрос `CHECK TABLE` в ClickHouse используется для проверки целостности данных в конкретной таблице или её партициях. Он контролирует целостность данных путём проверки контрольных сумм и других внутренних структур данных.

В частности, он сравнивает фактические размеры файлов с ожидаемыми значениями, которые хранятся на сервере. Если размеры файлов не совпадают с сохранёнными значениями, это означает, что данные повреждены. Это может быть вызвано, например, сбоем системы во время выполнения запроса.

:::warning
Запрос `CHECK TABLE` может читать все данные в таблице и занимать значительные ресурсы, что делает его ресурсоёмким.
Оцените потенциальное влияние на производительность и использование ресурсов перед выполнением этого запроса.
Этот запрос не улучшит производительность системы, и вам не следует выполнять его, если вы не уверены в своих действиях.
:::

## Синтаксис \{#syntax\}

Основной синтаксис запроса выглядит следующим образом:

```sql
CHECK TABLE table_name [PARTITION partition_expression | PART part_name] [FORMAT format] [SETTINGS check_query_single_value_result = (0|1) [, other_settings]]
```

* `table_name`: Указывает имя таблицы, которую вы хотите проверить.
* `partition_expression`: (Необязательно) Если вы хотите проверить определённую партицию таблицы, используйте это выражение, чтобы указать партицию.
* `part_name`: (Необязательно) Если вы хотите проверить конкретную часть данных в таблице, добавьте строковый литерал, чтобы указать её имя.
* `FORMAT format`: (Необязательно) Позволяет указать формат вывода результата.
* `SETTINGS`: (Необязательно) Позволяет задать дополнительные настройки.
  * (Необязательно): [check&#95;query&#95;single&#95;value&#95;result](../../operations/settings/settings#check_query_single_value_result): Эта настройка определяет, будет ли вывод детализированным (`0`) или суммарным (`1`).
  * Можно применить и другие настройки. Если для результатов не требуется детерминированный порядок, вы можете установить max&#95;threads больше единицы, чтобы ускорить запрос.

Ответ на запрос зависит от значения настройки `check_query_single_value_result`.
При значении `check_query_single_value_result = 1` возвращается только столбец `result` с одной строкой. Значение в этой строке равно `1`, если проверка целостности пройдена, и `0`, если данные повреждены.

При `check_query_single_value_result = 0` запрос возвращает следующие столбцы:

* `part_path`: Указывает путь к части данных или имя файла.
  * `is_passed`: Возвращает 1, если проверка для этой части прошла успешно, и 0 в противном случае.
  * `message`: Любые дополнительные сообщения, связанные с проверкой, такие как сообщения об ошибках или успешном выполнении.

Запрос `CHECK TABLE` поддерживает следующие движки таблиц:

* [Log](../../engines/table-engines/log-family/log.md)
* [TinyLog](../../engines/table-engines/log-family/tinylog.md)
* [StripeLog](../../engines/table-engines/log-family/stripelog.md)
* [MergeTree family](../../engines/table-engines/mergetree-family/mergetree.md)

Выполнение запроса для таблиц с другими движками таблиц вызывает исключение `NOT_IMPLEMENTED`.

Движки из семейства `*Log` не обеспечивают автоматическое восстановление данных при сбое. Используйте запрос `CHECK TABLE`, чтобы своевременно отслеживать потерю данных.

## Примеры \{#examples\}

По умолчанию запрос `CHECK TABLE` показывает общий статус проверки таблицы:

```sql
CHECK TABLE test_table;
```

```text
┌─result─┐
│      1 │
└────────┘
```

Если вы хотите видеть статус проверки для каждой отдельной части данных, вы можете использовать настройку `check_query_single_value_result`.

Также, чтобы проверить конкретную партицию таблицы, вы можете использовать ключевое слово `PARTITION`.

```sql
CHECK TABLE t0 PARTITION ID '201003'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Результат:

```text
┌─part_path────┬─is_passed─┬─message─┐
│ 201003_7_7_0 │         1 │         │
│ 201003_3_3_0 │         1 │         │
└──────────────┴───────────┴─────────┘
```

Аналогично, можно проверить отдельную часть таблицы с помощью ключевого слова `PART`.

```sql
CHECK TABLE t0 PART '201003_7_7_0'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Результат:

```text
┌─part_path────┬─is_passed─┬─message─┐
│ 201003_7_7_0 │         1 │         │
└──────────────┴───────────┴─────────┘
```

Обратите внимание: если такой части не существует, запрос завершится ошибкой:

```sql
CHECK TABLE t0 PART '201003_111_222_0'
```

```text
DB::Exception: No such data part '201003_111_222_0' to check in table 'default.t0'. (NO_SUCH_DATA_PART)
```

### Получение результата «Corrupted» \{#receiving-a-corrupted-result\}

:::warning
Отказ от ответственности: описанная здесь процедура, включая ручное изменение или удаление файлов непосредственно в каталоге данных, предназначена только для экспериментальных сред и сред разработки. **Не** пытайтесь выполнять её на боевом сервере, так как это может привести к потере данных или другим непредвиденным последствиям.
:::

Удалите существующий файл контрольной суммы:

```bash
rm /var/lib/clickhouse-server/data/default/t0/201003_3_3_0/checksums.txt
```

```sql
CHECK TABLE t0 PARTITION ID '201003'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0


Output:

```text
┌─part_path────┬─is_passed─┬─message──────────────────────────────────┐
│ 201003_7_7_0 │         1 │                                          │
│ 201003_3_3_0 │         1 │ Checksums recounted and written to disk. │
└──────────────┴───────────┴──────────────────────────────────────────┘
```

Если файл checksums.txt отсутствует, его можно восстановить. Он будет заново вычислен и перезаписан во время выполнения команды CHECK TABLE для конкретного раздела, и статус по‑прежнему будет иметь значение `is_passed = 1`.

Вы можете проверить все существующие таблицы `(Replicated)MergeTree` одновременно с помощью запроса `CHECK ALL TABLES`.

```sql
CHECK ALL TABLES
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

```text
┌─database─┬─table────┬─part_path───┬─is_passed─┬─message─┐
│ default  │ t2       │ all_1_95_3  │         1 │         │
│ db1      │ table_01 │ all_39_39_0 │         1 │         │
│ default  │ t1       │ all_39_39_0 │         1 │         │
│ db1      │ t1       │ all_39_39_0 │         1 │         │
│ db1      │ table_01 │ all_1_6_1   │         1 │         │
│ default  │ t1       │ all_1_6_1   │         1 │         │
│ db1      │ t1       │ all_1_6_1   │         1 │         │
│ db1      │ table_01 │ all_7_38_2  │         1 │         │
│ db1      │ t1       │ all_7_38_2  │         1 │         │
│ default  │ t1       │ all_7_38_2  │         1 │         │
└──────────┴──────────┴─────────────┴───────────┴─────────┘
```

## Если данные повреждены {#if-the-data-is-corrupted}

Если таблица повреждена, вы можете скопировать неповреждённые данные в другую таблицу. Для этого:

1.  Создайте новую таблицу с такой же структурой, как у повреждённой таблицы. Для этого выполните запрос `CREATE TABLE <new_table_name> AS <damaged_table_name>`.
2.  Установите значение `max_threads` равным 1, чтобы следующий запрос выполнялся в одном потоке. Для этого выполните запрос `SET max_threads = 1`.
3.  Выполните запрос `INSERT INTO <new_table_name> SELECT * FROM <damaged_table_name>`. Этот запрос копирует неповреждённые данные из повреждённой таблицы в другую таблицу. Будут скопированы только данные до повреждённой части.
4.  Перезапустите `clickhouse-client`, чтобы сбросить значение `max_threads`.
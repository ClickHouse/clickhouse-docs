---
slug: /sql-reference/aggregate-functions/combinators
sidebar_position: 37
sidebar_label: Комбинаторы
---


# Комбинаторы агрегатных функций

Имя агрегатной функции может иметь добавленный суффикс. Это изменяет способ работы агрегатной функции.

## -If {#-if}

К имени любой агрегатной функции можно добавить суффикс -If. В этом случае агрегатная функция принимает дополнительный аргумент – условие (тип Uint8). Агрегатная функция обрабатывает только строки, которые выполняют это условие. Если условие не было выполнено ни разу, она возвращает значение по умолчанию (обычно нули или пустые строки).

Примеры: `sumIf(column, cond)`, `countIf(cond)`, `avgIf(x, cond)`, `quantilesTimingIf(level1, level2)(x, cond)`, `argMinIf(arg, val, cond)` и так далее.

С помощью условных агрегатных функций вы можете вычислять агрегаты для нескольких условий одновременно, не используя подзапросы и `JOIN`s. Например, условные агрегатные функции могут быть использованы для реализации функционала сравнения сегментов.

## -Array {#-array}

Суффикс -Array можно добавить к любой агрегатной функции. В этом случае агрегатная функция принимает аргументы типа 'Array(T)' (массивы) вместо аргументов типа 'T'. Если агрегатная функция принимает несколько аргументов, это должны быть массивы одинаковой длины. При обработке массивов агрегатная функция работает как исходная агрегатная функция по всем элементам массива.

Пример 1: `sumArray(arr)` - Суммирует все элементы всех массивов 'arr'. В этом примере это можно было бы записать проще: `sum(arraySum(arr))`.

Пример 2: `uniqArray(arr)` – Считает количество уникальных элементов во всех массивах 'arr'. Это можно сделать более простым способом: `uniq(arrayJoin(arr))`, но не всегда возможно добавить 'arrayJoin' в запрос.

-If и -Array могут комбинироваться. Однако 'Array' должен быть первым, затем 'If'. Примеры: `uniqArrayIf(arr, cond)`, `quantilesTimingArrayIf(level1, level2)(arr, cond)`. Из-за этого порядка аргумент 'cond' не будет массивом.

## -Map {#-map}

К любой агрегатной функции можно добавить суффикс -Map. Это создаст агрегатную функцию, которая принимает аргумент типа Map и агрегирует значения каждого ключа карты отдельно, используя заданную агрегатную функцию. Результат также будет типа Map.

**Пример**

```sql
CREATE TABLE map_map(
    date Date,
    timeslot DateTime,
    status Map(String, UInt64)
) ENGINE = Log;

INSERT INTO map_map VALUES
    ('2000-01-01', '2000-01-01 00:00:00', (['a', 'b', 'c'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:00:00', (['c', 'd', 'e'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', (['d', 'e', 'f'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', (['f', 'g', 'g'], [10, 10, 10]));

SELECT
    timeslot,
    sumMap(status),
    avgMap(status),
    minMap(status)
FROM map_map
GROUP BY timeslot;

┌────────────timeslot─┬─sumMap(status)───────────────────────┬─avgMap(status)───────────────────────┬─minMap(status)───────────────────────┐
│ 2000-01-01 00:00:00 │ {'a':10,'b':10,'c':20,'d':10,'e':10} │ {'a':10,'b':10,'c':10,'d':10,'e':10} │ {'a':10,'b':10,'c':10,'d':10,'e':10} │
│ 2000-01-01 00:01:00 │ {'d':10,'e':10,'f':20,'g':20}        │ {'d':10,'e':10,'f':10,'g':10}        │ {'d':10,'e':10,'f':10,'g':10}        │
└─────────────────────┴──────────────────────────────────────┴──────────────────────────────────────┴──────────────────────────────────────┘
```

## -SimpleState {#-simplestate}

Если вы применяете этот комбинатор, агрегатная функция возвращает то же значение, но с другим типом. Это [SimpleAggregateFunction(...)](../../sql-reference/data-types/simpleaggregatefunction.md), которая может быть сохранена в таблице для работы с [AggregatingMergeTree](../../engines/table-engines/mergetree-family/aggregatingmergetree.md) таблицами.

**Синтаксис**

``` sql
<aggFunction>SimpleState(x)
```

**Аргументы**

- `x` — Параметры агрегатной функции.

**Возвращаемые значения**

Значение агрегатной функции с типом `SimpleAggregateFunction(...)`.

**Пример**

Запрос:

``` sql
WITH anySimpleState(number) AS c SELECT toTypeName(c), c FROM numbers(1);
```

Результат:

``` text
┌─toTypeName(c)────────────────────────┬─c─┐
│ SimpleAggregateFunction(any, UInt64) │ 0 │
└──────────────────────────────────────┴───┘
```

## -State {#-state}

Если вы применяете этот комбинатор, агрегатная функция не возвращает результирующее значение (например, количество уникальных значений для функции [uniq](/sql-reference/aggregate-functions/reference/uniq)), а промежуточное состояние агрегации (для `uniq` это хеш-таблица для подсчета числа уникальных значений). Это `AggregateFunction(...)`, который может быть использован для дальнейшей обработки или сохранен в таблице для завершения агрегации позже.

:::note
Пожалуйста, обратите внимание, что -MapState не является инвариантом для одних и тех же данных из-за того, что порядок данных в промежуточном состоянии может измениться, хотя это не влияет на прием этих данных.
:::

Чтобы работать с этими состояниями, используйте:

- [AggregatingMergeTree](../../engines/table-engines/mergetree-family/aggregatingmergetree.md) движок таблицы.
- [finalizeAggregation](/sql-reference/functions/other-functions#finalizeaggregation) функция.
- [runningAccumulate](../../sql-reference/functions/other-functions.md#runningaccumulate) функция.
- [-Merge](#-merge) комбинатор.
- [-MergeState](#-mergestate) комбинатор.

## -Merge {#-merge}

Если вы применяете этот комбинатор, агрегатная функция принимает промежуточное состояние агрегации как аргумент, объединяет состояния для завершения агрегации и возвращает результирующее значение.

## -MergeState {#-mergestate}

Объединяет промежуточные состояния агрегации так же, как и комбинатор -Merge. Однако он не возвращает результирующее значение, а промежуточное состояние агрегации, аналогичное комбинатору -State.

## -ForEach {#-foreach}

Преобразует агрегатную функцию для таблиц в агрегатную функцию для массивов, которая агрегирует соответствующие элементы массива и возвращает массив результатов. Например, `sumForEach` для массивов `[1, 2]`, `[3, 4, 5]` и `[6, 7]` возвращает результат `[10, 13, 5]` после сложения соответствующих элементов массива.

## -Distinct {#-distinct}

Каждое уникальное сочетание аргументов будет агрегироваться только один раз. Повторяющиеся значения игнорируются. Примеры: `sum(DISTINCT x)` (или `sumDistinct(x)`), `groupArray(DISTINCT x)` (или `groupArrayDistinct(x)`), `corrStable(DISTINCT x, y)` (или `corrStableDistinct(x, y)`) и так далее.

## -OrDefault {#-ordefault}

Изменяет поведение агрегатной функции.

Если агрегатная функция не имеет входных значений, с этим комбинатором она возвращает значение по умолчанию для своего типа возвращаемых данных. Применяется к агрегатным функциям, которые могут принимать пустые входные данные.

`-OrDefault` может быть использован с другими комбинаторами.

**Синтаксис**

``` sql
<aggFunction>OrDefault(x)
```

**Аргументы**

- `x` — Параметры агрегатной функции.

**Возвращаемые значения**

Возвращает значение по умолчанию типа возвращаемого типа агрегатной функции, если нечего агрегировать.

Тип зависит от используемой агрегатной функции.

**Пример**

Запрос:

``` sql
SELECT avg(number), avgOrDefault(number) FROM numbers(0)
```

Результат:

``` text
┌─avg(number)─┬─avgOrDefault(number)─┐
│         nan │                    0 │
└─────────────┴──────────────────────┘
```

Кроме того, `-OrDefault` может быть использован с другими комбинаторами. Это полезно, когда агрегатная функция не принимает пустые входные данные.

Запрос:

``` sql
SELECT avgOrDefaultIf(x, x > 10)
FROM
(
    SELECT toDecimal32(1.23, 2) AS x
)
```

Результат:

``` text
┌─avgOrDefaultIf(x, greater(x, 10))─┐
│                              0.00 │
└───────────────────────────────────┘
```

## -OrNull {#-ornull}

Изменяет поведение агрегатной функции.

Этот комбинатор преобразует результат агрегатной функции в тип [Nullable](../../sql-reference/data-types/nullable.md). Если у агрегатной функции нет значений для вычисления, она возвращает [NULL](/operations/settings/formats#input_format_null_as_default).

`-OrNull` может быть использован с другими комбинаторами.

**Синтаксис**

``` sql
<aggFunction>OrNull(x)
```

**Аргументы**

- `x` — Параметры агрегатной функции.

**Возвращаемые значения**

- Результат агрегатной функции, преобразованный в тип `Nullable`.
- `NULL`, если нечего агрегировать.

Тип: `Nullable(тип возвращаемого значения агрегатной функции)`.

**Пример**

Добавьте `-orNull` к концу агрегатной функции.

Запрос:

``` sql
SELECT sumOrNull(number), toTypeName(sumOrNull(number)) FROM numbers(10) WHERE number > 10
```

Результат:

``` text
┌─sumOrNull(number)─┬─toTypeName(sumOrNull(number))─┐
│              ᴺᵁᴸᴸ │ Nullable(UInt64)              │
└───────────────────┴───────────────────────────────┘
```

Кроме того, `-OrNull` может быть использован с другими комбинаторами. Это полезно, когда агрегатная функция не принимает пустые входные данные.

Запрос:

``` sql
SELECT avgOrNullIf(x, x > 10)
FROM
(
    SELECT toDecimal32(1.23, 2) AS x
)
```

Результат:

``` text
┌─avgOrNullIf(x, greater(x, 10))─┐
│                           ᴺᵁᴸᴸ │
└────────────────────────────────┘
```

## -Resample {#-resample}

Позволяет разбивать данные на группы, а затем отдельно агрегировать данные в этих группах. Группы создаются путём разбития значений из одной колонки на интервалы.

``` sql
<aggFunction>Resample(start, end, step)(<aggFunction_params>, resampling_key)
```

**Аргументы**

- `start` — Начальное значение всего необходимого интервала для значений `resampling_key`.
- `stop` — Конечное значение всего необходимого интервала для значений `resampling_key`. Весь интервал не включает значение `stop` `[start, stop)`.
- `step` — Шаг для разделения всего интервала на подинтервалы. Функция `aggFunction` выполняется независимо для каждого из этих подинтервалов.
- `resampling_key` — Колонка, значения которой используются для разбиения данных на интервалы.
- `aggFunction_params` — Параметры `aggFunction`.

**Возвращаемые значения**

- Массив результатов `aggFunction` для каждого подинтервала.

**Пример**

Рассмотрим таблицу `people` с следующими данными:

``` text
┌─name───┬─age─┬─wage─┐
│ John   │  16 │   10 │
│ Alice  │  30 │   15 │
│ Mary   │  35 │    8 │
│ Evelyn │  48 │ 11.5 │
│ David  │  62 │  9.9 │
│ Brian  │  60 │   16 │
└────────┴─────┴──────┘
```

Давайте получим имена людей, чей возраст находится в интервалах `[30,60)` и `[60,75)`. Поскольку мы используем целочисленное представление возраста, мы получаем возраст в интервалах `[30, 59]` и `[60,74]`.

Чтобы агрегировать имена в массив, мы используем агрегатную функцию [groupArray](/sql-reference/aggregate-functions/reference/grouparray). Она принимает один аргумент. В нашем случае это колонка `name`. Функция `groupArrayResample` должна использовать колонку `age` для агрегирования имен по возрасту. Чтобы определить необходимые интервалы, мы передаем аргументы `30, 75, 30` в функцию `groupArrayResample`.

``` sql
SELECT groupArrayResample(30, 75, 30)(name, age) FROM people
```

``` text
┌─groupArrayResample(30, 75, 30)(name, age)─────┐
│ [['Alice','Mary','Evelyn'],['David','Brian']] │
└───────────────────────────────────────────────┘
```

Рассмотрим результаты.

`John` не попал в выборку, потому что он слишком молод. Остальные люди распределены по указанным возрастным интервалам.

Теперь давайте подсчитаем общее количество людей и их среднюю зарплату в указанных возрастных интервалах.

``` sql
SELECT
    countResample(30, 75, 30)(name, age) AS amount,
    avgResample(30, 75, 30)(wage, age) AS avg_wage
FROM people
```

``` text
┌─amount─┬─avg_wage──────────────────┐
│ [3,2]  │ [11.5,12.949999809265137] │
└────────┴───────────────────────────┘
```

## -ArgMin {#-argmin}

Суффикс -ArgMin можно добавить к имени любой агрегатной функции. В этом случае агрегатная функция принимает дополнительный аргумент, который должен быть любым сравнимым выражением. Агрегатная функция обрабатывает только строки, которые имеют минимальное значение для указанного дополнительного выражения.

Примеры: `sumArgMin(column, expr)`, `countArgMin(expr)`, `avgArgMin(x, expr)` и так далее.

## -ArgMax {#-argmax}

Похоже на суффикс -ArgMin, но обрабатывает только строки, которые имеют максимальное значение для указанного дополнительного выражения.

## Связанный контент {#related-content}

- Блог: [Использование агрегатных комбинаторов в ClickHouse](https://clickhouse.com/blog/aggregate-functions-combinators-in-clickhouse-for-arrays-maps-and-states)

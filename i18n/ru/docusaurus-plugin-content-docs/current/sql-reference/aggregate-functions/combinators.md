---
description: 'Документация по комбинаторам агрегатных функций'
sidebar_label: 'Комбинаторы'
sidebar_position: 37
slug: /sql-reference/aggregate-functions/combinators
title: 'Комбинаторы агрегатных функций'
doc_type: 'reference'
---



# Комбинаторы агрегатных функций

К имени агрегатной функции может быть добавлен суффикс, что изменяет её поведение.



## -If {#-if}

Суффикс -If может быть добавлен к имени любой агрегатной функции. В этом случае агрегатная функция принимает дополнительный аргумент — условие (тип Uint8). Агрегатная функция обрабатывает только те строки, для которых условие истинно. Если условие ни разу не было истинным, функция возвращает значение по умолчанию (обычно ноль или пустую строку).

Примеры: `sumIf(column, cond)`, `countIf(cond)`, `avgIf(x, cond)`, `quantilesTimingIf(level1, level2)(x, cond)`, `argMinIf(arg, val, cond)` и т. д.

С помощью условных агрегатных функций можно вычислять агрегаты для нескольких условий одновременно, без использования подзапросов и `JOIN`. Например, условные агрегатные функции можно использовать для реализации функциональности сравнения сегментов.


## -Array {#-array}

Суффикс -Array может быть добавлен к любой агрегатной функции. В этом случае агрегатная функция принимает аргументы типа 'Array(T)' (массивы) вместо аргументов типа 'T'. Если агрегатная функция принимает несколько аргументов, это должны быть массивы одинаковой длины. При обработке массивов агрегатная функция работает как исходная агрегатная функция, применяясь ко всем элементам массива.

Пример 1: `sumArray(arr)` — суммирует все элементы всех массивов 'arr'. В данном примере это можно было бы записать проще: `sum(arraySum(arr))`.

Пример 2: `uniqArray(arr)` — подсчитывает количество уникальных элементов во всех массивах 'arr'. Это можно сделать более простым способом: `uniq(arrayJoin(arr))`, но не всегда возможно добавить 'arrayJoin' в запрос.

Суффиксы -If и -Array можно комбинировать. Однако 'Array' должен идти первым, затем 'If'. Примеры: `uniqArrayIf(arr, cond)`, `quantilesTimingArrayIf(level1, level2)(arr, cond)`. Из-за такого порядка аргумент 'cond' не будет массивом.


## -Map {#-map}

Суффикс -Map может быть добавлен к любой агрегатной функции. Это создаст агрегатную функцию, которая принимает тип Map в качестве аргумента и агрегирует значения для каждого ключа отдельно, используя указанную агрегатную функцию. Результат также имеет тип Map.

**Пример**

```sql
CREATE TABLE map_map(
    date Date,
    timeslot DateTime,
    status Map(String, UInt64)
) ENGINE = Log;

INSERT INTO map_map VALUES
    ('2000-01-01', '2000-01-01 00:00:00', (['a', 'b', 'c'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:00:00', (['c', 'd', 'e'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', (['d', 'e', 'f'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', (['f', 'g', 'g'], [10, 10, 10]));

SELECT
    timeslot,
    sumMap(status),
    avgMap(status),
    minMap(status)
FROM map_map
GROUP BY timeslot;

┌────────────timeslot─┬─sumMap(status)───────────────────────┬─avgMap(status)───────────────────────┬─minMap(status)───────────────────────┐
│ 2000-01-01 00:00:00 │ {'a':10,'b':10,'c':20,'d':10,'e':10} │ {'a':10,'b':10,'c':10,'d':10,'e':10} │ {'a':10,'b':10,'c':10,'d':10,'e':10} │
│ 2000-01-01 00:01:00 │ {'d':10,'e':10,'f':20,'g':20}        │ {'d':10,'e':10,'f':10,'g':10}        │ {'d':10,'e':10,'f':10,'g':10}        │
└─────────────────────┴──────────────────────────────────────┴──────────────────────────────────────┴──────────────────────────────────────┘
```


## -SimpleState {#-simplestate}

При применении этого комбинатора агрегатная функция возвращает то же значение, но с другим типом данных. Это [SimpleAggregateFunction(...)](../../sql-reference/data-types/simpleaggregatefunction.md), который можно сохранить в таблице для работы с таблицами [AggregatingMergeTree](../../engines/table-engines/mergetree-family/aggregatingmergetree.md).

**Синтаксис**

```sql
<aggFunction>SimpleState(x)
```

**Аргументы**

- `x` — параметры агрегатной функции.

**Возвращаемые значения**

Значение агрегатной функции с типом `SimpleAggregateFunction(...)`.

**Пример**

Запрос:

```sql
WITH anySimpleState(number) AS c SELECT toTypeName(c), c FROM numbers(1);
```

Результат:

```text
┌─toTypeName(c)────────────────────────┬─c─┐
│ SimpleAggregateFunction(any, UInt64) │ 0 │
└──────────────────────────────────────┴───┘
```


## -State {#-state}

При применении этого комбинатора агрегатная функция возвращает не итоговое значение (например, количество уникальных значений для функции [uniq](/sql-reference/aggregate-functions/reference/uniq)), а промежуточное состояние агрегации (для `uniq` это хеш-таблица для вычисления количества уникальных значений). Результатом является `AggregateFunction(...)`, который можно использовать для дальнейшей обработки или сохранить в таблице для завершения агрегации позднее.

:::note
Обратите внимание, что -MapState не является инвариантом для одних и тех же данных, так как порядок данных в промежуточном состоянии может изменяться, хотя это не влияет на обработку этих данных.
:::

Для работы с этими состояниями используйте:

- движок таблиц [AggregatingMergeTree](../../engines/table-engines/mergetree-family/aggregatingmergetree.md);
- функцию [finalizeAggregation](/sql-reference/functions/other-functions#finalizeAggregation);
- функцию [runningAccumulate](../../sql-reference/functions/other-functions.md#runningAccumulate);
- комбинатор [-Merge](#-merge);
- комбинатор [-MergeState](#-mergestate).


## -Merge {#-merge}

При использовании этого комбинатора агрегатная функция принимает промежуточное состояние агрегации в качестве аргумента, объединяет состояния для завершения агрегации и возвращает итоговое значение.


## -MergeState {#-mergestate}

Объединяет промежуточные состояния агрегации так же, как комбинатор -Merge. Однако возвращает не итоговое значение, а промежуточное состояние агрегации, как и комбинатор -State.


## -ForEach {#-foreach}

Преобразует агрегатную функцию для таблиц в агрегатную функцию для массивов, которая агрегирует соответствующие элементы массивов и возвращает массив результатов. Например, `sumForEach` для массивов `[1, 2]`, `[3, 4, 5]` и `[6, 7]` возвращает результат `[10, 13, 5]` после сложения соответствующих элементов массивов.


## -Distinct {#-distinct}

Каждая уникальная комбинация аргументов агрегируется только один раз. Повторяющиеся значения игнорируются.
Примеры: `sum(DISTINCT x)` (или `sumDistinct(x)`), `groupArray(DISTINCT x)` (или `groupArrayDistinct(x)`), `corrStable(DISTINCT x, y)` (или `corrStableDistinct(x, y)`) и т. д.


## -OrDefault {#-ordefault}

Изменяет поведение агрегатной функции.

Если агрегатная функция не имеет входных значений, с этим комбинатором она возвращает значение по умолчанию для своего возвращаемого типа данных. Применяется к агрегатным функциям, которые могут принимать пустые входные данные.

`-OrDefault` может использоваться с другими комбинаторами.

**Синтаксис**

```sql
<aggFunction>OrDefault(x)
```

**Аргументы**

- `x` — параметры агрегатной функции.

**Возвращаемые значения**

Возвращает значение по умолчанию для возвращаемого типа агрегатной функции, если нечего агрегировать.

Тип зависит от используемой агрегатной функции.

**Пример**

Запрос:

```sql
SELECT avg(number), avgOrDefault(number) FROM numbers(0)
```

Результат:

```text
┌─avg(number)─┬─avgOrDefault(number)─┐
│         nan │                    0 │
└─────────────┴──────────────────────┘
```

Также `-OrDefault` может использоваться с другими комбинаторами. Это полезно, когда агрегатная функция не принимает пустые входные данные.

Запрос:

```sql
SELECT avgOrDefaultIf(x, x > 10)
FROM
(
    SELECT toDecimal32(1.23, 2) AS x
)
```

Результат:

```text
┌─avgOrDefaultIf(x, greater(x, 10))─┐
│                              0.00 │
└───────────────────────────────────┘
```


## -OrNull {#-ornull}

Изменяет поведение агрегатной функции.

Этот комбинатор преобразует результат агрегатной функции в тип данных [Nullable](../../sql-reference/data-types/nullable.md). Если у агрегатной функции нет значений для вычисления, она возвращает [NULL](/operations/settings/formats#input_format_null_as_default).

`-OrNull` может использоваться с другими комбинаторами.

**Синтаксис**

```sql
<aggFunction>OrNull(x)
```

**Аргументы**

- `x` — параметры агрегатной функции.

**Возвращаемые значения**

- Результат агрегатной функции, преобразованный в тип данных `Nullable`.
- `NULL`, если нечего агрегировать.

Тип: `Nullable(тип возвращаемого значения агрегатной функции)`.

**Пример**

Добавьте `-orNull` в конец имени агрегатной функции.

Запрос:

```sql
SELECT sumOrNull(number), toTypeName(sumOrNull(number)) FROM numbers(10) WHERE number > 10
```

Результат:

```text
┌─sumOrNull(number)─┬─toTypeName(sumOrNull(number))─┐
│              ᴺᵁᴸᴸ │ Nullable(UInt64)              │
└───────────────────┴───────────────────────────────┘
```

Также `-OrNull` может использоваться с другими комбинаторами. Это полезно, когда агрегатная функция не принимает пустые входные данные.

Запрос:

```sql
SELECT avgOrNullIf(x, x > 10)
FROM
(
    SELECT toDecimal32(1.23, 2) AS x
)
```

Результат:

```text
┌─avgOrNullIf(x, greater(x, 10))─┐
│                           ᴺᵁᴸᴸ │
└────────────────────────────────┘
```


## -Resample {#-resample}

Позволяет разделить данные на группы и затем отдельно агрегировать данные в этих группах. Группы создаются путём разбиения значений одного столбца на интервалы.

```sql
<aggFunction>Resample(start, end, step)(<aggFunction_params>, resampling_key)
```

**Аргументы**

- `start` — Начальное значение всего требуемого интервала для значений `resampling_key`.
- `stop` — Конечное значение всего требуемого интервала для значений `resampling_key`. Весь интервал не включает значение `stop` `[start, stop)`.
- `step` — Шаг для разделения всего интервала на подинтервалы. Функция `aggFunction` выполняется для каждого из этих подинтервалов независимо.
- `resampling_key` — Столбец, значения которого используются для разделения данных на интервалы.
- `aggFunction_params` — Параметры функции `aggFunction`.

**Возвращаемые значения**

- Массив результатов `aggFunction` для каждого подинтервала.

**Пример**

Рассмотрим таблицу `people` со следующими данными:

```text
┌─name───┬─age─┬─wage─┐
│ John   │  16 │   10 │
│ Alice  │  30 │   15 │
│ Mary   │  35 │    8 │
│ Evelyn │  48 │ 11.5 │
│ David  │  62 │  9.9 │
│ Brian  │  60 │   16 │
└────────┴─────┴──────┘
```

Получим имена людей, чей возраст находится в интервалах `[30,60)` и `[60,75)`. Поскольку мы используем целочисленное представление для возраста, мы получаем возраста в интервалах `[30, 59]` и `[60,74]`.

Для агрегирования имён в массив используется агрегатная функция [groupArray](/sql-reference/aggregate-functions/reference/grouparray). Она принимает один аргумент. В нашем случае это столбец `name`. Функция `groupArrayResample` должна использовать столбец `age` для агрегирования имён по возрасту. Чтобы определить требуемые интервалы, передаём аргументы `30, 75, 30` в функцию `groupArrayResample`.

```sql
SELECT groupArrayResample(30, 75, 30)(name, age) FROM people
```

```text
┌─groupArrayResample(30, 75, 30)(name, age)─────┐
│ [['Alice','Mary','Evelyn'],['David','Brian']] │
└───────────────────────────────────────────────┘
```

Рассмотрим результаты.

`John` не входит в выборку, потому что он слишком молод. Остальные люди распределены в соответствии с указанными возрастными интервалами.

Теперь подсчитаем общее количество людей и их среднюю заработную плату в указанных возрастных интервалах.

```sql
SELECT
    countResample(30, 75, 30)(name, age) AS amount,
    avgResample(30, 75, 30)(wage, age) AS avg_wage
FROM people
```

```text
┌─amount─┬─avg_wage──────────────────┐
│ [3,2]  │ [11.5,12.949999809265137] │
└────────┴───────────────────────────┘
```


## -ArgMin {#-argmin}

Суффикс -ArgMin может быть добавлен к имени любой агрегатной функции. В этом случае агрегатная функция принимает дополнительный аргумент, который должен быть сравнимым выражением. Агрегатная функция обрабатывает только те строки, для которых указанное дополнительное выражение имеет минимальное значение.

Примеры: `sumArgMin(column, expr)`, `countArgMin(expr)`, `avgArgMin(x, expr)` и т. д.


## -ArgMax {#-argmax}

Аналогичен суффиксу -ArgMin, но обрабатывает только те строки, которые имеют максимальное значение для указанного дополнительного выражения.


## Связанный контент {#related-content}

- Блог: [Использование комбинаторов агрегатных функций в ClickHouse](https://clickhouse.com/blog/aggregate-functions-combinators-in-clickhouse-for-arrays-maps-and-states)

---
description: 'Обеспечивает одновременную обработку файлов, соответствующих заданному пути, на нескольких узлах кластера. Инициатор устанавливает соединения с рабочими узлами, раскрывает glob-шаблоны в пути к файлам и делегирует задачи чтения файлов рабочим узлам. Каждый рабочий узел запрашивает у инициатора следующий файл для обработки и продолжает до тех пор, пока все задачи не будут выполнены (все файлы не будут прочитаны).'
sidebar_label: 'fileCluster'
sidebar_position: 61
slug: /sql-reference/table-functions/fileCluster
title: 'fileCluster'
doc_type: 'reference'
---

# Табличная функция fileCluster {#filecluster-table-function}

Позволяет одновременно обрабатывать файлы, соответствующие заданному пути, на нескольких узлах кластера. Инициатор устанавливает соединения с рабочими узлами, разворачивает glob-шаблоны в пути к файлам и делегирует задачи чтения файлов рабочим узлам. Каждый рабочий узел запрашивает у инициатора следующий файл для обработки и повторяет это до тех пор, пока все задачи не будут выполнены (все файлы не будут прочитаны).

:::note    
Эта функция будет работать _корректно_ только в том случае, если набор файлов, соответствующих изначально указанному пути, идентичен на всех узлах, а их содержимое совпадает на разных узлах.  
Если эти файлы различаются между узлами, возвращаемое значение нельзя заранее предсказать, так как оно зависит от порядка, в котором рабочие узлы запрашивают задачи у инициатора.
:::

## Синтаксис {#syntax}

```sql
fileCluster(cluster_name, path[, format, structure, compression_method])
```

## Аргументы {#arguments}

| Аргумент             | Описание                                                                                                                                                                          |
|----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `cluster_name`       | Имя кластера, которое используется для формирования набора адресов и параметров подключения к удалённым и локальным серверам.                                                    |
| `path`               | Относительный путь к файлу относительно [user_files_path](/operations/server-configuration-parameters/settings.md#user_files_path). Путь к файлу также поддерживает [globs](#globs-in-path). |
| `format`             | [Формат](/sql-reference/formats) файлов. Тип: [String](../../sql-reference/data-types/string.md).                                                                                 |
| `structure`          | Структура таблицы в формате `'UserID UInt64, Name String'`. Определяет имена и типы столбцов. Тип: [String](../../sql-reference/data-types/string.md).                            |
| `compression_method` | Метод сжатия. Поддерживаемые типы сжатия: `gz`, `br`, `xz`, `zst`, `lz4` и `bz2`.                                                                                                 |

## Возвращаемое значение {#returned_value}

Таблица указанного формата и структуры с данными из файлов, путь к которым соответствует указанному.

**Пример**

Пусть имеется кластер с именем `my_cluster`, и задано следующее значение настройки `user_files_path`:

```bash
$ grep user_files_path /etc/clickhouse-server/config.xml
    <user_files_path>/var/lib/clickhouse/user_files/</user_files_path>
```

Также, при условии, что в `user_files_path` каждого узла кластера есть файлы `test1.csv` и `test2.csv`, и их содержимое одинаково на всех узлах:

```bash
$ cat /var/lib/clickhouse/user_files/test1.csv
    1,"file1"
    11,"file11"

$ cat /var/lib/clickhouse/user_files/test2.csv
    2,"file2"
    22,"file22"
```

Например, можно создать эти файлы, выполнив эти два запроса на каждом узле кластера:

```sql
INSERT INTO TABLE FUNCTION file('file1.csv', 'CSV', 'i UInt32, s String') VALUES (1,'file1'), (11,'file11');
INSERT INTO TABLE FUNCTION file('file2.csv', 'CSV', 'i UInt32, s String') VALUES (2,'file2'), (22,'file22');
```

Теперь прочитайте данные из файлов `test1.csv` и `test2.csv` с помощью табличной функции `fileCluster`:

```sql
SELECT * FROM fileCluster('my_cluster', 'file{1,2}.csv', 'CSV', 'i UInt32, s String') ORDER BY i, s
```

```response
┌──i─┬─s──────┐
│  1 │ file1  │
│ 11 │ file11 │
└────┴────────┘
┌──i─┬─s──────┐
│  2 │ file2  │
│ 22 │ file22 │
└────┴────────┘
```

## Глоб-шаблоны в пути {#globs-in-path}

Все шаблоны, поддерживаемые табличной функцией [File](../../sql-reference/table-functions/file.md#globs-in-path), также поддерживаются функцией FileCluster.

## Смотрите также {#related}

- [Табличная функция `file`](../../sql-reference/table-functions/file.md)

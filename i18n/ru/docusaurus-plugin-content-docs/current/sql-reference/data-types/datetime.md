---
slug: /sql-reference/data-types/datetime
sidebar_position: 16
sidebar_label: DateTime
---


# DateTime

Позволяет хранить момент времени, который можно выразить как календарную дату и время суток.

Синтаксис:

``` sql
DateTime([timezone])
```

Поддерживаемый диапазон значений: \[1970-01-01 00:00:00, 2106-02-07 06:28:15\].

Разрешение: 1 секунда.

## Скорость {#speed}

Тип данных `Date` быстрее, чем `DateTime` при _большинстве_ условий.

Тип `Date` требует 2 байта хранилища, в то время как `DateTime` требует 4. Однако, когда база данных сжимается, эта разница усиливается. Это усиление связано с тем, что минуты и секунды в `DateTime` менее сжимаемы. Фильтрация и агрегация `Date` вместо `DateTime` также быстрее.

## Замечания по использованию {#usage-remarks}

Момент времени сохраняется как [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time), независимо от часового пояса или перехода на летнее/зимнее время. Часовой пояс влияет на то, как значения типа `DateTime` отображаются в текстовом формате и как значения, указанные в виде строк, разбираются ('2020-01-01 05:00:01').

Универсальный Unix timestamp хранится в таблицах, а часовой пояс используется для преобразования его в текстовый формат или обратно при импорте/экспорте данных или для выполнения календарных вычислений на значениях (например: функции `toDate`, `toHour` и т. д.). Часовой пояс не хранится в строках таблицы (или в наборе результатов), но хранится в метаданных колонки.

Список поддерживаемых часовых поясов можно найти в [IANA Time Zone Database](https://www.iana.org/time-zones) и также можно запросить с помощью `SELECT * FROM system.time_zones`. [Список](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) также доступен на Википедии.

Вы можете явно установить часовой пояс для колонок типа `DateTime`, когда создаете таблицу. Пример: `DateTime('UTC')`. Если часовой пояс не установлен, ClickHouse использует значение параметра [timezone](../../operations/server-configuration-parameters/settings.md#timezone) в настройках сервера или настройки операционной системы на момент запуска сервера ClickHouse.

[clickhouse-client](../../interfaces/cli.md) по умолчанию применяет часовой пояс сервера, если часовой пояс не установлен явно при инициализации типа данных. Чтобы использовать часовой пояс клиента, запустите `clickhouse-client` с параметром `--use_client_time_zone`.

ClickHouse выводит значения в зависимости от значения настройки [date_time_output_format](../../operations/settings/settings-formats.md#date_time_output_format). По умолчанию текстовый формат `YYYY-MM-DD hh:mm:ss`. Кроме того, вы можете изменить вывод с помощью функции [formatDateTime](../../sql-reference/functions/date-time-functions.md#formatdatetime).

При вставке данных в ClickHouse вы можете использовать разные форматы строк даты и времени, в зависимости от значения настройки [date_time_input_format](../../operations/settings/settings-formats.md#date_time_input_format).

## Примеры {#examples}

**1.** Создание таблицы с колонкой типа `DateTime` и вставка данных в нее:

``` sql
CREATE TABLE dt
(
    `timestamp` DateTime('Asia/Istanbul'),
    `event_id` UInt8
)
ENGINE = TinyLog;
```

``` sql
-- Разбор DateTime
-- - из строки,
-- - из целого числа, интерпретируемого как количество секунд с 1970-01-01.
INSERT INTO dt VALUES ('2019-01-01 00:00:00', 1), (1546300800, 3);

SELECT * FROM dt;
```

``` text
┌───────────timestamp─┬─event_id─┐
│ 2019-01-01 00:00:00 │        2 │
│ 2019-01-01 03:00:00 │        1 │
└─────────────────────┴──────────┘
```

- При вставке времени в виде целого числа оно рассматривается как Unix Timestamp (UTC). `1546300800` представляет собой `'2019-01-01 00:00:00'` UTC. Однако, так как колонка `timestamp` имеет указанный часовой пояс `Asia/Istanbul` (UTC+3), при выводе в виде строки значение будет отображено как `'2019-01-01 03:00:00'`
- При вставке строкового значения как времени, оно рассматривается как находящееся в часовом поясе колонки. `'2019-01-01 00:00:00'` будет восприниматься как находящееся в часовом поясе `Asia/Istanbul` и сохранено как `1546290000`.

**2.** Фильтрация по значениям `DateTime`

``` sql
SELECT * FROM dt WHERE timestamp = toDateTime('2019-01-01 00:00:00', 'Asia/Istanbul')
```

``` text
┌───────────timestamp─┬─event_id─┐
│ 2019-01-01 00:00:00 │        1 │
└─────────────────────┴──────────┘
```

Значения колонки `DateTime` могут быть отфильтрованы с использованием строкового значения в предикате `WHERE`. Оно будет автоматически преобразовано в `DateTime`:

``` sql
SELECT * FROM dt WHERE timestamp = '2019-01-01 00:00:00'
```

``` text
┌───────────timestamp─┬─event_id─┐
│ 2019-01-01 00:00:00 │        1 │
└─────────────────────┴──────────┘
```

**3.** Получение часового пояса для колонки типа `DateTime`:

``` sql
SELECT toDateTime(now(), 'Asia/Istanbul') AS column, toTypeName(column) AS x
```

``` text
┌──────────────column─┬─x─────────────────────────┐
│ 2019-10-16 04:12:04 │ DateTime('Asia/Istanbul') │
└─────────────────────┴───────────────────────────┘
```

**4.** Преобразование часового пояса

``` sql
SELECT
toDateTime(timestamp, 'Europe/London') as lon_time,
toDateTime(timestamp, 'Asia/Istanbul') as mos_time
FROM dt
```

``` text
┌───────────lon_time──┬────────────mos_time─┐
│ 2019-01-01 00:00:00 │ 2019-01-01 03:00:00 │
│ 2018-12-31 21:00:00 │ 2019-01-01 00:00:00 │
└─────────────────────┴─────────────────────┘
```

Так как преобразование часового пояса изменяет только метаданные, операция не имеет вычислительной стоимости.


## Ограничения поддержки часовых поясов {#limitations-on-time-zones-support}

Некоторые часовые пояса могут не поддерживаться полностью. Есть несколько случаев:

Если смещение от UTC не кратно 15 минутам, вычисление часов и минут может быть неверным. Например, часовой пояс в Монровии, Либерия, имел смещение UTC -0:44:30 до 7 Января 1972 года. Если вы выполняете вычисления по историческому времени в часовом поясе Монровии, функции обработки времени могут дать неверные результаты. Тем не менее, результаты после 7 Января 1972 года будут правильными.

Если переход времени (из-за перехода на летнее/зимнее время или по другим причинам) был выполнен в момент, который не кратен 15 минутам, вы также можете получить неверные результаты в этот конкретный день.

Немонтохронные календарные даты. Например, в Гладкой Долине - Гусином берегу, время было переключено на час назад в 00:01:00 7 Ноября 2010 года (через минуту после полуночи). Таким образом, после окончания 6 Ноября, люди наблюдали целую минуту 7 Ноября, затем время было изменено обратно на 23:01 6 Ноября, и после еще 59 минут 7 Ноября снова началось. ClickHouse пока не поддерживает такой вид эксцентрики. В течение этих дней результаты функций обработки времени могут быть немного неверными.

Похожая проблема существует для станции Кейси в Антарктике в 2010 году. Они изменили время на три часа назад 5 Марта в 02:00. Если вы работаете на антарктической станции, пожалуйста, не бойтесь использовать ClickHouse. Просто убедитесь, что вы установили часовой пояс на UTC или осведомлены о неточностях.

Сдвиги времени на несколько дней. Некоторые тихоокеанские острова изменили свое смещение часового пояса с UTC+14 до UTC-12. Это нормально, но некоторые неточности могут возникнуть, если вы выполняете вычисления с их часовым поясом для исторических временных точек в дни преобразования.

## Обработка перехода на летнее время (DST) {#handling-daylight-saving-time-dst}

Тип DateTime ClickHouse с часовыми поясами может проявлять неожиданное поведение во время переходов на летнее/зимнее время (DST), особенно когда:

- [`date_time_output_format`](../../operations/settings/settings-formats.md#date_time_output_format) установлен в `simple`.
- Часы двигаются назад ("Fall Back"), вызывая наложение на один час.
- Часы двигаются вперед ("Spring Forward"), вызывая пропуск одного часа.

По умолчанию ClickHouse всегда выбирает более раннее время из наложенного времени и может интерпретировать несуществующее время во время переходов вперед.

Например, рассмотрим следующий переход от летнего времени (DST) к стандартному времени.

- 29 октября 2023 года в 02:00:00 часы перемещаются назад на 01:00:00 (BST → GMT).
- Час 01:00:00 – 01:59:59 появляется дважды (один раз в BST и один раз в GMT)
- ClickHouse всегда выбирает первое вхождение (BST), что приводит к неожиданным результатам при добавлении временных интервалов.

```sql
SELECT '2023-10-29 01:30:00'::DateTime('Europe/London') AS time, time + toIntervalHour(1) AS one_hour_later

┌────────────────time─┬──────one_hour_later─┐
│ 2023-10-29 01:30:00 │ 2023-10-29 01:30:00 │
└─────────────────────┴─────────────────────┘
```

Аналогично, во время перехода от стандартного времени к летнему времени час может не существовать.

Например:

- 26 марта 2023 года в `00:59:59` часы прыгают вперед на `02:00:00` (GMT → BST).
- Час `01:00:00` – `01:59:59` не существует.

```sql
SELECT '2023-03-26 01:30:00'::DateTime('Europe/London') AS time, time + toIntervalHour(1) AS one_hour_later

┌────────────────time─┬──────one_hour_later─┐
│ 2023-03-26 00:30:00 │ 2023-03-26 02:30:00 │
└─────────────────────┴─────────────────────┘
```

В этом случае ClickHouse перемещает несуществующее время `2023-03-26 01:30:00` назад на `2023-03-26 00:30:00`.

## Смотрите также {#see-also}

- [Функции преобразования типов](../../sql-reference/functions/type-conversion-functions.md)
- [Функции для работы с датами и временем](../../sql-reference/functions/date-time-functions.md)
- [Функции для работы с массивами](../../sql-reference/functions/array-functions.md)
- [Настройка `date_time_input_format`](../../operations/settings/settings-formats.md#date_time_input_format)
- [Настройка `date_time_output_format`](../../operations/settings/settings-formats.md#date_time_output_format)
- [Параметр конфигурации сервера `timezone`](../../operations/server-configuration-parameters/settings.md#timezone)
- [Настройка `session_timezone`](../../operations/settings/settings.md#session_timezone)
- [Операторы для работы с датами и временем](../../sql-reference/operators#operators-for-working-with-dates-and-times)
- [Тип данных `Date`](../../sql-reference/data-types/date.md)

---
slug: '/sql-reference/functions/bitmap-functions'
sidebar_label: 'Битовые функции'
description: 'Документация для функций Bitmap'
title: 'Битовые функции'
doc_type: reference
---
# Функции битовых карт

Битовые карты могут быть построены двумя способами. Первый способ — это использование агрегатной функции groupBitmap с `-State`, второй способ — это создание битовой карты из объекта Array.

<!-- 
Внутреннее содержание тегов ниже будет заменено на этапе сборки документа сгенерированными 
документами из system.functions. Пожалуйста, не изменяйте и не удаляйте теги.
См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## bitmapAnd {#bitmapAnd}

Введено в: v20.1

Вычисляет логическое и (AND) двух битовых карт.

**Синтаксис**

```sql
bitmapAnd(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает битовую карту, содержащую биты, присутствующие в обеих входных битовых картах [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(bitmapAnd(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─┐
│ [3] │
└─────┘
```



## bitmapAndCardinality {#bitmapAndCardinality}

Введено в: v20.1

Возвращает кардинальность логического и (AND) двух битовых карт.

**Синтаксис**

```sql
bitmapAndCardinality(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает количество установленных битов в пересечении двух битовых карт [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapAndCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```



## bitmapAndnot {#bitmapAndnot}

Введено в: v20.1

Вычисляет логическое и двух битовых карт и отрицает результат (AND-NOT).

**Синтаксис**

```sql
bitmapAndnot(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает битовую карту, содержащую установленные биты, присутствующие в первой битовой карте, но не во второй [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(bitmapAndnot(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res────┐
│ [1, 2] │
└────────┘
```



## bitmapAndnotCardinality {#bitmapAndnotCardinality}

Введено в: v20.1

Возвращает кардинальность операции AND-NOT двух битовых карт.

**Синтаксис**

```sql
bitmapAndnotCardinality(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает количество установленных битов в результате `bitmap1 AND-NOT bitmap2` [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapAndnotCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```



## bitmapBuild {#bitmapBuild}

Введено в: v20.1

Строит битовую карту из массива беззнаковых целых чисел. Это противоположно функции [`bitmapToArray`](/sql-reference/functions/bitmap-functions#bitmapToArray).

**Синтаксис**

```sql
bitmapBuild(array)
```

**Аргументы**

- `array` — Массив беззнаковых целых чисел. [`Array(UInt*)`](/sql-reference/data-types/array)


**Возвращаемое значение**

Возвращает битовую карту из предоставленного массива [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapBuild([1, 2, 3, 4, 5]) AS res, toTypeName(res);
```

```response title=Response
┌─res─┬─toTypeName(bitmapBuild([1, 2, 3, 4, 5]))─────┐
│     │ AggregateFunction(groupBitmap, UInt8)        │
└─────┴──────────────────────────────────────────────┘
```



## bitmapCardinality {#bitmapCardinality}

Введено в: v20.1

Возвращает количество установленных битов (кардинальность) в битовой карте.

**Синтаксис**

```sql
bitmapCardinality(bitmap)
```

**Аргументы**

- `bitmap` — Битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает количество установленных битов в битовой карте [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapCardinality(bitmapBuild([1, 3, 3, 5, 7, 7])) AS res
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```



## bitmapContains {#bitmapContains}

Введено в: v20.1

Проверяет, содержит ли битовая карта конкретный элемент.

**Синтаксис**

```sql
bitmapContains(bitmap, value)
```

**Аргументы**

- `bitmap` — Битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `value` — Элемент для проверки. [(U)Int8/16/32/64](/sql-reference/data-types/int-uint/) 

**Возвращаемое значение**

Возвращает `1`, если битовая карта содержит указанное значение, в противном случае `0` [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapContains(bitmapBuild([1, 2, 3]), 2) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapHasAll {#bitmapHasAll}

Введено в: v20.1

Проверяет, содержит ли первая битовая карта все установленные биты второй битовой карты.

**Синтаксис**

```sql
bitmapHasAll(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает `1`, если все установленные биты второй битовой карты присутствуют в первой битовой карте, в противном случае `0` [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapHasAll(bitmapBuild([1, 2, 3]), bitmapBuild([2, 3])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapHasAny {#bitmapHasAny}

Введено в: v20.1

Проверяет, содержит ли первая битовая карта любые установленные биты второй битовой карты.

**Синтаксис**

```sql
bitmapHasAny(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает `1`, если любые биты второй битовой карты присутствуют в первой битовой карте, в противном случае `0` [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapHasAny(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapMax {#bitmapMax}

Введено в: v20.1

Возвращает позицию наибольшего установленного бита в битовой карте или `0`, если битовая карта пуста.

**Синтаксис**

```sql
bitmapMax(bitmap)
```

**Аргументы**

- `bitmap` — Битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает позицию наибольшего установленного бита в битовой карте, иначе `0` [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapMax(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```



## bitmapMin {#bitmapMin}

Введено в: v20.1

Возвращает позицию наименьшего установленного бита в битовой карте. Если все биты не установлены, возвращает `UINT32_MAX` (`UINT64_MAX`, если битовая карта содержит более `2^64` бит).

**Синтаксис**

```sql
bitmapMin(bitmap)
```

**Аргументы**

- `bitmap` — Битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает позицию наименьшего установленного бита в битовой карте, или `UINT32_MAX`/`UINT64_MAX` [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapMin(bitmapBuild([3, 5, 2, 6])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```



## bitmapOr {#bitmapOr}

Введено в: v20.1

Вычисляет логическое или (OR) двух битовых карт.

**Синтаксис**

```sql
bitmapOr(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает битовую карту, содержащую установленные биты, присутствующие в любой входной битовой карте [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(bitmapOr(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```



## bitmapOrCardinality {#bitmapOrCardinality}

Введено в: v20.1

Возвращает кардинальность логического или (OR) двух битовых карт.

**Синтаксис**

```sql
bitmapOrCardinality(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает количество установленных битов в объединении двух битовых карт [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapOrCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```



## bitmapSubsetInRange {#bitmapSubsetInRange}

Введено в: v20.1

Возвращает подмножество битовой карты, содержащее только установленные биты в указанном диапазоне [start, end). Использует индексацию, начинающуюся с 1.

**Синтаксис**

```sql
bitmapSubsetInRange(bitmap, start, end)
```

**Аргументы**

- `bitmap` — Битовая карта, из которой нужно извлечь подмножество. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `start` — Начало диапазона (включительно). [`UInt*`](/sql-reference/data-types/int-uint) 
- `end` — Конец диапазона (исключительно). [`UInt*`](/sql-reference/data-types/int-uint) 

**Возвращаемое значение**

Возвращает битовую карту, содержащую только установленные биты в указанном диапазоне [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild([1, 2, 3, 4, 5]), 2, 5)) AS res;
```

```response title=Response
┌─res───────┐
│ [2, 3, 4] │
└───────────┘
```



## bitmapSubsetLimit {#bitmapSubsetLimit}

Введено в: v20.1

Возвращает подмножество битовой карты, начиная с позиции `range_start` с максимумом `cardinality_limit` установленных битов. Использует индексацию, начинающуюся с 1.

**Синтаксис**

```sql
bitmapSubsetLimit(bitmap, range_start, cardinality_limit)
```

**Аргументы**

- `bitmap` — Битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `range_start` — Начало диапазона (включительно). [`UInt32`](/sql-reference/data-types/int-uint) 
- `cardinality_limit` — Максимальная кардинальность подмножества. [`UInt32`](/sql-reference/data-types/int-uint) 

**Возвращаемое значение**

Возвращает битовую карту, содержащую максимум `cardinality_limit` установленных битов, начиная с `range_start` [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild([1, 5, 3, 2, 8]), 3, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [5, 3] │
└────────┘
```



## bitmapToArray {#bitmapToArray}

Введено в: v20.1

Преобразует битовую карту в массив беззнаковых целых чисел. Это противоположно функции [`bitmapBuild`](/sql-reference/functions/bitmap-functions#bitmapBuild).

**Синтаксис**

```sql
bitmapToArray(bitmap)
```

**Аргументы**

- `bitmap` — Битовая карта для преобразования. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает массив беззнаковых целых чисел, содержащихся в битовой карте [`Array(UInt*)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```



## bitmapTransform {#bitmapTransform}

Введено в: v20.1


Изменяет до N бит в битовой карте, заменяя специфические значения битов в `from_array` соответствующими значениями в `to_array`.
    

**Синтаксис**

```sql
bitmapTransform(bitmap, from_array, to_array)
```

**Аргументы**

- `bitmap` — Битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `from_array` — Массив оригинально установленных битов, которые нужно заменить. [`Array(T)`](/sql-reference/data-types/array). 
- `to_array` — Массив новых установленных битов для замены. [`Array(T)`](/sql-reference/data-types/array). 

**Возвращаемое значение**

Возвращает битовую карту с элементами, преобразованными согласно заданному сопоставлению [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(bitmapTransform(bitmapBuild([1, 2, 3, 4, 5]), [2, 4], [20, 40])) AS res;
```

```response title=Response
┌─res───────────────┐
│ [1, 3, 5, 20, 40] │
└───────────────────┘
```



## bitmapXor {#bitmapXor}

Введено в: v20.1

Вычисляет симметрическую разность (XOR) двух битовых карт.

**Синтаксис**

```sql
bitmapXor(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает битовую карту, содержащую установленные биты, присутствующие в любой входной битовой карте, но не в обеих [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(bitmapXor(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res──────────┐
│ [1, 2, 4, 5] │
└──────────────┘
```



## bitmapXorCardinality {#bitmapXorCardinality}

Введено в: v20.1

Возвращает кардинальность XOR (симметрической разности) двух битовых карт.

**Синтаксис**

```sql
bitmapXorCardinality(bitmap1, bitmap2)
```

**Аргументы**

- `bitmap1` — Первая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `bitmap2` — Вторая битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**Возвращаемое значение**

Возвращает количество установленных битов в симметрической разности двух битовых карт [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapXorCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```



## subBitmap {#subBitmap}

Введено в: v21.9

Возвращает подмножество битовой карты, начиная с позиции `offset`. Максимальная кардинальность возвращаемой битовой карты — `cardinality_limit`.

**Синтаксис**

```sql
subBitmap(bitmap, offset, cardinality_limit)
```

**Аргументы**

- `bitmap` — Битовая карта. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 
- `offset` — Количество установленных битов, которые нужно пропустить от начала (нумерация с нуля). [`UInt32`](/sql-reference/data-types/int-uint) 
- `cardinality_limit` — Максимальное число установленных битов, которые нужно включить в подмножество. [`UInt32`](/sql-reference/data-types/int-uint) 

**Возвращаемое значение**

Возвращает битовую карту, содержащую максимум `limit` установленных битов, начиная после пропуска `offset` установленных битов по порядку возрастания [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**Примеры**

**Пример использования**

```sql title=Query
SELECT bitmapToArray(subBitmap(bitmapBuild([1, 2, 3, 4, 5]), 2, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [3, 4] │
└────────┘
```



<!--AUTOGENERATED_END-->
---
description: 'Документация по функциям для поиска в строках'
sidebar_label: 'Поиск в строках'
slug: /sql-reference/functions/string-search-functions
title: 'Функции для поиска в строках'
doc_type: 'reference'
---

# Функции для поиска в строках {#functions-for-searching-in-strings}

Все функции в этом разделе по умолчанию выполняют поиск с учетом регистра. Поиск без учета регистра, как правило, реализован отдельными вариантами функций.

:::note
Поиск без учета регистра следует правилам соответствия строчных и заглавных букв английского языка. Например, заглавная буква `i` в английском языке — это
`I`, тогда как в турецком языке — `İ`, поэтому результаты для языков, отличных от английского, могут быть непредсказуемыми.
:::

Функции в этом разделе также предполагают, что строка, в которой выполняется поиск (в этом разделе называется `haystack`), и искомая строка (называется `needle`) — это текст в однобайтовой кодировке. Если это предположение
нарушается, исключение не генерируется, а результаты не определены. Поиск в строках в кодировке UTF-8, как правило, реализован отдельными вариантами функций.
Аналогично, если используется вариант функции для UTF-8, а входные строки не являются текстом в кодировке UTF-8, исключение не генерируется, а результаты
не определены. Обратите внимание, что автоматическая нормализация Unicode не выполняется, однако вы можете использовать функции
[normalizeUTF8*()](/sql-reference/functions/string-functions#normalizeUTF8NFC) для этой цели.

[Общие строковые функции](string-functions.md) и [функции для замены в строках](string-replace-functions.md) описаны отдельно.

:::note
Документация ниже сгенерирована из системной таблицы `system.functions`.
:::

{/* 
  Содержимое расположенных ниже тегов при сборке фреймворка документации
  заменяется на документацию, сгенерированную на основе system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## countMatches {#countMatches}

Введена в версии v21.1.

Возвращает количество совпадений регулярного выражения в строке.

:::note Version dependent behavior
Поведение этой функции зависит от версии ClickHouse:

* в версиях &lt; v25.6 функция прекращает счёт при первом пустом совпадении, даже если шаблон допускает дальнейшие совпадения;
* в версиях &gt;= 25.6 функция продолжает выполнение при возникновении пустого совпадения. Устаревшее поведение можно восстановить с помощью настройки `count_matches_stop_at_empty_match = true`;
  :::

**Синтаксис**

```sql
countMatches(haystack, pattern)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — шаблон регулярного выражения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество найденных совпадений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт последовательностей цифр**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```

## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

Введена в версии v21.1

Аналог [`countMatches`](#countMatches), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — шаблон регулярного выражения. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество найденных совпадений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт без учёта регистра**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```

## countSubstrings {#countSubstrings}

Добавлена в версии: v21.1

Возвращает, сколько раз подстрока `needle` встречается в строке `haystack`.

**Синтаксис**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [String](../../sql-reference/data-types/string.md) или [Enum](../../sql-reference/data-types/enum.md). - `needle` — подстрока, которую нужно найти. [String](../../sql-reference/data-types/string.md). - `start_pos` — позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [UInt](../../sql-reference/data-types/int-uint.md). Необязательный параметр.

**Возвращаемое значение**

Количество вхождений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**С использованием аргумента start&#95;pos**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```

## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

Впервые появилась в версии: v21.1

Аналог [`countSubstrings`](#countSubstrings), но выполняет подсчёт без учёта регистра.

**Синтаксис**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — искомая подстрока. [`String`](/sql-reference/data-types/string)
* `start_pos` — необязательный параметр. Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает количество вхождений `needle` в `haystack`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**С аргументом start&#95;pos**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```

## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

Введена в версии v21.1

Аналог [`countSubstrings`](#countSubstrings), но выполняет поиск без учета регистра и предполагает, что haystack — это строка в кодировке UTF-8.

**Синтаксис**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — необязательный аргумент. Позиция (начиная с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает количество вхождений `needle` в `haystack`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**С аргументом start&#95;pos**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```

## extract {#extract}

Введена в: v1.1

Извлекает первое совпадение регулярного выражения в строке.
Если &#39;haystack&#39; не соответствует &#39;pattern&#39;, возвращается пустая строка.

Эта функция использует библиотеку регулярных выражений RE2. См. поддерживаемый синтаксис в документации [re2](https://github.com/google/re2/wiki/Syntax).

Если регулярное выражение содержит группы захвата (подшаблоны), функция извлекает совпадение из первой группы захвата.

**Синтаксис**

```sql
extract(haystack, pattern)
```

**Аргументы**

* `haystack` — Строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string)
* `pattern` — Регулярное выражение, как правило содержащее захватывающую группу. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённый фрагмент в виде строки. [`String`](/sql-reference/data-types/string)

**Примеры**

**Извлечение домена из email-адреса**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**Если совпадений нет, возвращает пустую строку**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```

## extractAll {#extractAll}

Добавлено в версии: v1.1

Аналог функции [`extract`](#extract), но возвращает массив всех совпадений регулярного выражения в строке.
Если &#39;haystack&#39; не соответствует регулярному выражению &#39;pattern&#39;, возвращается пустой массив.

Если регулярное выражение содержит захватывающие группы (подшаблоны), функция сопоставляет входную строку с первой захватывающей группой.

**Синтаксис**

```sql
extractAll(haystack, pattern)
```

**Аргументы**

* `haystack` — Строка, из которой нужно извлечь фрагменты. [`String`](/sql-reference/data-types/string)
* `pattern` — Регулярное выражение, при необходимости содержащее группы захвата. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив извлечённых фрагментов. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Извлечение всех чисел**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**Извлечение с использованием захватывающей группы**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```

## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

Добавлено в: v20.5

Находит все группы в строке по указанному регулярному выражению и возвращает массив массивов, где каждый внутренний массив содержит все подстроки, захваченные одной и той же группой, упорядоченные по номеру группы.

**Синтаксис**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**Аргументы**

* `s` — входная строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — регулярное выражение для поиска совпадений. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Возвращает массив массивов, где каждый внутренний массив содержит все захваченные подстроки из одной группы захвата по всем найденным совпадениям. Первый внутренний массив содержит все захваты из группы 1, второй — из группы 2 и т.д. Если совпадения не найдены, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```

## extractGroups {#extractGroups}

Добавлено в: v20.5

Извлекает все группы из непересекающихся подстрок, найденных по регулярному выражению.

**Синтаксис**

```sql
extractAllGroups(s, regexp)
```

**Аргументы**

* `s` — входная строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — регулярное выражение. Константа. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Если функция находит хотя бы одну подходящую группу, она возвращает столбец типа Array(Array(String)), разбитый по group&#95;id (`1` до `N`, где `N` — количество групп захвата в regexp). Если подходящих групп нет, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## hasAllTokens {#hasAllTokens}

Введено в: v25.10

Аналогично [`hasAnyTokens`](#hasAnyTokens), но возвращает 1, если все токены в строке или массиве `needle` совпадают со строкой `input`, и 0 в противном случае. Если `input` — это столбец, возвращает все строки, которые удовлетворяют этому условию.

:::note
Для оптимальной производительности в столбце `input` должен быть определён [текстовый индекс](../../engines/table-engines/mergetree-family/textindexes).
Если текстовый индекс не определён, функция выполняет полное сканирование столбца методом перебора, что на порядки медленнее поиска по индексу.
:::

Перед поиском функция токенизирует

* аргумент `input` (обязательный) и
* аргумент `needle` (если он передан как значение типа [String](../../sql-reference/data-types/string.md))
  обрабатывается с использованием токенизатора, указанного для текстового индекса.
  Если для столбца не определён текстовый индекс, вместо этого используется токенизатор `splitByNonAlpha`.
  Если аргумент `needle` имеет тип [Array(String)](../../sql-reference/data-types/array.md), каждый элемент массива рассматривается как отдельный токен — дополнительная токенизация не выполняется.

Дублирующиеся токены игнорируются.
Например, needles = [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] обрабатывается так же, как и [&#39;ClickHouse&#39;].

**Синтаксис**

```sql
hasAllTokens(input, needles)
```

**Синонимы**: `hasAllToken`

**Аргументы**

* `input` — Входной столбец. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(String)`](/sql-reference/data-types/array) или [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — токены, которые нужно найти. Не более 64 токенов. [`String`](/sql-reference/data-types/string) или [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает 1, если все искомые элементы найдены. В противном случае — 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования для столбца типа String**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Укажите искомые подстроки в массиве КАК ЕСТЬ (без токенизации)**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Генерация искомых значений с помощью функции `tokens`**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Примеры использования для столбцов array и map**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**Пример со столбцом-массивом**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с mapKeys**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```

## hasAnyTokens {#hasAnyTokens}

Добавлена в версии: v25.10

Возвращает 1, если хотя бы один токен в строке или массиве `needle` совпадает со строкой `input`, и 0 в противном случае. Если `input` — это столбец, возвращает все строки, которые удовлетворяют этому условию.

:::note
Для столбца `input` должен быть определён [текстовый индекс](../../engines/table-engines/mergetree-family/textindexes) для оптимальной производительности.
Если текстовый индекс не определён, функция выполняет полное сканирование столбца, что на порядки медленнее, чем поиск по индексу.
:::

Перед поиском функция токенизирует

* аргумент `input` (всегда) и
* аргумент `needle` (если он передан как [String](../../sql-reference/data-types/string.md)),
  используя токенизатор, указанный для текстового индекса.
  Если у столбца не определён текстовый индекс, вместо этого используется токенизатор `splitByNonAlpha`.
  Если аргумент `needle` имеет тип [Array(String)](../../sql-reference/data-types/array.md), каждый элемент массива рассматривается как отдельный токен — дополнительная токенизация не выполняется.

Дубликаты токенов игнорируются.
Например, [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] обрабатывается так же, как [&#39;ClickHouse&#39;].

**Синтаксис**

```sql
hasAnyTokens(input, needles)
```

**Псевдонимы**: `hasAnyToken`

**Аргументы**

* `input` — Входной столбец. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(String)`](/sql-reference/data-types/array) или [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — Токены для поиска. Поддерживается не более чем 64 токена. [`String`](/sql-reference/data-types/string) или [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если было найдено хотя бы одно совпадение, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования для строкового столбца**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Укажите значения для поиска КАК ЕСТЬ (без разбиения на токены) в массиве**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Сгенерируйте подстроки (needles) с помощью функции `tokens`**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Примеры использования столбцов Array и Map**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**Пример со столбцом типа массив**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с mapKeys**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**Пример использования mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

## hasSubsequence {#hasSubsequence}

Введена в версии: v23.7

Проверяет, является ли `needle` подпоследовательностью `haystack`.
Подпоследовательность строки — это последовательность, которую можно получить из другой строки, удалив некоторые (или ни одного) символы, не изменяя порядок оставшихся символов.

**Синтаксис**

```sql
hasSubsequence(haystack, needle)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск подпоследовательности. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если needle является подпоследовательностью haystack, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовая проверка подпоследовательности**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**Подпоследовательность не найдена**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

Добавлена в версии: v23.7

Аналог функции [`hasSubsequence`](#hasSubsequence), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — Подпоследовательность, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если `needle` является подпоследовательностью `haystack`, иначе — 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

Появилась в версии v23.7

Аналог функции [`hasSubsequenceUTF8`](#hasSubsequenceUTF8), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — строка-подпоследовательность в кодировке UTF-8, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если needle является подпоследовательностью строки haystack, иначе — 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```

## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

Введена в версии v23.7

Аналог [`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence), но предполагает, что haystack и needle — строки в кодировке UTF-8.

**Синтаксис**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если `needle` является подпоследовательностью `haystack`, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**Неподходящая подпоследовательность**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```

## hasToken {#hasToken}

Добавлена в: v20.1

Проверяет, присутствует ли заданный токен в строке.

Токен определяется как максимально длинная подпоследовательность подряд идущих символов `[0-9A-Za-z_]`, то есть цифр, ASCII‑букв и символа подчёркивания.

**Синтаксис**

```sql
hasToken(haystack, token)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `token` — Токен, который нужно найти. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если токен найден, и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск токена**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```

## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

Добавлена в версии: v

Выполняет поиск `needle` в `haystack` без учета регистра с использованием индекса tokenbf&#95;v1.

**Синтаксис**

```sql
```

**Аргументы**

* Нет.

**Возвращаемое значение**

**Примеры**

## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

Введена в: v

Выполняет поиск `needle` в `haystack` без учета регистра с использованием индекса tokenbf&#95;v1. Возвращает null, если `needle` некорректно сформирован.

**Синтаксис**

```sql
```

**Аргументы**

* Нет.

**Возвращаемое значение**

**Примеры**

## hasTokenOrNull {#hasTokenOrNull}

Добавлено в: v20.1

Аналог [`hasToken`](#hasToken), но возвращает null, если токен некорректно сформирован.

**Синтаксис**

```sql
hasTokenOrNull(haystack, token)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. Должна быть константой. [`String`](/sql-reference/data-types/string)
* `token` — Токен для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если токен найден, `0` — в противном случае, `NULL`, если токен имеет некорректный формат. [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```

## ilike {#ilike}

Добавлено в: v20.6

Аналог [`like`](#like), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон LIKE, с которым выполняется сопоставление. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону LIKE (без учета регистра), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```

## like {#like}

Появилась в версии v1.1

Возвращает, соответствует ли строка `haystack` выражению `LIKE` `pattern`.

Выражение `LIKE` может содержать обычные символы и следующие метасимволы:

* `%` обозначает произвольное количество произвольных символов (включая ноль символов).
* `_` обозначает один произвольный символ.
* `\` используется для экранирования литералов `%`, `_` и `\`.

Сопоставление основано на UTF-8, например, `_` сопоставляется с кодовой точкой Unicode `¥`, которая в UTF-8 представлена двумя байтами.

Если `haystack` или выражение `LIKE` не являются корректными последовательностями UTF-8, поведение не определено.

Автоматическая нормализация Unicode не выполняется, для этого можно использовать функции `normalizeUTF8*`.

Чтобы сопоставить литеральные `%`, `_` и `\` (которые являются метасимволами `LIKE`), предваряйте их обратным слешем: `\%`, `\_` и `\\`.
Обратный слеш теряет своё специальное значение (т. е. интерпретируется как литерал), если он предваряет символ, отличный от `%`, `_` или `\`.

:::note
ClickHouse требует, чтобы обратные слеши в строках [также экранировались](../syntax.md#string), поэтому фактически нужно писать `\\%`, `\\_` и `\\\\`.
:::

Для выражений `LIKE` вида `%needle%` функция работает так же быстро, как функция `position`.
Все остальные выражения `LIKE` внутренне преобразуются в регулярное выражение и выполняются с производительностью, аналогичной функции `match`.

**Синтаксис**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон `LIKE` для сравнения со строкой. Может содержать `%` (соответствует любому количеству символов), `_` (соответствует одному символу) и `\` для экранирования. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону `LIKE`, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**Односимвольный подстановочный символ**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**Несовпадающий шаблон**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```

## locate {#locate}

Введена в: v18.16

Аналог функции [`position`](#position), но с аргументами `haystack` и `needle`, расположенными в обратном порядке.

:::note Поведение в разных версиях
Поведение этой функции зависит от версии ClickHouse:

* в версиях &lt; v24.3 `locate` была псевдонимом функции `position` и принимала аргументы `(haystack, needle[, start_pos])`;
* в версиях &gt;= 24.3 `locate` является отдельной функцией (для лучшей совместимости с MySQL) и принимает аргументы `(needle, haystack[, start_pos])`.
  Предыдущее поведение можно восстановить с помощью настройки `function_locate_has_mysql_compatible_argument_order = false`.
  :::

**Синтаксис**

```sql
locate(needle, haystack[, start_pos])
```

**Аргументы**

* `needle` — подстрока для поиска. [`String`](/sql-reference/data-types/string)
* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `start_pos` — необязательный параметр. Позиция (счёт с 1) в `haystack`, с которой начинается поиск. [`UInt`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах (нумерация с 1), если подстрока найдена, или `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```

## match {#match}

Введена в версии v1.1

Проверяет, соответствует ли указанная строка заданному шаблону регулярного выражения.

Эта функция использует библиотеку регулярных выражений RE2. Поддерживаемый синтаксис смотрите в документации [re2](https://github.com/google/re2/wiki/Syntax).

Сопоставление выполняется с допущением кодировки UTF-8, например, `¥` внутренне использует два байта, но при сопоставлении рассматривается как одна кодовая точка.
Регулярное выражение не должно содержать NULL-байты.
Если `haystack` или шаблон не являются корректным UTF-8, поведение не определено.

В отличие от поведения по умолчанию в re2, `.` совпадает с символами перевода строки. Чтобы отключить это, добавьте к шаблону префикс `(?-s)`.

Шаблон автоматически считается ограниченным с обеих сторон (как если бы он начинался с `^` и заканчивался `$`).

Если вам нужно находить только подстроки, используйте вместо этого функции [`like`](#like) или [`position`](#position) — они работают значительно быстрее, чем эта функция.

Альтернативный синтаксис оператора: `haystack REGEXP pattern`.

**Синтаксис**

```sql
match(haystack, pattern)
```

**Псевдонимы**: `REGEXP_MATCHES`

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск по шаблону. [`String`](/sql-reference/data-types/string)
* `pattern` — Шаблон регулярного выражения. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону, и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Простое сопоставление с шаблоном**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**Нет совпадения с шаблоном**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```

## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

Добавлено в версии: v20.1

Аналогично [`multiFuzzyMatchAny`](#multiFuzzyMatchAny), но возвращает массив всех индексов в произвольном порядке, значения которых соответствуют haystack в пределах постоянного [редакционного расстояния](https://en.wikipedia.org/wiki/Edit_distance).

**Синтаксис**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — максимальное допустимое расстояние редактирования для нечеткого поиска. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив всех индексов (начиная с 1), для которых строка совпадает с `haystack` в пределах указанного расстояния редактирования, в произвольном порядке. Возвращает пустой массив, если совпадений не найдено. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```

## multiFuzzyMatchAny {#multiFuzzyMatchAny}

Добавлено в: v20.1

Аналог [`multiMatchAny`](#multiMatchAny), но возвращает 1, если любой шаблон совпадает с `haystack` при заданном постоянном [редакционном расстоянии](https://en.wikipedia.org/wiki/Edit_distance).
Эта функция использует экспериментальную функциональность библиотеки [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) и может работать медленно в некоторых крайних случаях.
Производительность зависит от значения редакционного расстояния и используемых шаблонов, но всегда ниже, чем у нефаззи-вариантов.

:::note
Семейство функций `multiFuzzyMatch*()` не поддерживает регулярные выражения в UTF-8 (обрабатывает их как последовательность байт) из-за ограничений hyperscan.
:::

**Синтаксис**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — максимальное расстояние редактирования для нечеткого сопоставления. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — необязательный параметр. Массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если хотя бы один шаблон соответствует `haystack` в пределах заданного расстояния редактирования, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```

## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

Представлена в: v20.1

Аналог [`multiFuzzyMatchAny`](#multiFuzzyMatchAny), но возвращает любой индекс в исходной строке, для которого расстояние редактирования до образца не превышает заданного [редакционного расстояния](https://en.wikipedia.org/wiki/Edit_distance).

**Синтаксис**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — Максимальное редакционное расстояние для нечеткого поиска. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — Массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) любого шаблона, который совпадает с `haystack` в пределах указанного редакционного расстояния, в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```

## multiMatchAllIndices {#multiMatchAllIndices}

Добавлена в версии v20.1

Аналог функции [`multiMatchAny`](#multiMatchAny), но возвращает массив всех индексов, для которых есть совпадение с `haystack` в любом порядке.

**Синтаксис**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — Регулярные выражения для поиска совпадений. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Массив всех индексов (начиная с 1) тех шаблонов, которые дают совпадение с `haystack`, в произвольном порядке. Возвращает пустой массив, если совпадений нет. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```

## multiMatchAny {#multiMatchAny}

Добавлена в: v20.1

Проверяет, соответствует ли хотя бы один из нескольких шаблонов регулярных выражений исходной строке.

Если вам нужно искать только несколько подстрок в строке, вместо этой функции можно использовать функцию [`multiSearchAny`](#multiSearchAny) — она работает гораздо быстрее.

**Синтаксис**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск шаблонов. [`String`](/sql-reference/data-types/string)
* `pattern1[, pattern2, ...]` — Массив из одного или нескольких шаблонов регулярных выражений. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если хотя бы один шаблон совпадает, и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Сопоставление с несколькими шаблонами**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**Ни один шаблон не совпал**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```

## multiMatchAnyIndex {#multiMatchAnyIndex}

Впервые появилась в: v20.1

Аналог [`multiMatchAny`](#multiMatchAny), но возвращает любой индекс совпадения в строке, по которой выполняется поиск.

**Синтаксис**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — регулярные выражения для поиска совпадений. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) первого шаблона, для которого найдено совпадение, или 0, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```

## multiSearchAllPositions {#multiSearchAllPositions}

Добавлена в версии v20.1

Аналог [`position`](#position), но возвращает массив позиций (в байтах, начиная с 1) для нескольких подстрок `needle` в строке `haystack`.

Все функции `multiSearch*()` поддерживают не более 2^8 подстрок `needle`.

**Синтаксис**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — Массив из одной или нескольких подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах (отсчёт с 1), если подстрока была найдена, и `0`, если подстрока не найдена. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Поиск по нескольким подстрокам**

```sql title=Query
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

Добавлена в версии: v20.1

Аналог [`multiSearchAllPositions`](#multiSearchAllPositions), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — Массив из одной или нескольких подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах, считая от 1 (если подстрока найдена), или `0`, если подстрока не найдена. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Множественный поиск без учета регистра**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

Впервые появилась в версии v20.1

Аналог [`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, которые необходимо найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив начальных позиций найденной подстроки (в байтах, нумерация с 1). Возвращает 0, если подстрока не найдена. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Регистронезависимый поиск в UTF-8**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```

## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

Добавлена в: v20.1

Аналог [`multiSearchAllPositions`](#multiSearchAllPositions), но предполагает, что `haystack` и подстроки `needle` — это строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив подстрок в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций подстрок в байтах (отсчёт с 1, если подстрока найдена) или `0`, если подстрока не найдена. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Поиск нескольких подстрок в UTF-8**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```

## multiSearchAny {#multiSearchAny}

Впервые представлена в: v20.1

Проверяет, совпадает ли хотя бы одна из нескольких строк-шаблонов с исходной строкой.

Функции [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive), [`multiSearchAnyUTF8`](#multiSearchAnyUTF8) и [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) предоставляют варианты этой функции с поддержкой регистронезависимого поиска и/или UTF-8.

**Синтаксис**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение, иначе `0`, если не найдено ни одного совпадения. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск любого совпадения**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

Впервые появилась в версии v20.1

Аналог функции [multiSearchAny](#multiSearchAny), но без учета регистра.

**Синтаксис**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки, которые необходимо найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение без учета регистра, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учета регистра**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

Добавлена в: v20.1

Аналогична [multiSearchAnyUTF8](#multiSearchAnyUTF8), но не учитывает регистр.

**Синтаксис**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение без учета регистра, иначе — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Для строки UTF-8 &#39;Здравствуйте&#39; проверьте, содержится ли символ &#39;з&#39; (в нижнем регистре)**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

Добавлена в: v20.1

Аналог [multiSearchAny](#multiSearchAny), но предполагает, что `haystack` и подстроки `needle` являются строками в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение, иначе `0`, если совпадений нет. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Для строки в кодировке UTF-8 &#39;你好，世界&#39; (&#39;Hello, world&#39;) проверьте, есть ли в строке символы 你 или 界**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndex {#multiSearchFirstIndex}

Впервые появилась в: v20.1

Выполняет поиск нескольких подстрок в исходной строке (с учётом регистра) и возвращает индекс (нумерация с 1) первой найденной подстроки.

**Синтаксис**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needles` — Массив строк для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс, начинающийся с 1 (позицию в массиве `needles`) первой строки из `needles`, найденной в `haystack`. Возвращает 0, если ни одна из строк из `needles` не найдена. Поиск чувствителен к регистру. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**Поведение с учетом регистра**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**Совпадения не найдены**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

Добавлено в: v20.1

Возвращает индекс `i` (начиная с 1) шаблона needle&#95;i, который расположен левее всех остальных найденных в строке `haystack`, или 0, если ни один шаблон не найден.
Игнорирует регистр.

**Синтаксис**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — Подстроки, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) самой левой найденной подстроки `needle`. В противном случае — `0`, если совпадение не найдено. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

Впервые представлена в: v20.1

Выполняет поиск нескольких подстрок в строке-источнике без учета регистра с поддержкой кодировки UTF-8 и возвращает индекс (отсчет с 1) первой найденной подстроки.

**Синтаксис**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needles` — массив строк, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс, начинающийся с 1 (позицию в массиве `needles`) первой строки из `needles`, найденной в `haystack`. Возвращает 0, если ни одна из строк не найдена. Поиск регистронезависимый и учитывает кодировку символов UTF-8. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**Учёт регистра в UTF-8**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**Совпадений не найдено**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

Добавлена в версии v20.1

Возвращает индекс `i` (начиная с 1) самой левой найденной `needle&#95;i` в строке `haystack` или 0, если совпадение не найдено.
Предполагается, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в кодировке UTF-8, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) самой левой из найденных подстрок. В противном случае — 0, если совпадений не было. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstPosition {#multiSearchFirstPosition}

Впервые представлена в: v20.1

Аналог функции [`position`](#position), но возвращает самое левое смещение в строке `haystack`, в котором совпадает хотя бы одна из нескольких строк `needle`.

Функции [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive), [`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8) и [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) предоставляют варианты этой функции, нечувствительные к регистру и/или поддерживающие UTF-8.

**Синтаксис**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив из одной или нескольких подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает наименьшее смещение (считая слева) в строке `haystack`, с которого начинается совпадение с любой из подстрок `needle`; в противном случае — `0`, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск первой позиции**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

Добавлена в версии: v20.1

Аналог [multiSearchFirstPosition](#multiSearchFirstPosition), но без учёта регистра.

**Синтаксис**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает смещение от начала строки `haystack`, на котором обнаружено первое вхождение любой из подстрок массива `needle`. Возвращает `0`, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Первая позиция без учета регистра**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

Добавлена в версии: v20.1

Аналогична [multiSearchFirstPosition](#multiSearchFirstPosition), но предполагает, что `haystack` и `needle` — строки в кодировке UTF-8 и регистр символов не учитывается.

**Синтаксис**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в кодировке UTF-8, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает смещение самого левого вхождения в строке `haystack`, которое совпадает с любой из строк `needle`, без учета регистра. Возвращает `0`, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Найти смещение самого левого вхождения в строке UTF-8 &#39;Здравствуй, мир&#39; (&#39;Hello, world&#39;), которое совпадает с любой из заданных подстрок**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

Добавлена в: v20.1

Аналог [multiSearchFirstPosition](#multiSearchFirstPosition), но предполагает, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Смещение самого левого вхождения в строке `haystack`, которое совпадает с любой из строк `needle`. Возвращает `0`, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Найти смещение самого левого вхождения в строке UTF-8 &#39;Здравствуй, мир&#39; (&#39;Hello, world&#39;), которое совпадает с любой из заданных подстрок**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```

## ngramDistance {#ngramDistance}

Впервые добавлена в: v20.1

Вычисляет 4-граммное расстояние между двумя строками.
Для этого считает симметрическую разность между двумя мультимножествами 4-грамм и нормализует её, деля на сумму их мощностей.
Чем меньше возвращаемое значение, тем более похожи строки.

Для поиска без учёта регистра и/или в формате UTF8 используйте функции [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive), [`ngramDistanceUTF8`](#ngramDistanceUTF8), [`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8).

**Синтаксис**

```sql
ngramDistance(haystack, needle)
```

**Аргументы**

* `haystack` — строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. Чем меньше значение, тем более похожи строки. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Вычисление расстояния по 4-граммам**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

Появилась в версии: v20.1

Предоставляет регистронезависимый вариант [`ngramDistance`](#ngramDistance).
Вычисляет расстояние по 4-граммам между двумя строками, игнорируя регистр.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — первая сравниваемая строка. [`String`](/sql-reference/data-types/string)
* `needle` — вторая сравниваемая строка. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Регистронезависимое расстояние на основе 4-грамм**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

Добавлено в версии: v20.1

Предоставляет регистронезависимый UTF-8‑вариант функции [`ngramDistance`](#ngramDistance).
Предполагает, что строки `needle` и `haystack` закодированы в UTF‑8, и игнорирует регистр.
Вычисляет расстояние 3‑грамм между двумя строками UTF‑8, игнорируя регистр.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — первая строка для сравнения в кодировке UTF-8. [`String`](/sql-reference/data-types/string)
* `needle` — вторая строка для сравнения в кодировке UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Регистронезависимое расстояние по 3-граммам для строк в UTF-8**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```

## ngramDistanceUTF8 {#ngramDistanceUTF8}

Введена в версии: v20.1

Предоставляет UTF-8-вариант функции [`ngramDistance`](#ngramDistance).
Предполагается, что строки `needle` и `haystack` закодированы в UTF-8.
Вычисляет расстояние по 3-граммам между двумя строками в UTF-8.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — первая строка для сравнения в кодировке UTF-8. [`String`](/sql-reference/data-types/string)
* `needle` — вторая строка для сравнения в кодировке UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Расстояние по 3-граммам UTF-8**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```

## ngramSearch {#ngramSearch}

Введена в версии v20.1

Проверяет, что 4-граммное расстояние между двумя строками меньше или равно заданному порогу.

Для поиска без учета регистра и/или в формате UTF-8 используйте функции `ngramSearchCaseInsensitive`, `ngramSearchUTF8`, `ngramSearchCaseInsensitiveUTF8`.

**Синтаксис**

```sql
ngramSearch(haystack, needle)
```

**Аргументы**

* `haystack` — строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если 4-граммное расстояние между строками меньше или равно пороговому значению (`1.0` по умолчанию), в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск с использованием 4-грамм**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```

## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

Впервые появилась в: v20.1

Предоставляет регистронезависимый вариант [`ngramSearch`](#ngramSearch).
Вычисляет несимметричную разность между строкой-образцом (needle) и строкой, в которой выполняется поиск (haystack), то есть количество n-грамм из образца минус количество общих n-грамм, нормированное по количеству n-грамм в образце.
Проверяет, что расстояние по 4-граммам между двумя строками меньше либо равно заданному порогу, игнорируя регистр.

**Синтаксис**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — Строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — Строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если 4-граммное расстояние между строками меньше либо равно порогу (`1.0` по умолчанию), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учета регистра с использованием 4-грамм**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

Добавлена в версии: v20.1

Предоставляет регистронезависимый вариант функции [`ngramSearch`](#ngramSearch) для строк в кодировке UTF-8.
Предполагает, что `haystack` и `needle` являются строками в кодировке UTF-8, и игнорирует регистр.
Проверяет, что расстояние по 3-граммам между двумя строками UTF-8 не превышает заданный порог, игнорируя регистр.

**Синтаксис**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если 3-граммное расстояние между строками меньше или равно порогу (`1.0` по умолчанию), в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск в UTF-8 без учёта регистра с использованием 3-грамм**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```

## ngramSearchUTF8 {#ngramSearchUTF8}

Введена в версии v20.1

Предоставляет вариант функции `ngramSearch` для строк в кодировке UTF-8.
Предполагается, что `haystack` и `needle` являются строками в кодировке UTF-8.
Проверяет, что 3-граммное расстояние между двумя строками UTF-8 меньше или равно заданному порогу.

**Синтаксис**

```sql
ngramSearchUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 3-граммам между строками меньше или равно пороговому значению (по умолчанию `1.0`), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск по строкам UTF-8 с использованием 3-грамм**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```

## notILike {#notILike}

Введена в версии v20.6

Проверяет, что строка не соответствует шаблону без учёта регистра. Шаблон может содержать специальные символы `%` и `_` для сопоставления в стиле SQL LIKE.

**Синтаксис**

```sql
notILike(haystack, pattern)
```

**Аргументы**

* `haystack` — входная строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон для оператора SQL LIKE. Символ `%` соответствует любому количеству символов (включая ноль), `_` — ровно одному символу. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка не соответствует шаблону (без учета регистра), в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```

## notLike {#notLike}

Введена в: v1.1

Аналог [`like`](#like), но с инвертированным результатом.

**Синтаксис**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон `LIKE` для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка не соответствует шаблону `LIKE`, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**Отсутствие совпадения с шаблоном**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```

## position {#position}

Введена в: v1.1

Возвращает позицию (в байтах, начиная с 1) подстроки `needle` в строке `haystack`.

Если подстрока `needle` пуста, применяются следующие правила:

* если `start_pos` не указан: вернуть `1`
* если `start_pos = 0`: вернуть `1`
* если `start_pos >= 1` и `start_pos <= length(haystack) + 1`: вернуть `start_pos`
* иначе: вернуть `0`

Те же правила применяются к функциям [`locate`](#locate), [`positionCaseInsensitive`](#positionCaseInsensitive), [`positionUTF8`](#positionUTF8) и [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8).

**Синтаксис**

```sql
position(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Искомая подстрока. [`String`](/sql-reference/data-types/string)
* `start_pos` — Позиция (начиная с 1) в `haystack`, с которой начинается поиск. Необязательный параметр. [`UInt`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах (отсчёт с 1), если подстрока найдена, в противном случае `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**С аргументом start&#95;pos**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Синтаксис needle IN haystack**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**Пустая подстрока-образец**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```

## positionCaseInsensitive {#positionCaseInsensitive}

Добавлена в версии v1.1

Как [`position`](#position), но без учета регистра.

**Синтаксис**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**Псевдонимы**: `instr`

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Искомая подстрока. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный параметр. Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах (нумерация с 1), если подстрока найдена, в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учета регистра**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```

## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

Добавлена в версии v1.1

Аналог функции [`positionUTF8`](#positionUTF8), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный параметр. Позиция (начиная с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах, считая с 1, если подстрока найдена, в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск в UTF-8 без учёта регистра**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```

## positionUTF8 {#positionUTF8}

Добавлена в: v1.1

Аналог функции [`position`](#position), но предполагается, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока для поиска. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный параметр. Позиция (счёт начинается с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах, считая с 1, если подстрока была найдена; в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт символов в UTF-8**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

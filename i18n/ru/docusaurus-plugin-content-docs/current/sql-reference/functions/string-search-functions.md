---
description: 'Документация по функциям поиска по строкам'
sidebar_label: 'Поиск по строкам'
slug: /sql-reference/functions/string-search-functions
title: 'Функции поиска по строкам'
doc_type: 'reference'
---

# Функции для поиска в строках {#functions-for-searching-in-strings}

Все функции в этом разделе по умолчанию выполняют поиск с учётом регистра. Поиск без учёта регистра обычно реализован в отдельных вариантах функций.

:::note
Поиск без учёта регистра следует правилам соответствия строчных и прописных букв английского языка. Например, прописная буква для `i` в английском языке — это
`I`, тогда как в турецком языке — `İ`, поэтому результаты для языков, отличных от английского, могут быть неожиданными.
:::

Функции в этом разделе также предполагают, что строка, в которой выполняется поиск (в этом разделе обозначается как `haystack`), и строка поиска (обозначается как `needle`) являются текстом в однобайтной кодировке. Если это предположение
не выполняется, исключение не генерируется, а результаты не определены. Поиск в строках в кодировке UTF-8 обычно реализован в отдельных
вариантах функций. Аналогично, если используется вариант функции для UTF-8, а входные строки не являются текстом в кодировке UTF-8, исключение не генерируется, а
результаты не определены. Учтите, что автоматическая нормализация Unicode не выполняется, однако вы можете использовать функции
[normalizeUTF8*()](https://clickhouse.com../functions/string-functions/) для этого.

[Общие строковые функции](string-functions.md) и [функции для замены в строках](string-replace-functions.md) описаны отдельно.

:::note
Документация ниже сгенерирована из системной таблицы `system.functions`.
:::

{/* 
  Содержимое тегов ниже при сборке фреймворка документации
  заменяется документами, сгенерированными из system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## countMatches {#countMatches}

Введена в версии: v21.1

Возвращает количество вхождений регулярного выражения в строке.

:::note Зависимость поведения от версии
Поведение этой функции зависит от версии ClickHouse:

* в версиях &lt; v25.6 функция прекращает подсчёт при первом пустом совпадении, даже если шаблон допускает дальнейшие совпадения.
* в версиях &gt;= 25.6 функция продолжает выполнение при возникновении пустого совпадения. Устаревшее поведение можно восстановить с помощью настройки `count_matches_stop_at_empty_match = true`.
  :::

**Синтаксис**

```sql
countMatches(haystack, pattern)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — Шаблон регулярного выражения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество найденных совпадений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт последовательностей цифр**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```

## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

Добавлена в: v21.1

Аналог [`countMatches`](#countMatches), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — Шаблон регулярного выражения. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество найденных совпадений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчет без учета регистра**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```

## countSubstrings {#countSubstrings}

Впервые появилась в версии v21.1

Возвращает количество вхождений подстроки `needle` в строку `haystack`.

**Синтаксис**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [String](../../sql-reference/data-types/string.md) или [Enum](../../sql-reference/data-types/enum.md). - `needle` — Подстрока для поиска. [String](../../sql-reference/data-types/string.md). - `start_pos` — Позиция (отсчёт с 1) в `haystack`, с которой начинается поиск. [UInt](../../sql-reference/data-types/int-uint.md). Необязательный.

**Возвращаемое значение**

Количество вхождений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**С аргументом start&#95;pos**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```

## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

Добавлена в версии: v21.1

Аналог [`countSubstrings`](#countSubstrings), но выполняет подсчёт без учёта регистра.

**Синтаксис**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — необязательный аргумент. Позиция (начиная с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает количество вхождений `needle` в `haystack`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**С параметром start&#95;pos**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```

## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

Добавлена в: v21.1

Аналог [`countSubstrings`](#countSubstrings), но считает подстроки без учета регистра и предполагает, что haystack — строка в кодировке UTF-8.

**Синтаксис**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — необязательный параметр. Позиция (начиная с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает количество вхождений подстроки `needle` в строку `haystack`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**С аргументом start&#95;pos**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```

## extract {#extract}

Добавлена в версии: v1.1

Извлекает первое совпадение регулярного выражения в строке.
Если &#39;haystack&#39; не соответствует &#39;pattern&#39;, возвращается пустая строка.

Эта функция использует библиотеку регулярных выражений RE2. См. [re2](https://github.com/google/re2/wiki/Syntax) для описания поддерживаемого синтаксиса.

Если регулярное выражение содержит группы захвата (подшаблоны), функция возвращает содержимое первой группы захвата.

**Синтаксис**

```sql
extract(haystack, pattern)
```

**Аргументы**

* `haystack` — Строка, из которой извлекается значение. [`String`](/sql-reference/data-types/string)
* `pattern` — Регулярное выражение, обычно содержащее захватывающую группу. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённый фрагмент в виде строки. [`String`](/sql-reference/data-types/string)

**Примеры**

**Извлечение домена из email-адреса**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**Если совпадение не найдено, возвращается пустая строка**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```

## extractAll {#extractAll}

Добавлена в версии: v1.1

Аналогична [`extract`](#extract), но возвращает массив всех вхождений регулярного выражения в строке.
Если в строке `haystack` нет совпадений с регулярным выражением `pattern`, возвращается пустой массив.

Если регулярное выражение содержит группы захвата (подвыражения), функция сопоставляет входную строку по первой группе захвата.

**Синтаксис**

```sql
extractAll(haystack, pattern)
```

**Аргументы**

* `haystack` — строка, из которой извлекаются фрагменты. [`String`](/sql-reference/data-types/string)
* `pattern` — регулярное выражение, которое может содержать группы захвата. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив извлечённых фрагментов. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Извлечение всех чисел**

```sql title=Query
SELECT extractAll('привет 123 мир 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**Извлечение с помощью группы захвата**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```

## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

Добавлено в: v20.5

Находит все группы в строке с использованием переданного регулярного выражения и возвращает массив массивов, где каждый внутренний массив содержит все фрагменты, захваченные одной и той же группой, упорядоченные по номеру группы.

**Синтаксис**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**Аргументы**

* `s` — Входная строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — Регулярное выражение для сопоставления. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Возвращает массив массивов, где каждый внутренний массив содержит все захваченные подвыражения одной группы захвата по всем совпадениям. Первый внутренний массив содержит все значения, захваченные группой 1, второй — группой 2 и т. д. Если совпадения не найдены, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```

## extractGroups {#extractGroups}

Впервые представлена в: v20.5

Извлекает все группы из непересекающихся подстрок, соответствующих регулярному выражению.

**Синтаксис**

```sql
extractAllGroups(s, regexp)
```

**Аргументы**

* `s` — Входная строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — Регулярное выражение. Константное значение. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Если функция находит хотя бы одну совпадающую группу, она возвращает столбец типа Array(Array(String)), упорядоченный по group&#95;id (от `1` до `N`, где `N` — количество захватывающих групп в регулярном выражении). Если совпадающих групп нет, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## hasAllTokens {#hasAllTokens}

Введена в: v25.10

Аналогично [`hasAnyTokens`](#hasAnyTokens), но возвращает 1, если все токены в строке или массиве `needle` присутствуют в строке `input`, и 0 в противном случае. Если `input` — это столбец, возвращает все строки, удовлетворяющие этому условию.

:::note
Для столбца `input` должен быть определён [текстовый индекс](../../engines/table-engines/mergetree-family/invertedindexes) для обеспечения оптимальной производительности.
Если текстовый индекс не определён, функция выполняет полное сканирование столбца, которое на несколько порядков медленнее, чем поиск по индексу.
:::

Перед поиском функция выполняет токенизацию

* аргумента `input` (всегда) и
* аргумента `needle` (если он задан как [String](../../sql-reference/data-types/string.md))
  с использованием токенизатора, указанного для текстового индекса.
  Если для столбца не определён текстовый индекс, вместо него используется токенизатор `splitByNonAlpha`.
  Если аргумент `needle` имеет тип [Array(String)](../../sql-reference/data-types/array.md), каждый элемент массива рассматривается как отдельный токен — дополнительная токенизация не выполняется.

Дубликаты токенов игнорируются.
Например, needles = [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] обрабатывается так же, как [&#39;ClickHouse&#39;].

**Синтаксис**

```sql
hasAllTokens(input, needles)
```

**Псевдонимы**: `hasAllToken`

**Аргументы**

* `input` — входной столбец. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(String)`](/sql-reference/data-types/array) или [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — токены для поиска. Поддерживается не более 64 токенов. [`String`](/sql-reference/data-types/string) или [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает 1, если найдены все токены. В противном случае — 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования для строкового столбца**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Укажите подстроки для поиска по точному совпадению (без токенизации) в массиве**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Сгенерируйте подстроки с помощью функции `tokens`**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Примеры использования столбцов типов Array и Map**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**Пример со столбцом типа массив**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример использования mapKeys**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```

## hasAnyTokens {#hasAnyTokens}

Добавлена в: v25.10

Возвращает 1, если хотя бы один токен в строке или массиве `needle` совпадает со строкой `input`, и 0 в противном случае. Если `input` — это столбец, возвращает все строки, которые удовлетворяют этому условию.

:::note
Для столбца `input` должен быть определён [текстовый индекс](../../engines/table-engines/mergetree-family/invertedindexes) для оптимальной производительности.
Если текстовый индекс не определён, функция выполняет полное сканирование столбца (brute-force), которое на порядки медленнее поиска по индексу.
:::

Перед поиском функция выполняет токенизацию:

* аргумента `input` (всегда) и
* аргумента `needle` (если он задан как тип [String](../../sql-reference/data-types/string.md))
  с использованием токенизатора, указанного для текстового индекса.
  Если для столбца не определён текстовый индекс, вместо этого используется токенизатор `splitByNonAlpha`.
  Если аргумент `needle` имеет тип [Array(String)](../../sql-reference/data-types/array.md), каждый элемент массива рассматривается как отдельный токен — дополнительная токенизация не выполняется.

Дубликаты токенов игнорируются.
Например, [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] обрабатывается так же, как [&#39;ClickHouse&#39;].

**Синтаксис**

```sql
hasAnyTokens(input, needles)
```

**Псевдонимы**: `hasAnyToken`

**Аргументы**

* `input` — Входной столбец. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(String)`](/sql-reference/data-types/array) или [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — Токены для поиска. Поддерживается не более 64 токенов. [`String`](/sql-reference/data-types/string) или [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования для строкового столбца**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Указать значения для поиска в неизменном виде (без токенизации) в массиве**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Сгенерируйте искомые строки с помощью функции `tokens`**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Примеры использования столбцов с типами Array и Map**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**Пример со столбцом типа массив**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с mapKeys**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**Пример использования mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

## hasSubsequence {#hasSubsequence}

Введена в версии v23.7

Проверяет, является ли `needle` подпоследовательностью `haystack`.
Подпоследовательность строки — это последовательность, которую можно получить из другой строки, удалив некоторые символы или ни одного, не меняя порядок оставшихся символов.

**Синтаксис**

```sql
hasSubsequence(haystack, needle)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск подпоследовательности. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если needle является подпоследовательностью haystack, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовая проверка подпоследовательности**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**Подпоследовательность не найдена**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

Добавлено в версии: v23.7

Аналог [`hasSubsequence`](#hasSubsequence), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность, которую необходимо найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если `needle` является подпоследовательностью `haystack`, в противном случае — 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

Добавлена в версии v23.7

Аналог функции [`hasSubsequenceUTF8`](#hasSubsequenceUTF8), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность в строке в кодировке UTF-8, которую требуется найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если `needle` является подпоследовательностью `haystack`, иначе 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```

## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

Добавлена в версии: v23.7

Аналог функции [`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence), но предполагает, что и исходная строка, и образец закодированы в UTF-8.

**Синтаксис**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если `needle` является подпоследовательностью `haystack`, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**Несовпадающая подпоследовательность**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```

## hasToken {#hasToken}

Появилась в версии: v20.1

Проверяет, присутствует ли указанный токен в строке (haystack).

Токен определяется как максимально возможная последовательность идущих подряд символов `[0-9A-Za-z_]`, то есть цифр, ASCII‑букв и символа подчёркивания.

**Синтаксис**

```sql
hasToken(haystack, token)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `token` — Искомый токен. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если токен найден, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск токена**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```

## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

Впервые появилась в: v

Выполняет регистронезависимый поиск значения needle в haystack с использованием индекса tokenbf&#95;v1.

**Синтаксис**

```sql
```

**Аргументы**

* Нет.

**Возвращаемое значение**

**Примеры**

## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

Введена в версии: v

Выполняет поиск подстроки в строке без учета регистра с использованием индекса tokenbf&#95;v1. Возвращает null, если подстрока имеет некорректный формат.

**Синтаксис**

```sql
```

**Аргументы**

* Нет аргументов.

**Возвращаемое значение**

**Примеры**

## hasTokenOrNull {#hasTokenOrNull}

Появилась в версии: v20.1

Аналог функции [`hasToken`](#hasToken), но возвращает null, если токен имеет некорректный формат.

**Синтаксис**

```sql
hasTokenOrNull(haystack, token)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. Должна быть константой. [`String`](/sql-reference/data-types/string)
* `token` — токен для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если токен найден, `0` — в противном случае, и `null`, если токен имеет неверный формат. [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```

## ilike {#ilike}

Добавлено в: v20.6

Аналог [`like`](#like), но выполняет поиск независимо от регистра.

**Синтаксис**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон LIKE для сопоставления. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону LIKE (без учета регистра), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```

## like {#like}

Введена в версии: v1.1

Возвращает, соответствует ли строка `haystack` выражению `LIKE` `pattern`.

Выражение `LIKE` может содержать обычные символы и следующие метасимволы:

* `%` обозначает произвольное количество произвольных символов (включая ноль символов).
* `_` обозначает один произвольный символ.
* `\` используется для экранирования литералов `%`, `_` и `\`.

Сопоставление выполняется по правилам UTF-8, например `_` соответствует символу Unicode `¥`, который в UTF-8 представлен двумя байтами.

Если `haystack` или выражение `LIKE` не являются корректной строкой UTF-8, поведение не определено.

Автоматическая нормализация Unicode не выполняется, для этого можно использовать функции `normalizeUTF8*`.

Чтобы сопоставить литеральные `%`, `_` и `\` (которые являются метасимволами `LIKE`), добавьте перед ними обратную косую черту: `\%`, `\_` и `\\`.
Обратная косая черта теряет своё специальное значение (то есть интерпретируется буквально), если она предшествует символу, отличному от `%`, `_` или `\`.

:::note
ClickHouse также требует [экранировать обратные косые черты в строках](../syntax.md#string), поэтому на практике нужно писать `\\%`, `\\_` и `\\\\`.
:::

Для выражений `LIKE` вида `%needle%` функция работает так же быстро, как функция `position`.
Все остальные выражения `LIKE` внутренне преобразуются в регулярное выражение и выполняются с производительностью, сопоставимой с функцией `match`.

**Синтаксис**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон для оператора `LIKE`. Может содержать `%` (совпадает с любым количеством символов), `_` (совпадает с одним символом) и `\` для экранирования. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону `LIKE`, иначе — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**Подстановочный символ для одного символа**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**Несоответствующий шаблон**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```

## locate {#locate}

Впервые появилась в версии v18.16

Аналог функции [`position`](#position), но с аргументами `haystack` и `locate` в обратном порядке.

:::note Поведение зависит от версии
Поведение этой функции зависит от версии ClickHouse:

* в версиях &lt; v24.3 `locate` была псевдонимом функции `position` и принимала аргументы `(haystack, needle[, start_pos])`;
* в версиях &gt;= 24.3 `locate` является самостоятельной функцией (для лучшей совместимости с MySQL) и принимает аргументы `(needle, haystack[, start_pos])`.
  Предыдущее поведение можно восстановить, используя параметр настройки `function_locate_has_mysql_compatible_argument_order = false`.
  :::

**Синтаксис**

```sql
locate(needle, haystack[, start_pos])
```

**Аргументы**

* `needle` — подстрока для поиска. [`String`](/sql-reference/data-types/string)
* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `start_pos` — необязательный параметр. Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [`UInt`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах, считая с 1, если подстрока найдена, и `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```

## match {#match}

Добавлено в версии: v1.1

Проверяет, соответствует ли переданная строка указанному шаблону регулярного выражения.

Эта функция использует библиотеку регулярных выражений RE2. Обратитесь к [re2](https://github.com/google/re2/wiki/Syntax) для получения сведений о поддерживаемом синтаксисе.

Сопоставление исходит из предположения, что данные находятся в кодировке UTF-8, например, `¥` внутренне использует два байта, но при сопоставлении рассматривается как один кодпоинт.
Регулярное выражение не должно содержать байтов NULL.
Если строка (haystack) или шаблон не являются корректным UTF-8, поведение не определено.

В отличие от поведения по умолчанию в re2, `.` также сопоставляется с символами перевода строки. Чтобы отключить это, добавьте к шаблону префикс `(?-s)`.

Шаблон автоматически якорится с обеих сторон (как если бы шаблон начинался с `^` и заканчивался `$`).

Если вам нужно только искать подстроки, вместо этого вы можете использовать функции [`like`](#like) или [`position`](#position) — они работают значительно быстрее, чем эта функция.

Альтернативный синтаксис оператора: `haystack REGEXP pattern`.

**Синтаксис**

```sql
match(haystack, pattern)
```

**Псевдонимы**: `REGEXP_MATCHES`

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск по шаблону. [`String`](/sql-reference/data-types/string)
* `pattern` — Шаблон регулярного выражения. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если найдено совпадение с шаблоном, и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое сопоставление с шаблоном**

```sql title=Query
SELECT match('Привет, мир', 'Привет.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**Несовпадение шаблона**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```

## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

Введена в: v20.1

Аналог [`multiFuzzyMatchAny`](#multiFuzzyMatchAny), но возвращает массив всех индексов в произвольном порядке, элементы которых соответствуют набору строк (haystack) при фиксированном [редакционном расстоянии](https://en.wikipedia.org/wiki/Edit_distance).

**Синтаксис**

```sql
multiFuzzyMatchAllIndices(искатель, расстояние, [шаблон1, шаблон2, ..., шаблонN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — максимальное расстояние редактирования для нечеткого поиска. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив всех индексов (начиная с 1), которые соответствуют строке `haystack` в пределах указанного расстояния редактирования, в любом порядке. Возвращает пустой массив, если соответствия не найдены. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```

## multiFuzzyMatchAny {#multiFuzzyMatchAny}

Впервые появилась в: v20.1

Аналог функции [`multiMatchAny`](#multiMatchAny), но возвращает 1, если любой из шаблонов совпадает со строкой с учётом заданного [редакционного расстояния](https://en.wikipedia.org/wiki/Edit_distance).
Эта функция использует экспериментальную возможность библиотеки [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) и может работать медленно в некоторых крайних случаях.
Производительность зависит от значения редакционного расстояния и используемых шаблонов, но всегда ниже по сравнению с вариантами без неточного сопоставления.

:::note
Семейство функций `multiFuzzyMatch*()` не поддерживает регулярные выражения в кодировке UTF-8 (они рассматриваются как последовательность байт) из-за ограничений hyperscan.
:::

**Синтаксис**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — Максимальное редакционное расстояние для нечеткого поиска. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — Необязательный параметр. Массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если хотя бы один шаблон совпадает со строкой `haystack` в пределах заданного редакционного расстояния, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```

## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

Добавлена в: v20.1

Аналог функции [`multiFuzzyMatchAny`](#multiFuzzyMatchAny), но возвращает любой индекс, для которого строка соответствует строке поиска при фиксированном [редакционном расстоянии](https://en.wikipedia.org/wiki/Edit_distance).

**Синтаксис**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — Максимальное редакционное расстояние для нечеткого сопоставления. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — Массив шаблонов для поиска соответствий. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) любого шаблона, который соответствует `haystack` в пределах заданного редакционного расстояния, в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```

## multiMatchAllIndices {#multiMatchAllIndices}

Добавлена в версии: v20.1

Аналог [`multiMatchAny`](#multiMatchAny), но возвращает массив всех индексов, соответствующих элементам `haystack` в любом порядке.

**Синтаксис**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — Регулярное выражение для поиска совпадений. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Массив всех индексов (начиная с 1), в которых в `haystack` найдено совпадение с шаблоном, в произвольном порядке. Возвращает пустой массив, если совпадений не найдено. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```

## multiMatchAny {#multiMatchAny}

Введена в версии: v20.1

Проверяет, соответствует ли хотя бы один из нескольких шаблонов регулярных выражений исходной строке.

Если вам нужно только искать несколько подстрок в строке, вместо этой функции вы можете использовать [`multiSearchAny`](#multiSearchAny) — она работает гораздо быстрее.

**Синтаксис**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск шаблонов. [`String`](/sql-reference/data-types/string)
* `pattern1[, pattern2, ...]` — массив, содержащий один или несколько шаблонов регулярных выражений. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если хотя бы один шаблон совпал, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Сопоставление с несколькими шаблонами**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**Нет подходящих шаблонов**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```

## multiMatchAnyIndex {#multiMatchAnyIndex}

Появилась в версии: v20.1

Аналог [`multiMatchAny`](#multiMatchAny), но возвращает любой индекс, соответствующий строке, в которой осуществляется поиск.

**Синтаксис**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — регулярные выражения для поиска совпадений. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) первого шаблона, для которого найдено совпадение, или 0, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```

## multiSearchAllPositions {#multiSearchAllPositions}

Введена в версии v20.1

Аналог функции [`position`](#position), но возвращает массив позиций (в байтах, начиная с 1) для нескольких подстрок `needle` в строке `haystack`.

Все функции `multiSearch*()` поддерживают не более 2^8 подстрок `needle`.

**Синтаксис**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — Массив из одной или нескольких подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах, считая с 1, если подстрока найдена, и `0`, если подстрока не найдена. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Поиск по нескольким подстрокам**

```sql title=Query
SELECT multiSearchAllPositions('Привет, мир!', ['привет', '!', 'мир'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

Введена в версии: v20.1

Аналог [`multiSearchAllPositions`](#multiSearchAllPositions), но игнорирует регистр.

**Синтаксис**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — Массив одной или нескольких подстрок, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций подстроки в байтах с нумерацией от 1 (если подстрока найдена) или `0`, если подстрока не найдена. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Регистронезависимый множественный поиск**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

Добавлена в: v20.1

Аналог [`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8), но игнорирует регистр.

**Синтаксис**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(строка, [шаблон1, шаблон2, ..., шаблонN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, которые требуется найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив позиций начала подстроки в байтах, счёт от 1 (если подстрока была найдена). Возвращает 0, если подстрока не найдена. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Регистронезависимый поиск в UTF-8**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```

## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

Добавлена в версии: v20.1

Аналог [`multiSearchAllPositions`](#multiSearchAllPositions), но предполагается, что `haystack` и подстроки `needle` — это строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив подстрок в кодировке UTF-8, которые требуется найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах, считая с 1 (если подстрока найдена), или `0`, если подстрока не найдена. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Множественный поиск в UTF-8**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```

## multiSearchAny {#multiSearchAny}

Введена в версии: v20.1

Проверяет, содержит ли исходная строка хотя бы одну строку из набора строк-образцов.

Функции [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive), [`multiSearchAnyUTF8`](#multiSearchAnyUTF8) и [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) предоставляют регистронезависимые и/или UTF‑8‑варианты этой функции.

**Синтаксис**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив подстрок, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск при наличии любого совпадения**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

Введена в версии v20.1

Аналог [multiSearchAny](#multiSearchAny), но не учитывает регистр.

**Синтаксис**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — Подстроки, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение без учета регистра, или `0`, если ни одного совпадения без учета регистра не найдено. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учета регистра**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

Появилась в версии: v20.1

Аналог [multiSearchAnyUTF8](#multiSearchAnyUTF8), но без учета регистра.

**Синтаксис**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение без учета регистра, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Дана строка UTF-8 &#39;Здравствуйте&#39;, проверить, присутствует ли символ &#39;з&#39; (строчная буква)**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

Впервые появилась в: v20.1

Аналог [multiSearchAny](#multiSearchAny), но предполагает, что `haystack` и подстроки `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение, в противном случае `0`, если не найдено ни одного совпадения. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Для строки &#39;你好，世界&#39; (&#39;Hello, world&#39;) в кодировке UTF-8 проверьте, есть ли в строке символы 你 или 界**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndex {#multiSearchFirstIndex}

Добавлено в: v20.1

Выполняет поиск нескольких строк-образцов в строке-«стоге сена» (с учетом регистра) и возвращает индекс первого найденного образца, начиная с 1.

**Синтаксис**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needles` — Массив строк для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс, начинающийся с 1 (позицию в массиве `needles`) первой найденной строки в `haystack`. Возвращает 0, если ни одна из строк не найдена. Поиск чувствителен к регистру. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndex('База данных ClickHouse', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**Чувствительность к регистру**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**Совпадений не найдено**

```sql title=Query
SELECT multiSearchFirstIndex('Привет, мир', ['прощай', 'тест']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

Введено в: v20.1

Возвращает индекс `i` (начиная с 1) первой найденной слева подстроки needle&#95;i в строке `haystack` и 0 в противном случае.
Игнорирует регистр.

**Синтаксис**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) самой левой найденной подстроки. В противном случае — `0`, если совпадений нет. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('пРиВеТ МиР', ['мир', 'привет']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

Впервые появилась в: v20.1

Выполняет поиск нескольких подстрок (needle) в строке (haystack) без учета регистра с поддержкой кодировки UTF-8 и возвращает индекс первого найденного элемента (с отсчётом от 1).

**Синтаксис**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needles` — Массив строк для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс, начинающийся с 1 (позицию в массиве `needles`), первой строки, найденной в `haystack`. Возвращает 0, если ни одна строка не найдена. Поиск регистронезависимый и учитывает кодировку UTF-8. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('База данных ClickHouse', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**Обработка регистра символов UTF-8**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**Совпадений не найдено**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет, мир', ['до свидания', 'тест']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

Введена в версии: v20.1

Возвращает индекс `i` (начиная с 1) самой левой найденной подстроки `needle_i` в строке `haystack`, или 0, если совпадений нет.
Предполагается, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в кодировке UTF-8, которые требуется найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) самой левой найденной подстроки из массива `needle`. В противном случае — 0, если совпадений нет. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯введите'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstPosition {#multiSearchFirstPosition}

Введена в версии v20.1

Аналог функции [`position`](#position), но возвращает смещение самой левой позиции в строке `haystack`, соответствующей любой из нескольких строк `needle`.

Функции [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive), [`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8) и [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) предоставляют варианты этой функции, регистронезависимые и/или работающие с UTF-8.

**Синтаксис**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив из одной или более подстрок, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает смещение первой (самой левой) позиции в строке `haystack`, которая совпадает с любой из подстрок `needle`; в противном случае возвращает `0`, если совпадений не найдено. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск первой позиции**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

Появилась в версии: v20.1

Аналог [multiSearchFirstPosition](#multiSearchFirstPosition), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
multiSearchFirstPositionCaseInsensitive(строка, [подстрока1, подстрока2, ..., подстрокаN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает самое левое смещение в строке `haystack`, где найдено совпадение с любой подстрокой из `needle`. Возвращает `0`, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Первая позиция без учёта регистра**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('ПРИВЕТ МИР',['мир', 'ир', 'рив'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

Добавлено в: v20.1

Аналогично [multiSearchFirstPosition](#multiSearchFirstPosition), но предполагает, что `haystack` и `needle` — строки в кодировке UTF-8 и не учитывает регистр.

**Синтаксис**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в кодировке UTF-8, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает смещение от начала строки `haystack` до самого левого вхождения любой из подстрок `needle` при сравнении без учёта регистра. Возвращает `0`, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Найти смещение самого левого вхождения в строке UTF-8 &#39;Здравствуй, мир&#39; (&#39;Hello, world&#39;), которое совпадает с любой из заданных подстрок**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

Добавлена в версии v20.1

Аналог функции [multiSearchFirstPosition](#multiSearchFirstPosition), но предполагает, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Самое левое смещение (позиция, считая слева) в строке `haystack`, где найдено совпадение хотя бы с одной из подстрок `needle`. Возвращает `0`, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Найти самое левое смещение в строке UTF-8 &#39;Здравствуй, мир&#39; (&#39;Hello, world&#39;), которое совпадает хотя бы с одной из заданных подстрок**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```

## ngramDistance {#ngramDistance}

Добавлена в версии: v20.1

Вычисляет расстояние по 4-граммам между двумя строками.
Для этого функция считает симметрическую разность между двумя мультимножествами 4-грамм и нормализует её, деля на сумму их мощностей.
Чем меньше возвращаемое значение, тем более похожи строки.

Для поиска без учёта регистра и/или в кодировке UTF-8 используйте функции [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive), [`ngramDistanceUTF8`](#ngramDistanceUTF8), [`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8).

**Синтаксис**

```sql
ngramDistance(строка_искания, подстрока)
```

**Аргументы**

* `haystack` — строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа `Float32` в диапазоне от `0` до `1`. Чем меньше возвращаемое значение, тем более похожи строки. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Вычисление 4-граммного расстояния**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

Введена в версии: v20.1

Предоставляет регистронезависимый вариант функции [`ngramDistance`](#ngramDistance).
Вычисляет расстояние 4-грамм между двумя строками без учета регистра.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — первая строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — вторая строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа `Float32` в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Регистронезависимое расстояние по 4-граммам**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

Добавлено в: v20.1

Предоставляет вариант функции [`ngramDistance`](#ngramDistance) для UTF-8 без учета регистра.
Предполагается, что строки `needle` и `haystack` закодированы в UTF-8, и регистр символов игнорируется.
Вычисляет расстояние по 3-граммам между двумя строками UTF-8, игнорируя регистр.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — первая сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)
* `needle` — вторая сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Регистронезависимое UTF-8 расстояние по 3-граммам**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```

## ngramDistanceUTF8 {#ngramDistanceUTF8}

Введена в версии: v20.1

Предоставляет UTF-8-вариант функции [`ngramDistance`](#ngramDistance).
Предполагается, что строки `needle` и `haystack` закодированы в UTF-8.
Вычисляет расстояние по 3-граммам между двумя строками в UTF-8.
Чем меньше полученное значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — первая сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)
* `needle` — вторая сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Расстояние на основе 3-грамм в UTF-8**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```

## ngramSearch {#ngramSearch}

Появилась в версии: v20.1

Проверяет, что 4-граммное расстояние между двумя строками меньше или равно заданному порогу.

Для поиска без учета регистра и/или для строк в кодировке UTF-8 используйте функции `ngramSearchCaseInsensitive`, `ngramSearchUTF8`, `ngramSearchCaseInsensitiveUTF8`.

**Синтаксис**

```sql
ngramSearch(стог, иголка)
```

**Аргументы**

* `haystack` — строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние на основе 4-грамм между строками меньше или равно пороговому значению (`1.0` по умолчанию), в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск по 4-граммам**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```

## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

Добавлена в: v20.1

Предоставляет вариант функции [`ngramSearch`](#ngramSearch), нечувствительный к регистру.
Вычисляет несимметричную разность между строкой needle и строкой haystack, то есть (количество n-грамм в needle минус количество общих n-грамм), нормированное на количество n-грамм в needle.
Проверяет, что расстояние по 4-граммам между двумя строками меньше или равно заданному порогу, игнорируя регистр.

**Синтаксис**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 4-граммам между строками меньше либо равно порогу (`1.0` по умолчанию), в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учета регистра по 4-граммам**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Привет, мир','привет')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

Добавлена в: v20.1

Предоставляет регистронезависимый UTF-8‑вариант функции [`ngramSearch`](#ngramSearch).
Предполагается, что `haystack` и `needle` — это строки в кодировке UTF-8, при этом регистр символов не учитывается.
Проверяет, что расстояние по 3-граммам между двумя строками UTF-8 меньше или равно заданному порогу, игнорируя регистр.

**Синтаксис**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние на основе 3-грамм между строками меньше или равно пороговому значению (`1.0` по умолчанию), и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Регистронезависимый поиск по UTF-8 с использованием 3-грамм**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```

## ngramSearchUTF8 {#ngramSearchUTF8}

Введена в: v20.1

Предоставляет вариант функции `ngramSearch` для строк в кодировке UTF-8.
Предполагается, что `haystack` и `needle` — строки в кодировке UTF-8.
Проверяет, что 3-граммное расстояние между двумя строками UTF-8 меньше или равно заданному порогу.

**Синтаксис**

```sql
ngramSearchUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)
* `needle` — сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 3-граммам между строками меньше либо равно пороговому значению (`1.0` по умолчанию), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск по UTF-8-строкам с использованием 3-грамм**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```

## notILike {#notILike}

Добавлено в: v20.6

Проверяет, не соответствует ли строка шаблону без учета регистра. Шаблон может содержать специальные символы `%` и `_` для сопоставления в стиле SQL LIKE.

**Синтаксис**

```sql
notILike(haystack, pattern)
```

**Аргументы**

* `haystack` — входная строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон SQL LIKE для сопоставления. `%` соответствует любому числу символов (включая ноль), `_` соответствует ровно одному символу. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка не соответствует шаблону (без учета регистра), в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```

## notLike {#notLike}

Добавлена в версии v1.1

Аналогична [`like`](#like), но возвращает противоположный результат.

**Синтаксис**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — Шаблон для оператора LIKE, с которым выполняется сопоставление. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка не соответствует шаблону `LIKE`, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**Несоответствующий шаблон**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```

## position {#position}

Появилась в версии: v1.1

Возвращает позицию (в байтах, начиная с 1) подстроки `needle` в строке `haystack`.

Если подстрока `needle` пустая, применяются следующие правила:

* если `start_pos` не указан: возвращается `1`
* если `start_pos = 0`: возвращается `1`
* если `start_pos >= 1` и `start_pos <= length(haystack) + 1`: возвращается `start_pos`
* иначе: возвращается `0`

Те же правила применяются и к функциям [`locate`](#locate), [`positionCaseInsensitive`](#positionCaseInsensitive), [`positionUTF8`](#positionUTF8) и [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8).

**Синтаксис**

```sql
position(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — Позиция (отсчёт с 1) в `haystack`, с которой начинается поиск. Необязательный параметр. [`UInt`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах, считая с 1, если подстрока найдена, в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**С аргументом `start_pos`**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Синтаксис `needle IN haystack`**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**Пустая искомая подстрока**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```

## positionCaseInsensitive {#positionCaseInsensitive}

Появилась в версии: v1.1

Как [`position`](#position), но без учета регистра.

**Синтаксис**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**Псевдонимы**: `instr`

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — подстрока для поиска. [`String`](/sql-reference/data-types/string)
* `start_pos` — необязательный параметр. Позиция (счёт начиная с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах, считая с 1, если подстрока найдена, иначе — `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учёта регистра**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Привет, мир!', 'привет')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```

## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

Добавлена в версии: v1.1

Аналог [`positionUTF8`](#positionUTF8), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока для поиска. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный параметр. Позиция (счёт от 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию (в байтах, счёт с 1), если подстрока найдена, иначе `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Регистронезависимый поиск в UTF-8**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```

## positionUTF8 {#positionUTF8}

Добавлена в версии: v1.1

Аналог [`position`](#position), но предполагает, что `haystack` и `needle` — строки в кодировке UTF‑8.

**Синтаксис**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный параметр. Позиция в `haystack`, с которой начинается поиск (нумерация с 1). [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию подстроки в байтах (нумерация с 1), если подстрока найдена; в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт символов в UTF-8**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

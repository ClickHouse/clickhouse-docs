---
description: 'Документация по функциям для поиска в строках'
sidebar_label: 'Поиск в строках'
slug: /sql-reference/functions/string-search-functions
title: 'Функции для поиска в строках'
doc_type: 'reference'
---



# Функции для поиска в строках

Все функции в этом разделе по умолчанию выполняют поиск с учётом регистра. Поиск без учёта регистра обычно предоставляется отдельными вариантами функций.

:::note
Поиск без учёта регистра следует правилам преобразования строчных и прописных букв английского языка. Например, прописная буква `i` в английском языке — это
`I`, тогда как в турецком языке это `İ` — результаты для языков, отличных от английского, могут быть неожиданными.
:::

Функции в этом разделе также предполагают, что искомая строка (в этом разделе обозначается как `haystack`) и строка поиска (в этом разделе обозначается как `needle`) представляют собой текст в однобайтовой кодировке. Если это предположение
нарушается, исключение не выбрасывается, а результаты не определены. Поиск в строках с кодировкой UTF-8 обычно предоставляется отдельными вариантами
функций. Аналогично, если используется вариант функции для UTF-8, а входные строки не являются текстом в кодировке UTF-8, исключение не выбрасывается, а
результаты не определены. Обратите внимание, что автоматическая нормализация Unicode не выполняется, однако для этого можно использовать
функции [normalizeUTF8\*()](https://clickhouse.com../functions/string-functions/).

[Общие строковые функции](string-functions.md) и [функции для замены в строках](string-replace-functions.md) описаны отдельно.

:::note
Документация ниже генерируется из системной таблицы `system.functions`.
:::

<!--
Внутреннее содержимое тегов ниже заменяется во время сборки документации
документацией, сгенерированной из system.functions. Пожалуйста, не изменяйте и не удаляйте теги.
См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## countMatches {#countMatches}

Introduced in: v21.1

Возвращает количество совпадений регулярного выражения в строке.

:::note Поведение, зависящее от версии
Поведение этой функции зависит от версии ClickHouse:

- в версиях < v25.6 функция прекращает подсчёт при первом пустом совпадении, даже если шаблон его допускает.
- в версиях >= 25.6 функция продолжает выполнение при возникновении пустого совпадения. Прежнее поведение можно восстановить с помощью настройки `count_matches_stop_at_empty_match = true`;
  :::

**Синтаксис**

```sql
countMatches(haystack, pattern)
```

**Аргументы**

- `haystack` — строка для поиска. [`String`](/sql-reference/data-types/string)
- `pattern` — шаблон регулярного выражения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Количество найденных совпадений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт последовательностей цифр**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```


## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

Introduced in: v21.1

Аналогична [`countMatches`](#countMatches), но выполняет сопоставление без учёта регистра.

**Синтаксис**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**Аргументы**

- `haystack` — строка для поиска. [`String`](/sql-reference/data-types/string)
- `pattern` — шаблон регулярного выражения. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество найденных совпадений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт без учёта регистра**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```


## countSubstrings {#countSubstrings}

Введена в версии: v21.1

Возвращает количество вхождений подстроки `needle` в строку `haystack`.

**Синтаксис**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [String](../../sql-reference/data-types/string.md) или [Enum](../../sql-reference/data-types/enum.md).
- `needle` — искомая подстрока. [String](../../sql-reference/data-types/string.md).
- `start_pos` — позиция в `haystack` (нумерация с 1), с которой начинается поиск. [UInt](../../sql-reference/data-types/int-uint.md). Необязательный параметр.

**Возвращаемое значение**

Количество вхождений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Результат
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**С аргументом start_pos**

```sql title=Запрос
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Результат
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```


## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

Introduced in: v21.1

Аналогична [`countSubstrings`](#countSubstrings), но выполняет подсчёт без учёта регистра.

**Синтаксис**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
- `needle` — искомая подстрока. [`String`](/sql-reference/data-types/string)
- `start_pos` — необязательный параметр. Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает количество вхождений подстроки `needle` в строке `haystack`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Результат
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**С аргументом start_pos**

```sql title=Запрос
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Результат
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```


## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

Введена в версии: v21.1

Аналогична [`countSubstrings`](#countSubstrings), но выполняет подсчёт без учёта регистра и предполагает, что haystack является строкой UTF-8.

**Синтаксис**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Аргументы**

- `haystack` — строка UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
- `needle` — искомая подстрока. [`String`](/sql-reference/data-types/string)
- `start_pos` — необязательный параметр. Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает количество вхождений подстроки needle в строку haystack. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**С аргументом start_pos**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```


## extract {#extract}

Введено в версии: v1.1

Извлекает первое совпадение регулярного выражения в строке.
Если 'haystack' не соответствует 'pattern', возвращается пустая строка.

Функция использует библиотеку регулярных выражений RE2. Поддерживаемый синтаксис описан в документации [re2](https://github.com/google/re2/wiki/Syntax).

Если регулярное выражение содержит захватывающие группы (подшаблоны), функция возвращает совпадение с первой захватывающей группой.

**Синтаксис**

```sql
extract(haystack, pattern)
```

**Аргументы**

- `haystack` — Строка, из которой производится извлечение. [`String`](/sql-reference/data-types/string)
- `pattern` — Регулярное выражение, обычно содержащее захватывающую группу. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённый фрагмент в виде строки. [`String`](/sql-reference/data-types/string)

**Примеры**

**Извлечение домена из адреса электронной почты**

```sql title=Запрос
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Результат
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**При отсутствии совпадения возвращается пустая строка**

```sql title=Запрос
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Результат
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```


## extractAll {#extractAll}

Введена в версии: v1.1

Аналогична [`extract`](#extract), но возвращает массив всех совпадений регулярного выражения в строке.
Если 'haystack' не соответствует регулярному выражению 'pattern', возвращается пустой массив.

Если регулярное выражение содержит захватывающие группы (подшаблоны), функция сопоставляет входную строку с первой захватывающей группой.

**Синтаксис**

```sql
extractAll(haystack, pattern)
```

**Аргументы**

- `haystack` — Строка, из которой извлекаются фрагменты. [`String`](/sql-reference/data-types/string)
- `pattern` — Регулярное выражение, опционально содержащее захватывающие группы. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив извлечённых фрагментов. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Извлечение всех чисел**

```sql title=Запрос
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Результат
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**Извлечение с использованием захватывающей группы**

```sql title=Запрос
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Результат
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```


## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

Введена в версии: v20.5

Находит все группы в строке с помощью указанного регулярного выражения и возвращает массив массивов, где каждый массив содержит все захваты из одной группы захвата по всем совпадениям, упорядоченные по номеру группы.

**Синтаксис**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**Аргументы**

- `s` — Входная строка для извлечения. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — Регулярное выражение для поиска совпадений. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Возвращает массив массивов, где каждый внутренний массив содержит все захваты из одной группы захвата по всем совпадениям. Первый внутренний массив содержит все захваты из группы 1, второй — из группы 2 и т. д. Если совпадений не найдено, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Результат
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```


## extractGroups {#extractGroups}

Введена в версии: v20.5

Извлекает все группы из непересекающихся подстрок, соответствующих регулярному выражению.

**Синтаксис**

```sql
extractAllGroups(s, regexp)
```

**Аргументы**

- `s` — Входная строка для извлечения. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — Регулярное выражение. Константа. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Если функция находит хотя бы одну соответствующую группу, она возвращает столбец Array(Array(String)), сгруппированный по group_id (от `1` до `N`, где `N` — количество захватывающих групп в регулярном выражении). Если соответствующих групп нет, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Результат
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```


## hasAllTokens {#hasAllTokens}

Введена в версии: v25.10

Аналогична [`hasAnyTokens`](#hasAnyTokens), но возвращает 1, если все токены в строке или массиве `needle` совпадают со строкой `input`, и 0 в противном случае. Если `input` является столбцом, возвращает все строки, удовлетворяющие этому условию.

:::note
Для оптимальной производительности для столбца `input` должен быть определён [текстовый индекс](../../engines/table-engines/mergetree-family/invertedindexes).
Если текстовый индекс не определён, функция выполняет полное сканирование столбца, что на порядки медленнее поиска по индексу.
:::

Перед поиском функция выполняет токенизацию:

- аргумента `input` (всегда), и
- аргумента `needle` (если передан как [String](../../sql-reference/data-types/string.md))
  с использованием токенизатора, указанного для текстового индекса.
  Если для столбца не определён текстовый индекс, используется токенизатор `splitByNonAlpha`.
  Если аргумент `needle` имеет тип [Array(String)](../../sql-reference/data-types/array.md), каждый элемент массива рассматривается как токен — дополнительная токенизация не выполняется.

Дублирующиеся токены игнорируются.
Например, needles = ['ClickHouse', 'ClickHouse'] обрабатывается так же, как ['ClickHouse'].

**Синтаксис**

```sql
hasAllTokens(input, needles)
```

**Псевдонимы**: `hasAllToken`

**Аргументы**

- `input` — Входной столбец. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(String)`](/sql-reference/data-types/array) или [`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — Токены для поиска. Поддерживается не более 64 токенов. [`String`](/sql-reference/data-types/string) или [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает 1, если все токены совпадают, и 0 в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования для строкового столбца**

```sql title=Запрос
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Результат
┌─count()─┐
│       1 │
└─────────┘
```

**Указание токенов для поиска как есть (без токенизации) в массиве**

```sql title=Запрос
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Результат
┌─count()─┐
│       1 │
└─────────┘
```

**Генерация токенов с помощью функции `tokens`**

```sql title=Запрос
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Результат
┌─count()─┐
│       1 │
└─────────┘
```

**Примеры использования для столбцов типа массив и словарь**

```sql title=Запрос
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Результат

```

**Пример со столбцом типа массив**

```sql title=Запрос
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Результат
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с mapKeys**

```sql title=Запрос
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```


```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```


## hasAnyTokens {#hasAnyTokens}

Введена в версии: v25.10

Возвращает 1, если хотя бы один токен в строке или массиве `needle` совпадает со строкой `input`, и 0 в противном случае. Если `input` является столбцом, возвращает все строки, удовлетворяющие этому условию.

:::note
Для оптимальной производительности столбец `input` должен иметь определённый [текстовый индекс](../../engines/table-engines/mergetree-family/invertedindexes).
Если текстовый индекс не определён, функция выполняет полное сканирование столбца, что на порядки медленнее поиска по индексу.
:::

Перед поиском функция токенизирует

- аргумент `input` (всегда), и
- аргумент `needle` (если передан как [String](../../sql-reference/data-types/string.md))
  используя токенизатор, указанный для текстового индекса.
  Если для столбца не определён текстовый индекс, вместо него используется токенизатор `splitByNonAlpha`.
  Если аргумент `needle` имеет тип [Array(String)](../../sql-reference/data-types/array.md), каждый элемент массива рассматривается как токен — дополнительная токенизация не выполняется.

Дублирующиеся токены игнорируются.
Например, ['ClickHouse', 'ClickHouse'] обрабатывается так же, как ['ClickHouse'].

**Синтаксис**

```sql
hasAnyTokens(input, needles)
```

**Псевдонимы**: `hasAnyToken`

**Аргументы**

- `input` — Входной столбец. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(String)`](/sql-reference/data-types/array) или [`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — Токены для поиска. Поддерживается не более 64 токенов. [`String`](/sql-reference/data-types/string) или [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если было хотя бы одно совпадение, `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования для строкового столбца**

```sql title=Запрос
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Ответ
┌─count()─┐
│       3 │
└─────────┘
```

**Указание токенов для поиска как есть (без токенизации) в массиве**

```sql title=Запрос
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Ответ
┌─count()─┐
│       3 │
└─────────┘
```

**Генерация токенов с помощью функции `tokens`**

```sql title=Запрос
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Ответ
┌─count()─┐
│       3 │
└─────────┘
```

**Примеры использования для столбцов типа массив и словарь**

```sql title=Запрос
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Ответ

```

**Пример со столбцом типа массив**

```sql title=Запрос
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Ответ
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с mapKeys**

```sql title=Запрос
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```


```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**Пример использования mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```


## hasSubsequence {#hasSubsequence}

Введено в версии: v23.7

Проверяет, является ли needle подпоследовательностью haystack.
Подпоследовательность строки — это последовательность, которую можно получить из другой строки путём удаления некоторых символов (или без удаления) без изменения порядка оставшихся символов.

**Синтаксис**

```sql
hasSubsequence(haystack, needle)
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск подпоследовательности. [`String`](/sql-reference/data-types/string)
- `needle` — искомая подпоследовательность. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если needle является подпоследовательностью haystack, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовая проверка подпоследовательности**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**Подпоследовательность не найдена**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```


## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

Введена в версии: v23.7

Аналогична [`hasSubsequence`](#hasSubsequence), но выполняет поиск без учёта регистра.

**Синтаксис**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — искомая подпоследовательность. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если `needle` является подпоследовательностью `haystack`, иначе 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Результат
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```


## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

Добавлена в версии: v23.7

Аналогична [`hasSubsequenceUTF8`](#hasSubsequenceUTF8), но выполняет поиск без учёта регистра.

**Синтаксис**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

- `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — искомая подпоследовательность в кодировке UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если `needle` является подпоследовательностью `haystack`, иначе 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Результат
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```


## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

Introduced in: v23.7

Аналогична [`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence), но предполагает, что строки haystack и needle закодированы в UTF-8.

**Синтаксис**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — искомая подпоследовательность. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если `needle` является подпоследовательностью `haystack`, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Результат
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**Несовпадающая подпоследовательность**

```sql title=Запрос
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Результат
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```


## hasToken {#hasToken}

Введена в версии: v20.1

Проверяет, присутствует ли заданный токен в строке haystack.

Токен определяется как максимально длинная подпоследовательность идущих подряд символов `[0-9A-Za-z_]`, то есть цифр, ASCII-букв и символа подчёркивания.

**Синтаксис**

```sql
hasToken(haystack, token)
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `token` — токен для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если токен найден, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск токена**

```sql title=Запрос
SELECT hasToken('clickhouse test', 'test')
```

```response title=Результат
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```


## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

Добавлено в версии: v

Выполняет поиск подстроки needle в строке haystack без учёта регистра с использованием индекса tokenbf_v1.

**Синтаксис**

```sql

```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

**Примеры**


## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

Введена в версии: v

Выполняет поиск подстроки needle в строке haystack без учёта регистра с использованием индекса tokenbf_v1. Возвращает null, если needle имеет некорректный формат.

**Синтаксис**

```sql

```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

**Примеры**


## hasTokenOrNull {#hasTokenOrNull}

Введена в версии: v20.1

Аналогична [`hasToken`](#hasToken), но возвращает null, если токен некорректен.

**Синтаксис**

```sql
hasTokenOrNull(haystack, token)
```

**Аргументы**

- `haystack` — строка для поиска. Должна быть константой. [`String`](/sql-reference/data-types/string)
- `token` — токен для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если токен найден, `0` в противном случае, null, если токен некорректен. [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```


## ilike {#ilike}

Введена в версии: v20.6

Аналогична [`like`](#like), но выполняет поиск без учёта регистра.

**Синтаксис**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — шаблон LIKE для сопоставления. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону LIKE (без учёта регистра), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```


## like {#like}

Введено в версии: v1.1

Возвращает, соответствует ли строка `haystack` шаблону `LIKE` `pattern`.

Выражение `LIKE` может содержать обычные символы и следующие метасимволы:

- `%` обозначает произвольное количество произвольных символов (включая ноль символов).
- `_` обозначает один произвольный символ.
- `\` используется для экранирования литералов `%`, `_` и `\`.

Сопоставление выполняется на основе UTF-8, например, `_` соответствует кодовой точке Unicode `¥`, которая представлена в UTF-8 двумя байтами.

Если `haystack` или выражение `LIKE` не являются корректным UTF-8, поведение не определено.

Автоматическая нормализация Unicode не выполняется, для этого можно использовать функции `normalizeUTF8*`.

Чтобы сопоставить литералы `%`, `_` и `\` (которые являются метасимволами `LIKE`), добавьте перед ними обратную косую черту: `\%`, `\_` и `\\`.
Обратная косая черта теряет свое специальное значение (т. е. интерпретируется буквально), если она предшествует символу, отличному от `%`, `_` или `\`.

:::note
ClickHouse требует, чтобы обратные косые черты в строках [также экранировались](../syntax.md#string), поэтому фактически необходимо писать `\\%`, `\\_` и `\\\\`.
:::

Для выражений `LIKE` вида `%needle%` функция работает так же быстро, как функция `position`.
Все остальные выражения `LIKE` внутренне преобразуются в регулярное выражение и выполняются с производительностью, аналогичной функции `match`.

**Синтаксис**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — шаблон `LIKE` для сопоставления. Может содержать `%` (соответствует любому количеству символов), `_` (соответствует одному символу) и `\` для экранирования. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону `LIKE`, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT like('ClickHouse', '%House');
```

```response title=Результат
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**Подстановочный символ для одного символа**

```sql title=Запрос
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Результат
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**Несоответствующий шаблон**

```sql title=Запрос
SELECT like('ClickHouse', '%SQL%');
```

```response title=Результат
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```


## locate {#locate}

Введена в версии: v18.16

Аналогична функции [`position`](#position), но с переставленными аргументами `haystack` и `needle`.

:::note Поведение, зависящее от версии
Поведение этой функции зависит от версии ClickHouse:

- в версиях < v24.3 функция `locate` являлась псевдонимом функции `position` и принимала аргументы `(haystack, needle[, start_pos])`.
- в версиях >= 24.3 функция `locate` является отдельной функцией (для лучшей совместимости с MySQL) и принимает аргументы `(needle, haystack[, start_pos])`.
  Предыдущее поведение можно восстановить с помощью настройки `function_locate_has_mysql_compatible_argument_order = false`.
:::

**Синтаксис**

```sql
locate(needle, haystack[, start_pos])
```

**Аргументы**

- `needle` — Искомая подстрока. [`String`](/sql-reference/data-types/string)
- `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
- `start_pos` — Необязательный параметр. Позиция (начиная с 1) в строке `haystack`, с которой начинается поиск. [`UInt`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах (начиная с 1), если подстрока найдена, или `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Запрос
SELECT locate('ca', 'abcabc')
```

```response title=Результат
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```


## match {#match}

Введено в версии: v1.1

Проверяет, соответствует ли заданная строка указанному шаблону регулярного выражения.

Функция использует библиотеку регулярных выражений RE2. Поддерживаемый синтаксис описан в документации [re2](https://github.com/google/re2/wiki/Syntax).

Сопоставление выполняется с учетом кодировки UTF-8, например, символ `¥` внутренне занимает два байта, но при сопоставлении обрабатывается как одна кодовая точка.
Регулярное выражение не должно содержать NULL-байты.
Если строка для поиска или шаблон не являются корректным UTF-8, поведение не определено.

В отличие от поведения re2 по умолчанию, `.` соответствует символам перевода строки. Чтобы отключить это, добавьте `(?-s)` в начало шаблона.

Шаблон автоматически привязывается с обоих концов (как если бы шаблон начинался с `^` и заканчивался `$`).

Если требуется только найти подстроки, можно использовать функции [`like`](#like) или [`position`](#position) — они работают значительно быстрее данной функции.

Альтернативный синтаксис оператора: `haystack REGEXP pattern`.

**Синтаксис**

```sql
match(haystack, pattern)
```

**Псевдонимы**: `REGEXP_MATCHES`

**Аргументы**

- `haystack` — строка, в которой выполняется поиск по шаблону. [`String`](/sql-reference/data-types/string)
- `pattern` — шаблон регулярного выражения. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если шаблон соответствует, `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое сопоставление с шаблоном**

```sql title=Запрос
SELECT match('Hello World', 'Hello.*')
```

```response title=Результат
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**Шаблон не соответствует**

```sql title=Запрос
SELECT match('Hello World', 'goodbye.*')
```

```response title=Результат
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```


## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

Введена в версии: v20.1

Аналогична [`multiFuzzyMatchAny`](#multiFuzzyMatchAny), но возвращает массив всех индексов в произвольном порядке, которые соответствуют строке в пределах заданного [расстояния редактирования](https://en.wikipedia.org/wiki/Edit_distance).

**Синтаксис**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `distance` — максимальное расстояние редактирования для нечёткого сопоставления. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив всех индексов (начиная с 1), которые соответствуют строке в пределах указанного расстояния редактирования в произвольном порядке. Возвращает пустой массив, если совпадений не найдено. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Результат
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```


## multiFuzzyMatchAny {#multiFuzzyMatchAny}

Introduced in: v20.1

Аналогична [`multiMatchAny`](#multiMatchAny), но возвращает 1, если любой шаблон соответствует строке в пределах заданного [расстояния редактирования](https://en.wikipedia.org/wiki/Edit_distance).
Эта функция использует экспериментальную возможность библиотеки [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) и может работать медленно в некоторых граничных случаях.
Производительность зависит от значения расстояния редактирования и используемых шаблонов, но она всегда ниже по сравнению с точными вариантами.

:::note
Семейство функций `multiFuzzyMatch*()` не поддерживает регулярные выражения UTF-8 (они обрабатываются как последовательность байтов) из-за ограничений hyperscan.
:::

**Синтаксис**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `distance` — максимальное расстояние редактирования для нечёткого сопоставления. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — необязательный параметр. Массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если любой шаблон соответствует строке в пределах указанного расстояния редактирования, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```


## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

Введена в версии: v20.1

Аналогична [`multiFuzzyMatchAny`](#multiFuzzyMatchAny), но возвращает индекс любого шаблона, который соответствует строке поиска в пределах заданного [расстояния редактирования](https://en.wikipedia.org/wiki/Edit_distance).

**Синтаксис**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `distance` — максимальное расстояние редактирования для нечёткого сопоставления. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) любого шаблона, который соответствует строке поиска в пределах указанного расстояния редактирования, в противном случае `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Результат
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```


## multiMatchAllIndices {#multiMatchAllIndices}

Введена в версии: v20.1

Аналогична [`multiMatchAny`](#multiMatchAny), но возвращает массив всех индексов совпавших шаблонов в любом порядке.

**Синтаксис**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `pattern` — регулярные выражения для сопоставления. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Массив всех индексов (начиная с 1) совпавших шаблонов в любом порядке. Возвращает пустой массив, если совпадений не найдено. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Ответ
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```


## multiMatchAny {#multiMatchAny}

Введена в версии: v20.1

Проверяет, соответствует ли хотя бы один из нескольких шаблонов регулярных выражений искомой строке.

Если требуется только поиск нескольких подстрок в строке, рекомендуется использовать функцию [`multiSearchAny`](#multiSearchAny) — она работает значительно быстрее.

**Синтаксис**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск по шаблонам. [`String`](/sql-reference/data-types/string)
- `pattern1[, pattern2, ...]` — массив из одного или нескольких шаблонов регулярных выражений. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено совпадение хотя бы с одним шаблоном, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Сопоставление с несколькими шаблонами**

```sql title=Запрос
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Результат
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**Ни один шаблон не совпадает**

```sql title=Запрос
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Результат
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```


## multiMatchAnyIndex {#multiMatchAnyIndex}

Introduced in: v20.1

Аналогична [`multiMatchAny`](#multiMatchAny), но возвращает индекс первого совпавшего шаблона.

**Синтаксис**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `pattern` — регулярные выражения для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) первого совпавшего шаблона или 0, если совпадений не найдено. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Результат
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```


## multiSearchAllPositions {#multiSearchAllPositions}

Введена в версии: v20.1

Аналогична функции [`position`](#position), но возвращает массив позиций (в байтах, начиная с 1) для нескольких подстрок `needle` в строке `haystack`.

Все функции `multiSearch*()` поддерживают не более 2^8 искомых подстрок.

**Синтаксис**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — массив из одной или нескольких искомых подстрок. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах (нумерация с 1) для найденных подстрок или `0` для ненайденных подстрок. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Поиск нескольких подстрок**

```sql title=Запрос
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Результат
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```


## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

Introduced in: v20.1

Аналогична [`multiSearchAllPositions`](#multiSearchAllPositions), но игнорирует регистр символов.

**Синтаксис**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — массив из одной или нескольких подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах, считая от 1 (если подстрока найдена), или `0`, если подстрока не найдена. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Множественный поиск без учёта регистра**

```sql title=Запрос
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Результат
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```


## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

Введена в версии: v20.1

Аналогична [`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8), но не учитывает регистр символов.

**Синтаксис**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — подстроки в кодировке UTF-8 для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив начальных позиций в байтах, считая от 1 (если подстрока найдена). Возвращает 0, если подстрока не найдена. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Поиск в UTF-8 без учёта регистра**

```sql title=Запрос
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Результат
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```


## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

Введена в версии: v20.1

Аналогична [`multiSearchAllPositions`](#multiSearchAllPositions), но предполагает, что `haystack` и подстроки `needle` являются строками в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**Аргументы**

- `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — массив подстрок в кодировке UTF-8 для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах, считая от 1 (если подстрока найдена), или `0`, если подстрока не найдена. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Множественный поиск UTF-8**

```sql title=Запрос
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Результат
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```


## multiSearchAny {#multiSearchAny}

Введена в версии: v20.1

Проверяет, совпадает ли хотя бы одна из нескольких искомых строк со строкой, в которой выполняется поиск.

Функции [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive), [`multiSearchAnyUTF8`](#multiSearchAnyUTF8) и [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) предоставляют варианты этой функции без учёта регистра и/или с поддержкой UTF-8.

**Синтаксис**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — массив подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск любого совпадения**

```sql title=Запрос
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Результат
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```


## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

Introduced in: v20.1

Аналогична [multiSearchAny](#multiSearchAny), но не учитывает регистр символов.

**Синтаксис**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — подстроки для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение без учёта регистра, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учёта регистра**

```sql title=Запрос
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Результат
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```


## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

Introduced in: v20.1

Аналогична [multiSearchAnyUTF8](#multiSearchAnyUTF8), но не учитывает регистр символов.

**Синтаксис**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — подстроки UTF-8 для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение без учёта регистра, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Для строки UTF-8 'Здравствуйте' проверить наличие символа 'з' (в нижнем регистре)**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

Введена в версии: v20.1

Аналогична [multiSearchAny](#multiSearchAny), но предполагает, что `haystack` и подстроки `needle` являются строками в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — подстроки UTF-8 для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Для строки UTF-8 '你好，世界' ('Привет, мир') проверить, содержатся ли в ней символы 你 или 界**

```sql title=Запрос
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Результат
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstIndex {#multiSearchFirstIndex}

Введена в версии: v20.1

Выполняет поиск нескольких строк-образцов в исходной строке (с учётом регистра) и возвращает индекс (начиная с 1) первого найденного образца.

**Синтаксис**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needles` — массив строк для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1, позиция в массиве needles) первого найденного образца в исходной строке. Возвращает 0, если ни один образец не найден. Поиск выполняется с учётом регистра. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Результат
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**Поведение с учётом регистра**

```sql title=Запрос
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Результат
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**Совпадение не найдено**

```sql title=Запрос
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Результат
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```


## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

Добавлено в версии: v20.1

Возвращает индекс `i` (начиная с 1) самой левой найденной подстроки needle_i в строке `haystack`, в противном случае возвращает 0.
Не учитывает регистр символов.

**Синтаксис**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — искомые подстроки. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) самой левой найденной подстроки. Если совпадений не найдено, возвращает `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Результат
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

Добавлено в версии: v20.1

Выполняет поиск нескольких подстрок в строке без учёта регистра с поддержкой кодировки UTF-8 и возвращает индекс (начиная с 1) первой найденной подстроки.

**Синтаксис**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needles` — массив строк для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1, позиция в массиве needles) первой найденной подстроки. Возвращает 0, если ни одна подстрока не найдена. Поиск выполняется без учёта регистра с соблюдением кодировки символов UTF-8. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Результат
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**Обработка регистра UTF-8**

```sql title=Запрос
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Результат
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**Совпадение не найдено**

```sql title=Запрос
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Результат
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```


## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

Введена в версии: v20.1

Возвращает индекс `i` (начиная с 1) самой левой найденной подстроки needle_i в строке `haystack`, в противном случае возвращает 0.
Предполагается, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — массив подстрок в кодировке UTF-8 для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) самой левой найденной подстроки. В противном случае возвращает 0, если совпадение не найдено. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Результат
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstPosition {#multiSearchFirstPosition}

Введена в версии: v20.1

Аналогична функции [`position`](#position), но возвращает позицию самого левого вхождения в строке `haystack`, которое соответствует любой из нескольких строк `needle`.

Функции [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive), [`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8) и [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) предоставляют регистронезависимые и/или UTF-8 варианты этой функции.

**Синтаксис**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — массив из одной или нескольких подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает позицию самого левого вхождения в строке `haystack`, которое соответствует любой из строк `needle`, в противном случае `0`, если совпадений не найдено. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск первой позиции**

```sql title=Запрос
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Результат
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

Добавлено в версии: v20.1

Аналогична функции [multiSearchFirstPosition](#multiSearchFirstPosition), но не учитывает регистр символов.

**Синтаксис**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — массив искомых подстрок. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает позицию самого левого вхождения в строке `haystack`, которое соответствует любой из строк `needle`. Возвращает `0`, если совпадений не найдено. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Первая позиция без учёта регистра**

```sql title=Запрос
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Результат
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

Введена в версии: v20.1

Аналогична [multiSearchFirstPosition](#multiSearchFirstPosition), но предполагает, что `haystack` и `needle` являются UTF-8 строками, и не учитывает регистр.

**Синтаксис**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — UTF-8 строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — Массив UTF-8 подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает позицию самого левого вхождения в строке `haystack`, которое соответствует любой из строк `needle`, без учёта регистра. Возвращает `0`, если совпадений не найдено. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Найти позицию самого левого вхождения в UTF-8 строке 'Здравствуй, мир' ('Hello, world'), которое соответствует любой из заданных подстрок**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

Добавлена в версии: v20.1

Аналогична [multiSearchFirstPosition](#multiSearchFirstPosition), но предполагает, что `haystack` и `needle` являются строками в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

- `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
- `needle` — массив подстрок в кодировке UTF-8 для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Самое левое смещение в строке `haystack`, которое соответствует любой из строк `needle`. Возвращает `0`, если совпадение не найдено. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск самого левого смещения в строке UTF-8 'Здравствуй, мир', которое соответствует любой из заданных подстрок**

```sql title=Запрос
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Результат
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```


## ngramDistance {#ngramDistance}

Введена в версии: v20.1

Вычисляет 4-граммное расстояние между двумя строками.
Для этого вычисляется симметрическая разность между двумя мультимножествами 4-грамм и нормализуется по сумме их мощностей.
Чем меньше возвращаемое значение, тем более похожи строки.

Для поиска без учёта регистра и/или в формате UTF-8 используйте функции [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive), [`ngramDistanceUTF8`](#ngramDistanceUTF8), [`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8).

**Синтаксис**

```sql
ngramDistance(haystack, needle)
```

**Аргументы**

- `haystack` — строка для сравнения. [`String`](/sql-reference/data-types/string)
- `needle` — строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. Чем меньше возвращаемое значение, тем более похожи строки. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Вычисление 4-граммного расстояния**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```


## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

Введена в версии: v20.1

Предоставляет регистронезависимый вариант функции [`ngramDistance`](#ngramDistance).
Вычисляет 4-граммное расстояние между двумя строками без учёта регистра.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**Аргументы**

- `haystack` — первая строка для сравнения. [`String`](/sql-reference/data-types/string)
- `needle` — вторая строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Регистронезависимое 4-граммное расстояние**

```sql title=Запрос
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Результат
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```


## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

Введена в версии: v20.1

Предоставляет регистронезависимый UTF-8 вариант функции [`ngramDistance`](#ngramDistance).
Предполагается, что строки `needle` и `haystack` закодированы в UTF-8, регистр символов игнорируется.
Вычисляет 3-граммное расстояние между двумя UTF-8 строками без учета регистра.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

- `haystack` — первая строка для сравнения, закодированная в UTF-8. [`String`](/sql-reference/data-types/string)
- `needle` — вторая строка для сравнения, закодированная в UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Регистронезависимое 3-граммное расстояние UTF-8**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```


## ngramDistanceUTF8 {#ngramDistanceUTF8}

Добавлена в версии: v20.1

Предоставляет UTF-8 вариант функции [`ngramDistance`](#ngramDistance).
Предполагает, что строки `needle` и `haystack` закодированы в UTF-8.
Вычисляет расстояние между 3-граммами двух UTF-8 строк.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceUTF8(haystack, needle)
```

**Аргументы**

- `haystack` — первая строка для сравнения, закодированная в UTF-8. [`String`](/sql-reference/data-types/string)
- `needle` — вторая строка для сравнения, закодированная в UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Расстояние между UTF-8 3-граммами**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```


## ngramSearch {#ngramSearch}

Введена в версии: v20.1

Проверяет, меньше или равно ли расстояние по 4-граммам между двумя строками заданному порогу.

Для поиска без учёта регистра и/или в формате UTF-8 используйте функции `ngramSearchCaseInsensitive`, `ngramSearchUTF8`, `ngramSearchCaseInsensitiveUTF8`.

**Синтаксис**

```sql
ngramSearch(haystack, needle)
```

**Аргументы**

- `haystack` — строка для сравнения. [`String`](/sql-reference/data-types/string)
- `needle` — строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 4-граммам между строками меньше или равно порогу (по умолчанию `1.0`), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск с использованием 4-грамм**

```sql title=Запрос
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Результат
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```


## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

Введена в версии: v20.1

Предоставляет регистронезависимый вариант функции [`ngramSearch`](#ngramSearch).
Вычисляет несимметричную разность между строкой-образцом и строкой для поиска, то есть количество n-грамм из образца минус общее количество n-грамм, нормализованное по количеству n-грамм образца.
Проверяет, меньше или равно ли расстояние на основе 4-грамм между двумя строками заданному порогу, игнорируя регистр.

**Синтаксис**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**Аргументы**

- `haystack` — строка для поиска. [`String`](/sql-reference/data-types/string)
- `needle` — строка-образец для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние на основе 4-грамм между строками меньше или равно порогу (по умолчанию `1.0`), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Регистронезависимый поиск с использованием 4-грамм**

```sql title=Запрос
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Результат
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```


## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

Введена в версии: v20.1

Предоставляет регистронезависимый UTF-8 вариант функции [`ngramSearch`](#ngramSearch).
Предполагает, что `haystack` и `needle` являются UTF-8 строками, и игнорирует регистр.
Проверяет, меньше или равно ли расстояние по 3-граммам между двумя UTF-8 строками заданному порогу, игнорируя регистр.

**Синтаксис**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

- `haystack` — UTF-8 строка для сравнения. [`String`](/sql-reference/data-types/string)
- `needle` — UTF-8 строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 3-граммам между строками меньше или равно порогу (по умолчанию `1.0`), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Регистронезависимый UTF-8 поиск с использованием 3-грамм**

```sql title=Запрос
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Результат
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```


## ngramSearchUTF8 {#ngramSearchUTF8}

Введена в версии: v20.1

Предоставляет UTF-8 вариант функции `ngramSearch`.
Предполагает, что `haystack` и `needle` являются UTF-8 строками.
Проверяет, меньше или равно ли расстояние по 3-граммам между двумя UTF-8 строками заданному порогу.

**Синтаксис**

```sql
ngramSearchUTF8(haystack, needle)
```

**Аргументы**

- `haystack` — UTF-8 строка для сравнения. [`String`](/sql-reference/data-types/string)
- `needle` — UTF-8 строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 3-граммам между строками меньше или равно порогу (по умолчанию `1.0`), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск в UTF-8 с использованием 3-грамм**

```sql title=Запрос
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Результат
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```


## notILike {#notILike}

Введена в версии: v20.6

Проверяет, не соответствует ли строка шаблону, без учёта регистра. Шаблон может содержать специальные символы `%` и `_` для сопоставления в стиле SQL LIKE.

**Синтаксис**

```sql
notILike(haystack, pattern)
```

**Аргументы**

- `haystack` — Входная строка для поиска. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — Шаблон SQL LIKE для сопоставления. `%` соответствует любому количеству символов (включая ноль), `_` соответствует ровно одному символу. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка не соответствует шаблону (без учёта регистра), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT notILike('ClickHouse', '%house%');
```

```response title=Результат
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```


## notLike {#notLike}

Введена в версии: v1.1

Аналогична функции [`like`](#like), но возвращает инвертированный результат.

**Синтаксис**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — шаблон LIKE для сопоставления. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка не соответствует шаблону `LIKE`, иначе — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**Шаблон не совпадает**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```


## position {#position}

Введена в версии: v1.1

Возвращает позицию (в байтах, начиная с 1) подстроки `needle` в строке `haystack`.

Если подстрока `needle` пустая, применяются следующие правила:

- если `start_pos` не указан: возвращается `1`
- если `start_pos = 0`: возвращается `1`
- если `start_pos >= 1` и `start_pos <= length(haystack) + 1`: возвращается `start_pos`
- в противном случае: возвращается `0`

Те же правила применяются к функциям [`locate`](#locate), [`positionCaseInsensitive`](#positionCaseInsensitive), [`positionUTF8`](#positionUTF8) и [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8).

**Синтаксис**

```sql
position(haystack, needle[, start_pos])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
- `needle` — искомая подстрока. [`String`](/sql-reference/data-types/string)
- `start_pos` — позиция (начиная с 1) в `haystack`, с которой начинается поиск. Необязательный параметр. [`UInt`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах (считая с 1), если подстрока найдена, иначе `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Запрос
SELECT position('Hello, world!', '!')
```

```response title=Результат
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**С аргументом start_pos**

```sql title=Запрос
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Результат
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Синтаксис needle IN haystack**

```sql title=Запрос
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Результат
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**Пустая подстрока needle**

```sql title=Запрос
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Результат
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```


## positionCaseInsensitive {#positionCaseInsensitive}

Введена в версии: v1.1

Аналогична [`position`](#position), но не учитывает регистр символов.

**Синтаксис**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**Псевдонимы**: `instr`

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
- `needle` — искомая подстрока. [`String`](/sql-reference/data-types/string)
- `start_pos` — необязательный параметр. Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах (нумерация с 1), если подстрока найдена, иначе `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учёта регистра**

```sql title=Запрос
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Результат
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```


## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

Введена в версии: v1.1

Аналогична [`positionUTF8`](#positionUTF8), но выполняет поиск без учёта регистра.

**Синтаксис**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
- `needle` — искомая подстрока. [`String`](/sql-reference/data-types/string)
- `start_pos` — необязательный параметр. Позиция (начиная с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах (начиная с 1), если подстрока найдена, иначе `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск UTF-8 без учёта регистра**

```sql title=Запрос
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Результат
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```


## positionUTF8 {#positionUTF8}

Introduced in: v1.1

Аналогична [`position`](#position), но предполагает, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**Аргументы**

- `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
- `needle` — искомая подстрока. [`String`](/sql-reference/data-types/string)
- `start_pos` — необязательный параметр. Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах (нумерация с 1), если подстрока найдена, иначе `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчет символов UTF-8**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

<!--AUTOGENERATED_END-->

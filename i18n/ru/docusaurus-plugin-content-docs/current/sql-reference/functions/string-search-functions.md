---
description: 'Справочник по функциям поиска в строках'
sidebar_label: 'Поиск в строках'
slug: /sql-reference/functions/string-search-functions
title: 'Функции поиска в строках'
doc_type: 'reference'
---

# Функции для поиска в строках \{#functions-for-searching-in-strings\}

Все функции в этом разделе по умолчанию выполняют поиск с учётом регистра. Поиск без учёта регистра обычно реализуется отдельными вариантами функций.

:::note
Поиск без учёта регистра следует правилам соответствия строчных и прописных букв английского языка. Например, заглавная буква `i` в английском языке — это `I`, тогда как в турецком языке — это `İ`; результаты для языков, отличных от английского, могут быть неожиданными.
:::

Функции в этом разделе также предполагают, что строка, в которой выполняется поиск (в этом разделе она называется `haystack`), и искомая строка (называемая в этом разделе `needle`) представляют собой однобайтовый текст. Если это предположение
не выполняется, исключение не выбрасывается, а результаты не определены. Поиск по строкам в кодировке UTF-8 обычно реализуется отдельными
вариантами функций. Аналогично, если используется UTF-8-вариант функции, а входные строки не являются текстом в кодировке UTF-8, исключение не выбрасывается, а
результаты не определены. Обратите внимание, что автоматическая нормализация Unicode не выполняется; при необходимости вы можете использовать для этого функции
[normalizeUTF8*()](/sql-reference/functions/string-functions#normalizeUTF8NFC).

[Общие функции для работы со строками](string-functions.md) и [функции для замены в строках](string-replace-functions.md) описаны отдельно.

:::note
Документация ниже сгенерирована из системной таблицы `system.functions`.
:::

{/* 
  Содержимое тегов ниже во время сборки фреймворка документации заменяется
  на документацию, сгенерированную из таблицы system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## countMatches \{#countMatches\}

Впервые появилась в: v21.1

Возвращает количество совпадений регулярного выражения в строке.

:::note Зависимость поведения от версии
Поведение этой функции зависит от версии ClickHouse:

* в версиях &lt; v25.6 функция прекращает подсчет при первом пустом совпадении, даже если шаблон принимает пустое совпадение.
* в версиях &gt;= 25.6 функция продолжает выполнение при возникновении пустого совпадения. Устаревшее поведение можно вернуть, используя настройку `count_matches_stop_at_empty_match = true`;
  :::

**Синтаксис**

```sql
countMatches(haystack, pattern)
```

**Аргументы**

* `haystack` — Строка, в которой осуществляется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — Шаблон регулярного выражения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество найденных вхождений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт последовательностей цифр**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```

## countMatchesCaseInsensitive \{#countMatchesCaseInsensitive\}

Добавлена в версии: v21.1

Аналог [`countMatches`](#countMatches), но выполняет сравнение без учета регистра.

**Синтаксис**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — шаблон регулярного выражения. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество найденных совпадений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт без учёта регистра**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```

## countSubstrings \{#countSubstrings\}

Добавлена в версии: v21.1

Возвращает, сколько раз подстрока `needle` встречается в строке `haystack`.

**Синтаксис**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [String](../../sql-reference/data-types/string.md) или [Enum](../../sql-reference/data-types/enum.md). - `needle` — подстрока, которую нужно найти. [String](../../sql-reference/data-types/string.md). - `start_pos` — позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [UInt](../../sql-reference/data-types/int-uint.md). Необязательный параметр.

**Возвращаемое значение**

Количество вхождений. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**С использованием аргумента start&#95;pos**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```

## countSubstringsCaseInsensitive \{#countSubstringsCaseInsensitive\}

Введена в версии v21.1

Аналог [`countSubstrings`](#countSubstrings), но выполняет подсчёт без учёта регистра.

**Синтаксис**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока, которую требуется найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный аргумент. Позиция (считая с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает количество вхождений `needle` в `haystack`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**С аргументом start&#95;pos**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```

## countSubstringsCaseInsensitiveUTF8 \{#countSubstringsCaseInsensitiveUTF8\}

Добавлена в: v21.1

Аналог [`countSubstrings`](#countSubstrings), но выполняет подсчёт без учёта регистра и предполагает, что аргумент `haystack` является строкой в кодировке UTF-8.

**Синтаксис**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — необязательный параметр. Позиция (считая с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает количество вхождений `needle` в `haystack`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**С аргументом start&#95;pos**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```

## extract \{#extract\}

Добавлена в: v1.1

Извлекает первое совпадение регулярного выражения в строке.
Если &#39;haystack&#39; не соответствует &#39;pattern&#39;, возвращается пустая строка.

Эта функция использует библиотеку регулярных выражений RE2. См. [re2](https://github.com/google/re2/wiki/Syntax) для поддерживаемого синтаксиса.

Если регулярное выражение содержит группы захвата (подшаблоны), функция использует первую группу захвата в качестве совпадения.

**Синтаксис**

```sql
extract(haystack, pattern)
```

**Аргументы**

* `haystack` — Строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string)
* `pattern` — Регулярное выражение, как правило, содержащее группу захвата. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённый фрагмент в виде строки. [`String`](/sql-reference/data-types/string)

**Примеры**

**Извлечение домена из адреса электронной почты**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**Если совпадений нет, возвращается пустая строка.**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```

## extractAll \{#extractAll\}

Добавлена в: v1.1

Как [`extract`](#extract), но возвращает массив всех вхождений регулярного выражения в строке.
Если &#39;haystack&#39; не соответствует регулярному выражению &#39;pattern&#39;, возвращается пустой массив.

Если регулярное выражение содержит группы захвата (подшаблоны), функция возвращает совпадения для первой группы захвата.

**Синтаксис**

```sql
extractAll(haystack, pattern)
```

**Аргументы**

* `haystack` — Строка, из которой нужно извлечь фрагменты. [`String`](/sql-reference/data-types/string)
* `pattern` — Регулярное выражение, при необходимости содержащее группы захвата. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив извлечённых фрагментов. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Извлечение всех чисел**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**Извлечение с использованием захватывающей группы**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```

## extractAllGroupsHorizontal \{#extractAllGroupsHorizontal\}

Добавлено в версии: v20.5

Находит все группы в строке с помощью указанного регулярного выражения и возвращает массив массивов, где каждый внутренний массив содержит все захватывания одной и той же группы, расположенные по номеру группы.

**Синтаксис**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**Аргументы**

* `s` — Входная строка, из которой выполняется извлечение групп. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — Регулярное выражение для сопоставления. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Возвращает массив массивов, где каждый внутренний массив содержит все захваченные подстроки одной группы захвата по всем совпадениям. Первый внутренний массив содержит все захваты из группы 1, второй — из группы 2 и т. д. Если совпадения не найдены, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```

## extractGroups \{#extractGroups\}

Введена в: v20.5

Извлекает все группы из непересекающихся подстрок, найденных по регулярному выражению.

**Синтаксис**

```sql
extractGroups(s, regexp)
```

**Аргументы**

* `s` — Входная строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — Регулярное выражение. Константное значение. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Если функция находит хотя бы одну совпадающую группу, она возвращает столбец типа Array(Array(String)), упорядоченный по group&#95;id (`1` до `N`, где `N` — количество захватывающих групп в regexp). Если совпадающих групп нет, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## hasAllTokens \{#hasAllTokens\}

Добавлена в: v25.10

Аналогично [`hasAnyTokens`](#hasAnyTokens), но возвращает 1, если все токены в строке или массиве `needle` совпадают со строкой `input`, и 0 в противном случае. Если `input` — это столбец, возвращаются все строки, удовлетворяющие этому условию.

:::note
Для столбца `input` должен быть определён [текстовый индекс](../../engines/table-engines/mergetree-family/textindexes) для оптимальной производительности.
Если текстовый индекс не определён, функция выполняет полное сканирование столбца, которое на порядки медленнее, чем поиск по индексу.
:::

Перед поиском функция выполняет токенизацию

* аргумента `input` (всегда) и
* аргумента `needle` (если он задан как [String](../../sql-reference/data-types/string.md)),
  используя токенизатор, указанный для текстового индекса.
  Если для столбца не определён текстовый индекс, вместо него используется токенизатор `splitByNonAlpha`.
  Если аргумент `needle` имеет тип [Array(String)](../../sql-reference/data-types/array.md), каждый элемент массива рассматривается как токен — дополнительная токенизация не выполняется.

Дубликаты токенов игнорируются.
Например, `needles = [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;]` обрабатывается так же, как `[&#39;ClickHouse&#39;]`.

**Синтаксис**

```sql
hasAllTokens(input, needles)
```

**Псевдонимы**: `hasAllToken`

**Аргументы**

* `input` — входной столбец. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(String)`](/sql-reference/data-types/array) или [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — токены, которые требуется найти. [`String`](/sql-reference/data-types/string) или [`Array(String)`](/sql-reference/data-types/array)
* `tokenizer` — токенизатор, который следует использовать. Допустимые значения: `splitByNonAlpha`, `ngrams`, `splitByString`, `array` и `sparseGrams`. Необязательный параметр, если явно не задан, по умолчанию используется `splitByNonAlpha`. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если все токены найдены, иначе — 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование со строковым аргументом needle**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Укажите подстроки, которые нужно искать КАК ЕСТЬ (без токенизации) в массиве**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Генерация искомых подстрок с помощью функции `tokens`**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Использование пользовательского токенизатора через третий аргумент**

```sql title=Query
SELECT hasAllTokens('abcdef', 'abc', 'ngrams(3)');
```

```response title=Response
┌─hasAllTokens('abcdef', 'abc', 'ngrams(3)')─┐
│                                            1 │
└──────────────────────────────────────────────┘
```

**Примеры использования столбцов типов Array и Map**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**Пример со столбцом типа Array**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с функцией mapKeys**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример использования mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```

## hasAnyTokens \{#hasAnyTokens\}

Добавлено в: v25.10

Возвращает 1, если хотя бы один токен в строке или массиве `needle` совпадает со строкой `input`, и 0 в противном случае. Если `input` — это столбец, возвращает все строки, удовлетворяющие этому условию.

:::note
Для столбца `input` должен быть определён [текстовый индекс](../../engines/table-engines/mergetree-family/textindexes) для оптимальной производительности.
Если текстовый индекс не определён, функция выполняет полное сканирование столбца, что на порядки медленнее, чем поиск по индексу.
:::

Перед поиском функция выполняет токенизацию

* аргумента `input` (всегда) и
* аргумент `needle` (если он задан как [String](../../sql-reference/data-types/string.md)),
  используя токенизатор, указанный для текстового индекса.
  Если для столбца не определён текстовый индекс, вместо него используется токенизатор `splitByNonAlpha`.
  Если аргумент `needle` имеет тип [Array(String)](../../sql-reference/data-types/array.md), каждый элемент массива рассматривается как отдельный токен — дополнительная токенизация не выполняется.

Дублирующиеся токены игнорируются.
Например, [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] обрабатывается так же, как [&#39;ClickHouse&#39;].

**Синтаксис**

```sql
hasAnyTokens(input, needles)
```

**Псевдонимы**: `hasAnyToken`

**Аргументы**

* `input` — Входной столбец. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(String)`](/sql-reference/data-types/array) или [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — Токены, которые нужно найти. [`String`](/sql-reference/data-types/string) или [`Array(String)`](/sql-reference/data-types/array)
* `tokenizer` — Токенизатор, который будет использоваться. Допустимые аргументы: `splitByNonAlpha`, `ngrams`, `splitByString`, `array` и `sparseGrams`. Необязательный параметр: если явно не задан, по умолчанию используется `splitByNonAlpha`. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если было найдено хотя бы одно совпадение. `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование со строковым needle**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Укажите строки, которые следует искать «как есть» (без токенизации) в массиве**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Сгенерируйте искомые токены с помощью функции `tokens`**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Примеры использования столбцов типов Array и Map**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**Пример со столбцом массива**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Пример с функцией mapKeys**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**Пример использования mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

## hasSubsequence \{#hasSubsequence\}

Впервые появилась в: v23.7

Проверяет, является ли `needle` подпоследовательностью `haystack`.
Подпоследовательность строки — это последовательность, которую можно получить из другой строки путём удаления некоторых (или ни одного) символов без изменения порядка оставшихся символов.

**Синтаксис**

```sql
hasSubsequence(haystack, needle)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск подпоследовательности. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если needle является подпоследовательностью haystack, и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовая проверка наличия подпоследовательности**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**Подпоследовательность не найдена**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitive \{#hasSubsequenceCaseInsensitive\}

Добавлена в версии: v23.7

Аналог [`hasSubsequence`](#hasSubsequence), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если `needle` является подпоследовательностью `haystack`, и 0 в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitiveUTF8 \{#hasSubsequenceCaseInsensitiveUTF8\}

Появилась в версии: v23.7

Аналог функции [`hasSubsequenceUTF8`](#hasSubsequenceUTF8), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — строка-подпоследовательность в кодировке UTF-8, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает 1, если `needle` является подпоследовательностью строки `haystack`, иначе 0. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```

## hasSubsequenceUTF8 \{#hasSubsequenceUTF8\}

Добавлена в версии: v23.7

Аналог функции [`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence), но предполагает, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подпоследовательность, которую нужно найти. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если `needle` является подпоследовательностью `haystack`, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**Подпоследовательность без совпадений**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```

## hasToken \{#hasToken\}

Впервые появилась в: v20.1

Проверяет, присутствует ли заданный токен в строке.

Использует [splitByNonAlpha](/sql-reference/functions/splitting-merging-functions.md/#splitByNonAlpha) в качестве токенизатора, то есть токен определяется как максимально длинная подпоследовательность идущих подряд символов `[0-9A-Za-z_]` (цифры, ASCII-символы и символ подчёркивания).

**Синтаксис**

```sql
hasToken(haystack, token)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `token` — Токен для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если токен найден, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск токена**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```

## hasTokenCaseInsensitive \{#hasTokenCaseInsensitive\}

Добавлена в версии: v20.1

Выполняет регистронезависимый поиск значения `needle` в `haystack` с использованием индекса tokenbf&#95;v1.

**Синтаксис**

```sql
hasTokenCaseInsensitive(haystack, needle)
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

**Примеры**

## hasTokenCaseInsensitiveOrNull \{#hasTokenCaseInsensitiveOrNull\}

Введена в версии: v23.1

Выполняет поиск `needle` в `haystack` без учета регистра с использованием индекса tokenbf&#95;v1. Возвращает null, если `needle` задано некорректно.

**Синтаксис**

```sql
hasTokenCaseInsensitiveOrNull(haystack, needle)
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

**Примеры**

## hasTokenOrNull \{#hasTokenOrNull\}

Впервые появился в версии v20.1

Аналог [`hasToken`](#hasToken), но возвращает null, если токен имеет неверный формат.

**Синтаксис**

```sql
hasTokenOrNull(haystack, token)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. Должна быть константной. [`String`](/sql-reference/data-types/string)
* `token` — Токен для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если токен найден, `0` — в противном случае, `null` — если токен имеет неверный формат. [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**Примеры**

**Пример использования**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```

## ilike \{#ilike\}

Добавлено в: v20.6

Аналог [`like`](#like), но выполняет регистронезависимый поиск.

**Синтаксис**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон LIKE для поиска совпадений. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону LIKE (без учета регистра), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```

## like \{#like\}

Введено в: v1.1

Возвращает, соответствует ли строка `haystack` `LIKE`‑выражению `pattern`.

`LIKE`‑выражение может содержать обычные символы и следующие метасимволы:

* `%` обозначает произвольное количество произвольных символов (включая ноль символов).
* `_` обозначает один произвольный символ.
* `\` используется для экранирования литералов `%`, `_` и `\`.

Сопоставление выполняется в кодировке UTF-8, например, `_` соответствует кодовой точке Unicode `¥`, которая в UTF-8 представлена двумя байтами.

Если строка `haystack` или `LIKE`‑выражение не являются корректной строкой в кодировке UTF-8, поведение не определено.

Автоматическая нормализация Unicode не выполняется; для этого вы можете использовать функции `normalizeUTF8*`.

Чтобы сопоставлять литеральные `%`, `_` и `\` (которые являются метасимволами `LIKE`), добавьте перед ними обратную косую черту: `\%`, `\_` и `\\`.
Обратная косая черта теряет своё специальное значение (т. е. интерпретируется буквально), если она стоит перед символом, отличным от `%`, `_` или `\`.

:::note
ClickHouse требует [также экранировать обратные косые черты в строках](../syntax.md#string), поэтому фактически вам нужно написать `\\%`, `\\_` и `\\\\`.
:::

Для `LIKE`‑выражений вида `%needle%` функция работает так же быстро, как функция `position`.
Все остальные выражения `LIKE` внутренне преобразуются в регулярное выражение и выполняются с производительностью, аналогичной функции `match`.

**Синтаксис**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон `LIKE` для сравнения. Может содержать `%` (соответствует любому количеству символов), `_` (соответствует одному символу) и `\` для экранирования. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону `LIKE`, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**Подстановочный символ для одного символа**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**Отсутствие совпадения с шаблоном**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```

## locate \{#locate\}

Появилась в версии v18.16

Аналогична [`position`](#position), но с переставленными аргументами `haystack` и `locate`.

:::note Поведение в разных версиях
Поведение этой функции зависит от версии ClickHouse:

* в версиях &lt; v24.3 `locate` была псевдонимом функции `position` и принимала аргументы `(haystack, needle[, start_pos])`;
* в версиях &gt;= 24.3 `locate` является отдельной функцией (для лучшей совместимости с MySQL) и принимает аргументы `(needle, haystack[, start_pos])`.
  Предыдущее поведение можно восстановить с помощью настройки `function_locate_has_mysql_compatible_argument_order = false`.
  :::

**Синтаксис**

```sql
locate(needle, haystack[, start_pos])
```

**Аргументы**

* `needle` — Подстрока для поиска. [`String`](/sql-reference/data-types/string)
* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `start_pos` — Необязательный параметр. Позиция (начиная с 1) в `haystack`, с которой начинается поиск. [`UInt`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах, считая от 1, если подстрока найдена, или `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```

## match \{#match\}

Добавлена в: v1.1

Проверяет, соответствует ли указанная строка заданному шаблону регулярного выражения.

Эта функция использует библиотеку регулярных выражений RE2. Поддерживаемый синтаксис смотрите в [re2](https://github.com/google/re2/wiki/Syntax).

Сопоставление выполняется при предположении кодировки UTF-8, например, `¥` внутренне занимает два байта, но при сопоставлении рассматривается как один кодпоинт.
Регулярное выражение не должно содержать нулевых байтов.
Если `haystack` или шаблон не являются корректным UTF-8, поведение не определено.

В отличие от поведения по умолчанию re2, `.` сопоставляет также символы перевода строки. Чтобы отключить это, добавьте к шаблону префикс `(?-s)`.

Шаблон автоматически «якорится» с обеих сторон (как если бы шаблон начинался с `^` и заканчивался на `$`).

Если вам нужно лишь находить подстроки, вы можете использовать функции [`like`](#like) или [`position`](#position) — они работают значительно быстрее, чем эта функция.

Альтернативный синтаксис оператора: `haystack REGEXP pattern`.

**Синтаксис**

```sql
match(haystack, pattern)
```

**Псевдонимы**: `REGEXP_MATCHES`

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск по шаблону. [`String`](/sql-reference/data-types/string)
* `pattern` — Шаблон регулярного выражения. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка соответствует шаблону, и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое сопоставление с шаблоном**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**Нет совпадений с шаблоном**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```

## multiFuzzyMatchAllIndices \{#multiFuzzyMatchAllIndices\}

Добавлена в: v20.1

Аналог [`multiFuzzyMatchAny`](#multiFuzzyMatchAny), но возвращает массив всех индексов (в любом порядке), для которых соответствующая строка совпадает с «стогом сена» (haystack) в пределах заданного [редакционного расстояния](https://en.wikipedia.org/wiki/Edit_distance).

**Синтаксис**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — максимальное редакционное расстояние для нечеткого сопоставления. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив всех индексов (начиная с 1) шаблонов, которые совпадают со строкой `haystack` в пределах указанного редакционного расстояния в произвольном порядке. Возвращает пустой массив, если совпадений не найдено. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```

## multiFuzzyMatchAny \{#multiFuzzyMatchAny\}

Добавлена в: v20.1

Как [`multiMatchAny`](#multiMatchAny), но возвращает 1, если любой шаблон совпадает с искомой строкой с учётом фиксированного [редакционного расстояния](https://en.wikipedia.org/wiki/Edit_distance).
Эта функция опирается на экспериментальную возможность библиотеки [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) и может работать медленно в некоторых крайних случаях.
Производительность зависит от значения редакционного расстояния и используемых шаблонов, но всегда ниже по сравнению с вариантами без нечеткого сопоставления.

:::note
Семейство функций `multiFuzzyMatch*()` не поддерживает регулярные выражения в UTF-8 (обрабатывает их как последовательность байт) из‑за ограничений hyperscan.
:::

**Синтаксис**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — Максимальное редакционное расстояние для нечёткого поиска. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — Необязательный аргумент. Массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если хотя бы один шаблон совпадает со строкой `haystack` при указанном редакционном расстоянии, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```

## multiFuzzyMatchAnyIndex \{#multiFuzzyMatchAnyIndex\}

Введена в версии: v20.1

Аналог [`multiFuzzyMatchAny`](#multiFuzzyMatchAny), но возвращает любой индекс совпадения в строке, по которой ведётся поиск, в пределах заданного константного [редакционного расстояния](https://en.wikipedia.org/wiki/Edit_distance).

**Синтаксис**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `distance` — максимальное редакционное расстояние для нечеткого сопоставления. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — массив шаблонов для сопоставления. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) шаблона, совпадающего со строкой `haystack` в пределах указанного редакционного расстояния, иначе `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```

## multiMatchAllIndices \{#multiMatchAllIndices\}

Введена в версии v20.1

Аналог [`multiMatchAny`](#multiMatchAny), но возвращает массив всех индексов, которые совпадают с `haystack` в любом порядке.

**Синтаксис**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — регулярное выражение (шаблон) для сопоставления. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Массив всех индексов (начиная с 1), соответствующих совпадениям в `haystack`, в любом порядке. Возвращает пустой массив, если совпадения не найдены. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```

## multiMatchAny \{#multiMatchAny\}

Добавлена в версии: v20.1

Проверяет, соответствует ли хотя бы один из нескольких шаблонов регулярных выражений строке (&quot;стогу сена&quot;).

Если вам нужно только искать несколько подстрок в строке, вместо этого можно использовать функцию [`multiSearchAny`](#multiSearchAny) — она работает значительно быстрее, чем эта функция.

**Синтаксис**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск по шаблонам. [`String`](/sql-reference/data-types/string)
* `pattern1[, pattern2, ...]` — массив из одного или нескольких шаблонов регулярных выражений. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если есть совпадение с любым шаблоном, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Сопоставление нескольких шаблонов**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**Нет совпадений с шаблонами**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```

## multiMatchAnyIndex \{#multiMatchAnyIndex\}

Введена в версии v20.1

Аналог [`multiMatchAny`](#multiMatchAny), но возвращает любой индекс шаблона, который совпадает с исходной строкой.

**Синтаксис**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — регулярные выражения, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) первого шаблона, для которого найдено совпадение, или 0, если совпадений не найдено. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```

## multiSearchAllPositions \{#multiSearchAllPositions\}

Впервые представлена в: v20.1

Аналог функции [`position`](#position), но возвращает массив позиций (в байтах, начиная с 1) для нескольких подстрок `needle` в строке `haystack`.

Все функции `multiSearch*()` поддерживают не более 2^8 подстрок `needle`.

**Синтаксис**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — Массив из одной или более подстрок для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций подстрок в байтах (нумерация с 1), если подстрока была найдена, и `0`, если подстрока не была найдена. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Поиск нескольких подстрок**

```sql title=Query
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitive \{#multiSearchAllPositionsCaseInsensitive\}

Впервые добавлена в: v20.1

Аналог [`multiSearchAllPositions`](#multiSearchAllPositions), но не учитывает регистр.

**Синтаксис**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив из одной или нескольких подстрок, по которым ведется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах, начиная с 1 (если подстрока была найдена), либо `0`, если подстрока не найдена. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Множественный поиск без учета регистра**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitiveUTF8 \{#multiSearchAllPositionsCaseInsensitiveUTF8\}

Появилась в версии v20.1

Аналог [`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8), но игнорирует регистр.

**Синтаксис**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив позиций начала подстроки в байтах, нумерация с 1 (если подстрока найдена). Возвращает 0, если подстрока не найдена. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Регистронезависимый поиск в UTF-8**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```

## multiSearchAllPositionsUTF8 \{#multiSearchAllPositionsUTF8\}

Впервые появилось в: v20.1

Аналог [`multiSearchAllPositions`](#multiSearchAllPositions), но предполагает, что `haystack` и подстроки `needle` — это строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив подстрок в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив начальных позиций в байтах, нумерация с 1 (если подстрока найдена), либо `0`, если подстрока не найдена. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Множественный поиск в строках UTF-8**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```

## multiSearchAny \{#multiSearchAny\}

Добавлено в: v20.1

Проверяет, совпадает ли хотя бы одна из строк needle со строкой haystack.

Функции [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive), [`multiSearchAnyUTF8`](#multiSearchAnyUTF8) и [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) предоставляют варианты этой функции, работающие без учета регистра и/или с кодировкой UTF-8.

**Синтаксис**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив искомых подстрок. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение, иначе `0`, если совпадений нет. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск при наличии хотя бы одного совпадения**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitive \{#multiSearchAnyCaseInsensitive\}

Впервые появилась в: v20.1

Аналог [multiSearchAny](#multiSearchAny), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение без учета регистра, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учета регистра**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitiveUTF8 \{#multiSearchAnyCaseInsensitiveUTF8\}

Добавлена в версии: v20.1

Аналог [multiSearchAnyUTF8](#multiSearchAnyUTF8), но игнорирует регистр.

**Синтаксис**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено хотя бы одно совпадение без учета регистра, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Для строки UTF-8 &#39;Здравствуйте&#39; проверьте, присутствует ли символ &#39;з&#39; (в нижнем регистре)**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchAnyUTF8 \{#multiSearchAnyUTF8\}

Введена в версии: v20.1

Аналог функции [multiSearchAny](#multiSearchAny), но предполагает, что `haystack` и подстроки `needle` являются строками в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки в кодировке UTF-8, которые нужно найти. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если найдено как минимум одно совпадение, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Для строки &#39;你好，世界&#39; (&#39;Hello, world&#39;) в кодировке UTF-8 проверьте, есть ли в строке символы 你 или 界**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndex \{#multiSearchFirstIndex\}

Появилась в: v20.1

Выполняет поиск нескольких строк-образцов в исходной строке (с учётом регистра) и возвращает индекс (начиная с 1) первого найденного образца.

**Синтаксис**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needles` — Массив строк, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (позицию в массиве `needles`), начинающийся с 1, первой строки из `needles`, найденной в `haystack`. Возвращает 0, если ни одна строка не найдена. Поиск выполняется с учётом регистра. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**Регистрозависимое поведение**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**Совпадений не найдено**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitive \{#multiSearchFirstIndexCaseInsensitive\}

Впервые представлена в: v20.1

Возвращает индекс `i` (начиная с 1) самой левой найденной подстроки `needle_i` в строке `haystack`, и 0 в противном случае.
Игнорирует регистр.

**Синтаксис**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — подстроки для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) самого левого найденного вхождения `needle`. В противном случае — `0`, если совпадения не было. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitiveUTF8 \{#multiSearchFirstIndexCaseInsensitiveUTF8\}

Добавлено в: v20.1

Выполняет поиск нескольких подстрок-образцов в строке‑«стоге сена» без учета регистра с поддержкой кодировки UTF-8 и возвращает индекс первого найденного образца (нумерация с 1).

**Синтаксис**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needles` — массив строк для поиска. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс, начинающийся с 1 (позицию в массиве `needles`) первой строки, найденной в `haystack`. Возвращает 0, если ни одна из строк не найдена. Поиск нечувствителен к регистру и учитывает кодировку символов UTF-8. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**Учет регистра в UTF-8**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**Совпадений не найдено**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexUTF8 \{#multiSearchFirstIndexUTF8\}

Появилась в версии: v20.1

Возвращает индекс `i` (начиная с 1) самого левого вхождения `needle&#95;i` в строке `haystack` или 0, если совпадений нет.
Предполагается, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в кодировке UTF-8, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс (начиная с 1) самой левой найденной подстроки. В противном случае возвращает 0, если совпадений не было. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstPosition \{#multiSearchFirstPosition\}

Введена в: v20.1

Аналог функции [`position`](#position), но возвращает смещение от начала строки `haystack` до самого левого вхождения любой из нескольких строк `needle`.

Функции [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive), [`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8) и [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) предоставляют регистронезависимые и/или UTF-8-варианты этой функции.

**Синтаксис**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — массив из одной или более подстрок, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает смещение от начала строки `haystack`, соответствующее любой из подстрок `needle`. В случае отсутствия совпадений возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск позиции первого вхождения**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitive \{#multiSearchFirstPositionCaseInsensitive\}

Впервые появилась в версии v20.1

Аналог [multiSearchFirstPosition](#multiSearchFirstPosition), но без учета регистра.

**Синтаксис**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — Массив подстрок, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает наименьшее (самое левое) смещение в строке `haystack`, где найдено совпадение с любой из строк `needle`. Возвращает `0`, если совпадений не было. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Первое вхождение без учета регистра**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitiveUTF8 \{#multiSearchFirstPositionCaseInsensitiveUTF8\}

Впервые появилась в версии v20.1

Аналог [multiSearchFirstPosition](#multiSearchFirstPosition), но предполагает, что `haystack` и `needle` — строки в кодировке UTF-8, и игнорирует регистр.

**Синтаксис**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в кодировке UTF-8, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает самую левую позицию в строке `haystack`, которая совпадает с любой из строк `needle`, без учета регистра. Возвращает `0`, если совпадение не найдено. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Найти самую левую позицию в строке UTF-8 &#39;Здравствуй, мир&#39; (&#39;Hello, world&#39;), которая совпадает с любой из указанных подстрок**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionUTF8 \{#multiSearchFirstPositionUTF8\}

Появилась в версии: v20.1

Аналог [multiSearchFirstPosition](#multiSearchFirstPosition), но предполагает, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Аргументы**

* `haystack` — строка в UTF-8, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — массив подстрок в UTF-8, по которым выполняется поиск. [`Array(String)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Наименьшее (самое левое) смещение в строке `haystack`, в котором есть совпадение с любой из строк `needle`. Возвращает `0`, если совпадений нет. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Найдите наименьшее (самое левое) смещение в строке UTF-8 &#39;Здравствуй, мир&#39; (&#39;Hello, world&#39;), которое совпадает с любой из заданных подстрок**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```

## ngramDistance \{#ngramDistance\}

Впервые появилась в версии v20.1

Вычисляет расстояние по 4-граммам между двумя строками.
Для этого считает симметрическую разность между двумя мультимножествами 4-грамм и нормализует её по сумме их мощностей.
Чем меньше возвращаемое значение, тем более похожи строки.

Для поиска без учета регистра и/или в формате UTF8 используйте функции [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive), [`ngramDistanceUTF8`](#ngramDistanceUTF8), [`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8).

**Синтаксис**

```sql
ngramDistance(haystack, needle)
```

**Аргументы**

* `haystack` — строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. Чем меньше возвращаемое значение, тем более похожи строки. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Вычисление расстояния на основе 4-грамм**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitive \{#ngramDistanceCaseInsensitive\}

Впервые представлена в: v20.1

Предоставляет регистронезависимый вариант [`ngramDistance`](#ngramDistance).
Вычисляет расстояние на основе 4-грамм между двумя строками, игнорируя регистр.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — первая сравниваемая строка. [`String`](/sql-reference/data-types/string)
* `needle` — вторая сравниваемая строка. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число с плавающей запятой типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Регистронезависимое 4-граммное расстояние**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitiveUTF8 \{#ngramDistanceCaseInsensitiveUTF8\}

Впервые представлена в: v20.1

Предоставляет регистронезависимый вариант UTF-8 функции [`ngramDistance`](#ngramDistance).
Предполагается, что строки `needle` и `haystack` закодированы в UTF-8, при этом регистр игнорируется.
Вычисляет расстояние по 3-граммам между двумя строками в кодировке UTF-8 с игнорированием регистра.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — первая сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)
* `needle` — вторая сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**Регистронезависимое расстояние 3-грамм в UTF-8**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```

## ngramDistanceUTF8 \{#ngramDistanceUTF8\}

Введена в версии v20.1

Предоставляет вариант функции [`ngramDistance`](#ngramDistance) для строк в кодировке UTF‑8.
Предполагается, что строки `needle` и `haystack` закодированы в UTF‑8.
Вычисляет расстояние по 3-граммам между двумя строками UTF‑8.
Чем меньше возвращаемое значение, тем более похожи строки.

**Синтаксис**

```sql
ngramDistanceUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — первая сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)
* `needle` — вторая сравниваемая строка в кодировке UTF-8. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число типа Float32 в диапазоне от `0` до `1`. [`Float32`](/sql-reference/data-types/float)

**Примеры**

**3-граммное расстояние UTF-8**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```

## ngramSearch \{#ngramSearch\}

Введена в версии v20.1

Проверяет, что расстояние по 4-граммам между двумя строками меньше либо равно заданному порогу.

Для нечувствительного к регистру поиска и/или работы с UTF-8 используйте функции `ngramSearchCaseInsensitive`, `ngramSearchUTF8`, `ngramSearchCaseInsensitiveUTF8`.

**Синтаксис**

```sql
ngramSearch(haystack, needle)
```

**Аргументы**

* `haystack` — Строка для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — Строка для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 4-граммам между строками меньше либо равно порогу (`1.0` по умолчанию), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск с использованием 4-грамм**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```

## ngramSearchCaseInsensitive \{#ngramSearchCaseInsensitive\}

Добавлена в версии: v20.1

Предоставляет регистронезависимый вариант [`ngramSearch`](#ngramSearch).
Вычисляет несимметричную разницу между строкой-образцом и строкой-источником, то есть количество n-грамм из образца минус общее количество общих n-грамм, нормированное по количеству n-грамм в образце.
Проверяет, что 4-граммное расстояние между двумя строками меньше либо равно заданному порогу, игнорируя регистр.

**Синтаксис**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `needle` — Искомая строка. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 4-граммам между строками меньше или равно пороговому значению (`1.0` по умолчанию), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учета регистра с использованием 4-грамм**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

## ngramSearchCaseInsensitiveUTF8 \{#ngramSearchCaseInsensitiveUTF8\}

Добавлена в версии: v20.1

Предоставляет регистронезависимый UTF-8-вариант [`ngramSearch`](#ngramSearch).
Предполагается, что `haystack` и `needle` — это строки в кодировке UTF-8, и регистр в них игнорируется.
Проверяет, что расстояние по 3-граммам между двумя строками UTF-8 меньше либо равно заданному порогу, игнорируя регистр.

**Синтаксис**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние на основе 3-грамм между строками меньше или равно пороговому значению (`1.0` по умолчанию), и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Нечувствительный к регистру поиск в строках UTF-8 с использованием 3-грамм**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```

## ngramSearchUTF8 \{#ngramSearchUTF8\}

Появилась в: v20.1

Предоставляет вариант функции `ngramSearch` для строк в кодировке UTF-8.
Предполагает, что `haystack` и `needle` — строки в кодировке UTF-8.
Проверяет, что расстояние по 3-граммам между двумя строками UTF-8 меньше или равно заданному порогу.

**Синтаксис**

```sql
ngramSearchUTF8(haystack, needle)
```

**Аргументы**

* `haystack` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)
* `needle` — строка в кодировке UTF-8 для сравнения. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если расстояние по 3-граммам между строками меньше либо равно порогу (`1.0` по умолчанию), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск в UTF-8 с использованием 3-грамм**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```

## notILike \{#notILike\}

Появилась в версии: v20.6

Проверяет, что строка не соответствует шаблону без учета регистра. Шаблон может содержать специальные символы `%` и `_` для сопоставления в стиле SQL LIKE.

**Синтаксис**

```sql
notILike(haystack, pattern)
```

**Аргументы**

* `haystack` — входная строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон SQL `LIKE` для сравнения. `%` соответствует любому количеству символов (включая ноль), `_` соответствует ровно одному символу. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка не соответствует шаблону (сравнение без учета регистра), иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```

## notLike \{#notLike\}

Введён в: v1.1

Похож на [`like`](#like), но возвращает противоположный результат.

**Синтаксис**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**Аргументы**

* `haystack` — строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — шаблон `LIKE` для проверки соответствия. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка не соответствует шаблону `LIKE`, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**Отсутствие совпадения с шаблоном**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```

## position \{#position\}

Введена в версии: v1.1

Возвращает позицию (в байтах, начиная с 1) подстроки `needle` в строке `haystack`.

Если подстрока `needle` пуста, применяются следующие правила:

* если `start_pos` не указан: возвращается `1`;
* если `start_pos = 0`: возвращается `1`;
* если `start_pos >= 1` и `start_pos <= length(haystack) + 1`: возвращается `start_pos`;
* иначе: возвращается `0`.

Те же правила также применяются к функциям [`locate`](#locate), [`positionCaseInsensitive`](#positionCaseInsensitive), [`positionUTF8`](#positionUTF8) и [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8).

**Синтаксис**

```sql
position(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока для поиска. [`String`](/sql-reference/data-types/string)
* `start_pos` — Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. Необязательный параметр. [`UInt`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах, считая с 1, если подстрока найдена; в противном случае — `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**С аргументом start&#95;pos**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Синтаксис «иголка IN стоге сена»**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**Пустая подстрока-шаблон**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```

## positionCaseInsensitive \{#positionCaseInsensitive\}

Добавлена в версии: v1.1

Аналог функции [`position`](#position), но без учета регистра.

**Синтаксис**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**Псевдонимы**: `instr`

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный параметр. Позиция (счёт с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию в байтах, считая с 1, если подстрока найдена, и `0`, если подстрока не найдена. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Поиск без учёта регистра**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```

## positionCaseInsensitiveUTF8 \{#positionCaseInsensitiveUTF8\}

Введена в версии v1.1

Аналог [`positionUTF8`](#positionUTF8), но выполняет поиск без учета регистра.

**Синтаксис**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный параметр. Позиция (начиная с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию (в байтах, начиная с 1), если подстрока была найдена, в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Регистронезависимый поиск в UTF-8**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```

## positionUTF8 \{#positionUTF8\}

Появилась в версии: v1.1

Аналог функции [`position`](#position), но предполагается, что `haystack` и `needle` — строки в кодировке UTF-8.

**Синтаксис**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**Аргументы**

* `haystack` — Строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string) или [`Enum`](/sql-reference/data-types/enum)
* `needle` — Подстрока, которую нужно найти. [`String`](/sql-reference/data-types/string)
* `start_pos` — Необязательный параметр. Позиция (нумерация с 1) в `haystack`, с которой начинается поиск. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает начальную позицию подстроки в байтах (нумерация с 1), если подстрока найдена, в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Подсчёт символов в кодировке UTF-8**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

---
description: 'Документация по функциям разбиения строк'
sidebar_label: 'Разбиение строк'
slug: /sql-reference/functions/splitting-merging-functions
title: 'Функции разбиения строк'
doc_type: 'reference'
---

import DeprecatedBadge from '@theme/badges/DeprecatedBadge';

# Функции разбиения строк \{#functions-for-splitting-strings\}

:::note
Приведённая ниже документация сгенерирована из системной таблицы `system.functions`.
:::

{/* 
  Содержимое тегов ниже при сборке фреймворка документации
  заменяется документацией, сгенерированной из system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## alphaTokens \{#alphaTokens\}

Добавлена в: v1.1

Выбирает подстроки из последовательностей байтов в диапазонах символов `a-z` и `A-Z` и возвращает массив выбранных подстрок.

**Синтаксис**

```sql
alphaTokens(s[, max_substrings])
```

**Псевдонимы**: `splitByAlpha`

**Аргументы**

* `s` — Строка, которую нужно разбить. [`String`](/sql-reference/data-types/string)
* `max_substrings` — Необязательный параметр. Когда `max_substrings > 0`, количество возвращаемых подстрок не будет превышать `max_substrings`, в противном случае функция вернёт максимально возможное количество подстрок. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив полученных подстрок строки `s`. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT alphaTokens('abca1abc');
```

```response title=Response
┌─alphaTokens('abca1abc')─┐
│ ['abca','abc']          │
└─────────────────────────┘
```

## arrayStringConcat \{#arrayStringConcat\}

Добавлено в версии: v1.1

Соединяет строковые представления значений, перечисленных в массиве, с указанным разделителем; этот параметр является необязательным и по умолчанию равен пустой строке.

**Синтаксис**

```sql
arrayStringConcat(arr[, separator])
```

**Аргументы**

* `arr` — Массив, элементы которого нужно конкатенировать. [`Array(T)`](/sql-reference/data-types/array)
* `separator` — Необязательный параметр. Строка-разделитель. По умолчанию — пустая строка. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает конкатенированную строку. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayStringConcat(['12/05/2021', '12:50:00'], ' ') AS DateString;
```

```response title=Response
┌─DateString──────────┐
│ 12/05/2021 12:50:00 │
└─────────────────────┘
```

## extractAllGroupsVertical \{#extractAllGroupsVertical\}

Введена в версии v20.5

Находит все группы в строке с использованием регулярного выражения и возвращает массив массивов, где каждый вложенный массив содержит совпадающие фрагменты из каждой группы, упорядоченные по порядку появления во входной строке.

**Синтаксис**

```sql
extractAllGroupsVertical(s, regexp)
```

**Псевдонимы**: `extractAllGroups`

**Аргументы**

* `s` — Входная строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — Регулярное выражение для поиска совпадений. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Возвращает массив массивов, где каждый вложенный массив содержит группы, захваченные при одном совпадении. Каждое совпадение формирует массив с элементами, соответствующими группам захвата в регулярном выражении (группа 1, группа 2 и т. д.). Если совпадения не найдены, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsVertical(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## ngrams \{#ngrams\}

Появилась в версии v21.11

Разбивает строку в кодировке UTF-8 на n-граммы длиной `N`.

**Синтаксис**

```sql
ngrams(s, N)
```

**Аргументы**

* `s` — входная строка. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `N` — длина n-граммы. [`const UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив n-грамм. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT ngrams('ClickHouse', 3);
```

```response title=Response
['Cli','lic','ick','ckH','kHo','Hou','ous','use']
```

## reverseBySeparator \{#reverseBySeparator\}

Добавлена в: v26.2

Разворачивает порядок подстрок в строке, разделённой указанным разделителем.
Эта функция разделяет строку по разделителю, инвертирует порядок получившихся частей
и соединяет их обратно, используя тот же разделитель. Полезна для разбора доменных имён,
путей к файлам или других иерархических данных, где требуется изменить порядок компонентов.

Примеры:

* reverseBySeparator(&#39;www.google.com&#39;) возвращает &#39;com.google.www&#39;
* reverseBySeparator(&#39;a/b/c&#39;, &#39;/&#39;) возвращает &#39;c/b/a&#39;
* reverseBySeparator(&#39;x::y::z&#39;, &#39;::&#39;) возвращает &#39;z::y::x&#39;

**Синтаксис**

```sql
reverseBySeparator(string[, separator])
```

**Аргументы**

* `string` — Входная строка, в которой нужно развернуть порядок её частей. [`String`](/sql-reference/data-types/string)
* `separator` — Строка-разделитель, используемая для определения частей. Если не указан, используется &#39;.&#39; (точка). По умолчанию: &#39;.&#39; [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку с подстроками, упорядоченными справа налево относительно исходной строки и объединёнными тем же разделителем. [`String`](/sql-reference/data-types/string)

**Примеры**

**Простой пример разворота домена**

```sql title=Query
SELECT reverseBySeparator('www.google.com')
```

```response title=Response
'com.google.www'
```

**Реверс пути**

```sql title=Query
SELECT reverseBySeparator('a/b/c', '/')
```

```response title=Response
'c/b/a'
```

**Произвольный разделитель**

```sql title=Query
SELECT reverseBySeparator('x::y::z', '::')
```

```response title=Response
'z::y::x'
```

**Особый случай с точками**

```sql title=Query
SELECT reverseBySeparator('.a.b.', '.')
```

```response title=Response
'.b.a.'
```

**Один элемент**

```sql title=Query
SELECT reverseBySeparator('single')
```

```response title=Response
'single'
```

**Пустой символ-разделитель**

```sql title=Query
SELECT reverseBySeparator('abcde', '')
```

```response title=Response
'edcba'
```

## splitByChar \{#splitByChar\}

Введена в: v1.1

Разбивает строку, в которой подстроки разделены указанной константной строкой `separator` длиной ровно в один символ, на массив подстрок.
Пустые подстроки могут появляться, если разделитель встречается в начале или в конце строки, либо если есть несколько последовательных разделителей.

:::note
Настройка [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) определяет, включается ли оставшаяся часть строки в последний элемент результирующего массива, когда аргумент `max_substrings > 0`.
:::

Пустые подстроки могут появляться, когда:

* разделитель встречается в начале или в конце строки;
* есть несколько последовательных разделителей;
* исходная строка `s` пуста.

**Синтаксис**

```sql
splitByChar(separator, s[, max_substrings])
```

**Аргументы**

* `separator` — Разделитель должен быть однобайтовым символом. [`String`](/sql-reference/data-types/string)
* `s` — Строка для разбиения. [`String`](/sql-reference/data-types/string)
* `max_substrings` — Необязательный параметр. Если `max_substrings > 0`, возвращаемый массив будет содержать не более `max_substrings` подстрок, в противном случае функция вернёт максимально возможное количество подстрок. Значение по умолчанию — `0`.  [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив полученных подстрок. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByChar(',', '1,2,3,abcde');
```

```response title=Response
┌─splitByChar(⋯2,3,abcde')─┐
│ ['1','2','3','abcde']    │
└──────────────────────────┘
```

## splitByNonAlpha \{#splitByNonAlpha\}

Введена в версии: v21.9

Разбивает строку, разделённую пробельными символами и знаками пунктуации, на массив подстрок.

:::note
Настройка [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) задаёт, будет ли оставшаяся строка включена в последний элемент результирующего массива, когда аргумент `max_substrings > 0`.
:::

**Синтаксис**

```sql
splitByNonAlpha(s[, max_substrings])
```

**Аргументы**

* `s` — строка для разбиения. [`String`](/sql-reference/data-types/string)
* `max_substrings` — необязательный аргумент. Если `max_substrings > 0`, количество возвращаемых подстрок не превышает `max_substrings`, иначе функция возвращает максимально возможное количество подстрок. Значение по умолчанию: `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив подстрок, выделенных из `s`. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByNonAlpha('user@domain.com');
```

```response title=Response
['user','domain','com']
```

## splitByRegexp \{#splitByRegexp\}

Впервые представлена в: v21.6

Разбивает строку по указанному регулярному выражению на массив подстрок.
Если переданное регулярное выражение пустое, строка будет разбита на массив отдельных символов.
Если для регулярного выражения не найдено совпадений, строка не будет разбита.

Пустые подстроки могут появиться, когда:

* непустое совпадение регулярного выражения находится в начале или конце строки,
* есть несколько последовательных непустых совпадений регулярного выражения,
* исходная строка пуста, а регулярное выражение не пустое.

:::note
Настройка [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) управляет тем, будет ли оставшаяся часть строки включена в последний элемент результирующего массива, когда аргумент `max_substrings > 0`.
:::

**Синтаксис**

```sql
splitByRegexp(regexp, s[, max_substrings])
```

**Аргументы**

* `regexp` — регулярное выражение. Константа. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `s` — строка для разбиения. [`String`](/sql-reference/data-types/string)
* `max_substrings` — необязательный параметр. Если `max_substrings > 0`, количество возвращаемых подстрок не превышает `max_substrings`, в противном случае функция вернёт максимально возможное количество подстрок. Значение по умолчанию: `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив подстрок, полученных из `s`. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByRegexp('\\d+', 'a12bc23de345f');
```

```response title=Response
┌─splitByRegex⋯c23de345f')─┐
│ ['a12bc23de345f']        │
└──────────────────────────┘
```

**Пустое регулярное выражение**

```sql title=Query
SELECT splitByRegexp('', 'abcde');
```

```response title=Response
┌─splitByRegexp('', 'abcde')─┐
│ ['a','b','c','d','e']      │
└────────────────────────────┘
```

## splitByString \{#splitByString\}

Впервые представлена в: v1.1

Разбивает строку с константным разделителем `separator`, состоящим из нескольких символов, на массив подстрок.
Если строка `separator` пуста, строка `s` будет разбита на массив отдельных символов.

Пустые подстроки могут получаться в следующих случаях:

* Непустой разделитель находится в начале или в конце строки
* Есть несколько последовательных непустых разделителей
* Исходная строка `s` пуста, а разделитель не пуст

:::note
Параметр [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (значение по умолчанию: `0`) определяет, включается ли оставшаяся часть строки в последний элемент результирующего массива, когда аргумент `max_substrings > 0`.
:::

**Синтаксис**

```sql
splitByString(separator, s[, max_substrings])
```

**Аргументы**

* `separator` — разделитель. [`String`](/sql-reference/data-types/string)
* `s` — строка, которую нужно разбить. [`String`](/sql-reference/data-types/string)
* `max_substrings` — необязательный параметр. Если `max_substrings > 0`, количество возвращаемых подстрок не превышает `max_substrings`, иначе функция вернёт максимально возможное количество подстрок. Значение по умолчанию: `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив выбранных подстрок строки `s` [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByString(', ', '1, 2 3, 4,5, abcde');
```

```response title=Response
┌─splitByStrin⋯4,5, abcde')─┐
│ ['1','2 3','4,5','abcde'] │
└───────────────────────────┘
```

**Пустой разделитель**

```sql title=Query
SELECT splitByString('', 'abcde');
```

```response title=Response
┌─splitByString('', 'abcde')─┐
│ ['a','b','c','d','e']      │
└────────────────────────────┘
```

## splitByWhitespace \{#splitByWhitespace\}

Введена в: v21.9

Разбивает строку, разделённую пробельными символами, на массив подстрок.

:::note
Параметр [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) определяет, включается ли оставшаяся часть строки в последний элемент результирующего массива при аргументе `max_substrings > 0`.
:::

**Синтаксис**

```sql
splitByWhitespace(s[, max_substrings])
```

**Аргументы**

* `s` — Строка, которую нужно разделить. [`String`](/sql-reference/data-types/string)
* `max_substrings` — Необязательный параметр. Если `max_substrings > 0`, количество возвращаемых подстрок не превышает `max_substrings`, в противном случае функция вернёт максимально возможное количество подстрок. Значение по умолчанию: `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив выбранных подстрок строки `s`. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByWhitespace('  1!  a,  b.  ');
```

```response title=Response
['1!','a,','b.']
```

## tokens \{#tokens\}

Добавлена в: v21.11

Разбивает строку на токены с использованием указанного токенайзера.

Доступные токенайзеры:

* `splitByNonAlpha` разбивает строки по неалфавитно-цифровым ASCII-символам (см. также функцию [splitByNonAlpha](/sql-reference/functions/splitting-merging-functions.md/#splitByNonAlpha)).
* `splitByString(S)` разбивает строки по определённым пользовательским строкам-разделителям `S` (см. также функцию [splitByString](/sql-reference/functions/splitting-merging-functions.md/#splitByString)). Разделители можно задать с помощью необязательного параметра, например, `tokenizer = splitByString([', ', '; ', '\n', '\\'])`. Обратите внимание, что каждая строка может состоять из нескольких символов (`', '` в примере). Список разделителей по умолчанию, если он не задан явно (например, `tokenizer = splitByString`), — это один пробел `[' ']`.
* `ngrams(N)` разбивает строки на одинаковые по размеру `N`-граммы (см. также функцию [ngrams](/sql-reference/functions/splitting-merging-functions.md/#ngrams)). Длину n-граммы можно задать с помощью необязательного целочисленного параметра от 1 до 8, например, `tokenizer = ngrams(3)`. Размер n-граммы по умолчанию, если он не задан явно (например, `tokenizer = ngrams`), равен 3.
* `sparseGrams(min_length, max_length, min_cutoff_length)` разбивает строки на n-граммы переменной длины как минимум из `min_length` и не более чем из `max_length` (включительно) символов (см. также функцию [sparseGrams](/sql-reference/functions/string-functions#sparseGrams)). Если не указано явно, значения `min_length` и `max_length` по умолчанию равны 3 и 100. Если передан параметр `min_cutoff_length`, возвращаются только n-граммы с длиной не меньше `min_cutoff_length`. По сравнению с `ngrams(N)` токенайзер `sparseGrams` создаёт n-граммы переменной длины, что позволяет более гибко представлять исходный текст. Например, `tokenizer = sparseGrams(3, 5, 4)` внутренне формирует 3-, 4-, 5-граммы из входной строки, но возвращаются только 4- и 5-граммы.
* `array` не выполняет токенизацию, то есть каждое значение в строке (элемент массива) является токеном (см. также функцию [array](/sql-reference/functions/array-functions.md/#array)).

В случае токенайзера `splitByString`, если токены не образуют [префиксный код](https://en.wikipedia.org/wiki/Prefix_code), вам, вероятно, нужно, чтобы при сопоставлении более длинные разделители имели приоритет.
Для этого передавайте разделители в порядке убывания длины.
Например, при separators = `['%21', '%']` строка `%21abc` будет токенизирована как `['abc']`, тогда как при separators = `['%', '%21']` она будет токенизирована как `['21ac']` (что, вероятно, не соответствует ожидаемому результату).

**Синтаксис**

```sql
tokens(value) -- 'splitByNonAlpha' tokenizer
tokens(value, 'splitByNonAlpha')
tokens(value, 'splitByString'[, separators])
tokens(value, 'ngrams'[, n])
tokens(value, 'sparseGrams'[, min_length, max_length[, min_cutoff_length]])
tokens(value, 'array')
```

**Аргументы**

* `value` — Входная строка. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `tokenizer` — Токенизатор, который будет использоваться. Допустимые аргументы: `splitByNonAlpha`, `ngrams`, `splitByString`, `array` и `sparseGrams`. Необязательный параметр; если явно не задан, по умолчанию используется `splitByNonAlpha`. [`const String`](/sql-reference/data-types/string)
* `n` — Используется только если аргумент `tokenizer` равен `ngrams`: необязательный параметр, определяющий длину n-грамм. Если явно не задан, по умолчанию используется значение `3`. [`const UInt8`](/sql-reference/data-types/int-uint)
* `separators` — Используется только если аргумент `tokenizer` равен `split`: необязательный параметр, определяющий строки-разделители. Если явно не задан, по умолчанию используется `[' ']`. [`const Array(String)`](/sql-reference/data-types/array)
* `min_length` — Используется только если аргумент `tokenizer` равен `sparseGrams`: необязательный параметр, определяющий минимальную длину граммы, по умолчанию `3`. [`const UInt8`](/sql-reference/data-types/int-uint)
* `max_length` — Используется только если аргумент `tokenizer` равен `sparseGrams`: необязательный параметр, определяющий максимальную длину граммы, по умолчанию `100`. [`const UInt8`](/sql-reference/data-types/int-uint)
* `min_cutoff_length` — Используется только если аргумент `tokenizer` равен `sparseGrams`: необязательный параметр, определяющий минимальную длину отсечения. [`const UInt8`](/sql-reference/data-types/int-uint)

**Returned value**

Возвращает массив токенов, полученный из входной строки. [`Array`](/sql-reference/data-types/array)

**Examples**

**Default tokenizer**

```sql title=Query
SELECT tokens('test1,;\\\\ test2,;\\\\ test3,;\\\\   test4') AS tokens;
```

```response title=Response
['test1','test2','test3','test4']
```

**Токенизатор N-грамм**

```sql title=Query
SELECT tokens('abc def', 'ngrams', 3) AS tokens;
```

```response title=Response
['abc','bc ','c d',' de','def']
```

{/*AUTOGENERATED_END*/ }

---
description: 'Документация по функциям разбиения строк'
sidebar_label: 'Разбиение строк'
slug: /sql-reference/functions/splitting-merging-functions
title: 'Функции разбиения строк'
doc_type: 'reference'
---

import DeprecatedBadge from '@theme/badges/DeprecatedBadge';

# Функции для разделения строк \{#functions-for-splitting-strings\}

:::note
Документация ниже генерируется из системной таблицы `system.functions`.
:::

{/* 
  Внутреннее содержимое тегов ниже при сборке фреймворка документации
  заменяется документацией, сгенерированной из system.functions. Не изменяйте и не удаляйте эти теги.
  См. https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }


## alphaTokens \{#alphaTokens\}

Введена в версии v1.1

Выбирает подстроки из последовательностей подряд идущих байт в диапазонах `a-z` и `A-Z` и возвращает массив этих подстрок.

**Синтаксис**

```sql
alphaTokens(s[, max_substrings])
```

**Псевдонимы**: `splitByAlpha`

**Аргументы**

* `s` — строка, которую нужно разбить. [`String`](/sql-reference/data-types/string)
* `max_substrings` — необязательный параметр. Если `max_substrings > 0`, количество возвращаемых подстрок не будет превышать `max_substrings`, в противном случае функция вернёт максимально возможное количество подстрок. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив полученных подстрок `s`. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT alphaTokens('abca1abc');
```

```response title=Response
┌─alphaTokens('abca1abc')─┐
│ ['abca','abc']          │
└─────────────────────────┘
```


## arrayStringConcat \{#arrayStringConcat\}

Добавлено в: v1.1

Объединяет строковые представления значений, перечисленных в массиве, с указанным разделителем. Разделитель является необязательным параметром, по умолчанию — пустая строка.

**Синтаксис**

```sql
arrayStringConcat(arr[, separator])
```

**Аргументы**

* `arr` — Массив для конкатенации. [`Array(T)`](/sql-reference/data-types/array)
* `separator` — Необязательный параметр. Строка-разделитель. По умолчанию — пустая строка. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает конкатенированную строку. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayStringConcat(['12/05/2021', '12:50:00'], ' ') AS DateString;
```

```response title=Response
┌─DateString──────────┐
│ 12/05/2021 12:50:00 │
└─────────────────────┘
```


## extractAllGroupsVertical \{#extractAllGroupsVertical\}

Впервые появилась в: v20.5

Находит все группы в строке с использованием регулярного выражения и возвращает массив массивов, где каждый внутренний массив содержит фрагменты, соответствующие каждой группе, упорядоченные по их появлению во входной строке.

**Синтаксис**

```sql
extractAllGroupsVertical(s, regexp)
```

**Псевдонимы**: `extractAllGroups`

**Аргументы**

* `s` — Входная строка, из которой выполняется извлечение. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — Регулярное выражение для сопоставления. [`const String`](/sql-reference/data-types/string) или [`const FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Возвращает массив массивов, где каждый внутренний массив содержит группы захвата для одного совпадения. Каждое совпадение возвращает массив с элементами, соответствующими группам захвата в регулярном выражении (группа 1, группа 2 и т. д.). Если совпадения не найдены, возвращается пустой массив. [`Array(Array(String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsVertical(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```


## ngrams \{#ngrams\}

Появилась в версии v21.11

Разбивает строку в кодировке UTF-8 на n-граммы длиной `N`.

**Синтаксис**

```sql
ngrams(s, N)
```

**Аргументы**

* `s` — входная строка. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `N` — длина n-граммы. [`const UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив n-грамм. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT ngrams('ClickHouse', 3);
```

```response title=Response
['Cli','lic','ick','ckH','kHo','Hou','ous','use']
```


## splitByChar \{#splitByChar\}

Введена в версии v1.1

Разбивает строку на массив подстрок по указанному константному разделителю `separator`, который должен состоять ровно из одного символа.
Пустые подстроки могут присутствовать, если разделитель встречается в начале или конце строки или если есть несколько последовательных разделителей.

:::note
Параметр [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) определяет, будет ли оставшаяся часть строки включена в последний элемент результирующего массива, когда аргумент `max_substrings > 0`.
:::

Пустые подстроки могут присутствовать, когда:

* Разделитель встречается в начале или конце строки
* Есть несколько последовательных разделителей
* Исходная строка `s` пуста

**Синтаксис**

```sql
splitByChar(separator, s[, max_substrings])
```

**Аргументы**

* `separator` — Разделитель должен быть однобайтовым символом. [`String`](/sql-reference/data-types/string)
* `s` — Строка, которую нужно разбить. [`String`](/sql-reference/data-types/string)
* `max_substrings` — Необязательный аргумент. Если `max_substrings > 0`, возвращаемый массив будет содержать не более `max_substrings` подстрок, в противном случае функция вернёт максимально возможное количество подстрок. Значение по умолчанию — `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив полученных подстрок. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByChar(',', '1,2,3,abcde');
```

```response title=Response
┌─splitByChar(⋯2,3,abcde')─┐
│ ['1','2','3','abcde']    │
└──────────────────────────┘
```


## splitByNonAlpha \{#splitByNonAlpha\}

Введена в версии v21.9

Разбивает строку, разделённую пробельными символами и знаками пунктуации, на массив подстрок.

:::note
Настройка [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) определяет, включается ли оставшаяся часть строки в последний элемент результирующего массива, когда аргумент `max_substrings > 0`.
:::

**Синтаксис**

```sql
splitByNonAlpha(s[, max_substrings])
```

**Аргументы**

* `s` — строка для разбиения. [`String`](/sql-reference/data-types/string)
* `max_substrings` — необязательный параметр. Если `max_substrings > 0`, количество возвращаемых подстрок не будет превышать `max_substrings`, в противном случае функция вернёт максимально возможное количество подстрок. Значение по умолчанию: `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив выбранных подстрок строки `s`. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByNonAlpha('user@domain.com');
```

```response title=Response
['user','domain','com']
```


## splitByRegexp \{#splitByRegexp\}

Добавлена в версии v21.6

Разбивает строку, разделённую с помощью заданного регулярного выражения, на массив подстрок.
Если заданное регулярное выражение пустое, строка будет разбита на массив отдельных символов.
Если соответствий регулярному выражению не найдено, строка не будет разбита.

Пустые подстроки могут появляться в следующих случаях:

* в начале или в конце строки найдено непустое соответствие регулярному выражению
* найдено несколько последовательных непустых соответствий регулярному выражению
* исходная строка пуста, а регулярное выражение не пустое.

:::note
Параметр [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) определяет, будет ли оставшаяся строка включена в последний элемент результирующего массива, когда аргумент `max_substrings > 0`.
:::

**Синтаксис**

```sql
splitByRegexp(regexp, s[, max_substrings])
```

**Аргументы**

* `regexp` — регулярное выражение. Константа. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `s` — строка для разбиения. [`String`](/sql-reference/data-types/string)
* `max_substrings` — необязательный параметр. Если `max_substrings > 0`, количество возвращаемых подстрок не превышает `max_substrings`, в противном случае функция вернёт как можно больше подстрок. Значение по умолчанию: `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив выбранных подстрок строки `s`. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByRegexp('\\d+', 'a12bc23de345f');
```

```response title=Response
┌─splitByRegex⋯c23de345f')─┐
│ ['a12bc23de345f']        │
└──────────────────────────┘
```

**Пустое регулярное выражение**

```sql title=Query
SELECT splitByRegexp('', 'abcde');
```

```response title=Response
┌─splitByRegexp('', 'abcde')─┐
│ ['a','b','c','d','e']      │
└────────────────────────────┘
```


## splitByString \{#splitByString\}

Введена в версии v1.1

Разбивает строку с константным разделителем `separator`, состоящим из нескольких символов, на массив подстрок.
Если строка `separator` пуста, строка `s` будет разбита на массив отдельных символов.

Пустые подстроки могут появляться, когда:

* Непустой разделитель находится в начале или в конце строки
* Есть несколько подряд идущих непустых разделителей
* Исходная строка `s` пуста, а разделитель непустой

:::note
Параметр [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) определяет, включается ли оставшаяся часть строки в последний элемент результирующего массива, когда аргумент `max_substrings > 0`.
:::

**Синтаксис**

```sql
splitByString(separator, s[, max_substrings])
```

**Аргументы**

* `separator` — разделитель. [`String`](/sql-reference/data-types/string)
* `s` — строка для разбиения. [`String`](/sql-reference/data-types/string)
* `max_substrings` — необязательный аргумент. Если `max_substrings > 0`, количество возвращаемых подстрок не превышает `max_substrings`, в противном случае функция вернёт максимально возможное количество подстрок. Значение по умолчанию: `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив выбранных подстрок строки `s` [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByString(', ', '1, 2 3, 4,5, abcde');
```

```response title=Response
┌─splitByStrin⋯4,5, abcde')─┐
│ ['1','2 3','4,5','abcde'] │
└───────────────────────────┘
```

**Пустой разделитель**

```sql title=Query
SELECT splitByString('', 'abcde');
```

```response title=Response
┌─splitByString('', 'abcde')─┐
│ ['a','b','c','d','e']      │
└────────────────────────────┘
```


## splitByWhitespace \{#splitByWhitespace\}

Добавлено в: v21.9

Разбивает строку, разделённую пробельными символами, на массив подстрок.

:::note
Настройка [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (по умолчанию: `0`) определяет, должна ли оставшаяся часть строки включаться в последний элемент результирующего массива, когда `max_substrings > 0`.
:::

**Синтаксис**

```sql
splitByWhitespace(s[, max_substrings])
```

**Аргументы**

* `s` — Строка для разделения. [`String`](/sql-reference/data-types/string)
* `max_substrings` — Необязательный аргумент. Когда `max_substrings > 0`, количество возвращаемых подстрок не превышает `max_substrings`, в противном случае функция вернёт максимально возможное количество подстрок. Значение по умолчанию: `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив полученных подстрок `s`. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT splitByWhitespace('  1!  a,  b.  ');
```

```response title=Response
['1!','a,','b.']
```


## tokens \\{#tokens\\}

Появилась в: v21.11

Разбивает строку на токены с использованием заданного токенизатора.

Доступные токенизаторы:

* `splitByNonAlpha` разбивает строки по небуквенно-цифровым символам ASCII (см. также функцию [splitByNonAlpha](/sql-reference/functions/splitting-merging-functions.md/#splitByNonAlpha)).
* `splitByString(S)` разбивает строки по определённым строкам-разделителям `S`, задаваемым пользователем (см. также функцию [splitByString](/sql-reference/functions/splitting-merging-functions.md/#splitByString)). Разделители можно указать с помощью необязательного параметра, например, `tokenizer = splitByString([', ', '; ', '\n', '\\'])`. Обратите внимание, что каждая строка может состоять из нескольких символов (`', '` в примере). Список разделителей по умолчанию, если он не задан явно (например, `tokenizer = splitByString`), представляет собой одиночный пробел `[' ']`.
* `ngrams(N)` разбивает строки на `N`-граммы одинакового размера (см. также функцию [ngrams](/sql-reference/functions/splitting-merging-functions.md/#ngrams)). Длину n-граммы можно задать с помощью необязательного целочисленного параметра от 1 до 8, например, `tokenizer = ngrams(3)`. Размер n-граммы по умолчанию, если он не задан явно (например, `tokenizer = ngrams`), равен 3.
* `sparseGrams(min_length, max_length, min_cutoff_length)` разбивает строки на n-граммы переменной длины не менее `min_length` и не более `max_length` (включительно) символов (см. также функцию [sparseGrams](/sql-reference/functions/string-functions#sparseGrams)). Если явно не указано иное, `min_length` и `max_length` по умолчанию равны 3 и 100. Если задан параметр `min_cutoff_length`, возвращаются только n-граммы с длиной не менее `min_cutoff_length`. По сравнению с `ngrams(N)` токенизатор `sparseGrams` генерирует n-граммы переменной длины, что обеспечивает более гибкое представление исходного текста. Например, `tokenizer = sparseGrams(3, 5, 4)` внутренне формирует 3-, 4-, 5-граммы из входной строки, но возвращаются только 4- и 5-граммы.
* `array` не выполняет токенизацию, т.е. каждое значение строки является токеном (см. также функцию [array](/sql-reference/functions/array-functions.md/#array)).

В случае токенизатора `splitByString`, если токены не образуют [префиксный код](https://en.wikipedia.org/wiki/Prefix_code), вам, вероятно, нужно, чтобы при сопоставлении более длинные разделители имели приоритет.
Для этого передавайте разделители в порядке убывания длины.
Например, при separators = `['%21', '%']` строка `%21abc` будет разбита на токены как `['abc']`, тогда как при separators = `['%', '%21']` она будет разбита на токены как `['21ac']` (что, вероятно, не то, чего вы хотели).

**Синтаксис**

```sql
tokens(value) -- 'splitByNonAlpha' tokenizer
tokens(value, 'splitByNonAlpha')
tokens(value, 'splitByString'[, separators])
tokens(value, 'ngrams'[, n])
tokens(value, 'sparseGrams'[, min_length, max_length[, min_cutoff_length]])
tokens(value, 'array')
```

**Аргументы**


* `value` — Входная строка. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
* `tokenizer` — Используемый токенизатор. Допустимые значения: `splitByNonAlpha`, `ngrams`, `splitByString`, `array` и `sparseGrams`. Необязательный параметр — если не задан явно, по умолчанию используется `splitByNonAlpha`. [`const String`](/sql-reference/data-types/string)
* `n` — Актуален только если аргумент `tokenizer` равен `ngrams`: необязательный параметр, задающий длину n-грамм. Если не задан явно, по умолчанию равен `3`. [`const UInt8`](/sql-reference/data-types/int-uint)
* `separators` — Актуален только если аргумент `tokenizer` равен `split`: необязательный параметр, задающий строки-разделители. Если не задан явно, по умолчанию равен `[' ']`. [`const Array(String)`](/sql-reference/data-types/array)
* `min_length` — Актуален только если аргумент `tokenizer` равен `sparseGrams`: необязательный параметр, задающий минимальную длину граммы, по умолчанию 3. [`const UInt8`](/sql-reference/data-types/int-uint)
* `max_length` — Актуален только если аргумент `tokenizer` равен `sparseGrams`: необязательный параметр, задающий максимальную длину граммы, по умолчанию 100. [`const UInt8`](/sql-reference/data-types/int-uint)
* `min_cutoff_length` — Актуален только если аргумент `tokenizer` равен `sparseGrams`: необязательный параметр, задающий минимальную длину для отсечения. [`const UInt8`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив токенов, полученный из входной строки. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Токенизатор по умолчанию**

```sql title=Query
SELECT tokens('test1,;\\\\ test2,;\\\\ test3,;\\\\   test4') AS tokens;
```

```response title=Response
['test1','test2','test3','test4']
```

**Токенизатор n-грамм**

```sql title=Query
SELECT tokens('abc def', 'ngrams', 3) AS tokens;
```

```response title=Response
['abc','bc ','c d',' de','def']
```

<!--AUTOGENERATED_END-->

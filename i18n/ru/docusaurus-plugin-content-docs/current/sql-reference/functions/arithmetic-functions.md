---
description: 'Справочник по арифметическим функциям'
sidebar_label: 'Арифметика'
slug: /sql-reference/functions/arithmetic-functions
title: 'Арифметические функции'
doc_type: 'reference'
---

# Арифметические функции \\{#arithmetic-functions\\}

## Обзор \\{#overview\\}

Арифметические функции работают для любых двух операндов типов `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, `Float32` или `Float64`.

Перед выполнением операции оба операнда приводятся к типу результата. Тип результата определяется следующим образом (если иное не указано
в документации по функции ниже):

* Если оба операнда имеют разрядность не более 32 бит, размер типа результата будет равен размеру следующего более крупного типа по сравнению с большим из двух
  операндов (promotion целочисленного размера). Например, `UInt8 + UInt16 = UInt32` или `Float32 * Float32 = Float64`.
* Если один из операндов имеет разрядность 64 бита или больше, размер типа результата будет таким же, как размер большего из двух операндов. Например,
  `UInt32 + UInt128 = UInt128` или `Float32 * Float64 = Float64`.
* Если один из операндов является знаковым типом, тип результата также будет знаковым, в противном случае — беззнаковым. Например, `UInt32 * Int32 = Int64`.

Эти правила гарантируют, что тип результата будет наименьшим типом, который может представлять все возможные результаты. Хотя это и создаёт риск
переполнения около границ диапазона значений, оно обеспечивает быстрое выполнение вычислений с использованием максимальной нативной целочисленной
разрядности в 64 бита. Такое поведение также гарантирует совместимость со многими другими базами данных, которые предоставляют 64-битные целые числа
(BIGINT) как максимальный целочисленный тип.

Пример:

```sql
SELECT toTypeName(0), toTypeName(0 + 0), toTypeName(0 + 0 + 0), toTypeName(0 + 0 + 0 + 0)
```

```text
┌─toTypeName(0)─┬─toTypeName(plus(0, 0))─┬─toTypeName(plus(plus(0, 0), 0))─┬─toTypeName(plus(plus(plus(0, 0), 0), 0))─┐
│ UInt8         │ UInt16                 │ UInt32                          │ UInt64                                   │
└───────────────┴────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┘
```

Переполнения возникают так же, как в C++.

{/* 
  Содержимое приведённых ниже тегов во время сборки фреймворка документации
  заменяется на документы, сгенерированные из system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## abs \\{#abs\\}

Появилось в версии: v1.1

Вычисляет абсолютное значение `x`. Не влияет на результат, если `x` имеет беззнаковый тип. Если `x` имеет знаковый тип, возвращает беззнаковое число.

**Синтаксис**

```sql
abs(x)
```

**Аргументы**

* `x` — число, для которого вычисляется абсолютное значение

**Возвращаемое значение**

Абсолютное значение `x`

**Примеры**

**Пример использования**

```sql title=Query
SELECT abs(-0.5)
```

```response title=Response
0.5
```

## avg2 \\{#avg2\\}

Добавлена в версии: v25.11

Вычисляет и возвращает среднее значение переданных аргументов.
Поддерживает числовые и временные типы.

**Синтаксис**

```sql
avg2(x1, x2])
```

**Аргументы**

* `x1, x2]` — Принимает два значения и вычисляет их среднее.

**Возвращаемое значение**

Возвращает среднее значение переданных аргументов, приведённое к наибольшему совместимому типу.

**Примеры**

**Числовые типы**

```sql title=Query
SELECT avg2(toUInt8(3), 1.0) AS result, toTypeName(result) AS type;
-- Возвращаемый тип — Float64, так как UInt8 необходимо привести к 64-битному типу для сравнения.
```

```response title=Response
┌─result─┬─type────┐
│      2 │ Float64 │
└────────┴─────────┘
```

**Типы Decimal**

```sql title=Query
SELECT avg2(toDecimal32(1, 2), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Типы данных Date**

```sql title=Query
SELECT avg2(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**Типы данных DateTime**

```sql title=Query
SELECT avg2(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Типы данных Time64**

```sql title=Query
SELECT avg2(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```

## byteSwap \\{#byteSwap\\}

Добавлена в: v23.10

Переставляет байты целого числа в обратном порядке, т. е. изменяет его [порядок байтов (endianness)](https://en.wikipedia.org/wiki/Endianness).

Пример ниже можно разобрать следующим образом:

1. Преобразовать десятичное целое число в эквивалентное шестнадцатеричное представление в формате big-endian, т. е. 3351772109 -&gt; C7 C7 FB CD (4 байта)
2. Обратить порядок байт, т. е. C7 C7 FB CD -&gt; CD FB C7 C7
3. Преобразовать результат обратно в целое число, предполагая формат big-endian, т. е. CD FB C7 C7 -&gt; 3455829959

   Один из вариантов использования этой функции — разворот IPv4-адресов:

```result
┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
│ 199.199.251.205                                       │
└───────────────────────────────────────────────────────┘
```

**Синтаксис**

```sql
byteSwap(x)
```

**Аргументы**

* `x` — целочисленное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает `x` с байтами в обратном порядке. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**8-битный**

```sql title=Query
SELECT byteSwap(54)
```

```response title=Response
54
```

**16 бит**

```sql title=Query
SELECT byteSwap(4135)
```

```response title=Response
10000
```

**32-битный**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**64-битный**

```sql title=Query
SELECT byteSwap(123294967295)
```

```response title=Response
18439412204227788800
```

## divide \\{#divide\\}

Добавлена в версии v1.1

Вычисляет частное от двух значений `a` и `b`. Тип результата всегда [Float64](/sql-reference/data-types/float).
Целочисленное деление выполняется функцией `intDiv`.

:::note
Деление на `0` возвращает `inf`, `-inf` или `nan`.
:::

**Синтаксис**

```sql
divide(x, y)
```

**Аргументы**

* `x` — делимое, `y` — делитель

**Возвращаемое значение**

Частное от деления x на y

**Примеры**

**Деление двух чисел**

```sql title=Query
SELECT divide(25,5) AS quotient, toTypeName(quotient)
```

```response title=Response
5 Float64
```

**Деление на ноль**

```sql title=Query
SELECT divide(25,0)
```

```response title=Response
inf
```

## divideDecimal \\{#divideDecimal\\}

Впервые представлена в: v22.12

Выполняет деление двух десятичных чисел. Результирующее значение будет иметь тип [Decimal256](/sql-reference/data-types/decimal).
Масштаб результата может быть явно указан аргументом `result_scale` (константное целое число в диапазоне `[0, 76]`). Если он не указан, масштаб результата равен максимальному масштабу среди переданных аргументов.

:::note
Эти функции работают значительно медленнее, чем обычная `divide`.
Если вам не нужна строго контролируемая точность и/или требуется быстрое выполнение вычислений, рассмотрите использование [divide](#divide).
:::

**Синтаксис**

```sql
divideDecimal(x, y[, result_scale])
```

**Аргументы**

* `x` — первое значение: [Decimal](/sql-reference/data-types/decimal).
* `y` — второе значение: [Decimal](/sql-reference/data-types/decimal).
* `result_scale` — масштаб результата. Тип: [Int/UInt](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Результат деления с указанным масштабом. Тип — [`Decimal256`](/sql-reference/data-types/decimal)

**Примеры**

**Пример 1**

```sql title=Query
divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)
```

```response title=Response
┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐
│                                                -5.7142857142 │
└──────────────────────────────────────────────────────────────┘
```

**Пример 2**

```sql title=Query
SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);
SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);
```

```response title=Response
┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐
│                                             -5.7 │
└──────────────────────────────────────────────────┘
┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐
│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
```

## divideOrNull \\{#divideOrNull\\}

Введена в версии: v25.5

Аналог функции `divide`, но возвращает NULL при делении на ноль.

**Синтаксис**

```sql
divideOrNull(x, y)
```

**Аргументы**

* `x` — делимое, `y` — делитель

**Возвращаемое значение**

Частное от x и y или NULL.

**Примеры**

**Деление на ноль**

```sql title=Query
SELECT divideOrNull(25, 0)
```

```response title=Response
\N
```

## gcd \\{#gcd\\}

Введена в версии v1.1

Возвращает наибольший общий делитель двух значений a и b.

Исключение выбрасывается при делении на ноль или при делении минимального
отрицательного числа на минус один.

**Синтаксис**

```sql
gcd(x, y)
```

**Аргументы**

* `x` — первое целое число, `y` — второе целое число

**Возвращаемое значение**

Наибольший общий делитель `x` и `y`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT gcd(12, 18)
```

```response title=Response
6
```

## ifNotFinite \\{#ifNotFinite\\}

Введена в версии: v20.3

Проверяет, является ли число с плавающей запятой конечным.

Аналогичный результат можно получить с помощью [тернарного оператора](/sql-reference/functions/conditional-functions#if): `isFinite(x) ? x : y`.

**Синтаксис**

```sql
ifNotFinite(x,y)
```

**Аргументы**

* `x` — Значение для проверки, является ли оно бесконечным. [`Float*`](/sql-reference/data-types/float)
* `y` — Альтернативное значение. [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

* `x`, если `x` является конечным.
* `y`, если `x` не является конечным.

**Примеры**

**Пример использования**

```sql title=Query
SELECT 1/0 AS infimum, ifNotFinite(infimum,42)
```

```response title=Response
inf  42
```

## intDiv \\{#intDiv\\}

Введено в: v1.1

Выполняет целочисленное деление двух значений: `x` на `y`. Иными словами,
вычисляет частное, округлённое вниз до ближайшего меньшего целого числа.

Результат имеет ту же разрядность, что и делимое (первый параметр).

Исключение генерируется при делении на ноль, когда частное не помещается
в диапазон значений делимого, или при делении минимального отрицательного числа на минус один.

**Синтаксис**

```sql
intDiv(x, y)
```

**Аргументы**

* `x` — левый операнд. - `y` — правый операнд.

**Возвращаемое значение**

Результат целочисленного деления `x` на `y`.

**Примеры**

**Целочисленное деление двух чисел с плавающей точкой**

```sql title=Query
SELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)
```

```response title=Response
┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐
│ 1000 │ Int64                                   │
└──────┴─────────────────────────────────────────┘
```

**Частное выходит за пределы диапазона делимого**

```sql title=Query
SELECT
intDiv(1, 0.001) AS res,
toTypeName(res)
```

```response title=Response
Получено исключение от сервера (версия 23.2.1):
Код: 153. DB::Exception: Получено от localhost:9000. DB::Exception:
Невозможно выполнить целочисленное деление, поскольку результат будет бесконечным или слишком
большим числом: При обработке intDiv(1, 0.001) AS res, toTypeName(res).
(ILLEGAL_DIVISION)
```

## intDivOrNull \\{#intDivOrNull\\}

Добавлена в: v25.5

То же, что и `intDiv`, но возвращает NULL при делении на ноль или при делении
минимального отрицательного числа на минус один.

**Синтаксис**

```sql
intDivOrNull(x, y)
```

**Аргументы**

* `x` — левый операнд. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `y` — правый операнд. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Результат целочисленного деления `x` на `y`, или NULL.

**Примеры**

**Целочисленное деление на ноль**

```sql title=Query
SELECT intDivOrNull(1, 0)
```

```response title=Response
\N
```

**Деление минимального отрицательного числа на −1**

```sql title=Query
SELECT intDivOrNull(-9223372036854775808, -1)
```

```response title=Response
\N
```

## intDivOrZero \\{#intDivOrZero\\}

Появилась в версии: v1.1

То же, что и `intDiv`, но возвращает ноль при делении на ноль или при делении
минимально возможного отрицательного числа на минус один.

**Синтаксис**

```sql
intDivOrZero(a, b)
```

**Аргументы**

* `a` — левый операнд. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `b` — правый операнд. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Результат целочисленного деления a на b или ноль.

**Примеры**

**Целочисленное деление на ноль**

```sql title=Query
SELECT intDivOrZero(1, 0)
```

```response title=Response
0
```

**Деление на минус 1 минимального отрицательного числа**

```sql title=Query
SELECT intDivOrZero(0.05, -1)
```

```response title=Response
0
```

## isFinite \\{#isFinite\\}

Добавлена в: v1.1

Возвращает `1`, если аргумент типа Float32 или Float64 конечен и не равен `NaN`,
в противном случае функция возвращает `0`.

**Синтаксис**

```sql
isFinite(x)
```

**Аргументы**

* `x` — число, проверяемое на конечность. [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

`1`, если `x` не является бесконечным значением и не равен `NaN`, в противном случае `0`.

**Примеры**

**Проверка, является ли число конечным**

```sql title=Query
SELECT isFinite(inf)
```

```response title=Response
0
```

## isInfinite \\{#isInfinite\\}

Добавлена в: v1.1

Возвращает `1`, если аргумент типа Float32 или Float64 является бесконечным, в противном случае функция возвращает `0`.
Обратите внимание, что для значения `NaN` возвращается `0`.

**Синтаксис**

```sql
isInfinite(x)
```

**Аргументы**

* `x` — число для проверки на бесконечность. [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

`1`, если `x` является бесконечным, иначе `0` (включая `NaN`).

**Примеры**

**Проверка, является ли число бесконечным**

```sql title=Query
SELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))
```

```response title=Response
1 0 0
```

## isNaN \\{#isNaN\\}

Добавлена в: v1.1

Возвращает `1`, если аргумент типов Float32 или Float64 является `NaN`, в противном случае возвращает `0`.

**Синтаксис**

```sql
isNaN(x)
```

**Аргументы**

* `x` — аргумент, который проверяется на `NaN`. [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

`1`, если `NaN`, иначе `0`

**Примеры**

**Пример использования**

```sql title=Query
SELECT isNaN(NaN)
```

```response title=Response
1
```

## lcm \\{#lcm\\}

Добавлена в: v1.1

Возвращает наименьшее общее кратное двух значений `x` и `y`.

Исключение выбрасывается при делении на ноль или при делении минимального отрицательного значения на минус один.

**Синтаксис**

```sql
lcm(x, y)
```

**Аргументы**

* `x` — Первое целое число. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `y` — Второе целое число. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает наименьшее общее кратное `x` и `y`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT lcm(6, 8)
```

```response title=Response
24
```

## max2 \\{#max2\\}

Добавлена в версии: v21.11

Возвращает большее из двух числовых значений `x` и `y`.

**Синтаксис**

```sql
max2(x, y)
```

**Аргументы**

* `x` — первое значение [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float), или [`Decimal`](/sql-reference/data-types/decimal)
* `y` — второе значение [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float), или [`Decimal`](/sql-reference/data-types/decimal)

**Возвращаемое значение**

Возвращает большее из значений `x` и `y`. Тип результата — [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT max2(-1, 2)
```

```response title=Response
2
```

## midpoint \\{#midpoint\\}

Появилась в версии: v25.11

Вычисляет и возвращает среднее значение переданных аргументов.
Поддерживает числовые и временные типы.

**Синтаксис**

```sql
midpoint(x1[, x2, ...])
```

**Аргументы**

* `x1[, x2, ...]` — Принимает одно или несколько значений, по которым вычисляется среднее.

**Возвращаемое значение**

Возвращает среднее значение переданных аргументов, приведённое к наибольшему совместимому типу.

**Примеры**

**Числовые типы**

```sql title=Query
SELECT midpoint(1, toUInt8(3), 0.5) AS result, toTypeName(result) AS type;
-- Возвращаемый тип — Float64, так как UInt8 необходимо привести к 64-битному типу для сравнения.
```

```response title=Response
┌─result─┬─type────┐
│    1.5 │ Float64 │
└────────┴─────────┘
```

**Десятичные типы**

```sql title=Query
SELECT midpoint(toDecimal32(1.5, 2), toDecimal32(1, 1), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Типы данных Date**

```sql title=Query
SELECT midpoint(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**Типы данных DateTime**

```sql title=Query
SELECT midpoint(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Типы данных Time64**

```sql title=Query
SELECT midpoint(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```

## min2 \\{#min2\\}

Добавлена в версии v21.11.

Возвращает наименьшее из двух числовых значений `x` и `y`.

**Синтаксис**

```sql
min2(x, y)
```

**Аргументы**

* `x` — первое значение [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)
* `y` — второе значение [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Возвращаемое значение**

Возвращает меньшее значение из `x` и `y`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT min2(-1, 2)
```

```response title=Response
-1
```

## minus \\{#minus\\}

Добавлено в версии: v1.1

Вычисляет разность двух значений `a` и `b`. Результат всегда знаковый.
Аналогично функции plus, можно вычитать целое число из даты или даты со временем.
Также поддерживается вычитание дат со временем, в результате чего получается разница во времени между ними.

**Синтаксис**

```sql
minus(x, y)
```

**Аргументы**

* `x` — уменьшаемое.
* `y` — вычитаемое.

**Возвращаемое значение**

x минус y

**Примеры**

**Вычитание двух чисел**

```sql title=Query
SELECT minus(10, 5)
```

```response title=Response
5
```

**Вычитание целого числа из даты**

```sql title=Query
SELECT minus(toDate('2025-01-01'),5)
```

```response title=Response
2024-12-27
```

## modulo \\{#modulo\\}

Введена в версии: v1.1

Вычисляет остаток от деления двух значений a на b.

Тип результата — целое число, если оба аргумента являются целыми. Если
один из аргументов является числом с плавающей запятой, то тип результата — Float64.

Остаток вычисляется так же, как в C++. Для отрицательных чисел используется усечённое деление.

Исключение генерируется при делении на ноль или при делении минимального
отрицательного числа на минус один.

**Синтаксис**

```sql
modulo(a, b)
```

**Псевдонимы**: `mod`

**Аргументы**

* `a` — делимое
* `b` — делитель (модуль)

**Возвращаемое значение**

Остаток от `a % b`

**Примеры**

**Пример использования**

```sql title=Query
SELECT modulo(5, 2)
```

```response title=Response
1
```

## moduloOrNull \\{#moduloOrNull\\}

Впервые появилась в версии v25.5

Вычисляет остаток от деления `a` на `b`. Аналогична функции `modulo`, за исключением того, что `moduloOrNull` возвращает NULL,
если правый аргумент равен 0.

**Синтаксис**

```sql
moduloOrNull(x, y)
```

**Псевдонимы**: `modOrNull`

**Аргументы**

* `x` — Делимое. [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)
* `y` — Делитель (модуль). [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

Возвращает остаток от деления `x` на `y` или `NULL`, если делитель равен нулю.

**Примеры**

**moduloOrNull при делении на ноль**

```sql title=Query
SELECT moduloOrNull(5, 0)
```

```response title=Response
\N
```

## moduloOrZero \\{#moduloOrZero\\}

Введена в версии v20.3

Подобна `modulo`, но возвращает ноль, когда делитель равен нулю, в отличие от функции `modulo`, которая в этом случае генерирует исключение.

**Синтаксис**

```sql
moduloOrZero(a, b)
```

**Аргументы**

* `a` — делимое. [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)
* `b` — делитель (модуль деления). [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

Возвращает остаток от `a % b` или `0`, если делитель равен `0`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT moduloOrZero(5, 0)
```

```response title=Response
0
```

## multiply \\{#multiply\\}

Добавлена в версии: v1.1

Вычисляет произведение двух значений `x` и `y`.

**Синтаксис**

```sql
multiply(x, y)
```

**Аргументы**

* `x` — множитель. [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)
* `y` — множитель. [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Возвращаемое значение**

Возвращает произведение `x` и `y`.

**Примеры**

**Умножение двух чисел**

```sql title=Query
SELECT multiply(5,5)
```

```response title=Response
25
```

## multiplyDecimal \\{#multiplyDecimal\\}

Добавлена в версии: v22.12

Выполняет операцию умножения над двумя десятичными числами. Значение результата будет иметь тип [Decimal256](/sql-reference/data-types/decimal).
Масштаб результата (scale) может быть явно задан аргументом `result_scale` (константное целочисленное значение типа Integer в диапазоне `[0, 76]`). Если он не задан, масштаб результата равен максимальному масштабу среди указанных аргументов.

:::note
Эти функции работают значительно медленнее, чем обычная `multiply`.
Если вам не требуется контролируемая точность и/или необходима высокая скорость вычислений, рассмотрите возможность использования [multiply](#multiply)
:::

**Синтаксис**

```sql
multiplyDecimal(a, b[, result_scale])
```

**Аргументы**

* `a` — Первое значение. [`Decimal`](/sql-reference/data-types/decimal)
* `b` — Второе значение. [`Decimal`](/sql-reference/data-types/decimal)
* `result_scale` — Масштаб результата. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Результат умножения с заданным масштабом. Тип: [`Decimal256`](/sql-reference/data-types/decimal)

**Примеры**

**Пример использования**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
25.2
```

**Отличия по сравнению с обычным умножением**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                               -26.8609633 │
└───────────────────────────────────────────────────────────┘
┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                                         -26.8609 │
└──────────────────────────────────────────────────────────────────┘
```

**Переполнение десятичного типа**

```sql title=Query
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    multiplyDecimal(a, b);
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    a * b;
```

```response title=Response
┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐
│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │
└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘
Получено исключение от сервера (версия 22.11.1):
Код: 407. DB::Exception: Получено от localhost:9000. DB::Exception: Переполнение при арифметической операции с типом Decimal:
При обработке toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)
```

## negate \\{#negate\\}

Добавлена в: v1.1

Изменяет знак аргумента `x`. Результат всегда знаковый.

**Синтаксис**

```sql
negate(x)
```

**Аргументы**

* `x` — значение, которое нужно изменить на противоположное.

**Возвращаемое значение**

Возвращает -x (противоположное значение x)

**Примеры**

**Пример использования**

```sql title=Query
SELECT negate(10)
```

```response title=Response
-10
```

## plus \\{#plus\\}

Добавлена в: v1.1

Вычисляет сумму двух значений `x` и `y`. Псевдоним: `x + y` (оператор).
Можно складывать целое число с датой или датой и временем. В первом случае
операция увеличивает количество дней в дате, во втором случае
операция увеличивает количество секунд в дате и времени.

**Синтаксис**

```sql
plus(x, y)
```

**Аргументы**

* `x` — левый операнд. - `y` — правый операнд.

**Возвращаемое значение**

Возвращает сумму x и y.

**Примеры**

**Сложение двух чисел**

```sql title=Query
SELECT plus(5,5)
```

```response title=Response
10
```

**Добавление целого числа к дате**

```sql title=Query
SELECT plus(toDate('2025-01-01'),5)
```

```response title=Response
2025-01-06
```

## positiveModulo \\{#positiveModulo\\}

Появилась в: v22.11

Вычисляет остаток от деления `x` на `y`. Функция аналогична
`modulo`, за исключением того, что `positiveModulo` всегда возвращает неотрицательное число.

**Синтаксис**

```sql
positiveModulo(x, y)
```

**Псевдонимы**: `positive_modulo`, `pmod`

**Аргументы**

* `x` — Делимое. [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)
* `y` — Делитель (модуль). [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Возвращаемое значение**

Возвращает разность между `x` и ближайшим целым числом, которое не превосходит `x` и кратно `y`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT positiveModulo(-1, 10)
```

```response title=Response
9
```

## positiveModuloOrNull \\{#positiveModuloOrNull\\}

Введена в версии: v25.5

Вычисляет остаток от деления `a` на `b`. Аналогична функции `positiveModulo`, за исключением того, что `positiveModuloOrNull` вернёт NULL,
если правый аргумент равен 0.

**Синтаксис**

```sql
positiveModuloOrNull(x, y)
```

**Псевдонимы**: `positive_modulo_or_null`, `pmodOrNull`

**Аргументы**

* `x` — Делимое. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).
* `y` — Делитель (модуль). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).

**Возвращаемое значение**

Возвращает разность между `x` и ближайшим целым числом, не превосходящим `x` и кратным `y`, или `null`, если делитель равен нулю.

**Примеры**

**positiveModuloOrNull**

```sql title=Query
SELECT positiveModuloOrNull(5, 0)
```

```response title=Response
\N
```

{/*AUTOGENERATED_END*/ }

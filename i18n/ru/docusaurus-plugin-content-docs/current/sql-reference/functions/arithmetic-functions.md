---
description: 'Справочник по арифметическим функциям'
sidebar_label: 'Арифметика'
slug: /sql-reference/functions/arithmetic-functions
title: 'Арифметические функции'
doc_type: 'reference'
---



# Арифметические функции



## Обзор {#overview}

Арифметические функции работают с любыми двумя операндами типов `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, `Float32` или `Float64`.

Перед выполнением операции оба операнда приводятся к результирующему типу. Результирующий тип определяется следующим образом (если в документации функции ниже не указано иное):

- Если оба операнда имеют разрядность до 32 бит, размер результирующего типа будет равен размеру следующего большего типа относительно большего из двух операндов (повышение разрядности целых чисел). Например, `UInt8 + UInt16 = UInt32` или `Float32 * Float32 = Float64`.
- Если один из операндов имеет разрядность 64 бита или более, размер результирующего типа будет равен размеру большего из двух операндов. Например, `UInt32 + UInt128 = UInt128` или `Float32 * Float64 = Float64`.
- Если один из операндов является знаковым, результирующий тип также будет знаковым, в противном случае он будет беззнаковым. Например, `UInt32 * Int32 = Int64`.

Эти правила гарантируют, что результирующий тип будет наименьшим типом, способным представить все возможные результаты. Хотя это создает риск переполнения на границах диапазона значений, это обеспечивает быстрое выполнение вычислений с использованием максимальной нативной разрядности целых чисел в 64 бита. Такое поведение также гарантирует совместимость со многими другими базами данных, которые предоставляют 64-битные целые числа (BIGINT) в качестве наибольшего целочисленного типа.

Пример:

```sql
SELECT toTypeName(0), toTypeName(0 + 0), toTypeName(0 + 0 + 0), toTypeName(0 + 0 + 0 + 0)
```

```text
┌─toTypeName(0)─┬─toTypeName(plus(0, 0))─┬─toTypeName(plus(plus(0, 0), 0))─┬─toTypeName(plus(plus(plus(0, 0), 0), 0))─┐
│ UInt8         │ UInt16                 │ UInt32                          │ UInt64                                   │
└───────────────┴────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┘
```

Переполнения происходят так же, как в C++.

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## abs {#abs}

Введено в версии: v1.1

Вычисляет абсолютное значение `x`. Не имеет эффекта, если `x` беззнакового типа. Если `x` знакового типа, возвращает беззнаковое число.

**Синтаксис**

```sql
abs(x)
```

**Аргументы**

- `x` — значение, для которого вычисляется абсолютное значение

**Возвращаемое значение**

Абсолютное значение `x`

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT abs(-0.5)
```

```response title=Результат
0.5
```


## avg2 {#avg2}

Введена в версии: v25.11

Вычисляет и возвращает среднее значение переданных аргументов.
Поддерживает числовые и временные типы данных.

**Синтаксис**

```sql
avg2(x1, x2])
```

**Аргументы**

- `x1, x2]` — Принимает два значения для вычисления среднего.

**Возвращаемое значение**

Возвращает среднее значение переданных аргументов с приведением к наибольшему совместимому типу.

**Примеры**

**Числовые типы**

```sql title=Запрос
SELECT avg2(toUInt8(3), 1.0) AS result, toTypeName(result) AS type;
-- Возвращаемый тип — Float64, так как UInt8 должен быть приведён к 64-битному типу для сравнения.
```

```response title=Ответ
┌─result─┬─type────┐
│      2 │ Float64 │
└────────┴─────────┘
```

**Типы Decimal**

```sql title=Запрос
SELECT avg2(toDecimal32(1, 2), 2) AS result, toTypeName(result) AS type;
```

```response title=Ответ
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Типы Date**

```sql title=Запрос
SELECT avg2(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Ответ
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**Типы DateTime**

```sql title=Запрос
SELECT avg2(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Ответ
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Типы Time64**

```sql title=Запрос
SELECT avg2(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Ответ
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```


## byteSwap {#byteSwap}

Введена в версии: v23.10

Изменяет порядок байтов целого числа на обратный, то есть меняет его [порядок следования байтов](https://en.wikipedia.org/wiki/Endianness).

Приведённый ниже пример можно разобрать следующим образом:

1. Преобразовать целое число из десятичной системы счисления в эквивалентный шестнадцатеричный формат big-endian, то есть 3351772109 -> C7 C7 FB CD (4 байта)
2. Изменить порядок байтов на обратный, то есть C7 C7 FB CD -> CD FB C7 C7
3. Преобразовать результат обратно в целое число, предполагая формат big-endian, то есть CD FB C7 C7 -> 3455829959
   Один из вариантов использования этой функции — изменение порядка байтов в IPv4-адресах:

```result
┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
│ 199.199.251.205                                       │
└───────────────────────────────────────────────────────┘
```

**Синтаксис**

```sql
byteSwap(x)
```

**Аргументы**

- `x` — целочисленное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает `x` с обратным порядком байтов. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT byteSwap(3351772109)
```

```response title=Результат
3455829959
```

**8-битное**

```sql title=Запрос
SELECT byteSwap(54)
```

```response title=Результат
54
```

**16-битное**

```sql title=Запрос
SELECT byteSwap(4135)
```

```response title=Результат
10000
```

**32-битное**

```sql title=Запрос
SELECT byteSwap(3351772109)
```

```response title=Результат
3455829959
```

**64-битное**

```sql title=Запрос
SELECT byteSwap(123294967295)
```

```response title=Результат
18439412204227788800
```


## divide {#divide}

Введена в версии: v1.1

Вычисляет частное от деления двух значений `a` и `b`. Тип результата всегда [Float64](/sql-reference/data-types/float).
Целочисленное деление выполняется функцией `intDiv`.

:::note
Деление на `0` возвращает `inf`, `-inf` или `nan`.
:::

**Синтаксис**

```sql
divide(x, y)
```

**Аргументы**

- `x` — делимое
- `y` — делитель

**Возвращаемое значение**

Частное от деления x на y.

**Примеры**

**Деление двух чисел**

```sql title=Query
SELECT divide(25,5) AS quotient, toTypeName(quotient)
```

```response title=Response
5 Float64
```

**Деление на ноль**

```sql title=Query
SELECT divide(25,0)
```

```response title=Response
inf
```


## divideDecimal {#divideDecimal}

Введена в версии: v22.12

Выполняет деление двух десятичных чисел. Результат будет иметь тип [Decimal256](/sql-reference/data-types/decimal).
Масштаб результата может быть явно задан аргументом `result_scale` (константа Integer в диапазоне `[0, 76]`). Если не задан, масштаб результата равен максимальному масштабу из переданных аргументов.

:::note
Эта функция работает значительно медленнее, чем обычная `divide`.
Если вам не требуется контролируемая точность и/или нужны быстрые вычисления, рассмотрите использование [divide](#divide).
:::

**Синтаксис**

```sql
divideDecimal(x, y[, result_scale])
```

**Аргументы**

- `x` — Первое значение: [Decimal](/sql-reference/data-types/decimal).
- `y` — Второе значение: [Decimal](/sql-reference/data-types/decimal).
- `result_scale` — Масштаб результата. Тип [Int/UInt](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Результат деления с заданным масштабом. [`Decimal256`](/sql-reference/data-types/decimal)

**Примеры**

**Пример 1**

```sql title=Query
divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)
```

```response title=Response
┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐
│                                                -5.7142857142 │
└──────────────────────────────────────────────────────────────┘
```

**Пример 2**

```sql title=Query
SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);
SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);
```

```response title=Response
┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐
│                                             -5.7 │
└──────────────────────────────────────────────────┘
┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐
│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
```


## divideOrNull {#divideOrNull}

Введена в версии: v25.5

Работает так же, как `divide`, но возвращает NULL при делении на ноль.

**Синтаксис**

```sql
divideOrNull(x, y)
```

**Аргументы**

- `x` — делимое
- `y` — делитель

**Возвращаемое значение**

Частное от деления x на y или NULL.

**Примеры**

**Деление на ноль**

```sql title=Запрос
SELECT divideOrNull(25, 0)
```

```response title=Результат
\N
```


## gcd {#gcd}

Введено в версии: v1.1

    Возвращает наибольший общий делитель (НОД) двух значений a и b.

    Исключение выбрасывается при делении на ноль или при делении минимального
    отрицательного числа на минус один.

**Синтаксис**

```sql
gcd(x, y)
```

**Аргументы**

- `x` — первое целое число - `y` — второе целое число

**Возвращаемое значение**

Наибольший общий делитель `x` и `y`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT gcd(12, 18)
```

```response title=Response
6
```


## ifNotFinite {#ifNotFinite}

Введена в версии: v20.3

Проверяет, является ли значение с плавающей точкой конечным.

Аналогичный результат можно получить с помощью [тернарного оператора](/sql-reference/functions/conditional-functions#if): `isFinite(x) ? x : y`.

**Синтаксис**

```sql
ifNotFinite(x,y)
```

**Аргументы**

- `x` — проверяемое значение. [`Float*`](/sql-reference/data-types/float)
- `y` — возвращаемое значение, если `x` не является конечным. [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

- `x`, если `x` является конечным.
- `y`, если `x` не является конечным.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT 1/0 AS infimum, ifNotFinite(infimum,42)
```

```response title=Результат
inf  42
```


## intDiv {#intDiv}

Введено в версии: v1.1

Выполняет целочисленное деление значения `x` на `y`. Другими словами,
вычисляет частное, округлённое вниз до ближайшего меньшего целого числа.

Результат имеет ту же разрядность, что и делимое (первый параметр).

Исключение возникает при делении на ноль, когда частное не помещается
в диапазон делимого или при делении минимального отрицательного числа на минус один.

**Синтаксис**

```sql
intDiv(x, y)
```

**Аргументы**

- `x` — Левый операнд. - `y` — Правый операнд.

**Возвращаемое значение**

Результат целочисленного деления `x` на `y`

**Примеры**

**Целочисленное деление двух чисел с плавающей точкой**

```sql title=Запрос
SELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)
```

```response title=Ответ
┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐
│ 1000 │ Int64                                   │
└──────┴─────────────────────────────────────────┘
```

**Частное не помещается в диапазон делимого**

```sql title=Запрос
SELECT
intDiv(1, 0.001) AS res,
toTypeName(res)
```

```response title=Ответ
Received exception from server (version 23.2.1):
Code: 153. DB::Exception: Received from localhost:9000. DB::Exception:
Cannot perform integer division, because it will produce infinite or too
large number: While processing intDiv(1, 0.001) AS res, toTypeName(res).
(ILLEGAL_DIVISION)
```


## intDivOrNull {#intDivOrNull}

Введена в версии: v25.5

Работает так же, как `intDiv`, но возвращает NULL при делении на ноль или при делении
минимального отрицательного числа на минус один.

**Синтаксис**

```sql
intDivOrNull(x, y)
```

**Аргументы**

- `x` — Левый операнд. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — Правый операнд. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Результат целочисленного деления `x` на `y` или NULL.

**Примеры**

**Целочисленное деление на ноль**

```sql title=Запрос
SELECT intDivOrNull(1, 0)
```

```response title=Результат
\N
```

**Деление минимального отрицательного числа на минус 1**

```sql title=Запрос
SELECT intDivOrNull(-9223372036854775808, -1)
```

```response title=Результат
\N
```


## intDivOrZero {#intDivOrZero}

Введена в версии: v1.1

Аналогична `intDiv`, но возвращает ноль при делении на ноль или при делении
минимального отрицательного числа на минус единицу.

**Синтаксис**

```sql
intDivOrZero(a, b)
```

**Аргументы**

- `a` — Левый операнд. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `b` — Правый операнд. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Результат целочисленного деления a на b или ноль.

**Примеры**

**Целочисленное деление на ноль**

```sql title=Запрос
SELECT intDivOrZero(1, 0)
```

```response title=Результат
0
```

**Деление минимального отрицательного числа на минус 1**

```sql title=Запрос
SELECT intDivOrZero(0.05, -1)
```

```response title=Результат
0
```


## isFinite {#isFinite}

Введено в версии: v1.1

Возвращает `1`, если аргумент типа Float32 или Float64 не является бесконечным и не является `NaN`,
в противном случае функция возвращает `0`.

**Синтаксис**

```sql
isFinite(x)
```

**Аргументы**

- `x` — число для проверки на конечность. [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

`1`, если x не является бесконечным и не является `NaN`, в противном случае `0`.

**Примеры**

**Проверка числа на конечность**

```sql title=Query
SELECT isFinite(inf)
```

```response title=Результат
0
```


## isInfinite {#isInfinite}

Введена в версии: v1.1

    Возвращает `1`, если аргумент типа Float32 или Float64 является бесконечным, в противном случае функция возвращает `0`.
    Обратите внимание, что для `NaN` возвращается `0`.

**Синтаксис**

```sql
isInfinite(x)
```

**Аргументы**

- `x` — Число для проверки на бесконечность. [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

`1`, если x бесконечно, в противном случае `0` (в том числе для `NaN`).

**Примеры**

**Проверка числа на бесконечность**

```sql title=Запрос
SELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))
```

```response title=Результат
1 0 0
```


## isNaN {#isNaN}

Введено в версии: v1.1

Возвращает `1`, если аргумент типа Float32 или Float64 равен `NaN`, иначе возвращает `0`.

**Синтаксис**

```sql
isNaN(x)
```

**Аргументы**

- `x` — аргумент для проверки на `NaN`. [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

`1`, если `NaN`, иначе `0`

**Примеры**

**Пример использования**

```sql title=Query
SELECT isNaN(NaN)
```

```response title=Response
1
```


## lcm {#lcm}

Введено в версии: v1.1

Возвращает наименьшее общее кратное двух значений `x` и `y`.

Исключение возникает при делении на ноль или при делении минимального отрицательного числа на минус один.

**Синтаксис**

```sql
lcm(x, y)
```

**Аргументы**

- `x` — первое целое число. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — второе целое число. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Наименьшее общее кратное `x` и `y`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT lcm(6, 8)
```

```response title=Результат
24
```


## max2 {#max2}

Введена в версии: v21.11

    Возвращает большее из двух числовых значений `x` и `y`.

**Синтаксис**

```sql
max2(x, y)
```

**Аргументы**

- `x` — первое значение [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)
- `y` — второе значение [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Возвращаемое значение**

Большее из значений `x` и `y`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT max2(-1, 2)
```

```response title=Результат
2
```


## midpoint {#midpoint}

Введена в версии: v25.11

Вычисляет и возвращает среднее значение переданных аргументов.
Поддерживает числовые и временные типы данных.

**Синтаксис**

```sql
midpoint(x1[, x2, ...])
```

**Аргументы**

- `x1[, x2, ...]` — принимает одно или несколько значений для вычисления среднего.

**Возвращаемое значение**

Возвращает среднее значение переданных аргументов с приведением к наибольшему совместимому типу.

**Примеры**

**Числовые типы**

```sql title=Запрос
SELECT midpoint(1, toUInt8(3), 0.5) AS result, toTypeName(result) AS type;
-- Возвращаемый тип — Float64, так как UInt8 должен быть приведён к 64-битному типу для вычисления.
```

```response title=Результат
┌─result─┬─type────┐
│    1.5 │ Float64 │
└────────┴─────────┘
```

**Типы Decimal**

```sql title=Запрос
SELECT midpoint(toDecimal32(1.5, 2), toDecimal32(1, 1), 2) AS result, toTypeName(result) AS type;
```

```response title=Результат
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Типы Date**

```sql title=Запрос
SELECT midpoint(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Результат
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**Типы DateTime**

```sql title=Запрос
SELECT midpoint(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Результат
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Типы Time64**

```sql title=Запрос
SELECT midpoint(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Результат
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```


## min2 {#min2}

Введена в версии: v21.11

    Возвращает меньшее из двух числовых значений `x` и `y`.

**Синтаксис**

```sql
min2(x, y)
```

**Аргументы**

- `x` — первое значение [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)
- `y` — второе значение [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Возвращаемое значение**

Меньшее из значений `x` и `y`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT min2(-1, 2)
```

```response title=Результат
-1
```


## minus {#minus}

Введено в версии: v1.1

Вычисляет разность двух значений `a` и `b`. Результат всегда знаковый.
Аналогично функции plus, можно вычитать целое число из даты или даты со временем.
Также поддерживается вычитание между датами со временем, в результате чего получается временная разница между ними.

**Синтаксис**

```sql
minus(x, y)
```

**Аргументы**

- `x` — Уменьшаемое. - `y` — Вычитаемое.

**Возвращаемое значение**

x минус y

**Примеры**

**Вычитание двух чисел**

```sql title=Запрос
SELECT minus(10, 5)
```

```response title=Результат
5
```

**Вычитание целого числа из даты**

```sql title=Запрос
SELECT minus(toDate('2025-01-01'),5)
```

```response title=Результат
2024-12-27
```


## modulo {#modulo}

Введено в версии: v1.1

    Вычисляет остаток от деления значения a на b.

    Тип результата — целое число, если оба входных значения целые. Если одно из
    входных значений является числом с плавающей точкой, тип результата — Float64.

    Остаток вычисляется так же, как в C++. Для отрицательных чисел используется
    усечённое деление.

    Исключение выбрасывается при делении на ноль или при делении минимального
    отрицательного числа на минус один.

**Синтаксис**

```sql
modulo(a, b)
```

**Псевдонимы**: `mod`

**Аргументы**

- `a` — Делимое
- `b` — Делитель (модуль)

**Возвращаемое значение**

Остаток от деления a % b

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT modulo(5, 2)
```

```response title=Результат
1
```


## moduloOrNull {#moduloOrNull}

Введена в версии: v25.5

Вычисляет остаток от деления `a` на `b`. Аналогична функции `modulo`, за исключением того, что `moduloOrNull` возвращает NULL, если правый аргумент равен 0.

**Синтаксис**

```sql
moduloOrNull(x, y)
```

**Псевдонимы**: `modOrNull`

**Аргументы**

- `x` — Делимое. [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)
- `y` — Делитель (модуль). [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

Возвращает остаток от деления `x` на `y` или NULL, если делитель равен нулю.

**Примеры**

**moduloOrNull при делении на ноль**

```sql title=Запрос
SELECT moduloOrNull(5, 0)
```

```response title=Результат
\N
```


## moduloOrZero {#moduloOrZero}

Введена в версии: v20.3

Работает как функция modulo, но возвращает ноль при делении на ноль вместо исключения, которое генерирует функция modulo.

**Синтаксис**

```sql
moduloOrZero(a, b)
```

**Аргументы**

- `a` — делимое. [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)
- `b` — делитель (модуль). [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

Возвращает остаток от деления a % b или `0`, если делитель равен `0`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT moduloOrZero(5, 0)
```

```response title=Результат
0
```


## multiply {#multiply}

Введена в версии: v1.1

Вычисляет произведение двух значений `x` и `y`.

**Синтаксис**

```sql
multiply(x, y)
```

**Аргументы**

- `x` — множитель. [`(U)Int*`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)
- `y` — множитель. [`(U)Int*`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Возвращаемое значение**

Возвращает произведение `x` и `y`.

**Примеры**

**Умножение двух чисел**

```sql title=Запрос
SELECT multiply(5,5)
```

```response title=Результат
25
```


## multiplyDecimal {#multiplyDecimal}

Введена в версии: v22.12

Выполняет умножение двух десятичных чисел. Результат будет иметь тип [Decimal256](/sql-reference/data-types/decimal).
Масштаб результата может быть явно задан аргументом `result_scale` (целочисленная константа в диапазоне `[0, 76]`). Если не указан, масштаб результата равен максимальному масштабу переданных аргументов.

:::note
Эти функции работают значительно медленнее, чем обычная функция `multiply`.
Если вам не требуется контролируемая точность и/или нужны быстрые вычисления, рассмотрите использование [multiply](#multiply)
:::

**Синтаксис**

```sql
multiplyDecimal(a, b[, result_scale])
```

**Аргументы**

- `a` — первое значение. [`Decimal`](/sql-reference/data-types/decimal)
- `b` — второе значение. [`Decimal`](/sql-reference/data-types/decimal)
- `result_scale` — масштаб результата. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Результат умножения с заданным масштабом. Тип: [`Decimal256`](/sql-reference/data-types/decimal)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Результат
25.2
```

**Отличие от обычного умножения**

```sql title=Запрос
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Результат
┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                               -26.8609633 │
└───────────────────────────────────────────────────────────┘
┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                                         -26.8609 │
└──────────────────────────────────────────────────────────────────┘
```

**Переполнение Decimal**

```sql title=Запрос
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    multiplyDecimal(a, b);
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    a * b;
```

```response title=Результат
┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐
│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │
└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘
Получено исключение от сервера (версия 22.11.1):
Код: 407. DB::Exception: Получено от localhost:9000. DB::Exception: Переполнение при арифметических операциях с Decimal:
При обработке toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)
```


## negate {#negate}

Введено в версии: v1.1

Меняет знак аргумента `x` на противоположный. Результат всегда знаковый.

**Синтаксис**

```sql
negate(x)
```

**Аргументы**

- `x` — Значение, знак которого нужно изменить.

**Возвращаемое значение**

Возвращает `-x` для `x`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT negate(10)
```

```response title=Результат
-10
```


## plus {#plus}

Введено в версии: v1.1

Вычисляет сумму двух значений `x` и `y`. Псевдоним: `x + y` (оператор).
Можно складывать целое число с датой или датой со временем. В первом
случае увеличивается количество дней в дате, во втором —
количество секунд в дате со временем.

**Синтаксис**

```sql
plus(x, y)
```

**Аргументы**

- `x` — Левый операнд.
- `y` — Правый операнд.

**Возвращаемое значение**

Возвращает сумму x и y.

**Примеры**

**Сложение двух чисел**

```sql title=Запрос
SELECT plus(5,5)
```

```response title=Результат
10
```

**Сложение целого числа и даты**

```sql title=Запрос
SELECT plus(toDate('2025-01-01'),5)
```

```response title=Результат
2025-01-06
```


## positiveModulo {#positiveModulo}

Введена в версии: v22.11

Вычисляет остаток от деления `x` на `y`. Аналогична функции
`modulo`, за исключением того, что `positiveModulo` всегда возвращает неотрицательное число.

**Синтаксис**

```sql
positiveModulo(x, y)
```

**Псевдонимы**: `positive_modulo`, `pmod`

**Аргументы**

- `x` — делимое. [`(U)Int*`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)
- `y` — делитель (модуль). [`(U)Int*`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Возвращаемое значение**

Возвращает разность между `x` и ближайшим целым числом, не превышающим
`x`, которое делится на `y`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT positiveModulo(-1, 10)
```

```response title=Результат
9
```


## positiveModuloOrNull {#positiveModuloOrNull}

Введено в версии: v25.5

Вычисляет остаток от деления `a` на `b`. Аналогична функции `positiveModulo`, за исключением того, что `positiveModuloOrNull` возвращает NULL, если правый аргумент равен 0.

**Синтаксис**

```sql
positiveModuloOrNull(x, y)
```

**Псевдонимы**: `positive_modulo_or_null`, `pmodOrNull`

**Аргументы**

- `x` — Делимое. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).
- `y` — Делитель (модуль). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).

**Возвращаемое значение**

Возвращает разность между `x` и ближайшим целым числом, не превышающим `x` и делящимся на `y`; `null`, если делитель равен нулю.

**Примеры**

**positiveModuloOrNull**

```sql title=Запрос
SELECT positiveModuloOrNull(5, 0)
```

```response title=Результат
\N
```

<!--AUTOGENERATED_END-->

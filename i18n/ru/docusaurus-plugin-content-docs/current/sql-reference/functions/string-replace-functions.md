---
description: 'Документация по функциям замены строк'
sidebar_label: 'Замена строк'
slug: /sql-reference/functions/string-replace-functions
title: 'Функции замены строк'
doc_type: 'reference'
keywords: ['замена строк']
---

# Функции замены строк \\{#functions-for-string-replacement\\}

[Общие строковые функции](string-functions.md) и [функции для поиска в строках](string-search-functions.md) описаны отдельно.

:::note
Приведённая ниже документация сгенерирована из системной таблицы `system.functions`.
:::

{/* 
  Внутреннее содержимое тегов ниже заменяется на этапе сборки фреймворка документации
  документацией, сгенерированной из system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## format \\{#format\\}

Добавлено в: v20.1

Форматирует строку шаблона `pattern` с использованием значений (строк, целых чисел и т.д.), перечисленных в аргументах, аналогично форматированию в Python.
Строка шаблона может содержать поля подстановки, заключённые в фигурные скобки `{}`.
Всё, что не заключено в скобки, рассматривается как буквальный текст и копируется в вывод без изменений.
Символ фигурной скобки можно экранировать двумя скобками: `{{` и `}}`.
Имена полей могут быть числами (начиная с нуля) или быть пустыми (тогда им неявно присваиваются последовательно возрастающие номера).

**Синтаксис**

```sql
format(pattern, s0[, s1, ...])
```

**Аргументы**

* `pattern` — Форматная строка, содержащая заполнители. [`String`](/sql-reference/data-types/string)
* `s0[, s1, ...]` — Одно или несколько значений для подстановки в шаблон. [`Any`](/sql-reference/data-types)

**Возвращаемое значение**

Возвращает форматированную строку. [`String`](/sql-reference/data-types/string)

**Примеры**

**Нумерованные заполнители**

```sql title=Query
SELECT format('{1} {0} {1}', 'World', 'Hello')
```

```response title=Response
┌─format('{1} {0} {1}', 'World', 'Hello')─┐
│ Hello World Hello                       │
└─────────────────────────────────────────┘
```

**Неявная нумерация**

```sql title=Query
SELECT format('{} {}', 'Hello', 'World')
```

```response title=Response
┌─format('{} {}', 'Hello', 'World')─┐
│ Hello World                       │
└───────────────────────────────────┘
```

## overlay \\{#overlay\\}

Добавлена в: v24.9

Заменяет часть строки `input` строкой `replace`, начиная с индекса `offset`, отсчёт которого ведётся с 1.

**Синтаксис**

```sql
overlay(s, replace, offset[, length])
```

**Аргументы**

* `s` — Входная строка. [`String`](/sql-reference/data-types/string)
* `replace` — Строка для замены. [`const String`](/sql-reference/data-types/string)
* `offset` — Целочисленный тип `Int` (нумерация с 1). Если `offset` отрицательный, отсчёт ведётся с конца строки `s`. [`Int`](/sql-reference/data-types/int-uint)
* `length` — Необязательный параметр. Целочисленный тип `Int`. `length` задаёт длину фрагмента во входной строке `s`, который требуется заменить. Если `length` не указан, количество байт, удаляемых из `s`, равно длине `replace`; иначе удаляется `length` байт. [`Int`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает строку с выполненной заменой. [`String`](/sql-reference/data-types/string)

**Примеры**

**Базовая замена**

```sql title=Query
SELECT overlay('Мой отец из Мексики.', 'мать', 4) AS res;
```

```response title=Response
┌─res──────────────────────┐
│ Моя мама из Мексики.     │
└──────────────────────────┘
```

**Замена с заданной длиной**

```sql title=Query
SELECT overlay('My father is from Mexico.', 'dad', 4, 6) AS res;
```

```response title=Response
┌─res───────────────────┐
│ My dad is from Mexico.│
└───────────────────────┘
```

## overlayUTF8 \\{#overlayUTF8\\}

Появилась в версии: v24.9

Заменяет часть строки `s` другой строкой `replace`, начиная с позиции `offset` (индексация с 1).
Предполагается, что строка содержит корректный текст в кодировке UTF-8.
Если это предположение нарушено, исключение не выбрасывается, а результат становится неопределённым.

**Синтаксис**

```sql
overlayUTF8(s, replace, offset[, length])
```

**Аргументы**

* `s` — входная строка. [`String`](/sql-reference/data-types/string)
* `replace` — строка для замены. [`const String`](/sql-reference/data-types/string)
* `offset` — целочисленный тип `Int` (нумерация с 1). Если `offset` отрицательный, он отсчитывается от конца входной строки `s`. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — необязательный аргумент. Определяет длину фрагмента во входной строке `s`, который нужно заменить. Если `length` не указан, количество символов, удаляемых из `s`, равно длине `replace`, иначе удаляется `length` символов. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает строку с произведённой заменой. [`String`](/sql-reference/data-types/string)

**Примеры**

**Замена в UTF-8**

```sql title=Query
SELECT overlayUTF8('Mein Vater ist aus Österreich.', 'der Türkei', 20) AS res;
```

```response title=Response
┌─res───────────────────────────┐
│ Mein Vater ist aus der Türkei.│
└───────────────────────────────┘
```

## printf \\{#printf\\}

Добавлено в версии: v24.8

Функция `printf` форматирует заданную строку, подставляя значения (строки, целые числа, числа с плавающей запятой и т. д.), перечисленные в аргументах, аналогично функции printf в C++.
Строка формата может содержать спецификаторы формата, начинающиеся с символа `%`.
Все, что не является символом `%` и следующим за ним спецификатором формата, считается литеральным текстом и копируется в вывод без изменений.
Символ `%` как литерал можно экранировать с помощью `%%`.

**Синтаксис**

```sql
printf(format[, sub1, sub2, ...])
```

**Аргументы**

* `format` — Форматная строка со спецификаторами `%`. [`String`](/sql-reference/data-types/string)
* `sub1, sub2, ...` — Необязательный параметр. Ноль или более значений для подстановки в форматную строку. [`Any`](/sql-reference/data-types)

**Возвращаемое значение**

Возвращает отформатированную строку. [`String`](/sql-reference/data-types/string)

**Примеры**

**Форматирование в стиле C++**

```sql title=Query
SELECT printf('%%%s %s %d', 'Hello', 'World', 2024);
```

```response title=Response
┌─printf('%%%s %s %d', 'Hello', 'World', 2024)─┐
│ %Hello World 2024                            │
└──────────────────────────────────────────────┘
```

## regexpQuoteMeta \\{#regexpQuoteMeta\\}

Введена в версии v20.1

Добавляет обратный слеш перед следующими символами, которые имеют специальное значение в регулярных выражениях: `\0`, `\\`, `|`, `(`, `)`, `^`, `$`, `.`, `[`, `]`, `?`, `*`, `+`, `{`, `:`, `-`.
Эта реализация незначительно отличается от re2::RE2::QuoteMeta.
Она экранирует нулевой байт как `\0` вместо `\x00` и экранирует только необходимые символы.

**Синтаксис**

```sql
regexpQuoteMeta(s)
```

**Аргументы**

* `s` — Входная строка, содержащая символы, подлежащие экранированию в регулярных выражениях (regex). [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку, в которой экранированы специальные символы регулярных выражений (regex). [`String`](/sql-reference/data-types/string)

**Примеры**

**Экранирование специальных символов регулярных выражений (regex)**

```sql title=Query
SELECT regexpQuoteMeta('Hello. [World]? (Yes)*') AS res
```

```response title=Response
┌─res───────────────────────────┐
│ Hello\. \[World\]\? \(Yes\)\* │
└───────────────────────────────┘
```

## replaceAll \\{#replaceAll\\}

Появилась в версии: v1.1

Заменяет все вхождения подстроки `pattern` в `haystack` строкой `replacement`.

**Синтаксис**

```sql
replaceAll(haystack, pattern, replacement)
```

**Псевдонимы**: `replace`

**Аргументы**

* `haystack` — входная строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — подстрока, которую нужно найти и заменить. [`const String`](/sql-reference/data-types/string)
* `replacement` — строка, которой будет заменена подстрока `pattern`. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку, в которой все вхождения `pattern` заменены. [`String`](/sql-reference/data-types/string)

**Примеры**

**Замена всех вхождений**

```sql title=Query
SELECT replaceAll('Hello, Hello world', 'Hello', 'Hi') AS res;
```

```response title=Response
┌─res──────────┐
│ Hi, Hi world │
└──────────────┘
```

## replaceOne \\{#replaceOne\\}

Добавлена в: v1.1

Заменяет первое вхождение подстроки `pattern` в `haystack` строкой `replacement`.

**Синтаксис**

```sql
replaceOne(haystack, pattern, replacement)
```

**Аргументы**

* `haystack` — входная строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — подстрока для поиска и замены. [`const String`](/sql-reference/data-types/string)
* `replacement` — строка, которой будет заменена найденная подстрока. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку, в которой первое вхождение подстроки заменено. [`String`](/sql-reference/data-types/string)

**Примеры**

**Замена первого вхождения**

```sql title=Query
SELECT replaceOne('Hello, Hello world', 'Hello', 'Hi') AS res;
```

```response title=Response
┌─res─────────────┐
│ Привет, Hello world │
└─────────────────┘
```

## replaceRegexpAll \\{#replaceRegexpAll\\}

Введена в версии v1.1

Аналог функции `replaceRegexpOne`, но заменяет все вхождения шаблона.
В качестве исключения, если регулярное выражение сработало на пустой подстроке, замена выполняется не более одного раза.

**Синтаксис**

```sql
replaceRegexpAll(haystack, pattern, replacement)
```

**Псевдонимы**: `REGEXP_REPLACE`

**Аргументы**

* `haystack` — Входная строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — Шаблон регулярного выражения для поиска. [`const String`](/sql-reference/data-types/string)
* `replacement` — Строка, заменяющая найденный шаблон, может содержать подстановки. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку, в которой все совпадения с регулярным выражением заменены. [`String`](/sql-reference/data-types/string)

**Примеры**

**Заменить каждый символ на его удвоенную версию**

```sql title=Query
SELECT replaceRegexpAll('Hello123', '.', '\\\\0\\\\0') AS res
```

```response title=Response
┌─res──────────────────┐
│ HHeelllloo112233     │
└──────────────────────┘
```

**Пример замены пустой подстроки**

```sql title=Query
SELECT replaceRegexpAll('Hello, World!', '^', 'here: ') AS res
```

```response title=Response
┌─res─────────────────┐
│ здесь: Привет, мир! │
└─────────────────────┘
```

## replaceRegexpOne \\{#replaceRegexpOne\\}

Введено в: v1.1

Заменяет первое вхождение подстроки в `haystack`, совпадающей с регулярным выражением `pattern` (в синтаксисе re2), строкой `replacement`.
`replacement` может содержать подстановки `\0-\9`.
Подстановки `\1-\9` соответствуют 1-й–9-й захватывающим группам (подсовпадениям), подстановка `\0` соответствует полному совпадению.
Чтобы использовать буквальный символ `\` в строках `pattern` или `replacement`, экранируйте его с помощью `\`.
Также имейте в виду, что строковые литералы требуют дополнительного экранирования.

**Синтаксис**

```sql
replaceRegexpOne(haystack, pattern, replacement)
```

**Аргументы**

* `haystack` — Входная строка, в которой выполняется поиск. [`String`](/sql-reference/data-types/string)
* `pattern` — Шаблон регулярного выражения для поиска. [`const String`](/sql-reference/data-types/string)
* `replacement` — Строка, на которую заменяется совпадение с шаблоном, может содержать подстановки. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку, в которой первая подстрока, соответствующая регулярному выражению, заменена. [`String`](/sql-reference/data-types/string)

**Примеры**

**Преобразование дат из формата ISO в американский формат**

```sql title=Query
SELECT DISTINCT
    EventDate,
    replaceRegexpOne(toString(EventDate), '(\\d{4})-(\\d{2})-(\\d{2})', '\\2/\\3/\\1') AS res
FROM test.hits
LIMIT 7
FORMAT TabSeparated
```

```response title=Response
2014-03-17      03/17/2014
2014-03-18      03/18/2014
2014-03-19      03/19/2014
2014-03-20      03/20/2014
2014-03-21      03/21/2014
2014-03-22      03/22/2014
2014-03-23      03/23/2014
```

**Копирование строки десять раз**

```sql title=Query
SELECT replaceRegexpOne('Hello, World!', '.*', '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0') AS res
```

```response title=Response
┌─res────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!Привет, мир! │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

## translate \\{#translate\\}

Впервые появилась в: v22.7

Заменяет символы в строке `s` по взаимно-однозначному соответствию символов, заданному строками `from` и `to`.
`from` и `to` должны быть константными ASCII-строками.
Если длины `from` и `to` совпадают, каждое вхождение первого символа `from` в `s` заменяется на первый символ `to`, каждого вхождения второго символа `from` в `s` — на второй символ `to` и так далее.
Если `from` содержит больше символов, чем `to`, все вхождения символов из конца `from`, для которых нет соответствующего символа в `to`, удаляются из `s`.
Не-ASCII-символы в `s` этой функцией не изменяются.

**Синтаксис**

```sql
translate(s, from, to)
```

**Аргументы**

* `s` — входная строка для преобразования. [`String`](/sql-reference/data-types/string)
* `from` — константная строка ASCII, содержащая символы для замены. [`const String`](/sql-reference/data-types/string)
* `to` — константная строка ASCII, содержащая символы-заменители. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку с применёнными заменами символов. [`String`](/sql-reference/data-types/string)

**Примеры**

**Сопоставление символов**
```sql title=Query
SELECT translate('Hello, World!', 'delor', 'DELOR') AS res
```

```response title=Response
┌─res───────────┐
│ HELLO, WORLD! │
└───────────────┘
```

**Разная длина**

```sql title=Query
SELECT translate('clickhouse', 'clickhouse', 'CLICK') AS res
```

```response title=Response
┌─res───┐
│ CLICK │
└───────┘
```

## translateUTF8 \\{#translateUTF8\\}

Добавлена в версии: v22.7

Аналог [`translate`](#translate), но предполагает, что `s`, `from` и `to` — строки в кодировке UTF-8.

**Синтаксис**

```sql
translateUTF8(s, from, to)
```

**Аргументы**

* `s` — входная строка в кодировке UTF-8 для преобразования. [`String`](/sql-reference/data-types/string)
* `from` — константная строка UTF-8, содержащая заменяемые символы. [`const String`](/sql-reference/data-types/string)
* `to` — константная строка UTF-8, содержащая символы замены. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает значение типа данных `String`. [`String`](/sql-reference/data-types/string)

**Примеры**

**Преобразование символов UTF-8**

```sql title=Query
SELECT translateUTF8('Münchener Straße', 'üß', 'us') AS res;
```

```response title=Response
┌─res──────────────┐
│ Munchener Strase │
└──────────────────┘
```

{/*AUTOGENERATED_END*/ }

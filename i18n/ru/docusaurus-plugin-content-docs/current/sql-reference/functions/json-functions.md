---
description: 'Документация по функциям JSON'
sidebar_label: 'JSON'
slug: /sql-reference/functions/json-functions
title: 'Функции JSON'
doc_type: 'reference'
---

## Типы функций JSON \{#types-of-functions\}

Существует две группы функций для разбора JSON:

- [`simpleJSON*` (`visitParam*`)](#simplejson-visitparam-functions), предназначенные для сверхбыстрого разбора ограниченного подмножества JSON.
- [`JSONExtract*`](#jsonextract-functions), предназначенные для разбора обычного JSON.

### функции simpleJSON (visitParam) \{#simplejson-visitparam-functions\}

В ClickHouse есть специальные функции для работы с упрощённым JSON. Все эти функции JSON основаны на строгих предположениях о том, каким может быть JSON. Они стараются делать минимум необходимого, чтобы выполнить задачу как можно быстрее.

Делаются следующие предположения:

1.  Имя поля (аргумент функции) должно быть константой.
2.  Имя поля канонически закодировано в JSON. Например: `simpleJSONHas('{"abc":"def"}', 'abc') = 1`, но `simpleJSONHas('{"\\u0061\\u0062\\u0063":"def"}', 'abc') = 0`
3.  Поля ищутся на любом уровне вложенности, без учёта структуры. Если есть несколько совпадающих полей, используется первое вхождение.
4.  В JSON отсутствуют пробельные символы вне строковых литералов.

### Функции JSONExtract \{#jsonextract-functions\}

Эти функции основаны на [simdjson](https://github.com/lemire/simdjson) и предназначены для более сложных требований к разбору JSON.

### Регистронезависимые функции JSONExtract \

Эти функции выполняют поиск ключей в JSON-объектах по ASCII без учета регистра при извлечении значений.
Они работают идентично своим регистрозависимым версиям, за исключением того, что ключи объекта сопоставляются без учета регистра.
Если нескольким ключам соответствуют варианты, отличающиеся только регистром, возвращается первое совпадение.

:::note
Эти функции могут работать менее эффективно, чем их регистрозависимые аналоги, поэтому по возможности используйте обычные функции JSONExtract.
:::

{/* 
  Внутреннее содержимое приведённых ниже тегов при сборке фреймворка документации
  заменяется документацией, сгенерированной из system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }


## JSONAllPaths

Добавлена в версии v24.8

Возвращает список всех путей, сохранённых в каждой строке столбца JSON.

**Синтаксис**

```sql
JSONAllPaths(json)
```

**Аргументы**

* `json` — столбец типа JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает массив всех путей в столбце JSON. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPaths(json)─┐
│ {"a":"42"}                           │ ['a']              │
│ {"b":"Hello"}                        │ ['b']              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a','c']          │
└──────────────────────────────────────┴────────────────────┘
```


## JSONAllPathsWithTypes

Появилась в версии: v24.8

Возвращает список всех путей и их типов данных, хранящихся в каждой строке JSON-столбца.

**Синтаксис**

```sql
JSONAllPathsWithTypes(json)
```

**Аргументы**

* `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает отображение всех путей и соответствующих им типов данных в столбце JSON. [`Map(String, String)`](/sql-reference/data-types/map)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPathsWithTypes(json)───────────────┐
│ {"a":"42"}                           │ {'a':'Int64'}                             │
│ {"b":"Hello"}                        │ {'b':'String'}                            │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))','c':'Date'} │
└──────────────────────────────────────┴───────────────────────────────────────────┘
```


## JSONArrayLength

Появилась в версии: v23.2

Возвращает количество элементов во внешнем JSON-массиве.
Функция возвращает `NULL`, если входная JSON-строка некорректна.

**Синтаксис**

```sql
JSONArrayLength(json)
```

**Псевдонимы**: `JSON_ARRAY_LENGTH`

**Аргументы**

* `json` — строка с корректным JSON. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество элементов массива, если `json` — корректная строка JSON-массива, в противном случае возвращает `NULL`. [`Nullable(UInt64)`](/sql-reference/data-types/nullable)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
    JSONArrayLength(''),
    JSONArrayLength('[1,2,3]');
```

```response title=Response
┌─JSONArrayLength('')─┬─JSONArrayLength('[1,2,3]')─┐
│                ᴺᵁᴸᴸ │                          3 │
└─────────────────────┴────────────────────────────┘
```


## JSONDynamicPaths

Добавлено в версии v24.8

Возвращает список динамических путей, которые хранятся в виде отдельных подстолбцов в JSON-столбце.

**Синтаксис**

```sql
JSONDynamicPaths(json)
```

**Аргументы**

* `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает массив динамических путей в столбце JSON. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPaths(json)─┐
│ {"a":"42"}                           │ ['a']                  │
│ {"b":"Hello"}                        │ []                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a']                  │
└──────────────────────────────────────┴────────────────────────┘
```


## JSONDynamicPathsWithTypes

Добавлено в: v24.8

Возвращает список динамических путей, хранящихся в виде отдельных подстолбцов, и их типов для каждой строки JSON-столбца.

**Синтаксис**

```sql
JSONДинамическиеПутиСТипами(json)
```

**Аргументы**

* `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает ассоциативный массив динамических путей и их типов данных в столбце JSON. [`Map(String, String)`](/sql-reference/data-types/map)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {'a':'Int64'}                   │
│ {"b":"Hello"}                        │ {}                              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))'}  │
└──────────────────────────────────────┴─────────────────────────────────┘
```


## JSONExtract

Введён в версии: v19.14

Парсит JSON и извлекает значение указанного типа данных ClickHouse.

**Синтаксис**

```sql
JSONExtract(json[, indices_or_keys, ...], return_type)
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)
* `return_type` — возвращаемый тип данных ClickHouse. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает значение указанного типа данных ClickHouse, если возможно, в противном случае — значение по умолчанию для этого типа.

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtract('{"a": "hello", "b": [-100, 200.0, 300]}', 'Tuple(String, Array(Float64))') AS res;
```

```response title=Response
┌─res──────────────────────────────┐
│ ('hello',[-100,200,300])         │
└──────────────────────────────────┘
```


## JSONExtractArrayRaw

Добавлено в версии: v20.1

Возвращает массив с элементами JSON-массива, каждый из которых представлен как неразобранная строка.

**Синтаксис**

```sql
JSONExtractArrayRaw(json[, indices_or_keys, ...])
```

**Аргументы**

* `json` — строка JSON для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив строк с элементами JSON-массива. Если соответствующая часть не является массивом или не существует, возвращается пустой массив. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractArrayRaw('{"a": "hello", "b": [-100, 200.0, "hello"]}', 'b') AS res;
```

```response title=Response
┌─res──────────────────────────┐
│ ['-100','200.0','"hello"']   │
└──────────────────────────────┘
```


## JSONExtractArrayRawCaseInsensitive

Введена в версии: v25.8

Возвращает массив с элементами JSON-массива, каждый из которых представлен как необработанная строка, с использованием регистронезависимого сопоставления ключей. Эта функция похожа на [`JSONExtractArrayRaw`](#JSONExtractArrayRaw).

**Синтаксис**

```sql
JSONExtractArrayRawCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный параметр. Индексы или ключи для перехода к массиву. Ключи сопоставляются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив JSON-строк в исходном виде. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**базовый пример**

```sql title=Query
SELECT JSONExtractArrayRawCaseInsensitive('{"Items": [1, 2, 3]}', 'ITEMS')
```

```response title=Response
['1','2','3']
```


## JSONExtractBool

Добавлена в версии: v20.1

Разбирает JSON и извлекает значение типа Bool.

**Синтаксис**

```sql
JSONExtractBool(json[, indices_or_keys, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение типа `Bool`, если такое значение существует, в противном случае — `0`. [`Bool`](/sql-reference/data-types/boolean)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractBool('{"passed": true}', 'passed') AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```


## JSONExtractBoolCaseInsensitive

Добавлена в версии: v25.8

Разбирает JSON и извлекает логическое значение, используя регистронезависимое сопоставление ключа. Эта функция аналогична [`JSONExtractBool`](#JSONExtractBool).

**Синтаксис**

```sql
JSONExtractBoolCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный параметр. Индексы или ключи для перехода к полю. Ключи сопоставляются без учёта регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое логическое значение (1 — true, 0 — false); 0, если поле не найдено. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**простой**

```sql title=Query
SELECT JSONExtractBoolCaseInsensitive('{"IsActive": true}', 'isactive')
```

```response title=Response
1
```


## JSONExtractCaseInsensitive

Представлена в версии: v25.8

Разбирает JSON и извлекает значение указанного типа данных ClickHouse с использованием сопоставления ключей без учета регистра. Эта функция аналогична [`JSONExtract`](#JSONExtract).

**Синтаксис**

```sql
JSONExtractCaseInsensitive(json [, indices_or_keys...], return_type)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный параметр. Индексы или ключи для перехода к полю. Ключи сопоставляются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)
* `return_type` — Тип данных ClickHouse, в который нужно привести значение [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённое значение в указанном типе данных. [`Any`](/sql-reference/data-types)

**Примеры**

**int&#95;type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"Number": 123}', 'number', 'Int32')
```

```response title=Response
123
```

**array&#95;type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"List": [1, 2, 3]}', 'list', 'Array(Int32)')
```

```response title=Response
[1,2,3]
```


## JSONExtractFloat

Добавлена в версии: v20.1

Парсит JSON и извлекает значение типа Float.

**Синтаксис**

```sql
JSONExtractFloat(json[, indices_or_keys, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает число с плавающей запятой, если оно существует, в противном случае возвращает `0`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractFloat('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 2) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```


## JSONExtractFloatCaseInsensitive

Добавлена в версии: v25.8

Разбирает JSON и извлекает значение типа Float с использованием регистронезависимого сопоставления ключей. Эта функция похожа на [`JSONExtractFloat`](#JSONExtractFloat).

**Синтаксис**

```sql
JSONExtractFloatCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — необязательный параметр. Индексы или ключи для перехода к полю. Ключи сопоставляются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое значение типа Float, 0 — если значение не найдено или не может быть преобразовано. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**простой**

```sql title=Query
SELECT JSONExtractFloatCaseInsensitive('{"Price": 12.34}', 'PRICE')
```

```response title=Response
12.34
```


## JSONExtractInt

Появилось в версии: v20.1

Разбирает JSON и извлекает значение типа Int.

**Синтаксис**

```sql
JSONExtractInt(json[, indices_or_keys, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает целое значение типа Int, если соответствующее значение существует, в противном случае — `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 1) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```


## JSONExtractIntCaseInsensitive

Добавлена в версии: v25.8

Разбирает JSON и извлекает значение типа Int при нечувствительном к регистру сопоставлении ключа. Эта функция аналогична [`JSONExtractInt`](#JSONExtractInt).

**Синтаксис**

```sql
JSONExtractIntCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный параметр. Индексы или ключи для перехода к полю. Ключи сопоставляются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое значение типа Int, 0 — если значение не найдено или не может быть преобразовано. [`Int64`](/sql-reference/data-types/int-uint)

**Примеры**

**простой**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"Value": 123}', 'value')
```

```response title=Response
123
```

**вложенный**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"DATA": {"COUNT": 42}}', 'data', 'Count')
```

```response title=Response
42
```


## JSONExtractKeys

Добавлена в версии: v21.11

Разбирает JSON-строку и извлекает ключи.

**Синтаксис**

```sql
JSONExtractKeys(json[, indices_or_keys, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список, содержащий ноль или более аргументов, каждый из которых может быть либо строкой, либо целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив с ключами JSON-объекта. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractKeys('{"a": "hello", "b": [-100, 200.0, 300]}') AS res;
```

```response title=Response
┌─res─────────┐
│ ['a','b']   │
└─────────────┘
```


## JSONExtractKeysAndValues

Добавлена в версии: v20.1

Извлекает пары ключ–значение из JSON, в котором значения имеют заданный тип данных ClickHouse.

**Синтаксис**

```sql
JSONExtractKeysAndValues(json[, indices_or_keys, ...], value_type)
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля и более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)
* `value_type` — тип данных ClickHouse для значений. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив кортежей, содержащих разобранные пары ключ–значение. [`Array(Tuple(String, value_type))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractKeysAndValues('{"x": {"a": 5, "b": 7, "c": 11}}', 'Int8', 'x') AS res;
```

```response title=Response
┌─res────────────────────┐
│ [('a',5),('b',7),('c',11)] │
└────────────────────────┘
```


## JSONExtractKeysAndValuesCaseInsensitive

Появилась в версии: v25.8

Разбирает пары ключ–значение из JSON, используя сравнение ключей без учёта регистра. Эта функция аналогична [`JSONExtractKeysAndValues`](#JSONExtractKeysAndValues).

**Синтаксис**

```sql
JSONExtractKeysAndValuesCaseInsensitive(json [, indices_or_keys...], value_type)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный аргумент. Индексы или ключи для перехода к объекту. Ключи сравниваются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)
* `value_type` — Тип данных ClickHouse для значений [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив кортежей, содержащих пары ключ-значение. [`Array(Tuple(String, T))`](/sql-reference/data-types/array)

**Примеры**

**Простой пример**

```sql title=Query
SELECT JSONExtractKeysAndValuesCaseInsensitive('{"Name": "Alice", "AGE": 30}', 'String')
```

```response title=Response
[('Name','Alice'),('AGE','30')]
```


## JSONExtractKeysAndValuesRaw

Появилась в версии: v20.4

Возвращает массив кортежей с ключами и значениями из объекта JSON. Все значения представлены в виде нераспарсенных строк.

**Синтаксис**

```sql
JSONExtractKeysAndValuesRaw(json[, indices_or_keys, ...])
```

**Аргументы**

* `json` — JSON-строка для парсинга. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля и более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив кортежей с разобранными парами ключ-значение, где значения представлены как необработанные строки. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractKeysAndValuesRaw('{"a": [-100, 200.0], "b": "hello"}') AS res;
```

```response title=Response
┌─res──────────────────────────────────┐
│ [('a','[-100,200.0]'),('b','"hello"')] │
└──────────────────────────────────────┘
```


## JSONExtractKeysAndValuesRawCaseInsensitive

Добавлена в версии: v25.8

Извлекает «сырые» пары ключ–значение из JSON, используя сопоставление ключей без учета регистра. Эта функция аналогична [`JSONExtractKeysAndValuesRaw`](#JSONExtractKeysAndValuesRaw).

**Синтаксис**

```sql
JSONExtractKeysAndValuesRawCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный параметр. Индексы или ключи для перехода к объекту. Для ключей используется регистронезависимое сопоставление [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив кортежей, содержащих пары ключ-значение в виде исходных строк. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**Примеры**

**простой**

```sql title=Query
SELECT JSONExtractKeysAndValuesRawCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
[('Name','"Alice"'),('AGE','30')]
```


## JSONExtractKeysCaseInsensitive

Введена в версии: v25.8

Разбирает JSON-строку и извлекает ключи, используя регистронезависимое сопоставление ключей для навигации по вложенным объектам. Эта функция аналогична [`JSONExtractKeys`](#JSONExtractKeys).

**Синтаксис**

```sql
JSONExtractKeysCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — необязательный параметр. Индексы или ключи для перехода к объекту. Для ключей используется сопоставление без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив ключей из JSON-объекта. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**базовый**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
['Name','AGE']
```

**вложенный**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"User": {"name": "John", "AGE": 25}}', 'user')
```

```response title=Response
['name','AGE']
```


## JSONExtractRaw

Добавлена в версии: v20.1

Возвращает часть JSON в виде неразобранной строки.

**Синтаксис**

```sql
JSONExtractRaw(json[, индексы_или_ключи, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля и более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает часть JSON в виде строки без разбора. Если часть не существует или имеет несоответствующий тип, будет возвращена пустая строка. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractRaw('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') AS res;
```

```response title=Response
┌─res──────────────┐
│ [-100,200.0,300] │
└──────────────────┘
```


## JSONExtractRawCaseInsensitive

Добавлено в: v25.8

Возвращает часть JSON-документа в виде неразобранной строки, используя регистронезависимое сопоставление ключей. Эта функция аналогична [`JSONExtractRaw`](#JSONExtractRaw).

**Синтаксис**

```sql
JSONExtractRawCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный параметр. Индексы или ключи для перехода к полю. Ключи сопоставляются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает необработанную JSON-строку извлеченного элемента. [`String`](/sql-reference/data-types/string)

**Примеры**

**объект**

```sql title=Query
SELECT JSONExtractRawCaseInsensitive('{"Object": {"key": "value"}}', 'OBJECT')
```

```response title=Response
{"key":"value"}
```


## JSONExtractString

Появилась в версии: v20.1

Разбирает JSON и извлекает значение типа String.

**Синтаксис**

```sql
JSONExtractString(json[, indices_or_keys, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение типа String, если оно существует, в противном случае возвращает пустую строку. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractString('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') AS res;
```

```response title=Response
┌─res──────┐
│ привет   │
└──────────┘
```


## JSONExtractStringCaseInsensitive

Добавлена в версии: v25.8

Разбирает JSON и извлекает строку с использованием регистронезависимого сопоставления ключей. Эта функция аналогична [`JSONExtractString`](#JSONExtractString).

**Синтаксис**

```sql
JSONExtractStringCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для парсинга [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный параметр. Индексы или ключи для перехода к полю. Ключи сравниваются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое строковое значение, пустую строку — если значение не найдено. [`String`](/sql-reference/data-types/string)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"ABC": "def"}', 'abc')
```

```response title=Response
def
```

**вложенный**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"User": {"Name": "John"}}', 'user', 'name')
```

```response title=Response
Джон
```


## JSONExtractUInt

Появилось в версии v20.1

Разбирает JSON и извлекает значение типа UInt.

**Синтаксис**

```sql
JSONExtractUInt(json [, индексы_или_ключи, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — список из нуля или более аргументов; каждый из них может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение типа UInt, если оно существует, в противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractUInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', -1) AS res;
```

```response title=Response
┌─res─┐
│ 300 │
└─────┘
```


## JSONExtractUIntCaseInsensitive

Добавлена в: v25.8

Разбирает JSON и извлекает значение типа UInt, используя нечувствительное к регистру сопоставление ключей. Эта функция аналогична [`JSONExtractUInt`](#JSONExtractUInt).

**Синтаксис**

```sql
JSONExtractUIntCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — Необязательный параметр. Индексы или ключи для перехода к нужному полю. Ключи сопоставляются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлеченное значение типа UInt, 0 — если поле не найдено или не может быть преобразовано. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Простой пример**

```sql title=Query
SELECT JSONExtractUIntCaseInsensitive('{"COUNT": 789}', 'count')
```

```response title=Response
789
```


## JSONHas

Впервые представлена в: v20.1

Проверяет наличие переданного значения (значений) в JSON-документе.

**Синтаксис**

```sql
JSONHas(json[ ,indices_or_keys, ...])
```

**Аргументы**

* `json` — JSON-строка для парсинга [`String`](/sql-reference/data-types/string)
* `[ ,indices_or_keys, ...]` — список из нуля или более аргументов [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает `1`, если значение присутствует в `json`, иначе `0` [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 1;
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 4) = 0;
```

```response title=Response
1
0
```


## JSONLength

Введена в версии v20.1

Возвращает длину массива JSON или объекта JSON.
Если значение не существует или имеет неподходящий тип, будет возвращено `0`.

**Синтаксис**

```sql
JSONLength(json [, индексы_или_ключи, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `[, indices_or_keys, ...]` — Необязательный параметр. Список из нуля или более аргументов. [`String`](/sql-reference/data-types/string) или [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает длину JSON-массива или JSON-объекта, в противном случае возвращает `0`, если значение отсутствует или имеет неверный тип. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 3;
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}') = 2;
```

```response title=Response
1
1
```


## JSONMergePatch

Впервые появилось в версии v23.10

Возвращает строку объединённого JSON-объекта, сформированную путём слияния нескольких JSON-объектов.

**Синтаксис**

```sql
jsonMergePatch(json1[, json2, ...])
```

**Псевдонимы**: `jsonMergePatch`

**Аргументы**

* `json1[, json2, ...]` — Одна или несколько строк с валидным JSON. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку объединённого JSON-объекта, если строки JSON-объектов валидны. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT jsonMergePatch('{"a":1}', '{"name": "joey"}', '{"name": "tom"}', '{"name": "zoey"}') AS res;
```

```response title=Response
┌─res───────────────────┐
│ {"a":1,"name":"zoey"} │
└───────────────────────┘
```


## JSONSharedDataPaths

Введена в: v24.8

Возвращает список путей, хранящихся в общей структуре данных в JSON-столбце.

**Синтаксис**

```sql
JSONSharedDataPaths(json)
```

**Аргументы**

* `json` — JSON-столбец. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает массив путей, хранящихся в общей структуре данных в JSON-столбце. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPaths(json)─┐
│ {"a":"42"}                           │ []                        │
│ {"b":"Hello"}                        │ ['b']                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['c']                     │
└──────────────────────────────────────┴───────────────────────────┘
```


## JSONSharedDataPathsWithTypes

Добавлена в версии: v24.8

Возвращает список путей, которые хранятся в общей структуре данных, и соответствующих им типов для каждой строки JSON-столбца.

**Синтаксис**

```sql
JSONСовместныеПутиДанныхСТипами(json)
```

**Аргументы**

* `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает отображение путей, хранимых в общей структуре данных, и их типов данных в столбце JSON. [`Map(String, String)`](/sql-reference/data-types/map)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {}                                  │
│ {"b":"Hello"}                        │ {'b':'String'}                      │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'c':'Date'}                        │
└──────────────────────────────────────┴─────────────────────────────────────┘
```


## JSONType

Добавлено в: v20.1

Возвращает тип значения JSON. Если значение отсутствует, будет возвращено `Null=0`.

**Синтаксис**

```sql
JSONType(json[, индексы_или_ключи, ...])
```

**Аргументы**

* `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
* `json[, indices_or_keys, ...]` — Список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает тип JSON-значения в виде строки. Если значение не существует, возвращает `Null=0` [`Enum`](/sql-reference/data-types/enum)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}') = 'Object';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') = 'String';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 'Array';
```

```response title=Response
1
1
1
```


## JSON&#95;EXISTS

Добавлена в версии v21.8

Если значение существует в JSON-документе, будет возвращено `1`.
Если значение не существует, будет возвращено `0`.

**Синтаксис**

```sql
JSON_EXISTS(json, path)
```

**Аргументы**

* `json` — строка с корректным JSON-документом. [`String`](/sql-reference/data-types/string)
* `path` — строка, представляющая путь. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если значение существует в JSON-документе, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSON_EXISTS('{"hello":1}', '$.hello');
SELECT JSON_EXISTS('{"hello":{"world":1}}', '$.hello.world');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[*]');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[0]');
```

```response title=Response
┌─JSON_EXISTS(⋯ '$.hello')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯llo.world')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[*]')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[0]')─┐
│                        1 │
└──────────────────────────┘
```


## JSON&#95;QUERY

Введена в версии: v21.8

Разбирает JSON и извлекает значение в виде массива JSON или объекта JSON.
Если значение не существует, возвращается пустая строка.

**Синтаксис**

```sql
JSON_QUERY(json, path)
```

**Аргументы**

* `json` — строка с валидным JSON. [`String`](/sql-reference/data-types/string)
* `path` — строка, задающая путь. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённый JSON-массив или JSON-объект в виде строки либо пустую строку, если значение отсутствует. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSON_QUERY('{"hello":"world"}', '$.hello');
SELECT JSON_QUERY('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_QUERY('{"hello":2}', '$.hello');
SELECT toTypeName(JSON_QUERY('{"hello":2}', '$.hello'));
```

```response title=Response
["мир"]
[0, 1, 4, 0, -1, -4]
[2]
Строка
```


## JSON&#95;VALUE

Впервые появилась в версии v21.11

Разбирает JSON и извлекает значение в виде скаляра JSON. Если значение не существует, по умолчанию возвращается пустая строка.

Поведение функции определяется следующими настройками:

* при `SET function_json_value_return_type_allow_nullable = true` будет возвращён `NULL`. Если значение имеет сложный тип (например, `struct`, `array`, `map`), по умолчанию будет возвращена пустая строка.
* при `SET function_json_value_return_type_allow_complex = true` будет возвращено сложное значение.

**Синтаксис**

```sql
JSON_VALUE(json, path)
```

**Аргументы**

* `json` — Строка с валидным JSON. [`String`](/sql-reference/data-types/string)
* `path` — Строка, представляющая путь. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённый JSON-скаляр в виде строки или пустую строку, если значение отсутствует. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSON_VALUE('{"hello":"world"}', '$.hello');
SELECT JSON_VALUE('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_VALUE('{"hello":2}', '$.hello');
SELECT JSON_VALUE('{"hello":"world"}', '$.b') settings function_json_value_return_type_allow_nullable=true;
```

```response title=Response
мир
0
2
ᴺᵁᴸᴸ
```


## dynamicElement

Добавлено в версии: v24.1

Извлекает столбец указанного типа из столбца `Dynamic`.

Эта функция позволяет извлекать значения определённого типа из столбца `Dynamic`. Если строка содержит значение
запрошенного типа, возвращается это значение. Если строка содержит значение другого типа или NULL, возвращается NULL
для скалярных типов или пустой массив для типов-массивов.

**Синтаксис**

```sql
dynamicElement(dynamic, type_name)
```

**Аргументы**

* `dynamic` — столбец типа `Dynamic`, из которого выполняется извлечение. [`Dynamic`](/sql-reference/data-types/dynamic)
* `type_name` — имя варианта типа, который нужно извлечь (например, &#39;String&#39;, &#39;Int64&#39;, &#39;Array(Int64)&#39;).

**Возвращаемое значение**

Возвращает значения указанного типа из столбца типа `Dynamic`. Возвращает NULL для несовпадающих типов (или пустой массив для типов-массивов). [`Any`](/sql-reference/data-types)

**Примеры**

**Извлечение разных типов из столбца типа `Dynamic`**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d), dynamicElement(d, 'String'), dynamicElement(d, 'Int64'), dynamicElement(d, 'Array(Int64)'), dynamicElement(d, 'Date'), dynamicElement(d, 'Array(String)') FROM test
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┬─dynamicElement(d, 'String')─┬─dynamicElement(d, 'Int64')─┬─dynamicElement(d, 'Array(Int64)')─┬─dynamicElement(d, 'Date')─┬─dynamicElement(d, 'Array(String)')─┐
│ ᴺᵁᴸᴸ          │ None           │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ 42            │ Int64          │ ᴺᵁᴸᴸ                        │                         42 │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ Hello, World! │ String         │ Hello, World!               │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ [1,2,3]       │ Array(Int64)   │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ [1,2,3]                           │                      ᴺᵁᴸᴸ │ []                                 │
└───────────────┴────────────────┴─────────────────────────────┴────────────────────────────┴───────────────────────────────────┴───────────────────────────┴────────────────────────────────────┘
```


## dynamicType

Введена в версии: v24.1

Возвращает имя варианта типа данных для каждой строки столбца `Dynamic`.

Для строк, содержащих NULL, функция возвращает &#39;None&#39;. Для всех остальных строк она возвращает фактический тип данных,
хранящийся в этой строке столбца `Dynamic` (например, &#39;Int64&#39;, &#39;String&#39;, &#39;Array(Int64)&#39;).

**Синтаксис**

```sql
dynamicType(dynamic)
```

**Аргументы**

* `dynamic` — динамический столбец для анализа. [`Dynamic`](/sql-reference/data-types/dynamic)

**Возвращаемое значение**

Возвращает имя типа значения, содержащегося в каждой строке, или «None» для значений NULL. [`String`](/sql-reference/data-types/string)

**Примеры**

**Анализ типов в динамическом столбце**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d) FROM test;
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┐
│ ᴺᵁᴸᴸ          │ None           │
│ 42            │ Int64          │
│ Привет, мир!  │ String         │
│ [1,2,3]       │ Array(Int64)   │
└───────────────┴────────────────┘
```


## isDynamicElementInSharedData

Введено в: v24.1

Возвращает true для строк в столбце типа Dynamic, которые хранятся в формате общего варианта (shared variant format), а не как отдельные подстолбцы.

Когда у столбца Dynamic есть ограничение `max_types`, значения, превышающие этот предел, хранятся в общем двоичном формате
вместо разделения на отдельные типизированные подстолбцы. Эта функция определяет, какие строки хранятся в этом общем формате.

**Синтаксис**

```sql
isDynamicElementInSharedData(dynamic)
```

**Аргументы**

* `dynamic` — динамический столбец для анализа. [`Dynamic`](/sql-reference/data-types/dynamic)

**Возвращаемое значение**

Возвращает true, если значение хранится в формате shared variant, и false — если оно хранится как отдельный подстолбец или равно NULL. [`Bool`](/sql-reference/data-types/boolean)

**Примеры**

**Проверка формата хранения в динамическом столбце с ограничением max&#95;types**

```sql title=Query
CREATE TABLE test (d Dynamic(max_types=2)) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, isDynamicElementInSharedData(d) FROM test;
```

```response title=Response
┌─d─────────────┬─isDynamicElementInSharedData(d)─┐
│ ᴺᵁᴸᴸ          │ false                           │
│ 42            │ false                           │
│ Hello, World! │ true                            │
│ [1,2,3]       │ true                            │
└───────────────┴─────────────────────────────────┘
```


## isValidJSON

Добавлена в: v20.1

Проверяет, является ли переданная строка корректным JSON.

**Синтаксис**

```sql
isValidJSON(json)
```

**Аргументы**

* `json` — JSON-строка для проверки [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка является корректным JSON, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT isValidJSON('{"a": "hello", "b": [-100, 200.0, 300]}') = 1;
SELECT isValidJSON('not JSON') = 0;
```

```response title=Response
1
0
```

**Использование целых чисел для обращения и к массивам JSON, и к объектам JSON**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 0);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 3);
```

```response title=Response
0
1
1
1
1
1
0
```


## simpleJSONExtractBool

Добавлена в версии v21.4

Извлекает логическое значение (true/false) из значения поля `field_name`.
Результат имеет тип `UInt8`.

**Синтаксис**

```sql
simpleJSONExtractBool(json, field_name)
```

**Псевдонимы**: `visitParamExtractBool`

**Аргументы**

* `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
* `field_name` — имя поля, которое нужно найти. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если значение поля равно `true`, и `0` в противном случае. Это означает, что функция вернёт `0`, в том числе (и не только) в следующих случаях:

* Если поле не существует.
* Если поле содержит `true` в виде строки, например: `{"field":"true"}`.
* Если поле содержит `1` как числовое значение. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":false,"bar":true}');
INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONExtractBool(json, 'bar') FROM jsons ORDER BY json;
SELECT simpleJSONExtractBool(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
1
0
0
```


## simpleJSONExtractFloat

Добавлена в: v21.4

Извлекает значение типа `Float64` из поля с именем `field_name`.
Если `field_name` — строковое поле, функция пытается распарсить число с начала строки.
Если поле не существует или существует, но не содержит числа, возвращается `0`.

**Синтаксис**

```sql
simpleJSONExtractFloat(json, field_name)
```

**Псевдонимы**: `visitParamExtractFloat`

**Аргументы**

* `json` — JSON-строка, в которой выполняется поиск поля. [`String`](/sql-reference/data-types/string)
* `field_name` — имя искомого поля. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число, извлечённое из поля, если поле существует и содержит число; в противном случае — `0`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractFloat(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4000
0
-3.4
5
```


## simpleJSONExtractInt

Впервые представлена в версии v21.4

Извлекает значение типа `Int64` из поля с именем `field_name`.
Если `field_name` — строковое поле, пытается разобрать число с начала строки.
Если поле не существует или существует, но не содержит число, возвращает `0`.

**Синтаксис**

```sql
simpleJSONExtractInt(json, field_name)
```

**Псевдонимы**: `visitParamExtractInt`

**Аргументы**

* `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
* `field_name` — имя поля, которое нужно найти. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число, извлечённое из поля, если поле существует и содержит число, иначе — `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4
0
-3
5
```


## simpleJSONExtractRaw

Впервые появилась в: v21.4

Возвращает значение поля с именем `field_name` в виде `String`, включая разделители.

**Синтаксис**

```sql
simpleJSONExtractRaw(json, field_name)
```

**Псевдонимы**: `visitParamExtractRaw`

**Аргументы**

* `json` — JSON, в котором ищется поле. [`String`](/sql-reference/data-types/string)
* `field_name` — имя поля для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает значение поля в виде строки, включая разделители, если поле найдено, или пустую строку в противном случае. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":{"def":[1,2,3]}}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractRaw(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
"-4e3"
-3.4
5
{"def":[1,2,3]}
```


## simpleJSONExtractString

Впервые появилась в версии: v21.4

Извлекает строку (`String`) в двойных кавычках из значения поля с именем `field_name`.

**Подробности реализации**

В настоящее время не поддерживаются кодовые точки в формате `\uXXXX\uYYYY`, которые не принадлежат базовой многоязычной плоскости (они преобразуются в CESU-8 вместо UTF-8).

**Синтаксис**

```sql
simpleJSONExtractString(json, field_name)
```

**Псевдонимы**: `visitParamExtractString`

**Аргументы**

* `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
* `field_name` — имя поля для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает неэкранированное значение поля в виде строки, включая разделители. Пустая строка возвращается, если поле не содержит строки в двойных кавычках, если разэкранирование завершилось неудачно или если поле не существует. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"\\n\\u0000"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263a"}');
INSERT INTO jsons VALUES ('{"foo":"hello}');

SELECT simpleJSONExtractString(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
\n\0

☺
```


## simpleJSONExtractUInt

Впервые появилась в версии v21.4.

Извлекает значение типа `UInt64` из значения поля с именем `field_name`.
Если `field_name` — строковое поле, функция пытается разобрать число с начала строки.
Если поле не существует или существует, но не содержит число, возвращается `0`.

**Синтаксис**

```sql
simpleJSONExtractUInt(json, field_name)
```

**Псевдонимы**: `visitParamExtractUInt`

**Аргументы**

* `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
* `field_name` — имя поля, по которому выполняется поиск. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число, извлечённое из поля, если поле существует и содержит число; в противном случае — `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"4e3"}');
INSERT INTO jsons VALUES ('{"foo":3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractUInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
4
0
3
5
```


## simpleJSONHas

Добавлен в версии: v21.4

Проверяет, существует ли поле с именем `field_name`.

**Синтаксис**

```sql
simpleJSONHas(json, field_name)
```

**Псевдонимы**: `visitParamHas`

**Аргументы**

* `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
* `field_name` — имя поля, которое нужно найти. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если поле существует, и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONHas(json, 'foo') FROM jsons;
SELECT simpleJSONHas(json, 'bar') FROM jsons;
```

```response title=Response
1
0
```


## toJSONString \

Появилась в: v21.7

Сериализует значение в его JSON‑представление. Поддерживаются различные типы данных и вложенные структуры.
64-битные [целые числа](../data-types/int-uint.md) и числа большего диапазона (такие как `UInt64` или `Int128`) по умолчанию заключаются в кавычки. Этим поведением управляет настройка [output&#95;format&#95;json&#95;quote&#95;64bit&#95;integers](/operations/settings/formats#output_format_json_quote_64bit_integers).
Специальные значения `NaN` и `inf` заменяются на `null`. Включите настройку [output&#95;format&#95;json&#95;quote&#95;denormals](/operations/settings/formats#output_format_json_quote_denormals), чтобы отображать их.
При сериализации значения [Enum](../data-types/enum.md) функция выводит его имя.

См. также:

* [output&#95;format&#95;json&#95;quote&#95;64bit&#95;integers](/operations/settings/formats#output_format_json_quote_64bit_integers)
* [output&#95;format&#95;json&#95;quote&#95;denormals](/operations/settings/formats#output_format_json_quote_denormals)

**Синтаксис**

```sql
toJSONString(value)
```

**Аргументы**

* `value` — значение для сериализации. Значение может быть любого типа данных. [`Any`](/sql-reference/data-types)

**Возвращаемое значение**

Возвращает представление значения в формате JSON. [`String`](/sql-reference/data-types/string)

**Примеры**

**Сериализация Map**

```sql title=Query
SELECT toJSONString(map('key1', 1, 'key2', 2));
```

```response title=Response
┌─toJSONString(map('key1', 1, 'key2', 2))─┐
│ {"key1":1,"key2":2}                     │
└─────────────────────────────────────────┘
```

**Особые значения**

```sql title=Query
SELECT toJSONString(tuple(1.25, NULL, NaN, +inf, -inf, [])) SETTINGS output_format_json_quote_denormals = 1;
```

```response title=Response
┌─toJSONString(tuple(1.25, NULL, NaN, plus(inf), minus(inf), []))─┐
│ [1.25,null,"nan","inf","-inf",[]]                               │
└─────────────────────────────────────────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

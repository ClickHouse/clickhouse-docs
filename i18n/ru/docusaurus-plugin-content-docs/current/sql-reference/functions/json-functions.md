---
description: 'Документация по функциям JSON'
sidebar_label: 'JSON'
slug: /sql-reference/functions/json-functions
title: 'Функции JSON'
doc_type: 'reference'
---



## Типы JSON-функций {#types-of-functions}

Существует два набора функций для разбора JSON:

- [`simpleJSON*` (`visitParam*`)](#simplejson-visitparam-functions) — предназначены для очень быстрого разбора ограниченного подмножества JSON.
- [`JSONExtract*`](#jsonextract-functions) — предназначены для разбора обычного JSON.

### Функции simpleJSON (visitParam) {#simplejson-visitparam-functions}

В ClickHouse есть специальные функции для работы с упрощённым JSON. Все эти JSON-функции основаны на строгих предположениях о том, каким может быть JSON. Они выполняют минимум операций для максимально быстрого решения задачи.

Делаются следующие предположения:

1.  Имя поля (аргумент функции) должно быть константой.
2.  Имя поля должно быть канонически закодировано в JSON. Например: `simpleJSONHas('{"abc":"def"}', 'abc') = 1`, но `simpleJSONHas('{"\\u0061\\u0062\\u0063":"def"}', 'abc') = 0`
3.  Поля ищутся на любом уровне вложенности без разбора. Если существует несколько совпадающих полей, используется первое вхождение.
4.  JSON не содержит пробельных символов вне строковых литералов.

### Функции JSONExtract {#jsonextract-functions}

Эти функции основаны на библиотеке [simdjson](https://github.com/lemire/simdjson) и предназначены для более сложных требований к разбору JSON.

### Регистронезависимые функции JSONExtract {#case-insensitive-jsonextract-functions}

Эти функции выполняют регистронезависимое сопоставление ключей ASCII при извлечении значений из JSON-объектов.
Они работают идентично своим регистрозависимым аналогам, за исключением того, что ключи объектов сопоставляются без учёта регистра.
Когда несколько ключей совпадают с разным регистром, возвращается первое совпадение.

:::note
Эти функции могут работать медленнее, чем их регистрозависимые аналоги, поэтому по возможности используйте обычные функции JSONExtract.
:::

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## JSONAllPaths {#JSONAllPaths}

Введена в версии: v24.8

Возвращает список всех путей, сохранённых в каждой строке столбца JSON.

**Синтаксис**

```sql
JSONAllPaths(json)
```

**Аргументы**

- `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает массив всех путей в столбце JSON. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPaths(json)─┐
│ {"a":"42"}                           │ ['a']              │
│ {"b":"Hello"}                        │ ['b']              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a','c']          │
└──────────────────────────────────────┴────────────────────┘
```


## JSONAllPathsWithTypes {#JSONAllPathsWithTypes}

Введена в версии: v24.8

Возвращает список всех путей и их типов данных, хранящихся в каждой строке столбца JSON.

**Синтаксис**

```sql
JSONAllPathsWithTypes(json)
```

**Аргументы**

- `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает словарь всех путей и их типов данных в столбце JSON. [`Map(String, String)`](/sql-reference/data-types/map)

**Примеры**

**Пример использования**

```sql title=Запрос
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPathsWithTypes(json) FROM test;
```

```response title=Результат
┌─json─────────────────────────────────┬─JSONAllPathsWithTypes(json)───────────────┐
│ {"a":"42"}                           │ {'a':'Int64'}                             │
│ {"b":"Hello"}                        │ {'b':'String'}                            │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))','c':'Date'} │
└──────────────────────────────────────┴───────────────────────────────────────────┘
```


## JSONArrayLength {#JSONArrayLength}

Введена в версии: v23.2

Возвращает количество элементов в самом внешнем массиве JSON.
Функция возвращает `NULL`, если входная строка JSON невалидна.

**Синтаксис**

```sql
JSONArrayLength(json)
```

**Псевдонимы**: `JSON_ARRAY_LENGTH`

**Аргументы**

- `json` — строка с валидным JSON. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает количество элементов массива, если `json` является валидной строкой массива JSON, в противном случае возвращает `NULL`. [`Nullable(UInt64)`](/sql-reference/data-types/nullable)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
    JSONArrayLength(''),
    JSONArrayLength('[1,2,3]');
```

```response title=Response
┌─JSONArrayLength('')─┬─JSONArrayLength('[1,2,3]')─┐
│                ᴺᵁᴸᴸ │                          3 │
└─────────────────────┴────────────────────────────┘
```


## JSONDynamicPaths {#JSONDynamicPaths}

Введено в версии: v24.8

Возвращает список динамических путей, которые хранятся как отдельные подстолбцы в столбце JSON.

**Синтаксис**

```sql
JSONDynamicPaths(json)
```

**Аргументы**

- `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает массив динамических путей в столбце JSON. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPaths(json)─┐
│ {"a":"42"}                           │ ['a']                  │
│ {"b":"Hello"}                        │ []                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a']                  │
└──────────────────────────────────────┴────────────────────────┘
```


## JSONDynamicPathsWithTypes {#JSONDynamicPathsWithTypes}

Введена в версии: v24.8

Возвращает список динамических путей, которые хранятся как отдельные подстолбцы, и их типы для каждой строки в столбце JSON.

**Синтаксис**

```sql
JSONDynamicPathsWithTypes(json)
```

**Аргументы**

- `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает словарь динамических путей и их типов данных в столбце JSON. [`Map(String, String)`](/sql-reference/data-types/map)

**Примеры**

**Пример использования**

```sql title=Запрос
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPathsWithTypes(json) FROM test;
```

```response title=Результат
┌─json─────────────────────────────────┬─JSONDynamicPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {'a':'Int64'}                   │
│ {"b":"Hello"}                        │ {}                              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))'}  │
└──────────────────────────────────────┴─────────────────────────────────┘
```


## JSONExtract {#JSONExtract}

Введена в версии: v19.14

Разбирает JSON и извлекает значение с заданным типом данных ClickHouse.

**Синтаксис**

```sql
JSONExtract(json, return_type[, indices_or_keys, ...])
```

**Аргументы**

- `json` — строка JSON для разбора. [`String`](/sql-reference/data-types/string)
- `return_type` — возвращаемый тип данных ClickHouse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение указанного типа данных ClickHouse, если это возможно, иначе возвращает значение по умолчанию для этого типа.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtract('{"a": "hello", "b": [-100, 200.0, 300]}', 'Tuple(String, Array(Float64))') AS res;
```

```response title=Ответ
┌─res──────────────────────────────┐
│ ('hello',[-100,200,300])         │
└──────────────────────────────────┘
```


## JSONExtractArrayRaw {#JSONExtractArrayRaw}

Введена в версии: v20.1

Возвращает массив с элементами JSON-массива, каждый из которых представлен в виде непарсенной строки.

**Синтаксис**

```sql
JSONExtractArrayRaw(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для парсинга. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив строк с элементами JSON-массива. Если указанная часть не является массивом или не существует, возвращается пустой массив. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractArrayRaw('{"a": "hello", "b": [-100, 200.0, "hello"]}', 'b') AS res;
```

```response title=Результат
┌─res──────────────────────────┐
│ ['-100','200.0','"hello"']   │
└──────────────────────────────┘
```


## JSONExtractArrayRawCaseInsensitive {#JSONExtractArrayRawCaseInsensitive}

Введена в версии: v25.8

Возвращает массив элементов JSON-массива, каждый из которых представлен в виде необработанной строки, с использованием регистронезависимого сопоставления ключей. Эта функция аналогична [`JSONExtractArrayRaw`](#JSONExtractArrayRaw).

**Синтаксис**

```sql
JSONExtractArrayRawCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — JSON-строка для парсинга [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Необязательный параметр. Индексы или ключи для навигации к массиву. Ключи используют регистронезависимое сопоставление [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив необработанных JSON-строк. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**базовый пример**

```sql title=Query
SELECT JSONExtractArrayRawCaseInsensitive('{"Items": [1, 2, 3]}', 'ITEMS')
```

```response title=Response
['1','2','3']
```


## JSONExtractBool {#JSONExtractBool}

Добавлена в версии: v20.1

Парсит JSON и извлекает значение типа Bool.

**Синтаксис**

```sql
JSONExtractBool(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для парсинга. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение Bool, если оно существует, в противном случае возвращает `0`. [`Bool`](/sql-reference/data-types/boolean)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractBool('{"passed": true}', 'passed') AS res;
```

```response title=Результат
┌─res─┐
│   1 │
└─────┘
```


## JSONExtractBoolCaseInsensitive {#JSONExtractBoolCaseInsensitive}

Введена в версии: v25.8

Разбирает JSON и извлекает логическое значение, используя регистронезависимое сопоставление ключей. Эта функция аналогична [`JSONExtractBool`](#JSONExtractBool).

**Синтаксис**

```sql
JSONExtractBoolCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — строка JSON для разбора [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к полю. Ключи используют регистронезависимое сопоставление [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое логическое значение (1 для true, 0 для false), 0 если значение не найдено. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовый пример**

```sql title=Запрос
SELECT JSONExtractBoolCaseInsensitive('{"IsActive": true}', 'isactive')
```

```response title=Результат
1
```


## JSONExtractCaseInsensitive {#JSONExtractCaseInsensitive}

Введена в версии: v25.8

Разбирает JSON и извлекает значение заданного типа данных ClickHouse с использованием сопоставления ключей без учёта регистра. Эта функция аналогична [`JSONExtract`](#JSONExtract).

**Синтаксис**

```sql
JSONExtractCaseInsensitive(json [, indices_or_keys...], return_type)
```

**Аргументы**

- `json` — строка JSON для разбора [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к полю. Ключи сопоставляются без учёта регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)
- `return_type` — тип данных ClickHouse для извлечения [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённое значение в указанном типе данных. [`Any`](/sql-reference/data-types)

**Примеры**

**int_type**

```sql title=Запрос
SELECT JSONExtractCaseInsensitive('{"Number": 123}', 'number', 'Int32')
```

```response title=Результат
123
```

**array_type**

```sql title=Запрос
SELECT JSONExtractCaseInsensitive('{"List": [1, 2, 3]}', 'list', 'Array(Int32)')
```

```response title=Результат
[1,2,3]
```


## JSONExtractFloat {#JSONExtractFloat}

Введена в версии: v20.1

Разбирает JSON и извлекает значение типа Float.

**Синтаксис**

```sql
JSONExtractFloat(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — строка JSON для разбора. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение типа Float, если оно существует, в противном случае возвращает `0`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractFloat('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 2) AS res;
```

```response title=Результат
┌─res─┐
│ 200 │
└─────┘
```


## JSONExtractFloatCaseInsensitive {#JSONExtractFloatCaseInsensitive}

Введена в версии: v25.8

Разбирает JSON и извлекает значение типа Float, используя сопоставление ключей без учёта регистра. Эта функция аналогична [`JSONExtractFloat`](#JSONExtractFloat).

**Синтаксис**

```sql
JSONExtractFloatCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — строка JSON для разбора [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к полю. Ключи используют сопоставление без учёта регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое значение Float, 0, если значение не найдено или не может быть преобразовано. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**базовый пример**

```sql title=Запрос
SELECT JSONExtractFloatCaseInsensitive('{"Price": 12.34}', 'PRICE')
```

```response title=Ответ
12.34
```


## JSONExtractInt {#JSONExtractInt}

Введена в версии: v20.1

Разбирает JSON и извлекает значение типа Int.

**Синтаксис**

```sql
JSONExtractInt(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение типа Int, если оно существует, в противном случае возвращает `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 1) AS res;
```

```response title=Результат
┌─res─┐
│ 200 │
└─────┘
```


## JSONExtractIntCaseInsensitive {#JSONExtractIntCaseInsensitive}

Введена в версии: v25.8

Разбирает JSON и извлекает значение типа Int с использованием сопоставления ключей без учёта регистра. Эта функция аналогична [`JSONExtractInt`](#JSONExtractInt).

**Синтаксис**

```sql
JSONExtractIntCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — строка JSON для разбора [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к полю. Ключи сопоставляются без учёта регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое значение Int, 0 если значение не найдено или не может быть преобразовано. [`Int64`](/sql-reference/data-types/int-uint)

**Примеры**

**базовый пример**

```sql title=Запрос
SELECT JSONExtractIntCaseInsensitive('{"Value": 123}', 'value')
```

```response title=Ответ
123
```

**вложенная структура**

```sql title=Запрос
SELECT JSONExtractIntCaseInsensitive('{"DATA": {"COUNT": 42}}', 'data', 'Count')
```

```response title=Ответ
42
```


## JSONExtractKeys {#JSONExtractKeys}

Введена в версии: v21.11

Разбирает JSON-строку и извлекает ключи.

**Синтаксис**

```sql
JSONExtractKeys(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для разбора. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив с ключами JSON-объекта. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractKeys('{"a": "hello", "b": [-100, 200.0, 300]}') AS res;
```

```response title=Результат
┌─res─────────┐
│ ['a','b']   │
└─────────────┘
```


## JSONExtractKeysAndValues {#JSONExtractKeysAndValues}

Введена в версии: v20.1

Извлекает пары ключ-значение из JSON, где значения имеют заданный тип данных ClickHouse.

**Синтаксис**

```sql
JSONExtractKeysAndValues(json, value_type[, indices_or_keys, ...])
```

**Аргументы**

- `json` — строка JSON для парсинга. [`String`](/sql-reference/data-types/string)
- `value_type` — тип данных ClickHouse для значений. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив кортежей с разобранными парами ключ-значение. [`Array(Tuple(String, value_type))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractKeysAndValues('{"x": {"a": 5, "b": 7, "c": 11}}', 'Int8', 'x') AS res;
```

```response title=Результат
┌─res────────────────────┐
│ [('a',5),('b',7),('c',11)] │
└────────────────────────┘
```


## JSONExtractKeysAndValuesCaseInsensitive {#JSONExtractKeysAndValuesCaseInsensitive}

Введена в версии: v25.8

Извлекает пары ключ-значение из JSON с использованием регистронезависимого сопоставления ключей. Функция аналогична [`JSONExtractKeysAndValues`](#JSONExtractKeysAndValues).

**Синтаксис**

```sql
JSONExtractKeysAndValuesCaseInsensitive(json [, indices_or_keys...], value_type)
```

**Аргументы**

- `json` — строка JSON для парсинга [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к объекту. Ключи сопоставляются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)
- `value_type` — тип данных ClickHouse для значений [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив кортежей, содержащих пары ключ-значение. [`Array(Tuple(String, T))`](/sql-reference/data-types/array)

**Примеры**

**basic**

```sql title=Запрос
SELECT JSONExtractKeysAndValuesCaseInsensitive('{"Name": "Alice", "AGE": 30}', 'String')
```

```response title=Результат
[('Name','Alice'),('AGE','30')]
```


## JSONExtractKeysAndValuesRaw {#JSONExtractKeysAndValuesRaw}

Введена в версии: v20.4

Возвращает массив кортежей с ключами и значениями из JSON-объекта. Все значения представлены в виде непарсированных строк.

**Синтаксис**

```sql
JSONExtractKeysAndValuesRaw(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для парсинга. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив кортежей с парами ключ-значение, где значения представлены в виде непарсированных строк. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractKeysAndValuesRaw('{"a": [-100, 200.0], "b": "hello"}') AS res;
```

```response title=Результат
┌─res──────────────────────────────────┐
│ [('a','[-100,200.0]'),('b','"hello"')] │
└──────────────────────────────────────┘
```


## JSONExtractKeysAndValuesRawCaseInsensitive {#JSONExtractKeysAndValuesRawCaseInsensitive}

Введена в версии: v25.8

Извлекает необработанные пары ключ-значение из JSON с использованием регистронезависимого сопоставления ключей. Эта функция аналогична [`JSONExtractKeysAndValuesRaw`](#JSONExtractKeysAndValuesRaw).

**Синтаксис**

```sql
JSONExtractKeysAndValuesRawCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — строка JSON для парсинга [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к объекту. Ключи используют регистронезависимое сопоставление [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив кортежей, содержащих пары ключ-значение в виде необработанных строк. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**Примеры**

**базовый пример**

```sql title=Query
SELECT JSONExtractKeysAndValuesRawCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
[('Name','"Alice"'),('AGE','30')]
```


## JSONExtractKeysCaseInsensitive {#JSONExtractKeysCaseInsensitive}

Введена в версии: v25.8

Разбирает JSON-строку и извлекает ключи с использованием регистронезависимого сопоставления для навигации по вложенным объектам. Функция аналогична [`JSONExtractKeys`](#JSONExtractKeys).

**Синтаксис**

```sql
JSONExtractKeysCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — JSON-строка для разбора [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Необязательный параметр. Индексы или ключи для навигации к объекту. Ключи сопоставляются без учета регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив ключей из JSON-объекта. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**базовый пример**

```sql title=Запрос
SELECT JSONExtractKeysCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Результат
['Name','AGE']
```

**вложенный объект**

```sql title=Запрос
SELECT JSONExtractKeysCaseInsensitive('{"User": {"name": "John", "AGE": 25}}', 'user')
```

```response title=Результат
['name','AGE']
```


## JSONExtractRaw {#JSONExtractRaw}

Введена в версии: v20.1

Возвращает часть JSON в виде неразобранной строки.

**Синтаксис**

```sql
JSONExtractRaw(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — строка JSON для разбора. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает часть JSON в виде неразобранной строки. Если часть не существует или имеет неверный тип, будет возвращена пустая строка. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSONExtractRaw('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') AS res;
```

```response title=Response
┌─res──────────────┐
│ [-100,200.0,300] │
└──────────────────┘
```


## JSONExtractRawCaseInsensitive {#JSONExtractRawCaseInsensitive}

Добавлена в версии: v25.8

Возвращает часть JSON в виде необработанной строки с использованием регистронезависимого сопоставления ключей. Эта функция аналогична [`JSONExtractRaw`](#JSONExtractRaw).

**Синтаксис**

```sql
JSONExtractRawCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — строка JSON для парсинга. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к полю. Ключи используют регистронезависимое сопоставление. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает необработанную строку JSON извлечённого элемента. [`String`](/sql-reference/data-types/string)

**Примеры**

**объект**

```sql title=Query
SELECT JSONExtractRawCaseInsensitive('{"Object": {"key": "value"}}', 'OBJECT')
```

```response title=Response
{"key":"value"}
```


## JSONExtractString {#JSONExtractString}

Введена в версии: v20.1

Парсит JSON и извлекает значение типа String.

**Синтаксис**

```sql
JSONExtractString(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для парсинга. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение типа String, если оно существует, в противном случае возвращает пустую строку. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractString('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') AS res;
```

```response title=Результат
┌─res───┐
│ hello │
└───────┘
```


## JSONExtractStringCaseInsensitive {#JSONExtractStringCaseInsensitive}

Введена в версии: v25.8

Разбирает JSON и извлекает строку с использованием сопоставления ключей без учёта регистра. Функция аналогична [`JSONExtractString`](#JSONExtractString).

**Синтаксис**

```sql
JSONExtractStringCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — строка JSON для разбора [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к полю. Ключи сопоставляются без учёта регистра [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое строковое значение или пустую строку, если значение не найдено. [`String`](/sql-reference/data-types/string)

**Примеры**

**базовый пример**

```sql title=Запрос
SELECT JSONExtractStringCaseInsensitive('{"ABC": "def"}', 'abc')
```

```response title=Результат
def
```

**вложенная структура**

```sql title=Запрос
SELECT JSONExtractStringCaseInsensitive('{"User": {"Name": "John"}}', 'user', 'name')
```

```response title=Результат
John
```


## JSONExtractUInt {#JSONExtractUInt}

Добавлено в версии: v20.1

Разбирает JSON и извлекает значение типа UInt.

**Синтаксис**

```sql
JSONExtractUInt(json [, indices_or_keys, ...])
```

**Аргументы**

- `json` — строка JSON для разбора. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает значение типа UInt, если оно существует, в противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONExtractUInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', -1) AS res;
```

```response title=Результат
┌─res─┐
│ 300 │
└─────┘
```


## JSONExtractUIntCaseInsensitive {#JSONExtractUIntCaseInsensitive}

Добавлено в версии: v25.8

Разбирает JSON и извлекает значение типа UInt с использованием сопоставления ключей без учёта регистра. Функция аналогична [`JSONExtractUInt`](#JSONExtractUInt).

**Синтаксис**

```sql
JSONExtractUIntCaseInsensitive(json [, indices_or_keys]...)
```

**Аргументы**

- `json` — строка JSON для разбора. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — необязательный параметр. Индексы или ключи для навигации к полю. Ключи сопоставляются без учёта регистра. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает извлечённое значение UInt, либо 0, если значение не найдено или не может быть преобразовано. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**базовый пример**

```sql title=Query
SELECT JSONExtractUIntCaseInsensitive('{"COUNT": 789}', 'count')
```

```response title=Response
789
```


## JSONHas {#JSONHas}

Введена в версии: v20.1

Проверяет наличие указанного значения (значений) в JSON-документе.

**Синтаксис**

```sql
JSONHas(json[ ,indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для парсинга [`String`](/sql-reference/data-types/string)
- `[ ,indices_or_keys, ...]` — Список из нуля или более аргументов. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает `1`, если значение присутствует в `json`, иначе `0` [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 1;
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 4) = 0;
```

```response title=Результат
1
0
```


## JSONLength {#JSONLength}

Введена в версии: v20.1

Возвращает длину JSON-массива или JSON-объекта.
Если значение не существует или имеет неправильный тип, возвращается `0`.

**Синтаксис**

```sql
JSONLength(json [, indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для парсинга [`String`](/sql-reference/data-types/string)
- `[, indices_or_keys, ...]` — Необязательный параметр. Список из нуля или более аргументов. [`String`](/sql-reference/data-types/string) или [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает длину JSON-массива или JSON-объекта. Если значение не существует или имеет неправильный тип, возвращается `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 3;
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}') = 2;
```

```response title=Результат
1
1
```


## JSONMergePatch {#JSONMergePatch}

Introduced in: v23.10

Возвращает строку объединённого JSON-объекта, сформированного путём слияния нескольких JSON-объектов.

**Синтаксис**

```sql
jsonMergePatch(json1[, json2, ...])
```

**Псевдонимы**: `jsonMergePatch`

**Аргументы**

- `json1[, json2, ...]` — одна или несколько строк с корректным JSON. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает строку объединённого JSON-объекта, если строки JSON-объектов корректны. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT jsonMergePatch('{"a":1}', '{"name": "joey"}', '{"name": "tom"}', '{"name": "zoey"}') AS res;
```

```response title=Результат
┌─res───────────────────┐
│ {"a":1,"name":"zoey"} │
└───────────────────────┘
```


## JSONSharedDataPaths {#JSONSharedDataPaths}

Введена в версии: v24.8

Возвращает список путей, хранящихся в структуре разделяемых данных столбца JSON.

**Синтаксис**

```sql
JSONSharedDataPaths(json)
```

**Аргументы**

- `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает массив путей, хранящихся в структуре разделяемых данных столбца JSON. [`Array(String)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPaths(json) FROM test;
```

```response title=Результат
┌─json─────────────────────────────────┬─JSONSharedDataPaths(json)─┐
│ {"a":"42"}                           │ []                        │
│ {"b":"Hello"}                        │ ['b']                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['c']                     │
└──────────────────────────────────────┴───────────────────────────┘
```


## JSONSharedDataPathsWithTypes {#JSONSharedDataPathsWithTypes}

Введена в версии: v24.8

Возвращает список путей, хранящихся в общей структуре данных, и их типы для каждой строки столбца JSON.

**Синтаксис**

```sql
JSONSharedDataPathsWithTypes(json)
```

**Аргументы**

- `json` — столбец JSON. [`JSON`](/sql-reference/data-types/newjson)

**Возвращаемое значение**

Возвращает словарь путей, хранящихся в общей структуре данных, и их типов данных в столбце JSON. [`Map(String, String)`](/sql-reference/data-types/map)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {}                                  │
│ {"b":"Hello"}                        │ {'b':'String'}                      │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'c':'Date'}                        │
└──────────────────────────────────────┴─────────────────────────────────────┘
```


## JSONType {#JSONType}

Введена в версии: v20.1

Возвращает тип значения JSON. Если значение не существует, возвращается `Null=0`.

**Синтаксис**

```sql
JSONType(json[, indices_or_keys, ...])
```

**Аргументы**

- `json` — JSON-строка для парсинга [`String`](/sql-reference/data-types/string)
- `json[, indices_or_keys, ...]` — Список из нуля или более аргументов, каждый из которых может быть строкой или целым числом. [`String`](/sql-reference/data-types/string) или [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает тип значения JSON в виде строки, в противном случае, если значение не существует, возвращается `Null=0` [`Enum`](/sql-reference/data-types/enum)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}') = 'Object';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') = 'String';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 'Array';
```

```response title=Результат
1
1
1
```


## JSON_EXISTS {#JSON_EXISTS}

Введена в версии: v21.8

Если значение существует в JSON-документе, возвращается `1`.
Если значение не существует, возвращается `0`.

**Синтаксис**

```sql
JSON_EXISTS(json, path)
```

**Аргументы**

- `json` — строка с валидным JSON. [`String`](/sql-reference/data-types/string)
- `path` — строка, представляющая путь. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если значение существует в JSON-документе, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSON_EXISTS('{"hello":1}', '$.hello');
SELECT JSON_EXISTS('{"hello":{"world":1}}', '$.hello.world');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[*]');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[0]');
```

```response title=Результат
┌─JSON_EXISTS(⋯ '$.hello')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯llo.world')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[*]')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[0]')─┐
│                        1 │
└──────────────────────────┘
```


## JSON_QUERY {#JSON_QUERY}

Введена в версии: v21.8

Разбирает JSON и извлекает значение в виде массива JSON или объекта JSON.
Если значение не существует, возвращается пустая строка.

**Синтаксис**

```sql
JSON_QUERY(json, path)
```

**Аргументы**

- `json` — строка с валидным JSON. [`String`](/sql-reference/data-types/string)
- `path` — строка, представляющая путь. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлечённый массив JSON или объект JSON в виде строки, или пустую строку, если значение не существует. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT JSON_QUERY('{"hello":"world"}', '$.hello');
SELECT JSON_QUERY('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_QUERY('{"hello":2}', '$.hello');
SELECT toTypeName(JSON_QUERY('{"hello":2}', '$.hello'));
```

```response title=Результат
["world"]
[0, 1, 4, 0, -1, -4]
[2]
String
```


## JSON_VALUE {#JSON_VALUE}

Введена в версии: v21.11

Разбирает JSON и извлекает значение как JSON-скаляр. Если значение не существует, по умолчанию возвращается пустая строка.

Работа этой функции управляется следующими настройками:

- при установке `function_json_value_return_type_allow_nullable` = `true` будет возвращено значение `NULL`. Если значение имеет сложный тип (например: struct, array, map), по умолчанию возвращается пустая строка.
- при установке `function_json_value_return_type_allow_complex` = `true` будет возвращено сложное значение.

**Синтаксис**

```sql
JSON_VALUE(json, path)
```

**Аргументы**

- `json` — строка с валидным JSON. [`String`](/sql-reference/data-types/string)
- `path` — строка, представляющая путь. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает извлеченный JSON-скаляр в виде строки или пустую строку, если значение не существует. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Query
SELECT JSON_VALUE('{"hello":"world"}', '$.hello');
SELECT JSON_VALUE('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_VALUE('{"hello":2}', '$.hello');
SELECT JSON_VALUE('{"hello":"world"}', '$.b') settings function_json_value_return_type_allow_nullable=true;
```

```response title=Response
world
0
2
ᴺᵁᴸᴸ
```


## dynamicElement {#dynamicElement}

Введена в версии: v24.1

Извлекает столбец указанного типа из столбца `Dynamic`.

Эта функция позволяет извлекать значения определённого типа из столбца Dynamic. Если строка содержит значение
запрашиваемого типа, возвращается это значение. Если строка содержит значение другого типа или NULL, возвращается NULL
для скалярных типов или пустой массив для массивов.

**Синтаксис**

```sql
dynamicElement(dynamic, type_name)
```

**Аргументы**

- `dynamic` — столбец Dynamic, из которого выполняется извлечение. [`Dynamic`](/sql-reference/data-types/dynamic)
- `type_name` — имя типа для извлечения (например, 'String', 'Int64', 'Array(Int64)').

**Возвращаемое значение**

Возвращает значения указанного типа из столбца Dynamic. Для несовпадающих типов возвращается NULL (или пустой массив для массивов). [`Any`](/sql-reference/data-types)

**Примеры**

**Извлечение различных типов из столбца Dynamic**

```sql title=Запрос
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d), dynamicElement(d, 'String'), dynamicElement(d, 'Int64'), dynamicElement(d, 'Array(Int64)'), dynamicElement(d, 'Date'), dynamicElement(d, 'Array(String)') FROM test
```

```response title=Результат
┌─d─────────────┬─dynamicType(d)─┬─dynamicElement(d, 'String')─┬─dynamicElement(d, 'Int64')─┬─dynamicElement(d, 'Array(Int64)')─┬─dynamicElement(d, 'Date')─┬─dynamicElement(d, 'Array(String)')─┐
│ ᴺᵁᴸᴸ          │ None           │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ 42            │ Int64          │ ᴺᵁᴸᴸ                        │                         42 │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ Hello, World! │ String         │ Hello, World!               │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ [1,2,3]       │ Array(Int64)   │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ [1,2,3]                           │                      ᴺᵁᴸᴸ │ []                                 │
└───────────────┴────────────────┴─────────────────────────────┴────────────────────────────┴───────────────────────────────────┴───────────────────────────┴────────────────────────────────────┘
```


## dynamicType {#dynamicType}

Введена в версии: v24.1

Возвращает имя типа варианта для каждой строки столбца `Dynamic`.

Для строк, содержащих NULL, функция возвращает 'None'. Для всех остальных строк возвращается фактический тип данных,
хранящийся в этой строке столбца Dynamic (например, 'Int64', 'String', 'Array(Int64)').

**Синтаксис**

```sql
dynamicType(dynamic)
```

**Аргументы**

- `dynamic` — столбец Dynamic для анализа. [`Dynamic`](/sql-reference/data-types/dynamic)

**Возвращаемое значение**

Возвращает имя типа значения, хранящегося в каждой строке, или 'None' для значений NULL. [`String`](/sql-reference/data-types/string)

**Примеры**

**Анализ типов в столбце Dynamic**

```sql title=Запрос
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d) FROM test;
```

```response title=Результат
┌─d─────────────┬─dynamicType(d)─┐
│ ᴺᵁᴸᴸ          │ None           │
│ 42            │ Int64          │
│ Hello, World! │ String         │
│ [1,2,3]       │ Array(Int64)   │
└───────────────┴────────────────┘
```


## isDynamicElementInSharedData {#isDynamicElementInSharedData}

Введена в версии: v24.1

Возвращает true для строк в столбце типа Dynamic, которые хранятся в общем формате вариантов, а не в виде отдельных подстолбцов.

Когда столбец типа Dynamic имеет ограничение `max_types`, значения, превышающие этот лимит, сохраняются в общем бинарном формате
вместо разделения на отдельные типизированные подстолбцы. Эта функция определяет, какие строки хранятся в этом общем формате.

**Синтаксис**

```sql
isDynamicElementInSharedData(dynamic)
```

**Аргументы**

- `dynamic` — столбец типа Dynamic для проверки. [`Dynamic`](/sql-reference/data-types/dynamic)

**Возвращаемое значение**

Возвращает true, если значение хранится в общем формате вариантов, false, если хранится как отдельный подстолбец или является NULL. [`Bool`](/sql-reference/data-types/boolean)

**Примеры**

**Проверка формата хранения в столбце Dynamic с ограничением max_types**

```sql title=Query
CREATE TABLE test (d Dynamic(max_types=2)) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, isDynamicElementInSharedData(d) FROM test;
```

```response title=Response
┌─d─────────────┬─isDynamicElementInSharedData(d)─┐
│ ᴺᵁᴸᴸ          │ false                           │
│ 42            │ false                           │
│ Hello, World! │ true                            │
│ [1,2,3]       │ true                            │
└───────────────┴─────────────────────────────────┘
```


## isValidJSON {#isValidJSON}

Введена в версии: v20.1

Проверяет, является ли переданная строка валидным JSON.

**Синтаксис**

```sql
isValidJSON(json)
```

**Аргументы**

- `json` — JSON-строка для валидации [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если строка является валидным JSON, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT isValidJSON('{"a": "hello", "b": [-100, 200.0, 300]}') = 1;
SELECT isValidJSON('not JSON') = 0;
```

```response title=Результат
1
0
```

**Использование целых чисел для доступа к JSON-массивам и JSON-объектам**

```sql title=Запрос
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 0);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 3);
```

```response title=Результат
0
1
1
1
1
1
0
```


## simpleJSONExtractBool {#simpleJSONExtractBool}

Введена в версии: v21.4

Извлекает логическое значение true/false из поля с именем `field_name`.
Результат имеет тип `UInt8`.

**Синтаксис**

```sql
simpleJSONExtractBool(json, field_name)
```

**Псевдонимы**: `visitParamExtractBool`

**Аргументы**

- `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
- `field_name` — Имя искомого поля. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если значение поля равно `true`, иначе `0`. Это означает, что функция вернёт `0` в следующих случаях (включая, но не ограничиваясь):

- Если поле не существует.
- Если поле содержит `true` в виде строки, например: `{"field":"true"}`.
- Если поле содержит `1` в виде числового значения. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":false,"bar":true}');
INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONExtractBool(json, 'bar') FROM jsons ORDER BY json;
SELECT simpleJSONExtractBool(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Результат
0
1
0
0
```


## simpleJSONExtractFloat {#simpleJSONExtractFloat}

Введена в версии: v21.4

Извлекает значение типа `Float64` из поля с именем `field_name`.
Если `field_name` является строковым полем, функция пытается извлечь число из начала строки.
Если поле не существует или не содержит число, возвращается `0`.

**Синтаксис**

```sql
simpleJSONExtractFloat(json, field_name)
```

**Псевдонимы**: `visitParamExtractFloat`

**Аргументы**

- `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
- `field_name` — Имя искомого поля. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число, извлечённое из поля, если поле существует и содержит число, в противном случае — `0`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractFloat(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Результат
0
-4000
0
-3.4
5
```


## simpleJSONExtractInt {#simpleJSONExtractInt}

Введено в версии: v21.4

Извлекает значение типа `Int64` из поля с именем `field_name`.
Если `field_name` является строковым полем, функция пытается извлечь число из начала строки.
Если поле не существует или не содержит число, возвращается `0`.

**Синтаксис**

```sql
simpleJSONExtractInt(json, field_name)
```

**Псевдонимы**: `visitParamExtractInt`

**Аргументы**

- `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
- `field_name` — Имя искомого поля. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число, извлечённое из поля, если поле существует и содержит число, иначе `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Результат
0
-4
0
-3
5
```


## simpleJSONExtractRaw {#simpleJSONExtractRaw}

Введена в версии: v21.4

Возвращает значение поля с именем `field_name` в виде `String`, включая разделители.

**Синтаксис**

```sql
simpleJSONExtractRaw(json, field_name)
```

**Псевдонимы**: `visitParamExtractRaw`

**Аргументы**

- `json` — JSON, в котором осуществляется поиск поля. [`String`](/sql-reference/data-types/string)
- `field_name` — Имя искомого поля. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает значение поля в виде строки, включая разделители, если поле существует, или пустую строку в противном случае. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Запрос
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":{"def":[1,2,3]}}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractRaw(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Результат
"-4e3"
-3.4
5
{"def":[1,2,3]}
```


## simpleJSONExtractString {#simpleJSONExtractString}

Введена в версии: v21.4

Извлекает строковое значение в двойных кавычках из поля с именем `field_name`.

**Детали реализации**

В настоящее время не поддерживаются кодовые точки в формате `\uXXXX\uYYYY`, не входящие в базовую многоязычную плоскость (они преобразуются в CESU-8 вместо UTF-8).

**Синтаксис**

```sql
simpleJSONExtractString(json, field_name)
```

**Псевдонимы**: `visitParamExtractString`

**Аргументы**

- `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
- `field_name` — Имя искомого поля. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает значение поля в виде строки с обработанными escape-последовательностями, включая разделители. Возвращается пустая строка, если поле не содержит строку в двойных кавычках, если обработка escape-последовательностей завершилась неудачей или если поле не существует. [`String`](/sql-reference/data-types/string)

**Примеры**

**Пример использования**

```sql title=Запрос
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"\\n\\u0000"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263a"}');
INSERT INTO jsons VALUES ('{"foo":"hello}');

SELECT simpleJSONExtractString(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Результат
\n\0

☺
```


## simpleJSONExtractUInt {#simpleJSONExtractUInt}

Введена в версии: v21.4

Извлекает значение `UInt64` из поля с именем `field_name`.
Если `field_name` является строковым полем, функция пытается извлечь число из начала строки.
Если поле не существует или не содержит число, возвращается `0`.

**Синтаксис**

```sql
simpleJSONExtractUInt(json, field_name)
```

**Псевдонимы**: `visitParamExtractUInt`

**Аргументы**

- `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
- `field_name` — Имя поля для поиска. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает число, извлечённое из поля, если поле существует и содержит число, в противном случае `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"4e3"}');
INSERT INTO jsons VALUES ('{"foo":3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractUInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
4
0
3
5
```


## simpleJSONHas {#simpleJSONHas}

Introduced in: v21.4

Проверяет наличие поля с именем `field_name`.

**Синтаксис**

```sql
simpleJSONHas(json, field_name)
```

**Псевдонимы**: `visitParamHas`

**Аргументы**

- `json` — JSON, в котором выполняется поиск поля. [`String`](/sql-reference/data-types/string)
- `field_name` — Имя искомого поля. [`const String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает `1`, если поле существует, `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONHas(json, 'foo') FROM jsons;
SELECT simpleJSONHas(json, 'bar') FROM jsons;
```

```response title=Response
1
0
```


## toJSONString {#toJSONString}

Введена в версии: v21.7

Сериализует значение в его JSON-представление. Поддерживаются различные типы данных и вложенные структуры.
64-битные [целые числа](../data-types/int-uint.md) или больше (например, `UInt64` или `Int128`) по умолчанию заключаются в кавычки. Настройка [output_format_json_quote_64bit_integers](/operations/settings/formats#output_format_json_quote_64bit_integers) управляет этим поведением.
Специальные значения `NaN` и `inf` заменяются на `null`. Включите настройку [output_format_json_quote_denormals](/operations/settings/formats#output_format_json_quote_denormals), чтобы отображать их.
При сериализации значения [Enum](../data-types/enum.md) функция выводит его имя.

См. также:

- [output_format_json_quote_64bit_integers](/operations/settings/formats#output_format_json_quote_64bit_integers)
- [output_format_json_quote_denormals](/operations/settings/formats#output_format_json_quote_denormals)

**Синтаксис**

```sql
toJSONString(value)
```

**Аргументы**

- `value` — значение для сериализации. Значение может быть любого типа данных. [`Any`](/sql-reference/data-types)

**Возвращаемое значение**

Возвращает JSON-представление значения. [`String`](/sql-reference/data-types/string)

**Примеры**

**Сериализация Map**

```sql title=Запрос
SELECT toJSONString(map('key1', 1, 'key2', 2));
```

```response title=Результат
┌─toJSONString(map('key1', 1, 'key2', 2))─┐
│ {"key1":1,"key2":2}                     │
└─────────────────────────────────────────┘
```

**Специальные значения**

```sql title=Запрос
SELECT toJSONString(tuple(1.25, NULL, NaN, +inf, -inf, [])) SETTINGS output_format_json_quote_denormals = 1;
```

```response title=Результат
┌─toJSONString(tuple(1.25, NULL, NaN, plus(inf), minus(inf), []))─┐
│ [1.25,null,"nan","inf","-inf",[]]                               │
└─────────────────────────────────────────────────────────────────┘
```

<!--AUTOGENERATED_END-->

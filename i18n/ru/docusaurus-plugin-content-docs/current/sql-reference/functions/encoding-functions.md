---
description: 'Документация по функциям кодирования'
sidebar_label: 'Кодирование'
slug: /sql-reference/functions/encoding-functions
title: 'Функции кодирования'
keywords: ['encoding', 'regular functions', 'encode', 'decode']
doc_type: 'reference'
---



# Функции кодирования

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## bech32Decode {#bech32Decode}

Введена в версии: v25.6

Декодирует строку адреса Bech32, сгенерированную алгоритмом bech32 или bech32m.

:::note
В отличие от функции кодирования, `Bech32Decode` автоматически обрабатывает дополненные значения FixedString.
:::

**Синтаксис**

```sql
bech32Decode(address)
```

**Аргументы**

- `address` — строка Bech32 для декодирования. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)

**Возвращаемое значение**

Возвращает кортеж `(hrp, data)`, который использовался для кодирования строки. Данные представлены в двоичном формате. [`Tuple(String, String)`](/sql-reference/data-types/tuple)

**Примеры**

**Декодирование адреса**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z') AS tup)
```

```response title=Response
bc   751E76E8199196D454941C45D1B3A323F1433BD6
```

**Адрес тестовой сети**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('tb1w508d6qejxtdg4y5r3zarvary0c5xw7kzp034v') AS tup)
```

```response title=Response
tb   751E76E8199196D454941C45D1B3A323F1433BD6
```


## bech32Encode {#bech32Encode}

Добавлено в версии: v25.6

Кодирует строку двоичных данных вместе с человекочитаемой частью (HRP) с использованием алгоритмов [Bech32 или Bech32m](https://en.bitcoin.it/wiki/Bech32).

:::note
При использовании типа данных [`FixedString`](../data-types/fixedstring.md), если значение не полностью заполняет строку, оно дополняется нулевыми символами.
Хотя функция `bech32Encode` обрабатывает это автоматически для аргумента hrp, значения аргумента data не должны содержать дополнения.
По этой причине не рекомендуется использовать тип данных [`FixedString`](../data-types/fixedstring.md) для значений данных, если вы не
уверены, что все они имеют одинаковую длину, и не убедитесь, что столбец `FixedString` также имеет эту длину.
:::

**Синтаксис**

```sql
bech32Encode(hrp, data[, witver])
```

**Аргументы**

- `hrp` — Строка из `1 - 83` символов в нижнем регистре, определяющая «человекочитаемую часть» кода. Обычно 'bc' или 'tb'. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
- `data` — Строка двоичных данных для кодирования. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring)
- `witver` — Необязательный параметр. Версия witness (по умолчанию = 1). `UInt*`, указывающий версию алгоритма для выполнения. `0` для Bech32 и `1` или больше для Bech32m. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает строку адреса Bech32, состоящую из человекочитаемой части, символа-разделителя, который всегда равен '1', и части данных. Длина строки никогда не превысит 90 символов. Если алгоритм не может сгенерировать корректный адрес из входных данных, возвращается пустая строка. [`String`](/sql-reference/data-types/string)

**Примеры**

**Bech32m по умолчанию**

```sql title=Query
-- Когда версия witness не указана, по умолчанию используется 1, обновленный алгоритм Bech32m.
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'))
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7k8zcwmq
```

**Алгоритм Bech32**

```sql title=Query
-- Версия witness 0 приведет к другой строке адреса.
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 0)
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z
```

**Пользовательский HRP**

```sql title=Query
-- Хотя 'bc' (Mainnet) и 'tb' (Testnet) являются единственными допустимыми значениями hrp для
-- формата адреса SegWit, Bech32 допускает любой hrp, удовлетворяющий вышеуказанным требованиям.
SELECT bech32Encode('abcdefg', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 10)
```

```response title=Response
abcdefg1w508d6qejxtdg4y5r3zarvary0c5xw7k9rp8r4
```


## bin {#bin}

Добавлено в версии: v21.8

Возвращает строку, содержащую двоичное представление аргумента, в соответствии
со следующей логикой для различных типов:

| Тип                        | Описание                                                                                                                                                                                                                                                                                  |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `(U)Int*`                  | Выводит двоичные разряды от старшего к младшему (big-endian или "человекочитаемый" порядок). Начинается со старшего ненулевого байта (ведущие нулевые байты опускаются), но всегда выводит восемь разрядов каждого байта, если старший разряд равен нулю.                              |
| `Date` и `DateTime`        | Форматируются как соответствующие целые числа (количество дней с начала эпохи для Date и значение unix timestamp для DateTime).                                                                                                                                                          |
| `String` и `FixedString`   | Все байты кодируются как восемь двоичных разрядов. Нулевые байты не опускаются.                                                                                                                                                                                                      |
| `Float*` и `Decimal`       | Кодируются в соответствии с их представлением в памяти. Поскольку поддерживается архитектура little-endian, они кодируются в формате little-endian. Ведущие и завершающие нулевые байты не опускаются.                                                                                             |
| `UUID`                     | Кодируется как строка в порядке big-endian.                                                                                                                                                                                                                                                               |

**Синтаксис**

```sql
bin(arg)
```

**Аргументы**

- `arg` — значение для преобразования в двоичный формат. [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal) или [`Date`](/sql-reference/data-types/date) или [`DateTime`](/sql-reference/data-types/datetime)

**Возвращаемое значение**

Возвращает строку с двоичным представлением аргумента. [`String`](/sql-reference/data-types/string)

**Примеры**

**Простое целое число**

```sql title=Запрос
SELECT bin(14)
```

```response title=Результат
┌─bin(14)──┐
│ 00001110 │
└──────────┘
```

**Числа Float32**

```sql title=Запрос
SELECT bin(toFloat32(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Результат
┌─bin_presentation─────────────────┐
│ 00000000000000000111000001000001 │
│ 00000000000000001000000001000001 │
└──────────────────────────────────┘
```

**Числа Float64**

```sql title=Запрос
SELECT bin(toFloat64(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Результат
┌─bin_presentation─────────────────────────────────────────────────┐
│ 0000000000000000000000000000000000000000000000000010111001000000 │
│ 0000000000000000000000000000000000000000000000000011000001000000 │
└──────────────────────────────────────────────────────────────────┘
```

**Преобразование UUID**

```sql title=Запрос
SELECT bin(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')) AS bin_uuid
```

```response title=Результат
┌─bin_uuid─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ 01100001111100001100010000000100010111001011001100010001111001111001000001111011101001100000000001101010110100111101101110100000 │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```


## bitPositionsToArray {#bitPositionsToArray}

Введена в версии: v21.7

Функция возвращает позиции (в порядке возрастания) единичных битов в двоичном представлении беззнакового целого числа.
Знаковые целые числа сначала приводятся к беззнаковому типу.

**Синтаксис**

```sql
bitPositionsToArray(arg)
```

**Аргументы**

- `arg` — целочисленное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив с позициями единичных битов в двоичном представлении входного значения, упорядоченными по возрастанию. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Установлен один бит**

```sql title=Query
SELECT bitPositionsToArray(toInt8(1)) AS bit_positions
```

```response title=Response
┌─bit_positions─┐
│ [0]           │
└───────────────┘
```

**Установлены все биты**

```sql title=Query
SELECT bitPositionsToArray(toInt8(-1)) AS bit_positions
```

```response title=Response
┌─bit_positions─────────────┐
│ [0, 1, 2, 3, 4, 5, 6, 7]  │
└───────────────────────────┘
```


## bitmaskToArray {#bitmaskToArray}

Введена в версии: v1.1

Функция разлагает целое число на сумму степеней двойки.
Степени двойки возвращаются в виде массива, упорядоченного по возрастанию.

**Синтаксис**

```sql
bitmaskToArray(num)
```

**Аргументы**

- `num` — целочисленное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив со степенями двойки, упорядоченными по возрастанию, которые в сумме дают входное число. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT bitmaskToArray(50) AS powers_of_two
```

```response title=Response
┌─powers_of_two───┐
│ [2, 16, 32]     │
└─────────────────┘
```

**Единственная степень двойки**

```sql title=Query
SELECT bitmaskToArray(8) AS powers_of_two
```

```response title=Response
┌─powers_of_two─┐
│ [8]           │
└───────────────┘
```


## bitmaskToList {#bitmaskToList}

Введена в версии: v1.1

Аналогична bitmaskToArray, но возвращает степени двойки в виде строки, разделённой запятыми.

**Синтаксис**

```sql
bitmaskToList(num)
```

**Аргументы**

- `num` — целочисленное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает строку, содержащую степени двойки, разделённые запятыми. [`String`](/sql-reference/data-types/string)

**Примеры**

**Базовый пример**

```sql title=Запрос
SELECT bitmaskToList(50) AS powers_list
```

```response title=Результат
┌─powers_list───┐
│ 2, 16, 32     │
└───────────────┘
```


## char {#char}

Введена в версии: v20.1

Возвращает строку, длина которой равна количеству переданных аргументов, где каждый байт
имеет значение соответствующего аргумента. Принимает несколько аргументов числовых типов.

Если значение аргумента выходит за пределы диапазона типа данных `UInt8`, оно преобразуется
в `UInt8` с возможным округлением и переполнением.

**Синтаксис**

```sql
char(num1[, num2[, ...]])
```

**Аргументы**

- `num1[, num2[, num3 ...]]` — Числовые аргументы, интерпретируемые как целые числа. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float)

**Возвращаемое значение**

Возвращает строку из указанных байтов. [`String`](/sql-reference/data-types/string)

**Примеры**

**Базовый пример**

```sql title=Запрос
SELECT char(104.1, 101, 108.9, 108.9, 111) AS hello;
```

```response title=Результат
┌─hello─┐
│ hello │
└───────┘
```

**Построение строк в произвольных кодировках**

```sql title=Запрос
-- Вы можете построить строку в произвольной кодировке, передав соответствующие байты.
-- Например, UTF-8
SELECT char(0xD0, 0xBF, 0xD1, 0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1, 0x82) AS hello;
```

```response title=Результат
┌─hello──┐
│ привет │
└────────┘
```


## hex {#hex}

Введена в версии: v1.1

Возвращает строку, содержащую шестнадцатеричное представление аргумента, в соответствии
со следующей логикой для различных типов:

| Тип                        | Описание                                                                                                                                                                                                                                                                                      |
| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `(U)Int*`                  | Выводит шестнадцатеричные цифры (тетрады) от старшего к младшему разряду (порядок big-endian или «человекочитаемый» порядок). Начинается со старшего ненулевого байта (ведущие нулевые байты опускаются), но всегда выводит обе цифры каждого байта, даже если старшая цифра равна нулю. |
| `Date` и `DateTime`        | Форматируются как соответствующие целые числа (количество дней с начала эпохи для Date и значение unix timestamp для DateTime).                                                                                                                                                              |
| `String` и `FixedString`   | Все байты кодируются как два шестнадцатеричных числа. Нулевые байты не опускаются.                                                                                                                                                                                                    |
| `Float*` и `Decimal`       | Кодируются в соответствии с их представлением в памяти. ClickHouse внутренне всегда представляет значения в формате little endian, поэтому они кодируются соответствующим образом. Нулевые ведущие/завершающие байты не опускаются.                                                          |
| `UUID`                     | Кодируется как строка в порядке big-endian.                                                                                                                                                                                                                                                   |

Функция использует заглавные буквы `A-F` и не использует префиксы (например, `0x`) или суффиксы (например, `h`).

**Синтаксис**

```sql
hex(arg)
```

**Аргументы**

- `arg` — значение для преобразования в шестнадцатеричный формат. [`String`](/sql-reference/data-types/string) или [`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal) или [`Date`](/sql-reference/data-types/date) или [`DateTime`](/sql-reference/data-types/datetime)

**Возвращаемое значение**

Возвращает строку с шестнадцатеричным представлением аргумента. [`String`](/sql-reference/data-types/string)

**Примеры**

**Простое целое число**

```sql title=Запрос
SELECT hex(1)
```

```response title=Результат
01
```

**Числа Float32**

```sql title=Запрос
SELECT hex(toFloat32(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Результат
┌─hex_presentation─┐
│ 00007041         │
│ 00008041         │
└──────────────────┘
```

**Числа Float64**

```sql title=Запрос
SELECT hex(toFloat64(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Результат
┌─hex_presentation─┐
│ 0000000000002E40 │
│ 0000000000003040 │
└──────────────────┘
```

**Преобразование UUID**

```sql title=Запрос
SELECT lower(hex(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'))) AS uuid_hex
```

```response title=Результат
┌─uuid_hex─────────────────────────┐
│ 61f0c4045cb311e7907ba6006ad3dba0 │
└──────────────────────────────────┘
```


## hilbertDecode {#hilbertDecode}

Введена в версии: v24.6

Декодирует индекс кривой Гильберта обратно в кортеж беззнаковых целых чисел, представляющих координаты в многомерном пространстве.

Как и функция `hilbertEncode`, эта функция имеет два режима работы:

- **Простой**
- **Расширенный**

**Простой режим**

Принимает до 2 беззнаковых целых чисел в качестве аргументов и возвращает код `UInt64`.

**Расширенный режим**

Принимает маску диапазона (кортеж) в качестве первого аргумента и до 2 беззнаковых целых чисел в качестве
остальных аргументов. Каждое число в маске задает количество битов, на которое
соответствующий аргумент будет сдвинут влево, эффективно масштабируя аргумент
в пределах его диапазона.

Расширение диапазона может быть полезным, когда требуется схожее распределение для
аргументов с сильно различающимися диапазонами (или мощностью). Например: 'IP-адрес' `(0...FFFFFFFF)`
и 'Код страны' `(0...FF)`. Как и в функции кодирования, максимальное количество
чисел ограничено 8.

**Синтаксис**

```sql
hilbertDecode(tuple_size, code)
```

**Аргументы**

- `tuple_size` — Целочисленное значение не более `2`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint) или [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — Код `UInt64`. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает кортеж указанного размера. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**Примеры**

**Простой режим**

```sql title=Запрос
SELECT hilbertDecode(2, 31)
```

```response title=Ответ
["3", "4"]
```

**Один аргумент**

```sql title=Запрос
-- Код Гильберта для одного аргумента всегда является самим аргументом (в виде кортежа).
SELECT hilbertDecode(1, 1)
```

```response title=Ответ
["1"]
```

**Расширенный режим**

```sql title=Запрос
-- Один аргумент с кортежем, указывающим битовые сдвиги, будет соответственно сдвинут вправо.
SELECT hilbertDecode(tuple(2), 32768)
```

```response title=Ответ
["128"]
```

**Использование столбцов**

```sql title=Запрос
-- Сначала создайте таблицу и вставьте данные
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';
insert into hilbert_numbers (*) values(1,2);

-- Используйте имена столбцов вместо констант в качестве аргументов функции
SELECT untuple(hilbertDecode(2, hilbertEncode(n1, n2))) FROM hilbert_numbers;
```

```response title=Ответ
1    2
```


## hilbertEncode {#hilbertEncode}

Введена в версии: v24.6

Вычисляет код кривой Гильберта для списка беззнаковых целых чисел.

Функция работает в двух режимах:

- **Простой**
- **Расширенный**

**Простой режим**

Принимает до 2 беззнаковых целых чисел в качестве аргументов и возвращает код типа UInt64.

**Расширенный режим**

Принимает маску диапазона ([Tuple](../../sql-reference/data-types/tuple.md)) в качестве
первого аргумента и до 2 [беззнаковых целых чисел](../../sql-reference/data-types/int-uint.md)
в качестве остальных аргументов.

Каждое число в маске задает количество битов, на которое соответствующий
аргумент будет сдвинут влево, что позволяет масштабировать аргумент в пределах его диапазона.

**Синтаксис**

```sql
-- Простой режим
hilbertEncode(args)

-- Расширенный режим
hilbertEncode(range_mask, args)
```

**Аргументы**

- `args` — До двух значений `UInt` или столбцов типа `UInt`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — Для расширенного режима: до двух значений `UInt` или столбцов типа `UInt`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает код типа `UInt64`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Простой режим**

```sql title=Запрос
SELECT hilbertEncode(3, 4)
```

```response title=Результат
31
```

**Расширенный режим**

```sql title=Запрос
-- Расширение диапазона полезно, когда требуется схожее распределение для
-- аргументов с сильно различающимися диапазонами (или мощностью).
-- Например: 'IP-адрес' (0...FFFFFFFF) и 'Код страны' (0...FF).
-- Примечание: размер кортежа должен совпадать с количеством остальных аргументов.
SELECT hilbertEncode((10, 6), 1024, 16)
```

```response title=Результат
4031541586602
```

**Один аргумент**

```sql title=Запрос
-- Для одного аргумента без кортежа функция возвращает сам аргумент
-- в качестве индекса Гильберта, так как многомерное отображение не требуется.
SELECT hilbertEncode(1)
```

```response title=Результат
1
```

**Расширенный режим с одним аргументом**

```sql title=Запрос
-- Если один аргумент передан с кортежем, задающим битовые сдвиги, функция
-- сдвигает аргумент влево на указанное количество битов.
SELECT hilbertEncode(tuple(2), 128)
```

```response title=Результат
512
```

**Использование столбцов**

```sql title=Запрос
-- Сначала создадим таблицу и вставим данные
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1;
insert into hilbert_numbers (*) values(1, 2);

-- Используем имена столбцов вместо констант в качестве аргументов функции
SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;
```

```response title=Результат
13
```


## mortonDecode {#mortonDecode}

Введено в версии: v24.6

Декодирует кодировку Мортона (ZCurve) в соответствующий кортеж беззнаковых целых чисел.

Как и функция `mortonEncode`, эта функция имеет два режима работы:

- **Простой**
- **Расширенный**

**Простой режим**

Принимает размер результирующего кортежа в качестве первого аргумента и код в качестве второго аргумента.

**Расширенный режим**

Принимает маску диапазона (кортеж) в качестве первого аргумента и код в качестве второго аргумента.
Каждое число в маске задает степень сжатия диапазона:

- `1` — без сжатия
- `2` — сжатие в 2 раза
- `3` — сжатие в 3 раза
  ⋮
- До сжатия в 8 раз.

Расширение диапазона может быть полезно, когда требуется схожее распределение для
аргументов с сильно различающимися диапазонами (или мощностью). Например: 'IP-адрес' `(0...FFFFFFFF)`
и 'Код страны' `(0...FF)`. Как и в функции кодирования, поддерживается
не более 8 чисел.

**Синтаксис**

```sql
-- Простой режим
mortonDecode(tuple_size, code)

-- Расширенный режим
mortonDecode(range_mask, code)
```

**Аргументы**

- `tuple_size` — Целочисленное значение не более 8. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — Для расширенного режима — маска для каждого аргумента. Маска представляет собой кортеж беззнаковых целых чисел. Каждое число в маске задает степень сжатия диапазона. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — Код UInt64. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает кортеж указанного размера. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**Примеры**

**Простой режим**

```sql title=Запрос
SELECT mortonDecode(3, 53)
```

```response title=Ответ
["1", "2", "3"]
```

**Один аргумент**

```sql title=Запрос
SELECT mortonDecode(1, 1)
```

```response title=Ответ
["1"]
```

**Расширенный режим, сжатие одного аргумента**

```sql title=Запрос
SELECT mortonDecode(tuple(2), 32768)
```

```response title=Ответ
["128"]
```

**Использование столбцов**

```sql title=Запрос
-- Сначала создайте таблицу и вставьте данные
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- Используйте имена столбцов вместо констант в качестве аргументов функции
SELECT untuple(mortonDecode(8, mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8))) FROM morton_numbers;
```

```response title=Ответ
1 2 3 4 5 6 7 8
```


## mortonEncode {#mortonEncode}

Введена в версии: v24.6

Вычисляет кодирование Мортона (Z-кривая) для списка беззнаковых целых чисел.

Функция работает в двух режимах:

- **Простой**
- **Расширенный**

**Простой режим**

Принимает до 8 беззнаковых целых чисел в качестве аргументов и возвращает код `UInt64`.

**Расширенный режим**

Принимает маску диапазона ([Tuple](../data-types/tuple.md)) в качестве первого аргумента и
до 8 [беззнаковых целых чисел](../data-types/int-uint.md) в качестве остальных аргументов.

Каждое число в маске задает степень расширения диапазона:

- 1 — без расширения
- 2 — двукратное расширение
- 3 — трёхкратное расширение
  ⋮
- До восьмикратного расширения.

**Синтаксис**

```sql
-- Простой режим
mortonEncode(args)

-- Расширенный режим
mortonEncode(range_mask, args)
```

**Аргументы**

- `args` — До 8 беззнаковых целых чисел или столбцов указанного типа. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — Для расширенного режима — маска для каждого аргумента. Маска представляет собой кортеж беззнаковых целых чисел от `1` до `8`. Каждое число в маске задает степень сжатия диапазона. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)

**Возвращаемое значение**

Возвращает код `UInt64`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Простой режим**

```sql title=Запрос
SELECT mortonEncode(1, 2, 3)
```

```response title=Результат
53
```

**Расширенный режим**

```sql title=Запрос
-- Расширение диапазона может быть полезно, когда требуется схожее распределение для
-- аргументов с сильно различающимися диапазонами (или мощностью).
-- Например: 'IP-адрес' (0...FFFFFFFF) и 'Код страны' (0...FF).
-- Примечание: размер кортежа должен совпадать с количеством остальных аргументов.
SELECT mortonEncode((1,2), 1024, 16)
```

```response title=Результат
1572864
```

**Один аргумент**

```sql title=Запрос
-- Кодирование Мортона для одного аргумента всегда равно самому аргументу
SELECT mortonEncode(1)
```

```response title=Результат
1
```

**Расширенный режим с одним аргументом**

```sql title=Запрос
SELECT mortonEncode(tuple(2), 128)
```

```response title=Результат
32768
```

**Использование столбцов**

```sql title=Запрос
-- Сначала создадим таблицу и вставим данные
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- Используем имена столбцов вместо констант в качестве аргументов функции
SELECT mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8) FROM morton_numbers;
```

```response title=Результат
2155374165
```


## sqidDecode {#sqidDecode}

Introduced in: v24.1

Преобразует [sqid](https://sqids.org/) обратно в массив чисел.

**Синтаксис**

```sql
sqidDecode(sqid)
```

**Аргументы**

- `sqid` — sqid для декодирования. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив чисел из `sqid`. [`Array(UInt64)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT sqidDecode('gXHfJ1C6dN');
```

```response title=Response
┌─sqidDecode('gXHfJ1C6dN')─────┐
│ [1, 2, 3, 4, 5]              │
└──────────────────────────────┘
```


## sqidEncode {#sqidEncode}

Введена в версии: v24.1

Преобразует числа в [sqid](https://sqids.org/) — строку идентификатора, аналогичную ID в YouTube.

**Синтаксис**

```sql
sqidEncode(n1[, n2, ...])
```

**Псевдонимы**: `sqid`

**Аргументы**

- `n1[, n2, ...]` — произвольное количество чисел. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает хеш-идентификатор типа [`String`](/sql-reference/data-types/string).

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT sqidEncode(1, 2, 3, 4, 5);
```

```response title=Результат
┌─sqidEncode(1, 2, 3, 4, 5)─┐
│ gXHfJ1C6dN                │
└───────────────────────────┘
```


## unbin {#unbin}

Введена в версии: v21.8

Интерпретирует каждую пару двоичных цифр (в аргументе) как число и преобразует его в байт, представленный этим числом. Функция выполняет операцию, обратную функции bin.

Для числового аргумента `unbin()` не возвращает обратное значение `bin()`. Если необходимо преобразовать результат в число, можно использовать функции reverse и `reinterpretAs<Type>`.

:::note
Если `unbin` вызывается из `clickhouse-client`, двоичные строки отображаются в кодировке UTF-8.
:::

Поддерживает двоичные цифры `0` и `1`. Количество двоичных цифр не обязательно должно быть кратно восьми. Если строка аргумента содержит что-либо, кроме двоичных цифр,
результат не определён (исключение не выбрасывается).

**Синтаксис**

```sql
unbin(arg)
```

**Аргументы**

- `arg` — строка, содержащая любое количество двоичных цифр. [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает двоичную строку (BLOB). [`String`](/sql-reference/data-types/string)

**Примеры**

**Базовое использование**

```sql title=Запрос
SELECT UNBIN('001100000011000100110010'), UNBIN('0100110101111001010100110101000101001100')
```

```response title=Результат
┌─unbin('001100000011000100110010')─┬─unbin('0100110101111001010100110101000101001100')─┐
│ 012                               │ MySQL                                             │
└───────────────────────────────────┴───────────────────────────────────────────────────┘
```

**Преобразование в число**

```sql title=Запрос
SELECT reinterpretAsUInt64(reverse(unbin('1110'))) AS num
```

```response title=Результат
┌─num─┐
│  14 │
└─────┘
```


## unhex {#unhex}

Введена в версии: v1.1

Выполняет операцию, обратную [`hex`](#hex). Интерпретирует каждую пару шестнадцатеричных цифр (в аргументе) как число и преобразует
его в байт, представленный этим числом. Возвращаемое значение — двоичная строка (BLOB).

Если необходимо преобразовать результат в число, можно использовать функции `reverse` и `reinterpretAs<Type>`.

:::note
`clickhouse-client` интерпретирует строки как UTF-8.
Это может привести к неожиданному отображению значений, возвращаемых функцией `hex`.
:::

Поддерживаются как прописные, так и строчные буквы `A-F`.
Количество шестнадцатеричных цифр не обязательно должно быть четным.
Если оно нечетное, последняя цифра интерпретируется как младшая половина байта `00-0F`.
Если строка аргумента содержит символы, отличные от шестнадцатеричных цифр, возвращается результат, определяемый реализацией (исключение не выбрасывается).
Для числового аргумента функция unhex() не выполняет операцию, обратную hex(N).

**Синтаксис**

```sql
unhex(arg)
```

**Аргументы**

- `arg` — строка, содержащая любое количество шестнадцатеричных цифр. Тип: [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring).

**Возвращаемое значение**

Возвращает двоичную строку (BLOB). Тип: [`String`](/sql-reference/data-types/string).

**Примеры**

**Базовое использование**

```sql title=Query
SELECT unhex('303132'), UNHEX('4D7953514C')
```

```response title=Response
┌─unhex('303132')─┬─unhex('4D7953514C')─┐
│ 012             │ MySQL               │
└─────────────────┴─────────────────────┘
```

**Преобразование в число**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unhex('FFF'))) AS num
```

```response title=Response
┌──num─┐
│ 4095 │
└──────┘
```

<!--AUTOGENERATED_END-->

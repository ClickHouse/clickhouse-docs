---
slug: /sql-reference/functions/type-conversion-functions
sidebar_position: 185
sidebar_label: Преобразование типов
---


# Преобразование типов
## Общие проблемы с преобразованием данных {#common-issues-with-data-conversion}

ClickHouse, как правило, использует [такое же поведение, как и программы на C++](https://en.cppreference.com/w/cpp/language/implicit_conversion).

Функции `to<type>` и [cast](#cast) ведут себя по-разному в некоторых случаях, например, в случае [LowCardinality](../data-types/lowcardinality.md): [cast](#cast) удаляет признак [LowCardinality](../data-types/lowcardinality.md), тогда как функции `to<type>` этого не делают. То же самое касается [Nullable](../data-types/nullable.md), данное поведение несовместимо со стандартом SQL и может быть изменено с помощью настройки [cast_keep_nullable](../../operations/settings/settings.md/#cast_keep_nullable).

:::note
Обратите внимание на потенциальную потерю данных, если значения типа данных преобразуются в меньший тип данных (например, из `Int64` в `Int32`) или между несовместимыми типами данных (например, из `String` в `Int`). Убедитесь, что результат соответствует ожидаемому.
:::

Пример:

```sql
SELECT
    toTypeName(toLowCardinality('') AS val) AS source_type,
    toTypeName(toString(val)) AS to_type_result_type,
    toTypeName(CAST(val, 'String')) AS cast_result_type

┌─source_type────────────┬─to_type_result_type────┬─cast_result_type─┐
│ LowCardinality(String) │ LowCardinality(String) │ String           │
└────────────────────────┴────────────────────────┴──────────────────┘

SELECT
    toTypeName(toNullable('') AS val) AS source_type,
    toTypeName(toString(val)) AS to_type_result_type,
    toTypeName(CAST(val, 'String')) AS cast_result_type

┌─source_type──────┬─to_type_result_type─┬─cast_result_type─┐
│ Nullable(String) │ Nullable(String)    │ String           │
└──────────────────┴─────────────────────┴──────────────────┘

SELECT
    toTypeName(toNullable('') AS val) AS source_type,
    toTypeName(toString(val)) AS to_type_result_type,
    toTypeName(CAST(val, 'String')) AS cast_result_type
SETTINGS cast_keep_nullable = 1

┌─source_type──────┬─to_type_result_type─┬─cast_result_type─┐
│ Nullable(String) │ Nullable(String)    │ Nullable(String) │
└──────────────────┴─────────────────────┴──────────────────┘
```
## toBool {#tobool}

Преобразует входное значение в значение типа [`Bool`](../data-types/boolean.md). Генерирует исключение в случае ошибки.

**Синтаксис**

```sql
toBool(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку. [Выражение](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения типов (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.
- Строки `true` или `false` (регистронезависимо).

**Возвращаемое значение**

- Возвращает `true` или `false` в зависимости от оценки аргумента. [Bool](../data-types/boolean.md).

**Пример**

Запрос:

```sql
SELECT
    toBool(toUInt8(1)),
    toBool(toInt8(-1)),
    toBool(toFloat32(1.01)),
    toBool('true'),
    toBool('false'),
    toBool('FALSE')
FORMAT Vertical
```

Результат:

```response
toBool(toUInt8(1)):      true
toBool(toInt8(-1)):      true
toBool(toFloat32(1.01)): true
toBool('true'):          true
toBool('false'):         false
toBool('FALSE'):         false
```
## toInt8 {#toint8}

Преобразует входное значение в значение типа [`Int8`](../data-types/int-uint.md). Генерирует исключение в случае ошибки.

**Синтаксис**

```sql
toInt8(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Несоответствующие аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt8('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int8](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
Например: `SELECT toInt8(128) == -128;`.
:::

**Возвращаемое значение**

- 8-битное целое значение. [Int8](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toInt8(-8),
    toInt8(-8.8),
    toInt8('-8')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt8(-8):   -8
toInt8(-8.8): -8
toInt8('-8'): -8
```

**См. также**

- [`toInt8OrZero`](#toint8orzero).
- [`toInt8OrNull`](#toInt8OrNull).
- [`toInt8OrDefault`](#toint8ordefault).
## toInt8OrZero {#toint8orzero}

Как [`toInt8`](#toint8), эта функция преобразует входное значение в значение типа [Int8](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toInt8OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Несоответствующие аргументы (возвращают `0`):
- Строковые представления обычных значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt8OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int8](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 8-битное целое значение, если успешно, в противном случае `0`. [Int8](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt8OrZero('-8'),
    toInt8OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt8OrZero('-8'):  -8
toInt8OrZero('abc'): 0
```

**См. также**

- [`toInt8`](#toint8).
- [`toInt8OrNull`](#toInt8OrNull).
- [`toInt8OrDefault`](#toint8ordefault).
## toInt8OrNull {#toInt8OrNull}

Как [`toInt8`](#toint8), эта функция преобразует входное значение в значение типа [Int8](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toInt8OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Несоответствующие аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt8OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int8](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 8-битное целое значение, если успешно, в противном случае `NULL`. [Int8](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt8OrNull('-8'),
    toInt8OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt8OrNull('-8'):  -8
toInt8OrNull('abc'): ᴺᵁᴸᴸ
```

**См. также**

- [`toInt8`](#toint8).
- [`toInt8OrZero`](#toint8orzero).
- [`toInt8OrDefault`](#toint8ordefault).
## toInt8OrDefault {#toint8ordefault}

Как [`toInt8`](#toint8), эта функция преобразует входное значение в значение типа [Int8](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки.
Если значение `default` не передано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toInt8OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию для возврата, если разбор типа `Int8` не выполнен успешно. [Int8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt8OrDefault('0xc0fe', CAST('-1', 'Int8'));`.

:::note
Если входное значение не может быть представлено в пределах границ [Int8](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 8-битное целое значение, если успешно, в противном случае возвращает значение по умолчанию, если передано, или `0`, если не передано. [Int8](../data-types/int-uint.md).

:::note
- Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
- Тип значения по умолчанию должен совпадать с типом приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt8OrDefault('-8', CAST('-1', 'Int8')),
    toInt8OrDefault('abc', CAST('-1', 'Int8'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt8OrDefault('-8', CAST('-1', 'Int8')):  -8
toInt8OrDefault('abc', CAST('-1', 'Int8')): -1
```

**См. также**

- [`toInt8`](#toint8).
- [`toInt8OrZero`](#toint8orzero).
- [`toInt8OrNull`](#toInt8OrNull).
## toInt16 {#toint16}

Преобразует входное значение в значение типа [`Int16`](../data-types/int-uint.md). Генерирует исключение в случае ошибки.

**Синтаксис**

```sql
toInt16(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Несоответствующие аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt16('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int16](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
Например: `SELECT toInt16(32768) == -32768;`.
:::

**Возвращаемое значение**

- 16-битное целое значение. [Int16](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toInt16(-16),
    toInt16(-16.16),
    toInt16('-16')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt16(-16):    -16
toInt16(-16.16): -16
toInt16('-16'):  -16
```

**См. также**

- [`toInt16OrZero`](#toint16orzero).
- [`toInt16OrNull`](#toint16ornull).
- [`toInt16OrDefault`](#toint16ordefault).
## toInt16OrZero {#toint16orzero}

Как [`toInt16`](#toint16), эта функция преобразует входное значение в значение типа [Int16](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toInt16OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Несоответствующие аргументы (возвращают `0`):
- Строковые представления Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt16OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int16](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 16-битное целое значение, если успешно, в противном случае `0`. [Int16](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt16OrZero('-16'),
    toInt16OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt16OrZero('-16'): -16
toInt16OrZero('abc'): 0
```

**См. также**

- [`toInt16`](#toint16).
- [`toInt16OrNull`](#toint16ornull).
- [`toInt16OrDefault`](#toint16ordefault).
## toInt16OrNull {#toint16ornull}

Как [`toInt16`](#toint16), эта функция преобразует входное значение в значение типа [Int16](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toInt16OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Несоответствующие аргументы (возвращают `\N`)
- Строковые представления Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt16OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int16](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 16-битное целое значение, если успешно, в противном случае `NULL`. [Int16](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt16OrNull('-16'),
    toInt16OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt16OrNull('-16'): -16
toInt16OrNull('abc'): ᴺᵁᴸᴸ
```

**См. также**

- [`toInt16`](#toint16).
- [`toInt16OrZero`](#toint16orzero).
- [`toInt16OrDefault`](#toint16ordefault).
## toInt16OrDefault {#toint16ordefault}

Как [`toInt16`](#toint16), эта функция преобразует входное значение в значение типа [Int16](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки.
Если значение `default` не передано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toInt16OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию для возврата, если разбор типа `Int16` не выполнен успешно. [Int16](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt16OrDefault('0xc0fe', CAST('-1', 'Int16'));`.

:::note
Если входное значение не может быть представлено в пределах границ [Int16](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 16-битное целое значение, если успешно, в противном случае возвращает значение по умолчанию, если передано, или `0`, если не передано. [Int16](../data-types/int-uint.md).

:::note
- Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
- Тип значения по умолчанию должен совпадать с типом приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt16OrDefault('-16', CAST('-1', 'Int16')),
    toInt16OrDefault('abc', CAST('-1', 'Int16'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt16OrDefault('-16', CAST('-1', 'Int16')): -16
toInt16OrDefault('abc', CAST('-1', 'Int16')): -1
```

**См. также**

- [`toInt16`](#toint16).
- [`toInt16OrZero`](#toint16orzero).
- [`toInt16OrNull`](#toint16ornull).
## toInt32 {#toint32}

Преобразует входное значение в значение типа [`Int32`](../data-types/int-uint.md). Генерирует исключение в случае ошибки.

**Синтаксис**

```sql
toInt32(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Несоответствующие аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt32('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int32](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
Например: `SELECT toInt32(2147483648) == -2147483648;`.
:::

**Возвращаемое значение**

- 32-битное целое значение. [Int32](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toInt32(-32),
    toInt32(-32.32),
    toInt32('-32')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt32(-32):    -32
toInt32(-32.32): -32
toInt32('-32'):  -32
```

**См. также**

- [`toInt32OrZero`](#toint32orzero).
- [`toInt32OrNull`](#toint32ornull).
- [`toInt32OrDefault`](#toint32ordefault).
## toInt32OrZero {#toint32orzero}

Как [`toInt32`](#toint32), эта функция преобразует входное значение в значение типа [Int32](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toInt32OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Несоответствующие аргументы (возвращают `0`):
- Строковые представления Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt32OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int32](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 32-битное целое значение, если успешно, в противном случае `0`. [Int32](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt32OrZero('-32'),
    toInt32OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt32OrZero('-32'): -32
toInt32OrZero('abc'): 0
```
**См. также**

- [`toInt32`](#toint32).
- [`toInt32OrNull`](#toint32ornull).
- [`toInt32OrDefault`](#toint32ordefault).
## toInt32OrNull {#toint32ornull}

Как [`toInt32`](#toint32), эта функция преобразует входное значение в значение типа [Int32](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toInt32OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Несоответствующие аргументы (возвращают `\N`)
- Строковые представления Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt32OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int32](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 32-битное целое значение, если успешно, в противном случае `NULL`. [Int32](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt32OrNull('-32'),
    toInt32OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt32OrNull('-32'): -32
toInt32OrNull('abc'): ᴺᵁᴸᴸ
```

**См. также**

- [`toInt32`](#toint32).
- [`toInt32OrZero`](#toint32orzero).
- [`toInt32OrDefault`](#toint32ordefault).
## toInt32OrDefault {#toint32ordefault}

Как [`toInt32`](#toint32), эта функция преобразует входное значение в значение типа [Int32](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки.
Если значение `default` не передано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toInt32OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию для возврата, если разбор типа `Int32` не выполнен успешно. [Int32](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt32OrDefault('0xc0fe', CAST('-1', 'Int32'));`.

:::note
Если входное значение не может быть представлено в пределах границ [Int32](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 32-битное целое значение, если успешно, в противном случае возвращает значение по умолчанию, если передано, или `0`, если не передано. [Int32](../data-types/int-uint.md).

:::note
- Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
- Тип значения по умолчанию должен совпадать с типом приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt32OrDefault('-32', CAST('-1', 'Int32')),
    toInt32OrDefault('abc', CAST('-1', 'Int32'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt32OrDefault('-32', CAST('-1', 'Int32')): -32
toInt32OrDefault('abc', CAST('-1', 'Int32')): -1
```

**См. также**

- [`toInt32`](#toint32).
- [`toInt32OrZero`](#toint32orzero).
- [`toInt32OrNull`](#toint32ornull).
## toInt64 {#toint64}

Преобразует входное значение в значение типа [`Int64`](../data-types/int-uint.md). Генерирует исключение в случае ошибки.

**Синтаксис**

```sql
toInt64(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Несоответствующие типы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt64('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int64](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
Например: `SELECT toInt64(9223372036854775808) == -9223372036854775808;`
:::

**Возвращаемое значение**

- 64-битное целое значение. [Int64](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toInt64(-64),
    toInt64(-64.64),
    toInt64('-64')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt64(-64):    -64
toInt64(-64.64): -64
toInt64('-64'):  -64
```

**См. также**

- [`toInt64OrZero`](#toint64orzero).
- [`toInt64OrNull`](#toint64ornull).
- [`toInt64OrDefault`](#toint64ordefault).
## toInt64OrZero {#toint64orzero}

Как [`toInt64`](#toint64), эта функция преобразует входное значение в значение типа [Int64](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toInt64OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Несоответствующие аргументы (возвращают `0`):
- Строковые представления Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt64OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int64](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 64-битное целое значение, если успешно, в противном случае `0`. [Int64](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt64OrZero('-64'),
    toInt64OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt64OrZero('-64'): -64
toInt64OrZero('abc'): 0
```

**См. также**

- [`toInt64`](#toint64).
- [`toInt64OrNull`](#toint64ornull).
- [`toInt64OrDefault`](#toint64ordefault).
## toInt64OrNull {#toint64ornull}

Как [`toInt64`](#toint64), эта функция преобразует входное значение в значение типа [Int64](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toInt64OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Несоответствующие аргументы (возвращают `\N`)
- Строковые представления Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt64OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int64](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 64-битное целое значение, если успешно, в противном случае `NULL`. [Int64](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt64OrNull('-64'),
    toInt64OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt64OrNull('-64'): -64
toInt64OrNull('abc'): ᴺᵁᴸᴸ
```

**См. также**

- [`toInt64`](#toint64).
- [`toInt64OrZero`](#toint64orzero).
- [`toInt64OrDefault`](#toint64ordefault).
## toInt64OrDefault {#toint64ordefault}

Как [`toInt64`](#toint64), эта функция преобразует входное значение в значение типа [Int64](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки.
Если значение `default` не передано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toInt64OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию для возврата, если разбор типа `Int64` не выполнен успешно. [Int64](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt64OrDefault('0xc0fe', CAST('-1', 'Int64'));`.

:::note
Если входное значение не может быть представлено в пределах границ [Int64](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 64-битное целое значение, если успешно, в противном случае возвращает значение по умолчанию, если передано, или `0`, если не передано. [Int64](../data-types/int-uint.md).

:::note
- Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
- Тип значения по умолчанию должен совпадать с типом приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt64OrDefault('-64', CAST('-1', 'Int64')),
    toInt64OrDefault('abc', CAST('-1', 'Int64'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt64OrDefault('-64', CAST('-1', 'Int64')): -64
toInt64OrDefault('abc', CAST('-1', 'Int64')): -1
```

**См. также**

- [`toInt64`](#toint64).
- [`toInt64OrZero`](#toint64orzero).
- [`toInt64OrNull`](#toint64ornull).
## toInt128 {#toint128}

Преобразует входное значение в значение типа [`Int128`](../data-types/int-uint.md). Генерирует исключение в случае ошибки.

**Синтаксис**

```sql
toInt128(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строку, представляющую число. [Выражение](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типов Float32/64.

Несоответствующие аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления бинарных и шестнадцатеричных значений, например, `SELECT toInt128('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах границ [Int128](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 128-битное целое значение. [Int128](../data-types/int-uint.md).

:::note
Функция использует [округление в сторону нуля](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toInt128(-128),
    toInt128(-128.8),
    toInt128('-128')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt128(-128):   -128
toInt128(-128.8): -128
toInt128('-128'): -128
```

**См. также**

- [`toInt128OrZero`](#toint128orzero).
- [`toInt128OrNull`](#toint128ornull).
- [`toInt128OrDefault`](#toint128ordefault).

## toInt128OrZero {#toint128orzero}

Как и [`toInt128`](#toint128), эта функция преобразует входное значение в значение типа [Int128](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toInt128OrZero(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toInt128OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [Int128](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 128-битовое целочисленное значение, если успешно, в противном случае `0`. [Int128](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt128OrZero('-128'),
    toInt128OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt128OrZero('-128'): -128
toInt128OrZero('abc'):  0
```

**Смотрите также**

- [`toInt128`](#toint128).
- [`toInt128OrNull`](#toint128ornull).
- [`toInt128OrDefault`](#toint128ordefault).
## toInt128OrNull {#toint128ornull}

Как и [`toInt128`](#toint128), эта функция преобразует входное значение в значение типа [Int128](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toInt128OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toInt128OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [Int128](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 128-битовое целочисленное значение, если успешно, в противном случае `NULL`. [Int128](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt128OrNull('-128'),
    toInt128OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt128OrNull('-128'): -128
toInt128OrNull('abc'):  ᴺᵁᴸᴸ
```

**Смотрите также**

- [`toInt128`](#toint128).
- [`toInt128OrZero`](#toint128orzero).
- [`toInt128OrDefault`](#toint128ordefault).
## toInt128OrDefault {#toint128ordefault}

Как и [`toInt128`](#toint128), эта функция преобразует входное значение в значение типа [Int128](../data-types/int-uint.md) но возвращает значение по умолчанию в случае ошибки.
Если значение `default` не передано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toInt128OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию, которое нужно вернуть, если преобразование в тип `Int128` не удалось. [Int128](../data-types/int-uint.md).

Поддерживаемые аргументы:
- (U)Int8/16/32/64/128/256.
- Float32/64.
- Строковые представления (U)Int8/16/32/128/256.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toInt128OrDefault('0xc0fe', CAST('-1', 'Int128'));`.

:::note
Если входное значение не может быть представлено в пределах [Int128](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 128-битовое целочисленное значение, если успешно, в противном случае возвращает значение по умолчанию, если оно передано, или `0`, если нет. [Int128](../data-types/int-uint.md).

:::note
- Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
- Тип значения по умолчанию должен совпадать с типом приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt128OrDefault('-128', CAST('-1', 'Int128')),
    toInt128OrDefault('abc', CAST('-1', 'Int128'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt128OrDefault('-128', CAST('-1', 'Int128')): -128
toInt128OrDefault('abc', CAST('-1', 'Int128')):  -1
```

**Смотрите также**

- [`toInt128`](#toint128).
- [`toInt128OrZero`](#toint128orzero).
- [`toInt128OrNull`](#toint128ornull).
## toInt256 {#toint256}

Преобразует входное значение в значение типа [`Int256`](../data-types/int-uint.md). Возвращает исключение в случае ошибки.

**Синтаксис**

```sql
toInt256(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toInt256('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [Int256](../data-types/int-uint.md), результат переполнится или недополнится.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 256-битовое целочисленное значение. [Int256](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toInt256(-256),
    toInt256(-256.256),
    toInt256('-256')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt256(-256):     -256
toInt256(-256.256): -256
toInt256('-256'):   -256
```

**Смотрите также**

- [`toInt256OrZero`](#toint256orzero).
- [`toInt256OrNull`](#toint256ornull).
- [`toInt256OrDefault`](#toint256ordefault).
## toInt256OrZero {#toint256orzero}

Как и [`toInt256`](#toint256), эта функция преобразует входное значение в значение типа [Int256](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toInt256OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toInt256OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [Int256](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 256-битовое целочисленное значение, если успешно, в противном случае `0`. [Int256](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt256OrZero('-256'),
    toInt256OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt256OrZero('-256'): -256
toInt256OrZero('abc'):  0
```

**Смотрите также**

- [`toInt256`](#toint256).
- [`toInt256OrNull`](#toint256ornull).
- [`toInt256OrDefault`](#toint256ordefault).
## toInt256OrNull {#toint256ornull}

Как и [`toInt256`](#toint256), эта функция преобразует входное значение в значение типа [Int256](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toInt256OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toInt256OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [Int256](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 256-битовое целочисленное значение, если успешно, в противном случае `NULL`. [Int256](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt256OrNull('-256'),
    toInt256OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt256OrNull('-256'): -256
toInt256OrNull('abc'):  ᴺᵁᴸᴸ
```

**Смотрите также**

- [`toInt256`](#toint256).
- [`toInt256OrZero`](#toint256orzero).
- [`toInt256OrDefault`](#toint256ordefault).
## toInt256OrDefault {#toint256ordefault}

Как и [`toInt256`](#toint256), эта функция преобразует входное значение в значение типа [Int256](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки.
Если значение по умолчанию не передано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toInt256OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию, которое нужно вернуть, если преобразование в тип `Int256` не удалось. [Int256](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toInt256OrDefault('0xc0fe', CAST('-1', 'Int256'));`.

:::note
Если входное значение не может быть представлено в пределах [Int256](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 256-битовое целочисленное значение, если успешно, в противном случае возвращает значение по умолчанию, если оно передано, или `0`, если нет. [Int256](../data-types/int-uint.md).

:::note
- Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
- Тип значения по умолчанию должен совпадать с типом приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toInt256OrDefault('-256', CAST('-1', 'Int256')),
    toInt256OrDefault('abc', CAST('-1', 'Int256'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toInt256OrDefault('-256', CAST('-1', 'Int256')): -256
toInt256OrDefault('abc', CAST('-1', 'Int256')):  -1
```

**Смотрите также**

- [`toInt256`](#toint256).
- [`toInt256OrZero`](#toint256orzero).
- [`toInt256OrNull`](#toint256ornull).
## toUInt8 {#touint8}

Преобразует входное значение в значение типа [`UInt8`](../data-types/int-uint.md). Возвращает исключение в случае ошибки.

**Синтаксис**

```sql
toUInt8(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt8('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt8](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
Например: `SELECT toUInt8(256) == 0;`.
:::

**Возвращаемое значение**

- 8-битовое беззнаковое целочисленное значение. [UInt8](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toUInt8(8),
    toUInt8(8.8),
    toUInt8('8')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt8(8):   8
toUInt8(8.8): 8
toUInt8('8'): 8
```

**Смотрите также**

- [`toUInt8OrZero`](#touint8orzero).
- [`toUInt8OrNull`](#touint8ornull).
- [`toUInt8OrDefault`](#touint8ordefault).
## toUInt8OrZero {#touint8orzero}

Как и [`toUInt8`](#touint8), эта функция преобразует входное значение в значение типа [UInt8](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toUInt8OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления значений обычных Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt8OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt8](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 8-битовое беззнаковое целочисленное значение, если успешно, в противном случае `0`. [UInt8](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt8OrZero('-8'),
    toUInt8OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt8OrZero('-8'):  0
toUInt8OrZero('abc'): 0
```

**Смотрите также**

- [`toUInt8`](#touint8).
- [`toUInt8OrNull`](#touint8ornull).
- [`toUInt8OrDefault`](#touint8ordefault).
## toUInt8OrNull {#touint8ornull}

Как и [`toUInt8`](#touint8), эта функция преобразует входное значение в значение типа [UInt8](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toUInt8OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt8OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt8](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 8-битовое беззнаковое целочисленное значение, если успешно, в противном случае `NULL`. [UInt8](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt8OrNull('8'),
    toUInt8OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt8OrNull('8'):   8
toUInt8OrNull('abc'): ᴺᵁᴸᴸ
```

**Смотрите также**

- [`toUInt8`](#touint8).
- [`toUInt8OrZero`](#touint8orzero).
- [`toUInt8OrDefault`](#touint8ordefault).
## toUInt8OrDefault {#touint8ordefault}

Как и [`toUInt8`](#touint8), эта функция преобразует входное значение в значение типа [UInt8](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки.
Если значение по умолчанию не передано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toUInt8OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию, которое нужно вернуть, если преобразование в тип `UInt8` не удалось. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt8OrDefault('0xc0fe', CAST('0', 'UInt8'));`.

:::note
Если входное значение не может быть представлено в пределах [UInt8](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 8-битовое беззнаковое целочисленное значение, если успешно, в противном случае возвращает значение по умолчанию, если оно передано, или `0`, если нет. [UInt8](../data-types/int-uint.md).

:::note
- Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
- Тип значения по умолчанию должен совпадать с типом приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt8OrDefault('8', CAST('0', 'UInt8')),
    toUInt8OrDefault('abc', CAST('0', 'UInt8'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt8OrDefault('8', CAST('0', 'UInt8')):   8
toUInt8OrDefault('abc', CAST('0', 'UInt8')): 0
```

**Смотрите также**

- [`toUInt8`](#touint8).
- [`toUInt8OrZero`](#touint8orzero).
- [`toUInt8OrNull`](#touint8ornull).
## toUInt16 {#touint16}

Преобразует входное значение в значение типа [`UInt16`](../data-types/int-uint.md). Возвращает исключение в случае ошибки.

**Синтаксис**

```sql
toUInt16(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt16('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt16](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
Например: `SELECT toUInt16(65536) == 0;`.
:::

**Возвращаемое значение**

- 16-битовое беззнаковое целочисленное значение. [UInt16](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toUInt16(16),
    toUInt16(16.16),
    toUInt16('16')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt16(16):    16
toUInt16(16.16): 16
toUInt16('16'):  16
```

**Смотрите также**

- [`toUInt16OrZero`](#touint16orzero).
- [`toUInt16OrNull`](#touint16ornull).
- [`toUInt16OrDefault`](#touint16ordefault).
## toUInt16OrZero {#touint16orzero}

Как и [`toUInt16`](#touint16), эта функция преобразует входное значение в значение типа [UInt16](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toUInt16OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt16OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt16](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 16-битовое беззнаковое целочисленное значение, если успешно, в противном случае `0`. [UInt16](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt16OrZero('16'),
    toUInt16OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt16OrZero('16'):  16
toUInt16OrZero('abc'): 0
```

**Смотрите также**

- [`toUInt16`](#touint16).
- [`toUInt16OrNull`](#touint16ornull).
- [`toUInt16OrDefault`](#touint16ordefault).
## toUInt16OrNull {#touint16ornull}

Как и [`toUInt16`](#touint16), эта функция преобразует входное значение в значение типа [UInt16](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toUInt16OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt16OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt16](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 16-битовое беззнаковое целочисленное значение, если успешно, в противном случае `NULL`. [UInt16](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt16OrNull('16'),
    toUInt16OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt16OrNull('16'):  16
toUInt16OrNull('abc'): ᴺᵁᴸᴸ
```

**Смотрите также**

- [`toUInt16`](#touint16).
- [`toUInt16OrZero`](#touint16orzero).
- [`toUInt16OrDefault`](#touint16ordefault).
## toUInt16OrDefault {#touint16ordefault}

Как и [`toUInt16`](#touint16), эта функция преобразует входное значение в значение типа [UInt16](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки.
Если значение по умолчанию не передано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toUInt16OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию, которое нужно вернуть, если преобразование в тип `UInt16` не удалось. [UInt16](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt16OrDefault('0xc0fe', CAST('0', 'UInt16'));`.

:::note
Если входное значение не может быть представлено в пределах [UInt16](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 16-битовое беззнаковое целочисленное значение, если успешно, в противном случае возвращает значение по умолчанию, если оно передано, или `0`, если нет. [UInt16](../data-types/int-uint.md).

:::note
- Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
- Тип значения по умолчанию должен совпадать с типом приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt16OrDefault('16', CAST('0', 'UInt16')),
    toUInt16OrDefault('abc', CAST('0', 'UInt16'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt16OrDefault('16', CAST('0', 'UInt16')):  16
toUInt16OrDefault('abc', CAST('0', 'UInt16')): 0
```

**Смотрите также**

- [`toUInt16`](#touint16).
- [`toUInt16OrZero`](#touint16orzero).
- [`toUInt16OrNull`](#touint16ornull).
## toUInt32 {#touint32}

Преобразует входное значение в значение типа [`UInt32`](../data-types/int-uint.md). Возвращает исключение в случае ошибки.

**Синтаксис**

```sql
toUInt32(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt32('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt32](../data-types/int-uint.md), результат переполнится или недополнится.
Это не считается ошибкой.
Например: `SELECT toUInt32(4294967296) == 0;`
:::

**Возвращаемое значение**

- 32-битовое беззнаковое целочисленное значение. [UInt32](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toUInt32(32),
    toUInt32(32.32),
    toUInt32('32')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt32(32):    32
toUInt32(32.32): 32
toUInt32('32'):  32
```

**Смотрите также**

- [`toUInt32OrZero`](#touint32orzero).
- [`toUInt32OrNull`](#touint32ornull).
- [`toUInt32OrDefault`](#touint32ordefault).
## toUInt32OrZero {#touint32orzero}

Как и [`toUInt32`](#touint32), эта функция преобразует входное значение в значение типа [UInt32](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toUInt32OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt32OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt32](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 32-битовое беззнаковое целочисленное значение, если успешно, в противном случае `0`. [UInt32](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero)
, что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt32OrZero('32'),
    toUInt32OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt32OrZero('32'):  32
toUInt32OrZero('abc'): 0
```
**Смотрите также**

- [`toUInt32`](#touint32).
- [`toUInt32OrNull`](#touint32ornull).
- [`toUInt32OrDefault`](#touint32ordefault).
## toUInt32OrNull {#touint32ornull}

Как и [`toUInt32`](#touint32), эта функция преобразует входное значение в значение типа [UInt32](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toUInt32OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toUInt32OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах [UInt32](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 32-битовое беззнаковое целочисленное значение, если успешно, в противном случае `NULL`. [UInt32](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero)
, что означает, что она отбрасывает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt32OrNull('32'),
    toUInt32OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt32OrNull('32'):  32
toUInt32OrNull('abc'): ᴺᵁᴸᴸ
```

**Смотрите также**

- [`toUInt32`](#touint32).
- [`toUInt32OrZero`](#touint32orzero).
- [`toUInt32OrDefault`](#touint32ordefault).
```

## toUInt32OrDefault {#touint32ordefault}

Как и [`toUInt32`](#touint32), эта функция преобразует входное значение в значение типа [UInt32](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки. 
Если значение `default` не передано, то возвращается `0` в случае ошибки.

**Синтаксис**

```sql
toUInt32OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательно) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `UInt32` не удался. [UInt32](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt32OrDefault('0xc0fe', CAST('0', 'UInt32'));`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt32](../data-types/int-uint.md), происходит переполнение или недополнение результата. 
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 32-битное беззнаковое целое значение, если успешно, иначе возвращает значение по умолчанию, если оно передано, или `0`, если нет. [UInt32](../data-types/int-uint.md).

:::note
- Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
- Тип значения по умолчанию должен быть таким же, как и тип приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt32OrDefault('32', CAST('0', 'UInt32')),
    toUInt32OrDefault('abc', CAST('0', 'UInt32'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt32OrDefault('32', CAST('0', 'UInt32')):  32
toUInt32OrDefault('abc', CAST('0', 'UInt32')): 0
```

**См. также**

- [`toUInt32`](#touint32).
- [`toUInt32OrZero`](#touint32orzero).
- [`toUInt32OrNull`](#touint32ornull).
## toUInt64 {#touint64}

Преобразует входное значение в значение типа [`UInt64`](../data-types/int-uint.md). Вызывает исключение в случае ошибки.

**Синтаксис**

```sql
toUInt64(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Неподдерживаемые типы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt64('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt64](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
Например: `SELECT toUInt64(18446744073709551616) == 0;`
:::

**Возвращаемое значение**

- 64-битное беззнаковое целое значение. [UInt64](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toUInt64(64),
    toUInt64(64.64),
    toUInt64('64')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt64(64):    64
toUInt64(64.64): 64
toUInt64('64'):  64
```

**См. также**

- [`toUInt64OrZero`](#touint64orzero).
- [`toUInt64OrNull`](#touint64ornull).
- [`toUInt64OrDefault`](#touint64ordefault).
## toUInt64OrZero {#touint64orzero}

Как и [`toUInt64`](#touint64), эта функция преобразует входное значение в значение типа [UInt64](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toUInt64OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt64OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt64](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 64-битное беззнаковое целое значение, если успешно, иначе `0`. [UInt64](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt64OrZero('64'),
    toUInt64OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt64OrZero('64'):  64
toUInt64OrZero('abc'): 0
```

**См. также**

- [`toUInt64`](#touint64).
- [`toUInt64OrNull`](#touint64ornull).
- [`toUInt64OrDefault`](#touint64ordefault).
## toUInt64OrNull {#touint64ornull}

Как и [`toUInt64`](#touint64), эта функция преобразует входное значение в значение типа [UInt64](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toUInt64OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt64OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt64](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 64-битное беззнаковое целое значение, если успешно, иначе `NULL`. [UInt64](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt64OrNull('64'),
    toUInt64OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt64OrNull('64'):  64
toUInt64OrNull('abc'): ᴺᵁᴸᴸ
```

**См. также**

- [`toUInt64`](#touint64).
- [`toUInt64OrZero`](#touint64orzero).
- [`toUInt64OrDefault`](#touint64ordefault).
## toUInt64OrDefault {#touint64ordefault}

Как и [`toUInt64`](#touint64), эта функция преобразует входное значение в значение типа [UInt64](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки.
Если значение `default` не передано, то возвращается `0` в случае ошибки.

**Синтаксис**

```sql
toUInt64OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательно) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `UInt64` не удался. [UInt64](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt64OrDefault('0xc0fe', CAST('0', 'UInt64'));`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt64](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 64-битное беззнаковое целое значение, если успешно, иначе возвращает значение по умолчанию, если оно передано, или `0`, если нет. [UInt64](../data-types/int-uint.md).

:::note
- Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
- Тип значения по умолчанию должен быть таким же, как и тип приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt64OrDefault('64', CAST('0', 'UInt64')),
    toUInt64OrDefault('abc', CAST('0', 'UInt64'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt64OrDefault('64', CAST('0', 'UInt64')):  64
toUInt64OrDefault('abc', CAST('0', 'UInt64')): 0
```

**См. также**

- [`toUInt64`](#touint64).
- [`toUInt64OrZero`](#touint64orzero).
- [`toUInt64OrNull`](#touint64ornull).
## toUInt128 {#touint128}

Преобразует входное значение в значение типа [`UInt128`](../data-types/int-uint.md). Вызывает исключение в случае ошибки.

**Синтаксис**

```sql
toUInt128(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt128('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt128](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 128-битное беззнаковое целое значение. [UInt128](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toUInt128(128),
    toUInt128(128.8),
    toUInt128('128')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt128(128):   128
toUInt128(128.8): 128
toUInt128('128'): 128
```

**См. также**

- [`toUInt128OrZero`](#touint128orzero).
- [`toUInt128OrNull`](#touint128ornull).
- [`toUInt128OrDefault`](#touint128ordefault).
## toUInt128OrZero {#touint128orzero}

Как и [`toUInt128`](#touint128), эта функция преобразует входное значение в значение типа [UInt128](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toUInt128OrZero(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt128OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt128](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 128-битное беззнаковое целое значение, если успешно, иначе `0`. [UInt128](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt128OrZero('128'),
    toUInt128OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt128OrZero('128'): 128
toUInt128OrZero('abc'): 0
```

**См. также**

- [`toUInt128`](#touint128).
- [`toUInt128OrNull`](#touint128ornull).
- [`toUInt128OrDefault`](#touint128ordefault).
## toUInt128OrNull {#touint128ornull}

Как и [`toUInt128`](#touint128), эта функция преобразует входное значение в значение типа [UInt128](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toUInt128OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt128OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt128](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 128-битное беззнаковое целое значение, если успешно, иначе `NULL`. [UInt128](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt128OrNull('128'),
    toUInt128OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt128OrNull('128'): 128
toUInt128OrNull('abc'): ᴺᵁᴸᴸ
```

**См. также**

- [`toUInt128`](#touint128).
- [`toUInt128OrZero`](#touint128orzero).
- [`toUInt128OrDefault`](#touint128ordefault).
## toUInt128OrDefault {#touint128ordefault}

Как и [`toUInt128`](#toint128), эта функция преобразует входное значение в значение типа [UInt128](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки. 
Если значение `default` не передано, то возвращается `0` в случае ошибки.

**Синтаксис**

```sql
toUInt128OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательно) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `UInt128` не удался. [UInt128](../data-types/int-uint.md).

Поддерживаемые аргументы:
- (U)Int8/16/32/64/128/256.
- Float32/64.
- Строковые представления (U)Int8/16/32/128/256.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt128OrDefault('0xc0fe', CAST('0', 'UInt128'));`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt128](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 128-битное беззнаковое целое значение, если успешно, иначе возвращает значение по умолчанию, если оно передано, или `0`, если нет. [UInt128](../data-types/int-uint.md).

:::note
- Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
- Тип значения по умолчанию должен быть таким же, как и тип приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt128OrDefault('128', CAST('0', 'UInt128')),
    toUInt128OrDefault('abc', CAST('0', 'UInt128'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt128OrDefault('128', CAST('0', 'UInt128')): 128
toUInt128OrDefault('abc', CAST('0', 'UInt128')): 0
```

**См. также**

- [`toUInt128`](#touint128).
- [`toUInt128OrZero`](#touint128orzero).
- [`toUInt128OrNull`](#touint128ornull).
## toUInt256 {#touint256}

Преобразует входное значение в значение типа [`UInt256`](../data-types/int-uint.md). Вызывает исключение в случае ошибки.

**Синтаксис**

```sql
toUInt256(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt256('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt256](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 256-битное беззнаковое целое значение. [Int256](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

```sql
SELECT
    toUInt256(256),
    toUInt256(256.256),
    toUInt256('256')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt256(256):     256
toUInt256(256.256): 256
toUInt256('256'):   256
```

**См. также**

- [`toUInt256OrZero`](#touint256orzero).
- [`toUInt256OrNull`](#touint256ornull).
- [`toUInt256OrDefault`](#touint256ordefault).
## toUInt256OrZero {#touint256orzero}

Как и [`toUInt256`](#touint256), эта функция преобразует входное значение в значение типа [UInt256](../data-types/int-uint.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toUInt256OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt256OrZero('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt256](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 256-битное беззнаковое целое значение, если успешно, иначе `0`. [UInt256](../data-types/int-uint.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt256OrZero('256'),
    toUInt256OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt256OrZero('256'): 256
toUInt256OrZero('abc'): 0
```

**См. также**

- [`toUInt256`](#touint256).
- [`toUInt256OrNull`](#touint256ornull).
- [`toUInt256OrDefault`](#touint256ordefault).
## toUInt256OrNull {#touint256ornull}

Как и [`toUInt256`](#touint256), эта функция преобразует входное значение в значение типа [UInt256](../data-types/int-uint.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toUInt256OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256.

Неподдерживаемые аргументы (возвращают `\N`)
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt256OrNull('0xc0fe');`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt256](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 256-битное беззнаковое целое значение, если успешно, иначе `NULL`. [UInt256](../data-types/int-uint.md) / [NULL](../data-types/nullable.md).

:::note
Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt256OrNull('256'),
    toUInt256OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt256OrNull('256'): 256
toUInt256OrNull('abc'): ᴺᵁᴸᴸ
```

**См. также**

- [`toUInt256`](#touint256).
- [`toUInt256OrZero`](#touint256orzero).
- [`toUInt256OrDefault`](#touint256ordefault).
## toUInt256OrDefault {#touint256ordefault}

Как и [`toUInt256`](#touint256), эта функция преобразует входное значение в значение типа [UInt256](../data-types/int-uint.md), но возвращает значение по умолчанию в случае ошибки. 
Если значение `default` не передано, то возвращается `0` в случае ошибки.

**Синтаксис**

```sql
toUInt256OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательно) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `UInt256` не удался. [UInt256](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения типа Float32/64.

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления значений Float32/64, включая `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toUInt256OrDefault('0xc0fe', CAST('0', 'UInt256'));`.

:::note
Если входное значение не может быть представлено в пределах значений [UInt256](../data-types/int-uint.md), происходит переполнение или недополнение результата.
Это не считается ошибкой.
:::

**Возвращаемое значение**

- 256-битное беззнаковое целое значение, если успешно, иначе возвращает значение по умолчанию, если оно передано, или `0`, если нет. [UInt256](../data-types/int-uint.md).

:::note
- Функция использует [округление к нулю](https://en.wikipedia.org/wiki/Rounding#Rounding_towards_zero), что означает, что она обрезает дробные цифры чисел.
- Тип значения по умолчанию должен быть таким же, как и тип приведения.
:::

**Пример**

Запрос:

``` sql
SELECT
    toUInt256OrDefault('-256', CAST('0', 'UInt256')),
    toUInt256OrDefault('abc', CAST('0', 'UInt256'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toUInt256OrDefault('-256', CAST('0', 'UInt256')): 0
toUInt256OrDefault('abc', CAST('0', 'UInt256')):  0
```

**См. также**

- [`toUInt256`](#touint256).
- [`toUInt256OrZero`](#touint256orzero).
- [`toUInt256OrNull`](#touint256ornull).
## toFloat32 {#tofloat32}

Преобразует входное значение в значение типа [`Float32`](../data-types/float.md). Вызывает исключение в случае ошибки.

**Синтаксис**

```sql
toFloat32(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения типа (U)Int8/16/32/64/128/256.
- Строковые представления (U)Int8/16/32/128/256.
- Значения типа Float32/64, включая `NaN` и `Inf`.
- Строковые представления Float32/64, включая `NaN` и `Inf` (без учета регистра).

Неподдерживаемые аргументы:
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toFloat32('0xc0fe');`.

**Возвращаемое значение**

- 32-битное число с плавающей запятой. [Float32](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT
    toFloat32(42.7),
    toFloat32('42.7'),
    toFloat32('NaN')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toFloat32(42.7):   42.7
toFloat32('42.7'): 42.7
toFloat32('NaN'):  nan
```

**См. также**

- [`toFloat32OrZero`](#tofloat32orzero).
- [`toFloat32OrNull`](#tofloat32ornull).
- [`toFloat32OrDefault`](#tofloat32ordefault).
## toFloat32OrZero {#tofloat32orzero}

Как и [`toFloat32`](#tofloat32), эта функция преобразует входное значение в значение типа [Float32](../data-types/float.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toFloat32OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256, Float32/64.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toFloat32OrZero('0xc0fe');`.

**Возвращаемое значение**

- 32-битное число с плавающей запятой, если успешно, иначе `0`. [Float32](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT
    toFloat32OrZero('42.7'),
    toFloat32OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toFloat32OrZero('42.7'): 42.7
toFloat32OrZero('abc'):  0
```

**См. также**

- [`toFloat32`](#tofloat32).
- [`toFloat32OrNull`](#tofloat32ornull).
- [`toFloat32OrDefault`](#tofloat32ordefault).
## toFloat32OrNull {#tofloat32ornull}

Как и [`toFloat32`](#tofloat32), эта функция преобразует входное значение в значение типа [Float32](../data-types/float.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toFloat32OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256, Float32/64.

Неподдерживаемые аргументы (возвращают `\N`):
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toFloat32OrNull('0xc0fe');`.

**Возвращаемое значение**

- 32-битное число с плавающей запятой, если успешно, иначе `\N`. [Float32](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT
    toFloat32OrNull('42.7'),
    toFloat32OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toFloat32OrNull('42.7'): 42.7
toFloat32OrNull('abc'):  ᴺᵁᴸᴸ
```

**См. также**

- [`toFloat32`](#tofloat32).
- [`toFloat32OrZero`](#tofloat32orzero).
- [`toFloat32OrDefault`](#tofloat32ordefault).
## toFloat32OrDefault {#tofloat32ordefault}

Как и [`toFloat32`](#tofloat32), эта функция преобразует входное значение в значение типа [Float32](../data-types/float.md), но возвращает значение по умолчанию в случае ошибки. 
Если значение `default` не передано, то возвращается `0` в случае ошибки.

**Синтаксис**

```sql
toFloat32OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions) / [String](../data-types/string.md).
- `default` (необязательно) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `Float32` не удался. [Float32](../data-types/float.md).

Поддерживаемые аргументы:
- Значения типа (U)Int8/16/32/64/128/256.
- Строковые представления (U)Int8/16/32/128/256.
- Значения типа Float32/64, включая `NaN` и `Inf`.
- Строковые представления Float32/64, включая `NaN` и `Inf` (без учета регистра).

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toFloat32OrDefault('0xc0fe', CAST('0', 'Float32'));`.

**Возвращаемое значение**

- 32-битное число с плавающей запятой, если успешно, иначе возвращает значение по умолчанию, если оно передано, или `0`, если нет. [Float32](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT
    toFloat32OrDefault('8', CAST('0', 'Float32')),
    toFloat32OrDefault('abc', CAST('0', 'Float32'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toFloat32OrDefault('8', CAST('0', 'Float32')):   8
toFloat32OrDefault('abc', CAST('0', 'Float32')): 0
```

**См. также**

- [`toFloat32`](#tofloat32).
- [`toFloat32OrZero`](#tofloat32orzero).
- [`toFloat32OrNull`](#tofloat32ornull).
## toFloat64 {#tofloat64}

Преобразует входное значение в значение типа [`Float64`](../data-types/float.md). Вызывает исключение в случае ошибки.

**Синтаксис**

```sql
toFloat64(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения типа (U)Int8/16/32/64/128/256.
- Строковые представления (U)Int8/16/32/128/256.
- Значения типа Float32/64, включая `NaN` и `Inf`.
- Строковые представления типа Float32/64, включая `NaN` и `Inf` (без учета регистра).

Неподдерживаемые аргументы:
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toFloat64('0xc0fe');`.

**Возвращаемое значение**

- 64-битное число с плавающей запятой. [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT
    toFloat64(42.7),
    toFloat64('42.7'),
    toFloat64('NaN')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toFloat64(42.7):   42.7
toFloat64('42.7'): 42.7
toFloat64('NaN'):  nan
```

**См. также**

- [`toFloat64OrZero`](#tofloat64orzero).
- [`toFloat64OrNull`](#tofloat64ornull).
- [`toFloat64OrDefault`](#tofloat64ordefault).
## toFloat64OrZero {#tofloat64orzero}

Как и [`toFloat64`](#tofloat64), эта функция преобразует входное значение в значение типа [Float64](../data-types/float.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toFloat64OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256, Float32/64.

Неподдерживаемые аргументы (возвращают `0`):
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toFloat64OrZero('0xc0fe');`.

**Возвращаемое значение**

- 64-битное число с плавающей запятой, если успешно, иначе `0`. [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT
    toFloat64OrZero('42.7'),
    toFloat64OrZero('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toFloat64OrZero('42.7'): 42.7
toFloat64OrZero('abc'):  0
```

**См. также**

- [`toFloat64`](#tofloat64).
- [`toFloat64OrNull`](#tofloat64ornull).
- [`toFloat64OrDefault`](#tofloat64ordefault).
## toFloat64OrNull {#tofloat64ornull}

Как и [`toFloat64`](#tofloat64), эта функция преобразует входное значение в значение типа [Float64](../data-types/float.md), но возвращает `NULL` в случае ошибки.

**Синтаксис**

```sql
toFloat64OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [String](../data-types/string.md).

Поддерживаемые аргументы:
- Строковые представления (U)Int8/16/32/128/256, Float32/64.

Неподдерживаемые аргументы (возвращают `\N`):
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toFloat64OrNull('0xc0fe');`.

**Возвращаемое значение**

- 64-битное число с плавающей запятой, если успешно, иначе `\N`. [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT
    toFloat64OrNull('42.7'),
    toFloat64OrNull('abc')
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toFloat64OrNull('42.7'): 42.7
toFloat64OrNull('abc'):  ᴺᵁᴸᴸ
```

**См. также**

- [`toFloat64`](#tofloat64).
- [`toFloat64OrZero`](#tofloat64orzero).
- [`toFloat64OrDefault`](#tofloat64ordefault).
```

## toFloat64OrDefault {#tofloat64ordefault}

Как и [`toFloat64`](#tofloat64), эта функция преобразует входное значение в значение типа [Float64](../data-types/float.md), но возвращает значение по умолчанию в случае ошибки. Если значение `default` не указано, то в случае ошибки возвращается `0`.

**Синтаксис**

```sql
toFloat64OrDefault(expr[, default])
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Выражение](/sql-reference/syntax#expressions) / [Строка](../data-types/string.md).
- `default` (необязательный) — Значение по умолчанию, которое возвращается, если разбор в тип `Float64` не удался. [Float64](../data-types/float.md).

Поддерживаемые аргументы:
- Значения типа (U)Int8/16/32/64/128/256.
- Строковые представления (U)Int8/16/32/128/256.
- Значения типа Float32/64, включая `NaN` и `Inf`.
- Строковые представления Float32/64, включая `NaN` и `Inf` (регистронезависимо).

Аргументы, для которых возвращается значение по умолчанию:
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toFloat64OrDefault('0xc0fe', CAST('0', 'Float64'));`.

**Возвращаемое значение**

- 64-битное значение типа Float, если успешно, иначе возвращает значение по умолчанию, если оно указано, или `0`, если нет. [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT
    toFloat64OrDefault('8', CAST('0', 'Float64')),
    toFloat64OrDefault('abc', CAST('0', 'Float64'))
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
toFloat64OrDefault('8', CAST('0', 'Float64')):   8
toFloat64OrDefault('abc', CAST('0', 'Float64')): 0
```

**См. также**

- [`toFloat64`](#tofloat64).
- [`toFloat64OrZero`](#tofloat64orzero).
- [`toFloat64OrNull`](#tofloat64ornull).
## toBFloat16 {#tobfloat16}

Преобразует входное значение в значение типа [`BFloat16`](../data-types/float.md/#bfloat16). 
Вызывает исключение в случае ошибки.

**Синтаксис**

```sql
toBFloat16(expr)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Выражение](/sql-reference/syntax#expressions).

Поддерживаемые аргументы:
- Значения типа (U)Int8/16/32/64/128/256.
- Строковые представления (U)Int8/16/32/128/256.
- Значения типа Float32/64, включая `NaN` и `Inf`.
- Строковые представления Float32/64, включая `NaN` и `Inf` (регистронезависимо).

**Возвращаемое значение**

- 16-битное значение brain-float. [BFloat16](../data-types/float.md/#bfloat16).

**Пример**

```sql
SELECT toBFloat16(toFloat32(42.7))

42.5

SELECT toBFloat16(toFloat32('42.7'));

42.5

SELECT toBFloat16('42.7');

42.5
```

**См. также**

- [`toBFloat16OrZero`](#tobfloat16orzero).
- [`toBFloat16OrNull`](#tobfloat16ornull).
## toBFloat16OrZero {#tobfloat16orzero}

Преобразует строковое входное значение в значение типа [`BFloat16`](../data-types/float.md/#bfloat16).
Если строка не представляет собой число с плавающей запятой, функция возвращает ноль.

**Синтаксис**

```sql
toBFloat16OrZero(x)
```

**Аргументы**

- `x` — Строковое представление числа. [Строка](../data-types/string.md).

Поддерживаемые аргументы:

- Строковые представления числовых значений.

Неподдерживаемые аргументы (возвращают `0`):

- Строковые представления двоичных и шестнадцатеричных значений.
- Числовые значения.

**Возвращаемое значение**

- 16-битное значение brain-float, иначе `0`. [BFloat16](../data-types/float.md/#bfloat16).

:::note
Функция допускает тихую потерю точности при преобразовании из строкового представления.
:::

**Пример**

```sql
SELECT toBFloat16OrZero('0x5E'); -- неподдерживаемые аргументы

0

SELECT toBFloat16OrZero('12.3'); -- типичное использование

12.25

SELECT toBFloat16OrZero('12.3456789');

12.3125 -- тихая потеря точности
```

**См. также**

- [`toBFloat16`](#tobfloat16).
- [`toBFloat16OrNull`](#tobfloat16ornull).
## toBFloat16OrNull {#tobfloat16ornull}

Преобразует строковое входное значение в значение типа [`BFloat16`](../data-types/float.md/#bfloat16) 
но если строка не представляет собой число с плавающей запятой, функция возвращает `NULL`.

**Синтаксис**

```sql
toBFloat16OrNull(x)
```

**Аргументы**

- `x` — Строковое представление числа. [Строка](../data-types/string.md).

Поддерживаемые аргументы:

- Строковые представления числовых значений.

Неподдерживаемые аргументы (возвращают `NULL`):

- Строковые представления двоичных и шестнадцатеричных значений.
- Числовые значения.

**Возвращаемое значение**

- 16-битное значение brain-float, иначе `NULL` (`\N`). [BFloat16](../data-types/float.md/#bfloat16).

:::note
Функция допускает тихую потерю точности при преобразовании из строкового представления.
:::

**Пример**

```sql
SELECT toBFloat16OrNull('0x5E'); -- неподдерживаемые аргументы

\N

SELECT toBFloat16OrNull('12.3'); -- типичное использование

12.25

SELECT toBFloat16OrNull('12.3456789');

12.3125 -- тихая потеря точности
```

**См. также**

- [`toBFloat16`](#tobfloat16).
- [`toBFloat16OrZero`](#tobfloat16orzero).
## toDate {#todate}

Преобразует аргумент в тип данных [Дата](../data-types/date.md).

Если аргумент является [DateTime](../data-types/datetime.md) или [DateTime64](../data-types/datetime64.md), он обрезается, и остается только компонент даты:

```sql
SELECT
    now() AS x,
    toDate(x)
```

```response
┌───────────────────x─┬─toDate(now())─┐
│ 2022-12-30 13:44:17 │    2022-12-30 │
└─────────────────────┴───────────────┘
```

Если аргумент — это [Строка](../data-types/string.md), она разбирается как [Дата](../data-types/date.md) или [DateTime](../data-types/datetime.md). Если она была разобрана как [DateTime](../data-types/datetime.md), используется компонент даты:

```sql
SELECT
    toDate('2022-12-30') AS x,
    toTypeName(x)
```

```response
┌──────────x─┬─toTypeName(toDate('2022-12-30'))─┐
│ 2022-12-30 │ Date                             │
└────────────┴──────────────────────────────────┘

1 row in set. Elapsed: 0.001 sec.
```

```sql
SELECT
    toDate('2022-12-30 01:02:03') AS x,
    toTypeName(x)
```

```response
┌──────────x─┬─toTypeName(toDate('2022-12-30 01:02:03'))─┐
│ 2022-12-30 │ Date                                      │
└────────────┴───────────────────────────────────────────┘
```

Если аргумент — это число и выглядит как метка времени UNIX (больше 65535), он интерпретируется как [DateTime](../data-types/datetime.md), а затем сокращается до [Дата](../data-types/date.md) в текущем часовом поясе. Аргумент часового пояса может быть указан как второй аргумент функции. Обрезка до [Дата](../data-types/date.md) зависит от часового пояса:

```sql
SELECT
    now() AS current_time,
    toUnixTimestamp(current_time) AS ts,
    toDateTime(ts) AS time_Amsterdam,
    toDateTime(ts, 'Pacific/Apia') AS time_Samoa,
    toDate(time_Amsterdam) AS date_Amsterdam,
    toDate(time_Samoa) AS date_Samoa,
    toDate(ts) AS date_Amsterdam_2,
    toDate(ts, 'Pacific/Apia') AS date_Samoa_2
```

```response
Row 1:
──────
current_time:     2022-12-30 13:51:54
ts:               1672404714
time_Amsterdam:   2022-12-30 13:51:54
time_Samoa:       2022-12-31 01:51:54
date_Amsterdam:   2022-12-30
date_Samoa:       2022-12-31
date_Amsterdam_2: 2022-12-30
date_Samoa_2:     2022-12-31
```

Приведенный выше пример демонстрирует, как одна и та же метка времени UNIX может интерпретироваться как разные даты в разных часовых поясах.

Если аргумент — это число и меньше 65536, он интерпретируется как количество дней с 1970-01-01 (первый UNIX день) и преобразуется в [Дата](../data-types/date.md). Он соответствует внутреннему числовому представлению типа `Дата`. Пример:

```sql
SELECT toDate(12345)
```
```response
┌─toDate(12345)─┐
│    2003-10-20 │
└───────────────┘
```

Это преобразование не зависит от часовых поясов.

Если аргумент не помещается в диапазон типа Дата, это приводит к неопределенному поведению реализации, которое может насыщать максимум поддерживаемой даты или переполнять:
```sql
SELECT toDate(10000000000.)
```
```response
┌─toDate(10000000000.)─┐
│           2106-02-07 │
└──────────────────────┘
```

Функцию `toDate` также можно записать в альтернативных формах:

```sql
SELECT
    now() AS time,
    toDate(time),
    DATE(time),
    CAST(time, 'Date')
```
```response
┌────────────────time─┬─toDate(now())─┬─DATE(now())─┬─CAST(now(), 'Date')─┐
│ 2022-12-30 13:54:58 │    2022-12-30 │  2022-12-30 │          2022-12-30 │
└─────────────────────┴───────────────┴─────────────┴─────────────────────┘
```
## toDateOrZero {#todateorzero}

То же самое, что и [toDate](#todate), но возвращает нижнюю границу типа [Дата](../data-types/date.md), если получен недопустимый аргумент. Поддерживается только аргумент [Строка](../data-types/string.md).

**Пример**

Запрос:

``` sql
SELECT toDateOrZero('2022-12-30'), toDateOrZero('');
```

Результат:

```response
┌─toDateOrZero('2022-12-30')─┬─toDateOrZero('')─┐
│                 2022-12-30 │       1970-01-01 │
└────────────────────────────┴──────────────────┘
```
## toDateOrNull {#todateornull}

То же самое, что и [toDate](#todate), но возвращает `NULL`, если получен недопустимый аргумент. Поддерживается только аргумент [Строка](../data-types/string.md).

**Пример**

Запрос:

``` sql
SELECT toDateOrNull('2022-12-30'), toDateOrNull('');
```

Результат:

```response
┌─toDateOrNull('2022-12-30')─┬─toDateOrNull('')─┐
│                 2022-12-30 │             ᴺᵁᴸᴸ │
└────────────────────────────┴──────────────────┘
```
## toDateOrDefault {#todateordefault}

Как и [toDate](#todate), но если не удалось, возвращает значение по умолчанию, которое может быть либо вторым аргументом (если указано), либо иначе нижней границей типа [Дата](../data-types/date.md).

**Синтаксис**

``` sql
toDateOrDefault(expr [, default_value])
```

**Пример**

Запрос:

``` sql
SELECT toDateOrDefault('2022-12-30'), toDateOrDefault('', '2023-01-01'::Date);
```

Результат:

```response
┌─toDateOrDefault('2022-12-30')─┬─toDateOrDefault('', CAST('2023-01-01', 'Date'))─┐
│                    2022-12-30 │                                      2023-01-01 │
└───────────────────────────────┴─────────────────────────────────────────────────┘
```
## toDateTime {#todatetime}

Преобразует входное значение в [DateTime](../data-types/datetime.md).

**Синтаксис**

``` sql
toDateTime(expr[, time_zone ])
```

**Аргументы**

- `expr` — Значение. [Строка](../data-types/string.md), [Int](../data-types/int-uint.md), [Дата](../data-types/date.md) или [DateTime](../data-types/datetime.md).
- `time_zone` — Часовой пояс. [Строка](../data-types/string.md).

:::note
Если `expr` является числом, оно интерпретируется как количество секунд с начала эпохи Unix (как метка времени Unix).
Если `expr` является [Строкой](../data-types/string.md), оно может интерпретироваться как метка времени Unix или как строковое представление даты / даты с временем.
Таким образом, разбор строковых представлений коротких чисел (до 4 цифр) явно отключен из-за неоднозначности, например строка `'1999'` может быть как годом (незавершенное строковое представление Даты / DateTime), так и меткой времени unix. Более длинные числовые строки допускаются.
:::

**Возвращаемое значение**

- Дата и время. [DateTime](../data-types/datetime.md)

**Пример**

Запрос:

``` sql
SELECT toDateTime('2022-12-30 13:44:17'), toDateTime(1685457500, 'UTC');
```

Результат:

```response
┌─toDateTime('2022-12-30 13:44:17')─┬─toDateTime(1685457500, 'UTC')─┐
│               2022-12-30 13:44:17 │           2023-05-30 14:38:20 │
└───────────────────────────────────┴───────────────────────────────┘
```
## toDateTimeOrZero {#todatetimeorzero}

То же самое, что и [toDateTime](#todatetime), но возвращает нижнюю границу типа [DateTime](../data-types/datetime.md), если получен недопустимый аргумент. Поддерживается только аргумент [Строка](../data-types/string.md).

**Пример**

Запрос:

``` sql
SELECT toDateTimeOrZero('2022-12-30 13:44:17'), toDateTimeOrZero('');
```

Результат:

```response
┌─toDateTimeOrZero('2022-12-30 13:44:17')─┬─toDateTimeOrZero('')─┐
│                     2022-12-30 13:44:17 │  1970-01-01 00:00:00 │
└─────────────────────────────────────────┴──────────────────────┘
```
## toDateTimeOrNull {#todatetimeornull}

То же самое, что и [toDateTime](#todatetime), но возвращает `NULL`, если получен недопустимый аргумент. Поддерживается только аргумент [Строка](../data-types/string.md).

**Пример**

Запрос:

``` sql
SELECT toDateTimeOrNull('2022-12-30 13:44:17'), toDateTimeOrNull('');
```

Результат:

```response
┌─toDateTimeOrNull('2022-12-30 13:44:17')─┬─toDateTimeOrNull('')─┐
│                     2022-12-30 13:44:17 │                 ᴺᵁᴸᴸ │
└─────────────────────────────────────────┴──────────────────────┘
```
## toDateTimeOrDefault {#todatetimeordefault}

Как и [toDateTime](#todatetime), но если не удалось, возвращает значение по умолчанию, которое может быть либо третьим аргументом (если указано), либо иначе нижняя граница типа [DateTime](../data-types/datetime.md).

**Синтаксис**

``` sql
toDateTimeOrDefault(expr [, time_zone [, default_value]])
```

**Пример**

Запрос:

``` sql
SELECT toDateTimeOrDefault('2022-12-30 13:44:17'), toDateTimeOrDefault('', 'UTC', '2023-01-01'::DateTime('UTC'));
```

Результат:

```response
┌─toDateTimeOrDefault('2022-12-30 13:44:17')─┬─toDateTimeOrDefault('', 'UTC', CAST('2023-01-01', 'DateTime(\'UTC\')'))─┐
│                        2022-12-30 13:44:17 │                                                     2023-01-01 00:00:00 │
└────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────┘
```
## toDate32 {#todate32}

Преобразует аргумент в тип [Date32](../data-types/date32.md). Если значение находится за пределами диапазона, `toDate32` возвращает граничные значения, поддерживаемые [Date32](../data-types/date32.md). Если аргумент имеет тип [Дата](../data-types/date.md), учитываются его границы.

**Синтаксис**

``` sql
toDate32(expr)
```

**Аргументы**

- `expr` — Значение. [Строка](../data-types/string.md), [UInt32](../data-types/int-uint.md) или [Дата](../data-types/date.md).

**Возвращаемое значение**

- Календарная дата. Тип [Date32](../data-types/date32.md).

**Пример**

1. Значение находится в диапазоне:

``` sql
SELECT toDate32('1955-01-01') AS value, toTypeName(value);
```

```response
┌──────value─┬─toTypeName(toDate32('1925-01-01'))─┐
│ 1955-01-01 │ Date32                             │
└────────────┴────────────────────────────────────┘
```

2. Значение находится за пределами диапазона:

``` sql
SELECT toDate32('1899-01-01') AS value, toTypeName(value);
```

```response
┌──────value─┬─toTypeName(toDate32('1899-01-01'))─┐
│ 1900-01-01 │ Date32                             │
└────────────┴────────────────────────────────────┘
```

3. С аргументом [Дата](../data-types/date.md):

``` sql
SELECT toDate32(toDate('1899-01-01')) AS value, toTypeName(value);
```

```response
┌──────value─┬─toTypeName(toDate32(toDate('1899-01-01')))─┐
│ 1970-01-01 │ Date32                                     │
└────────────┴────────────────────────────────────────────┘
```
## toDate32OrZero {#todate32orzero}

То же самое, что и [toDate32](#todate32), но возвращает минимальное значение типа [Date32](../data-types/date32.md), если получен недопустимый аргумент.

**Пример**

Запрос:

``` sql
SELECT toDate32OrZero('1899-01-01'), toDate32OrZero('');
```

Результат:

```response
┌─toDate32OrZero('1899-01-01')─┬─toDate32OrZero('')─┐
│                   1900-01-01 │         1900-01-01 │
└──────────────────────────────┴────────────────────┘
```
## toDate32OrNull {#todate32ornull}

То же самое, что и [toDate32](#todate32), но возвращает `NULL`, если получен недопустимый аргумент.

**Пример**

Запрос:

``` sql
SELECT toDate32OrNull('1955-01-01'), toDate32OrNull('');
```

Результат:

```response
┌─toDate32OrNull('1955-01-01')─┬─toDate32OrNull('')─┐
│                   1955-01-01 │               ᴺᵁᴸᴸ │
└──────────────────────────────┴────────────────────┘
```
## toDate32OrDefault {#todate32ordefault}

Преобразует аргумент в тип [Date32](../data-types/date32.md). Если значение находится за пределами диапазона, `toDate32OrDefault` возвращает нижнюю границу, поддерживаемую типом [Date32](../data-types/date32.md). Если аргумент имеет тип [Дата](../data-types/date.md), учитываются его границы. Возвращает значение по умолчанию, если получен недопустимый аргумент.

**Пример**

Запрос:

``` sql
SELECT
    toDate32OrDefault('1930-01-01', toDate32('2020-01-01')),
    toDate32OrDefault('xx1930-01-01', toDate32('2020-01-01'));
```

Результат:

```response
┌─toDate32OrDefault('1930-01-01', toDate32('2020-01-01'))─┬─toDate32OrDefault('xx1930-01-01', toDate32('2020-01-01'))─┐
│                                              1930-01-01 │                                                2020-01-01 │
└─────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────┘
```
## toDateTime64 {#todatetime64}

Преобразует входное значение в значение типа [DateTime64](../data-types/datetime64.md).

**Синтаксис**

``` sql
toDateTime64(expr, scale, [timezone])
```

**Аргументы**

- `expr` — Значение. [Строка](../data-types/string.md), [UInt32](../data-types/int-uint.md), [Float](../data-types/float.md) или [DateTime](../data-types/datetime.md).
- `scale` - Размер тика (точность): 10<sup>-precision</sup> секунд. Допустимый диапазон: [ 0 : 9 ].
- `timezone` (необязательно) - Часовой пояс указанного объекта datetime64.

**Возвращаемое значение**

- Календарная дата и время суток с подсекундной точностью. [DateTime64](../data-types/datetime64.md).

**Пример**

1. Значение находится в диапазоне:

``` sql
SELECT toDateTime64('1955-01-01 00:00:00.000', 3) AS value, toTypeName(value);
```

```response
┌───────────────────value─┬─toTypeName(toDateTime64('1955-01-01 00:00:00.000', 3))─┐
│ 1955-01-01 00:00:00.000 │ DateTime64(3)                                          │
└─────────────────────────┴────────────────────────────────────────────────────────┘
```

2. Как десятичное число с точностью:

``` sql
SELECT toDateTime64(1546300800.000, 3) AS value, toTypeName(value);
```

```response
┌───────────────────value─┬─toTypeName(toDateTime64(1546300800., 3))─┐
│ 2019-01-01 00:00:00.000 │ DateTime64(3)                            │
└─────────────────────────┴──────────────────────────────────────────┘
```

Без десятичной точки значение также рассматривается как метка времени Unix в секундах:

``` sql
SELECT toDateTime64(1546300800000, 3) AS value, toTypeName(value);
```

```response
┌───────────────────value─┬─toTypeName(toDateTime64(1546300800000, 3))─┐
│ 2282-12-31 00:00:00.000 │ DateTime64(3)                              │
└─────────────────────────┴────────────────────────────────────────────┘
```


3. С `timezone`:

``` sql
SELECT toDateTime64('2019-01-01 00:00:00', 3, 'Asia/Istanbul') AS value, toTypeName(value);
```

```response
┌───────────────────value─┬─toTypeName(toDateTime64('2019-01-01 00:00:00', 3, 'Asia/Istanbul'))─┐
│ 2019-01-01 00:00:00.000 │ DateTime64(3, 'Asia/Istanbul')                                      │
└─────────────────────────┴─────────────────────────────────────────────────────────────────────┘
```
## toDateTime64OrZero {#todatetime64orzero}

Как и [toDateTime64](#todatetime64), эта функция преобразует входное значение в значение типа [DateTime64](../data-types/datetime64.md), но возвращает минимальное значение типа [DateTime64](../data-types/datetime64.md), если получен недопустимый аргумент.

**Синтаксис**

``` sql
toDateTime64OrZero(expr, scale, [timezone])
```

**Аргументы**

- `expr` — Значение. [Строка](../data-types/string.md), [UInt32](../data-types/int-uint.md), [Float](../data-types/float.md) или [DateTime](../data-types/datetime.md).
- `scale` - Размер тика (точность): 10<sup>-precision</sup> секунд. Допустимый диапазон: [ 0 : 9 ].
- `timezone` (необязательно) - Часовой пояс указанного объекта DateTime64.

**Возвращаемое значение**

- Дата и время суток с подсекундной точностью, иначе минимальное значение `DateTime64`: `1970-01-01 01:00:00.000`. [DateTime64](../data-types/datetime64.md).

**Пример**

Запрос:

```sql
SELECT toDateTime64OrZero('2008-10-12 00:00:00 00:30:30', 3) AS invalid_arg
```

Результат:

```response
┌─────────────invalid_arg─┐
│ 1970-01-01 01:00:00.000 │
└─────────────────────────┘
```

**См. также**

- [toDateTime64](#todatetime64).
- [toDateTime64OrNull](#todatetime64ornull).
- [toDateTime64OrDefault](#todatetime64ordefault).
## toDateTime64OrNull {#todatetime64ornull}

Как и [toDateTime64](#todatetime64), эта функция преобразует входное значение в значение типа [DateTime64](../data-types/datetime64.md), но возвращает `NULL`, если получен недопустимый аргумент.

**Синтаксис**

``` sql
toDateTime64OrNull(expr, scale, [timezone])
```

**Аргументы**

- `expr` — Значение. [Строка](../data-types/string.md), [UInt32](../data-types/int-uint.md), [Float](../data-types/float.md) или [DateTime](../data-types/datetime.md).
- `scale` - Размер тика (точность): 10<sup>-precision</sup> секунд. Допустимый диапазон: [ 0 : 9 ].
- `timezone` (необязательно) - Часовой пояс указанного объекта DateTime64.

**Возвращаемое значение**

- Дата и время суток с подсекундной точностью, иначе `NULL`. [DateTime64](../data-types/datetime64.md)/[NULL](../data-types/nullable.md).

**Пример**

Запрос:

```sql
SELECT
    toDateTime64OrNull('1976-10-18 00:00:00.30', 3) AS valid_arg,
    toDateTime64OrNull('1976-10-18 00:00:00 30', 3) AS invalid_arg
```

Результат:

```response
┌───────────────valid_arg─┬─invalid_arg─┐
│ 1976-10-18 00:00:00.300 │        ᴺᵁᴸᴸ │
└─────────────────────────┴─────────────┘
```

**См. также**

- [toDateTime64](#todatetime64).
- [toDateTime64OrZero](#todatetime64orzero).
- [toDateTime64OrDefault](#todatetime64ordefault).
## toDateTime64OrDefault {#todatetime64ordefault}

Как и [toDateTime64](#todatetime64), эта функция преобразует входное значение в значение типа [DateTime64](../data-types/datetime64.md),
но возвращает либо значение по умолчанию типа [DateTime64](../data-types/datetime64.md)
либо указанные значения по умолчанию, если получен недопустимый аргумент.

**Синтаксис**

``` sql
toDateTime64OrNull(expr, scale, [timezone, default])
```

**Аргументы**

- `expr` — Значение. [Строка](../data-types/string.md), [UInt32](../data-types/int-uint.md), [Float](../data-types/float.md) или [DateTime](../data-types/datetime.md).
- `scale` - Размер тика (точность): 10<sup>-precision</sup> секунд. Допустимый диапазон: [ 0 : 9 ].
- `timezone` (необязательно) - Часовой пояс указанного объекта DateTime64.
- `default` (необязательно) - Значение по умолчанию, которое возвращается, если получен недопустимый аргумент. [DateTime64](../data-types/datetime64.md).

**Возвращаемое значение**

- Дата и время суток с подсекундной точностью, иначе минимальное значение `DateTime64` или значения `default`, если указано. [DateTime64](../data-types/datetime64.md).

**Пример**

Запрос:

```sql
SELECT
    toDateTime64OrDefault('1976-10-18 00:00:00 30', 3) AS invalid_arg,
    toDateTime64OrDefault('1976-10-18 00:00:00 30', 3, 'UTC', toDateTime64('2001-01-01 00:00:00.00',3)) AS invalid_arg_with_default
```

Результат:

```response
┌─────────────invalid_arg─┬─invalid_arg_with_default─┐
│ 1970-01-01 01:00:00.000 │  2000-12-31 23:00:00.000 │
└─────────────────────────┴──────────────────────────┘
```

**См. также**

- [toDateTime64](#todatetime64).
- [toDateTime64OrZero](#todatetime64orzero).
- [toDateTime64OrNull](#todatetime64ornull).
## toDecimal32 {#todecimal32}

Преобразует входное значение в значение типа [`Decimal(9, S)`](../data-types/decimal.md) с масштабом `S`. Вызывает исключение в случае ошибки.

**Синтаксис**

```sql
toDecimal32(expr, S)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Выражение](/sql-reference/syntax#expressions).
- `S` — Параметр масштаба от 0 до 9, указывающий, сколько цифр может содержать дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типа (U)Int8/16/32/64/128/256.
- Значения или строковые представления типа Float32/64.

Неподдерживаемые аргументы:
- Значения или строковые представления значений Float32/64 `NaN` и `Inf` (регистронезависимо).
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toDecimal32('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превышает границы `Decimal32`: `( -1 * 10^(9 - S), 1 * 10^(9 - S) )`.
Избыточные цифры в дроби отбрасываются (не округляются).
Избыточные цифры в целой части приведут к исключению.
:::

:::warning
Преобразования отбрасывают лишние цифры и могут работать неожиданным образом при работе с входными данными Float32/Float64, так как операции выполняются с использованием плавающих точек.
Например: `toDecimal32(1.15, 2)` равно `1.14` потому что 1.15 * 100 в формате плавающей точки — это 114.99.
Вы можете использовать входные данные в формате строки, чтобы операции использовали внутренний целочисленный тип: `toDecimal32('1.15', 2) = 1.15`
:::

**Возвращаемое значение**

- Значение типа `Decimal(9, S)`. [Decimal32(S)](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT
    toDecimal32(2, 1) AS a, toTypeName(a) AS type_a,
    toDecimal32(4.2, 2) AS b, toTypeName(b) AS type_b,
    toDecimal32('4.2', 3) AS c, toTypeName(c) AS type_c
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:      2
type_a: Decimal(9, 1)
b:      4.2
type_b: Decimal(9, 2)
c:      4.2
type_c: Decimal(9, 3)
```

**См. также**

- [`toDecimal32OrZero`](#todecimal32orzero).
- [`toDecimal32OrNull`](#todecimal32ornull).
- [`toDecimal32OrDefault`](#todecimal32ordefault).
## toDecimal32OrZero {#todecimal32orzero}

Как [`toDecimal32`](#todecimal32), эта функция преобразует входное значение в значение типа [Decimal(9, S)](../data-types/decimal.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toDecimal32OrZero(expr, S)
```

**Аргументы**

- `expr` — Строковое представление числа. [Строка](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 9, указывающий, сколько цифр может содержать дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Строковые представления типа (U)Int8/16/32/64/128/256.
- Строковые представления типа Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toDecimal32OrZero('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превышает границы `Decimal32`: `( -1 * 10^(9 - S), 1 * 10^(9 - S) )`.
Избыточные цифры в дроби отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

**Возвращаемое значение**

- Значение типа `Decimal(9, S)` если успешно, иначе `0` с `S` десятичными знаками. [Decimal32(S)](../data-types/decimal.md).

**Пример**

Запрос:

``` sql
SELECT
    toDecimal32OrZero(toString(-1.111), 5) AS a,
    toTypeName(a),
    toDecimal32OrZero(toString('Inf'), 5) as b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             -1.111
toTypeName(a): Decimal(9, 5)
b:             0
toTypeName(b): Decimal(9, 5)
```

**См. также**

- [`toDecimal32`](#todecimal32).
- [`toDecimal32OrNull`](#todecimal32ornull).
- [`toDecimal32OrDefault`](#todecimal32ordefault).
## toDecimal32OrNull {#todecimal32ornull}

Как [`toDecimal32`](#todecimal32), эта функция преобразует входное значение в значение типа [Nullable(Decimal(9, S))](../data-types/decimal.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toDecimal32OrNull(expr, S)
```

**Аргументы**

- `expr` — Строковое представление числа. [Строка](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 9, указывающий, сколько цифр может содержать дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Строковые представления типа (U)Int8/16/32/64/128/256.
- Строковые представления типа Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/Float64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например `SELECT toDecimal32OrNull('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превышает границы `Decimal32`: `( -1 * 10^(9 - S), 1 * 10^(9 - S) )`.
Избыточные цифры в дроби отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

**Возвращаемое значение**

- Значение типа `Nullable(Decimal(9, S))` если успешно, иначе значение `NULL` того же типа. [Decimal32(S)](../data-types/decimal.md).

**Примеры**

Запрос:

``` sql
SELECT
    toDecimal32OrNull(toString(-1.111), 5) AS a,
    toTypeName(a),
    toDecimal32OrNull(toString('Inf'), 5) as b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             -1.111
toTypeName(a): Nullable(Decimal(9, 5))
b:             ᴺᵁᴸᴸ
toTypeName(b): Nullable(Decimal(9, 5))
```

**См. также**

- [`toDecimal32`](#todecimal32).
- [`toDecimal32OrZero`](#todecimal32orzero).
- [`toDecimal32OrDefault`](#todecimal32ordefault).
```

## toDecimal32OrDefault {#todecimal32ordefault}

Как и [`toDecimal32`](#todecimal32), эта функция преобразует входное значение в значение типа [Decimal(9, S)](../data-types/decimal.md), но возвращает значение по умолчанию в случае ошибки.

**Синтаксис**

```sql
toDecimal32OrDefault(expr, S[, default])
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 9, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).
- `default` (необязательный) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `Decimal32(S)` завершится неуспешно. [Decimal32(S)](../data-types/decimal.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal32OrDefault('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal32`: `( -1 * 10^(9 - S), 1 * 10^(9 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

:::warning
Конверсии отбрасывают лишние цифры и могут работать неожиданным образом при работе с входными данными Float32/Float64, так как операции выполняются с использованием инструкций с плавающей запятой.
Например: `toDecimal32OrDefault(1.15, 2)` равно `1.14`, потому что 1.15 * 100 в формате с плавающей запятой равно 114.99.
Вы можете использовать входную строку, чтобы операции использовали основной целочисленный тип: `toDecimal32OrDefault('1.15', 2) = 1.15`
:::

**Возвращаемое значение**

- Значение типа `Decimal(9, S)`, если успешно, в противном случае возвращает значение по умолчанию, если оно было передано, или `0`, если нет. [Decimal32(S)](../data-types/decimal.md).

**Примеры**

Запрос:

```sql
SELECT
    toDecimal32OrDefault(toString(0.0001), 5) AS a,
    toTypeName(a),
    toDecimal32OrDefault('Inf', 0, CAST('-1', 'Decimal32(0)')) AS b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.0001
toTypeName(a): Decimal(9, 5)
b:             -1
toTypeName(b): Decimal(9, 0)
```

**Смотрите также**

- [`toDecimal32`](#todecimal32).
- [`toDecimal32OrZero`](#todecimal32orzero).
- [`toDecimal32OrNull`](#todecimal32ornull).
## toDecimal64 {#todecimal64}

Преобразует входное значение в значение типа [`Decimal(18, S)`](../data-types/decimal.md) с масштабом `S`. Бросает исключение в случае ошибки.

**Синтаксис**

```sql
toDecimal64(expr, S)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).
- `S` — Параметр масштаба от 0 до 18, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типов (U)Int8/16/32/64/128/256.
- Значения или строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Значения или строковые представления значений Float32/64 `NaN` и `Inf` (без учета регистра).
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal64('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal64`: `( -1 * 10^(18 - S), 1 * 10^(18 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к исключению.
:::

:::warning
Конверсии отбрасывают лишние цифры и могут работать неожиданным образом при работе с входными данными Float32/Float64, так как операции выполняются с использованием инструкций с плавающей запятой.
Например: `toDecimal64(1.15, 2)` равно `1.14`, потому что 1.15 * 100 в формате с плавающей запятой равно 114.99.
Вы можете использовать входную строку, чтобы операции использовали основной целочисленный тип: `toDecimal64('1.15', 2) = 1.15`
:::

**Возвращаемое значение**

- Значение типа `Decimal(18, S)`. [Decimal64(S)](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT
    toDecimal64(2, 1) AS a, toTypeName(a) AS type_a,
    toDecimal64(4.2, 2) AS b, toTypeName(b) AS type_b,
    toDecimal64('4.2', 3) AS c, toTypeName(c) AS type_c
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:      2
type_a: Decimal(18, 1)
b:      4.2
type_b: Decimal(18, 2)
c:      4.2
type_c: Decimal(18, 3)
```

**Смотрите также**

- [`toDecimal64OrZero`](#todecimal64orzero).
- [`toDecimal64OrNull`](#todecimal64ornull).
- [`toDecimal64OrDefault`](#todecimal64ordefault).
## toDecimal64OrZero {#todecimal64orzero}

Как и [`toDecimal64`](#todecimal64), эта функция преобразует входное значение в значение типа [Decimal(18, S)](../data-types/decimal.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toDecimal64OrZero(expr, S)
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 18, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal64OrZero('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal64`: `( -1 * 10^(18 - S), 1 * 10^(18 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

**Возвращаемое значение**

- Значение типа `Decimal(18, S)`, если успешно, в противном случае `0` с `S` десятичными знаками. [Decimal64(S)](../data-types/decimal.md).

**Пример**

Запрос:

```sql
SELECT
    toDecimal64OrZero(toString(0.0001), 18) AS a,
    toTypeName(a),
    toDecimal64OrZero(toString('Inf'), 18) as b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.0001
toTypeName(a): Decimal(18, 18)
b:             0
toTypeName(b): Decimal(18, 18)
```

**Смотрите также**

- [`toDecimal64`](#todecimal64).
- [`toDecimal64OrNull`](#todecimal64ornull).
- [`toDecimal64OrDefault`](#todecimal64ordefault).
## toDecimal64OrNull {#todecimal64ornull}

Как и [`toDecimal64`](#todecimal64), эта функция преобразует входное значение в значение типа [Nullable(Decimal(18, S))](../data-types/decimal.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toDecimal64OrNull(expr, S)
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 18, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal64OrNull('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal64`: `( -1 * 10^(18 - S), 1 * 10^(18 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

**Возвращаемое значение**

- Значение типа `Nullable(Decimal(18, S))`, если успешно, в противном случае значение `NULL` того же типа. [Decimal64(S)](../data-types/decimal.md).

**Примеры**

Запрос:

```sql
SELECT
    toDecimal64OrNull(toString(0.0001), 18) AS a,
    toTypeName(a),
    toDecimal64OrNull(toString('Inf'), 18) as b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.0001
toTypeName(a): Nullable(Decimal(18, 18))
b:             ᴺᵁᴸᴸ
toTypeName(b): Nullable(Decimal(18, 18))
```

**Смотрите также**

- [`toDecimal64`](#todecimal64).
- [`toDecimal64OrZero`](#todecimal64orzero).
- [`toDecimal64OrDefault`](#todecimal64ordefault).
## toDecimal64OrDefault {#todecimal64ordefault}

Как и [`toDecimal64`](#todecimal64), эта функция преобразует входное значение в значение типа [Decimal(18, S)](../data-types/decimal.md), но возвращает значение по умолчанию в случае ошибки.

**Синтаксис**

```sql
toDecimal64OrDefault(expr, S[, default])
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 18, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).
- `default` (необязательный) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `Decimal64(S)` завершится неуспешно. [Decimal64(S)](../data-types/decimal.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal64OrDefault('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal64`: `( -1 * 10^(18 - S), 1 * 10^(18 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

:::warning
Конверсии отбрасывают лишние цифры и могут работать неожиданным образом при работе с Float32/Float64, так как операции выполняются с использованием инструкций с плавающей запятой.
Например: `toDecimal64OrDefault(1.15, 2)` равно `1.14`, потому что 1.15 * 100 в формате с плавающей запятой равно 114.99.
Вы можете использовать входную строку, чтобы операции использовали основной целочисленный тип: `toDecimal64OrDefault('1.15', 2) = 1.15`
:::

**Возвращаемое значение**

- Значение типа `Decimal(18, S)`, если успешно, в противном случае возвращает значение по умолчанию, если оно было передано, или `0`, если нет. [Decimal64(S)](../data-types/decimal.md).

**Примеры**

Запрос:

```sql
SELECT
    toDecimal64OrDefault(toString(0.0001), 18) AS a,
    toTypeName(a),
    toDecimal64OrDefault('Inf', 0, CAST('-1', 'Decimal64(0)')) AS b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.0001
toTypeName(a): Decimal(18, 18)
b:             -1
toTypeName(b): Decimal(18, 0)
```

**Смотрите также**

- [`toDecimal64`](#todecimal64).
- [`toDecimal64OrZero`](#todecimal64orzero).
- [`toDecimal64OrNull`](#todecimal64ornull).
## toDecimal128 {#todecimal128}

Преобразует входное значение в значение типа [`Decimal(38, S)`](../data-types/decimal.md) с масштабом `S`. Бросает исключение в случае ошибки.

**Синтаксис**

```sql
toDecimal128(expr, S)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).
- `S` — Параметр масштаба от 0 до 38, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типов (U)Int8/16/32/64/128/256.
- Значения или строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Значения или строковые представления значений Float32/64 `NaN` и `Inf` (без учета регистра).
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal128('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal128`: `( -1 * 10^(38 - S), 1 * 10^(38 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к исключению.
:::

:::warning
Конверсии отбрасывают лишние цифры и могут работать неожиданным образом при работе с Float32/Float64, так как операции выполняются с использованием инструкций с плавающей запятой.
Например: `toDecimal128(1.15, 2)` равно `1.14`, потому что 1.15 * 100 в формате с плавающей запятой равно 114.99.
Вы можете использовать входную строку, чтобы операции использовали основной целочисленный тип: `toDecimal128('1.15', 2) = 1.15`
:::

**Возвращаемое значение**

- Значение типа `Decimal(38, S)`. [Decimal128(S)](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT
    toDecimal128(99, 1) AS a, toTypeName(a) AS type_a,
    toDecimal128(99.67, 2) AS b, toTypeName(b) AS type_b,
    toDecimal128('99.67', 3) AS c, toTypeName(c) AS type_c
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:      99
type_a: Decimal(38, 1)
b:      99.67
type_b: Decimal(38, 2)
c:      99.67
type_c: Decimal(38, 3)
```

**Смотрите также**

- [`toDecimal128OrZero`](#todecimal128orzero).
- [`toDecimal128OrNull`](#todecimal128ornull).
- [`toDecimal128OrDefault`](#todecimal128ordefault).
## toDecimal128OrZero {#todecimal128orzero}

Как и [`toDecimal128`](#todecimal128), эта функция преобразует входное значение в значение типа [Decimal(38, S)](../data-types/decimal.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toDecimal128OrZero(expr, S)
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 38, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal128OrZero('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal128`: `( -1 * 10^(38 - S), 1 * 10^(38 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

**Возвращаемое значение**

- Значение типа `Decimal(38, S)`, если успешно, в противном случае `0` с `S` десятичными знаками. [Decimal128(S)](../data-types/decimal.md).

**Пример**

Запрос:

```sql
SELECT
    toDecimal128OrZero(toString(0.0001), 38) AS a,
    toTypeName(a),
    toDecimal128OrZero(toString('Inf'), 38) as b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.0001
toTypeName(a): Decimal(38, 38)
b:             0
toTypeName(b): Decimal(38, 38)
```

**Смотрите также**

- [`toDecimal128`](#todecimal128).
- [`toDecimal128OrNull`](#todecimal128ornull).
- [`toDecimal128OrDefault`](#todecimal128ordefault).
## toDecimal128OrNull {#todecimal128ornull}

Как и [`toDecimal128`](#todecimal128), эта функция преобразует входное значение в значение типа [Nullable(Decimal(38, S))](../data-types/decimal.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toDecimal128OrNull(expr, S)
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 38, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal128OrNull('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal128`: `( -1 * 10^(38 - S), 1 * 10^(38 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

**Возвращаемое значение**

- Значение типа `Nullable(Decimal(38, S))`, если успешно, в противном случае значение `NULL` того же типа. [Decimal128(S)](../data-types/decimal.md).

**Примеры**

Запрос:

```sql
SELECT
    toDecimal128OrNull(toString(1/42), 38) AS a,
    toTypeName(a),
    toDecimal128OrNull(toString('Inf'), 38) as b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.023809523809523808
toTypeName(a): Nullable(Decimal(38, 38))
b:             ᴺᵁᴸᴸ
toTypeName(b): Nullable(Decimal(38, 38))
```

**Смотрите также**

- [`toDecimal128`](#todecimal128).
- [`toDecimal128OrZero`](#todecimal128orzero).
- [`toDecimal128OrDefault`](#todecimal128ordefault).
## toDecimal128OrDefault {#todecimal128ordefault}

Как и [`toDecimal128`](#todecimal128), эта функция преобразует входное значение в значение типа [Decimal(38, S)](../data-types/decimal.md), но возвращает значение по умолчанию в случае ошибки.

**Синтаксис**

```sql
toDecimal128OrDefault(expr, S[, default])
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 38, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).
- `default` (необязательный) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `Decimal128(S)` завершится неуспешно. [Decimal128(S)](../data-types/decimal.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal128OrDefault('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal128`: `( -1 * 10^(38 - S), 1 * 10^(38 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

:::warning
Конверсии отбрасывают лишние цифры и могут работать неожиданным образом при работе с Float32/Float64, так как операции выполняются с использованием инструкций с плавающей запятой.
Например: `toDecimal128OrDefault(1.15, 2)` равно `1.14`, потому что 1.15 * 100 в формате с плавающей запятой равно 114.99.
Вы можете использовать входную строку, чтобы операции использовали основной целочисленный тип: `toDecimal128OrDefault('1.15', 2) = 1.15`
:::

**Возвращаемое значение**

- Значение типа `Decimal(38, S)`, если успешно, в противном случае возвращает значение по умолчанию, если оно было передано, или `0`, если нет. [Decimal128(S)](../data-types/decimal.md).

**Примеры**

Запрос:

```sql
SELECT
    toDecimal128OrDefault(toString(1/42), 18) AS a,
    toTypeName(a),
    toDecimal128OrDefault('Inf', 0, CAST('-1', 'Decimal128(0)')) AS b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.023809523809523808
toTypeName(a): Decimal(38, 18)
b:             -1
toTypeName(b): Decimal(38, 0)
```

**Смотрите также**

- [`toDecimal128`](#todecimal128).
- [`toDecimal128OrZero`](#todecimal128orzero).
- [`toDecimal128OrNull`](#todecimal128ornull).
## toDecimal256 {#todecimal256}

Преобразует входное значение в значение типа [`Decimal(76, S)`](../data-types/decimal.md) с масштабом `S`. Бросает исключение в случае ошибки.

**Синтаксис**

```sql
toDecimal256(expr, S)
```

**Аргументы**

- `expr` — Выражение, возвращающее число или строковое представление числа. [Expression](/sql-reference/syntax#expressions).
- `S` — Параметр масштаба от 0 до 76, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Значения или строковые представления типов (U)Int8/16/32/64/128/256.
- Значения или строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Значения или строковые представления значений Float32/64 `NaN` и `Inf` (без учета регистра).
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal256('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal256`: `( -1 * 10^(76 - S), 1 * 10^(76 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к исключению.
:::

:::warning
Конверсии отбрасывают лишние цифры и могут работать неожиданным образом при работе с Float32/Float64, так как операции выполняются с использованием инструкций с плавающей запятой.
Например: `toDecimal256(1.15, 2)` равно `1.14`, потому что 1.15 * 100 в формате с плавающей запятой равно 114.99.
Вы можете использовать входную строку, чтобы операции использовали основной целочисленный тип: `toDecimal256('1.15', 2) = 1.15`
:::

**Возвращаемое значение**

- Значение типа `Decimal(76, S)`. [Decimal256(S)](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT
    toDecimal256(99, 1) AS a, toTypeName(a) AS type_a,
    toDecimal256(99.67, 2) AS b, toTypeName(b) AS type_b,
    toDecimal256('99.67', 3) AS c, toTypeName(c) AS type_c
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:      99
type_a: Decimal(76, 1)
b:      99.67
type_b: Decimal(76, 2)
c:      99.67
type_c: Decimal(76, 3)
```

**Смотрите также**

- [`toDecimal256OrZero`](#todecimal256orzero).
- [`toDecimal256OrNull`](#todecimal256ornull).
- [`toDecimal256OrDefault`](#todecimal256ordefault).
## toDecimal256OrZero {#todecimal256orzero}

Как и [`toDecimal256`](#todecimal256), эта функция преобразует входное значение в значение типа [Decimal(76, S)](../data-types/decimal.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toDecimal256OrZero(expr, S)
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 76, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal256OrZero('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal256`: `( -1 * 10^(76 - S), 1 * 10^(76 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

**Возвращаемое значение**

- Значение типа `Decimal(76, S)`, если успешно, в противном случае `0` с `S` десятичными знаками. [Decimal256(S)](../data-types/decimal.md).

**Пример**

Запрос:

```sql
SELECT
    toDecimal256OrZero(toString(0.0001), 76) AS a,
    toTypeName(a),
    toDecimal256OrZero(toString('Inf'), 76) as b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.0001
toTypeName(a): Decimal(76, 76)
b:             0
toTypeName(b): Decimal(76, 76)
```

**Смотрите также**

- [`toDecimal256`](#todecimal256).
- [`toDecimal256OrNull`](#todecimal256ornull).
- [`toDecimal256OrDefault`](#todecimal256ordefault).
## toDecimal256OrNull {#todecimal256ornull}

Как и [`toDecimal256`](#todecimal256), эта функция преобразует входное значение в значение типа [Nullable(Decimal(76, S))](../data-types/decimal.md), но возвращает `0` в случае ошибки.

**Синтаксис**

```sql
toDecimal256OrNull(expr, S)
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 76, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal256OrNull('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal256`: `( -1 * 10^(76 - S), 1 * 10^(76 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

**Возвращаемое значение**

- Значение типа `Nullable(Decimal(76, S))`, если успешно, в противном случае значение `NULL` того же типа. [Decimal256(S)](../data-types/decimal.md).

**Примеры**

Запрос:

```sql
SELECT
    toDecimal256OrNull(toString(1/42), 76) AS a,
    toTypeName(a),
    toDecimal256OrNull(toString('Inf'), 76) as b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.023809523809523808
toTypeName(a): Nullable(Decimal(76, 76))
b:             ᴺᵁᴸᴸ
toTypeName(b): Nullable(Decimal(76, 76))
```

**Смотрите также**

- [`toDecimal256`](#todecimal256).
- [`toDecimal256OrZero`](#todecimal256orzero).
- [`toDecimal256OrDefault`](#todecimal256ordefault).
## toDecimal256OrDefault {#todecimal256ordefault}

Как и [`toDecimal256`](#todecimal256), эта функция преобразует входное значение в значение типа [Decimal(76, S)](../data-types/decimal.md), но возвращает значение по умолчанию в случае ошибки.

**Синтаксис**

```sql
toDecimal256OrDefault(expr, S[, default])
```

**Аргументы**

- `expr` — Строковое представление числа. [String](../data-types/string.md).
- `S` — Параметр масштаба от 0 до 76, указывающий, сколько цифр может иметь дробная часть числа. [UInt8](../data-types/int-uint.md).
- `default` (необязательный) — Значение по умолчанию, которое будет возвращено, если парсинг в тип `Decimal256(S)` завершится неуспешно. [Decimal256(S)](../data-types/decimal.md).

Поддерживаемые аргументы:
- Строковые представления типов (U)Int8/16/32/64/128/256.
- Строковые представления типов Float32/64.

Неподдерживаемые аргументы:
- Строковые представления значений Float32/64 `NaN` и `Inf`.
- Строковые представления двоичных и шестнадцатеричных значений, например, `SELECT toDecimal256OrDefault('0xc0fe', 1);`.

:::note
Переполнение может произойти, если значение `expr` превысит границы `Decimal256`: `( -1 * 10^(76 - S), 1 * 10^(76 - S) )`.
Избыточные цифры в дробной части отбрасываются (не округляются).
Избыточные цифры в целой части приведут к ошибке.
:::

:::warning
Конверсии отбрасывают лишние цифры и могут работать неожиданным образом при работе с Float32/Float64, так как операции выполняются с использованием инструкций с плавающей запятой.
Например: `toDecimal256OrDefault(1.15, 2)` равно `1.14`, потому что 1.15 * 100 в формате с плавающей запятой равно 114.99.
Вы можете использовать входную строку, чтобы операции использовали основной целочисленный тип: `toDecimal256OrDefault('1.15', 2) = 1.15`
:::

**Возвращаемое значение**

- Значение типа `Decimal(76, S)`, если успешно, в противном случае возвращает значение по умолчанию, если оно было передано, или `0`, если нет. [Decimal256(S)](../data-types/decimal.md).

**Примеры**

Запрос:

```sql
SELECT
    toDecimal256OrDefault(toString(1/42), 76) AS a,
    toTypeName(a),
    toDecimal256OrDefault('Inf', 0, CAST('-1', 'Decimal256(0)')) AS b,
    toTypeName(b)
FORMAT Vertical;
```

Результат:

```response
Row 1:
──────
a:             0.023809523809523808
toTypeName(a): Decimal(76, 76)
b:             -1
toTypeName(b): Decimal(76, 0)
```

**Смотрите также**

- [`toDecimal256`](#todecimal256).
- [`toDecimal256OrZero`](#todecimal256orzero).
- [`toDecimal256OrNull`](#todecimal256ornull).
## toString {#tostring}

Функции для преобразования между числами, строками (но не фиксированными строками), датами и датами с временем.
Все эти функции принимают один аргумент.

При преобразовании в строку или из нее значение форматируется или разбирается с использованием тех же правил, что и для формата TabSeparated (и почти всех других текстовых форматов). Если строку невозможно разобрать, выбрасывается исключение, и запрос отменяется.

При преобразовании дат в числа или наоборот, дата соответствует количеству дней с начала Unix эпохи.
При преобразовании дат с временем в числа или наоборот, дата с временем соответствует количеству секунд с начала Unix эпохи.

Форматы даты и даты с временем для функций toDate/toDateTime определяются следующим образом:

```response
YYYY-MM-DD
YYYY-MM-DD hh:mm:ss
```

В качестве исключения, если преобразуется из числовых типов UInt32, Int32, UInt64 или Int64 в дату, и если число больше или равно 65536, число интерпретируется как Unix timestamp (а не как количество дней) и округляется до даты. Это позволяет поддерживать распространенную практику написания `toDate(unix_timestamp)`, что в противном случае вызвало бы ошибку и потребовало бы написания более громоздкого `toDate(toDateTime(unix_timestamp))`.

Преобразование между датой и датой с временем выполняется естественным образом: добавлением нулевого времени или отбрасыванием времени.

Преобразование между числовыми типами использует те же правила, что и присваивания между различными числовыми типами в C++.

Кроме того, функция toString аргумента DateTime может принимать второй строковый аргумент, содержащий имя часового пояса. Пример: `Asia/Yekaterinburg` В этом случае время форматируется в соответствии с указанным часовым поясом.

**Пример**

Запрос:

```sql
SELECT
    now() AS ts,
    time_zone,
    toString(ts, time_zone) AS str_tz_datetime
FROM system.time_zones
WHERE time_zone LIKE 'Europe%'
LIMIT 10
```

Результат:

```response
┌──────────────────ts─┬─time_zone─────────┬─str_tz_datetime─────┐
│ 2023-09-08 19:14:59 │ Europe/Amsterdam  │ 2023-09-08 21:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Andorra    │ 2023-09-08 21:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Astrakhan  │ 2023-09-08 23:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Athens     │ 2023-09-08 22:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Belfast    │ 2023-09-08 20:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Belgrade   │ 2023-09-08 21:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Berlin     │ 2023-09-08 21:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Bratislava │ 2023-09-08 21:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Brussels   │ 2023-09-08 21:14:59 │
│ 2023-09-08 19:14:59 │ Europe/Bucharest  │ 2023-09-08 22:14:59 │
└─────────────────────┴───────────────────┴─────────────────────┘
```

Также смотрите функцию `toUnixTimestamp`.
```

## toFixedString {#tofixedstring}

Преобразует аргумент типа [String](../data-types/string.md) в тип [FixedString(N)](../data-types/fixedstring.md) (строка фиксированной длины N). Если строка имеет меньше байт, чем N, она дополняется нулевыми байтами справа. Если строка имеет больше байт, чем N, выбрасывается исключение.

**Синтаксис**

```sql
toFixedString(s, N)
```

**Аргументы**

- `s` — Строка, которую необходимо преобразовать в фиксированную строку. [String](../data-types/string.md).
- `N` — Длина N. [UInt8](../data-types/int-uint.md)

**Возвращаемое значение**

- Фиксированная строка длины N из `s`. [FixedString](../data-types/fixedstring.md).

**Пример**

Запрос:

``` sql
SELECT toFixedString('foo', 8) AS s;
```

Результат:

```response
┌─s─────────────┐
│ foo\0\0\0\0\0 │
└───────────────┘
```
## toStringCutToZero {#tostringcuttozero}

Принимает аргумент типа String или FixedString. Возвращает строку с содержимым, обрезанным на первом нулевом байте, найденном.

**Синтаксис**

```sql
toStringCutToZero(s)
```

**Пример**

Запрос:

``` sql
SELECT toFixedString('foo', 8) AS s, toStringCutToZero(s) AS s_cut;
```

Результат:

```response
┌─s─────────────┬─s_cut─┐
│ foo\0\0\0\0\0 │ foo   │
└───────────────┴───────┘
```

Запрос:

``` sql
SELECT toFixedString('foo\0bar', 8) AS s, toStringCutToZero(s) AS s_cut;
```

Результат:

```response
┌─s──────────┬─s_cut─┐
│ foo\0bar\0 │ foo   │
└────────────┴───────┘
```
## toDecimalString {#todecimalstring}

Преобразует числовое значение в строку с количеством дробных знаков в выводе, указанным пользователем.

**Синтаксис**

``` sql
toDecimalString(number, scale)
```

**Аргументы**

- `number` — Значение, которое должно быть представлено в виде строки, [Int, UInt](../data-types/int-uint.md), [Float](../data-types/float.md), [Decimal](../data-types/decimal.md),
- `scale` — Количество дробных знаков, [UInt8](../data-types/int-uint.md).
    * Максимальная доля для типов [Decimal](../data-types/decimal.md) и [Int, UInt](../data-types/int-uint.md) составляет 77 (это максимальное возможное количество значимых цифр для Decimal),
    * Максимальная доля для [Float](../data-types/float.md) составляет 60.

**Возвращаемое значение**

- Входное значение, представленное в виде [String](../data-types/string.md) с заданным количеством дробных знаков (scale).
    Число округляется вверх или вниз в соответствии с общепринятой арифметикой в случае, если запрашиваемая доля меньше, чем доля оригинального числа.

**Пример**

Запрос:

``` sql
SELECT toDecimalString(CAST('64.32', 'Float64'), 5);
```

Результат:

```response
┌toDecimalString(CAST('64.32', 'Float64'), 5)─┐
│ 64.32000                                    │
└─────────────────────────────────────────────┘
```
## reinterpretAsUInt8 {#reinterpretasuint8}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа UInt8. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsUInt8(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как UInt8. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как UInt8. [UInt8](/sql-reference/data-types/int-uint).

**Пример**

Запрос:

```sql
SELECT
    toInt8(257) AS x,
    toTypeName(x),
    reinterpretAsUInt8(x) AS res,
    toTypeName(res);
```

Результат:

```response
┌─x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 1 │ Int8          │   1 │ UInt8           │
└───┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsUInt16 {#reinterpretasuint16}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа UInt16. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsUInt16(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как UInt16. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как UInt16. [UInt16](/sql-reference/data-types/int-uint).

**Пример**

Запрос:

```sql
SELECT
    toUInt8(257) AS x,
    toTypeName(x),
    reinterpretAsUInt16(x) AS res,
    toTypeName(res);
```

Результат:

```response
┌─x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 1 │ UInt8         │   1 │ UInt16          │
└───┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsUInt32 {#reinterpretasuint32}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа UInt32. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsUInt32(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как UInt32. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как UInt32. [UInt32](/sql-reference/data-types/int-uint).

**Пример**

Запрос:

```sql
SELECT
    toUInt16(257) AS x,
    toTypeName(x),
    reinterpretAsUInt32(x) AS res,
    toTypeName(res)
```

Результат:

```response
┌───x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 257 │ UInt16        │ 257 │ UInt32          │
└─────┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsUInt64 {#reinterpretasuint64}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа UInt64. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsUInt64(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как UInt64. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как UInt64. [UInt64](/sql-reference/data-types/int-uint).

**Пример**

Запрос:

```sql
SELECT
    toUInt32(257) AS x,
    toTypeName(x),
    reinterpretAsUInt64(x) AS res,
    toTypeName(res)
```

Результат:

```response
┌───x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 257 │ UInt32        │ 257 │ UInt64          │
└─────┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsUInt128 {#reinterpretasuint128}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа UInt128. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsUInt128(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как UInt128. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как UInt128. [UInt128](/sql-reference/data-types/int-uint).

**Пример**

Запрос:

```sql
SELECT
    toUInt64(257) AS x,
    toTypeName(x),
    reinterpretAsUInt128(x) AS res,
    toTypeName(res)
```

Результат:

```response
┌───x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 257 │ UInt64        │ 257 │ UInt128         │
└─────┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsUInt256 {#reinterpretasuint256}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа UInt256. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsUInt256(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как UInt256. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как UInt256. [UInt256](/sql-reference/data-types/int-uint).

**Пример**

Запрос:

```sql
SELECT
    toUInt128(257) AS x,
    toTypeName(x),
    reinterpretAsUInt256(x) AS res,
    toTypeName(res)
```

Результат:

```response
┌───x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 257 │ UInt128       │ 257 │ UInt256         │
└─────┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsInt8 {#reinterpretasint8}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа Int8. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsInt8(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как Int8. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как Int8. [Int8](/sql-reference/data-types/int-uint#integer-ranges).

**Пример**

Запрос:

```sql
SELECT
    toUInt8(257) AS x,
    toTypeName(x),
    reinterpretAsInt8(x) AS res,
    toTypeName(res);
```

Результат:

```response
┌─x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 1 │ UInt8         │   1 │ Int8            │
└───┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsInt16 {#reinterpretasint16}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа Int16. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsInt16(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как Int16. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как Int16. [Int16](/sql-reference/data-types/int-uint#integer-ranges).

**Пример**

Запрос:

```sql
SELECT
    toInt8(257) AS x,
    toTypeName(x),
    reinterpretAsInt16(x) AS res,
    toTypeName(res);
```

Результат:

```response
┌─x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 1 │ Int8          │   1 │ Int16           │
└───┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsInt32 {#reinterpretasint32}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа Int32. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsInt32(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как Int32. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как Int32. [Int32](/sql-reference/data-types/int-uint#integer-ranges).

**Пример**

Запрос:

```sql
SELECT
    toInt16(257) AS x,
    toTypeName(x),
    reinterpretAsInt32(x) AS res,
    toTypeName(res);
```

Результат:

```response
┌───x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 257 │ Int16         │ 257 │ Int32           │
└─────┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsInt64 {#reinterpretasint64}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа Int64. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsInt64(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как Int64. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как Int64. [Int64](/sql-reference/data-types/int-uint#integer-ranges).

**Пример**

Запрос:

```sql
SELECT
    toInt32(257) AS x,
    toTypeName(x),
    reinterpretAsInt64(x) AS res,
    toTypeName(res);
```

Результат:

```response
┌───x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 257 │ Int32         │ 257 │ Int64           │
└─────┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsInt128 {#reinterpretasint128}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа Int128. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsInt128(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как Int128. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как Int128. [Int128](/sql-reference/data-types/int-uint#integer-ranges).

**Пример**

Запрос:

```sql
SELECT
    toInt64(257) AS x,
    toTypeName(x),
    reinterpretAsInt128(x) AS res,
    toTypeName(res);
```

Результат:

```response
┌───x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 257 │ Int64         │ 257 │ Int128          │
└─────┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsInt256 {#reinterpretasint256}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа Int256. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsInt256(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как Int256. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как Int256. [Int256](/sql-reference/data-types/int-uint#integer-ranges).

**Пример**

Запрос:

```sql
SELECT
    toInt128(257) AS x,
    toTypeName(x),
    reinterpretAsInt256(x) AS res,
    toTypeName(res);
```

Результат:

```response
┌───x─┬─toTypeName(x)─┬─res─┬─toTypeName(res)─┐
│ 257 │ Int128        │ 257 │ Int256          │
└─────┴───────────────┴─────┴─────────────────┘
```
## reinterpretAsFloat32 {#reinterpretasfloat32}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа Float32. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsFloat32(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как Float32. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как Float32. [Float32](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT reinterpretAsUInt32(toFloat32(0.2)) as x, reinterpretAsFloat32(x);
```

Результат:

```response
┌──────────x─┬─reinterpretAsFloat32(x)─┐
│ 1045220557 │                     0.2 │
└────────────┴─────────────────────────┘
```
## reinterpretAsFloat64 {#reinterpretasfloat64}

Выполняет переинтерпретацию байтов, рассматривая входное значение как значение типа Float64. В отличие от [`CAST`](#cast), функция не пытается сохранить оригинальное значение - если целевой тип не может представить входной тип, выход будет нецелесообразным.

**Синтаксис**

```sql
reinterpretAsFloat64(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое как Float64. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Переинтерпретированное значение `x` как Float64. [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
SELECT reinterpretAsUInt64(toFloat64(0.2)) as x, reinterpretAsFloat64(x);
```

Результат:

```response
┌───────────────────x─┬─reinterpretAsFloat64(x)─┐
│ 4596373779694328218 │                     0.2 │
└─────────────────────┴─────────────────────────┘
```
## reinterpretAsDate {#reinterpretasdate}

Принимает строку, фиксированную строку или числовое значение и интерпретирует байты как число в порядок хосте (little endian). Возвращает дату из интерпретированного числа как количество дней с начала эпохи Unix.

**Синтаксис**

```sql
reinterpretAsDate(x)
```

**Параметры**

- `x`: количество дней с начала эпохи Unix. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Дата. [Date](../data-types/date.md).

**Детали реализации**

:::note
Если предоставленная строка недостаточно длинная, функция работает так, будто строка дополнена необходимым количеством нулевых байтов. Если строка длиннее, чем необходимо, лишние байты игнорируются.
:::

**Пример**

Запрос:

```sql
SELECT reinterpretAsDate(65), reinterpretAsDate('A');
```

Результат:

```response
┌─reinterpretAsDate(65)─┬─reinterpretAsDate('A')─┐
│            1970-03-07 │             1970-03-07 │
└───────────────────────┴────────────────────────┘
```
## reinterpretAsDateTime {#reinterpretasdatetime}

Эти функции принимают строку и интерпретируют байты, помещенные в начале строки, как число в порядок хосте (little endian). Возвращает дату с временем, интерпретированным как количество секунд с начала эпохи Unix.

**Синтаксис**

```sql
reinterpretAsDateTime(x)
```

**Параметры**

- `x`: количество секунд с начала эпохи Unix. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md), [UUID](../data-types/uuid.md), [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

**Возвращаемое значение**

- Дата и время. [DateTime](../data-types/datetime.md).

**Детали реализации**

:::note
Если предоставленная строка недостаточно длинная, функция работает так, будто строка дополнена необходимым количеством нулевых байтов. Если строка длиннее, чем необходимо, лишние байты игнорируются.
:::

**Пример**

Запрос:

```sql
SELECT reinterpretAsDateTime(65), reinterpretAsDateTime('A');
```

Результат:

```response
┌─reinterpretAsDateTime(65)─┬─reinterpretAsDateTime('A')─┐
│       1970-01-01 01:01:05 │        1970-01-01 01:01:05 │
└───────────────────────────┴────────────────────────────┘
```
## reinterpretAsString {#reinterpretasstring}

Эта функция принимает число, дату или дату с временем и возвращает строку, содержащую байты, представляющие соответствующее значение в порядке хосте (little endian). Нулевые байты отбрасываются с конца. Например, значение типа UInt32 255 представляет собой строку длиной один байт.

**Синтаксис**

```sql
reinterpretAsString(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое в строку. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md).

**Возвращаемое значение**

- Строка, содержащая байты, представляющие `x`. [String](../data-types/fixedstring.md).

**Пример**

Запрос:

```sql
SELECT
    reinterpretAsString(toDateTime('1970-01-01 01:01:05')),
    reinterpretAsString(toDate('1970-03-07'));
```

Результат:

```response
┌─reinterpretAsString(toDateTime('1970-01-01 01:01:05'))─┬─reinterpretAsString(toDate('1970-03-07'))─┐
│ A                                                      │ A                                         │
└────────────────────────────────────────────────────────┴───────────────────────────────────────────┘
```
## reinterpretAsFixedString {#reinterpretasfixedstring}

Эта функция принимает число, дату или дату с временем и возвращает FixedString, содержащую байты, представляющие соответствующее значение в порядке хосте (little endian). Нулевые байты отбрасываются с конца. Например, значение типа UInt32 255 представляет собой FixedString длиной один байт.

**Синтаксис**

```sql
reinterpretAsFixedString(x)
```

**Параметры**

- `x`: значение, переинтерпретируемое в строку. [(U)Int*](../data-types/int-uint.md), [Float](../data-types/float.md), [Date](../data-types/date.md), [DateTime](../data-types/datetime.md).

**Возвращаемое значение**

- Фиксированная строка, содержащая байты, представляющие `x`. [FixedString](../data-types/fixedstring.md).

**Пример**

Запрос:

```sql
SELECT
    reinterpretAsFixedString(toDateTime('1970-01-01 01:01:05')),
    reinterpretAsFixedString(toDate('1970-03-07'));
```

Результат:

```response
┌─reinterpretAsFixedString(toDateTime('1970-01-01 01:01:05'))─┬─reinterpretAsFixedString(toDate('1970-03-07'))─┐
│ A                                                           │ A                                              │
└─────────────────────────────────────────────────────────────┴────────────────────────────────────────────────┘
```
## reinterpretAsUUID {#reinterpretasuuid}

:::note
В дополнение к функциям UUID, перечисленным здесь, имеется специальная [документация по функциям UUID](../functions/uuid-functions.md).
:::

Принимает строку длиной 16 байт и возвращает UUID, интерпретируя каждую 8-байтовую часть в порядке байтов little-endian. Если строка недостаточно длинная, функция работает так, будто строка дополнена необходимым количеством нулевых байтов в конце. Если строка длиннее 16 байт, лишние байты в конце игнорируются.

**Синтаксис**

``` sql
reinterpretAsUUID(fixed_string)
```

**Аргументы**

- `fixed_string` — строка с байтами в порядке big-endian. [FixedString](/sql-reference/data-types/fixedstring).

**Возвращаемое значение**

- Значение типа UUID. [UUID](/sql-reference/data-types/uuid).

**Примеры**

Строка в UUID.

Запрос:

``` sql
SELECT reinterpretAsUUID(reverse(unhex('000102030405060708090a0b0c0d0e0f')));
```

Результат:

```response
┌─reinterpretAsUUID(reverse(unhex('000102030405060708090a0b0c0d0e0f')))─┐
│                                  08090a0b-0c0d-0e0f-0001-020304050607 │
└───────────────────────────────────────────────────────────────────────┘
```

Обратное преобразование из строки в UUID.

Запрос:

``` sql
WITH
    generateUUIDv4() AS uuid,
    identity(lower(hex(reverse(reinterpretAsString(uuid))))) AS str,
    reinterpretAsUUID(reverse(unhex(str))) AS uuid2
SELECT uuid = uuid2;
```

Результат:

```response
┌─equals(uuid, uuid2)─┐
│                   1 │
└─────────────────────┘
```
## reinterpret {#reinterpret}

Использует ту же последовательность байтов в памяти для значения `x` и переинтерпретирует его в тип назначения.

**Синтаксис**

``` sql
reinterpret(x, type)
```

**Аргументы**

- `x` — Любой тип.
- `type` — Тип назначения. [String](../data-types/string.md).

**Возвращаемое значение**

- Значение типа назначения.

**Примеры**

Запрос:
```sql
SELECT reinterpret(toInt8(-1), 'UInt8') as int_to_uint,
    reinterpret(toInt8(1), 'Float32') as int_to_float,
    reinterpret('1', 'UInt32') as string_to_int;
```

Результат:

```text
┌─int_to_uint─┬─int_to_float─┬─string_to_int─┐
│         255 │        1e-45 │            49 │
└─────────────┴──────────────┴───────────────┘
```
## CAST {#cast}

Преобразует входное значение в указанный тип данных. В отличие от функции [reinterpret](#reinterpret), `CAST` пытается представить то же значение, используя новый тип данных. Если преобразование не может быть выполнено, возникает исключение. Поддерживаются несколько вариантов синтаксиса.

**Синтаксис**

``` sql
CAST(x, T)
CAST(x AS t)
x::t
```

**Аргументы**

- `x` — Значение для преобразования. Может быть любого типа.
- `T` — Название целевого типа данных. [String](../data-types/string.md).
- `t` — Целевой тип данных.

**Возвращаемое значение**

- Преобразованное значение.

:::note
Если входное значение не подходит под пределы целевого типа, результат переполняется. Например, `CAST(-1, 'UInt8')` возвращает `255`.
:::

**Примеры**

Запрос:

```sql
SELECT
    CAST(toInt8(-1), 'UInt8') AS cast_int_to_uint,
    CAST(1.5 AS Decimal(3,2)) AS cast_float_to_decimal,
    '1'::Int32 AS cast_string_to_int;
```

Результат:

```yaml
┌─cast_int_to_uint─┬─cast_float_to_decimal─┬─cast_string_to_int─┐
│              255 │                  1.50 │                  1 │
└──────────────────┴───────────────────────┴────────────────────┘
```

Запрос:

``` sql
SELECT
    '2016-06-15 23:00:00' AS timestamp,
    CAST(timestamp AS DateTime) AS datetime,
    CAST(timestamp AS Date) AS date,
    CAST(timestamp, 'String') AS string,
    CAST(timestamp, 'FixedString(22)') AS fixed_string;
```

Результат:

```response
┌─timestamp───────────┬────────────datetime─┬───────date─┬─string──────────────┬─fixed_string──────────────┐
│ 2016-06-15 23:00:00 │ 2016-06-15 23:00:00 │ 2016-06-15 │ 2016-06-15 23:00:00 │ 2016-06-15 23:00:00\0\0\0 │
└─────────────────────┴─────────────────────┴────────────┴─────────────────────┴───────────────────────────┘
```

Преобразование в [FixedString (N)](../data-types/fixedstring.md) работает только для аргументов типов [String](../data-types/string.md) или [FixedString](../data-types/fixedstring.md).

Преобразование в [Nullable](../data-types/nullable.md) и обратно поддерживается.

**Пример**

Запрос:

``` sql
SELECT toTypeName(x) FROM t_null;
```

Результат:

```response
┌─toTypeName(x)─┐
│ Int8          │
│ Int8          │
└───────────────┘
```

Запрос:

``` sql
SELECT toTypeName(CAST(x, 'Nullable(UInt16)')) FROM t_null;
```

Результат:

```response
┌─toTypeName(CAST(x, 'Nullable(UInt16)'))─┐
│ Nullable(UInt16)                        │
│ Nullable(UInt16)                        │
└─────────────────────────────────────────┘
```

**См. также**

- [cast_keep_nullable](../../operations/settings/settings.md/#cast_keep_nullable) настройка
## accurateCast(x, T) {#accuratecastx-t}

Преобразует `x` в тип данных `T`.

Отличие от [cast](#cast) заключается в том, что `accurateCast` не позволяет переполнение числовых типов во время преобразования, если значение типа `x` не подходит под пределы типа `T`. Например, `accurateCast(-1, 'UInt8')` выбрасывает исключение.

**Пример**

Запрос:

``` sql
SELECT cast(-1, 'UInt8') as uint8;
```

Результат:

```response
┌─uint8─┐
│   255 │
└───────┘
```

Запрос:

```sql
SELECT accurateCast(-1, 'UInt8') as uint8;
```

Результат:

```response
Code: 70. DB::Exception: Received from localhost:9000. DB::Exception: Value in column Int8 cannot be safely converted into type UInt8: While processing accurateCast(-1, 'UInt8') AS uint8.
```
## accurateCastOrNull(x, T) {#accuratecastornullx-t}

Преобразует входное значение `x` в указанный тип данных `T`. Всегда возвращает [Nullable](../data-types/nullable.md) тип и возвращает [NULL](/sql-reference/syntax#null), если преобразованное значение не может быть представлено в целевом типе.

**Синтаксис**

```sql
accurateCastOrNull(x, T)
```

**Аргументы**

- `x` — Входное значение.
- `T` — Название возвращаемого типа данных.

**Возвращаемое значение**

- Значение, преобразованное в указанный тип данных `T`.

**Пример**

Запрос:

``` sql
SELECT toTypeName(accurateCastOrNull(5, 'UInt8'));
```

Результат:

```response
┌─toTypeName(accurateCastOrNull(5, 'UInt8'))─┐
│ Nullable(UInt8)                            │
└────────────────────────────────────────────┘
```

Запрос:

``` sql
SELECT
    accurateCastOrNull(-1, 'UInt8') as uint8,
    accurateCastOrNull(128, 'Int8') as int8,
    accurateCastOrNull('Test', 'FixedString(2)') as fixed_string;
```

Результат:

```response
┌─uint8─┬─int8─┬─fixed_string─┐
│  ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ         │
└───────┴──────┴──────────────┘
```
## accurateCastOrDefault(x, T[, default_value]) {#accuratecastordefaultx-t-default_value}

Преобразует входное значение `x` в указанный тип данных `T`. Возвращает значение по умолчанию типа или `default_value`, если он указан, если преобразованное значение не может быть представлен в целевом типе.

**Синтаксис**

```sql
accurateCastOrDefault(x, T)
```

**Аргументы**

- `x` — Входное значение.
- `T` — Название возвращаемого типа данных.
- `default_value` — Значение по умолчанию возвращаемого типа данных.

**Возвращаемое значение**

- Значение, преобразованное в указанный тип данных `T`.

**Пример**

Запрос:

``` sql
SELECT toTypeName(accurateCastOrDefault(5, 'UInt8'));
```

Результат:

```response
┌─toTypeName(accurateCastOrDefault(5, 'UInt8'))─┐
│ UInt8                                         │
└───────────────────────────────────────────────┘
```

Запрос:

``` sql
SELECT
    accurateCastOrDefault(-1, 'UInt8') as uint8,
    accurateCastOrDefault(-1, 'UInt8', 5) as uint8_default,
    accurateCastOrDefault(128, 'Int8') as int8,
    accurateCastOrDefault(128, 'Int8', 5) as int8_default,
    accurateCastOrDefault('Test', 'FixedString(2)') as fixed_string,
    accurateCastOrDefault('Test', 'FixedString(2)', 'Te') as fixed_string_default;
```

Результат:

```response
┌─uint8─┬─uint8_default─┬─int8─┬─int8_default─┬─fixed_string─┬─fixed_string_default─┐
│     0 │             5 │    0 │            5 │              │ Te                   │
└───────┴───────────────┴──────┴──────────────┴──────────────┴──────────────────────┘
```
## toIntervalYear {#tointervalyear}

Возвращает интервал в `n` лет типа [IntervalYear](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalYear(n)
```

**Аргументы**

- `n` — Количество лет. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` лет. [IntervalYear](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDate('2024-06-15') AS date,
    toIntervalYear(1) AS interval_to_year
SELECT date + interval_to_year AS result
```

Результат:

```response
┌─────result─┐
│ 2025-06-15 │
└────────────┘
```
## toIntervalQuarter {#tointervalquarter}

Возвращает интервал в `n` кварталов типа [IntervalQuarter](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalQuarter(n)
```

**Аргументы**

- `n` — Количество кварталов. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` кварталов. [IntervalQuarter](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDate('2024-06-15') AS date,
    toIntervalQuarter(1) AS interval_to_quarter
SELECT date + interval_to_quarter AS result
```

Результат:

```response
┌─────result─┐
│ 2024-09-15 │
└────────────┘
```
## toIntervalMonth {#tointervalmonth}

Возвращает интервал в `n` месяцах типа [IntervalMonth](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalMonth(n)
```

**Аргументы**

- `n` — Количество месяцев. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` месяцах. [IntervalMonth](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDate('2024-06-15') AS date,
    toIntervalMonth(1) AS interval_to_month
SELECT date + interval_to_month AS result
```

Результат:

```response
┌─────result─┐
│ 2024-07-15 │
└────────────┘
```
## toIntervalWeek {#tointervalweek}

Возвращает интервал в `n` неделях типа [IntervalWeek](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalWeek(n)
```

**Аргументы**

- `n` — Количество недель. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` неделях. [IntervalWeek](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDate('2024-06-15') AS date,
    toIntervalWeek(1) AS interval_to_week
SELECT date + interval_to_week AS result
```

Результат:

```response
┌─────result─┐
│ 2024-06-22 │
└────────────┘
```
## toIntervalDay {#tointervalday}

Возвращает интервал в `n` днях типа [IntervalDay](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalDay(n)
```

**Аргументы**

- `n` — Количество дней. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` днях. [IntervalDay](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDate('2024-06-15') AS date,
    toIntervalDay(5) AS interval_to_days
SELECT date + interval_to_days AS result
```

Результат:

```response
┌─────result─┐
│ 2024-06-20 │
└────────────┘
```
## toIntervalHour {#tointervalhour}

Возвращает интервал в `n` часах типа [IntervalHour](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalHour(n)
```

**Аргументы**

- `n` — Количество часов. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` часах. [IntervalHour](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDate('2024-06-15') AS date,
    toIntervalHour(12) AS interval_to_hours
SELECT date + interval_to_hours AS result
```

Результат:

```response
┌──────────────result─┐
│ 2024-06-15 12:00:00 │
└─────────────────────┘
```
## toIntervalMinute {#tointervalminute}

Возвращает интервал в `n` минутах типа [IntervalMinute](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalMinute(n)
```

**Аргументы**

- `n` — Количество минут. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` минутах. [IntervalMinute](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDate('2024-06-15') AS date,
    toIntervalMinute(12) AS interval_to_minutes
SELECT date + interval_to_minutes AS result
```

Результат:

```response
┌──────────────result─┐
│ 2024-06-15 00:12:00 │
└─────────────────────┘
```
## toIntervalSecond {#tointervalsecond}

Возвращает интервал в `n` секундах типа [IntervalSecond](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalSecond(n)
```

**Аргументы**

- `n` — Количество секунд. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` секундах. [IntervalSecond](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDate('2024-06-15') AS date,
    toIntervalSecond(30) AS interval_to_seconds
SELECT date + interval_to_seconds AS result
```

Результат:

```response
┌──────────────result─┐
│ 2024-06-15 00:00:30 │
└─────────────────────┘
```
## toIntervalMillisecond {#tointervalmillisecond}

Возвращает интервал в `n` миллисекундах типа [IntervalMillisecond](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalMillisecond(n)
```

**Аргументы**

- `n` — Количество миллисекунд. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` миллисекундах. [IntervalMilliseconds](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDateTime('2024-06-15') AS date,
    toIntervalMillisecond(30) AS interval_to_milliseconds
SELECT date + interval_to_milliseconds AS result
```

Результат:

```response
┌──────────────────result─┐
│ 2024-06-15 00:00:00.030 │
└─────────────────────────┘
```
## toIntervalMicrosecond {#tointervalmicrosecond}

Возвращает интервал в `n` микросекундах типа [IntervalMicrosecond](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalMicrosecond(n)
```

**Аргументы**

- `n` — Количество микросекунд. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` микросекундах. [IntervalMicrosecond](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDateTime('2024-06-15') AS date,
    toIntervalMicrosecond(30) AS interval_to_microseconds
SELECT date + interval_to_microseconds AS result
```

Результат:

```response
┌─────────────────────result─┐
│ 2024-06-15 00:00:00.000030 │
└────────────────────────────┘
```
## toIntervalNanosecond {#tointervalnanosecond}

Возвращает интервал в `n` наносекундах типа [IntervalNanosecond](../data-types/special-data-types/interval.md).

**Синтаксис**

``` sql
toIntervalNanosecond(n)
```

**Аргументы**

- `n` — Количество наносекунд. Целые числа или строковые представления таковых, и вещественные числа. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).

**Возвращаемые значения**

- Интервал в `n` наносекундах. [IntervalNanosecond](../data-types/special-data-types/interval.md).

**Пример**

Запрос:

``` sql
WITH
    toDateTime('2024-06-15') AS date,
    toIntervalNanosecond(30) AS interval_to_nanoseconds
SELECT date + interval_to_nanoseconds AS result
```

Результат:

```response
┌────────────────────────result─┐
│ 2024-06-15 00:00:00.000000030 │
└───────────────────────────────┘
```
## parseDateTime {#parsedatetime}

Преобразует [String](../data-types/string.md) в [DateTime](../data-types/datetime.md) согласно строке формата [MySQL](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-format).

Эта функция является обратной операцией к функции [formatDateTime](/sql-reference/functions/date-time-functions#formatdatetime).

**Синтаксис**

``` sql
parseDateTime(str[, format[, timezone]])
```

**Аргументы**

- `str` — Строка, которую нужно разобрать.
- `format` — Строка формата. Необязательно. `%Y-%m-%d %H:%i:%s`, если не указано.
- `timezone` — [Часовой пояс](operations/server-configuration-parameters/settings.md#timezone). Необязательно.

**Возвращаемое значение(я)**

Возвращает значение [DateTime](../data-types/datetime.md), разобранное из входной строки в соответствии со строкой формата в стиле MySQL.

**Поддерживаемые спецификаторы формата**

Все спецификаторы формата, перечисленные в [formatDateTime](/sql-reference/functions/date-time-functions#formatdatetime), за исключением:
- %Q: Квартал (1-4)

**Пример**

``` sql
SELECT parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s')

┌─parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s')─┐
│                                       2021-01-04 23:00:00 │
└───────────────────────────────────────────────────────────┘
```

Псевдоним: `TO_TIMESTAMP`.
## parseDateTimeOrZero {#parsedatetimeorzero}

То же самое, что и [parseDateTime](#parsedatetime), за исключением того, что возвращает дату ноль, когда встречает формат даты, который не может быть обработан.
## parseDateTimeOrNull {#parsedatetimeornull}

То же самое, что и [parseDateTime](#parsedatetime), за исключением того, что возвращает `NULL`, когда встречает формат даты, который не может быть обработан.

Псевдоним: `str_to_date`.
## parseDateTimeInJodaSyntax {#parsedatetimeinjodasyntax}

Похоже на [parseDateTime](#parsedatetime), за исключением того, что строка формата в [Joda](https://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html), а не в синтаксисе MySQL.

Эта функция является обратной операцией к функции [formatDateTimeInJodaSyntax](/sql-reference/functions/date-time-functions#formatdatetimeinjodasyntax).

**Синтаксис**

``` sql
parseDateTimeInJodaSyntax(str[, format[, timezone]])
```

**Аргументы**

- `str` — Строка, которую нужно разобрать.
- `format` — Строка формата. Необязательно. `yyyy-MM-dd HH:mm:ss`, если не указано.
- `timezone` — [Часовой пояс](operations/server-configuration-parameters/settings.md#timezone). Необязательно.

**Возвращаемое значение(я)**

Возвращает значение [DateTime](../data-types/datetime.md), разобранное из входной строки в соответствии со строкой формата в стиле Joda.

**Поддерживаемые спецификаторы формата**

Все спецификаторы формата, перечисленные в [formatDateTimeInJoda](/sql-reference/functions/date-time-functions#formatdatetime), поддерживаются, за исключением:
- S: доля секунды
- z: часовой пояс
- Z: смещение/идентификатор часового пояса

**Пример**

``` sql
SELECT parseDateTimeInJodaSyntax('2023-02-24 14:53:31', 'yyyy-MM-dd HH:mm:ss', 'Europe/Minsk')

┌─parseDateTimeInJodaSyntax('2023-02-24 14:53:31', 'yyyy-MM-dd HH:mm:ss', 'Europe/Minsk')─┐
│                                                                     2023-02-24 14:53:31 │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```
## parseDateTimeInJodaSyntaxOrZero {#parsedatetimeinjodasyntaxorzero}

То же самое, что и [parseDateTimeInJodaSyntax](#parsedatetimeinjodasyntax), за исключением того, что возвращает дату ноль, когда встречает формат даты, который не может быть обработан.
## parseDateTimeInJodaSyntaxOrNull {#parsedatetimeinjodasyntaxornull}

То же самое, что и [parseDateTimeInJodaSyntax](#parsedatetimeinjodasyntax), за исключением того, что возвращает `NULL`, когда встречает формат даты, который не может быть обработан.
## parseDateTime64 {#parsedatetime64}

Преобразует [String](../data-types/string.md) в [DateTime64](../data-types/datetime64.md) согласно строке формата [MySQL](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-format).

**Синтаксис**

``` sql
parseDateTime64(str[, format[, timezone]])
```

**Аргументы**

- `str` — Строка, которую нужно разобрать.
- `format` — Строка формата. Необязательно. `%Y-%m-%d %H:%i:%s.%f`, если не указано.
- `timezone` — [Часовой пояс](/operations/server-configuration-parameters/settings.md#timezone). Необязательно.

**Возвращаемое значение(я)**

Возвращает значение [DateTime64](../data-types/datetime64.md), разобранное из входной строки в соответствии со строкой формата в стиле MySQL.
Точность возвращаемого значения составляет 6.
## parseDateTime64OrZero {#parsedatetime64orzero}

То же самое, что и [parseDateTime64](#parsedatetime64), за исключением того, что возвращает дату ноль, когда встречает формат даты, который не может быть обработан.
## parseDateTime64OrNull {#parsedatetime64ornull}

То же самое, что и [parseDateTime64](#parsedatetime64), за исключением того, что возвращает `NULL`, когда встречает формат даты, который не может быть обработан.
## parseDateTime64InJodaSyntax {#parsedatetime64injodasyntax}

Преобразует [String](../data-types/string.md) в [DateTime64](../data-types/datetime64.md) согласно строке формата [Joda](https://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html).

**Синтаксис**

``` sql
parseDateTime64InJodaSyntax(str[, format[, timezone]])
```

**Аргументы**

- `str` — Строка, которую нужно разобрать.
- `format` — Строка формата. Необязательно. `yyyy-MM-dd HH:mm:ss`, если не указано.
- `timezone` — [Часовой пояс](/operations/server-configuration-parameters/settings.md#timezone). Необязательно.

**Возвращаемое значение(я)**

Возвращает значение [DateTime64](../data-types/datetime64.md), разобранное из входной строки в соответствии со строкой формата в стиле Joda.
Точность возвращаемого значения равна числу заполнителей `S` в строке формата (но не более 6).
## parseDateTime64InJodaSyntaxOrZero {#parsedatetime64injodasyntaxorzero}

То же самое, что и [parseDateTime64InJodaSyntax](#parsedatetime64injodasyntax), за исключением того, что возвращает дату ноль, когда встречает формат даты, который не может быть обработан.
## parseDateTime64InJodaSyntaxOrNull {#parsedatetime64injodasyntaxornull}

То же самое, что и [parseDateTime64InJodaSyntax](#parsedatetime64injodasyntax), за исключением того, что возвращает `NULL`, когда встречает формат даты, который не может быть обработан.
## parseDateTimeBestEffort {#parsedatetimebesteffort}
## parseDateTime32BestEffort {#parsedatetime32besteffort}

Преобразует дату и время в строковом представлении [String](../data-types/string.md) в тип данных [DateTime](/sql-reference/data-types/datetime).

Функция разбирает [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), [RFC 1123 - 5.2.14 RFC-822 Дата и время](https://tools.ietf.org/html/rfc1123#page-55), форматы даты и времени ClickHouse и некоторые другие.

**Синтаксис**

``` sql
parseDateTimeBestEffort(time_string [, time_zone])
```

**Аргументы**

- `time_string` — Строка, содержащая дату и время для преобразования. [String](../data-types/string.md).
- `time_zone` — Часовой пояс. Функция разбирает `time_string` в соответствии с часовым поясом. [String](../data-types/string.md).

**Поддерживаемые нестандартные форматы**

- Строка, содержащая 9..10 цифр [unix timestamp](https://en.wikipedia.org/wiki/Unix_time).
- Строка с компонентом даты и времени: `YYYYMMDDhhmmss`, `DD/MM/YYYY hh:mm:ss`, `DD-MM-YY hh:mm`, `YYYY-MM-DD hh:mm:ss` и т. д.
- Строка с датой, но без компонента времени: `YYYY`, `YYYYMM`, `YYYY*MM`, `DD/MM/YYYY`, `DD-MM-YY` и т. д.
- Строка с днем и временем: `DD`, `DD hh`, `DD hh:mm`. В этом случае `MM` заменяется на `01`.
- Строка, которая включает дату и время вместе с информацией о смещении часового пояса: `YYYY-MM-DD hh:mm:ss ±h:mm` и т. д. Например, `2020-12-12 17:36:00 -5:00`.
- [syslog timestamp](https://datatracker.ietf.org/doc/html/rfc3164#section-4.1.2): `Mmm dd hh:mm:ss`. Например, `Jun  9 14:20:32`.

Для всех форматов с разделителем функция разбирает имена месяцев, выраженные полным названием или первыми тремя буквами названия месяца. Примеры: `24/DEC/18`, `24-Dec-18`, `01-September-2018`.
Если год не указан, он считается равным текущему году. Если полученное DateTime оказывается в будущем (даже на секунду после текущего момента), то текущий год заменяется на предыдущий.

**Возвращаемое значение**

- `time_string`, преобразованная в тип данных [DateTime](../data-types/datetime.md).

**Примеры**

Запрос:

``` sql
SELECT parseDateTimeBestEffort('23/10/2020 12:12:57')
AS parseDateTimeBestEffort;
```

Результат:

```response
┌─parseDateTimeBestEffort─┐
│     2020-10-23 12:12:57 │
└─────────────────────────┘
```

Запрос:

``` sql
SELECT parseDateTimeBestEffort('Sat, 18 Aug 2018 07:22:16 GMT', 'Asia/Istanbul')
AS parseDateTimeBestEffort;
```

Результат:

```response
┌─parseDateTimeBestEffort─┐
│     2018-08-18 10:22:16 │
└─────────────────────────┘
```

Запрос:

``` sql
SELECT parseDateTimeBestEffort('1284101485')
AS parseDateTimeBestEffort;
```

Результат:

```response
┌─parseDateTimeBestEffort─┐
│     2015-07-07 12:04:41 │
└─────────────────────────┘
```

Запрос:

``` sql
SELECT parseDateTimeBestEffort('2018-10-23 10:12:12')
AS parseDateTimeBestEffort;
```

Результат:

```response
┌─parseDateTimeBestEffort─┐
│     2018-10-23 10:12:12 │
└─────────────────────────┘
```

Запрос:

``` sql
SELECT toYear(now()) as year, parseDateTimeBestEffort('10 20:19');
```

Результат:

```response
┌─year─┬─parseDateTimeBestEffort('10 20:19')─┐
│ 2023 │                 2023-01-10 20:19:00 │
└──────┴─────────────────────────────────────┘
```

Запрос:

``` sql
WITH
    now() AS ts_now,
    formatDateTime(ts_around, '%b %e %T') AS syslog_arg
SELECT
    ts_now,
    syslog_arg,
    parseDateTimeBestEffort(syslog_arg)
FROM (SELECT arrayJoin([ts_now - 30, ts_now + 30]) AS ts_around);
```

Результат:

```response
┌──────────────ts_now─┬─syslog_arg──────┬─parseDateTimeBestEffort(syslog_arg)─┐
│ 2023-06-30 23:59:30 │ Jun 30 23:59:00 │                 2023-06-30 23:59:00 │
│ 2023-06-30 23:59:30 │ Jul  1 00:00:00 │                 2022-07-01 00:00:00 │
└─────────────────────┴─────────────────┴─────────────────────────────────────┘
```

**См. также**

- [RFC 1123](https://datatracker.ietf.org/doc/html/rfc1123)
- [toDate](#todate)
- [toDateTime](#todatetime)
- [ISO 8601 объявление @xkcd](https://xkcd.com/1179/)
- [RFC 3164](https://datatracker.ietf.org/doc/html/rfc3164#section-4.1.2)
## parseDateTimeBestEffortUS {#parsedatetimebesteffortus}

Эта функция ведет себя как [parseDateTimeBestEffort](#parsedatetimebesteffort) для форматов даты ISO, например, `YYYY-MM-DD hh:mm:ss`, и других форматов даты, где компоненты месяца и даты могут быть однозначно извлечены, например, `YYYYMMDDhhmmss`, `YYYY-MM`, `DD hh`, или `YYYY-MM-DD hh:mm:ss ±h:mm`. Если компоненты месяца и даты не могут быть однозначно извлечены, например, `MM/DD/YYYY`, `MM-DD-YYYY` или `MM-DD-YY`, она предпочитает американский формат даты вместо `DD/MM/YYYY`, `DD-MM-YYYY` или `DD-MM-YY`. Как исключение, если месяц больше 12 и меньше или равен 31, эта функция возвращается к поведению [parseDateTimeBestEffort](#parsedatetimebesteffort), например, `15/08/2020` интерпретируется как `2020-08-15`.
## parseDateTimeBestEffortOrNull {#parsedatetimebesteffortornull}
## parseDateTime32BestEffortOrNull {#parsedatetime32besteffortornull}

То же самое, что и [parseDateTimeBestEffort](#parsedatetimebesteffort), за исключением того, что возвращает `NULL`, когда встречает формат даты, который не может быть обработан.
## parseDateTimeBestEffortOrZero {#parsedatetimebesteffortorzero}
## parseDateTime32BestEffortOrZero {#parsedatetime32besteffortorzero}

То же самое, что и [parseDateTimeBestEffort](#parsedatetimebesteffort), за исключением того, что возвращает дату ноль или ноль даты и времени, когда встречает формат даты, который не может быть обработан.
## parseDateTimeBestEffortUSOrNull {#parsedatetimebesteffortusornull}

То же самое, что и функция [parseDateTimeBestEffortUS](#parsedatetimebesteffortus), за исключением того, что возвращает `NULL`, когда встречает формат даты, который не может быть обработан.
## parseDateTimeBestEffortUSOrZero {#parsedatetimebesteffortusorzero}

То же самое, что и функция [parseDateTimeBestEffortUS](#parsedatetimebesteffortus), за исключением того, что возвращает дату ноль (`1970-01-01`) или ноль даты с временем (`1970-01-01 00:00:00`), когда встречает формат даты, который не может быть обработан.
## parseDateTime64BestEffort {#parsedatetime64besteffort}

То же самое, что и функция [parseDateTimeBestEffort](#parsedatetimebesteffort), но также разбирает миллисекунды и микросекунды и возвращает тип данных [DateTime](/sql-reference/data-types/datetime).

**Синтаксис**

``` sql
parseDateTime64BestEffort(time_string [, precision [, time_zone]])
```

**Аргументы**

- `time_string` — Строка, содержащая дату или дату с временем для преобразования. [String](../data-types/string.md).
- `precision` — Необходимая точность. `3` — для миллисекунд, `6` — для микросекунд. По умолчанию — `3`. Необязательно. [UInt8](../data-types/int-uint.md).
- `time_zone` — [Часовой пояс](/operations/server-configuration-parameters/settings.md#timezone). Функция разбирает `time_string` в соответствии с часовым поясом. Необязательно. [String](../data-types/string.md).

**Возвращаемое значение**

- `time_string`, преобразованная в тип данных [DateTime](../data-types/datetime.md).

**Примеры**

Запрос:

```sql
SELECT parseDateTime64BestEffort('2021-01-01') AS a, toTypeName(a) AS t
UNION ALL
SELECT parseDateTime64BestEffort('2021-01-01 01:01:00.12346') AS a, toTypeName(a) AS t
UNION ALL
SELECT parseDateTime64BestEffort('2021-01-01 01:01:00.12346',6) AS a, toTypeName(a) AS t
UNION ALL
SELECT parseDateTime64BestEffort('2021-01-01 01:01:00.12346',3,'Asia/Istanbul') AS a, toTypeName(a) AS t
FORMAT PrettyCompactMonoBlock;
```

Результат:

```sql
┌──────────────────────────a─┬─t──────────────────────────────┐
│ 2021-01-01 01:01:00.123000 │ DateTime64(3)                  │
│ 2021-01-01 00:00:00.000000 │ DateTime64(3)                  │
│ 2021-01-01 01:01:00.123460 │ DateTime64(6)                  │
│ 2020-12-31 22:01:00.123000 │ DateTime64(3, 'Asia/Istanbul') │
└────────────────────────────┴────────────────────────────────┘
```
## parseDateTime64BestEffortUS {#parsedatetime64besteffortus}

То же самое, что и [parseDateTime64BestEffort](#parsedatetime64besteffort), за исключением того, что эта функция предпочитает американский формат даты (`MM/DD/YYYY` и т. д.) в случае неоднозначности.
## parseDateTime64BestEffortOrNull {#parsedatetime64besteffortornull}

То же самое, что и [parseDateTime64BestEffort](#parsedatetime64besteffort), за исключением того, что возвращает `NULL`, когда встречает формат даты, который не может быть обработан.
## parseDateTime64BestEffortOrZero {#parsedatetime64besteffortorzero}

То же самое, что и [parseDateTime64BestEffort](#parsedatetime64besteffort), за исключением того, что возвращает дату ноль или ноль даты и времени, когда встречает формат даты, который не может быть обработан.
## parseDateTime64BestEffortUSOrNull {#parsedatetime64besteffortusornull}

То же самое, что и [parseDateTime64BestEffort](#parsedatetime64besteffort), за исключением того, что эта функция предпочитает американский формат даты (`MM/DD/YYYY` и т. д.) в случае неоднозначности и возвращает `NULL`, когда встречает формат даты, который не может быть обработан.
## parseDateTime64BestEffortUSOrZero {#parsedatetime64besteffortusorzero}

То же самое, что и [parseDateTime64BestEffort](#parsedatetime64besteffort), за исключением того, что эта функция предпочитает американский формат даты (`MM/DD/YYYY` и т. д.) в случае неоднозначности и возвращает дату ноль или ноль даты и времени, когда встречает формат даты, который не может быть обработан.
## toLowCardinality {#tolowcardinality}

Преобразует входной параметр в версию типа данных [LowCardinality](../data-types/lowcardinality.md) того же типа.

Чтобы преобразовать данные из типа данных `LowCardinality`, используйте функцию [CAST](#cast). Например, `CAST(x as String)`.

**Синтаксис**

```sql
toLowCardinality(expr)
```

**Аргументы**

- `expr` — [Выражение](/sql-reference/syntax#expressions), результатом которого является один из [поддерживаемых типов данных](/sql-reference/data-types).

**Возвращаемые значения**

- Результат `expr`. [LowCardinality](../data-types/lowcardinality.md) того же типа, что и `expr`.

**Пример**

Запрос:

```sql
SELECT toLowCardinality('1');
```

Результат:

```response
┌─toLowCardinality('1')─┐
│ 1                     │
└───────────────────────┘
```
## toUnixTimestamp64Second {#tounixtimestamp64second}

Преобразует `DateTime64` в значение `Int64` с фиксированной точностью до секунд. Входное значение увеличивается или уменьшается в зависимости от своей точности.

:::note
Выходное значение является временной меткой в UTC, а не в часовой зоне `DateTime64`.
:::

**Синтаксис**

```sql
toUnixTimestamp64Second(value)
```

**Аргументы**

- `value` — Значение DateTime64 с любой точностью. [DateTime64](../data-types/datetime64.md).

**Возвращаемое значение**

- `value`, преобразованное в тип данных `Int64`. [Int64](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
WITH toDateTime64('2009-02-13 23:31:31.011', 3, 'UTC') AS dt64
SELECT toUnixTimestamp64Second(dt64);
```

Результат:

```response
┌─toUnixTimestamp64Second(dt64)─┐
│                    1234567891 │
└───────────────────────────────┘
```
## toUnixTimestamp64Milli {#tounixtimestamp64milli}

Преобразует `DateTime64` в значение `Int64` с фиксированной точностью до миллисекунд. Входное значение увеличивается или уменьшается в зависимости от своей точности.

:::note
Выходное значение является временной меткой в UTC, а не в часовой зоне `DateTime64`.
:::

**Синтаксис**

```sql
toUnixTimestamp64Milli(value)
```

**Аргументы**

- `value` — Значение DateTime64 с любой точностью. [DateTime64](../data-types/datetime64.md).

**Возвращаемое значение**

- `value`, преобразованное в тип данных `Int64`. [Int64](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
WITH toDateTime64('2009-02-13 23:31:31.011', 3, 'UTC') AS dt64
SELECT toUnixTimestamp64Milli(dt64);
```

Результат:

```response
┌─toUnixTimestamp64Milli(dt64)─┐
│                1234567891011 │
└──────────────────────────────┘
```
## toUnixTimestamp64Micro {#tounixtimestamp64micro}

Преобразует `DateTime64` в значение `Int64` с фиксированной точностью до микросекунд. Входное значение увеличивается или уменьшается в зависимости от своей точности.

:::note
Выходное значение является временной меткой в UTC, а не в часовой зоне `DateTime64`.
:::

**Синтаксис**

```sql
toUnixTimestamp64Micro(value)
```

**Аргументы**

- `value` — Значение DateTime64 с любой точностью. [DateTime64](../data-types/datetime64.md).

**Возвращаемое значение**

- `value`, преобразованное в тип данных `Int64`. [Int64](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
WITH toDateTime64('1970-01-15 06:56:07.891011', 6, 'UTC') AS dt64
SELECT toUnixTimestamp64Micro(dt64);
```

Результат:

```response
┌─toUnixTimestamp64Micro(dt64)─┐
│                1234567891011 │
└──────────────────────────────┘
```
## toUnixTimestamp64Nano {#tounixtimestamp64nano}

Преобразует `DateTime64` в значение `Int64` с фиксированной точностью до наносекунд. Входное значение увеличивается или уменьшается в зависимости от своей точности.

:::note
Выходное значение является временной меткой в UTC, а не в часовой зоне `DateTime64`.
:::

**Синтаксис**

```sql
toUnixTimestamp64Nano(value)
```

**Аргументы**

- `value` — Значение DateTime64 с любой точностью. [DateTime64](../data-types/datetime64.md).

**Возвращаемое значение**

- `value`, преобразованное в тип данных `Int64`. [Int64](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
WITH toDateTime64('1970-01-01 00:20:34.567891011', 9, 'UTC') AS dt64
SELECT toUnixTimestamp64Nano(dt64);
```

Результат:

```response
┌─toUnixTimestamp64Nano(dt64)─┐
│               1234567891011 │
└─────────────────────────────┘
```
```yaml
title: 'fromUnixTimestamp64Second'
sidebar_label: 'fromUnixTimestamp64Second'
keywords: ['fromUnixTimestamp64Second', 'ClickHouse', 'функции']
description: 'Конвертация Int64 в DateTime64 с фиксированной точностью.'
```

## fromUnixTimestamp64Second {#fromunixtimestamp64second}

Конвертирует `Int64` в значение `DateTime64` с фиксированной точностью до секунд и необязательным часовым поясом. Входное значение масштабируется вверх или вниз в зависимости от его точности.

:::note
Пожалуйста, обратите внимание, что входное значение рассматривается как метка времени UTC, а не метка времени в заданном (или неявном) часовом поясе.
:::

**Синтаксис**

```sql
fromUnixTimestamp64Second(value[, timezone])
```

**Аргументы**

- `value` — значение с любой точностью. [Int64](../data-types/int-uint.md).
- `timezone` — (необязательный) имя часового пояса результата. [String](../data-types/string.md).

**Возвращаемое значение**

- `value` конвертировано в DateTime64 с точностью `0`. [DateTime64](../data-types/datetime64.md).

**Пример**

Запрос:

```sql
WITH CAST(1733935988, 'Int64') AS i64
SELECT
    fromUnixTimestamp64Second(i64, 'UTC') AS x,
    toTypeName(x);
```

Результат:

```response
┌───────────────────x─┬─toTypeName(x)────────┐
│ 2024-12-11 16:53:08 │ DateTime64(0, 'UTC') │
└─────────────────────┴──────────────────────┘
```
## fromUnixTimestamp64Milli {#fromunixtimestamp64milli}

Конвертирует `Int64` в значение `DateTime64` с фиксированной точностью до миллисекунд и необязательным часовым поясом. Входное значение масштабируется вверх или вниз в зависимости от его точности.

:::note
Пожалуйста, обратите внимание, что входное значение рассматривается как метка времени UTC, а не метка времени в заданном (или неявном) часовом поясе.
:::

**Синтаксис**

```sql
fromUnixTimestamp64Milli(value[, timezone])
```

**Аргументы**

- `value` — значение с любой точностью. [Int64](../data-types/int-uint.md).
- `timezone` — (необязательный) имя часового пояса результата. [String](../data-types/string.md).

**Возвращаемое значение**

- `value` конвертировано в DateTime64 с точностью `3`. [DateTime64](../data-types/datetime64.md).

**Пример**

Запрос:

```sql
WITH CAST(1733935988123, 'Int64') AS i64
SELECT
    fromUnixTimestamp64Milli(i64, 'UTC') AS x,
    toTypeName(x);
```

Результат:

```response
┌───────────────────────x─┬─toTypeName(x)────────┐
│ 2024-12-11 16:53:08.123 │ DateTime64(3, 'UTC') │
└─────────────────────────┴──────────────────────┘
```
## fromUnixTimestamp64Micro {#fromunixtimestamp64micro}

Конвертирует `Int64` в значение `DateTime64` с фиксированной точностью до микросекунд и необязательным часовым поясом. Входное значение масштабируется вверх или вниз в зависимости от его точности.

:::note
Пожалуйста, обратите внимание, что входное значение рассматривается как метка времени UTC, а не метка времени в заданном (или неявном) часовом поясе.
:::

**Синтаксис**

```sql
fromUnixTimestamp64Micro(value[, timezone])
```

**Аргументы**

- `value` — значение с любой точностью. [Int64](../data-types/int-uint.md).
- `timezone` — (необязательный) имя часового пояса результата. [String](../data-types/string.md).

**Возвращаемое значение**

- `value` конвертировано в DateTime64 с точностью `6`. [DateTime64](../data-types/datetime64.md).

**Пример**

Запрос:

```sql
WITH CAST(1733935988123456, 'Int64') AS i64
SELECT
    fromUnixTimestamp64Micro(i64, 'UTC') AS x,
    toTypeName(x);
```

Результат:

```response
┌──────────────────────────x─┬─toTypeName(x)────────┐
│ 2024-12-11 16:53:08.123456 │ DateTime64(6, 'UTC') │
└────────────────────────────┴──────────────────────┘
```
## fromUnixTimestamp64Nano {#fromunixtimestamp64nano}

Конвертирует `Int64` в значение `DateTime64` с фиксированной точностью до наносекунд и необязательным часовым поясом. Входное значение масштабируется вверх или вниз в зависимости от его точности.

:::note
Пожалуйста, обратите внимание, что входное значение рассматривается как метка времени UTC, а не метка времени в заданном (или неявном) часовом поясе.
:::

**Синтаксис**

```sql
fromUnixTimestamp64Nano(value[, timezone])
```

**Аргументы**

- `value` — значение с любой точностью. [Int64](../data-types/int-uint.md).
- `timezone` — (необязательный) имя часового пояса результата. [String](../data-types/string.md).

**Возвращаемое значение**

- `value` конвертировано в DateTime64 с точностью `9`. [DateTime64](../data-types/datetime64.md).

**Пример**

Запрос:

```sql
WITH CAST(1733935988123456789, 'Int64') AS i64
SELECT
    fromUnixTimestamp64Nano(i64, 'UTC') AS x,
    toTypeName(x);
```

Результат:

```response
┌─────────────────────────────x─┬─toTypeName(x)────────┐
│ 2024-12-11 16:53:08.123456789 │ DateTime64(9, 'UTC') │
└───────────────────────────────┴──────────────────────┘
```
## formatRow {#formatrow}

Конвертирует произвольные выражения в строку через заданный формат.

**Синтаксис**

```sql
formatRow(format, x, y, ...)
```

**Аргументы**

- `format` — Текстовый формат. Например, [CSV](/interfaces/formats.md/#csv), [TSV](/interfaces/formats.md/#tabseparated).
- `x`,`y`, ... — Выражения.

**Возвращаемое значение**

- Форматированная строка. (для текстовых форматов она обычно заканчивается символом новой строки).

**Пример**

Запрос:

```sql
SELECT formatRow('CSV', number, 'good')
FROM numbers(3);
```

Результат:

```response
┌─formatRow('CSV', number, 'good')─┐
│ 0,"good"
                         │
│ 1,"good"
                         │
│ 2,"good"
                         │
└──────────────────────────────────┘
```

**Примечание**: Если формат содержит суффикс/префикс, он будет записан в каждой строке.

**Пример**

Запрос:

```sql
SELECT formatRow('CustomSeparated', number, 'good')
FROM numbers(3)
SETTINGS format_custom_result_before_delimiter='<prefix>\n', format_custom_result_after_delimiter='<suffix>'
```

Результат:

```response
┌─formatRow('CustomSeparated', number, 'good')─┐
│ <prefix>
0	good
<suffix>                   │
│ <prefix>
1	good
<suffix>                   │
│ <prefix>
2	good
<suffix>                   │
└──────────────────────────────────────────────┘
```

Примечание: Поддерживаются только строковые форматы в этой функции.
## formatRowNoNewline {#formatrownonewline}

Конвертирует произвольные выражения в строку через заданный формат. Отвечает formatRow, но эта функция обрезает последний `\n`, если он есть.

**Синтаксис**

```sql
formatRowNoNewline(format, x, y, ...)
```

**Аргументы**

- `format` — Текстовый формат. Например, [CSV](/interfaces/formats.md/#csv), [TSV](/interfaces/formats.md/#tabseparated).
- `x`,`y`, ... — Выражения.

**Возвращаемое значение**

- Форматированная строка.

**Пример**

Запрос:

```sql
SELECT formatRowNoNewline('CSV', number, 'good')
FROM numbers(3);
```

Результат:

```response
┌─formatRowNoNewline('CSV', number, 'good')─┐
│ 0,"good"                                  │
│ 1,"good"                                  │
│ 2,"good"                                  │
└───────────────────────────────────────────┘
```

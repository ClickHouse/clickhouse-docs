---
description: 'Документация по функциям массивов'
sidebar_label: 'Массивы'
slug: /sql-reference/functions/array-functions
title: 'Функции массивов'
doc_type: 'reference'
---



# Функции для работы с массивами

<!--
Внутреннее содержимое тегов ниже заменяется во время сборки фреймворка документации
на документацию, сгенерированную из system.functions. Пожалуйста, не изменяйте и не удаляйте теги.
См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## array {#array}

Introduced in: v1.1

Создаёт массив из аргументов функции.

Аргументы должны быть константами и иметь типы с общим супертипом.
Необходимо передать хотя бы один аргумент, поскольку иначе неясно, какой тип массива создавать.
Это означает, что данную функцию нельзя использовать для создания пустого массива. Для этого используйте функцию `emptyArray*`.

Для той же функциональности можно использовать оператор `[ ]`.

**Синтаксис**

```sql
array(x1 [, x2, ..., xN])
```

**Аргументы**

- `x1` — Константное значение любого типа T. Если передан только этот аргумент, массив будет иметь тип T. - `[, x2, ..., xN]` — Дополнительные N константных значений с общим супертипом с `x1`

**Возвращаемое значение**

Возвращает массив, где 'T' — наименьший общий тип из переданных аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Корректное использование**

```sql title=Запрос
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Ответ
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**Некорректное использование**

```sql title=Запрос
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Ответ
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```


## arrayAUCPR {#arrayAUCPR}

Введена в версии: v20.4

Вычисляет площадь под кривой точность-полнота (precision-recall, PR).
Кривая точность-полнота строится путём отображения точности по оси Y и полноты по оси X для всех порогов.
Результирующее значение находится в диапазоне от 0 до 1, при этом более высокое значение указывает на лучшую производительность модели.
PR AUC особенно полезна для несбалансированных наборов данных, обеспечивая более чёткое сравнение производительности по сравнению с ROC AUC в таких случаях.
Для получения дополнительной информации см. [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**Псевдонимы**: `arrayPRAUC`

**Аргументы**

- `scores` — Оценки, выдаваемые моделью прогнозирования. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Enum)`](/sql-reference/data-types/array)
- `partial_offsets` — Необязательный параметр. [`Array(T)`](/sql-reference/data-types/array) из трёх неотрицательных целых чисел для вычисления частичной площади под кривой PR (эквивалентно вертикальной полосе пространства PR) вместо полной AUC. Эта опция полезна для распределённого вычисления PR AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`].
  - `higher_partitions_tp`: Количество положительных меток в разделах с более высокими оценками.
  - `higher_partitions_fp`: Количество отрицательных меток в разделах с более высокими оценками.
  - `total_positives`: Общее количество положительных образцов во всём наборе данных.

:::note
При использовании `arr_partial_offsets` массивы `arr_scores` и `arr_labels` должны представлять собой только раздел всего набора данных, содержащий интервал оценок.
Набор данных должен быть разделён на смежные разделы, где каждый раздел содержит подмножество данных, оценки которых попадают в определённый диапазон.
Например:

- Один раздел может содержать все оценки в диапазоне [0, 0.5).
- Другой раздел может содержать оценки в диапазоне [0.5, 1.0].
:::

**Возвращаемое значение**

Возвращает площадь под кривой точность-полнота (PR). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Результат
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll {#arrayAll}

Введена в версии: v1.1

Возвращает `1`, если лямбда-функция `func(x [, y1, y2, ... yN])` возвращает true для всех элементов. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает true для всех элементов, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Все элементы совпадают**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**Не все элементы совпадают**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg {#arrayAvg}

Введена в версии: v21.1

Возвращает среднее значение элементов исходного массива.

Если указана лямбда-функция `func`, возвращает среднее значение результатов её применения к элементам.

**Синтаксис**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает среднее значение элементов исходного массива или среднее значение результатов применения лямбда-функции, если она указана. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Базовый пример**

```sql title=Запрос
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Результат
2.5
```

**Использование с лямбда-функцией**

```sql title=Запрос
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Результат
6.5
```


## arrayCompact {#arrayCompact}

Introduced in: v20.1

Удаляет последовательные повторяющиеся элементы из массива, включая значения `null`. Порядок значений в результирующем массиве определяется порядком в исходном массиве.

**Синтаксис**

```sql
arrayCompact(arr)
```

**Аргументы**

- `arr` — массив, из которого удаляются дубликаты. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив без повторяющихся значений. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```


## arrayConcat {#arrayConcat}

Введена в версии: v1.1

Объединяет массивы, переданные в качестве аргументов.

**Синтаксис**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**Аргументы**

- `arr1 [, arr2, ... , arrN]` — произвольное количество массивов для объединения. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает единый массив, полученный объединением переданных массивов-аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Результат
[1, 2, 3, 4, 5, 6]
```


## arrayCount {#arrayCount}

Введена в версии: v1.1

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает true.
Если `func` не указана, возвращает количество ненулевых элементов массива.

`arrayCount` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayCount([func, ] arr1, ...)
```

**Аргументы**

- `func` — необязательный параметр. Функция, применяемая к каждому элементу массива(ов). [`Lambda-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1, ..., arrN` — N массивов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество элементов, для которых `func` возвращает true. В противном случае возвращает количество ненулевых элементов массива. [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Результат
5
```


## arrayCumSum {#arrayCumSum}

Введена в версии: v1.1

Возвращает массив частичных (накопительных) сумм элементов исходного массива. Если указана лямбда-функция, сумма вычисляется путём применения лямбды к элементам массива на каждой позиции.

**Синтаксис**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

- `func` — Необязательный параметр. Лямбда-функция, применяемая к элементам массива на каждой позиции. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — Исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — Необязательный параметр. Дополнительные массивы того же размера, передаваемые в качестве аргументов лямбда-функции, если она указана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов исходного массива. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Запрос
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Ответ
[1, 2, 3, 4]
```

**С лямбда-функцией**

```sql title=Запрос
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Ответ
[2, 6, 12]
```


## arrayCumSumNonNegative {#arrayCumSumNonNegative}

Введена в версии: v18.12

Возвращает массив частичных (накопительных) сумм элементов исходного массива, заменяя любую отрицательную накопительную сумму нулём. Если указана лямбда-функция, сумма вычисляется путём применения лямбда-функции к элементам массива на каждой позиции.

**Синтаксис**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

- `func` — Необязательный параметр. Лямбда-функция, применяемая к элементам массива на каждой позиции. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — Исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — Необязательный параметр. Дополнительные массивы того же размера, передаваемые в качестве аргументов лямбда-функции, если она указана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов исходного массива, при этом любая отрицательная накопительная сумма заменяется нулём. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Запрос
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Результат
[1, 2, 0, 1]
```

**С лямбда-функцией**

```sql title=Запрос
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Результат
[2, 0, 6]
```


## arrayDifference {#arrayDifference}

Введена в версии: v1.1

Вычисляет массив разностей между соседними элементами массива.
Первый элемент результирующего массива будет равен 0, второй — `arr[1] - arr[0]`, третий — `arr[2] - arr[1]` и т. д.
Тип элементов результирующего массива определяется правилами вывода типов для операции вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

```sql
arrayDifference(arr)
```

**Аргументы**

- `arr` — массив, для которого вычисляются разности между соседними элементами. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив разностей между соседними элементами массива. [`UInt*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**Пример переполнения из-за типа результата Int64**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct {#arrayDistinct}

Добавлено в версии: v1.1

Возвращает массив, содержащий только уникальные элементы исходного массива.

**Синтаксис**

```sql
arrayDistinct(arr)
```

**Аргументы**

- `arr` — массив, из которого извлекаются уникальные элементы. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, содержащий уникальные элементы. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct {#arrayDotProduct}

Введена в версии: v23.5

Возвращает скалярное произведение двух массивов.

:::note
Размеры двух векторов должны быть одинаковыми. Массивы и кортежи также могут содержать элементы смешанных типов.
:::

**Синтаксис**

```sql
arrayDotProduct(v1, v2)
```

**Аргументы**

- `v1` — первый вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
- `v2` — второй вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**Возвращаемое значение**

Скалярное произведение двух векторов.

:::note
Тип возвращаемого значения определяется типами аргументов. Если массивы или кортежи содержат элементы смешанных типов, то типом результата является супертип.
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)

**Примеры**

**Пример с массивом**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**Пример с кортежем**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement {#arrayElement}

Введено в версии: v1.1

Возвращает элемент массива с индексом `n`, где `n` может быть любым целочисленным типом.
Если индекс выходит за границы массива, возвращается значение по умолчанию (0 для чисел, пустая строка для строк и т. д.),
за исключением случая с аргументами неконстантного массива и константного индекса 0. В этом случае возникнет ошибка `Array indices are 1-based`.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, нумерация которого ведётся с конца. Например, `arr[-1]` — это последний элемент массива.

Оператор `[n]` предоставляет ту же функциональность.

**Синтаксис**

```sql
arrayElement(arr, n)
```

**Аргументы**

- `arr` — Массив. [`Array(T)`](/sql-reference/data-types/array).
- `n` — Позиция элемента. [`(U)Int*`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Элемент массива с указанным индексом. Тип: `T`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Ответ
2
```

**Отрицательная индексация**

```sql title=Запрос
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Ответ
3
```

**Использование нотации [n]**

```sql title=Запрос
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Ответ
2
```

**Индекс за пределами границ массива**

```sql title=Запрос
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Ответ
0
```


## arrayElementOrNull {#arrayElementOrNull}

Введено в версии: v1.1

Возвращает элемент массива с индексом `n`, где `n` может быть любым целочисленным типом.
Если индекс выходит за границы массива, возвращается `NULL` вместо значения по умолчанию.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, нумеруемый с конца. Например, `arr[-1]` — это последний элемент массива.

**Синтаксис**

```sql
arrayElementOrNull(arrays)
```

**Аргументы**

- `arrays` — Массив. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает элемент массива или `NULL`, если индекс выходит за границы. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Результат
2
```

**Отрицательная индексация**

```sql title=Запрос
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Результат
3
```

**Индекс за пределами границ массива**

```sql title=Запрос
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Результат
NULL
```


## arrayEnumerate {#arrayEnumerate}

Введена в версии: v1.1

Возвращает массив `[1, 2, 3, ..., length (arr)]`

Эта функция обычно используется с конструкцией [`ARRAY JOIN`](/sql-reference/statements/select/array-join). Она позволяет выполнить подсчёт только
один раз для каждого массива после применения `ARRAY JOIN`.
Функция также может использоваться в функциях высшего порядка. Например, с её помощью можно получить индексы элементов массива, удовлетворяющих условию.

**Синтаксис**

```sql
arrayEnumerate(arr)
```

**Аргументы**

- `arr` — массив для перечисления. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив `[1, 2, 3, ..., length (arr)]`. [`Array(UInt32)`](/sql-reference/data-types/array)

**Примеры**

**Базовый пример с ARRAY JOIN**

```sql title=Запрос
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Результат
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense {#arrayEnumerateDense}

Introduced in: v18.12

Возвращает массив того же размера, что и исходный массив, с указанием порядкового номера первого появления каждого элемента в исходном массиве.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Аргументы**

- `arr` — массив для нумерации. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же размера, что и `arr`, с указанием порядкового номера первого появления каждого элемента в исходном массиве [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

Введена в версии: v20.1

Возвращает массив того же размера, что и исходный массив, указывая позицию первого появления каждого элемента в исходном массиве. Позволяет выполнять нумерацию многомерного массива с возможностью указать глубину просмотра внутри массива.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

- `clear_depth` — Нумеровать элементы на указанном уровне отдельно. Должно быть меньше или равно `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — N-мерный массив для нумерации. [`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — Максимальная эффективная глубина. Должна быть меньше или равна глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив, указывающий позицию первого появления каждого элемента в исходном массиве [`Array`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
-- При clear_depth=1 и max_array_depth=1 результат идентичен тому, что выдаёт функция arrayEnumerateDense.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**Использование с многомерным массивом**

```sql title=Query
-- В этом примере arrayEnumerateDenseRanked используется для получения массива, указывающего для каждого элемента
-- многомерного массива его позицию среди элементов с тем же значением.
-- Для первой строки переданного массива [10, 10, 30, 20] соответствующая первая строка результата [1, 1, 2, 3]
-- указывает, что 10 — это первое встреченное число в позициях 1 и 2, 30 — второе встреченное число в позиции 3,
-- а 20 — третье встреченное число в позиции 4.
-- Для второй строки [40, 50, 10, 30] соответствующая вторая строка результата [4,5,1,2] указывает, что 40
-- и 50 — это четвёртое и пятое встреченные числа в позициях 1 и 2 этой строки, что ещё одно 10
-- (первое встреченное число) находится в позиции 3, а 30 (второе встреченное число) — в последней позиции.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**Пример с увеличенным clear_depth**

```sql title=Query
-- Изменение clear_depth=2 приводит к тому, что нумерация выполняется отдельно для каждой строки заново.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq {#arrayEnumerateUniq}

Введена в версии: v1.1

Возвращает массив того же размера, что и исходный массив, указывая для каждого элемента его порядковый номер среди элементов с таким же значением.

Функция полезна при использовании `ARRAY JOIN` и агрегации элементов массива.

Функция может принимать несколько массивов одинакового размера в качестве аргументов. В этом случае уникальность определяется для кортежей элементов, находящихся на одинаковых позициях во всех массивах.

**Синтаксис**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**Аргументы**

- `arr1` — первый массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `arr2, ...` — необязательно. Дополнительные массивы того же размера для определения уникальности кортежей. [`Array(UInt32)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, где каждый элемент представляет собой порядковый номер среди элементов с таким же значением или кортежем. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Запрос
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Результат
[1, 1, 2, 1]
```

**Несколько массивов**

```sql title=Запрос
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Результат
[1,2,1,1,2,1]
```

**Агрегация с ARRAY JOIN**

```sql title=Запрос
-- Для каждого идентификатора цели вычисляется количество конверсий (каждый элемент во вложенной структуре данных Goals представляет собой достигнутую цель, которую мы называем конверсией)
-- и количество сессий. Без ARRAY JOIN мы бы подсчитали количество сессий как sum(Sign). Но в данном конкретном случае
-- строки были умножены на вложенную структуру Goals, поэтому чтобы подсчитать каждую сессию только один раз, мы применяем условие к
-- значению функции arrayEnumerateUniq(Goals.ID).

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Результат
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

Добавлена в версии: v20.1

Возвращает массив (или многомерный массив) с теми же размерностями, что и исходный массив,
указывая для каждого элемента его позицию среди элементов с таким же значением.
Функция позволяет выполнять нумерацию многомерного массива с возможностью указать глубину просмотра внутри массива.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

- `clear_depth` — Нумеровать элементы на указанном уровне отдельно. Положительное целое число, меньшее или равное `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — N-мерный массив для нумерации. [`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — Максимальная эффективная глубина. Положительное целое число, меньшее или равное глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает N-мерный массив того же размера, что и `arr`, где каждый элемент показывает позицию этого элемента относительно других элементов с таким же значением. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
-- При clear_depth=1 и max_array_depth=1 результат arrayEnumerateUniqRanked
-- идентичен тому, который дала бы функция arrayEnumerateUniq для того же массива.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**Пример 2**

```sql title=Query
-- При clear_depth=1 и max_array_depth=1 результат arrayEnumerateUniqRanked
-- идентичен тому, который дала бы функция arrayEnumerateUniq для того же массива.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**Пример 3**

```sql title=Query
-- В этом примере arrayEnumerateUniqRanked используется для получения массива, указывающего
-- для каждого элемента многомерного массива его позицию среди элементов
-- с таким же значением. Для первой строки переданного массива [1, 2, 3] соответствующий
-- результат — [1, 1, 1], что указывает на первое появление значений 1, 2 и 3.
-- Для второй строки переданного массива [2, 2, 1] соответствующий результат — [2, 3, 2],
-- что указывает на второе и третье появление значения 2 и второе появление значения 1.
-- Аналогично, для третьей строки переданного массива [3]
-- соответствующий результат — [2], что указывает на второе появление значения 3.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**Пример 4**

```sql title=Query
-- Изменение clear_depth=2 приводит к тому, что элементы нумеруются отдельно для каждой строки.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept {#arrayExcept}

Введена в версии: v25.9

Возвращает массив, содержащий элементы из `source`, которые отсутствуют в `except`, с сохранением исходного порядка.

Функция выполняет операцию разности множеств между двумя массивами. Для каждого элемента в `source` проверяется его наличие в `except` (используется точное сравнение). Если элемент отсутствует, он включается в результат.

Операция обладает следующими свойствами:

1. Порядок элементов из `source` сохраняется
2. Дубликаты в `source` сохраняются, если они отсутствуют в `except`
3. NULL обрабатывается как отдельное значение

**Синтаксис**

```sql
arrayExcept(source, except)
```

**Аргументы**

- `source` — исходный массив, содержащий элементы для фильтрации. [`Array(T)`](/sql-reference/data-types/array)
- `except` — массив, содержащий элементы, которые необходимо исключить из результата. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же типа, что и входной массив, содержащий элементы из `source`, которые не были найдены в `except`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**basic**

```sql title=Запрос
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Результат
[1, 2, 2, 4]
```

**with_nulls1**

```sql title=Запрос
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Результат
[1, NULL, NULL]
```

**with_nulls2**

```sql title=Запрос
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Результат
[1]
```

**strings**

```sql title=Запрос
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Результат
['apple', 'cherry']
```


## arrayExists {#arrayExists}

Введено в версии: v1.1

Возвращает `1`, если в исходном массиве есть хотя бы один элемент, для которого `func(x[, y1, y2, ... yN])` возвращает true. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает true хотя бы для одного элемента, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Результат
0
```


## arrayFill {#arrayFill}

Введена в версии: v20.1

Функция `arrayFill` последовательно обрабатывает исходный массив от первого элемента
до последнего, вычисляя лямбда-условие в каждой позиции с использованием элементов
исходного массива и массивов условий. Когда лямбда-функция возвращает false в
позиции i, функция заменяет этот элемент элементом из позиции i-1
текущего состояния массива. Первый элемент всегда сохраняется
независимо от условия.

**Синтаксис**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x [, y1, ..., yN])` — Лямбда-функция `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`, которая оперирует элементами исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Запрос
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Результат
[1, 1, 2, 2]
```

**Пример с несколькими массивами**

```sql title=Запрос
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Результат
[5, 5, 6, 6]
```


## arrayFilter {#arrayFilter}

Введена в версии: v1.1

Возвращает массив, содержащий только те элементы исходного массива, для которых лямбда-функция возвращает истину.

**Синтаксис**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая оперирует элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает подмножество исходного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Запрос
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Результат
['abc World']
```

**Пример 2**

```sql title=Запрос
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Результат
[2]
```


## arrayFirst {#arrayFirst}

Введена в версии: v1.1

Возвращает первый элемент исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает true, иначе возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — лямбда-функция, которая оперирует элементами исходного массива (`x`) и массивами условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — необязательные параметры. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `λ` истинна, иначе возвращает значение по умолчанию типа `T`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Результат
b
```

**Нет совпадений**

```sql title=Запрос
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Результат
0 UInt8
```


## arrayFirstIndex {#arrayFirstIndex}

Introduced in: v1.1

Возвращает индекс первого элемента в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true, иначе возвращает `0`.

**Синтаксис**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая оперирует элементами исходного массива (`x`) и массивами условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает индекс первого элемента исходного массива, для которого `func` возвращает true, иначе возвращает `0`. [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Результат
2
```

**Нет совпадений**

```sql title=Запрос
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Результат
0
```


## arrayFirstOrNull {#arrayFirstOrNull}

Введена в версии: v1.1

Возвращает первый элемент исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает true, иначе возвращает `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — лямбда-функция, которая оперирует элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `func` возвращает true, иначе возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Результат
b
```

**Нет совпадений**

```sql title=Запрос
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Результат
NULL Nullable(UInt8)
```


## arrayFlatten {#arrayFlatten}

Введена в версии: v20.1

Преобразует массив массивов в плоский массив.

Функция:

- Применяется к вложенным массивам любой глубины.
- Не изменяет массивы, которые уже плоские.

Результирующий плоский массив содержит все элементы из всех исходных массивов.

**Синтаксис**

```sql
arrayFlatten(arr)
```

**Синонимы**: `flatten`

**Аргументы**

- `arr` — Многомерный массив. [`Array(Array(T))`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает плоский массив, полученный из многомерного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Результат
[1, 2, 3]
```


## arrayFold {#arrayFold}

Введена в версии: v23.10

Применяет лямбда-функцию к одному или нескольким массивам одинакового размера и накапливает результат в аккумуляторе.

**Синтаксис**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**Аргументы**

- `λ(x, x1 [, x2, x3, ... xN])` — Лямбда-функция `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`, где `F` — операция, применяемая к `acc` и значениям массива из `x`, результат которой повторно используется в `acc`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1 [, arr2, arr3, ... arrN]` — N массивов, над которыми выполняется операция. [`Array(T)`](/sql-reference/data-types/array)
- `acc` — Начальное значение аккумулятора того же типа, что и возвращаемый тип лямбда-функции.

**Возвращаемое значение**

Возвращает итоговое значение `acc`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Результат
23
```

**Последовательность Фибоначчи**

```sql title=Запрос
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Результат
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**Пример с использованием нескольких массивов**

```sql title=Запрос
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Результат
300
```


## arrayIntersect {#arrayIntersect}

Введена в версии: v1.1

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**Аргументы**

- `arrN` — N массивов, из которых формируется новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив с уникальными элементами, которые присутствуют во всех N массивах. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Результат
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex {#arrayJaccardIndex}

Введена в версии: v23.7

Возвращает [индекс Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) для двух массивов.

**Синтаксис**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**Аргументы**

- `arr_x` — первый массив. [`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — второй массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс Жаккара для массивов `arr_x` и `arr_y`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin {#arrayJoin}

Введена в версии: v1.1

Функция `arrayJoin` принимает строку, содержащую массив, и разворачивает её, создавая несколько строк — по одной для каждого элемента массива.
Это отличается от обычных функций в ClickHouse, которые преобразуют входные значения в выходные в пределах одной строки,
и агрегатных функций, которые принимают группу строк и «сжимают» или «сводят» их в одну итоговую строку
(или одно значение в итоговой строке при использовании с `GROUP BY`).

Все значения в столбцах просто копируются, за исключением значений в столбце, к которому применяется эта функция;
они заменяются соответствующим значением из массива.

**Синтаксис**

```sql
arrayJoin(arr)
```

**Аргументы**

- `arr` — массив для разворачивания. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает набор строк, развёрнутых из `arr`.

**Примеры**

**Базовое использование**

```sql title=Запрос
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Ответ
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin влияет на все секции запроса**

```sql title=Запрос
-- Функция arrayJoin влияет на все секции запроса, включая секцию WHERE. Обратите внимание на результат 2, хотя подзапрос вернул 1 строку.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Ответ
┌─impressions─┐
│           2 │
└─────────────┘
```

**Использование нескольких функций arrayJoin**

```sql title=Запрос
-- Запрос может использовать несколько функций arrayJoin. В этом случае преобразование выполняется несколько раз, и строки умножаются.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Ответ
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**Неожиданные результаты из-за оптимизаций**

```sql title=Запрос
-- Использование нескольких arrayJoin с одним и тем же выражением может не дать ожидаемого результата из-за оптимизаций.
-- В таких случаях рассмотрите возможность изменения повторяющегося выражения массива с помощью дополнительных операций, которые не влияют на результат объединения.
-- например, arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- технически корректно, но уничтожит набор результатов
    arrayJoin(arrayConcat(dice, [])) as second_throw -- выражение намеренно изменено для принудительной повторной оценки
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─первый_бросок─┬─второй_бросок─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└───────────────┴───────────────┘
```

**Использование конструкции ARRAY JOIN**

```sql title=Query
-- Обратите внимание на синтаксис ARRAY JOIN в запросе `SELECT` ниже, который предоставляет более широкие возможности.
-- ARRAY JOIN позволяет одновременно преобразовывать несколько массивов с одинаковым количеством элементов.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Использование кортежа Tuple**

```sql title=Query
-- Также можно использовать Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast {#arrayLast}

Введена в версии: v1.1

Возвращает последний элемент исходного массива, для которого лямбда-функция `func(x [, y1, y2, ... yN])` возвращает true, иначе возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1, ... , condN]` — Необязательно. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого `func` возвращает true, иначе возвращает значение по умолчанию типа `T`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Результат
c
```

**Нет совпадений**

```sql title=Запрос
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Результат
0 UInt8
```


## arrayLastIndex {#arrayLastIndex}

Introduced in: v1.1

Возвращает индекс последнего элемента в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true, иначе возвращает `0`.

**Синтаксис**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая оперирует элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс последнего элемента исходного массива, для которого `func` возвращает true, иначе возвращает `0` [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**Нет совпадений**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull {#arrayLastOrNull}

Введена в версии: v1.1

Возвращает последний элемент исходного массива, для которого лямбда-функция `func(x [, y1, y2, ... yN])` возвращает true, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x [, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого `λ` возвращает true, в противном случае возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Результат
c
```

**Нет совпадений**

```sql title=Запрос
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Результат
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance {#arrayLevenshteinDistance}

Добавлена в версии: v25.4

Вычисляет расстояние Левенштейна между двумя массивами.

**Синтаксис**

```sql
arrayLevenshteinDistance(from, to)
```

**Аргументы**

- `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array).
- `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Результат
1
```


## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

Введена в версии: v25.4

Вычисляет расстояние Левенштейна для двух массивов с заданными весами для каждого элемента.
Количество элементов в массиве и количество весов должны совпадать.

**Синтаксис**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**Аргументы**

- `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array).
- `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array).
- `from_weights` — веса для первого массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — веса для второго массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами с заданными весами для каждого элемента. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Результат
14
```


## arrayMap {#arrayMap}

Introduced in: v1.1

Возвращает массив, полученный из исходных массивов путём применения лямбда-функции к каждому элементу.

**Синтаксис**

```sql
arrayMap(func, arr)
```

**Аргументы**

- `func` — Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — N массивов для обработки. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив из результатов применения лямбда-функции [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**Создание кортежа из элементов различных массивов**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax {#arrayMax}

Введена в версии: v21.1

Возвращает максимальный элемент исходного массива.

Если указана лямбда-функция `func`, возвращает максимальный элемент среди результатов применения лямбда-функции.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает максимальный элемент исходного массива или максимальный элемент среди результатов применения лямбда-функции, если она указана.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin {#arrayMin}

Введена в версии: v21.1

Возвращает минимальный элемент исходного массива.

Если указана лямбда-функция `func`, возвращает минимальный элемент среди результатов применения лямбда-функции.

**Синтаксис**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает минимальный элемент исходного массива или минимальный элемент среди результатов применения лямбда-функции, если она указана.

**Примеры**

**Базовый пример**

```sql title=Запрос
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Ответ
2
```

**Использование с лямбда-функцией**

```sql title=Запрос
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Ответ
4
```


## arrayNormalizedGini {#arrayNormalizedGini}

Введена в версии: v25.1

Вычисляет нормализованный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

- `predicted` — Прогнозируемое значение. [`Array(T)`](/sql-reference/data-types/array)
- `label` — Фактическое значение. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Кортеж, содержащий коэффициент Джини прогнозируемых значений, коэффициент Джини нормализованных значений и нормализованный коэффициент Джини (= отношение двух предыдущих коэффициентов Джини) [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Результат
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort {#arrayPartialReverseSort}

Добавлена в версии: v23.2

Эта функция работает так же, как `arrayReverseSort`, но с дополнительным аргументом `limit`, позволяющим выполнять частичную сортировку.

:::tip
Чтобы оставить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

- `f(arr[, arr1, ... ,arrN])` — Лямбда-функция, применяемая к элементам массива `x`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — Сортируемый массив. [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — N дополнительных массивов (в случае, когда `f` принимает несколько аргументов). [`Array(T)`](/sql-reference/data-types/array)
- `limit` — Индекс, до которого выполняется сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный, где элементы в диапазоне `[1..limit]` отсортированы
в порядке убывания. Остальные элементы `(limit..N]` находятся в неопределённом порядке.

**Примеры**

**simple_int**

```sql title=Запрос
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Результат
[9, 5, 1, 3]
```

**simple_string**

```sql title=Запрос
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Результат
['lasso','gladly','expenses','embolism']
```

**retain_sorted**

```sql title=Запрос
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Результат
[9, 5]
```

**lambda_simple**

```sql title=Запрос
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Результат
[1, 3, 5, 9]
```

**lambda_complex**

```sql title=Запрос
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Результат
[0, 1, 2]
```


## arrayPartialShuffle {#arrayPartialShuffle}

Добавлено в версии: v23.2

Возвращает массив того же размера, что и исходный массив, где элементы в диапазоне `[1..limit]` представляют собой случайное
подмножество исходного массива. Оставшиеся элементы `(limit..n]` содержат элементы, не входящие в диапазон `[1..limit]`, в неопределённом порядке.
Значение limit должно находиться в диапазоне `[1..n]`. Значения за пределами этого диапазона эквивалентны выполнению полного `arrayShuffle`:

:::note
Эта функция не материализует константы.

Значение `limit` должно находиться в диапазоне `[1..N]`. Значения за пределами этого диапазона эквивалентны выполнению полного [`arrayShuffle`](#arrayShuffle).
:::

**Синтаксис**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**Аргументы**

- `arr` — массив для перемешивания. [`Array(T)`](/sql-reference/data-types/array)
- `seed` — необязательный параметр. Начальное значение для генератора случайных чисел. Если не указано, используется случайное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `limit` — необязательный параметр. Количество элементов для перемешивания, в диапазоне `[1..N]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с частично перемешанными элементами. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**no_limit1**

```sql title=Запрос
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Результат
[2, 4, 3, 1]
```

**no_limit2**

```sql title=Запрос
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Результат
[4, 1, 3, 2]
```

**random_seed**

```sql title=Запрос
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Результат
[3, 4, 1, 2]
```

**explicit_seed**

```sql title=Запрос
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Результат
[3, 2, 1, 4]
```

**materialize**

```sql title=Запрос
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Результат
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort {#arrayPartialSort}

Введена в версии: v23.2

Эта функция работает так же, как `arraySort`, но с дополнительным аргументом `limit`, позволяющим выполнять частичную сортировку.

:::tip
Чтобы оставить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

- `f(arr[, arr1, ... ,arrN])` — Лямбда-функция, применяемая к элементам массива `x`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — Сортируемый массив. [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — N дополнительных массивов для случая, когда `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array)
- `limit` — Индекс, до которого выполняется сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, в котором элементы в диапазоне `[1..limit]` отсортированы
по возрастанию. Остальные элементы `(limit..N]` находятся в неопределённом порядке.

**Примеры**

**simple_int**

```sql title=Запрос
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Результат
[1, 3, 5, 9]
```

**simple_string**

```sql title=Запрос
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Результат
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain_sorted**

```sql title=Запрос
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Результат
[1, 3]
```

**lambda_simple**

```sql title=Запрос
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Результат
[9, 5, 1, 3]
```

**lambda_complex**

```sql title=Запрос
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Результат
[2, 1, 0]
```


## arrayPopBack {#arrayPopBack}

Introduced in: v1.1

Удаляет последний элемент массива.

**Синтаксис**

```sql
arrayPopBack(arr)
```

**Аргументы**

- `arr` — Массив, из которого удаляется последний элемент. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но без последнего элемента. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Результат
[1, 2]
```


## arrayPopFront {#arrayPopFront}

Введена в версии: v1.1

Удаляет первый элемент массива.

**Синтаксис**

```sql
arrayPopFront(arr)
```

**Аргументы**

- `arr` — массив, из которого удаляется первый элемент. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но без первого элемента. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Результат
[2, 3]
```


## arrayProduct {#arrayProduct}

Введена в версии: v21.1

Возвращает произведение элементов исходного массива.

Если указана лямбда-функция `func`, возвращает произведение элементов результатов лямбда-функции.

**Синтаксис**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает произведение элементов исходного массива или произведение элементов результатов лямбда-функции, если она указана. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack {#arrayPushBack}

Добавлено в версии: v1.1

Добавляет один элемент в конец массива.

**Синтаксис**

```sql
arrayPushBack(arr, x)
```

**Аргументы**

- `arr` — Массив, в конец которого добавляется значение `x`. [`Array(T)`](/sql-reference/data-types/array)
- `x` — Значение, добавляемое в конец массива. [`Array(T)`](/sql-reference/data-types/array).

:::note

- В массив чисел можно добавлять только числа, а в массив строк — только строки.
- При добавлении чисел ClickHouse автоматически приводит тип `x` к типу данных массива.
- Может принимать значение `NULL`. Функция добавляет элемент `NULL` в массив, при этом тип элементов массива преобразуется в `Nullable`.

Подробнее о типах данных в ClickHouse см. в разделе [Типы данных](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, с добавленным значением `x` в конце. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Результат
['a','b']
```


## arrayPushFront {#arrayPushFront}

Введена в версии: v1.1

Добавляет один элемент в начало массива.

**Синтаксис**

```sql
arrayPushFront(arr, x)
```

**Аргументы**

- `arr` — массив, в начало которого добавляется значение `x`. [`Array(T)`](/sql-reference/data-types/array).
- `x` — значение, добавляемое в начало массива. [`Array(T)`](/sql-reference/data-types/array).

:::note

- В массив чисел можно добавлять только числа, а в массив строк — только строки.
- При добавлении чисел ClickHouse автоматически приводит тип `x` к типу данных массива.
- Может принимать значение `NULL`. Функция добавляет элемент `NULL` в массив, при этом тип элементов массива преобразуется в `Nullable`.

Подробнее о типах данных в ClickHouse см. в разделе [Типы данных](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с дополнительным значением `x` в начале. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Результат
['a','b']
```


## arrayROCAUC {#arrayROCAUC}

Введена в версии: v20.4

Вычисляет площадь под ROC-кривой (кривой ошибок классификации).
ROC-кривая строится путём отображения доли истинно положительных результатов (TPR) по оси Y и доли ложноположительных результатов (FPR) по оси X для всех порогов классификации.
Результирующее значение находится в диапазоне от нуля до единицы, при этом более высокое значение указывает на лучшую производительность модели.

ROC AUC (также известная как AUC) — это концепция машинного обучения.
Для получения дополнительной информации см. [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**Псевдонимы**: `arrayAUC`

**Аргументы**

- `scores` — Оценки, выдаваемые моделью прогнозирования. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Enum`](/sql-reference/data-types/enum)
- `scale` — Необязательный параметр. Определяет, возвращать ли нормализованную площадь. Если false, вместо этого возвращается площадь под кривой TP (истинно положительные) × FP (ложноположительные). Значение по умолчанию: true. [`Bool`](/sql-reference/data-types/boolean)
- `partial_offsets` —
- Массив из четырёх неотрицательных целых чисел для вычисления частичной площади под ROC-кривой (эквивалентно вертикальной полосе ROC-пространства) вместо полной AUC. Эта опция полезна для распределённого вычисления ROC AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) неотрицательных [целых чисел](../data-types/int-uint.md). Необязательный параметр.
  - `higher_partitions_tp`: Количество положительных меток в разделах с более высокими оценками.
  - `higher_partitions_fp`: Количество отрицательных меток в разделах с более высокими оценками.
  - `total_positives`: Общее количество положительных образцов во всём наборе данных.
  - `total_negatives`: Общее количество отрицательных образцов во всём наборе данных.

:::note
При использовании `arr_partial_offsets` параметры `arr_scores` и `arr_labels` должны представлять собой только раздел всего набора данных, содержащий интервал оценок.
Набор данных должен быть разделён на смежные разделы, где каждый раздел содержит подмножество данных, оценки которых попадают в определённый диапазон.
Например:

- Один раздел может содержать все оценки в диапазоне [0, 0.5).
- Другой раздел может содержать оценки в диапазоне [0.5, 1.0].
:::

**Возвращаемое значение**

Возвращает площадь под ROC-кривой (кривой ошибок классификации). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Результат
0.75
```


## arrayRandomSample {#arrayRandomSample}

Введена в версии: v23.10

Возвращает подмножество из `samples` случайных элементов входного массива. Если значение `samples` превышает размер входного массива, размер выборки ограничивается размером массива, т. е. возвращаются все элементы массива, но их порядок не гарантируется. Функция может обрабатывать как одномерные, так и вложенные массивы.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

- `arr` — входной одномерный или многомерный массив, из которого выбираются элементы. [`Array(T)`](/sql-reference/data-types/array)
- `samples` — количество элементов для включения в случайную выборку. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив, содержащий случайную выборку элементов из входного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Результат
['cherry','apple']
```

**Использование многомерного массива**

```sql title=Запрос
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Результат
[[3,4],[5,6]]
```


## arrayReduce {#arrayReduce}

Введена в версии: v1.1

Применяет агрегатную функцию к элементам массива и возвращает её результат.
Имя агрегатной функции передаётся в виде строки в одинарных кавычках `'max'`, `'sum'`.
При использовании параметрических агрегатных функций параметр указывается после имени функции в круглых скобках `'uniqUpTo(6)'`.

**Синтаксис**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**Аргументы**

- `agg_f` — имя агрегатной функции, которое должно быть константой. [`String`](/sql-reference/data-types/string)
- `arr1 [, arr2, ... , arrN)]` — N массивов, соответствующих аргументам `agg_f`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает результат агрегатной функции.

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Результат
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**Пример с агрегатной функцией, принимающей несколько аргументов**

```sql title=Запрос
--Если агрегатная функция принимает несколько аргументов, то функция должна применяться к нескольким массивам одинакового размера.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Результат
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**Пример с параметрической агрегатной функцией**

```sql title=Запрос
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Результат
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges {#arrayReduceInRanges}

Введена в версии: v20.4

Применяет агрегатную функцию к элементам массива в заданных диапазонах и возвращает массив с результатами, соответствующими каждому диапазону.
Функция возвращает тот же результат, что и множественные вызовы `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**Аргументы**

- `agg_f` — имя агрегатной функции. [`String`](/sql-reference/data-types/string)
- `ranges` — диапазоны для агрегирования. Массив кортежей `(i, r)`, где `i` — индекс начала диапазона, а `r` — длина диапазона для агрегирования. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T)`](/sql-reference/data-types/tuple)
- `arr1 [, arr2, ... ,arrN)]` — N массивов в качестве аргументов агрегатной функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с результатами агрегатной функции для указанных диапазонов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Ответ
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove {#arrayRemove}

Введена в версии: v25.11

Удаляет из массива все элементы, равные заданному значению.
Значения NULL считаются равными.

**Синтаксис**

```sql
arrayRemove(arr, elem)
```

**Псевдонимы**: `array_remove`

**Аргументы**

- `arr` — Array(T) - `elem` — T

**Возвращаемое значение**

Возвращает подмножество исходного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**Пример 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```


## arrayResize {#arrayResize}

Введена в версии: v1.1

Изменяет длину массива.

**Синтаксис**

```sql
arrayResize(arr, size[, extender])
```

**Аргументы**

- `arr` — массив, размер которого нужно изменить. [`Array(T)`](/sql-reference/data-types/array)
- `size` — новая длина массива.
  Если `size` меньше исходного размера массива, массив обрезается справа.
  Если `size` больше исходного размера массива, массив расширяется справа значениями `extender` или значениями по умолчанию для типа данных элементов массива.
- `extender` — значение, используемое для расширения массива. Может быть `NULL`.

**Возвращаемое значение**

Массив длиной `size`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Запрос
SELECT arrayResize([1], 3);
```

```response title=Результат
[1,0,0]
```

**Пример 2**

```sql title=Запрос
SELECT arrayResize([1], 3, NULL);
```

```response title=Результат
[1,NULL,NULL]
```


## arrayReverse {#arrayReverse}

Добавлена в версии: v1.1

Переворачивает порядок элементов заданного массива.

:::note
Функция `reverse(arr)` выполняет ту же операцию, но также работает с другими типами данных
помимо массивов.
:::

**Синтаксис**

```sql
arrayReverse(arr)
```

**Аргументы**

- `arr` — массив для переворачивания. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный, содержащий элементы в обратном порядке. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill {#arrayReverseFill}

Введена в версии: v20.1

Функция `arrayReverseFill` последовательно обрабатывает исходный массив от последнего
элемента к первому, вычисляя лямбда-условие в каждой позиции с использованием элементов
из исходного массива и массивов условий. Когда условие возвращает false в
позиции i, функция заменяет этот элемент элементом из позиции i+1
текущего состояния массива. Последний элемент всегда сохраняется
независимо от условия.

**Синтаксис**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с элементами исходного массива, замененными результатами работы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Запрос
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Результат
[1, 2, 2, NULL]
```

**Пример с двумя массивами**

```sql title=Запрос
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Результат
[5, 6, 6, 2]
```


## arrayReverseSort {#arrayReverseSort}

Введено в версии: v1.1

Сортирует элементы массива в порядке убывания.
Если указана функция `f`, переданный массив сортируется в соответствии с результатом
применения функции к элементам массива, после чего отсортированный массив переворачивается.
Если `f` принимает несколько аргументов, функции `arrayReverseSort` передаётся несколько массивов,
которые будут соответствовать аргументам `func`.

Если сортируемый массив содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**Аргументы**

- `f(y1[, y2 ... yN])` — Лямбда-функция, применяемая к элементам массива `x`. - `arr` — Массив для сортировки. [`Array(T)`](/sql-reference/data-types/array) - `arr1, ..., yN` — Необязательно. N дополнительных массивов в случае, когда `f` принимает несколько аргументов.

**Возвращаемое значение**

Возвращает массив `x`, отсортированный в порядке убывания, если лямбда-функция не указана, в противном случае
возвращает массив, отсортированный в соответствии с логикой переданной лямбда-функции, а затем перевёрнутый. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Запрос
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Ответ
[5,3,4]
```

**Пример 2**

```sql title=Запрос
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Ответ
[4,3,5]
```


## arrayReverseSplit {#arrayReverseSplit}

Введена в версии: v20.1

Разделяет исходный массив на несколько массивов. Когда `func(x[, y1, ..., yN])` возвращает ненулевое значение, массив разделяется справа от элемента. Массив не разделяется после последнего элемента.

**Синтаксис**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив массивов. [`Array(Array(T))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Ответ
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft {#arrayRotateLeft}

Введено в версии: v23.8

Циклически сдвигает массив влево на указанное количество элементов. Отрицательные значения `n` интерпретируются как сдвиг вправо на абсолютное значение.

**Синтаксис**

```sql
arrayRotateLeft(arr, n)
```

**Аргументы**

- `arr` — Массив, элементы которого нужно сдвинуть. [`Array(T)`](/sql-reference/data-types/array).
- `n` — Количество позиций для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, циклически сдвинутый влево на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Результат
[3,4,5,6,1,2]
```

**Отрицательное значение n**

```sql title=Запрос
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Результат
[5,6,1,2,3,4]
```


## arrayRotateRight {#arrayRotateRight}

Введено в версии: v23.8

Циклически сдвигает массив вправо на указанное количество элементов. Отрицательные значения `n` интерпретируются как циклический сдвиг влево на абсолютное значение.

**Синтаксис**

```sql
arrayRotateRight(arr, n)
```

**Аргументы**

- `arr` — Массив, элементы которого нужно сдвинуть. [`Array(T)`](/sql-reference/data-types/array).
- `n` — Количество позиций для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, циклически сдвинутый вправо на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```


## arrayShiftLeft {#arrayShiftLeft}

Добавлено в версии: v23.8

Сдвигает массив влево на указанное количество элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элементов массива.
Если количество элементов отрицательное, массив сдвигается вправо.

**Синтаксис**

```sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

- `arr` — Массив, элементы которого нужно сдвинуть. [`Array(T)`](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).
- `default` — Необязательный параметр. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

Массив, сдвинутый влево на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Результат
[3,4,5,6,0,0]
```

**Отрицательное значение n**

```sql title=Запрос
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Результат
[0,0,1,2,3,4]
```

**Использование значения по умолчанию**

```sql title=Запрос
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Результат
[3,4,5,6,42,42]
```


## arrayShiftRight {#arrayShiftRight}

Добавлено в версии: v23.8

Сдвигает массив вправо на указанное количество элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию типа элементов массива.
Если количество элементов отрицательное, массив сдвигается влево.

**Синтаксис**

```sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

- `arr` — массив, элементы которого нужно сдвинуть. [`Array(T)`](/sql-reference/data-types/array)
- `n` — количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `default` — необязательный параметр. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

Массив, сдвинутый вправо на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Результат
[0, 0, 1, 2, 3, 4]
```

**Отрицательное значение n**

```sql title=Запрос
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Результат
[3, 4, 5, 6, 0, 0]
```

**Использование значения по умолчанию**

```sql title=Запрос
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Результат
[42, 42, 1, 2, 3, 4]
```


## arrayShingles {#arrayShingles}

Введена в версии: v24.1

Генерирует массив шинглов (аналогично n-граммам для строк), т. е. последовательные подмассивы указанной длины из входного массива.

**Синтаксис**

```sql
arrayShingles(arr, l)
```

**Аргументы**

- `arr` — массив, для которого генерируется массив шинглов. [`Array(T)`](/sql-reference/data-types/array)
- `l` — длина каждого шингла. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив сгенерированных шинглов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Результат
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle {#arrayShuffle}

Добавлено в версии: v23.2

Возвращает массив того же размера, что и исходный массив, с элементами в случайном порядке.
Элементы переупорядочиваются таким образом, что каждая возможная перестановка имеет одинаковую вероятность.

:::note
Эта функция не материализует константы.
:::

**Синтаксис**

```sql
arrayShuffle(arr [, seed])
```

**Аргументы**

- `arr` — Массив для перемешивания. [`Array(T)`](/sql-reference/data-types/array)
- `seed (optional)` — Необязательный параметр. Начальное значение (seed) для генератора случайных чисел. Если не указано, используется случайное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с перемешанными элементами [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример без начального значения (нестабильные результаты)**

```sql title=Запрос
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Результат
[1,4,2,3]
```

**Пример с начальным значением (стабильные результаты)**

```sql title=Запрос
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Результат
[3,2,1,4]
```


## arraySimilarity {#arraySimilarity}

Введено в версии: v25.4

Вычисляет степень сходства двух массивов в диапазоне от `0` до `1` на основе взвешенного расстояния Левенштейна.

**Синтаксис**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**Аргументы**

- `from` — первый массив [`Array(T)`](/sql-reference/data-types/array)
- `to` — второй массив [`Array(T)`](/sql-reference/data-types/array)
- `from_weights` — веса для первого массива [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — веса для второго массива [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает степень сходства двух массивов в диапазоне от `0` до `1` на основе взвешенного расстояния Левенштейна [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Результат
0.2222222222222222
```


## arraySlice {#arraySlice}

Добавлено в версии: v1.1

Возвращает срез массива, включая элементы `NULL`.

**Синтаксис**

```sql
arraySlice(arr, offset [, length])
```

**Аргументы**

- `arr` — массив для получения среза. [`Array(T)`](/sql-reference/data-types/array)
- `offset` — смещение от края массива. Положительное значение задает смещение слева, отрицательное — справа. Нумерация элементов массива начинается с `1`. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `length` — длина требуемого среза. Если указано отрицательное значение, функция возвращает открытый срез `[offset, array_length - length]`. Если значение опущено, функция возвращает срез `[offset, the_end_of_array]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Срез массива из `length` элементов, начиная с указанного смещения `offset`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Результат
[2, NULL, 4]
```


## arraySort {#arraySort}

Введено в версии: v1.1

Сортирует элементы переданного массива в порядке возрастания.
Если указана лямбда-функция `f`, порядок сортировки определяется результатом
применения лямбда-функции к каждому элементу массива.
Если лямбда-функция принимает несколько аргументов, в функцию `arraySort` передаётся несколько
массивов, которым будут соответствовать аргументы `f`.

Если сортируемый массив содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**Аргументы**

- `f(y1[, y2 ... yN])` — Лямбда-функция, применяемая к элементам массива `x`.
- `arr` — Массив для сортировки. [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ..., yN` — Необязательно. N дополнительных массивов в случае, когда `f` принимает несколько аргументов.

**Возвращаемое значение**

Возвращает массив `arr`, отсортированный в порядке возрастания, если лямбда-функция не указана, в противном случае
возвращает массив, отсортированный в соответствии с логикой переданной лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Запрос
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Результат
[0,1,3,3]
```

**Пример 2**

```sql title=Запрос
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Результат
['!','hello','world']
```

**Пример 3**

```sql title=Запрос
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Результат
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit {#arraySplit}

Введена в версии: v20.1

Разделяет исходный массив на несколько массивов. Когда `func(x [, y1, ..., yN])` возвращает ненулевое значение, массив разделяется слева от элемента. Массив не разделяется перед первым элементом.

**Синтаксис**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — лямбда-функция, которая оперирует элементами исходного массива (`x`) и массивами условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — исходный массив для разделения [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив массивов [`Array(Array(T))`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Ответ
[[1, 2, 3], [4, 5]]
```


## arraySum {#arraySum}

Введено в версии: v21.1

Возвращает сумму элементов исходного массива.

Если указана лямбда-функция `func`, возвращает сумму результатов применения лямбда-функции к элементам массива.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ... , condN_arr` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает сумму элементов исходного массива или сумму результатов применения лямбда-функции, если она указана.

**Примеры**

**Базовый пример**

```sql title=Запрос
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Ответ
10
```

**Использование с лямбда-функцией**

```sql title=Запрос
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Ответ
8
```


## arraySymmetricDifference {#arraySymmetricDifference}

Введена в версии: v25.4

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют не во всех исходных массивах. Результат содержит только уникальные значения.

:::note
Симметрическая разность _более чем двух множеств_ [математически определяется](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)
как множество всех входных элементов, которые встречаются в нечётном количестве входных множеств.
В отличие от этого определения, функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые присутствуют не во всех входных множествах.
:::

**Синтаксис**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**Аргументы**

- `arrN` — N массивов, из которых формируется новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив уникальных элементов, которые присутствуют не во всех исходных массивах [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion {#arrayUnion}

Введена в версии: v24.10

Принимает несколько массивов и возвращает массив, содержащий все элементы, которые присутствуют хотя бы в одном из исходных массивов. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — N массивов, из которых формируется новый массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с уникальными элементами из исходных массивов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Результат
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq {#arrayUniq}

Введена в версии: v1.1

При передаче одного аргумента подсчитывает количество различных элементов в массиве.
При передаче нескольких аргументов подсчитывает количество различных **кортежей**, образованных из элементов на соответствующих позициях в нескольких массивах.

Например, `SELECT arrayUniq([1,2], [3,4], [5,6])` сформирует следующие кортежи:

- Позиция 1: (1,3,5)
- Позиция 2: (2,4,6)

Затем будет подсчитано количество уникальных кортежей. В данном случае — `2`.

Все переданные массивы должны иметь одинаковую длину.

:::tip
Если необходимо получить список уникальных элементов в массиве, можно использовать `arrayReduce('groupUniqArray', arr)`.
:::

**Синтаксис**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**Аргументы**

- `arr1` — массив, для которого подсчитывается количество уникальных элементов. [`Array(T)`](/sql-reference/data-types/array)
- `[, arr2, ..., arrN]` — необязательные дополнительные массивы, используемые для подсчета количества уникальных кортежей элементов на соответствующих позициях в нескольких массивах. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Для одного аргумента возвращает количество уникальных элементов. Для нескольких аргументов возвращает количество уникальных кортежей, образованных из элементов на соответствующих позициях в массивах.
[`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Один аргумент**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**Несколько аргументов**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```


## arrayWithConstant {#arrayWithConstant}

Введена в версии: v20.1

Создаёт массив длиной `length`, заполненный константой `x`.

**Синтаксис**

```sql
arrayWithConstant(N, x)
```

**Аргументы**

- `length` — Количество элементов в массиве. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `x` — Значение элементов массива, любого типа.

**Возвращаемое значение**

Возвращает массив из `N` элементов со значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayWithConstant(3, 1)
```

```response title=Результат
[1, 1, 1]
```


## arrayZip {#arrayZip}

Introduced in: v20.1

Объединяет несколько массивов в один. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в порядке перечисления аргументов.

**Синтаксис**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**Аргументы**

- `arr1, arr2, ... , arrN` — N массивов для объединения в один. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с элементами из исходных массивов, сгруппированными в кортежи. Типы данных в кортеже совпадают с типами входных массивов и следуют в том же порядке, в котором переданы массивы. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Результат
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned {#arrayZipUnaligned}

Introduced in: v20.1

Объединяет несколько массивов в один массив, допуская массивы разной длины. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в порядке перечисления аргументов.

**Синтаксис**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arr1, arr2, ..., arrN` — N массивов для объединения в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с элементами из исходных массивов, сгруппированными в кортежи. Типы данных в кортеже совпадают с типами входных массивов и следуют в том же порядке, в котором переданы массивы. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual {#countEqual}

Введена в версии: v1.1

Возвращает количество элементов массива, равных `x`. Эквивалентна `arrayCount(elem -> elem = x, arr)`.

Элементы `NULL` обрабатываются как отдельные значения.

**Синтаксис**

```sql
countEqual(arr, x)
```

**Аргументы**

- `arr` — массив для поиска. [`Array(T)`](/sql-reference/data-types/array)
- `x` — значение для подсчёта в массиве. Любой тип.

**Возвращаемое значение**

Количество элементов массива, равных `x`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Результат
2
```


## empty {#empty}

Введено в версии: v1.1

Проверяет, является ли входной массив пустым.

Массив считается пустым, если он не содержит ни одного элемента.

:::note
Может быть оптимизирована путём включения настройки [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подстолбец [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всего столбца массива. Запрос `SELECT empty(arr) FROM TABLE;` преобразуется в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает для строк (String) и UUID.

**Синтаксис**

```sql
empty(arr)
```

**Аргументы**

- `arr` — входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для пустого массива или `0` для непустого массива. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate {#emptyArrayDate}

Введена в версии: v1.1

Возвращает пустой массив типа Date.

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив типа Date. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayDate
```

```response title=Результат
[]
```


## emptyArrayDateTime {#emptyArrayDateTime}

Введена в версии: v1.1

Возвращает пустой массив DateTime

**Синтаксис**

```sql
emptyArrayDateTime()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив DateTime. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayDateTime
```

```response title=Результат
[]
```


## emptyArrayFloat32 {#emptyArrayFloat32}

Введена в версии: v1.1

Возвращает пустой массив Float32.

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

- Нет.

**Возвращаемое значение**

Пустой массив Float32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayFloat32
```

```response title=Ответ
[]
```


## emptyArrayFloat64 {#emptyArrayFloat64}

Добавлена в версии: v1.1

Возвращает пустой массив типа Float64.

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив типа Float64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayFloat64
```

```response title=Результат
[]
```


## emptyArrayInt16 {#emptyArrayInt16}

Введена в версии: v1.1

Возвращает пустой массив Int16

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

- Нет.

**Возвращаемое значение**

Пустой массив Int16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayInt16
```

```response title=Результат
[]
```


## emptyArrayInt32 {#emptyArrayInt32}

Добавлена в версии: v1.1

Возвращает пустой массив типа Int32.

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив типа Int32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayInt32
```

```response title=Результат
[]
```


## emptyArrayInt64 {#emptyArrayInt64}

Введена в версии: v1.1

Возвращает пустой массив Int64

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив Int64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayInt64
```

```response title=Результат
[]
```


## emptyArrayInt8 {#emptyArrayInt8}

Введена в версии: v1.1

Возвращает пустой массив Int8

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив Int8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayInt8
```

```response title=Результат
[]
```


## emptyArrayString {#emptyArrayString}

Введена в версии: v1.1

Возвращает пустой массив строк.

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив строк. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayString
```

```response title=Результат
[]
```


## emptyArrayToSingle {#emptyArrayToSingle}

Добавлено в версии: v1.1

Принимает пустой массив и возвращает одноэлементный массив со значением по умолчанию.

**Синтаксис**

```sql
emptyArrayToSingle(arr)
```

**Аргументы**

- `arr` — пустой массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив с одним элементом типа по умолчанию для данного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовый пример**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16 {#emptyArrayUInt16}

Введена в версии: v1.1

Возвращает пустой массив UInt16.

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив UInt16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayUInt16
```

```response title=Результат
[]
```


## emptyArrayUInt32 {#emptyArrayUInt32}

Добавлена в версии: v1.1

Возвращает пустой массив UInt32.

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив UInt32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayUInt32
```

```response title=Результат
[]
```


## emptyArrayUInt64 {#emptyArrayUInt64}

Введена в версии: v1.1

Возвращает пустой массив типа UInt64

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив типа UInt64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayUInt64
```

```response title=Ответ
[]
```


## emptyArrayUInt8 {#emptyArrayUInt8}

Добавлена в версии: v1.1

Возвращает пустой массив типа UInt8.

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

- Отсутствуют.

**Возвращаемое значение**

Пустой массив типа UInt8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT emptyArrayUInt8
```

```response title=Ответ
[]
```


## has {#has}

Introduced in: v1.1

Проверяет, содержит ли массив указанный элемент.

**Синтаксис**

```sql
has(arr, x)
```

**Аргументы**

- `arr` — исходный массив. [`Array(T)`](/sql-reference/data-types/array)
- `x` — искомое значение.

**Возвращаемое значение**

Возвращает `1`, если массив содержит указанный элемент, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Запрос
SELECT has([1, 2, 3], 2)
```

```response title=Результат
1
```

**Элемент не найден**

```sql title=Запрос
SELECT has([1, 2, 3], 4)
```

```response title=Результат
0
```


## hasAll {#hasAll}

Введено в версии: v1.1

Проверяет, является ли один массив подмножеством другого.

- Пустой массив является подмножеством любого массива.
- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Синтаксис**

```sql
hasAll(set, subset)
```

**Аргументы**

- `set` — Массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
- `subset` — Массив любого типа, имеющий общий супертип с `set`, содержащий элементы, которые должны быть проверены на то, являются ли они подмножеством `set`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

- `1`, если `set` содержит все элементы из `subset`.
- `0` в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы set и subset не имеют общего супертипа.

**Примеры**

**Пустые массивы**

```sql title=Запрос
SELECT hasAll([], [])
```

```response title=Результат
1
```

**Массивы, содержащие значения NULL**

```sql title=Запрос
SELECT hasAll([1, Null], [Null])
```

```response title=Результат
1
```

**Массивы, содержащие значения разных типов**

```sql title=Запрос
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Результат
1
```

**Массивы, содержащие строковые значения**

```sql title=Запрос
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Результат
1
```

**Массивы без общего типа**

```sql title=Запрос
SELECT hasAll([1], ['a'])
```

```response title=Результат
Вызывает исключение NO_COMMON_TYPE
```

**Массив массивов**

```sql title=Запрос
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Результат
0
```


## hasAny {#hasAny}

Введена в версии: v1.1

Проверяет, имеют ли два массива пересечение по каким-либо элементам.

- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Синтаксис**

```sql
hasAny(arr_x, arr_y)
```

**Аргументы**

- `arr_x` — Массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — Массив любого типа, имеющий общий супертип с массивом `arr_x`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

- `1`, если `arr_x` и `arr_y` имеют хотя бы один общий элемент.
- `0` в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы двух массивов не имеют общего супертипа.

**Примеры**

**Один массив пустой**

```sql title=Запрос
SELECT hasAny([1], [])
```

```response title=Результат
0
```

**Массивы, содержащие значения NULL**

```sql title=Запрос
SELECT hasAny([Null], [Null, 1])
```

```response title=Результат
1
```

**Массивы, содержащие значения разных типов**

```sql title=Запрос
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Результат
1
```

**Массивы без общего типа**

```sql title=Запрос
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Результат
Вызывает исключение `NO_COMMON_TYPE`
```

**Массив массивов**

```sql title=Запрос
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Результат
1
```


## hasSubstr {#hasSubstr}

Введена в версии: v20.6

Проверяет, присутствуют ли все элементы массива array2 в массиве array1 в том же самом порядке.
Таким образом, функция возвращает `1` тогда и только тогда, когда array1 = prefix + array2 + suffix.

Другими словами, функция проверяет, содержатся ли все элементы array2 в array1, как это делает функция `hasAll`.
Кроме того, она проверяет, что элементы следуют в одинаковом порядке как в array1, так и в array2.

- Функция возвращает `1`, если array2 пуст.
- `Null` обрабатывается как значение. Другими словами, `hasSubstr([1, 2, NULL, 3, 4], [2,3])` вернёт `0`. Однако `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` вернёт `1`
- Порядок значений в обоих массивах имеет значение.

Вызывает исключение `NO_COMMON_TYPE`, если элементы двух массивов не имеют общего супертипа.

**Синтаксис**

```sql
hasSubstr(arr1, arr2)
```

**Аргументы**

- `arr1` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
- `arr2` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если массив `arr1` содержит массив `arr2`. В противном случае возвращает `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Оба массива пусты**

```sql title=Запрос
SELECT hasSubstr([], [])
```

```response title=Результат
1
```

**Массивы, содержащие значения NULL**

```sql title=Запрос
SELECT hasSubstr([1, Null], [Null])
```

```response title=Результат
1
```

**Массивы, содержащие значения разных типов**

```sql title=Запрос
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Результат
0
```

**Массивы, содержащие строки**

```sql title=Запрос
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Результат
1
```

**Массивы с правильным порядком**

```sql title=Запрос
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Результат
1
```

**Массивы с неправильным порядком**

```sql title=Запрос
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Результат
0
```

**Массив массивов**

```sql title=Запрос
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Результат
1
```

**Массивы без общего типа**

```sql title=Запрос
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Результат
Вызывает исключение `NO_COMMON_TYPE`
```


## indexOf {#indexOf}

Introduced in: v1.1

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он находится в массиве.
Если массив не содержит искомое значение, функция возвращает `0`.

Элементы со значением `NULL` обрабатываются как обычные значения.

**Синтаксис**

```sql
indexOf(arr, x)
```

**Аргументы**

- `arr` — Массив для поиска `x`. [`Array(T)`](/sql-reference/data-types/array)
- `x` — Значение искомого элемента в `arr`, для которого возвращается индекс. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация с единицы) первого вхождения `x` в `arr`, если оно существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовый пример**

```sql title=Запрос
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Результат
4
```

**Массив со значениями null**

```sql title=Запрос
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Результат
3
```


## indexOfAssumeSorted {#indexOfAssumeSorted}

Введена в версии: v24.12

Возвращает индекс первого элемента со значением 'x' (начиная с `1`), если он находится в массиве.
Если массив не содержит искомое значение, функция возвращает `0`.

:::note
В отличие от функции `indexOf`, эта функция предполагает, что массив отсортирован в
порядке возрастания. Если массив не отсортирован, результаты не определены.
:::

**Синтаксис**

```sql
indexOfAssumeSorted(arr, x)
```

**Аргументы**

- `arr` — Отсортированный массив для поиска. [`Array(T)`](/sql-reference/data-types/array)
- `x` — Значение первого совпадающего элемента в отсортированном массиве `arr`, для которого требуется вернуть индекс. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация начинается с единицы) первого элемента `x` в массиве `arr`, если он существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовый пример**

```sql title=Запрос
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Ответ
5
```


## length {#length}

Введена в версии: v1.1

Вычисляет длину строки или массива.

- Для аргументов типа String или FixedString: вычисляет количество байтов в строке.
- Для аргументов типа Array: вычисляет количество элементов в массиве.
- При применении к аргументу типа FixedString функция является константным выражением.

Обратите внимание, что количество байтов в строке не совпадает с количеством
кодовых точек Unicode, не совпадает с количеством графемных кластеров Unicode
(то, что обычно называют «символами»), и не совпадает с видимой шириной строки.

Строки могут содержать нулевые байты ASCII, которые также будут учитываться.

**Синтаксис**

```sql
length(x)
```

**Псевдонимы**: `OCTET_LENGTH`

**Аргументы**

- `x` — значение, для которого вычисляется количество байтов (для String/FixedString) или элементов (для Array). [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество байтов в String/FixedString `x` или количество элементов в массиве `x`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример со строкой**

```sql title=Запрос
SELECT length('Hello, world!')
```

```response title=Результат
13
```

**Пример с массивом**

```sql title=Запрос
SELECT length(['Hello', 'world'])
```

```response title=Результат
2
```

**Пример с константным выражением**

```sql title=Запрос
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Результат
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**Пример с Unicode**

```sql title=Запрос
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Результат
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**Пример сравнения ASCII и UTF-8**

```sql title=Запрос
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Результат
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty {#notEmpty}

Введена в версии: v1.1

Проверяет, является ли входной массив непустым.

Массив считается непустым, если содержит хотя бы один элемент.

:::note
Может быть оптимизирована путём включения настройки [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подстолбец [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всего столбца массива. Запрос `SELECT notEmpty(arr) FROM table` преобразуется в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функция также работает для строк (String) и UUID.

**Синтаксис**

```sql
notEmpty(arr)
```

**Аргументы**

- `arr` — входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для непустого массива или `0` для пустого массива. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT notEmpty([1,2]);
```

```response title=Результат
1
```


## range {#range}

Введено в версии: v1.1

Возвращает массив чисел от `start` до `end - 1` с шагом `step`.

Поддерживаемые типы:

- `UInt8/16/32/64`
- `Int8/16/32/64`

- Все аргументы `start`, `end`, `step` должны быть одного из перечисленных выше поддерживаемых типов. Элементы возвращаемого массива будут иметь супертип аргументов.
- Генерируется исключение, если функция возвращает массив с общей длиной, превышающей количество элементов, указанное в настройке [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block).
- Возвращает `NULL`, если любой из аргументов имеет тип Nullable(nothing). Генерируется исключение, если любой из аргументов имеет значение `NULL` (тип Nullable(T)).

**Синтаксис**

```sql
range([start, ] end [, step])
```

**Аргументы**

- `start` — Необязательный. Первый элемент массива. Обязателен, если используется `step`. Значение по умолчанию: `0`.
- `end` — Обязательный. Число, до которого строится массив.
- `step` — Необязательный. Определяет шаг приращения между элементами массива. Значение по умолчанию: `1`.

**Возвращаемое значение**

Массив чисел от `start` до `end - 1` с шагом `step`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Результат
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate {#replicate}

Введена в версии: v1.1

Создаёт массив, заполненный одним значением.

**Синтаксис**

```sql
replicate(x, arr)
```

**Аргументы**

- `x` — значение для заполнения результирующего массива. [`Any`](/sql-reference/data-types)
- `arr` — массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив той же длины, что и `arr`, заполненный значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Запрос
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Результат
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse {#reverse}

Добавлено в версии: v1.1

Изменяет порядок элементов во входном массиве или символов во входной строке на обратный.

**Синтаксис**

```sql
reverse(arr | str)
```

**Аргументы**

- `arr | str` — Исходный массив или строка. [`Array(T)`](/sql-reference/data-types/array) или [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив или строку с обратным порядком элементов или символов.

**Примеры**

**Обратный порядок элементов массива**

```sql title=Запрос
SELECT reverse([1, 2, 3, 4]);
```

```response title=Результат
[4, 3, 2, 1]
```

**Обратный порядок символов строки**

```sql title=Запрос
SELECT reverse('abcd');
```

```response title=Результат
'dcba'
```

<!--AUTOGENERATED_END-->


## Функции расстояния {#distance-functions}

Все поддерживаемые функции описаны в [документации функций расстояния](../../sql-reference/functions/distance-functions.md).

---
slug: /sql-reference/functions/array-functions
sidebar_position: 10
sidebar_label: Массивы
---

# Функции Массивов
## empty {#empty}

Проверяет, является ли входной массив пустым.

**Синтаксис**

``` sql
empty([x])
```

Массив считается пустым, если он не содержит никаких элементов.

:::note
Можно оптимизировать, включив настройку [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция считывает только подколонку [size0](/sql-reference/data-types/array#array-size), вместо того чтобы считывать и обрабатывать всю колонку массива. Запрос `SELECT empty(arr) FROM TABLE;` трансформируется в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает для [строк](string-functions.md#empty) или [UUID](uuid-functions.md#empty).

**Аргументы**

- `[x]` — Входной массив. [Array](/sql-reference/data-types/array).

**Возвращаемое значение**

- Возвращает `1` для пустого массива или `0` для непустого массива. [UInt8](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT empty([]);
```

Результат:

```text
┌─empty(array())─┐
│              1 │
└────────────────┘
```
## notEmpty {#notempty}

Проверяет, является ли входной массив непустым.

**Синтаксис**

``` sql
notEmpty([x])
```

Массив считается непустым, если он содержит хотя бы один элемент.

:::note
Можно оптимизировать, включив настройку [optimize_functions_to_subcolumns](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция считывает только подколонку [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всей колонки. Запрос `SELECT notEmpty(arr) FROM table` трансформируется в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функция также работает для [строк](string-functions.md#notempty) или [UUID](uuid-functions.md#notempty).

**Аргументы**

- `[x]` — Входной массив. [Array](/sql-reference/data-types/array).

**Возвращаемое значение**

- Возвращает `1` для непустого массива или `0` для пустого массива. [UInt8](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT notEmpty([1,2]);
```

Результат:

```text
┌─notEmpty([1, 2])─┐
│                1 │
└──────────────────┘
```
## length {#length}

Возвращает количество элементов в массиве.
Тип результата — UInt64.
Функция также работает для строк.

Можно оптимизировать, включив настройку [optimize_functions_to_subcolumns](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция считывает только подколонку [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всей колонки. Запрос `SELECT length(arr) FROM table` трансформируется в `SELECT arr.size0 FROM TABLE`.

Псевдоним: `OCTET_LENGTH`
## emptyArrayUInt8 {#emptyarrayuint8}

Возвращает пустой массив UInt8.

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt8();
```

Результат:

```response
[]
```
## emptyArrayUInt16 {#emptyarrayuint16}

Возвращает пустой массив UInt16.

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt16();

```

Результат:

```response
[]
```
## emptyArrayUInt32 {#emptyarrayuint32}

Возвращает пустой массив UInt32.

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt32();
```

Результат:

```response
[]
```
## emptyArrayUInt64 {#emptyarrayuint64}

Возвращает пустой массив UInt64.

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt64();
```

Результат:

```response
[]
```
## emptyArrayInt8 {#emptyarrayint8}

Возвращает пустой массив Int8.

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt8();
```

Результат:

```response
[]
```
## emptyArrayInt16 {#emptyarrayint16}

Возвращает пустой массив Int16.

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt16();
```

Результат:

```response
[]
```
## emptyArrayInt32 {#emptyarrayint32}

Возвращает пустой массив Int32.

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt32();
```

Результат:

```response
[]
```
## emptyArrayInt64 {#emptyarrayint64}

Возвращает пустой массив Int64.

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt64();
```

Результат:

```response
[]
```
## emptyArrayFloat32 {#emptyarrayfloat32}

Возвращает пустой массив Float32.

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayFloat32();
```

Результат:

```response
[]
```
## emptyArrayFloat64 {#emptyarrayfloat64}

Возвращает пустой массив Float64.

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayFloat64();
```

Результат:

```response
[]
```
## emptyArrayDate {#emptyarraydate}

Возвращает пустой массив Дата.

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayDate();
```
## emptyArrayDateTime {#emptyarraydatetime}

Возвращает пустой массив DateTime.

**Синтаксис**

```sql
emptyArrayDateTime()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayDateTime();
```

Результат:

```response
[]
```
## emptyArrayString {#emptyarraystring}

Возвращает пустой массив строк.

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayString();
```

Результат:

```response
[]
```
## emptyArrayToSingle {#emptyarraytosingle}

Принимает пустой массив и возвращает массив с одним элементом, равным значению по умолчанию.
## range(end), range(\[start, \] end \[, step\]) {#rangeend-rangestart--end--step}

Возвращает массив чисел от `start` до `end - 1` с шагом `step`. Поддерживаемые типы: [UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64](../data-types/int-uint.md).

**Синтаксис**

``` sql
range([start, ] end [, step])
```

**Аргументы**

- `start` — Первый элемент массива. Опционально, обязательный, если используется `step`. Значение по умолчанию: 0.
- `end` — Число, перед которым строится массив. Обязательное.
- `step` — Определяет размер шага между каждым элементом в массиве. Опционально. Значение по умолчанию: 1.

**Возвращаемое значение**

- Массив чисел от `start` до `end - 1` с шагом `step`.

**Подробности реализации**

- Все аргументы `start`, `end`, `step` должны быть из приведенных типов данных: `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, а также элементы возвращаемого массива, который имеет тип, являющийся суперттипом всех аргументов.
- Генерируется исключение, если результат запроса приводит к массивам с общей длиной более числа элементов, указанного в настройке [function_range_max_elements_in_block](../../operations/settings/settings.md#function_range_max_elements_in_block).
- Возвращает Null, если любой аргумент имеет тип Nullable(Nothing). Генерируется исключение, если любой аргумент имеет значение Null (Nullable(T) тип).

**Примеры**

Запрос:

``` sql
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

Результат:

```txt
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```
## array(x1, ...), оператор \[x1, ...\] {#arrayx1--operator-x1-}

Создает массив из аргументов функции.
Аргументы должны быть константами и иметь типы, имеющие наименьший общий тип. Должен быть передан хотя бы один аргумент, иначе неясно, какой тип массива создать. То есть, вы не можете использовать эту функцию для создания пустого массива (для этого используйте функцию 'emptyArray\*', описанную выше).
Возвращает результат типа 'Array(T)', где 'T' является наименьшим общим типом из переданных аргументов.
## arrayWithConstant(length, elem) {#arraywithconstantlength-elem}

Создает массив длины `length`, заполненный постоянной `elem`.
## arrayConcat {#arrayconcat}

Объединяет массивы, переданные в качестве аргументов.

``` sql
arrayConcat(arrays)
```

**Аргументы**

- `arrays` – Произвольное количество аргументов типа [Array](/sql-reference/data-types/array).

**Пример**

``` sql
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

``` text
┌─res───────────┐
│ [1,2,3,4,5,6] │
└───────────────┘
```
## arrayElement(arr, n), оператор arr\[n\] {#arrayelementarr-n-operator-arrn}

Получает элемент с индексом `n` из массива `arr`. `n` должен быть любого целочисленного типа.
Индексы в массиве начинаются с единицы.

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, нумеруемый с конца. Например, `arr[-1]` — это последний элемент в массиве.

Если индекс выходит за пределы массива, возвращается некоторое значение по умолчанию (0 для чисел, пустая строка для строк и т.д.), за исключением случая с неконстантным массивом и константным индексом 0 (в этом случае будет ошибка `Array indices are 1-based`).
## has(arr, elem) {#hasarr-elem}

Проверяет, содержит ли массив 'arr' элемент 'elem'.
Возвращает 0, если элемент отсутствует в массиве, или 1, если он есть.

`NULL` обрабатывается как значение.

``` sql
SELECT has([1, 2, NULL], NULL)
```

``` text
┌─has([1, 2, NULL], NULL)─┐
│                       1 │
└─────────────────────────┘
```
## arrayElementOrNull(arr, n) {#arrayelementornullarr-n}

Получает элемент с индексом `n` из массива `arr`. `n` должен быть любого целочисленного типа.
Индексы в массиве начинаются с единицы.

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, нумеруемый с конца. Например, `arr[-1]` — это последний элемент в массиве.

Если индекс выходит за пределы массива, возвращается `NULL` вместо значения по умолчанию.
### Примеры {#examples}

``` sql
SELECT arrayElementOrNull([1, 2, 3], 2), arrayElementOrNull([1, 2, 3], 4)
```

``` text
 ┌─arrayElementOrNull([1, 2, 3], 2)─┬─arrayElementOrNull([1, 2, 3], 4)─┐
 │                                2 │                             ᴺᵁᴸᴸ │
 └──────────────────────────────────┴──────────────────────────────────┘
```
## hasAll {#hasall}

Проверяет, является ли один массив подмножеством другого.

``` sql
hasAll(set, subset)
```

**Аргументы**

- `set` – Массив любого типа с набором элементов.
- `subset` – Массив любого типа, который разделяет общий супертиип с `set`, содержащий элементы, которые должны быть проверены на принадлежность к `set`.

**Возвращаемые значения**

- `1`, если `set` содержит все элементы из `subset`.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы наборов и подмножеств не имеют общего супертиипа.

**Особые свойства**

- Пустой массив является подмножеством любого массива.
- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Примеры**

`SELECT hasAll([], [])` возвращает 1.

`SELECT hasAll([1, Null], [Null])` возвращает 1.

`SELECT hasAll([1.0, 2, 3, 4], [1, 3])` возвращает 1.

`SELECT hasAll(['a', 'b'], ['a'])` возвращает 1.

`SELECT hasAll([1], ['a'])` вызывает исключение `NO_COMMON_TYPE`.

`SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])` возвращает 0.
## hasAny {#hasany}

Проверяет, имеют ли два массива пересечение по каким-либо элементам.

``` sql
hasAny(array1, array2)
```

**Аргументы**

- `array1` – Массив любого типа с набором элементов.
- `array2` – Массив любого типа, который разделяет общий супертиип с `array1`.

**Возвращаемые значения**

- `1`, если `array1` и `array2` имеют хотя бы один общий элемент.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы array1 и array2 не имеют общего супертиипа.

**Особые свойства**

- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Примеры**

`SELECT hasAny([1], [])` возвращает `0`.

`SELECT hasAny([Null], [Null, 1])` возвращает `1`.

`SELECT hasAny([-128, 1., 512], [1])` возвращает `1`.

`SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])` вызывает исключение `NO_COMMON_TYPE`.

`SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])` возвращает `1`.
## hasSubstr {#hassubstr}

Проверяет, появляются ли все элементы array2 в array1 в том же точном порядке. Таким образом, функция вернет 1, если и только если `array1 = prefix + array2 + suffix`.

``` sql
hasSubstr(array1, array2)
```

Иными словами, функции проверят, содержатся ли все элементы `array2` в `array1`, как функция `hasAll`. В дополнение к этому, будет проверено, что элементы наблюдаются в том же порядке в обоих `array1` и `array2`.

Например:

- `hasSubstr([1,2,3,4], [2,3])` возвращает 1. Однако, `hasSubstr([1,2,3,4], [3,2])` вернет `0`.
- `hasSubstr([1,2,3,4], [1,2,3])` возвращает 1. Однако, `hasSubstr([1,2,3,4], [1,2,4])` вернет `0`.

**Аргументы**

- `array1` – Массив любого типа с набором элементов.
- `array2` – Массив любого типа с набором элементов.

**Возвращаемые значения**

- `1`, если `array1` содержит `array2`.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы array1 и array2 не имеют общего супертиипа.

**Особые свойства**

- Функция вернет `1`, если `array2` пуст.
- `Null` обрабатывается как значение. Иными словами, `hasSubstr([1, 2, NULL, 3, 4], [2,3])` вернет `0`. Однако, `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` вернет `1`.
- Порядок значений в обоих массивах имеет значение.

**Примеры**

`SELECT hasSubstr([], [])` возвращает 1.

`SELECT hasSubstr([1, Null], [Null])` возвращает 1.

`SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])` возвращает 0.

`SELECT hasSubstr(['a', 'b'], ['a'])` возвращает 1.

`SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])` возвращает 1.

`SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])` возвращает 0.

`SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])` возвращает 1.

`SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])` вызывает исключение `NO_COMMON_TYPE`.
## indexOf(arr, x) {#indexofarr-x}

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он присутствует в массиве.
Если массив не содержит искомое значение, функция возвращает 0.

Пример:

``` sql
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

``` text
┌─indexOf([1, 3, NULL, NULL], NULL)─┐
│                                 3 │
└───────────────────────────────────┘
```

Элементы, установленные в `NULL`, обрабатываются как нормальные значения.
## indexOfAssumeSorted(arr, x) {#indexofassumesortedarr-x}

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он присутствует в массиве.
Если массив не содержит искомое значение, функция возвращает 0.
Предполагает, что массив отсортирован в порядке возрастания (т.е. функция использует двоичный поиск).
Если массив не отсортирован, результаты неопределенны.
Если внутренний массив имеет тип Nullable, будет вызвана функция 'indexOf'.

Пример:

``` sql
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

``` text
┌─indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)─┐
│                                             5 │
└───────────────────────────────────────────────┘
```
## arrayCount(\[func,\] arr1, ...) {#arraycountfunc-arr1-}

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает что-то другое, чем 0. Если `func` не указан, возвращает количество ненулевых элементов в массиве.

Обратите внимание, что `arrayCount` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.
## arrayDotProduct {#arraydotproduct}

Возвращает скалярное произведение двух массивов.

**Синтаксис**

```sql
arrayDotProduct(vector1, vector2)
```

Псевдоним: `scalarProduct`, `dotProduct`

**Параметры**

- `vector1`: Первый вектор. [Array](/sql-reference/data-types/array) или [Tuple](../data-types/tuple.md) числовых значений.
- `vector2`: Второй вектор. [Array](/sql-reference/data-types/array) или [Tuple](../data-types/tuple.md) числовых значений.

:::note
Размеры двух векторов должны быть равны. Массивы и кортежи могут также содержать смешанные типы элементов.
:::

**Возвращаемое значение**

- Скалярное произведение двух векторов. [Numeric](/native-protocol/columns#numeric-types).

:::note
Тип возвращаемого значения определяется типом аргументов. Если массивы или кортежи содержат смешанные типы элементов, то тип результата является супертиипом.
:::

**Примеры**

Запрос:

```sql
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

Результат:

```response
32	UInt16
```

Запрос:

```sql
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

Результат:

```response
32	Float64
```
## countEqual(arr, x) {#countequalarr-x}

Возвращает количество элементов в массиве, равных x. Эквивалентно arrayCount (elem -\> elem = x, arr).

Элементы `NULL` обрабатываются как отдельные значения.

Пример:

``` sql
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

``` text
┌─countEqual([1, 2, NULL, NULL], NULL)─┐
│                                    2 │
└──────────────────────────────────────┘
```
## arrayEnumerate(arr) {#arrayenumeratearr}

Возвращает массив \[1, 2, 3, ..., length (arr) \]

Эта функция обычно используется с ARRAY JOIN. Она позволяет выполнить подсчет чего-либо только один раз для каждого массива после применения ARRAY JOIN. Пример:

``` sql
SELECT
    count() AS Reaches,
    countIf(num = 1) AS Hits
FROM test.hits
ARRAY JOIN
    GoalsReached,
    arrayEnumerate(GoalsReached) AS num
WHERE CounterID = 160656
LIMIT 10
```

``` text
┌─Reaches─┬──Hits─┐
│   95606 │ 31406 │
└─────────┴───────┘
```

В этом примере Reaches — это количество конверсий (строк, полученных после применения ARRAY JOIN), а Hits — это количество просмотров страниц (строк до ARRAY JOIN). В данном конкретном случае вы можете получить тот же результат более простым способом:

``` sql
SELECT
    sum(length(GoalsReached)) AS Reaches,
    count() AS Hits
FROM test.hits
WHERE (CounterID = 160656) AND notEmpty(GoalsReached)
```

``` text
┌─Reaches─┬──Hits─┐
│   95606 │ 31406 │
└─────────┴───────┘
```

Эту функцию также можно использовать в функциях высшего порядка. Например, вы можете использовать ее, чтобы получить индексы массива для элементов, которые соответствуют условию.
## arrayEnumerateUniq {#arrayenumerateuniq}

Возвращает массив того же размера, что и исходный массив, указывая для каждого элемента, какова его позиция среди элементов с таким же значением.
Например: arrayEnumerateUniq(\[10, 20, 10, 30\]) = \[1, 1, 2, 1\].

Эта функция полезна при использовании ARRAY JOIN и агрегировании элементов массива.
Пример:

``` sql
SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

``` text
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```

В этом примере для каждого идентификатора цели производится подсчет количества конверсий (каждый элемент в вложенной структуре данных Goals — это цель, которая была достигнута, которую мы называем конверсией) и количества сеансов. Без ARRAY JOIN мы бы посчитали количество сеансов как sum(Sign). Но в данном конкретном случае строки были умножены структурой вложенных Goals, поэтому чтобы считать каждый сеанс один раз после этого, мы применяем условие к значению функции arrayEnumerateUniq(Goals.ID).

Функция arrayEnumerateUniq может принимать несколько массивов одинакового размера в качестве аргументов. В этом случае уникальность считается для кортежей элементов на одинаковых позициях во всех массивах.

``` sql
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]) AS res
```

``` text
┌─res───────────┐
│ [1,2,1,1,2,1] │
└───────────────┘
```

Это необходимо при использовании ARRAY JOIN с вложенной структурой данных и дальнейшей агрегацией по нескольким элементам в этой структуре.
## arrayEnumerateUniqRanked {#arrayenumerateuniqranked}

Возвращает массив того же размера, что и исходный массив, указывая для каждого элемента, какова его позиция среди элементов с таким же значением. Позволяет перечислять многомерный массив с возможностью указать, на какую глубину заглядывать внутрь массива.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Параметры**

- `clear_depth`: Перечислить элементы на указанном уровне отдельно. Положительное [Целое число](../data-types/int-uint.md), меньшее или равное `max_arr_depth`.
- `arr`: N-мерный массив для перечисления. [Array](/sql-reference/data-types/array).
- `max_array_depth`: Максимальная эффективная глубина. Положительное [Целое число](../data-types/int-uint.md), меньшее или равного глубине `arr`.

**Пример**

С `clear_depth=1` и `max_array_depth=1`, результат `arrayEnumerateUniqRanked` идентичен тому, который даст [`arrayEnumerateUniq`](#arrayenumerateuniq) для того же массива.

Запрос:

``` sql
SELECT arrayEnumerateUniqRanked(1, [1,2,1], 1);
```

Результат:

``` text
[1,1,2]
```

В этом примере `arrayEnumerateUniqRanked` используется для получения массива, указывающего для каждого элемента многомерного массива, какова его позиция среди элементов с таким же значением. Для первой строки переданного массива `\[1,2,3\]` соответствующий результат `\[1,1,1\]`, указывающий, что это первый раз, когда встречаются `1`, `2` и `3`. Для второй строки переданного массива `\[2,2,1\]` соответствующий результат `\[2,3,3\]`, указывающий, что `2` встречается второй и третий раз, а `1` встречается второй раз. Точно так же для третьей строки переданного массива `\[3\]` соответствующий результат `\[2\]`, указывающий, что `3` встречается второй раз.

Запрос:

``` sql
SELECT arrayEnumerateUniqRanked(1, [[1,2,3],[2,2,1],[3]], 2);
```

Результат:

``` text
[[1,1,1],[2,3,2],[2]]
```

Изменение `clear_depth=2` приводит к перечислению элементов отдельно для каждой строки.

Запрос:

``` sql
SELECT arrayEnumerateUniqRanked(2, [[1,2,3],[2,2,1],[3]], 2);
```

Результат:

``` text
[[1,1,1],[1,2,1],[1]]
```
## arrayPopBack {#arraypopback}

Удаляет последний элемент из массива.

``` sql
arrayPopBack(array)
```

**Аргументы**

- `array` – Массив.

**Пример**

``` sql
SELECT arrayPopBack([1, 2, 3]) AS res;
```

``` text
┌─res───┐
│ [1,2] │
└───────┘
```
## arrayPopFront {#arraypopfront}

Удаляет первый элемент из массива.

``` sql
arrayPopFront(array)
```

**Аргументы**

- `array` – Массив.

**Пример**

``` sql
SELECT arrayPopFront([1, 2, 3]) AS res;
```

``` text
┌─res───┐
│ [2,3] │
└───────┘
```
## arrayPushBack {#arraypushback}

Добавляет один элемент в конец массива.

``` sql
arrayPushBack(array, single_value)
```

**Аргументы**

- `array` – Массив.
- `single_value` – Одна переменная. В массив с числами могут быть добавлены только числа, а в массив строк — только строки. При добавлении чисел ClickHouse автоматически устанавливает тип `single_value` для типа данных массива. Дополнительную информацию о типах данных в ClickHouse см. в разделе "[Типы данных](/sql-reference/data-types)". Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

**Пример**

``` sql
SELECT arrayPushBack(['a'], 'b') AS res;
```

``` text
┌─res───────┐
│ ['a','b'] │
└───────────┘
```
## arrayPushFront {#arraypushfront}

Добавляет один элемент в начало массива.

``` sql
arrayPushFront(array, single_value)
```

**Аргументы**

- `array` – Массив.
- `single_value` – Одна переменная. В массив с числами могут быть добавлены только числа, а в массив строк — только строки. При добавлении чисел ClickHouse автоматически устанавливает тип `single_value` для типа данных массива. Дополнительную информацию о типах данных в ClickHouse см. в разделе "[Типы данных](/sql-reference/data-types)". Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

**Пример**

``` sql
SELECT arrayPushFront(['b'], 'a') AS res;
```

``` text
┌─res───────┐
│ ['a','b'] │
└───────────┘
```
## arrayResize {#arrayresize}

Изменяет длину массива.

``` sql
arrayResize(array, size[, extender])
```

**Аргументы:**

- `array` — Массив.
- `size` — Требуемая длина массива.
  - Если `size` меньше изначального размера массива, массив обрезается справа.
- Если `size` больше исходного размера массива, массив расширяется вправо с помощью значений `extender` или значений по умолчанию для типа данных элементов массива.
- `extender` — Значение для расширения массива. Может быть `NULL`.

**Возвращаемое значение:**

Массив длиной `size`.

**Примеры вызовов**

``` sql
SELECT arrayResize([1], 3);
```

``` text
┌─arrayResize([1], 3)─┐
│ [1,0,0]             │
└─────────────────────┘
```

``` sql
SELECT arrayResize([1], 3, NULL);
```

``` text
┌─arrayResize([1], 3, NULL)─┐
│ [1,NULL,NULL]             │
└───────────────────────────┘
```
## arraySlice {#arrayslice}

Возвращает срез массива.

``` sql
arraySlice(array, offset[, length])
```

**Аргументы**

- `array` – Массив данных.
- `offset` – Смещение от края массива. Положительное значение указывает на смещение слева, а отрицательное значение — на смещение справа. Нумерация элементов массива начинается с 1.
- `length` – Длина необходимого среза. Если вы укажете отрицательное значение, функция вернет открытый срез `[offset, array_length - length]`. Если вы пропустите значение, функция вернет срез `[offset, the_end_of_array]`.

**Пример**

``` sql
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

``` text
┌─res────────┐
│ [2,NULL,4] │
└────────────┘
```

Элементы массивов, установленные в `NULL`, обрабатываются как нормальные значения.
## arrayShingles {#arrayshingles}

Генерирует массив «шинглов», т.е. последовательных подмассивов с заданной длиной входного массива.

**Синтаксис**

``` sql
arrayShingles(array, length)
```

**Аргументы**

- `array` — Входной массив [Array](/sql-reference/data-types/array).
- `length` — Длина каждого шингла.

**Возвращаемое значение**

- Массив сгенерированных шинглов. [Array](/sql-reference/data-types/array).

**Примеры**

Запрос:

``` sql
SELECT arrayShingles([1,2,3,4], 3) as res;
```

Результат:

``` text
┌─res───────────────┐
│ [[1,2,3],[2,3,4]] │
└───────────────────┘
```

## arraySort(\[func,\] arr, ...) {#sort}

Сортирует элементы массива `arr` в порядке возрастания. Если задана функция `func`, порядок сортировки определяется результатом применения функции `func` к элементам массива. Если `func` принимает несколько аргументов, функции `arraySort` передаются несколько массивов, каждому из аргументов `func` будет соответствовать свой массив. Подробные примеры показаны в конце описания `arraySort`.

Пример сортировки целых значений:

``` sql
SELECT arraySort([1, 3, 3, 0]);
```

``` text
┌─arraySort([1, 3, 3, 0])─┐
│ [0,1,3,3]               │
└─────────────────────────┘
```

Пример сортировки строковых значений:

``` sql
SELECT arraySort(['hello', 'world', '!']);
```

``` text
┌─arraySort(['hello', 'world', '!'])─┐
│ ['!','hello','world']              │
└────────────────────────────────────┘
```

Рассмотрите следующий порядок сортировки для значений `NULL`, `NaN` и `Inf`:

``` sql
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

``` text
┌─arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf])─┐
│ [-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]                     │
└───────────────────────────────────────────────────────────┘
```

- Значения `-Inf` находятся первыми в массиве.
- Значения `NULL` находятся последними в массиве.
- Значения `NaN` располагаются перед `NULL`.
- Значения `Inf` располагаются перед `NaN`.

Обратите внимание, что `arraySort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ему лямбда-функцию в качестве первого аргумента. В этом случае порядок сортировки определяется результатом применения лямбда-функции к элементам массива.

Рассмотрим следующий пример:

``` sql
SELECT arraySort((x) -> -x, [1, 2, 3]) as res;
```

``` text
┌─res─────┐
│ [3,2,1] │
└─────────┘
```

Для каждого элемента исходного массива лямбда-функция возвращает ключ сортировки, т.е. \[1 –\> -1, 2 –\> -2, 3 –\> -3\]. Поскольку функция `arraySort` сортирует ключи в порядке возрастания, результат будет \[3, 2, 1\]. Таким образом, лямбда-функция `(x) –> -x` устанавливает [убывающий порядок](#arrayreversesort) в сортировке.

Лямбда-функция может принимать несколько аргументов. В этом случае нужно передать функции `arraySort` несколько массивов одинаковой длины, которые будут соответствовать аргументам лямбда-функции. Результирующий массив будет состоять из элементов первого входного массива; элементы следующих входных массивов будут определять ключи сортировки. Например:

``` sql
SELECT arraySort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;
```

``` text
┌─res────────────────┐
│ ['world', 'hello'] │
└────────────────────┘
```

Здесь элементы, переданные во втором массиве (\[2, 1\]), определяют ключи сортировки для соответствующих элементов исходного массива (\['hello', 'world'\]), т.е. \['hello' –\> 2, 'world' –\> 1\]. Поскольку лямбда-функция не использует `x`, фактические значения исходного массива не влияют на порядок в результате. Таким образом, 'hello' будет вторым элементом в результате, а 'world' — первым.

Другие примеры приведены ниже.

``` sql
SELECT arraySort((x, y) -> y, [0, 1, 2], ['c', 'b', 'a']) as res;
```

``` text
┌─res─────┐
│ [2,1,0] │
└─────────┘
```

``` sql
SELECT arraySort((x, y) -> -y, [0, 1, 2], [1, 2, 3]) as res;
```

``` text
┌─res─────┐
│ [2,1,0] │
└─────────┘
```

:::note
Для повышения эффективности сортировки используется [трансформация Шварца](https://en.wikipedia.org/wiki/Schwartzian_transform).
:::
## arrayPartialSort(\[func,\] limit, arr, ...) {#arraypartialsortfunc-limit-arr-}

То же самое, что и `arraySort`, с дополнительным аргументом `limit`, позволяющим частичную сортировку. Возвращает массив такого же размера, как исходный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке возрастания. Оставшиеся элементы `(limit..N]` будут содержать элементы в неопределенном порядке.
## arrayReverseSort {#arrayreversesort}

Сортирует элементы массива `arr` в порядке убывания. Если указана функция `func`, `arr` сортируется в соответствии с результатом функции `func`, примененной к элементам массива, после чего отсортированный массив переворачивается. Если `func` принимает несколько аргументов, функции `arrayReverseSort` передаются несколько массивов, которые будут соответствовать аргументам `func`. Подробные примеры показаны в конце описания `arrayReverseSort`.

**Синтаксис**

```sql
arrayReverseSort([func,] arr, ...)
```
Пример сортировки целых значений:

``` sql
SELECT arrayReverseSort([1, 3, 3, 0]);
```

``` text
┌─arrayReverseSort([1, 3, 3, 0])─┐
│ [3,3,1,0]                      │
└────────────────────────────────┘
```

Пример сортировки строковых значений:

``` sql
SELECT arrayReverseSort(['hello', 'world', '!']);
```

``` text
┌─arrayReverseSort(['hello', 'world', '!'])─┐
│ ['world','hello','!']                     │
└───────────────────────────────────────────┘
```

Рассмотрите следующий порядок сортировки для значений `NULL`, `NaN` и `Inf`:

``` sql
SELECT arrayReverseSort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]) as res;
```

``` text
┌─res───────────────────────────────────┐
│ [inf,3,2,1,-4,-inf,nan,nan,NULL,NULL] │
└───────────────────────────────────────┘
```

- Значения `Inf` находятся первыми в массиве.
- Значения `NULL` находятся последними в массиве.
- Значения `NaN` располагаются перед `NULL`.
- Значения `-Inf` располагаются перед `NaN`.

Обратите внимание, что `arrayReverseSort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента. Пример показан ниже.

``` sql
SELECT arrayReverseSort((x) -> -x, [1, 2, 3]) as res;
```

``` text
┌─res─────┐
│ [1,2,3] │
└─────────┘
```

Массив сортируется следующим образом:

1. Сначала исходный массив (\[1, 2, 3\]) сортируется в соответствии с результатом применения лямбда-функции к элементам массива. Результат — массив \[3, 2, 1\].
2. Массив, полученный на предыдущем шаге, переворачивается. Таким образом, окончательный результат — \[1, 2, 3\].

Лямбда-функция может принимать несколько аргументов. В этом случае нужно передать функции `arrayReverseSort` несколько массивов одинаковой длины, которые будут соответствовать аргументам лямбда-функции. Результирующий массив будет состоять из элементов первого входного массива; элементы следующих входных массивов будут определять ключи сортировки. Например:

``` sql
SELECT arrayReverseSort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;
```

``` text
┌─res───────────────┐
│ ['hello','world'] │
└───────────────────┘
```

В этом примере массив сортируется следующим образом:

1. Сначала исходный массив (\['hello', 'world'\]) сортируется в соответствии с результатом применения лямбда-функции к элементам массивов. Элементы, переданные во втором массиве (\[2, 1\]), определяют ключи сортировки для соответствующих элементов из исходного массива. Результатом является массив \['world', 'hello'\].
2. Массив, отсортированный на предыдущем шаге, переворачивается. Таким образом, окончательный результат — \['hello', 'world'\].

Другие примеры представлены ниже.

``` sql
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

``` text
┌─res─────┐
│ [5,3,4] │
└─────────┘
```

``` sql
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

``` text
┌─res─────┐
│ [4,3,5] │
└─────────┘
```
## arrayPartialReverseSort(\[func,\] limit, arr, ...) {#arraypartialreversesortfunc-limit-arr-}

То же самое, что и `arrayReverseSort`, с дополнительным аргументом `limit`, позволяющим частичную сортировку. Возвращает массив такого же размера как исходный, в котором элементы в диапазоне `[1..limit]` отсортированы в порядке убывания. Оставшиеся элементы `(limit..N]` будут содержать элементы в неопределенном порядке.
## arrayShuffle {#arrayshuffle}

Возвращает массив такого же размера, как исходный массив, содержащий элементы в перемешанном порядке.
Элементы переупорядочиваются таким образом, чтобы каждая возможная перестановка этих элементов имела равную вероятность появления.

**Синтаксис**

```sql
arrayShuffle(arr[, seed])
```

**Параметры**

- `arr`: Массив для частичного перемешивания. [Массив](/sql-reference/data-types/array).
- `seed` (необязательно): семя, которое будет использоваться для генерации случайных чисел. Если не указано, используется случайное. [UInt или Int](../data-types/int-uint.md).

**Возвращаемое значение**

- Массив с перемешанными элементами.

**Подробности реализации**

:::note 
Эта функция не будет материализовать константы.
:::

**Примеры**

В этом примере `arrayShuffle` используется без указания `seed` и, следовательно, будет генерировать его случайным образом.

Запрос:

```sql
SELECT arrayShuffle([1, 2, 3, 4]);
```

Примечание: при использовании [ClickHouse Fiddle](https://fiddle.clickhouse.com/) точный ответ может отличаться из-за случайного характера функции.

Результат: 

```response
[1,4,2,3]
```

В этом примере `arrayShuffle` указан `seed`, и он будет производить стабильные результаты.

Запрос:

```sql
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

Результат: 

```response
[3,2,1,4]
```
## arrayPartialShuffle {#arraypartialshuffle}

Дает массив размера `N` для входного массива, где элементы в диапазоне `[1...limit]` перемешаны, а оставшиеся элементы в диапазоне `(limit...n]` не перемешаны.

**Синтаксис**

```sql
arrayPartialShuffle(arr[, limit[, seed]])
```

**Параметры**

- `arr`: Массив размера `N` для частичного перемешивания. [Массив](/sql-reference/data-types/array).
- `limit` (необязательно): Число, ограничивающее количество замен элементов, в диапазоне `[1..N]`. [UInt или Int](../data-types/int-uint.md).
- `seed` (необязательно): Значение семени, которое будет использоваться для генерации случайных чисел. Если не указано, используется случайное. [UInt или Int](../data-types/int-uint.md)

**Возвращаемое значение**

- Массив с частично перемешанными элементами.

**Подробности реализации**

:::note 
Эта функция не будет материализовать константы.

Значение `limit` должно находиться в диапазоне `[1..N]`. Значения вне этого диапазона эквивалентны выполнению полной [arrayShuffle](#arrayshuffle).
:::

**Примеры**

Примечание: при использовании [ClickHouse Fiddle](https://fiddle.clickhouse.com/) точный ответ может отличаться из-за случайного характера функции. 

Запрос:

```sql
SELECT arrayPartialShuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)
```

Результат:

Порядок элементов сохраняется (`[2,3,4,5], [7,8,9,10]`), кроме двух перемешанных элементов `[1, 6]`. Семя не указано, поэтому функция выбирает его случайно.

```response
[6,2,3,4,5,1,7,8,9,10]
```

В этом примере `limit` увеличивается до `2`, и значение `seed` указывается. Порядок 

Запрос:

```sql
SELECT arrayPartialShuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2);
```

Порядок элементов сохраняется (`[4, 5, 6, 7, 8], [10]`), кроме четырех перемешанных элементов `[1, 2, 3, 9]`.

Результат: 
```response
[3,9,1,4,5,6,7,8,2,10]
```
## arrayUniq(arr, ...) {#arrayuniqarr-}

Если передан один аргумент, он подсчитывает количество различных элементов в массиве.
Если передано несколько аргументов, он подсчитывает количество различных кортежей элементов на соответствующих позициях в нескольких массивах.

Если вы хотите получить список уникальных элементов в массиве, вы можете использовать arrayReduce('groupUniqArray', arr).
## arrayJoin(arr) {#arrayjoinarr}

Специальная функция. Смотрите раздел ["Функция ArrayJoin"](/sql-reference/functions/array-join).
## arrayDifference {#arraydifference}

Выравнивает массив различий между соседними элементами массива. Первый элемент результирующего массива будет 0, второй `a[1] - a[0]`, третий `a[2] - a[1]` и т.д. Тип элементов результата определяется правилами вывода типов для вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

``` sql
arrayDifference(array)
```

**Аргументы**

- `array` – [Массив](/sql-reference/data-types/array).

**Возвращаемые значения**

Возвращает массив различий между соседними элементами массива. [UInt\*](/sql-reference/data-types/int-uint#integer-ranges), [Int\*](/sql-reference/data-types/int-uint#integer-ranges), [Float\*](/sql-reference/data-types/float).

**Пример**

Запрос:

``` sql
SELECT arrayDifference([1, 2, 3, 4]);
```

Результат:

``` text
┌─arrayDifference([1, 2, 3, 4])─┐
│ [0,1,1,1]                     │
└───────────────────────────────┘
```

Пример переполнения из-за типа результата Int64:

Запрос:

``` sql
SELECT arrayDifference([0, 10000000000000000000]);
```

Результат:

``` text
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```
## arrayDistinct {#arraydistinct}

Принимает массив, возвращает массив, содержащий толькоDistinct элементы.

**Синтаксис**

``` sql
arrayDistinct(array)
```

**Аргументы**

- `array` – [Массив](/sql-reference/data-types/array).

**Возвращаемые значения**

Возвращает массив, содержащийDistinct элементы.

**Пример**

Запрос:

``` sql
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

Результат:

``` text
┌─arrayDistinct([1, 2, 2, 3, 1])─┐
│ [1,2,3]                        │
└────────────────────────────────┘
```
## arrayEnumerateDense {#arrayenumeratedense}

Возвращает массив такого же размера, как исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Пример**

Запрос:

``` sql
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

Результат:

``` text
┌─arrayEnumerateDense([10, 20, 10, 30])─┐
│ [1,2,1,3]                             │
└───────────────────────────────────────┘
```
## arrayEnumerateDenseRanked {#arrayenumeratedenseranked}

Возвращает массив того же размера, что и исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве. Он позволяет перечисление многомерного массива с возможностью указать, насколько глубоко нужно смотреть внутри массива.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Параметры**

- `clear_depth`: Перечислять элементы на указанном уровне отдельно. Положительное [Целое число](../data-types/int-uint.md) меньше или равно `max_arr_depth`.
- `arr`: N-мерный массив для перечисления. [Массив](/sql-reference/data-types/array).
- `max_array_depth`: Максимальная эффективная глубина. Положительное [Целое число](../data-types/int-uint.md) меньше или равно глубине `arr`.

**Пример**

С `clear_depth=1` и `max_array_depth=1` результат аналогичен тому, что дала бы [arrayEnumerateDense](#arrayenumeratedense).

Запрос:

``` sql
SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

Результат:

``` text
[1,2,1,3]
```

В этом примере `arrayEnumerateDenseRanked` используется для получения массива, указывающего, для каждого элемента многомерного массива, какой у него номер среди элементов одного и того же значения. Для первой строки переданного массива,`[10,10,30,20]`, соответствующая первая строка результата — `[1,1,2,3]`, указывая, что `10` — это первое число, встречающееся на позициях 1 и 2, `30` — это второе число, встречающееся на позиции 3, а `20` — третье число, встречающееся на позиции 4. Для второй строки, `[40, 50, 10, 30]`, соответствующая вторая строка результата — `[4,5,1,2]`, указывая, что `40` и `50` — это четвертое и пятое числа, встречающиеся на позициях 1 и 2 этой строки, что другое `10` (первое встреченное число) - это позиция 3, а `30` (второе встреченное число) - это последняя позиция.

Запрос:

``` sql
SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

Результат:

``` text
[[1,1,2,3],[4,5,1,2]]
```

Изменение `clear_depth=2` приводит к тому, что перечисление происходит отдельно для каждой строки заново.

Запрос:

``` sql
SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```
Результат:

``` text
[[1,1,2,3],[1,2,3,4]]
```
## arrayUnion {#arrayunion}

Принимает несколько массивов и возвращает массив, который содержит все элементы, присутствующие в одном из исходных массивов.
Результат содержит только уникальные значения.

**Синтаксис**

``` sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Массив](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов.

**Возвращаемое значение**

- [Массив](/sql-reference/data-types/array) с уникальными элементами из исходных массивов.


**Пример**

Запрос:

```sql
SELECT
    arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
    arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
    arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

Результат:

```text
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```
## arrayIntersect {#arrayintersect}

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах.
Результат содержит только уникальные значения.

**Синтаксис**

``` sql
arrayIntersect(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Массив](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов.

**Возвращаемое значение**

- [Массив](/sql-reference/data-types/array) с уникальными элементами, присутствующими во всех исходных массивах.

**Пример**

Запрос:

``` sql
SELECT
    arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
    arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

Результат:

``` text
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```
## arraySymmetricDifference {#arraysymmetricdifference}

Принимает несколько массивов и возвращает массив с элементами, которые отсутствуют во всех исходных массивах.
Результат содержит только уникальные значения.

:::note
Симметричная разность _более чем двух множеств_ математически определена как множество всех входных элементов, которые встречаются в нечетном количестве входных множеств.
В отличие от этого, функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые не встречаются во всех входных множествах.
:::

**Синтаксис**

``` sql
arraySymmetricDifference(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Массив](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов.

**Возвращаемое значение**

- [Массив](/sql-reference/data-types/array) сDistinct элементами, отсутствующими во всех исходных массивах.

**Пример**

Запрос:

``` sql
SELECT
    arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
    arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference,
```

Результат:

``` text
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```
## arrayJaccardIndex {#arrayjaccardindex}

Возвращает [индекс Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) для двух массивов.

**Пример**

Запрос:
``` sql
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

Результат:
``` text
┌─res────────────────┐
│ 0.3333333333333333 │
└────────────────────┘
```
## arrayReduce {#arrayreduce}

Применяет агрегатную функцию к элементам массива и возвращает его результат. Имя агрегатной функции передается как строка в одиночных кавычках `'max'`, `'sum'`. При использовании параметрических агрегатных функций параметр указывается после имени функции в скобках `'uniqUpTo(6)'`.

**Синтаксис**

``` sql
arrayReduce(agg_func, arr1, arr2, ..., arrN)
```

**Аргументы**

- `agg_func` — Имя агрегатной функции, которое должно быть постоянной [строкой](../data-types/string.md).
- `arr` — Любое количество колонок типа [массив](/sql-reference/data-types/array) в качестве параметров агрегатной функции.

**Возвращаемое значение**

**Пример**

Запрос:

``` sql
SELECT arrayReduce('max', [1, 2, 3]);
```

Результат:

``` text
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

Если агрегатная функция принимает несколько аргументов, то эта функция должна применяться к нескольким массивам одинакового размера.

Запрос:

``` sql
SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

Результат:

``` text
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

Пример с параметрической агрегатной функцией:

Запрос:

``` sql
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

Результат:

``` text
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```

**Смотрите также**

- [arrayFold](#arrayfold)
## arrayReduceInRanges {#arrayreduceinranges}

Применяет агрегатную функцию к элементам массива в заданных диапазонах и возвращает массив, содержащий результат для каждого диапазона. Функция вернет тот же результат, что и несколько `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

``` sql
arrayReduceInRanges(agg_func, ranges, arr1, arr2, ..., arrN)
```

**Аргументы**

- `agg_func` — Имя агрегатной функции, которое должно быть постоянной [строкой](../data-types/string.md).
- `ranges` — Диапазоны для агрегирования, которые должны быть [массивом](/sql-reference/data-types/array) [кортежей](../data-types/tuple.md), содержащих индекс и длину каждого диапазона.
- `arr` — Любое количество колонок типа [массив](/sql-reference/data-types/array) в качестве параметров агрегатной функции.

**Возвращаемое значение**

- Массив, содержащий результаты агрегатной функции по указанным диапазонам. [Массив](/sql-reference/data-types/array).

**Пример**

Запрос:

``` sql
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

Результат:

``` text
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```
## arrayFold {#arrayfold}

Применяет лямбда-функцию к одному или нескольким массивам одинакового размера и собирает результат в аккумулятор.

**Синтаксис**

``` sql
arrayFold(lambda_function, arr1, arr2, ..., accumulator)
```

**Пример**

Запрос:

``` sql
SELECT arrayFold( acc,x -> acc + x*2,  [1, 2, 3, 4], toInt64(3)) AS res;
```

Результат:

``` text
┌─res─┐
│  23 │
└─────┘
```

**Пример с последовательностью Фибоначчи**

```sql
SELECT arrayFold( acc,x -> (acc.2, acc.2 + acc.1), range(number), (1::Int64, 0::Int64)).1 AS fibonacci
FROM numbers(1,10);

┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**Смотрите также**

- [arrayReduce](#arrayreduce)
## arrayReverse {#arrayreverse}

Возвращает массив такого же размера, как исходный массив, содержащий элементы в обратном порядке.

**Синтаксис**

```sql
arrayReverse(arr)
```

Пример:

``` sql
SELECT arrayReverse([1, 2, 3])
```

``` text
┌─arrayReverse([1, 2, 3])─┐
│ [3,2,1]                 │
└─────────────────────────┘
```
## reverse(arr) {#reversearr}

Синоним для ["arrayReverse"](#arrayreverse)
## arrayFlatten {#arrayflatten}

Преобразует массив массивов в плоский массив.

Функция:

- Применима к любой глубине вложенных массивов.
- Не изменяет, если массивы уже являются плоскими.

Отфильтрованный массив содержит все элементы из всех исходных массивов.

**Синтаксис**

``` sql
flatten(array_of_arrays)
```

Псевдоним: `flatten`.

**Параметры**

- `array_of_arrays` — [Массив](/sql-reference/data-types/array) массивов. Например, `[[1,2,3], [4,5]]`.

**Примеры**

``` sql
SELECT flatten([[[1]], [[2], [3]]]);
```

``` text
┌─flatten(array(array([1]), array([2], [3])))─┐
│ [1,2,3]                                     │
└─────────────────────────────────────────────┘
```
## arrayCompact {#arraycompact}

Удаляет последовательные дубликаты элементов из массива. Порядок значений результата определяется порядком в исходном массиве.

**Синтаксис**

``` sql
arrayCompact(arr)
```

**Аргументы**

`arr` — [массив](/sql-reference/data-types/array) для проверки.

**Возвращаемое значение**

Массив без дубликатов. [Массив](/sql-reference/data-types/array).

**Пример**

Запрос:

``` sql
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

Результат:

``` text
┌─arrayCompact([1, 1, nan, nan, 2, 3, 3, 3])─┐
│ [1,nan,nan,2,3]                            │
└────────────────────────────────────────────┘
```
## arrayZip {#arrayzip}

Объединяет несколько массивов в один массив. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в порядке, указанном в списке аргументов.

**Синтаксис**

``` sql
arrayZip(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Массив](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов. Все входные массивы должны быть одинакового размера.

**Возвращаемое значение**

- Массив с элементами из исходных массивов, сгруппированными в [кортежи](../data-types/tuple.md). Типы данных в кортеже такие же, как и типы входных массивов, и в том же порядке, в котором массивы были переданы. [Массив](/sql-reference/data-types/array).

**Пример**

Запрос:

``` sql
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```


Результат:

``` text
┌─arrayZip(['a', 'b', 'c'], [5, 2, 1])─┐
│ [('a',5),('b',2),('c',1)]            │
└──────────────────────────────────────┘
```
## arrayZipUnaligned {#arrayzipunaligned}

Объединяет несколько массивов в один массив, позволяя использовать не выровненные массивы. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в порядке, указанном в списке аргументов.

**Синтаксис**

``` sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Массив](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов.

**Возвращаемое значение**

- Массив с элементами из исходных массивов, сгруппированными в [кортежи](../data-types/tuple.md). Типы данных в кортеже такие же, как и типы входных массивов, и в том же порядке, в котором массивы были переданы. [Массив](/sql-reference/data-types/array). Если массивы имеют разные размеры, более короткие массивы будут дополнены значениями `null`.

**Пример**

Запрос:

``` sql
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

Результат:

``` text
┌─arrayZipUnaligned(['a'], [1, 2, 3])─┐
│ [('a',1),(NULL,2),(NULL,3)]         │
└─────────────────────────────────────┘
```
## arrayROCAUC {#arrayrocauc}

Вычисляет площадь под кривой операционной характеристики (ROC).
Кривая ROC создается путем построения графика доли истинноположительных срабатываний (TPR) на оси y и доли ложноположительных срабатываний (FPR) на оси x для всех порогов.
Результирующее значение колеблется от 0 до 1, более высокое значение указывает на лучшее качество модели.
ROC AUC (также известная как просто AUC) является понятием в машинном обучении.
Для получения более детальной информации смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

``` sql
arrayROCAUC(arr_scores, arr_labels[, scale[, arr_partial_offsets]])
```

Псевдоним: `arrayAUC`

**Аргументы**

- `arr_scores` — Оценки, которые дает модель прогнозирования. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Чисел с плавающей запятой](../data-types/float.md).
- `arr_labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Перечислений](../data-types/enum.md).
- `scale` — Определяет, следует ли возвращать нормализованную площадь. Если значение false, возвращается площадь под TP (истинно положительными) x FP (ложноположительными) кривая вместо этого. Значение по умолчанию: true. [Bool](../data-types/boolean.md). Необязательный.
- `arr_partial_offsets` — Массив из четырех неотрицательных целых чисел для вычисления частичной площади под кривой ROC (эквивалентно вертикальной полосе пространства ROC) вместо всей AUC. Эта опция полезна для распределенных вычислений ROC AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Массив](/sql-reference/data-types/array) неотрицательных [Целых чисел](../data-types/int-uint.md). Необязательный.
    - `higher_partitions_tp`: Число положительных меток в большей части.
    - `higher_partitions_fp`: Число отрицательных меток в большей части.
    - `total_positives`: Общее количество положительных образцов во всем наборе данных.
    - `total_negatives`: Общее количество отрицательных образцов во всем наборе данных.

::::note
Когда `arr_partial_offsets` используется, `arr_scores` и `arr_labels` должны быть только частью всего набора данных, содержащей интервал оценок.
Набор данных должен быть разделен на смежные части, каждая из которых содержит подмножество данных, оценки которых попадают в определенный диапазон.
Например:
- Одна часть может содержать все оценки в диапазоне [0, 0.5).
- Другая часть может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой операционной характеристики (ROC). [Float64](../data-types/float.md).

**Пример**

Запрос:

``` sql
select arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

Результат:

``` text
┌─arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                                             0.75 │
└──────────────────────────────────────────────────┘
```

## arrayAUCPR {#arrayaucpr}

Вычисляет площадь под кривой точности-призыва (PR). Кривая точности-призыва создается путем построения точности на оси y и призава на оси x для всех порогов. Полученное значение варьируется от 0 до 1, при этом более высокое значение указывает на лучшую производительность модели. PR AUC особенно полезен для несбалансированных наборов данных, обеспечивая более ясное сравнение производительности по сравнению с ROC AUC в таких случаях. Для получения более подробной информации, пожалуйста, см. [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

``` sql
arrayAUCPR(arr_scores, arr_labels[, arr_partial_offsets])
```

Псевдоним: `arrayPRAUC`

**Аргументы**

- `arr_scores` — Оценки, которые дает модель предсказания. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Дробей](../data-types/float.md).
- `arr_labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Перечислений](../data-types/enum.md).
- `arr_partial_offsets` — Необязательный. [Массив](/sql-reference/data-types/array) из трех неотрицательных целых чисел для вычисления частичной площади под кривой PR (эквивалентно вертикальной полосе пространства PR) вместо всей AUC. Эта опция полезна для распределенного вычисления PR AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]. [Массив](/sql-reference/data-types/array) неотрицательных [Целых чисел](../data-types/int-uint.md). Необязательный.
    - `higher_partitions_tp`: Количество положительных меток в более высоких оцененных партициях.
    - `higher_partitions_fp`: Количество отрицательных меток в более высоких оцененных партициях.
    - `total_positives`: Общее количество положительных образцов во всем наборе данных.

::::note
При использовании `arr_partial_offsets`, `arr_scores` и `arr_labels` должны быть только частью всего набора данных, содержащей интервал оценок. Набор данных должен быть разделен на непрерывные партиции, где каждая партиция содержит подмножество данных, оценки которых попадают в определенный диапазон. Например:
- Одна партиция может содержать все оценки в диапазоне [0, 0.5).
- Другая партиция может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой точности-призыва (PR). [Float64](../data-types/float.md).

**Пример**

Запрос:

``` sql
select arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

Результат:

``` text
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```
## arrayMap(func, arr1, ...) {#arraymapfunc-arr1-}

Возвращает массив, полученный из оригинальных массивов путем применения `func(arr1[i], ..., arrN[i])` для каждого элемента. Массивы `arr1` ... `arrN` должны содержать одинаковое количество элементов.

Примеры:

``` sql
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

``` text
┌─res─────┐
│ [3,4,5] │
└─────────┘
```

Следующий пример показывает, как создать кортеж элементов из разных массивов:

``` sql
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

``` text
┌─res─────────────────┐
│ [(1,4),(2,5),(3,6)] │
└─────────────────────┘
```

Обратите внимание, что `arrayMap` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arrayFilter(func, arr1, ...) {#arrayfilterfunc-arr1-}

Возвращает массив, содержащий только элементы в `arr1`, для которых `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0.

Примеры:

``` sql
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

``` text
┌─res───────────┐
│ ['abc World'] │
└───────────────┘
```

``` sql
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

``` text
┌─res─┐
│ [2] │
└─────┘
```

Обратите внимание, что `arrayFilter` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arrayFill(func, arr1, ...) {#arrayfillfunc-arr1-}

Сканирует `arr1` от первого элемента до последнего элемента и заменяет `arr1[i]` на `arr1[i - 1]`, если `func(arr1[i], ..., arrN[i])` возвращает 0. Первый элемент `arr1` не будет заменен.

Примеры:

``` sql
SELECT arrayFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res
```

``` text
┌─res──────────────────────────────┐
│ [1,1,3,11,12,12,12,5,6,14,14,14] │
└──────────────────────────────────┘
```

Обратите внимание, что `arrayFill` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arrayReverseFill(func, arr1, ...) {#arrayreversefillfunc-arr1-}

Сканирует `arr1` от последнего элемента к первому элементу и заменяет `arr1[i]` на `arr1[i + 1]`, если `func(arr1[i], ..., arrN[i])` возвращает 0. Последний элемент `arr1` не будет заменен.

Примеры:

``` sql
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res
```

``` text
┌─res────────────────────────────────┐
│ [1,3,3,11,12,5,5,5,6,14,NULL,NULL] │
└────────────────────────────────────┘
```

Обратите внимание, что `arrayReverseFill` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arraySplit(func, arr1, ...) {#arraysplitfunc-arr1-}

Делит `arr1` на несколько массивов. Когда `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0, массив будет разделен на левой стороне элемента. Массив не будет разделен перед первым элементом.

Примеры:

``` sql
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

``` text
┌─res─────────────┐
│ [[1,2,3],[4,5]] │
└─────────────────┘
```

Обратите внимание, что `arraySplit` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arrayReverseSplit(func, arr1, ...) {#arrayreversesplitfunc-arr1-}

Делит `arr1` на несколько массивов. Когда `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0, массив будет разделен на правой стороне элемента. Массив не будет разделен после последнего элемента.

Примеры:

``` sql
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

``` text
┌─res───────────────┐
│ [[1],[2,3,4],[5]] │
└───────────────────┘
```

Обратите внимание, что `arrayReverseSplit` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arrayExists(\[func,\] arr1, ...) {#arrayexistsfunc-arr1-}

Возвращает 1, если существует хотя бы один элемент в `arr`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0. В противном случае возвращает 0.

Обратите внимание, что `arrayExists` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию ей в качестве первого аргумента.
## arrayAll(\[func,\] arr1, ...) {#arrayallfunc-arr1-}

Возвращает 1, если `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0 для всех элементов массивов. В противном случае возвращает 0.

Обратите внимание, что `arrayAll` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию ей в качестве первого аргумента.
## arrayFirst(func, arr1, ...) {#arrayfirstfunc-arr1-}

Возвращает первый элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0.
## arrayFirstOrNull {#arrayfirstornull}

Возвращает первый элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func, arr1, ...)
```

**Параметры**

- `func`: Лямбда-функция. [Лямбда-функция](/sql-reference/functions/overview#higher-order-functions).
- `arr1`: Массив для обработки. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Первый элемент в переданном массиве.
- В противном случае возвращает `NULL`.

**Подробности реализации**

Обратите внимание, что `arrayFirstOrNull` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.

**Пример**

Запрос:

```sql
SELECT arrayFirstOrNull(x -> x >= 2, [1, 2, 3]);
```

Результат:

```response
2
```

Запрос:

```sql
SELECT arrayFirstOrNull(x -> x >= 2, emptyArrayUInt8());
```

Результат:

```response
\N
```

Запрос:

```sql
SELECT arrayLastOrNull((x,f) -> f, [1,2,3,NULL], [0,1,0,1]);
```

Результат:

```response
\N
```
## arrayLast(func, arr1, ...) {#arraylastfunc-arr1-}

Возвращает последний элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0.

Обратите внимание, что `arrayLast` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arrayLastOrNull {#arraylastornull}

Возвращает последний элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func, arr1, ...)
```

**Параметры**

- `func`: Лямбда-функция. [Лямбда-функция](/sql-reference/functions/overview#higher-order-functions).
- `arr1`: Массив для обработки. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Последний элемент в переданном массиве.
- В противном случае возвращает `NULL`.

**Подробности реализации**

Обратите внимание, что `arrayLastOrNull` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.

**Пример**

Запрос:

```sql
SELECT arrayLastOrNull(x -> x >= 2, [1, 2, 3]);
```

Результат:

```response
3
```

Запрос:

```sql
SELECT arrayLastOrNull(x -> x >= 2, emptyArrayUInt8());
```

Результат:

```response
\N
```
## arrayFirstIndex(func, arr1, ...) {#arrayfirstindexfunc-arr1-}

Возвращает индекс первого элемента в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0.

Обратите внимание, что `arrayFirstIndex` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arrayLastIndex(func, arr1, ...) {#arraylastindexfunc-arr1-}

Возвращает индекс последнего элемента в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то кроме 0.

Обратите внимание, что `arrayLastIndex` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и она не может быть опущена.
## arrayMin {#arraymin}

Возвращает минимум элементов в исходном массиве.

Если функция `func` задана, возвращает минимум элементов, преобразованных этой функцией.

Обратите внимание, что `arrayMin` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayMin([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Минимум значений функции (или минимум массива).

:::note
Если `func` задан, то возвращаемый тип совпадает с типом возвращаемого значения `func`, в противном случае совпадает с типом элементов массива.
:::

**Примеры**

Запрос:

```sql
SELECT arrayMin([1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│   1 │
└─────┘
```

Запрос:

```sql
SELECT arrayMin(x -> (-x), [1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  -4 │
└─────┘
```
## arrayMax {#arraymax}

Возвращает максимум элементов в исходном массиве.

Если функция `func` задана, возвращает максимум элементов, преобразованных этой функцией.

Обратите внимание, что `arrayMax` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayMax([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Максимум значений функции (или максимум массива).

:::note
Если `func` задан, то возвращаемый тип совпадает с типом возвращаемого значения `func`, в противном случае совпадает с типом элементов массива.
:::

**Примеры**

Запрос:

```sql
SELECT arrayMax([1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│   4 │
└─────┘
```

Запрос:

```sql
SELECT arrayMax(x -> (-x), [1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  -1 │
└─────┘
```
## arraySum {#arraysum}

Возвращает сумму элементов в исходном массиве.

Если функция `func` задана, возвращает сумму элементов, преобразованных этой функцией.

Обратите внимание, что `arraySum` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arraySum([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Сумма значений функции (или сумма массива).

:::note
Тип возвращаемого значения:

- Для десятичных чисел в исходном массиве (или для преобразованных значений, если `func` задан) — [Decimal128](../data-types/decimal.md).
- Для чисел с плавающей запятой — [Float64](../data-types/float.md).
- Для беззнаковых чисел — [UInt64](../data-types/int-uint.md). 
- Для_signed чисел — [Int64](../data-types/int-uint.md).
:::

**Примеры**

Запрос:

```sql
SELECT arraySum([2, 3]) AS res;
```

Результат:

```text
┌─res─┐
│   5 │
└─────┘
```

Запрос:

```sql
SELECT arraySum(x -> x*x, [2, 3]) AS res;
```

Результат:

```text
┌─res─┐
│  13 │
└─────┘
```
## arrayAvg {#arrayavg}

Возвращает среднее значение элементов в исходном массиве.

Если функция `func` задана, возвращает среднее значение элементов, преобразованных этой функцией.

Обратите внимание, что `arrayAvg` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayAvg([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Среднее значение значений функции (или среднее значение массива). [Float64](../data-types/float.md).

**Примеры**

Запрос:

```sql
SELECT arrayAvg([1, 2, 4]) AS res;
```

Результат:

```text
┌────────────────res─┐
│ 2.3333333333333335 │
└────────────────────┘
```

Запрос:

```sql
SELECT arrayAvg(x -> (x * x), [2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  10 │
└─────┘
```
## arrayCumSum(\[func,\] arr1, ...) {#arraycumsumfunc-arr1-}

Возвращает массив частичных (текущих) сумм элементов в исходном массиве `arr1`. Если `func` задан, то сумма вычисляется путем применения `func` к `arr1`, `arr2`, ..., `arrN`, то есть `func(arr1[i], ..., arrN[i])`.

**Синтаксис**

``` sql
arrayCumSum(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Возвращает массив частичных сумм элементов в исходном массиве. [UInt*](/sql-reference/data-types/int-uint#integer-ranges), [Int*](/sql-reference/data-types/int-uint#integer-ranges), [Float*](/sql-reference/data-types/float/).

Пример:

``` sql
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

``` text
┌─res──────────┐
│ [1, 2, 3, 4] │
└──────────────┘
```

Обратите внимание, что `arrayCumSum` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.
## arrayCumSumNonNegative(\[func,\] arr1, ...) {#arraycumsumnonnegativefunc-arr1-}

Так же, как `arrayCumSum`, возвращает массив частичных (текущих) сумм элементов в исходном массиве. Если `func` задан, то сумма вычисляется путем применения `func` к `arr1`, `arr2`, ..., `arrN`, то есть `func(arr1[i], ..., arrN[i])`. В отличие от `arrayCumSum`, если текущая текущая сумма меньше 0, она заменяется 0.

**Синтаксис**

``` sql
arrayCumSumNonNegative(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Возвращает массив неотрицательных частичных сумм элементов в исходном массиве. [UInt*](/sql-reference/data-types/int-uint#integer-ranges), [Int*](/sql-reference/data-types/int-uint#integer-ranges), [Float*](/sql-reference/data-types/float/).

``` sql
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

``` text
┌─res───────┐
│ [1,2,0,1] │
└───────────┘
```

Обратите внимание, что `arraySumNonNegative` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.
## arrayProduct {#arrayproduct}

Умножает элементы [массива](/sql-reference/data-types/array).

**Синтаксис**

``` sql
arrayProduct(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Произведение элементов массива. [Float64](../data-types/float.md).

**Примеры**

Запрос:

``` sql
SELECT arrayProduct([1,2,3,4,5,6]) as res;
```

Результат:

``` text
┌─res───┐
│ 720   │
└───────┘
```

Запрос:

``` sql
SELECT arrayProduct([toDecimal64(1,8), toDecimal64(2,8), toDecimal64(3,8)]) as res, toTypeName(res);
```

Тип возвращаемого значения всегда [Float64](../data-types/float.md). Результат:

``` text
┌─res─┬─toTypeName(arrayProduct(array(toDecimal64(1, 8), toDecimal64(2, 8), toDecimal64(3, 8))))─┐
│ 6   │ Float64                                                                                  │
└─────┴──────────────────────────────────────────────────────────────────────────────────────────┘
```
## arrayRotateLeft {#arrayrotateleft}

Вращает [массив](/sql-reference/data-types/array) влево на указанное количество элементов. Если количество элементов отрицательное, массив вращается вправо.

**Синтаксис**

``` sql
arrayRotateLeft(arr, n)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для вращения.

**Возвращаемое значение**

- Массив, вращенный влево на заданное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

``` sql
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

Результат:

``` text
┌─res───────────┐
│ [3,4,5,6,1,2] │
└───────────────┘
```

Запрос:

``` sql
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

Результат:

``` text
┌─res───────────┐
│ [5,6,1,2,3,4] │
└───────────────┘
```

Запрос:

``` sql
SELECT arrayRotateLeft(['a','b','c','d','e'], 3) as res;
```

Результат:

``` text
┌─res───────────────────┐
│ ['d','e','a','b','c'] │
└───────────────────────┘
```
## arrayRotateRight {#arrayrotateright}

Вращает [массив](/sql-reference/data-types/array) вправо на указанное количество элементов. Если количество элементов отрицательное, массив вращается влево.

**Синтаксис**

``` sql
arrayRotateRight(arr, n)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для вращения.

**Возвращаемое значение**

- Массив, вращенный вправо на заданное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

``` sql
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

Результат:

``` text
┌─res───────────┐
│ [5,6,1,2,3,4] │
└───────────────┘
```

Запрос:

``` sql
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

Результат:

``` text
┌─res───────────┐
│ [3,4,5,6,1,2] │
└───────────────┘
```

Запрос:

``` sql
SELECT arrayRotateRight(['a','b','c','d','e'], 3) as res;
```

Результат:

``` text
┌─res───────────────────┐
│ ['c','d','e','a','b'] │
└───────────────────────┘
```
## arrayShiftLeft {#arrayshiftleft}

Сдвигает [массив](/sql-reference/data-types/array) влево на указанное количество элементов. Новые элементы заполняются предоставленным аргументом или значением по умолчанию типа элемента массива. Если количество элементов отрицательное, массив сдвигается вправо.

**Синтаксис**

``` sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига.
- `default` — Необязательно. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

- Массив, сдвинутый влево на заданное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

``` sql
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

Результат:

``` text
┌─res───────────┐
│ [3,4,5,6,0,0] │
└───────────────┘
```

Запрос:

``` sql
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

Результат:

``` text
┌─res───────────┐
│ [0,0,1,2,3,4] │
└───────────────┘
```

Запрос:

``` sql
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

Результат:

``` text
┌─res─────────────┐
│ [3,4,5,6,42,42] │
└─────────────────┘
```

Запрос:

``` sql
SELECT arrayShiftLeft(['a','b','c','d','e','f'], 3, 'foo') as res;
```

Результат:

``` text
┌─res─────────────────────────────┐
│ ['d','e','f','foo','foo','foo'] │
└─────────────────────────────────┘
```

Запрос:

``` sql
SELECT arrayShiftLeft([1,2,3,4,5,6] :: Array(UInt16), 2, 4242) as res;
```

Результат:

``` text
┌─res─────────────────┐
│ [3,4,5,6,4242,4242] │
└─────────────────────┘
```
## arrayShiftRight {#arrayshiftright}

Сдвигает [массив](/sql-reference/data-types/array) вправо на указанное количество элементов. Новые элементы заполняются предоставленным аргументом или значением по умолчанию типа элемента массива. Если количество элементов отрицательное, массив сдвигается влево.

**Синтаксис**

``` sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига.
- `default` — Необязательно. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

- Массив, сдвинутый вправо на заданное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

``` sql
SELECT arrayShiftRight([1,2,3,4,5,6], 2) as res;
```

Результат:

``` text
┌─res───────────┐
│ [0,0,1,2,3,4] │
└───────────────┘
```

Запрос:

``` sql
SELECT arrayShiftRight([1,2,3,4,5,6], -2) as res;
```

Результат:

``` text
┌─res───────────┐
│ [3,4,5,6,0,0] │
└───────────────┘
```

Запрос:

``` sql
SELECT arrayShiftRight([1,2,3,4,5,6], 2, 42) as res;
```

Результат:

``` text
┌─res─────────────┐
│ [42,42,1,2,3,4] │
└─────────────────┘
```

Запрос:

``` sql
SELECT arrayShiftRight(['a','b','c','d','e','f'], 3, 'foo') as res;
```

Результат:

``` text
┌─res─────────────────────────────┐
│ ['foo','foo','foo','a','b','c'] │
└─────────────────────────────────┘
```

Запрос:

``` sql
SELECT arrayShiftRight([1,2,3,4,5,6] :: Array(UInt16), 2, 4242) as res;
```

Результат:

``` text
┌─res─────────────────┐
│ [4242,4242,1,2,3,4] │
└─────────────────────┘
```
## arrayRandomSample {#arrayrandomsample}

Функция `arrayRandomSample` возвращает подмножество из `samples` случайных элементов исходного массива. Если `samples` превышает размер входного массива, размер выборки ограничивается размером массива, т.е. возвращаются все элементы массива, но их порядок не гарантируется. Функция может обрабатывать как плоские массивы, так и вложенные массивы.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

- `arr` — Входной массив, из которого будут выбраны элементы. ([Array(T)](/sql-reference/data-types/array))
- `samples` — Количество элементов, которые следует включить в случайную выборку ([UInt*](../data-types/int-uint.md))

**Возвращаемое значение**

- Массив, содержащий случайную выборку элементов из входного массива. [Array](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

Результат:

```response
┌─res────────────────┐
│ ['cherry','apple'] │
└────────────────────┘
```

Запрос:

```sql
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

Результат:

```response
┌─res───────────┐
│ [[3,4],[5,6]] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRandomSample([1, 2, 3], 5) as res;
```

Результат:

```response
┌─res─────┐
│ [3,1,2] │
└─────────┘
```
## arrayNormalizedGini {#arraynormalizedgini}

Вычисляет нормализованный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

- `predicted` — Предсказанные значения ([Array(T)](/sql-reference/data-types/array))
- `label` — Фактические значения ([Array(T)](/sql-reference/data-types/array))

**Возвращаемое значение**

- Кортеж, содержащий коэффициенты Джини предсказанных значений, коэффициент Джини нормализованных значений и нормализованный коэффициент Джини (= отношение первых двух коэффициентов Джини).

**Примеры**

Запрос:

```sql
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7], [6, 1, 0, 2]);
```

Результат:

```response
┌─arrayNormalizedGini([0.9, 0.3, 0.8, 0.7], [6, 1, 0, 2])──────────┐
│ (0.18055555555555558,0.2638888888888889,0.6842105263157896) │
└─────────────────────────────────────────────────────────────┘
```
## Distance functions {#distance-functions}

Все поддерживаемые функции описаны в [документации по функциям расстояния](../../sql-reference/functions/distance-functions.md).
```

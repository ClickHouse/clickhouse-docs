---
'description': 'Документация для Array Functions'
'sidebar_label': 'Массивы'
'slug': '/sql-reference/functions/array-functions'
'title': 'Массивные функции'
'doc_type': 'reference'
---
# Функции массивов

<!-- 
Содержимое внутри тегов ниже будет заменено во время сборки документа на 
документацию, сгенерированную из system.functions. Пожалуйста, не изменяйте и не удаляйте теги.
См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGЕНЕРИРОВАНО_START-->
## array {#array}

Представлено в: v1.1

Создает массив из аргументов функции.

Аргументы должны быть константами и иметь типы, которые имеют общий супертехнолог. 
Должен быть передан как минимум один аргумент, поскольку в противном случае неясно, какой тип массива создать. 
Это означает, что вы не можете использовать эту функцию для создания пустого массива. Для этого используйте функцию `emptyArray*`.

Используйте оператор `[ ]` для той же функциональности.

**Синтаксис**

```sql
array(x1 [, x2, ..., xN])
```

**Аргументы**

- `x1` — Константное значение любого типа T. Если только этот аргумент предоставлен, массив будет типа T. 
- `[, x2, ..., xN]` — Дополнительные N константных значений, имеющих общий супертехнолог с `x1`.

**Возвращаемое значение**

Возвращает массив, где 'T' — это наименьший общий тип из переданных аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Корректное использование**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**Некорректное использование**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```
## arrayAUCPR {#arrayAUCPR}

Представлено в: v20.4

Вычисляет площадь под кривой точности-полноты (PR).
Кривая точности-полноты создается путем отображения точности по оси Y и полноты по оси X при всех порогах.
Полученное значение варьируется от 0 до 1, при этом более высокое значение указывает на лучшую производительность модели.
PR AUC особенно полезен для несбалансированных наборов данных, предоставляя более четкое сравнение производительности по сравнению с ROC AUC в этих случаях.
Для получения дополнительной информации, пожалуйста, обратитесь [сюда](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [сюда](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [сюда](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**Аргументы**

- `cores` — Оценки, которые дает модель. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Enum)`](/sql-reference/data-types/array)
- `partial_offsets` — 
- Необязательный. Массив [`Array(T)`](/sql-reference/data-types/array) из трех неотрицательных целых чисел для вычисления частичной площади под кривой PR (эквивалентно вертикальной полосе в пространстве PR) вместо всей AUC. Этот параметр полезен для распределенных вычислений PR AUC. Массив должен содержать следующие элементы: [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`].
    - `higher_partitions_tp`: Количество положительных меток в частях с более высокими оценками.
    - `higher_partitions_fp`: Количество отрицательных меток в частях с более высокими оценками.
    - `total_positives`: Общее количество положительных образцов в полном наборе данных.

::::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны быть только частью всего набора данных, содержащей интервал оценок.
Набор данных должен быть разделен на непрерывные части, где каждая часть содержит подмножество данных, оценки которого попадают в конкретный диапазон.
Например:
- Одна часть может содержать все оценки в диапазоне [0, 0.5).
- Другая часть может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой точности-полноты (PR). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```
## arrayAll {#arrayAll}

Представлено в: v1.1

Возвращает `1`, если лямбда-функция `func(x [, y1, y2, ... yN])` возвращает true для всех элементов. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — Необязательные. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает true для всех элементов, `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Все элементы совпадают**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**Не все элементы совпадают**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```
## arrayAvg {#arrayAvg}

Представлено в: v21.1

Возвращает среднее значение элементов в исходном массиве.

Если указана лямбда-функция `func`, возвращает среднее значение элементов результатов лямбды.

**Синтаксис**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательный. Лямбда-функция, которая работает с элементами источника массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательные. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает среднее значение элементов в исходном массиве, или среднее значение элементов результатов лямбды, если она предоставлена. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Основной пример**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```
## arrayCompact {#arrayCompact}

Представлено в: v20.1

Удаляет последовательные дублирующиеся элементы из массива, включая значения `null`. Порядок значений в результирующем массиве определяется порядком в исходном массиве.

**Синтаксис**

```sql
arrayCompact(arr)
```

**Аргументы**

- `arr` — Массив, из которого следует удалить дубликаты. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив без дублирующих значений [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```
## arrayConcat {#arrayConcat}

Представлено в: v1.1

Объединяет массивы, переданные в качестве аргументов.

**Синтаксис**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**Аргументы**

- `arr1 [, arr2, ... , arrN]` — N число массивов для конкатенации. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает единый объединенный массив из предоставленных массивов аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```
## arrayCount {#arrayCount}

Представлено в: v1.1

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает true. 
Если `func` не указана, возвращает количество ненулевых элементов в массиве.

`arrayCount` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayCount([func, ] arr1, ...)
```

**Аргументы**

- `func` — Необязательный. Функция, применяемая к каждому элементу массива(ов). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1, ..., arrN` — N массивов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество элементов, для которых `func` возвращает true. В противном случае возвращает количество ненулевых элементов в массиве. [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```
## arrayCumSum {#arrayCumSum}

Представлено в: v1.1

Возвращает массив частичных (поточечных) сумм элементов в исходном массиве. Если указана лямбда-функция, сумма вычисляется путем применения лямбды к элементам массива на каждой позиции.

**Синтаксис**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

- `func` — Необязательный. Лямбда-функция, применяемая к элементам массива на каждой позиции. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — Исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — Необязательные. Дополнительные массивы того же размера, переданные в качестве аргументов лямбда-функции, если указана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов в исходном массиве. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Основное использование**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**С лямбдой**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```
## arrayCumSumNonNegative {#arrayCumSumNonNegative}

Представлено в: v18.12

Возвращает массив частичных (поточечных) сумм элементов в исходном массиве, заменяя любые отрицательные поточные суммы на ноль. Если указана лямбда-функция, сумма вычисляется путем применения лямбды к элементам массива на каждой позиции.

**Синтаксис**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

- `func` — Необязательный. Лямбда-функция, применяемая к элементам массива на каждой позиции. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — Исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — Необязательные. Дополнительные массивы того же размера, переданные в качестве аргументов лямбда-функции, если указана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов в исходном массиве, при этом любые отрицательные поточные суммы заменяются на ноль. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Основное использование**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**С лямбдой**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```
## arrayDifference {#arrayDifference}

Представлено в: v1.1

Вычисляет массив разностей между смежными элементами массива.
Первый элемент результирующего массива будет равен 0, второй `arr[1] - arr[0]`, третий `arr[2] - arr[1]` и т.д.
Тип элементов результирующего массива определяется правилами вывода типов для вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

```sql
arrayDifference(arr)
```

**Аргументы**

- `arr` — Массив, для которого нужно вычислить разности между смежными элементами. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив разностей между смежными элементами массива [`UInt*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**Пример переполнения из-за типа результата Int64**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```
## arrayDistinct {#arrayDistinct}

Представлено в: v1.1

Возвращает массив, содержащий только уникальные элементы массива.

**Синтаксис**

```sql
arrayDistinct(arr)
```

**Аргументы**

- `arr` — Массив, для которого необходимо извлечь уникальные элементы. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, содержащий уникальные элементы [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```
## arrayDotProduct {#arrayDotProduct}

Представлено в: v23.5

Возвращает скалярное произведение двух массивов.

:::note
Размеры двух векторов должны быть равны. Массивы и кортежи также могут содержать смешанные типы элементов.
:::

**Синтаксис**

```sql
arrayDotProduct(v1, v2)
```

**Аргументы**

- `v1` — Первый вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
- `v2` — Второй вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**Возвращаемое значение**

Скалярное произведение двух векторов.

:::note
Тип возвращаемого значения определяется типом аргументов. Если массивы или кортежи содержат смешанные типы элементов, то тип результата является супертехнологом.
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Примеры**

**Пример массива**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**Пример кортежа**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```
## arrayElement {#arrayElement}

Представлено в: v1.1

Получает элемент предоставленного массива с индексом `n`, где `n` может быть любого типа целого числа.
Если индекс выходит за пределы массива, возвращается значение по умолчанию (0 для чисел, пустая строка для строк и т.д.),
за исключением аргументов непостоянного массива и постоянного индекса 0. В этом случае будет ошибка `Индексы массива начинаются с 1`.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Отрицательные индексы поддерживаются. В этом случае выбирается соответствующий элемент, нумеруемый с конца. Например, `arr[-1]` — последний элемент в массиве.

Оператор `[n]` предоставляет ту же функциональность.

**Синтаксис**

```sql
arrayElement(arr, n)
```

**Аргументы**

- `arr` — Массив для поиска. [`Array(T)`](/sql-reference/data-types/array). 
- `n` — Позиция элемента, который нужно получить. [`(U)Int*`](/sql-reference/data-types/int-uint). 

**Возвращаемое значение**

Возвращает отдельный комбинированный массив из предоставленных массивов аргументов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Отрицательная индексация**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**Использование [n] нотации**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Индекс вышел за пределы массива**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```
## arrayElementOrNull {#arrayElementOrNull}

Представлено в: v1.1

Получает элемент предоставленного массива с индексом `n`, где `n` может быть любого типа целого числа.
Если индекс выходит за пределы массива, возвращается `NULL` вместо значения по умолчанию.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Отрицательные индексы поддерживаются. В этом случае выбирается соответствующий элемент, нумеруемый с конца. Например, `arr[-1]` — последний элемент в массиве.

**Синтаксис**

```sql
arrayElementOrNull(arrays)
```

**Аргументы**

- `arrays` — Произвольное количество массивных аргументов. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает отдельный комбинированный массив из предоставленных массивов аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Отрицательная индексация**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**Индекс вышел за пределы массива**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```
## arrayEnumerate {#arrayEnumerate}

Представлено в: v1.1

Возвращает массив `[1, 2, 3, ..., length(arr)]`

Эта функция обычно используется с клаузой [`ARRAY JOIN`](/sql-reference/statements/select/array-join). Она позволяет подсчитывать что-либо только
один раз для каждого массива после применения `ARRAY JOIN`.
Эта функция также может использоваться в функциях высшего порядка. Например, вы можете использовать ее для получения индексов массива для элементов, которые соответствуют условию.

**Синтаксис**

```sql
arrayEnumerate(arr)
```

**Аргументы**

- `arr` — Массив для перечисления. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив `[1, 2, 3, ..., length(arr)]`. [`Array(UInt32)`](/sql-reference/data-types/array)

**Примеры**

**Основной пример с ARRAY JOIN**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```
## arrayEnumerateDense {#arrayEnumerateDense}

Представлено в: v18.12

Возвращает массив такого же размера, как исходный массив, указывая, где каждый элемент первый раз появляется в исходном массиве.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Аргументы**

- `arr` — Массив для перечисления. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив такого же размера, как `arr`, указывая, где каждый элемент впервые появляется в исходном массиве [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```
## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

Представлено в: v20.1

Возвращает массив того же размера, что исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве. Это позволяет перечислять многомерный массив с возможностью указать, насколько глубоко искать внутри массива.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

- `clear_depth` — Перечислить элементы на указанном уровне отдельно. Должно быть меньше или равно `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — N-мерный массив для перечисления. [`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — Максимальная эффективная глубина. Должна быть меньше или равна глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив, указывающий, где каждый элемент впервые появляется в исходном массиве [`Array`](/sql-reference/data-types/array)

**Примеры**

**Основное использование**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result is identical to what arrayEnumerateDense would give.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**Использование с многомерным массивом**

```sql title=Query
-- In this example, arrayEnumerateDenseRanked is used to obtain an array indicating, for each element of the
-- multidimensional array, what its position is among elements of the same value.
-- For the first row of the passed array, [10, 10, 30, 20], the corresponding first row of the result is [1, 1, 2, 3],
-- indicating that 10 is the first number encountered in position 1 and 2, 30 the second number encountered in position 3
-- and 20 is the third number encountered in position 4.
-- For the second row, [40, 50, 10, 30], the corresponding second row of the result is [4,5,1,2], indicating that 40
-- and 50 are the fourth and fifth numbers encountered in position 1 and 2 of that row, that another 10
-- (the first encountered number) is in position 3 and 30 (the second number encountered) is in the last position.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**Пример с увеличенной clear_depth**

```sql title=Query
-- Changing clear_depth=2 results in the enumeration occurring separately for each row anew.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```
## arrayEnumerateUniq {#arrayEnumerateUniq}

Представлено в: v1.1

Возвращает массив того же размера, что исходный массив, указывая для каждого элемента его позицию среди элементов с тем же значением.

Эта функция полезна при использовании `ARRAY JOIN` и агрегации элементов массива.

Функция может принимать несколько массивов одинакового размера в качестве аргументов. В этом случае уникальность рассматривается для кортежей элементов в одинаковых позициях во всех массивах.

**Синтаксис**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**Аргументы**

- `arr1` — Первый массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `arr2, ...` — Необязательные. Дополнительные массивы того же размера для уникальности кортежей. [`Array(UInt32)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, где каждый элемент — это позиция среди элементов с тем же значением или кортежем. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Основное использование**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**Несколько массивов**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**Агрегация ARRAY JOIN**

```sql title=Query
-- Each goal ID has a calculation of the number of conversions (each element in the Goals nested data structure is a goal that was reached, which we refer to as a conversion)
-- and the number of sessions. Without ARRAY JOIN, we would have counted the number of sessions as sum(Sign). But in this particular case,
-- the rows were multiplied by the nested Goals structure, so in order to count each session one time after this, we apply a condition to the
-- value of the arrayEnumerateUniq(Goals.ID) function.

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```
## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

Представлено в: v20.1

Возвращает массив (или многомерный массив) с теми же размерами, что и исходный массив,
указывая для каждого элемента его позицию среди элементов с тем же значением.
Это позволяет перечислять многомерный массив с возможностью указать, насколько глубоко искать внутри массива.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

- `clear_depth` — Перечислить элементы на указанном уровне отдельно. Положительное целое число, меньшее или равное `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — N-мерный массив для перечисления. [`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — Максимальная эффективная глубина. Положительное целое число, меньшее или равное глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает N-мерный массив того же размера, что и `arr`, каждый элемент которого показывает позицию этого элемента относительно других элементов с тем же значением. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniq would give for the same array.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**Пример 2**

```sql title=Query
-- with clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniqwould give for the same array.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**Пример 3**

```sql title=Query
-- In this example, arrayEnumerateUniqRanked is used to obtain an array indicating,
-- for each element of the multidimensional array, what its position is among elements
-- of the same value. For the first row of the passed array, [1, 2, 3], the corresponding
-- result is [1, 1, 1], indicating that this is the first time 1, 2 and 3 are encountered.
-- For the second row of the provided array, [2, 2, 1], the corresponding result is [2, 3, 3],
-- indicating that 2 is encountered for a second and third time, and 1 is encountered
-- for the second time. Likewise, for the third row of the provided array [3] the
-- corresponding result is [2] indicating that 3 is encountered for the second time.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**Пример 4**

```sql title=Query
-- Changing clear_depth=2, results in elements being enumerated separately for each row.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```
## arrayExcept {#arrayExcept}

Представлено в: v25.9

Возвращает массив, содержащий элементы из `source`, которые отсутствуют в `except`, сохраняя оригинальный порядок.

Эта функция выполняет операцию разности множеств между двумя массивами. Для каждого элемента в `source` она проверяет, существует ли элемент в `except` (используя точное сравнение). Если нет, элемент включается в результат.

Операция сохраняет следующие свойства:
1. Порядок элементов из `source` сохраняется.
2. Дубликаты в `source` сохраняются, если они отсутствуют в `except`.
3. NULL рассматривается как отдельное значение.

**Синтаксис**

```sql
arrayExcept(source, except)
```

**Аргументы**

- `source` — Исходный массив, содержащий элементы для фильтрации.  [`Array(T)`](/sql-reference/data-types/array)
- `except` — Массив, содержащий элементы для исключения из результата.  [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же типа, что и входной массив, содержащий элементы из `source`, которые не были найдены в `except`.  [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**основной**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**с_nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**с_nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**строки**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```
## arrayExists {#arrayExists}

Представлено в: v1.1

Возвращает `1`, если существует хотя бы один элемент в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательные. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает true для хотя бы одного элемента, `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```
## arrayFill {#arrayFill}

Представлено в: v20.1

Функция `arrayFill` последовательно обрабатывает исходный массив с первого элемента
до последнего, оценивая условие лямбды на каждой позиции с использованием элементов из
исходного и условных массивов. Когда лямбда-функция оценивается как ложная на
позиции i, функция заменяет этот элемент на элемент на позиции i-1
из текущего состояния массива. Первый элемент всегда сохраняется
независимо от условий.

**Синтаксис**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x [, y1, ..., yN])` — Лямбда-функция `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `[, cond1_arr, ... , condN_arr]` — Необязательные. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**Пример с двумя массивами**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```
## arrayFilter {#arrayFilter}

Представлено в: v1.1

Возвращает массив, содержащий только элементы исходного массива, для которых возвращает true лямбда-функция.

**Синтаксис**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательные. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает подмножество исходного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**Пример 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```
## arrayFirst {#arrayFirst}

Представлено в: v1.1

Возвращает первый элемент в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true, иначе возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). 
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). 
- `[, cond1_arr, ... , condN_arr]` — Необязательные. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array). 

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `λ` истинен, иначе возвращает значение по умолчанию для `T`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**Нет совпадения**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```
## arrayFirstIndex {#arrayFirstIndex}

Представлено в: v1.1

Возвращает индекс первого элемента в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true, иначе возвращает '0'.

**Синтаксис**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). 
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). 
- `[, cond1_arr, ... , condN_arr]` — Необязательные. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array). 

**Возвращаемое значение**

Возвращает индекс первого элемента исходного массива, для которого `func` истинен, в противном случае возвращает `0` [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**Нет совпадения**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```
## arrayFirstOrNull {#arrayFirstOrNull}

Представлено в: v1.1

Возвращает первый элемент в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true, иначе возвращает `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательные. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `func` истинен, иначе возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**Нет совпадения**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```
## arrayFlatten {#arrayFlatten}

Представлено в: v20.1

Преобразует многомерный массив в плоский массив.

Функция:

- Применяется к массивам вложенной глубины.
- Не изменяет массивы, которые уже плоские.

Плоский массив содержит все элементы из всех исходных массивов.

**Синтаксис**

```sql
arrayFlatten(arr)
```

**Аргументы**

- `arr` — Многомерный массив. [`Array(Array(T))`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает плоский массив из многомерного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```
## arrayFold {#arrayFold}

Представлено в: v23.10

Применяет лямбда-функцию к одному или нескольким массивам одинакового размера и собирает результат в аккумулятор.

**Синтаксис**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**Аргументы**

- `λ(x, x1 [, x2, x3, ... xN])` — Лямбда-функция `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`, где `F` — это операция, применяемая к `acc` и значениям массива `x` с результатом `acc`, который переиспользуется. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1 [, arr2, arr3, ... arrN]` — N массивов, над которыми нужно работать. [`Array(T)`](/sql-reference/data-types/array)
- `acc` — Значение аккумулятора того же типа, что и возвращаемый тип лямбда-функции.

**Возвращаемое значение**

Возвращает итоговое значение `acc`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**Последовательность Фибоначчи**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**Пример с использованием нескольких массивов**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```
## arrayIntersect {#arrayIntersect}

Представлено в: v1.1

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**Аргументы**

- `arrN` — N массивов, из которых следует создать новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив с различными элементами, которые присутствуют во всех N массивах. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```
## arrayJaccardIndex {#arrayJaccardIndex}

Представлено в: v23.7

Возвращает [индекс Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) двух массивов.

**Синтаксис**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**Аргументы**

- `arr_x` — Первый массив. [`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — Второй массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс Жаккара для `arr_x` и `arr_y`. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```
## arrayJoin {#arrayJoin}

Введено в: v1.1

Функция `arrayJoin` принимает строку, содержащую массив, и "разворачивает" её, генерируя несколько строк — по одной для каждого элемента в массиве. Это контрастирует с регулярными функциями в ClickHouse, которые сопоставляют входные значения с выходными значениями в одной строке, и агрегатными функциями, которые берут группу строк и "сжимают" или "уменьшают" их в одну сводную строку (или одно значение внутри сводной строки, если используется с `GROUP BY`).

Все значения в столбцах просто копируются, за исключением значений в столбце, где применяется эта функция; эти значения заменяются соответствующим значением массива.

**Синтаксис**

```sql
arrayJoin(arr)
```

**Аргументы**

- `arr` — Массив для разворачивания. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает набор строк, развернутых из `arr`.

**Примеры**

**Основное использование**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin влияет на все секции запроса**

```sql title=Query
-- The arrayJoin function affects all sections of the query, including the WHERE section. Notice the result 2, even though the subquery returned 1 row.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**Использование нескольких функций arrayJoin**

```sql title=Query
- A query can use multiple arrayJoin functions. In this case, the transformation is performed multiple times and the rows are multiplied.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**Неожиданность результатов из-за оптимизаций**

```sql title=Query
-- Using multiple arrayJoin with the same expression may not produce the expected result due to optimizations.
-- For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.
- e.g. arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set
    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```

```response title=Response
┌─first_throw─┬─second_throw─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**Использование синтаксиса ARRAY JOIN**

```sql title=Query
-- Note the ARRAY JOIN syntax in the `SELECT` query below, which provides broader possibilities.
-- ARRAY JOIN allows you to convert multiple arrays with the same number of elements at a time.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Использование Tuple**

```sql title=Query
-- You can also use Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

## arrayLast {#arrayLast}

Введено в: v1.1

Возвращает последний элемент в исходном массиве, для которого лямбда `func(x [, y1, y2, ... yN])` возвращает true, в противном случае возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1, ... , condN]` — Необязательно. N условных массивов, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого `func` истинно, в противном случае возвращает значение по умолчанию для `T`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**Нет совпадения**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```

## arrayLastIndex {#arrayLastIndex}

Введено в: v1.1

Возвращает индекс последнего элемента в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true, в противном случае возвращает '0'.

**Синтаксис**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N условных массивов, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс последнего элемента исходного массива, для которого `func` истинно, в противном случае возвращает `0` [`UInt32`](/sql-reference/data-types/int-uint).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**Нет совпадения**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```

## arrayLastOrNull {#arrayLastOrNull}

Введено в: v1.1

Возвращает последний элемент в исходном массиве, для которого лямбда `func(x [, y1, y2, ... yN])` возвращает true, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x [, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N условных массивов, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого `λ` не истинен, в противном случае возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**Нет совпадения**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```

## arrayLevenshteinDistance {#arrayLevenshteinDistance}

Введено в: v25.4

Вычисляет расстояние Левенштейна для двух массивов.

**Синтаксис**

```sql
arrayLevenshteinDistance(from, to)
```

**Аргументы**

- `from` — Первый массив. [`Array(T)`](/sql-reference/data-types/array).
- `to` — Второй массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```

## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

Введено в: v25.4

Вычисляет расстояние Левенштейна для двух массивов с пользовательскими весами для каждого элемента. Количество элементов в массиве и его веса должны совпадать.

**Синтаксис**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**Аргументы**

- `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array).
- `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array).
- `from_weights` — веса для первого массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — веса для второго массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами с пользовательскими весами для каждого элемента [`Float64`](/sql-reference/data-types/float).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```

## arrayMap {#arrayMap}

Введено в: v1.1

Возвращает массив, полученный из оригинальных массивов путём применения лямбда-функции к каждому элементу.

**Синтаксис**

```sql
arrayMap(func, arr)
```

**Аргументы**

- `func` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `arr` — N массивов для обработки. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив из результатов лямбды [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**Создание кортежа элементов из различных массивов**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```

## arrayMax {#arrayMax}

Введено в: v21.1

Возвращает максимальный элемент в исходном массиве.

Если указана лямбда-функция `func`, возвращает максимальный элемент результатов лямбды.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательно. Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N условных массивов, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает максимальный элемент в исходном массиве, или максимальный элемент результатов лямбды, если предоставлена.

**Примеры**

**Основной пример**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```

## arrayMin {#arrayMin}

Введено в: v21.1

Возвращает минимальный элемент в исходном массиве.

Если указана лямбда-функция `func`, возвращает минимальный элемент результатов лямбды.

**Синтаксис**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательно. Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `cond1_arr, ...` — Необязательно. N условных массивов, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает минимальный элемент в исходном массиве, или минимальный элемент результатов лямбды, если предоставлен.

**Примеры**

**Основной пример**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```

## arrayNormalizedGini {#arrayNormalizedGini}

Введено в: v25.1

Вычисляет нормализованный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

- `predicted` — Предсказанное значение. [`Array(T)`](/sql-reference/data-types/array)
- `label` — Фактическое значение. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Кортеж, содержащий коэффициенты Джини предсказанных значений, коэффициент Джини нормализованных значений и нормализованный коэффициент Джини (= отношение первых двух коэффициентов Джини) [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```

## arrayPartialReverseSort {#arrayPartialReverseSort}

Введено в: v23.2

Эта функция аналогична `arrayReverseSort`, но с дополнительным аргументом `limit`, позволяющим частичную сортировку.

:::tip
Чтобы оставить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

- `f(arr[, arr1, ... ,arrN])` — Лямбда-функция, которую нужно применить к элементам массива `x`. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `arr` — Массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array).
- `arr1, ... ,arrN` — N дополнительных массивов, если `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array).
- `limit` — Значение индекса, до которого будет произведена сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Возвращает массив того же размера, что и оригинальный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке убывания. Остальные элементы `(limit..N]` находятся в неопределенном порядке.

**Примеры**

**simple_int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple_string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain_sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda_simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda_complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```

## arrayPartialShuffle {#arrayPartialShuffle}

Введено в: v23.2

Возвращает массив того же размера, что и оригинальный массив, где элементы в диапазоне `[1..limit]` являются случайным подмножеством оригинального массива. Оставшиеся элементы `(limit..n]` содержат элементы, не входящие в диапазон `[1..limit]`, в неопределенном порядке. Значение ограничения должно находиться в диапазоне `[1..n]`. Значения за пределами этого диапазона эквивалентны выполнению полной `arrayShuffle`:

:::note
Эта функция не будет материализовать константы.

Значение `limit` должно находиться в диапазоне `[1..N]`. Значения вне этого диапазона эквивалентны выполнению полной [`arrayShuffle`](#arrayShuffle).
:::

**Синтаксис**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**Аргументы**

- `arr` — Массив для перетасовки. [`Array(T)`](/sql-reference/data-types/array).
- `seed` — Необязательно. Семя, которое будет использоваться для генерации случайных чисел. Если не предоставлено, используется случайное. [`(U)Int*`](/sql-reference/data-types/int-uint).
- `limit` — Необязательно. Число, ограничивающее обмен элементами, в диапазоне `[1..N]`. [`(U)Int*`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив с частично перемешанными элементами. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**no_limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no_limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random_seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit_seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```

## arrayPartialSort {#arrayPartialSort}

Введено в: v23.2

Эта функция аналогична `arraySort`, но с дополнительным аргументом `limit`, позволяющим частичную сортировку.

:::tip
Чтобы оставить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

- `f(arr[, arr1, ... ,arrN])` — Лямбда-функция, которую нужно применить к элементам массива `x`. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `arr` — Массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array).
- `arr1, ... ,arrN` — N дополнительных массивов, если `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array).
- `limit` — Значение индекса, до которого будет произведена сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Возвращает массив того же размера, что и оригинальный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке возрастания. Остальные элементы `(limit..N]` находятся в неопределенном порядке.

**Примеры**

**simple_int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple_string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain_sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda_simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda_complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```

## arrayPopBack {#arrayPopBack}

Введено в: v1.1

Удаляет последний элемент из массива.

**Синтаксис**

```sql
arrayPopBack(arr)
```

**Аргументы**

- `arr` — Массив, из которого нужно удалить последний элемент. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но без последнего элемента `arr` [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```

## arrayPopFront {#arrayPopFront}

Введено в: v1.1

Удаляет первый элемент из массива.

**Синтаксис**

```sql
arrayPopFront(arr)
```

**Аргументы**

- `arr` — Массив, из которого нужно удалить первый элемент. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но без первого элемента `arr` [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```

## arrayProduct {#arrayProduct}

Введено в: v21.1

Возвращает произведение элементов в исходном массиве.

Если указана лямбда-функция `func`, возвращает произведение элементов результатов лямбды.

**Синтаксис**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Необязательно. Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N условных массивов, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает произведение элементов в исходном массиве, или произведение элементов результатов лямбды, если предоставлено. [`Float64`](/sql-reference/data-types/float).

**Примеры**

**Основной пример**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```

## arrayPushBack {#arrayPushBack}

Введено в: v1.1

Добавляет один элемент в конец массива.

**Синтаксис**

```sql
arrayPushBack(arr, x)
```

**Аргументы**

- `arr` — Массив, в который нужно добавить значение `x` в конец. [`Array(T)`](/sql-reference/data-types/array).
- `x` — 
  - Единственное значение, которое нужно добавить в конец массива. [`Array(T)`](/sql-reference/data-types/array).

:::note
- Только числа можно добавлять в массив с числами, и только строки можно добавлять в массив строк.
- При добавлении чисел ClickHouse автоматически устанавливает тип `x` в соответствии с типом данных массива.
- Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

Для получения дополнительной информации о типах данных в ClickHouse смотрите [Типы данных](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с дополнительным значением `x` в конце массива [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```

## arrayPushFront {#arrayPushFront}

Введено в: v1.1

Добавляет один элемент в начало массива.

**Синтаксис**

```sql
arrayPushFront(arr, x)
```

**Аргументы**

- `arr` — Массив, в который нужно добавить значение `x` в начало. [`Array(T)`](/sql-reference/data-types/array).
- `x` — 
  - Единственное значение, которое нужно добавить в начало массива. [`Array(T)`](/sql-reference/data-types/array).

:::note
- Только числа можно добавлять в массив с числами, и только строки можно добавлять в массив строк.
- При добавлении чисел ClickHouse автоматически устанавливает тип `x` в соответствии с типом данных массива.
- Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

Для получения дополнительной информации о типах данных в ClickHouse смотрите [Типы данных](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с дополнительным значением `x` в начале массива [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```

## arrayROCAUC {#arrayROCAUC}

Введено в: v20.4

Вычисляет площадь под кривой характеристики оператора приемника (ROC).
ROC-кривая создаётся путём построения доли истинных положительных (TPR) на оси y и доли ложных положительных (FPR) на оси x по всем порогам. Полученное значение варьируется от нуля до единицы, при этом более высокое значение указывает на лучшую производительность модели.

ROC AUC (также известная просто как AUC) — это концепция в машинном обучении. 
Для получения дополнительной информации смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**Аргументы**

- `scores` — Оценки, которые предсказательная модель выдает. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array).
- `labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Enum`](/sql-reference/data-types/enum).
- `scale` — Необязательно. Определяет, возвращать ли нормализованную площадь. Если false, возвращает площадь под кривой TP (истинные положительные) x FP (ложные положительные). Значение по умолчанию: true. [`Bool`](/sql-reference/data-types/boolean).
- `partial_offsets` — 
  - Массив из четырёх неотрицательных целых чисел для вычисления частичной площади под кривой ROC (эквивалентно вертикальной полосе в пространстве ROC), вместо всей AUC. Этот параметр полезен для распределённого вычисления ROC AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) неотрицательных [целых чисел](../data-types/int-uint.md). Необязательно.
    - `higher_partitions_tp`: Количество положительных меток в разделах с более высоким рейтингом.
    - `higher_partitions_fp`: Количество отрицательных меток в разделах с более высоким рейтингом.
    - `total_positives`: Общее количество положительных образцов в полном наборе данных.
    - `total_negatives`: Общее количество отрицательных образцов в полном наборе данных.

::::note
При использовании `arr_partial_offsets`, `arr_scores` и `arr_labels` должны быть лишь частью полного набора данных, содержащей интервал оценок. Набор данных должен быть разделён на смежные разделы, где каждый раздел содержит подмножество данных, оценки которых попадают в определённый диапазон. 
Например:
- Один раздел может содержать все оценки в диапазоне [0, 0.5).
- Другой раздел может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой характеристик оператора приемника (ROC). [`Float64`](/sql-reference/data-types/float).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```

## arrayRandomSample {#arrayRandomSample}

Введено в: v23.10

Возвращает подмножество с `samples`-м количеством случайных элементов из входного массива. Если `samples` превышает размер входного массива, размер выборки ограничивается размером массива, т.е. все элементы массива возвращаются, но их порядок не гарантируется. Функция может обрабатывать как плоские массивы, так и вложенные массивы.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

- `arr` — Входной массив или многомерный массив, из которого нужно взять элементы. [`Array(T)`](/sql-reference/data-types/array).
- `samples` — Количество элементов, которые нужно включить в случайную выборку. [`(U)Int*`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, содержащий случайную выборку элементов из входного массива [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**Использование многомерного массива**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```

## arrayReduce {#arrayReduce}

Введено в: v1.1

Применяет агрегатную функцию к элементам массива и возвращает её результат. Название агрегатной функции передаётся как строка в одинарных кавычках `'max'`, `'sum'`. При использовании параметрических агрегатных функций параметр указывается после имени функции в скобках `'uniqUpTo(6)'`.

**Синтаксис**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**Аргументы**

- `agg_f` — Название агрегатной функции, которая должна быть константой. [`String`](/sql-reference/data-types/string).
- `arr1 [, arr2, ... , arrN)]` — N массивов, соответствующих аргументам `agg_f`. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает результат агрегатной функции.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**Пример с агрегатной функцией, использующей несколько аргументов**

```sql title=Query
--If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**Пример с параметрической агрегатной функцией**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```

## arrayReduceInRanges {#arrayReduceInRanges}

Введено в: v20.4

Применяет агрегатную функцию к элементам массива в заданных диапазонах и возвращает массив, содержащий результат, соответствующий каждому диапазону. Функция вернёт тот же результат, что и несколько `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**Аргументы**

- `agg_f` — Название агрегатной функции, которую следует использовать. [`String`](/sql-reference/data-types/string).
- `ranges` — Диапазон, по которому будет производиться агрегация. Массив кортежей, `(i, r)`, содержащих индекс `i`, с которого начинать, и диапазон `r` для агрегации. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T)`](/sql-reference/data-types/tuple).
- `arr1 [, arr2, ... ,arrN)]` — N массивов в качестве аргументов для агрегатной функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив, содержащий результаты агрегатной функции по указанным диапазонам [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```

## arrayResize {#arrayResize}

Введено в: v1.1

Изменяет длину массива.

**Синтаксис**

```sql
arrayResize(arr, size[, extender])
```

**Аргументы**

- `arr` — Массив для изменения размера. [`Array(T)`](/sql-reference/data-types/array).
- `size` — 
  - Новая длина массива. Если `size` меньше исходного размера массива, массив обрезается справа. Если `size` больше исходного размера массива, массив расширяется вправо с помощью значений `extender` или значений по умолчанию для типа данных элементов массива.
- `extender` — Значение для использования при расширении массива. Может быть `NULL`.

**Возвращаемое значение**

Массив длины `size`. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**Пример 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```

## arrayReverse {#arrayReverse}

Введено в: v1.1

Обращает порядок элементов данного массива.

:::note
Функция `reverse(arr)` выполняет ту же функциональность, но работает с другими типами данных, помимо массивов.
:::

**Синтаксис**

```sql
arrayReverse(arr)
```

**Аргументы**

- `arr` — Массив для реверсирования. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив такого же размера, как оригинальный массив, содержащий элементы в обратном порядке [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```

## arrayReverseFill {#arrayReverseFill}

Введено в: v20.1

Функция `arrayReverseFill` последовательно обрабатывает исходный массив с конца до начала, оценивая лямбда-условие на каждой позиции, используя элементы из исходного и условных массивов. Когда условие оценивается как ложное на позиции i, функция заменяет этот элемент на элемент в позиции i+1 из текущего состояния массива. Последний элемент всегда сохраняется независимо от любых условий.

**Синтаксис**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N условных массивов, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив, элементы которого исходного массива заменены результатами лямбды. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример с одним массивом**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**Пример с двумя массивами**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```

## arrayReverseSort {#arrayReverseSort}

Введено в: v1.1

Сортирует элементы массива в порядке убывания. Если указана функция `f`, переданный массив сортируется в соответствии с результатом функции, применённой к элементам массива, после чего отсортированный массив обращается. Если `f` принимает несколько аргументов, функции `arrayReverseSort` передаётся несколько массивов, которые будут соответствовать аргументам `func`.

Если массив для сортировки содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**Аргументы**

- `f(y1[, y2 ... yN])` — Лямбда-функция, которую нужно применить к элементам массива `x`.
- `arr` — Массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array).
- `arr1, ..., yN` — Необязательно. N дополнительных массивов, если `f` принимает несколько аргументов.

**Возвращаемое значение**

Возвращает массив `x`, отсортированный в порядке убывания, если лямбда-функция не предоставлена, в противном случае возвращает массив, отсортированный согласно логике предоставленной лямбда-функции, и затем обратный. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**Пример 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```

## arrayReverseSplit {#arrayReverseSplit}

Введено в: v20.1

Разделяет исходный массив на несколько массивов. Когда `func(x[, y1, ..., yN])` возвращает что-то, отличное от нуля, массив будет разделён справа от элемента. Массив не будет разделён после последнего элемента.

**Синтаксис**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и условными массивами (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — Исходный массив для обработки. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `[, cond1_arr, ... , condN_arr]` — Необязательно. N условных массивов, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив массивов. [`Array(Array(T))`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```

## arrayRotateLeft {#arrayRotateLeft}

Введено в: v23.8

Поворачивает массив влево на указанное количество элементов. Отрицательные значения `n` рассматриваются как поворот вправо на абсолютное значение поворота.

**Синтаксис**

```sql
arrayRotateLeft(arr, n)
```

**Аргументы**

- `arr` — Массив, элементы которого нужно повернуть. [`Array(T)`](/sql-reference/data-types/array).
- `n` — Количество элементов, на которое нужно повернуть. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, повернутый влево на указанное количество элементов [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

## arrayRotateRight {#arrayRotateRight}

Введено в: v23.8

Поворачивает массив вправо на указанное количество элементов. Отрицательные значения `n` рассматриваются как поворот влево на абсолютное значение поворота.

**Синтаксис**

```sql
arrayRotateRight(arr, n)
```

**Аргументы**

- `arr` — Массив, элементы которого нужно повернуть. [`Array(T)`](/sql-reference/data-types/array).
- `n` — Количество элементов, на которое нужно повернуть. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, повернутый вправо на указанное количество элементов [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```
## arrayShiftLeft {#arrayShiftLeft}

Представлено в: v23.8

Сдвигает массив влево на указанное количество элементов. Новые элементы заполняются предоставленным аргументом или значением по умолчанию для типа элемента массива. Если количество элементов отрицательно, массив сдвигается вправо.

**Синтаксис**

```sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

- `arr` — Массив, элементы которого нужно сдвинуть. [`Array(T)`](/sql-reference/data-types/array). 
- `n` — Количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). 
- `default` — Опционально. Значение по умолчанию для новых элементов. 

**Возвращаемое значение**

Массив, сдвинутый влево на указанное количество элементов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**Использование значения по умолчанию**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```

## arrayShiftRight {#arrayShiftRight}

Представлено в: v23.8

Сдвигает массив вправо на указанное количество элементов. Новые элементы заполняются предоставленным аргументом или значением по умолчанию для типа элемента массива. Если количество элементов отрицательно, массив сдвигается влево.

**Синтаксис**

```sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

- `arr` — Массив, элементы которого нужно сдвинуть. [`Array(T)`](/sql-reference/data-types/array)
- `n` — Количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `default` — Опционально. Значение по умолчанию для новых элементов. 

**Возвращаемое значение**

Массив, сдвинутый вправо на указанное количество элементов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**Использование значения по умолчанию**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```

## arrayShingles {#arrayShingles}

Представлено в: v24.1

Генерирует массив шинглов (аналогично ngrams для строк), т.е. последовательные подмассивы с заданной длиной входного массива.

**Синтаксис**

```sql
arrayShingles(arr, l)
```

**Аргументы**

- `arr` — Массив, для которого генерируется массив шинглов. [`Array(T)`](/sql-reference/data-types/array)
- `l` — Длина каждого шингла. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив сгенерированных шинглов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```

## arrayShuffle {#arrayShuffle}

Представлено в: v23.2

Возвращает массив того же размера, что и оригинальный, содержащий элементы в перемешанном порядке. Элементы перераспределены так, что каждая возможная перестановка этих элементов имеет равную вероятность появления.

:::note
Эта функция не будет материализовать константы.
:::

**Синтаксис**

```sql
arrayShuffle(arr [, seed])
```

**Аргументы**

- `arr` — Массив для перемешивания. [`Array(T)`](/sql-reference/data-types/array)
- `seed (optional)` — Опционально. Начальное значение для генерации случайных чисел. Если не указано, используется случайное. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с перемешанными элементами [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример без начального значения (нестабильные результаты)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**Пример без начального значения (стабильные результаты)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```

## arraySimilarity {#arraySimilarity}

Представлено в: v25.4

Вычисляет схожесть двух массивов от `0` до `1` на основе взвешенного расстояния Левенштейна.

**Синтаксис**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**Аргументы**

- `from` — первый массив [`Array(T)`](/sql-reference/data-types/array)
- `to` — второй массив [`Array(T)`](/sql-reference/data-types/array)
- `from_weights` — веса для первого массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — веса для второго массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает схожесть между `0` и `1` двух массивов на основе взвешенного расстояния Левенштейна [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```

## arraySlice {#arraySlice}

Представлено в: v1.1

Возвращает срез массива, включая элементы `NULL`.

**Синтаксис**

```sql
arraySlice(arr, offset [, length])
```

**Аргументы**

- `arr` — Массив для среза. [`Array(T)`](/sql-reference/data-types/array)
- `offset` — Отступ от края массива. Положительное значение указывает на отступ слева, а отрицательное значение — на отступ справа. Нумерация элементов массива начинается с `1`. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `length` — Длина требуемого среза. Если вы укажете отрицательное значение, функция вернет открытый срез `[offset, array_length - length]`. Если вы пропустите значение, функция вернет срез `[offset, the_end_of_array]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает срез массива с `length` элементов от указанного `offset` [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```

## arraySort {#arraySort}

Представлено в: v1.1

Сортирует элементы предоставленного массива в порядке возрастания. Если указана функция лямбда `f`, порядок сортировки определяется результатом лямбда-функции, примененной к каждому элементу массива. Если лямбда принимает несколько аргументов, функции `arraySort` передаются несколько массивов, которые будут соответствовать аргументам `f`.

Если массив, который нужно отсортировать, содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**Аргументы**

- `f(y1[, y2 ... yN])` — Лямбда-функция, применяемая к элементам массива `x`. 
- `arr` — Массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array) 
- `arr1, ..., yN` — Опционально. N дополнительных массивов, если `f` принимает несколько аргументов. 

**Возвращаемое значение**

Возвращает массив `arr`, отсортированный в порядке возрастания, если не указано лямбда-значение, в противном случае возвращает массив, отсортированный в соответствии с логикой предоставленной лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**Пример 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**Пример 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```

## arraySplit {#arraySplit}

Представлено в: v20.1

Разделяет исходный массив на несколько массивов. Когда `func(x [, y1, ..., yN])` возвращает что-то, кроме нуля, массив будет разделен слева от элемента. Массив не будет разделен перед первым элементом.

**Синтаксис**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`).[Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). 
- `source_arr` — Исходный массив, который нужно разделить [`Array(T)`](/sql-reference/data-types/array). 
- `[, cond1_arr, ... , condN_arr]` — Опционально. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array). 

**Возвращаемое значение**

Возвращает массив массивов [`Array(Array(T))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```

## arraySum {#arraySum}

Представлено в: v21.1

Возвращает сумму элементов в исходном массиве.

Если задана лямбда-функция `func`, возвращает сумму результатов по элементам лямбды.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

- `func(x[, y1, ..., yN])` — Опционально. Лямбда-функция, которая работает с элементами исходного массива (`x`) и массивами условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
- `, cond1_arr, ... , condN_arr]` — Опционально. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает сумму элементов исходного массива или сумму результатов лямбды, если она указана.

**Примеры**

**Простой пример**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```

## arraySymmetricDifference {#arraySymmetricDifference}

Представлено в: v25.4

Принимает несколько массивов и возвращает массив с элементами, которые отсутствуют во всех исходных массивах. Результат содержит только уникальные значения.

:::note
Симметрическая разность _более чем двух множеств_ [математически определяется](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)
как множество всех входных элементов, которые встречаются в нечетном количестве входных множеств. В отличие от этого, функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые не встречаются во всех входных множествах.
:::

**Синтаксис**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**Аргументы**

- `arrN` — N массивов, из которых будет сформирован новый массив. [`Array(T)`](/sql-reference/data-types/array). 

**Возвращаемое значение**

Возвращает массив уникальных элементов, отсутствующих во всех исходных массивах [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```

## arrayUnion {#arrayUnion}

Представлено в: v24.10

Принимает несколько массивов и возвращает массив, который содержит все элементы, присутствующие в одном из исходных массивов. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — N массивов, из которых будет сформирован новый массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с уникальными элементами из исходных массивов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```

## arrayUniq {#arrayUniq}

Представлено в: v1.1

Для одного переданного аргумента считает количество различных элементов в массиве. Для нескольких переданных аргументов считает количество различных **кортежей**, составленных из элементов на совпадающих позициях в нескольких массивах.

Например, `SELECT arrayUniq([1,2], [3,4], [5,6])` сформирует следующие кортежи:
* Позиция 1: (1,3,5)
* Позиция 2: (2,4,6)

Затем будет подсчитано количество уникальных кортежей. В данном случае это `2`.

Все переданные массивы должны иметь одинаковую длину.

:::tip
Если вы хотите получить список уникальных элементов в массиве, вы можете использовать `arrayReduce('groupUniqArray', arr)`.
:::

**Синтаксис**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**Аргументы**

- `arr1` — Массив, для которого будет подсчитано количество уникальных элементов. [`Array(T)`](/sql-reference/data-types/array)
- `[, arr2, ..., arrN]` — Опционально. Дополнительные массивы, используемые для подсчета количества уникальных кортежей элементов на соответствующих позициях в нескольких массивах. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Для одного аргумента возвращает количество уникальных элементов. Для нескольких аргументов возвращает количество уникальных кортежей, составленных из элементов на соответствующих позициях в массивах. [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Один аргумент**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**Несколько аргументов**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```

## arrayWithConstant {#arrayWithConstant}

Представлено в: v20.1

Создает массив длиной `length`, заполненный константой `x`.

**Синтаксис**

```sql
arrayWithConstant(N, x)
```

**Аргументы**

- `length` — Количество элементов в массиве. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `x` — Значение `N` элементов в массиве, любого типа. 

**Возвращаемое значение**

Возвращает массив с `N` элементами значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```

## arrayZip {#arrayZip}

Представлено в: v20.1

Объединяет несколько массивов в один. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в порядке перечисления аргументов.

**Синтаксис**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**Аргументы**

- `arr1, arr2, ... , arrN` — N массивов, которые нужно объединить в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с элементами из исходных массивов, сгруппированными в кортежи. Типы данных в кортеже такие же, как типы входных массивов и находятся в том же порядке, в котором массивы передаются [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```

## arrayZipUnaligned {#arrayZipUnaligned}

Представлено в: v20.1

Объединяет несколько массивов в единый массив, позволяя использование несогласованных массивов (массивов различной длины). Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в порядке перечисления аргументов.

**Синтаксис**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arr1, arr2, ..., arrN` — N массивов, которые нужно объединить в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с элементами из исходных массивов, сгруппированными в кортежи. Типы данных в кортеже такие же, как типы входных массивов и находятся в том же порядке, в котором массивы передаются. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```

## countEqual {#countEqual}

Представлено в: v1.1

Возвращает количество элементов в массиве, равных `x`. Эквивалентно `arrayCount(elem -> elem = x, arr)`.

Элементы, установленные в `NULL`, обрабатываются как отдельные значения.

**Синтаксис**

```sql
countEqual(arr, x)
```

**Аргументы**

- `arr` — Массив для поиска. [`Array(T)`](/sql-reference/data-types/array)
- `x` — Значение в массиве для подсчета. Любой тип. 

**Возвращаемое значение**

Возвращает количество элементов в массиве, равных `x` [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```

## empty {#empty}

Представлено в: v1.1

Проверяет, является ли входной массив пустым.

Массив считается пустым, если он не содержит никаких элементов.

:::note
Может быть оптимизирован настройкой [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). С `optimize_functions_to_subcolumns = 1` функция читает только [size0](/sql-reference/data-types/array#array-size) подколонку вместо чтения и обработки всего столбца массива. Запрос `SELECT empty(arr) FROM TABLE;` преобразуется в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает для [строк](string-functions.md#empty) или [UUID](uuid-functions.md#empty).

**Синтаксис**

```sql
empty(arr)
```

**Аргументы**

- `arr` — Входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для пустого массива или `0` для непустого массива [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```

## emptyArrayDate {#emptyArrayDate}

Представлено в: v1.1

Возвращает пустой массив дат.

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив дат. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```

## emptyArrayDateTime {#emptyArrayDateTime}

Представлено в: v1.1

Возвращает пустой массив DateTime.

**Синтаксис**

```sql
emptyArrayDateTime()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив DateTime. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```

## emptyArrayFloat32 {#emptyArrayFloat32}

Представлено в: v1.1

Возвращает пустой массив Float32.

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив Float32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```

## emptyArrayFloat64 {#emptyArrayFloat64}

Представлено в: v1.1

Возвращает пустой массив Float64.

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив Float64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```

## emptyArrayInt16 {#emptyArrayInt16}

Представлено в: v1.1

Возвращает пустой массив Int16.

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив Int16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```

## emptyArrayInt32 {#emptyArrayInt32}

Представлено в: v1.1

Возвращает пустой массив Int32.

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив Int32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```

## emptyArrayInt64 {#emptyArrayInt64}

Представлено в: v1.1

Возвращает пустой массив Int64.

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив Int64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```

## emptyArrayInt8 {#emptyArrayInt8}

Представлено в: v1.1

Возвращает пустой массив Int8.

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив Int8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```

## emptyArrayString {#emptyArrayString}

Представлено в: v1.1

Возвращает пустой массив строк.

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив строк. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```

## emptyArrayToSingle {#emptyArrayToSingle}

Представлено в: v1.1

Принимает пустой массив и возвращает массив с одним элементом, равным значению по умолчанию.

**Синтаксис**

```sql
emptyArrayToSingle(arr)
```

**Аргументы**

- `arr` — Пустой массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив с одним значением типа по умолчанию массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Простой пример**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```

## emptyArrayUInt16 {#emptyArrayUInt16}

Представлено в: v1.1

Возвращает пустой массив UInt16.

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив UInt16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```

## emptyArrayUInt32 {#emptyArrayUInt32}

Представлено в: v1.1

Возвращает пустой массив UInt32.

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив UInt32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```

## emptyArrayUInt64 {#emptyArrayUInt64}

Представлено в: v1.1

Возвращает пустой массив UInt64.

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив UInt64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```

## emptyArrayUInt8 {#emptyArrayUInt8}

Представлено в: v1.1

Возвращает пустой массив UInt8.

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

- Нет.
**Возвращаемое значение**

Пустой массив UInt8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```

## has {#has}

Представлено в: v1.1

Возвращает, содержит ли массив указанный элемент.

**Синтаксис**

```sql
has(arr, x)
```

**Аргументы**

- `arr` — Исходный массив. [`Array(T)`](/sql-reference/data-types/array)
- `x` — Значение для поиска в массиве. 

**Возвращаемое значение**

Возвращает `1`, если массив содержит указанный элемент, в противном случае `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Простой пример использования**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**Не найдено**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```

## hasAll {#hasAll}

Представлено в: v1.1

Проверяет, является ли один массив подмножеством другого.

- Пустой массив является подмножеством любого массива.
- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Синтаксис**

```sql
hasAll(set, subset)
```

**Аргументы**

- `set` — Массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
- `subset` — Массив любого типа, который имеет общий супертип с `set` и содержит элементы, которые должны быть проверены как подмножество `set`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

- `1`, если `set` содержит все элементы из `subset`.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы множества и подмножества не имеют общего супертипа.

**Примеры**

**Пустые массивы**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**Массивы, содержащие NULL значения**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**Массивы, содержащие значения другого типа**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**Массивы, содержащие строковые значения**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Массивы без общего типа**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Raises a NO_COMMON_TYPE exception
```

**Массив массивов**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```

## hasAny {#hasAny}

Представлено в: v1.1

Проверяет, пересекаются ли два массива по некоторым элементам.

- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Синтаксис**

```sql
hasAny(arr_x, arr_y)
```

**Аргументы**

- `arr_x` — Массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — Массив любого типа, который имеет общий супертип с массивом `arr_x`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

- `1`, если `arr_x` и `arr_y` имеют хотя бы один похожий элемент.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если какие-либо из элементов двух массивов не имеют общего супертипа.

**Примеры**

**Один массив пустой**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**Массивы, содержащие NULL значения**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**Массивы, содержащие значения другого типа**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**Массивы без общего типа**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

**Массив массивов**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```

## hasSubstr {#hasSubstr}

Представлено в: v20.6

Проверяет, появляются ли все элементы массива2 в массиве1 в том же точном порядке. Таким образом, функция вернет `1`, если и только если массив1 = префикс + массив2 + суффикс.

Иными словами, функции проверят, содержатся ли все элементы массива2 в массиве1, как функция `hasAll`. В дополнение к этому проверяется, что элементы наблюдаются в том же порядке в обоих массиве1 и массиве2.

- Функция вернет `1`, если массив2 пустой.
- `Null` обрабатывается как значение. Иными словами, `hasSubstr([1, 2, NULL, 3, 4], [2,3])` вернет `0`. Однако `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` вернет `1`.
- Порядок значений в обоих массивах имеет значение.

Вызывает исключение `NO_COMMON_TYPE`, если какие-либо из элементов двух массивов не имеют общего супертипа.

**Синтаксис**

```sql
hasSubstr(arr1, arr2)
```

**Аргументы**

- `arr1` — Массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
- `arr2` — Массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если массив `arr1` содержит массив `arr2`. В противном случае возвращает `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Оба массива пустые**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**Массивы, содержащие NULL значения**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**Массивы, содержащие значения другого типа**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**Массивы, содержащие строки**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Массивы с правильным порядком**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**Массивы с неверным порядком**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**Массив массивов**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**Массивы без общего типа**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

## indexOf {#indexOf}

Представлено в: v1.1

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он находится в массиве. Если массив не содержит искомого значения, функция возвращает `0`.

Элементы, установленные в `NULL`, обрабатываются как обычные значения.

**Синтаксис**

```sql
indexOf(arr, x)
```

**Аргументы**

- `arr` — Массив для поиска значения `x`. [`Array(T)`](/sql-reference/data-types/array)
- `x` — Значение первого совпадающего элемента в `arr`, для которого нужно вернуть индекс. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация с единицы) первого `x` в `arr`, если он существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Простой пример**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**Массив с null-значениями**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```

## indexOfAssumeSorted {#indexOfAssumeSorted}

Представлено в: v24.12

Возвращает индекс первого элемента со значением 'x' (начиная с `1`), если он находится в массиве. Если массив не содержит искомого значения, функция возвращает `0`.

:::note
В отличие от функции `indexOf`, эта функция предполагает, что массив отсортирован в
порядке возрастания. Если массив не отсортирован, результаты неопределенные.
:::

**Синтаксис**

```sql
indexOfAssumeSorted(arr, x)
```

**Аргументы**

- `arr` — Отсортированный массив для поиска. [`Array(T)`](/sql-reference/data-types/array)
- `x` — Значение первого совпадающего элемента в отсортированном `arr`, для которого нужно вернуть индекс. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация с единицы) первого `x` в `arr`, если он существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Простой пример**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```

## length {#length}

Представлено в: v1.1

Вычисляет длину строки или массива.

- Для строковых или фиксированных строковых аргументов: вычисляет количество байтов в строке.
- Для аргументов массива: вычисляет количество элементов в массиве.
- Если применяется к аргументу фиксированной строки, функция является константным выражением.

Обратите внимание, что количество байтов в строке не равно количеству
Unicode "кодовых точек" и не равно количеству Unicode "графемных кластеров"
(то, что мы обычно называем "символами") и не равно видимой ширине строки.

Разрешено наличие ASCII NULL байтов в строках, и они также будут учитываться.

**Синтаксис**

```sql
length(x)
```

**Аргументы**

- `x` — Значение, для которого нужно вычислить количество байтов (для String/FixedString) или элементов (для Array). [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество байтов в строке/фиксированной строке `x` / количество элементов в массиве `x` [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример строки**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**Пример массива**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**Пример constexpr**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**Пример unicode**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**Пример ascii_vs_utf8**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```

## notEmpty {#notEmpty}

Представлено в: v1.1

Проверяет, является ли входной массив непустым.

Массив считается непустым, если он содержит хотя бы один элемент.

:::note
Может быть оптимизирован настройкой [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). С `optimize_functions_to_subcolumns = 1` функция читает только [size0](/sql-reference/data-types/array#array-size) подколонку вместо чтения и обработки всего столбца массива. Запрос `SELECT notEmpty(arr) FROM table` преобразуется в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функция также работает для [строк](string-functions.md#notempty) или [UUID](uuid-functions.md#notempty).

**Синтаксис**

```sql
notEmpty(arr)
```

**Аргументы**

- `arr` — Входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для непустого массива или `0` для пустого массива [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```

## range {#range}

Представлено в: v1.1

Возвращает массив чисел от `start` до `end - 1` с шагом `step`.

Поддерживаемые типы:
- `UInt8/16/32/64`
- `Int8/16/32/64`

- Все аргументы `start`, `end`, `step` должны быть одного из вышеупомянутых поддерживаемых типов. Элементы возвращаемого массива будут супертитом аргументов.
- Исключение будет выброшено, если функция возвращает массив с общей длиной больше, чем количество элементов, указанных в настройке [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block).
- Возвращает `NULL`, если любой аргумент имеет тип Nullable(nothing). Исключение будет выброшено, если любой аргумент имеет значение `NULL` (Nullable(T) тип).

**Синтаксис**

```sql
range([start, ] end [, step])
```

**Аргументы**

- `start` — Опционально. Первый элемент массива. Обязательно, если используется параметр `step`. Значение по умолчанию: `0`. 
- `end` — Обязательно. Число, перед которым строится массив. 
- `step` — Опционально. Определяет шаг между каждым элементом в массиве. Значение по умолчанию: `1`. 

**Возвращаемое значение**

Массив чисел от `start` до `end - 1` с шагом `step`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```

## replicate {#replicate}

Представлено в: v1.1

Создает массив с одним значением.

**Синтаксис**

```sql
replicate(x, arr)
```

**Аргументы**

- `x` — Значение, чтобы заполнить результирующий массив. [`Any`](/sql-reference/data-types)
- `arr` — Массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив той же длины, что и `arr`, заполненный значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```
## reverse {#reverse}

Введено в: v1.1

Обращает порядок элементов в исходном массиве или символов в строке.

**Синтаксис**

```sql
reverse(arr | str)
```

**Аргументы**

- `arr | str` — Исходный массив или строка. [`Array(T)`](/sql-reference/data-types/array) или [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив или строку с обращённым порядком элементов или символов.

**Примеры**

**Обратить массив**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**Обратить строку**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

<!--AUTOGENERATED_END-->
## Distance functions {#distance-functions}

Все поддерживаемые функции описаны в [документации по функциям расстояния](../../sql-reference/functions/distance-functions.md).
---
description: 'Документация по функциям массивов'
sidebar_label: 'Массивы'
slug: /sql-reference/functions/array-functions
title: 'Функции массивов'
doc_type: 'reference'
---



# Функции массивов {#array-functions}

{/* 
  Внутреннее содержимое расположенных ниже тегов при сборке фреймворка документации
  заменяется документацией, сгенерированной на основе system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }


{/*АВТОГЕНЕРАЦИЯ_НАЧАЛО*/ }

## array {#array}

Введена в версии: v1.1

Создаёт массив из аргументов функции.

Аргументы должны быть константами и иметь типы, которые имеют общий супертип.
Должен быть передан как минимум один аргумент, иначе будет непонятно, какой тип массива создавать.
Это означает, что вы не можете использовать эту функцию для создания пустого массива. Для этого используйте функцию `emptyArray*`.

Для той же функциональности используйте оператор `[ ]`.

**Синтаксис**

```sql
array(x1 [, x2, ..., xN])
```

**Аргументы**

* `x1` — константное значение любого типа T. Если указан только этот аргумент, массив будет иметь тип T. - `[, x2, ..., xN]` — дополнительные N константных значений с общим надтипом с `x1`

**Возвращаемое значение**

Возвращает массив, где &#39;T&#39; — это наименьший общий тип среди переданных аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Корректное использование**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**Недопустимое использование**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```


## arrayAUCPR {#arrayAUCPR}

Добавлена в: v20.4

Вычисляет площадь под кривой точность–полнота («точность–полнота», PR).
Кривая точность–полнота строится путём откладывания значений точности по оси y и полноты по оси x для всех порогов.
Получаемое значение лежит в диапазоне от 0 до 1, при этом большее значение указывает на лучшую производительность модели.
PR AUC особенно полезна для несбалансированных наборов данных, обеспечивая более наглядное сравнение производительности по сравнению с ROC AUC в таких случаях.
Подробнее см. [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**Псевдонимы**: `arrayPRAUC`

**Аргументы**

* `cores` — Оценки, которые возвращает модель. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — Метки объектов, обычно 1 для положительного и 0 для отрицательного объекта. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Enum)`](/sql-reference/data-types/array)
* `partial_offsets` —
* Необязательный аргумент. [`Array(T)`](/sql-reference/data-types/array) из трёх неотрицательных целых чисел для вычисления частичной площади под PR-кривой (что эквивалентно вертикальной полосе в PR-пространстве) вместо полной AUC. Эта опция полезна для распределённого вычисления PR AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`].
  * `higher_partitions_tp`: Количество положительных меток в партициях с более высокими оценками.
  * `higher_partitions_fp`: Количество отрицательных меток в партициях с более высокими оценками.
  * `total_positives`: Общее количество положительных объектов во всём наборе данных.

:::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны представлять только одну партицию всего набора данных, содержащую интервал значений оценок.
Набор данных должен быть разделён на смежные партиции, где каждая партиция содержит подмножество данных, чьи оценки попадают в определённый диапазон.
Например:

* Одна партиция может содержать все оценки в диапазоне [0, 0.5).
* Другая партиция может содержать оценки в диапазоне [0.5, 1.0].
  :::

**Возвращаемое значение**

Возвращает площадь под кривой «точность–полнота» (PR). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll {#arrayAll}

Введена в версии: v1.1

Возвращает `1`, если лямбда-функция `func(x [, y1, y2, ... yN])` возвращает true для всех элементов массива. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает true для всех элементов, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Все элементы соответствуют**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**Не все элементы соответствуют условию**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg {#arrayAvg}

Впервые представлена в: v21.1

Возвращает среднее значение элементов исходного массива.

Если задана лямбда-функция `func`, возвращает среднее значение элементов результатов лямбда-функции.

**Синтаксис**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный аргумент. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает среднее значение элементов исходного массива или среднее значение элементов результатов лямбда-функции, если она указана. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**Использование лямбда-функции**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```


## arrayCompact {#arrayCompact}

Введена в версии: v20.1

Удаляет последовательные дублирующиеся элементы из массива, включая значения `null`. Порядок значений в результирующем массиве определяется порядком в исходном массиве.

**Синтаксис**

```sql
arrayCompact(arr)
```

**Аргументы**

* `arr` — массив, из которого нужно удалить дубликаты. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив без дубликатов значений [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```


## arrayConcat {#arrayConcat}

Введена в версии: v1.1

Объединяет массивы, переданные в качестве аргументов.

**Синтаксис**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**Аргументы**

* `arr1 [, arr2, ... , arrN]` — N массивов, которые нужно конкатенировать. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает один массив, полученный объединением переданных аргументов-массивов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```


## arrayCount {#arrayCount}

Появилась в версии: v1.1

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает true.
Если `func` не указана, возвращает количество ненулевых элементов в массиве.

`arrayCount` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayCount([func, ] arr1, ...)
```

**Аргументы**

* `func` — Необязательный аргумент. Функция, применяемая к каждому элементу массива (массивов). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1, ..., arrN` — N массивов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает число элементов, для которых `func` возвращает true. В противном случае возвращает число ненулевых элементов в массиве. [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```


## arrayCumSum {#arrayCumSum}

Введена в версии: v1.1

Возвращает массив частичных (накопительных) сумм элементов исходного массива. Если указана лямбда‑функция, сумма вычисляется на основе применения лямбда‑функции к элементам массива на каждой позиции.

**Синтаксис**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

* `func` — Необязательный. Лямбда-функция, применяемая к элементам массива в каждой позиции. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — Исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — Необязательно. Дополнительные массивы того же размера, которые передаются в качестве аргументов лямбда-функции, если она указана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов исходного массива. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**С Lambda**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```


## arrayCumSumNonNegative {#arrayCumSumNonNegative}

Добавлено в версии v18.12

Возвращает массив частичных (накопительных) сумм элементов исходного массива, заменяя любую отрицательную накопительную сумму на ноль. Если задана лямбда-функция, сумма вычисляется как результат её применения к элементам массива на каждой позиции.

**Синтаксис**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

* `func` — Необязательный аргумент. Лямбда-функция, которая применяется к элементам массива в каждой позиции. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — Исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — Необязательно. Дополнительные массивы того же размера, передаваемые в качестве аргументов лямбда-функции, если она задана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов исходного массива, при этом любые отрицательные значения накопленной суммы заменяются на ноль. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**С лямбда-функцией**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```


## arrayDifference {#arrayDifference}

Добавлена в: v1.1

Вычисляет массив разностей между соседними элементами массива.
Первый элемент результирующего массива будет равен 0, второй — `arr[1] - arr[0]`, третий — `arr[2] - arr[1]` и т. д.
Тип элементов результирующего массива определяется правилами вывода типа для операции вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

```sql
arrayDifference(arr)
```

**Аргументы**

* `arr` — массив, для которого нужно вычислить разности между соседними элементами. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив разностей между соседними элементами массива типа [`UInt*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**Пример переполнения при типе результата Int64**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct {#arrayDistinct}

Введена в версии: v1.1

Возвращает массив, содержащий только уникальные элементы исходного массива.

**Синтаксис**

```sql
arrayDistinct(arr)
```

**Аргументы**

* `arr` — Массив, из которого необходимо получить элементы без дубликатов значений. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив без дубликатов значений [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct {#arrayDotProduct}

Добавлено в версии v23.5

Возвращает скалярное произведение двух массивов.

:::note
Размеры двух векторов должны быть равны. Массивы и Tuples также могут содержать элементы разных типов.
:::

**Синтаксис**

```sql
arrayDotProduct(v1, v2)
```

**Аргументы**

* `v1` — Первый вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
* `v2` — Второй вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**Возвращаемое значение**

Скалярное произведение двух векторов.

:::note
Тип возвращаемого значения определяется типом аргументов. Если `Array` или `Tuple` содержат элементы смешанных типов, то тип результата — супертип.
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Примеры**

**Пример с массивом**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**Пример tuple**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement {#arrayElement}

Появилась в версии: v1.1

Возвращает элемент переданного массива с индексом `n`, где `n` может быть целым числом любого типа.
Если индекс выходит за пределы массива, функция возвращает значение по умолчанию (0 для чисел, пустую строку для строк и т. д.),
за исключением случая неконстантного массива и константного индекса 0. В этом случае будет ошибка `Array indices are 1-based`.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент с номером, отсчитываемым с конца массива. Например, `arr[-1]` — это последний элемент массива.

Оператор `[n]` предоставляет ту же функциональность.

**Синтаксис**

```sql
arrayElement(arr, n)
```

**Аргументы**

* `arr` — Массив, в котором выполняется поиск. [`Array(T)`](/sql-reference/data-types/array). - `n` — Позиция элемента, который нужно получить. [`(U)Int*`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Возвращает один объединённый массив, полученный из переданных массивов-аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Отрицательные индексы**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**Использование нотации [n]**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Выход индекса за границы массива**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```


## arrayElementOrNull {#arrayElementOrNull}

Появилась в версии: v1.1

Возвращает элемент переданного массива с индексом `n`, где `n` может быть целым числом любого типа.
Если индекс выходит за границы массива, вместо значения по умолчанию возвращается `NULL`.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, нумеруемый с конца. Например, `arr[-1]` — последний элемент массива.

**Синтаксис**

```sql
arrayElementOrNull(arrays)
```

**Аргументы**

* `arrays` — Произвольное количество аргументов-массивов. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает один объединённый массив из переданных аргументов-массивов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Отрицательные индексы**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**Выход индекса за границы массива**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```


## arrayEnumerate {#arrayEnumerate}

Появилась в версии: v1.1

Возвращает массив `[1, 2, 3, ..., length (arr)]`

Эта функция обычно используется с оператором [`ARRAY JOIN`](/sql-reference/statements/select/array-join). Она позволяет учесть что‑то один раз для каждого массива после применения `ARRAY JOIN`.
Эту функцию также можно использовать в функциях высшего порядка. Например, можно использовать её, чтобы получить индексы элементов массива, которые удовлетворяют условию.

**Синтаксис**

```sql
arrayEnumerate(arr)
```

**Аргументы**

* `arr` — массив, который нужно пронумеровать. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив вида `[1, 2, 3, ..., length(arr)]`. [`Array(UInt32)`](/sql-reference/data-types/array)

**Примеры**

**Базовый пример с ARRAY JOIN**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense {#arrayEnumerateDense}

Добавлена в версии: v18.12

Возвращает массив той же длины, что и исходный массив, указывающий позицию первого вхождения каждого элемента в исходном массиве.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Аргументы**

* `arr` — Массив, для которого выполняется нумерация. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же размера, что и `arr`, элементы которого указывают позицию первого вхождения соответствующего элемента в исходный массив. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

Введена в версии: v20.1

Возвращает массив той же длины, что и исходный массив, значения которого указывают позицию, в которой каждый элемент впервые встречается в исходном массиве. Позволяет перебирать многомерный массив с возможностью задать глубину просмотра внутри массива.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

* `clear_depth` — Перечисляет элементы на указанном уровне отдельно. Должен быть меньше или равен значению `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — N-мерный массив для нумерации. [`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — Максимальная рабочая глубина. Должна быть меньше или равна глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив, указывающий, где каждый элемент впервые встречается в исходном массиве [`Array`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result is identical to what arrayEnumerateDense would give.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**Использование с многомерным массивом**

```sql title=Query
-- In this example, arrayEnumerateDenseRanked is used to obtain an array indicating, for each element of the
-- multidimensional array, what its position is among elements of the same value.
-- For the first row of the passed array, [10, 10, 30, 20], the corresponding first row of the result is [1, 1, 2, 3],
-- indicating that 10 is the first number encountered in position 1 and 2, 30 the second number encountered in position 3
-- and 20 is the third number encountered in position 4.
-- For the second row, [40, 50, 10, 30], the corresponding second row of the result is [4,5,1,2], indicating that 40
-- and 50 are the fourth and fifth numbers encountered in position 1 and 2 of that row, that another 10
-- (the first encountered number) is in position 3 and 30 (the second number encountered) is in the last position.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**Пример для повышенного clear&#95;depth**

```sql title=Query
-- Changing clear_depth=2 results in the enumeration occurring separately for each row anew.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq {#arrayEnumerateUniq}

Введена в версии: v1.1

Возвращает массив того же размера, что и исходный массив, в котором для каждого элемента указано, каким по счёту он является среди элементов с тем же значением.

Эта функция полезна при использовании `ARRAY JOIN` и агрегации элементов массива.

Функция может принимать несколько массивов одинакового размера в качестве аргументов. В этом случае уникальность определяется для кортежей элементов, находящихся на одних и тех же позициях во всех массивах.

**Синтаксис**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**Аргументы**

* `arr1` — Первый массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `arr2, ...` — Необязательно. Дополнительные массивы того же размера для обеспечения уникальности кортежей. [`Array(UInt32)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, в котором каждый элемент — позиция среди элементов с тем же значением или тем же кортежем. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**Несколько массивов**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**Агрегация с ARRAY JOIN**

```sql title=Query
-- Each goal ID has a calculation of the number of conversions (each element in the Goals nested data structure is a goal that was reached, which we refer to as a conversion)
-- and the number of sessions. Without ARRAY JOIN, we would have counted the number of sessions as sum(Sign). But in this particular case,
-- the rows were multiplied by the nested Goals structure, so in order to count each session one time after this, we apply a condition to the
-- value of the arrayEnumerateUniq(Goals.ID) function.

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

Введена в: v20.1

Возвращает массив (или многомерный массив) с теми же размерами, что и исходный массив,
в котором для каждого элемента указывается его позиция среди элементов с тем же значением.
Позволяет нумеровать многомерный массив с возможностью задать глубину просмотра массива.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

* `clear_depth` — Нумерует элементы на указанном уровне отдельно. Положительное целое число, меньшее либо равное `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — N-мерный массив для нумерации. [`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — Максимальная эффективная глубина. Положительное целое число, меньшее либо равное глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает N-мерный массив того же размера, что и `arr`, в котором каждый элемент показывает позицию этого элемента среди других элементов с тем же значением. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniq would give for the same array.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**Пример 2**

```sql title=Query
-- with clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniqwould give for the same array.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**Пример 3**

```sql title=Query
-- In this example, arrayEnumerateUniqRanked is used to obtain an array indicating,
-- for each element of the multidimensional array, what its position is among elements
-- of the same value. For the first row of the passed array, [1, 2, 3], the corresponding
-- result is [1, 1, 1], indicating that this is the first time 1, 2 and 3 are encountered.
-- For the second row of the provided array, [2, 2, 1], the corresponding result is [2, 3, 3],
-- indicating that 2 is encountered for a second and third time, and 1 is encountered
-- for the second time. Likewise, for the third row of the provided array [3] the
-- corresponding result is [2] indicating that 3 is encountered for the second time.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**Пример 4**

```sql title=Query
-- Changing clear_depth=2, results in elements being enumerated separately for each row.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept {#arrayExcept}

Появилась в версии: v25.9

Возвращает массив, содержащий элементы из `source`, которые отсутствуют в `except`, при этом сохраняется исходный порядок.

Эта функция выполняет операцию разности множеств между двумя массивами. Для каждого элемента в `source` проверяется, существует ли этот элемент в `except` (с использованием точного сравнения). Если нет — элемент включается в результат.

Операция обладает следующими свойствами:

1. Порядок элементов из `source` сохраняется
2. Дубликаты в `source` сохраняются, если они отсутствуют в `except`
3. NULL обрабатывается как отдельное значение

**Синтаксис**

```sql
arrayExcept(source, except)
```

**Аргументы**

* `source` — исходный массив, элементы которого нужно отфильтровать.  [`Array(T)`](/sql-reference/data-types/array)
* `except` — массив, содержащий элементы, которые нужно исключить из результата.  [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же типа, что и входной массив, содержащий элементы из `source`, которые отсутствуют в `except`.  [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**простой пример**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with&#95;nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with&#95;nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**строки**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```


## arrayExists {#arrayExists}

Введена в версии: v1.1

Возвращает `1`, если в исходном массиве есть хотя бы один элемент, для которого `func(x[, y1, y2, ... yN])` возвращает `true`. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает true хотя бы для одного элемента, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```


## arrayFill {#arrayFill}

Функция представлена в: v20.1

Функция `arrayFill` последовательно обрабатывает массив-источник от первого
до последнего элемента, вычисляя лямбда‑условие в каждой позиции, используя элементы
массива-источника и массива условий. Когда значение лямбда‑функции в позиции `i`
ложно, функция заменяет этот элемент элементом в позиции `i-1`
из текущего состояния массива. Первый элемент всегда сохраняется,
независимо от условий.

**Синтаксис**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x [, y1, ..., yN])` — Лямбда-функция `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**Пример для двух массивов**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```


## arrayFilter {#arrayFilter}

Появилась в версии: v1.1

Возвращает массив, содержащий только элементы исходного массива, для которых лямбда-функция возвращает true.

**Синтаксис**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает подмножество исходного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**Пример 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```


## arrayFirst {#arrayFirst}

Появилась в версии: v1.1

Возвращает первый элемент исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает значение `true`, в противном случае возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `λ` истинно, в противном случае возвращает значение по умолчанию типа `T`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayFirstIndex {#arrayFirstIndex}

Появилась в версии: v1.1

Возвращает индекс первого элемента исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает значение `true`, в противном случае возвращает &#39;0&#39;.

**Синтаксис**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает индекс первого элемента исходного массива, для которого `func` возвращает `true`, в противном случае возвращает `0` [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**Нет совпадений**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```


## arrayFirstOrNull {#arrayFirstOrNull}

Появилась в версии: v1.1

Возвращает первый элемент исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает `true`; в противном случае — `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `func` возвращает `true`, в противном случае возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayFlatten {#arrayFlatten}

Появилась в версии: v20.1

Преобразует массив массивов в плоский массив.

Функция:

* Применяется к массивам любой глубины вложенности.
* Не изменяет массивы, которые уже являются плоскими.

Плоский массив содержит все элементы из всех исходных массивов.

**Синтаксис**

```sql
arrayFlatten(arr)
```

**Псевдонимы**: `flatten`

**Аргументы**

* `arr` — многомерный массив. [`Array(Array(T))`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает одномерный массив, полученный из многомерного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```


## arrayFold {#arrayFold}

Введена в версии: v23.10

Применяет лямбда-функцию к одному или нескольким массивам одинакового размера и сохраняет результат в аккумуляторе.

**Синтаксис**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**Аргументы**

* `λ(x, x1 [, x2, x3, ... xN])` — Лямбда-функция `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`, где `F` — операция, применяемая к `acc` и значениям массива `x` с повторным использованием результата `acc`. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1 [, arr2, arr3, ... arrN]` — N массивов, над которыми выполняется операция. [`Array(T)`](/sql-reference/data-types/array)
* `acc` — Значение аккумулятора того же типа, что и возвращаемый тип лямбда-функции.

**Возвращаемое значение**

Возвращает итоговое значение `acc`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**Числа Фибоначчи**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**Пример для нескольких массивов**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```


## arrayIntersect {#arrayIntersect}

Впервые представлена в версии: v1.1

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**Аргументы**

* `arrN` — N массивов, из которых формируется новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив уникальных элементов, присутствующих во всех N массивах [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex {#arrayJaccardIndex}

Функция появилась в: v23.7

Возвращает [индекс Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) для двух массивов.

**Синтаксис**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**Аргументы**

* `arr_x` — Первый массив. [`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — Второй массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс Жаккара для `arr_x` и `arr_y` типа [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin {#arrayJoin}

Появилась в версии: v1.1

Функция `arrayJoin` принимает строку, содержащую массив, и разворачивает его, генерируя несколько строк — по одной для каждого элемента массива.
Это отличается от обычных функций в ClickHouse, которые отображают входные значения в выходные в пределах одной строки,
и агрегатных функций, которые принимают группу строк и «сжимают» или сводят их в одну итоговую строку
(или в одно значение внутри итоговой строки, если используются с `GROUP BY`).

Все значения в столбцах просто копируются, за исключением значений в столбце, к которому применяется эта функция;
они заменяются соответствующим значением из массива.

**Синтаксис**

```sql
arrayJoin(arr)
```

**Аргументы**

* `arr` — массив, который нужно развернуть. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает набор строк, полученных из `arr`.

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin затрагивает все части запроса**

```sql title=Query
-- The arrayJoin function affects all sections of the query, including the WHERE section. Notice the result 2, even though the subquery returned 1 row.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**Использование разных функций arrayJoin**

```sql title=Query
- A query can use multiple arrayJoin functions. In this case, the transformation is performed multiple times and the rows are multiplied.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**Неожиданные результаты из-за оптимизаций**

```sql title=Query
-- Using multiple arrayJoin with the same expression may not produce the expected result due to optimizations.
-- For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.
- e.g. arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set
    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─first_throw─┬─second_throw─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**Использование синтаксиса ARRAY JOIN**

```sql title=Query
-- Note the ARRAY JOIN syntax in the `SELECT` query below, which provides broader possibilities.
-- ARRAY JOIN allows you to convert multiple arrays with the same number of elements at a time.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Использование кортежа (Tuple)**

```sql title=Query
-- You can also use Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast {#arrayLast}

Введена в версии: v1.1

Возвращает последний элемент исходного массива, для которого лямбда `func(x [, y1, y2, ... yN])` возвращает `true`; если такого элемента нет, возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам-условиям (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1, ... , condN]` — Необязательно. N массивов-условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого `func` возвращает true, иначе возвращает значение по умолчанию типа `T`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayLastIndex {#arrayLastIndex}

Добавлена в: v1.1

Возвращает индекс последнего элемента исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает значение true; в противном случае — &#39;0&#39;.

**Синтаксис**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс последнего элемента исходного массива, для которого `func` возвращает true, в противном случае возвращает `0` [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**Совпадений нет**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull {#arrayLastOrNull}

Введена в версии: v1.1

Возвращает последний элемент исходного массива, для которого лямбда-выражение `func(x [, y1, y2, ... yN])` возвращает `true`; в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x [, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого результат `λ` не равен `true`, в противном случае возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance {#arrayLevenshteinDistance}

Введена в версии: v25.4

Функция вычисляет расстояние Левенштейна между двумя массивами.

**Синтаксис**

```sql
arrayLevenshteinDistance(from, to)
```

**Аргументы**

* `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array). - `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```


## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

Введена в версии: v25.4

Вычисляет расстояние Левенштейна для двух массивов с пользовательскими весами для каждого элемента.
Количество элементов массива и соответствующих весов должно совпадать.

**Синтаксис**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**Аргументы**

* `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array). - `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array). - `from_weights` — веса для первого массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — веса для второго массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами с заданными для каждого элемента весами, возвращаемое значение имеет тип [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```


## arrayMap {#arrayMap}

Впервые представлена в версии: v1.1

Возвращает массив, полученный из исходных массивов путём применения лямбда-функции к каждому элементу.

**Синтаксис**

```sql
arrayMap(func, arr)
```

**Аргументы**

* `func` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов-условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — N массивов для обработки. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с результатами лямбда-функции [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**Создание tuple из разных массивов**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax {#arrayMax}

Появилась в версии: v21.1

Возвращает максимальный элемент исходного массива.

Если указана лямбда-функция `func`, возвращает максимальный элемент среди результатов её выполнения.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный аргумент. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает максимальный элемент в исходном массиве или максимальный элемент среди результатов лямбда-функции, если она используется.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**Использование лямбда-функции**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin {#arrayMin}

Введена в версии: v21.1

Возвращает минимальный элемент исходного массива.

Если указана лямбда-функция `func`, возвращает минимальный элемент среди результатов её применения.

**Синтаксис**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательно. Функция-лямбда, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает минимальный элемент исходного массива или минимальный элемент среди результатов функции-лямбды, если она используется.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```


## arrayNormalizedGini {#arrayNormalizedGini}

Добавлено в версии: v25.1

Вычисляет нормированный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

* `predicted` — Предсказанное значение. [`Array(T)`](/sql-reference/data-types/array)
* `label` — Фактическое значение. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Кортеж, содержащий коэффициент Джини для предсказанных значений, коэффициент Джини для нормализованных значений и нормализованный коэффициент Джини (равный отношению первых двух коэффициентов Джини) [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort {#arrayPartialReverseSort}

Появилась в версии: v23.2

Эта функция аналогична `arrayReverseSort`, но с дополнительным аргументом `limit`, позволяющим выполнять частичную сортировку.

:::tip
Чтобы сохранить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

* `f(arr[, arr1, ... ,arrN])` — лямбда-функция, применяемая к элементам массива `x`. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — N дополнительных массивов, если `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array)
* `limit` — значение индекса, до которого будет выполняться сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, в котором элементы в диапазоне `[1..limit]` отсортированы
по убыванию. Оставшиеся элементы `(limit..N]` находятся в неопределённом порядке.

**Примеры**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```


## arrayPartialShuffle {#arrayPartialShuffle}

Добавлена в: v23.2

Возвращает массив того же размера, что и исходный массив, где элементы в диапазоне `[1..limit]` представляют собой случайное подмножество элементов исходного массива. Оставшаяся часть диапазона `(limit..n]` должна содержать элементы, не попавшие в диапазон `[1..limit]`, в произвольном порядке. Значение `limit` должно быть в диапазоне `[1..n]`. Значения вне этого диапазона эквивалентны выполнению полного `arrayShuffle`:

:::note
Эта функция не будет материализовывать константы.

Значение `limit` должно быть в диапазоне `[1..N]`. Значения вне этого диапазона эквивалентны выполнению полного [`arrayShuffle`](#arrayShuffle).
:::

**Синтаксис**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**Аргументы**

* `arr` — Массив, который нужно перемешать. [`Array(T)`](/sql-reference/data-types/array)
* `seed` — Необязательный аргумент. Начальное значение (seed), используемое для генерации случайных чисел. Если не задан, используется случайное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `limit` — Необязательный аргумент. Число, ограничивающее количество перестановок элементов, в диапазоне `[1..N]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с частично перемешанными элементами. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**no&#95;limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no&#95;limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort {#arrayPartialSort}

Введена в версии: v23.2

Эта функция аналогична `arraySort`, но имеет дополнительный аргумент `limit`, который позволяет выполнять частичную сортировку.

:::tip
Чтобы оставить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

* `f(arr[, arr1, ... ,arrN])` — Лямбда-функция, применяемая к элементам массива `x`. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — Массив, подлежащий сортировке. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — N дополнительных массивов, когда `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array)
* `limit` — Значение индекса, до которого будет выполняться сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, в котором элементы в диапазоне `[1..limit]` отсортированы
по возрастанию. Оставшиеся элементы в диапазоне `(limit..N]` могут быть в произвольном порядке.

**Примеры**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```


## arrayPopBack {#arrayPopBack}

Введена в версии: v1.1

Удаляет последний элемент массива.

**Синтаксис**

```sql
arrayPopBack(arr)
```

**Аргументы**

* `arr` — массив, из которого нужно удалить последний элемент. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, совпадающий с `arr`, но без его последнего элемента. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```


## arrayPopFront {#arrayPopFront}

Добавлена в версии: v1.1

Удаляет первый элемент массива.

**Синтаксис**

```sql
arrayPopFront(arr)
```

**Аргументы**

* `arr` — массив, из которого нужно удалить первый элемент. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но без первого элемента `arr`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```


## arrayProduct {#arrayProduct}

Введена в версии: v21.1

Возвращает произведение элементов исходного массива.

Если указана лямбда-функция `func`, возвращает произведение элементов, полученных в результате её применения.

**Синтаксис**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает произведение элементов исходного массива или произведение элементов результатов лямбда-функции, если она указана. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack {#arrayPushBack}

Добавлена в версии: v1.1

Добавляет один элемент в конец массива.

**Синтаксис**

```sql
arrayPushBack(arr, x)
```

**Аргументы**

* `arr` — массив, к которому в конец добавляется значение `x`. [`Array(T)`](/sql-reference/data-types/array)
* `x` —
* Отдельное значение, добавляемое в конец массива. [`Array(T)`](/sql-reference/data-types/array).

:::note

* В массив с числами можно добавлять только числа, а в массив строк — только строки.
* При добавлении чисел ClickHouse автоматически устанавливает тип `x` в соответствии с типом элементов массива.
* Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

Подробнее о типах данных в ClickHouse см. раздел [Data types](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с дополнительным значением `x` в конце массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```


## arrayPushFront {#arrayPushFront}

Введено в версии: v1.1

Добавляет один элемент в начало массива.

**Синтаксис**

```sql
arrayPushFront(arr, x)
```

**Аргументы**

* `arr` — Массив, в который необходимо добавить значение `x` в начало. [`Array(T)`](/sql-reference/data-types/array). - `x` —
* Одно значение, которое нужно добавить в начало массива. [`Array(T)`](/sql-reference/data-types/array).

:::note

* В массив с числами можно добавлять только числа, а в массив строк — только строки.
* При добавлении чисел ClickHouse автоматически приводит тип `x` к типу данных массива.
* Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

Дополнительные сведения о типах данных в ClickHouse см. в разделе [Типы данных](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с дополнительным значением `x` в начале массива [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```


## arrayROCAUC {#arrayROCAUC}

Введена в версии: v20.4

Вычисляет площадь под ROC-кривой (receiver operating characteristic).
ROC-кривая строится путём откладывания доли истинно положительных (True Positive Rate, TPR) по оси Y и доли ложно положительных (False Positive Rate, FPR) по оси X для всех пороговых значений.
Получаемое значение лежит в диапазоне от нуля до единицы, причём большее значение указывает на более высокое качество модели.

ROC AUC (также просто AUC) — это понятие из области машинного обучения.
Для получения дополнительной информации см. [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**Псевдонимы**: `arrayAUC`

**Аргументы**

* `scores` — Оценки, которые возвращает модель предсказаний. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — Метки выборок, обычно 1 для положительной и 0 для отрицательной выборки. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Enum`](/sql-reference/data-types/enum)
* `scale` — Необязательный аргумент. Определяет, нужно ли возвращать нормированную площадь. Если значение false, возвращается площадь под кривой TP (true positives) x FP (false positives). Значение по умолчанию: true. [`Bool`](/sql-reference/data-types/boolean)
* `partial_offsets` —
* Массив из четырёх неотрицательных целых чисел для вычисления частичной площади под ROC-кривой (эквивалентно вертикальной полосе в ROC-пространстве) вместо полной AUC. Эта опция полезна для распределённых вычислений ROC AUC. Массив должен содержать следующие элементы: [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) неотрицательных [Integers](../data-types/int-uint.md). Необязательный аргумент.
  * `higher_partitions_tp`: Число положительных меток в партициях с более высокими оценками.
  * `higher_partitions_fp`: Число отрицательных меток в партициях с более высокими оценками.
  * `total_positives`: Общее количество положительных выборок во всём наборе данных.
  * `total_negatives`: Общее количество отрицательных выборок во всём наборе данных.

:::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны представлять только одну партицию всего набора данных, содержащую определённый интервал оценок.
Набор данных должен быть разделён на смежные партиции, где каждая партиция содержит подмножество данных с оценками, попадающими в определённый диапазон.
Например:

* Одна партиция может содержать все оценки в диапазоне [0, 0.5).
* Другая партиция может содержать оценки в диапазоне [0.5, 1.0].
  :::

**Возвращаемое значение**

Возвращает площадь под ROC-кривой (receiver operating characteristic). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```


## arrayRandomSample {#arrayRandomSample}

Функция представлена в: v23.10

Возвращает подмножество из `samples` случайных элементов входного массива. Если `samples` превышает размер входного массива, размер выборки ограничивается размером массива, то есть возвращаются все элементы массива, но их порядок не гарантируется. Функция может работать как с плоскими массивами, так и с вложенными массивами.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

* `arr` — Входной массив или многомерный массив, из которого отбираются элементы. [`Array(T)`](/sql-reference/data-types/array)
* `samples` — Количество элементов, которые включаются в случайную выборку. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив, содержащий случайную выборку элементов из входного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**Использование с многомерным массивом**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```


## arrayReduce {#arrayReduce}

Введена в версии: v1.1

Применяет агрегатную функцию к элементам массива и возвращает её результат.
Имя агрегатной функции передаётся как строка в одинарных кавычках `'max'`, `'sum'`.
При использовании параметрических агрегатных функций параметр указывается после имени функции в скобках `'uniqUpTo(6)'`.

**Синтаксис**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**Аргументы**

* `agg_f` — Имя агрегатной функции, значение которой должно быть константой. [`String`](/sql-reference/data-types/string)
* `arr1 [, arr2, ... , arrN)]` — N массивов, соответствующих аргументам `agg_f`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает результат агрегатной функции

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**Пример агрегатной функции с несколькими параметрами**

```sql title=Query
--If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**Пример с параметрической агрегатной функцией**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges {#arrayReduceInRanges}

Введена в версии: v20.4

Применяет агрегатную функцию к элементам массива в заданных диапазонах и возвращает массив, содержащий результат, соответствующий каждому диапазону.
Функция вернёт тот же результат, что и несколько вызовов `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**Аргументы**

* `agg_f` — имя агрегатной функции, которую нужно использовать. [`String`](/sql-reference/data-types/string)
* `ranges` — массив кортежей `(i, r)`, задающий диапазоны, по которым выполняется агрегация. Каждый кортеж содержит индекс `i`, с которого нужно начать, и диапазон `r`, по которому выполняется агрегация. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T)`](/sql-reference/data-types/tuple)
* `arr1 [, arr2, ... ,arrN)]` — N массивов в качестве аргументов агрегатной функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с результатами работы агрегатной функции на указанных диапазонах [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove {#arrayRemove}

Добавлена в версии: v25.11

Удаляет из массива все элементы, равные заданному значению.
Значения NULL считаются равными.

**Синтаксис**

```sql
arrayRemove(arr, elem)
```

**Псевдонимы**: `array_remove`

**Аргументы**

* `arr` — Array(T), `elem` — T

**Возвращаемое значение**

Возвращает подмножество массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**Пример 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```


## arrayResize {#arrayResize}

Появилась в версии: v1.1

Изменяет длину массива.

**Синтаксис**

```sql
arrayResize(arr, size[, extender])
```

**Аргументы**

* `arr` — Массив, размер которого нужно изменить. [`Array(T)`](/sql-reference/data-types/array)
* `size` —
  * Новый размер массива.
    Если `size` меньше исходной длины массива, массив усекается справа.
    Если `size` больше исходной длины массива, массив расширяется справа значениями `extender` или значениями по умолчанию для типа данных элементов массива.
* `extender` — Значение, используемое для расширения массива. Может быть `NULL`.

**Возвращаемое значение**

Массив длины `size`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**Пример 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```


## arrayReverse {#arrayReverse}

Появилась в версии: v1.1

Меняет порядок элементов заданного массива на противоположный.

:::note
Функция `reverse(arr)` выполняет ту же функцию, но работает также с другими типами данных,
помимо массивов.
:::

**Синтаксис**

```sql
arrayReverse(arr)
```

**Аргументы**

* `arr` — массив, который нужно развернуть. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, с элементами в обратном порядке. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill {#arrayReverseFill}

Появилась в версии: v20.1

Функция `arrayReverseFill` последовательно обрабатывает исходный массив в обратном порядке — от
последнего элемента к первому, на каждой позиции вычисляя лямбда-условие с использованием элементов
исходного и условного массивов. Когда на позиции i условие оказывается ложным (`false`),
функция заменяет этот элемент элементом на позиции i+1
из текущего состояния массива. Последний элемент всегда сохраняется,
независимо от условия.

**Синтаксис**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, в котором элементы исходного массива заменены результатами выполнения лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**Пример для двух массивов**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```


## arrayReverseSort {#arrayReverseSort}

Появилась в версии: v1.1

Сортирует элементы массива в порядке убывания.
Если указана функция `f`, переданный массив сортируется в соответствии с результатом
применения этой функции к элементам массива, после чего отсортированный массив переворачивается.
Если `f` принимает несколько аргументов, функции `arrayReverseSort` передаётся несколько массивов,
которые соответствуют аргументам `func`.

Если сортируемый массив содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**Аргументы**

* `f(y1[, y2 ... yN])` — лямбда-функция, которая применяется к элементам массива `x`.

- `arr` — массив для сортировки. [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ..., yN` — необязательно. N дополнительных массивов, если `f` принимает несколько аргументов.

**Возвращаемое значение**

Возвращает массив `x`, отсортированный по убыванию, если лямбда-функция не задана, в противном случае
возвращает массив, отсортированный в соответствии с логикой переданной лямбда-функции и затем обращённый. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**Пример 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```


## arrayReverseSplit {#arrayReverseSplit}

Функция представлена в: v20.1

Разбивает исходный массив на несколько массивов. Когда `func(x[, y1, ..., yN])` возвращает значение, отличное от нуля, массив разделяется справа от этого элемента. Массив не разделяется после последнего элемента.

**Синтаксис**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив массивов. [`Array(Array(T))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft {#arrayRotateLeft}

Функция представлена в версии v23.8.

Циклически сдвигает массив влево на указанное количество элементов. Отрицательные значения `n` интерпретируются как циклический сдвиг вправо на абсолютное значение величины сдвига.

**Синтаксис**

```sql
arrayRotateLeft(arr, n)
```

**Аргументы**

* `arr` — массив, элементы которого нужно сдвинуть. [`Array(T)`](/sql-reference/data-types/array). - `n` — число элементов, на которое выполняется сдвиг. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, сдвинутый влево на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```


## arrayRotateRight {#arrayRotateRight}

Введена в версии: v23.8

Циклически сдвигает массив вправо на указанное число элементов. Отрицательные значения `n` рассматриваются как сдвиг влево на величину, равную модулю значения `n`.

**Синтаксис**

```sql
arrayRotateRight(arr, n)
```

**Аргументы**

* `arr` — массив, элементы которого нужно циклически сдвинуть. [`Array(T)`](/sql-reference/data-types/array). - `n` — количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, циклически сдвинутый вправо на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```


## arrayShiftLeft {#arrayShiftLeft}

Функция представлена в версии v23.8.

Сдвигает массив влево на указанное количество элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элементов массива.
Если количество элементов отрицательное, массив сдвигается вправо.

**Синтаксис**

```sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

* `arr` — Массив, элементы которого необходимо сдвинуть. [`Array(T)`](/sql-reference/data-types/array). - `n` — Количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). - `default` — Необязательный аргумент. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

Массив, сдвинутый влево на указанное количество элементов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**Отрицательное значение параметра n**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**Использование значения по умолчанию**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```


## arrayShiftRight {#arrayShiftRight}

Функция представлена в: v23.8

Сдвигает массив вправо на указанное количество элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элементов массива.
Если количество элементов отрицательное, массив сдвигается влево.

**Синтаксис**

```sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

* `arr` — Массив, элементы которого необходимо сдвинуть. [`Array(T)`](/sql-reference/data-types/array)
* `n` — Количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `default` — Необязательный аргумент. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

Массив, сдвинутый вправо на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**Использование значения по умолчанию**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```


## arrayShingles {#arrayShingles}

Функция представлена в версии v24.1.

Генерирует массив шинглов (по аналогии с n-граммами для строк), то есть последовательных подмассивов заданной длины входного массива.

**Синтаксис**

```sql
arrayShingles(arr, l)
```

**Аргументы**

* `arr` — Массив, для которого нужно сгенерировать массив шинглов. [`Array(T)`](/sql-reference/data-types/array)
* `l` — Длина каждого шингла. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив сгенерированных шинглов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle {#arrayShuffle}

Введена в версии v23.2

Возвращает массив того же размера, что и исходный массив, содержащий элементы в случайном порядке.
Элементы переставляются таким образом, что каждая возможная перестановка этих элементов имеет равную вероятность появления.

:::note
Эта функция не материализует константы.
:::

**Синтаксис**

```sql
arrayShuffle(arr [, seed])
```

**Аргументы**

* `arr` — Массив для перемешивания. [`Array(T)`](/sql-reference/data-types/array)
* `seed (optional)` — Необязательный аргумент. Значение seed, используемое при генерации случайных чисел. Если не указано, используется случайное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с перемешанными элементами [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример без seed (нестабильные результаты)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**Пример без seed (стабильный результат)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```


## arraySimilarity {#arraySimilarity}

Функция представлена в: v25.4

Вычисляет схожесть двух массивов в диапазоне от `0` до `1` на основе взвешенного расстояния Левенштейна.

**Синтаксис**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**Аргументы**

* `from` — первый массив [`Array(T)`](/sql-reference/data-types/array)
* `to` — второй массив [`Array(T)`](/sql-reference/data-types/array)
* `from_weights` — веса для первого массива [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — веса для второго массива [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает значение степени сходства в диапазоне от `0` до `1` для двух массивов на основе взвешенного расстояния Левенштейна [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```


## arraySlice {#arraySlice}

Появилась в версии: v1.1

Возвращает срез массива, включая элементы `NULL`.

**Синтаксис**

```sql
arraySlice(arr, offset [, length])
```

**Аргументы**

* `arr` — Массив, из которого берётся срез. [`Array(T)`](/sql-reference/data-types/array)
* `offset` — Смещение от края массива. Положительное значение указывает смещение слева, отрицательное — смещение справа. Нумерация элементов массива начинается с `1`. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — Длина требуемого среза. Если указано отрицательное значение, функция возвращает открытый срез `[offset, array_length - length]`. Если значение опущено, функция возвращает срез `[offset, the_end_of_array]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает срез массива длиной `length` элементов, начиная с указанного `offset` [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```


## arraySort {#arraySort}

Добавлена в: v1.1

Сортирует элементы переданного массива в порядке возрастания.
Если задана лямбда-функция `f`, порядок сортировки определяется результатом
применения лямбда-функции к каждому элементу массива.
Если лямбда принимает несколько аргументов, функции `arraySort` передаётся несколько
массивов, которые соответствуют аргументам `f`.

Если сортируемый массив содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` — [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**Аргументы**

* `f(y1[, y2 ... yN])` — лямбда-функция, которую нужно применить к элементам массива `x`. - `arr` — массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array) - `arr1, ..., yN` — необязательно. N дополнительных массивов, если `f` принимает несколько аргументов.

**Возвращаемое значение**

Возвращает массив `arr`, отсортированный по возрастанию, если лямбда-функция не задана; в противном случае возвращает массив, отсортированный в соответствии с логикой переданной лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**Пример 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**Пример 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit {#arraySplit}

Введена в: v20.1

Разделяет исходный массив на несколько массивов. Когда `func(x [, y1, ..., yN])` возвращает значение, отличное от нуля, массив будет разделён слева от элемента. Массив не будет разделён перед первым элементом.

**Синтаксис**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [Лямбда-функция](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив, который нужно разделить [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив массивов [`Array(Array(T))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```


## arraySum {#arraySum}

Впервые представлен в версии: v21.1

Возвращает сумму элементов исходного массива.

Если задана лямбда-функция `func`, возвращает сумму значений, полученных при её применении.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательно. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает сумму элементов исходного массива или сумму элементов результата лямбда-функции, если она задана.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**Использование лямбда-функции**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```


## arraySymmetricDifference {#arraySymmetricDifference}

Введена в версии: v25.4

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют не во всех исходных массивах. Результат содержит только уникальные значения.

:::note
Симметрическая разность *более чем двух множеств* [математически определяется](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)
как множество всех входных элементов, которые встречаются в нечётном числе входных множеств.
В отличие от этого определения, функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые не встречаются во всех входных множествах.
:::

**Синтаксис**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**Аргументы**

* `arrN` — N массивов, из которых формируется новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив уникальных элементов, которые не присутствуют во всех исходных массивах [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion {#arrayUnion}

Появилась в версии: v24.10

Принимает несколько массивов и возвращает массив, который содержит все элементы, присутствующие хотя бы в одном из исходных массивов. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

* `arrN` — N массивов, из которых формируется новый массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив без дубликатов значений из исходных массивов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq {#arrayUniq}

Появилась в версии: v1.1

Если передан один аргумент, функция считает количество различных элементов в массиве.
Если передано несколько аргументов, функция считает количество различных **кортежей**, составленных из элементов на одинаковых позициях в нескольких массивах.

Например, `SELECT arrayUniq([1,2], [3,4], [5,6])` сформирует следующие кортежи:

* Позиция 1: (1,3,5)
* Позиция 2: (2,4,6)

Затем будет посчитано количество уникальных кортежей. В данном случае — `2`.

Все переданные массивы должны иметь одинаковую длину.

:::tip
Если требуется получить список уникальных элементов в массиве, можно использовать `arrayReduce('groupUniqArray', arr)`.
:::

**Синтаксис**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**Аргументы**

* `arr1` — Массив, для которого считается количество уникальных элементов. [`Array(T)`](/sql-reference/data-types/array)
* `[, arr2, ..., arrN]` — Необязательный аргумент. Дополнительные массивы, по которым считается количество уникальных кортежей элементов, стоящих на соответствующих позициях в нескольких массивах. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Для одного аргумента возвращает количество уникальных
элементов. Для нескольких аргументов возвращает количество уникальных кортежей, составленных из
элементов на соответствующих позициях во всех массивах.
[`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Один аргумент**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**Несколько аргументов**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```


## arrayWithConstant {#arrayWithConstant}

Введена в версии: v20.1

Создаёт массив длины `length`, заполненный константой `x`.

**Синтаксис**

```sql
arrayWithConstant(N, x)
```

**Аргументы**

* `length` — Количество элементов в массиве. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `x` — Значение для `N` элементов массива, любого типа.

**Возвращаемое значение**

Возвращает массив из `N` элементов, каждый со значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```


## arrayZip {#arrayZip}

Введена в: v20.1

Объединяет несколько массивов в один. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**Аргументы**

* `arr1, arr2, ... , arrN` — N массивов для объединения в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, элементы которого представляют собой кортежи, сформированные из исходных массивов. Типы данных в кортеже совпадают с типами входных массивов и расположены в том же порядке, в котором массивы передаются в функцию. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned {#arrayZipUnaligned}

Введена в: v20.1

Объединяет несколько массивов в один, при этом допускаются невыравненные массивы (массивы разной длины). Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке.

**Синтаксис**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

* `arr1, arr2, ..., arrN` — N массивов, которые требуется объединить в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, элементы которого представляют собой кортежи, сформированные из элементов исходных массивов. Типы данных в кортеже совпадают с типами входных массивов и располагаются в том же порядке, в котором массивы были переданы. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual {#countEqual}

Функция появилась в версии: v1.1

Возвращает количество элементов в массиве, равных `x`. Эквивалентно `arrayCount(elem -> elem = x, arr)`.

Элементы `NULL` обрабатываются как отдельные значения.

**Синтаксис**

```sql
countEqual(arr, x)
```

**Аргументы**

* `arr` — Массив, в котором ведётся поиск. [`Array(T)`](/sql-reference/data-types/array)
* `x` — Значение в массиве, количество вхождений которого нужно посчитать. Любой тип.

**Возвращаемое значение**

Возвращает количество элементов массива, равных `x`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```


## empty {#empty}

Появилась в версии: v1.1

Проверяет, является ли входной массив пустым.

Массив считается пустым, если он не содержит ни одного элемента.

:::note
Её работу можно оптимизировать, включив настройку [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подстолбец [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всего столбца массива. Запрос `SELECT empty(arr) FROM TABLE;` преобразуется в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает для значений типов String или UUID.

**Синтаксис**

```sql
empty(arr)
```

**Аргументы**

* `arr` — входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для пустого массива или `0` для непустого массива [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate {#emptyArrayDate}

Введена в версии: v1.1

Возвращает пустой массив типа Date

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив значений типа Date. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```


## emptyArrayDateTime {#emptyArrayDateTime}

Введена в версии: v1.1

Возвращает пустой массив типа DateTime

**Синтаксис**

```sql
emptyArrayDateTime()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив DateTime. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```


## emptyArrayFloat32 {#emptyArrayFloat32}

Появилась в версии: v1.1

Возвращает пустой массив типа Float32

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив Float32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```


## emptyArrayFloat64 {#emptyArrayFloat64}

Появилась в версии: v1.1

Возвращает пустой массив типа Float64

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

* Нет аргументов.

**Возвращаемое значение**

Пустой массив Float64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```


## emptyArrayInt16 {#emptyArrayInt16}

Введён в версии: v1.1

Возвращает пустой массив Int16

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив типа Int16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```


## emptyArrayInt32 {#emptyArrayInt32}

Появилась в версии: v1.1

Возвращает пустой массив типа Int32

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив типа Int32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```


## emptyArrayInt64 {#emptyArrayInt64}

Функция появилась в версии: v1.1

Возвращает пустой массив Int64

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив Int64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```


## emptyArrayInt8 {#emptyArrayInt8}

Появилась в версии: v1.1

Возвращает пустой массив типа Int8

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив Int8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```


## emptyArrayString {#emptyArrayString}

Появилась в версии: v1.1

Возвращает пустой массив типа String

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив типа String. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```


## emptyArrayToSingle {#emptyArrayToSingle}

Появилась в версии: v1.1

Принимает пустой массив и возвращает массив с одним элементом, равным значению по умолчанию.

**Синтаксис**

```sql
emptyArrayToSingle(arr)
```

**Аргументы**

* `arr` — пустой массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив с одним значением типа по умолчанию для `Array`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовый пример**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16 {#emptyArrayUInt16}

Введена в версии: v1.1

Возвращает пустой массив UInt16

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив типа UInt16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```


## emptyArrayUInt32 {#emptyArrayUInt32}

Введена в версии: v1.1

Возвращает пустой массив UInt32

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив типа UInt32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```


## emptyArrayUInt64 {#emptyArrayUInt64}

Функция появилась в версии: v1.1

Возвращает пустой массив UInt64

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив UInt64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```


## emptyArrayUInt8 {#emptyArrayUInt8}

Введена в версии: v1.1

Возвращает пустой массив типа UInt8

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив UInt8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```


## has {#has}

Появилась в версии: v1.1

Возвращает, содержит ли массив указанный элемент.

**Синтаксис**

```sql
has(arr, x)
```

**Аргументы**

* `arr` — исходный массив. [`Array(T)`](/sql-reference/data-types/array)
* `x` — значение, которое нужно найти в массиве.

**Возвращаемое значение**

Возвращает `1`, если массив содержит указанный элемент, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**Не найдено**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```


## hasAll {#hasAll}

Появилась в версии: v1.1

Проверяет, является ли один массив подмножеством другого.

* Пустой массив является подмножеством любого массива.
* `Null` обрабатывается как значение.
* Порядок значений в обоих массивах не имеет значения.

**Синтаксис**

```sql
hasAll(set, subset)
```

**Аргументы**

* `set` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `subset` — массив любого типа, имеющий с `set` общий супертип и содержащий элементы, для которых нужно проверить, все ли они содержатся в `set`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

* `1`, если `set` содержит все элементы из `subset`.
* `0`, в противном случае.

Вызывается исключение `NO_COMMON_TYPE`, если элементы `set` и `subset` не имеют общего супертипа.

**Примеры**

**Пустые массивы**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**Массивы, содержащие NULL**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**Массивы, содержащие элементы другого типа**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**Массивы, содержащие значения String**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Массивы без единого типа**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Raises a NO_COMMON_TYPE exception
```

**Массив массивов**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```


## hasAny {#hasAny}

Появилась в версии: v1.1

Проверяет, имеют ли два массива общие элементы.

* `Null` обрабатывается как значение.
* Порядок значений в обоих массивах не имеет значения.

**Синтаксис**

```sql
hasAny(arr_x, arr_y)
```

**Аргументы**

* `arr_x` — массив произвольного типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — массив произвольного типа, имеющий общий супертиип с массивом `arr_x`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

* `1`, если `arr_x` и `arr_y` имеют хотя бы один общий элемент.
* `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если какие-либо элементы двух массивов не имеют общего супертиипа.

**Примеры**

**Один из массивов пустой**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**Массивы, содержащие NULL**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**Массивы, содержащие значения другого типа**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**Массивы без общего типа элементов**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

**Массив массивов**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```


## hasSubstr {#hasSubstr}

Появилась в версии: v20.6

Проверяет, появляются ли все элементы `array2` в `array1` в точно таком же порядке.
Следовательно, функция вернёт `1` тогда и только тогда, когда array1 = prefix + array2 + suffix.

Другими словами, функция проверяет, что все элементы `array2` содержатся в `array1`, как функция `hasAll`.
Кроме того, она проверяет, что элементы встречаются в одном и том же порядке и в array1, и в array2.

* Функция вернёт `1`, если array2 пуст.
* `Null` обрабатывается как значение. Другими словами, `hasSubstr([1, 2, NULL, 3, 4], [2,3])` вернёт `0`. Однако `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` вернёт `1`.
* Порядок значений в обоих массивах имеет значение.

Вызывает исключение `NO_COMMON_TYPE`, если какой-либо из элементов двух массивов не имеет общего супертипа.

**Синтаксис**

```sql
hasSubstr(arr1, arr2)
```

**Аргументы**

* `arr1` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `arr2` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если массив `arr1` содержит массив `arr2`. В противном случае возвращает `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Оба массива пусты**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**Массивы, содержащие NULL-значения**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**Массивы, содержащие значения разных типов**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**Массивы, содержащие строки**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Массивы с корректным порядком**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**Массивы с некорректным порядком**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**Массив массивов**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**Массивы без общего типа элементов**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```


## indexOf {#indexOf}

Введена в версии: v1.1

Возвращает индекс первого элемента со значением &#39;x&#39; (начиная с 1), если он присутствует в массиве.
Если массив не содержит искомого значения, функция возвращает `0`.

Элементы со значением `NULL` обрабатываются как обычные значения.

**Синтаксис**

```sql
indexOf(arr, x)
```

**Аргументы**

* `arr` — Массив, в котором выполняется поиск значения `x`. [`Array(T)`](/sql-reference/data-types/array)
* `x` — Значение первого совпадающего элемента в `arr`, индекс которого нужно вернуть. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация начинается с единицы) первого вхождения `x` в `arr`, если такой элемент существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**Массив с NULL-значениями**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```


## indexOfAssumeSorted {#indexOfAssumeSorted}

Введена в версии: v24.12

Возвращает индекс первого элемента со значением `x` (начиная с `1`), если он присутствует в массиве.
Если массив не содержит искомого значения, функция возвращает `0`.

:::note
В отличие от функции `indexOf`, эта функция предполагает, что массив отсортирован
по возрастанию. Если массив не отсортирован, результат не определён.
:::

**Синтаксис**

```sql
indexOfAssumeSorted(arr, x)
```

**Аргументы**

* `arr` — Отсортированный массив, в котором выполняется поиск. [`Array(T)`](/sql-reference/data-types/array)
* `x` — Значение первого совпадающего элемента в отсортированном `arr`, индекс которого нужно вернуть. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация начинается с единицы) первого `x` в `arr`, если такой элемент существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```


## length {#length}

Появилась в версии: v1.1

Вычисляет длину строки или массива.

* Для аргументов типа String или FixedString: вычисляет количество байт в строке.
* Для аргументов типа Array: вычисляет количество элементов в массиве.
* При применении к аргументу типа FixedString функция является константным выражением.

Обратите внимание, что количество байт в строке отличается от количества
Unicode &quot;кодовых точек&quot;, количества Unicode &quot;графемных кластеров&quot;
(того, что мы обычно называем &quot;символами&quot;), а также от видимой ширины строки.

В строках могут присутствовать байты ASCII NULL — они также будут учитываться.

**Синтаксис**

```sql
length(x)
```

**Псевдонимы**: `OCTET_LENGTH`

**Аргументы**

* `x` — Значение, для которого нужно вычислить количество байт (для String/FixedString) или элементов (для Array). [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество байт в String/FixedString `x` или количество элементов в массиве `x`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример для String**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**Пример массива**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**пример constexpr**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**пример Unicode**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**Пример ascii&#95;vs&#95;utf8**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty {#notEmpty}

Впервые представлена в версии: v1.1

Проверяет, является ли входной массив непустым.

Массив считается непустым, если он содержит по крайней мере один элемент.

:::note
Может быть оптимизирована путём включения параметра [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подстолбец [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всего столбца массива. Запрос `SELECT notEmpty(arr) FROM table` преобразуется в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функция также работает для типов String и UUID.

**Синтаксис**

```sql
notEmpty(arr)
```

**Аргументы**

* `arr` — входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для непустого массива или `0` для пустого массива, значение типа [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```


## range {#range}

Введён в версии: v1.1

Возвращает массив чисел от `start` до `end - 1` с шагом `step`.

Поддерживаемые типы:

* `UInt8/16/32/64`

* `Int8/16/32/64`

* Все аргументы `start`, `end`, `step` должны быть одним из перечисленных выше поддерживаемых типов. Элементы возвращаемого массива будут супертипом этих аргументов.

* Генерируется исключение, если функция возвращает массив с общей длиной, превышающей число элементов, заданное настройкой [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block).

* Возвращает `NULL`, если какой-либо аргумент имеет тип `Nullable(nothing)`. Генерируется исключение, если какой-либо аргумент имеет значение `NULL` (тип `Nullable(T)`).

**Синтаксис**

```sql
range([start, ] end [, step])
```

**Аргументы**

* `start` — Необязательный аргумент. Первый элемент массива. Обязателен, если используется `step`. Значение по умолчанию: `0`. - `end` — Обязательный аргумент. Число, до которого (не включая его) строится массив. - `step` — Необязательный аргумент. Определяет шаг между элементами массива. Значение по умолчанию: `1`.

**Возвращаемое значение**

Массив чисел от `start` до `end - 1` с шагом `step`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate {#replicate}

Появилась в версии: v1.1

Создаёт массив с одним значением.

**Синтаксис**

```sql
replicate(x, arr)
```

**Аргументы**

* `x` — Значение, которым заполняется результирующий массив. [`Any`](/sql-reference/data-types)
* `arr` — Массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив той же длины, что и `arr`, заполненный значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse {#reverse}

Представлена в версии: v1.1

Меняет порядок элементов во входном массиве или символов во входной строке на обратный.

**Синтаксис**

```sql
reverse(arr | str)
```

**Аргументы**

* `arr | str` — исходный массив или строка. [`Array(T)`](/sql-reference/data-types/array) или [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив или строку с элементами или символами в обратном порядке.

**Примеры**

**Обратный порядок элементов массива**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**Обращение строки**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

{/*AUTOGENERATED_END*/ }


## Функции расстояний {#distance-functions}

Все поддерживаемые функции описаны в [документации по функциям расстояний](../../sql-reference/functions/distance-functions.md).

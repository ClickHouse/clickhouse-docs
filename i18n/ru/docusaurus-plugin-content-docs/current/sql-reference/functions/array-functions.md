---
description: 'Документация по функциям массивов'
sidebar_label: 'Массивы'
slug: /sql-reference/functions/array-functions
title: 'Функции массивов'
doc_type: 'reference'
---

# Функции массивов \{#array-functions\}

{/* 
  Внутреннее содержимое приведённых ниже тегов заменяется на этапе сборки фреймворка документации 
  документами, сгенерированными из system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }


## array \{#array\}

Добавлено в: v1.1

Создает массив из аргументов функции.

Аргументы должны быть константами и иметь типы с общим супертипом.
Должен быть передан как минимум один аргумент, иначе непонятно, какой тип массива создавать.
Это означает, что вы не можете использовать эту функцию для создания пустого массива. Для этого используйте функции семейства `emptyArray*`.

Используйте оператор `[ ]` для получения того же результата.

**Синтаксис**

```sql
array(x1 [, x2, ..., xN])
```

**Аргументы**

* `x1` — константное значение любого типа T. Если указан только этот аргумент, массив будет иметь тип T.
* `[, x2, ..., xN]` — дополнительные N константных значений, имеющих общий надтип с `x1`.

**Возвращаемое значение**

Возвращает массив, где &#39;T&#39; — наименьший общий тип среди переданных аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Корректное использование**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**Некорректное использование**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```


## arrayAUCPR \{#arrayAUCPR\}

Введена в версии: v20.4

Вычисляет площадь под кривой precision-recall (PR).
Кривая precision-recall строится путём откладывания precision по оси Y и recall по оси X для всех порогов.
Результирующее значение лежит в диапазоне от 0 до 1, при этом более высокое значение указывает на лучшее качество модели.
PR AUC особенно полезна для несбалансированных наборов данных, обеспечивая более наглядное сравнение качества по сравнению с ROC AUC в таких случаях.
Для получения дополнительной информации см. [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**Псевдонимы**: `arrayPRAUC`

**Аргументы**

* `cores` — Оценки (скоринги), которые выдает модель предсказания. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — Метки объектов, обычно 1 для положительного объекта и 0 для отрицательного. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Enum)`](/sql-reference/data-types/array)
* `partial_offsets` —
* Необязательный параметр. [`Array(T)`](/sql-reference/data-types/array) из трех неотрицательных целых чисел для вычисления частичной площади под PR-кривой (эквивалент вертикальной полосы в PR-пространстве) вместо полной AUC. Эта опция полезна для распределенного вычисления PR AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`].
  * `higher_partitions_tp`: Количество положительных меток в партициях с более высокими значениями оценок.
  * `higher_partitions_fp`: Количество отрицательных меток в партициях с более высокими значениями оценок.
  * `total_positives`: Общее количество положительных объектов во всем наборе данных.

:::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны представлять собой только партицию всего набора данных, содержащую некоторый интервал значений оценок.
Набор данных должен быть разделен на смежные партиции, где каждая партиция содержит подмножество данных, значения оценок которого попадают в определенный диапазон.
Например:

* Одна партиция может содержать все оценки в диапазоне [0, 0.5).
* Другая партиция может содержать оценки в диапазоне [0.5, 1.0].
  :::

**Возвращаемое значение**

Возвращает площадь под кривой «точность — полнота» (PR). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll \{#arrayAll\}

Впервые представлена в: v1.1

Возвращает `1`, если лямбда-функция `func(x [, y1, y2, ... yN])` возвращает `true` для всех элементов массива. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов-условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — Необязательно. N массивов-условий, передающих дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает true для всех элементов, иначе — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Все элементы удовлетворяют условию**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**Не все элементы совпадают**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg \{#arrayAvg\}

Введена в: v21.1

Возвращает среднее значение элементов исходного массива.

Если указана лямбда-функция `func`, возвращает среднее значение элементов, полученных в результате её применения.

**Синтаксис**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда‑функция, которая применяется к элементам исходного массива (`x`) и массивов‑условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов‑условий, передающих дополнительные аргументы в лямбда‑функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает среднее значение элементов исходного массива или среднее значение результатов применения лямбда‑функции к элементам массива, если она задана. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```


## arrayCompact \{#arrayCompact\}

Впервые представлена в версии v20.1

Удаляет подряд идущие дублирующиеся элементы из массива, включая значения `null`. Порядок значений в результирующем массиве определяется порядком в исходном массиве.

**Синтаксис**

```sql
arrayCompact(arr)
```

**Аргументы**

* `arr` — массив, из которого удаляются дубликаты. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив без повторяющихся значений. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```


## arrayConcat \{#arrayConcat\}

Впервые представлена в: v1.1

Объединяет массивы, переданные в качестве аргументов.

**Синтаксис**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**Аргументы**

* `arr1 [, arr2, ... , arrN]` — N массивов для конкатенации. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает один объединённый массив из переданных аргументов-массивов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```


## arrayCount \{#arrayCount\}

Добавлена в: v1.1

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает true.
Если `func` не задана, возвращает количество ненулевых элементов в массиве.

`arrayCount` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayCount([func, ] arr1, ...)
```

**Аргументы**

* `func` — необязательная функция, применяемая к каждому элементу массива (массивов). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1, ..., arrN` — N массивов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество элементов, для которых `func` возвращает true. Если `func` не задана, возвращает количество ненулевых элементов в массиве. [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```


## arrayCumSum \{#arrayCumSum\}

Появилась в версии v1.1

Возвращает массив частичных (префиксных, накопительных) сумм элементов исходного массива. Если указана лямбда-функция, сумма вычисляется по результатам применения лямбды к элементам массива на каждой позиции.

**Синтаксис**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

* `func` — необязательный параметр. Лямбда-функция, применяемая к элементам массива на каждой позиции. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — необязательные дополнительные массивы того же размера, передаваемые в качестве аргументов лямбда-функции, если она указана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов исходного массива. Тип результата совпадает с числовым типом элементов входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**С лямбда-выражением**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```


## arrayCumSumNonNegative \{#arrayCumSumNonNegative\}

Введена в версии v18.12

Возвращает массив частичных (накопительных) сумм элементов исходного массива, при этом любая отрицательная промежуточная сумма заменяется на ноль. Если указана лямбда-функция, сумма вычисляется из результата применения лямбды к элементам массива на каждой позиции.

**Синтаксис**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

* `func` — Необязательный параметр. Lambda‑функция, применяемая к элементам массива на каждой позиции. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — Исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — Необязательные параметры. Дополнительные массивы того же размера, передаваемые в lambda‑функцию в качестве аргументов, если она задана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов исходного массива, при этом любая отрицательная текущая сумма заменяется нулём. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**С лямбда-функцией**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```


## arrayDifference \{#arrayDifference\}

Впервые появилась в версии v1.1

Вычисляет массив разностей между соседними элементами массива.
Первый элемент результирующего массива будет равен 0, второй — `arr[1] - arr[0]`, третий — `arr[2] - arr[1]` и т.д.
Тип элементов в результирующем массиве определяется по правилам вывода типа для операции вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

```sql
arrayDifference(arr)
```

**Аргументы**

* `arr` — Массив, для которого вычисляются разности между соседними элементами. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив разностей между соседними элементами массива. [`UInt*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**Пример переполнения при использовании результирующего типа Int64**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct \{#arrayDistinct\}

Введена в версии: v1.1

Возвращает массив, содержащий только уникальные элементы исходного массива.

**Синтаксис**

```sql
arrayDistinct(arr)
```

**Аргументы**

* `arr` — массив, из которого нужно извлечь уникальные элементы. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, содержащий уникальные элементы. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct \{#arrayDotProduct\}

Добавлена в версии: v23.5

Возвращает скалярное произведение двух массивов.

:::note
Размеры двух векторов должны совпадать. Массивы и `Tuple` также могут содержать элементы разных типов.
:::

**Синтаксис**

```sql
arrayDotProduct(v1, v2)
```

**Аргументы**

* `v1` — первый вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
* `v2` — второй вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**Возвращаемое значение**

Скалярное произведение двух векторов.

:::note
Тип возвращаемого значения определяется типами аргументов. Если `Array` или `Tuple` содержат элементы разных типов, тип результата — их общий супертип.
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Примеры**

**Пример с массивом Array**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**Пример кортежа**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement \{#arrayElement\}

Добавлена в: v1.1

Возвращает элемент переданного массива с индексом `n`, где `n` может быть целым числом любого типа.
Если индекс выходит за границы массива, возвращается значение по умолчанию (0 для чисел, пустая строка для строк и т. д.),
за исключением случая, когда аргументом является неконстантный массив, а индекс — константа 0. В этом случае будет ошибка `Array indices are 1-based`.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, отсчитываемый с конца. Например, `arr[-1]` — последний элемент массива.

Оператор `[n]` обладает той же функциональностью.

**Синтаксис**

```sql
arrayElement(arr, n)
```

**Аргументы**

* `arr` — массив, в котором выполняется поиск. [`Array(T)`](/sql-reference/data-types/array). - `n` — позиция элемента, который нужно получить. [`(U)Int*`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Возвращает единый объединённый массив из переданных аргументов-массивов [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Отрицательные индексы**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**Использование обозначения [n]**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Индекс за пределами массива**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```


## arrayElementOrNull \{#arrayElementOrNull\}

Введена в: v1.1

Возвращает элемент переданного массива с индексом `n`, где `n` может быть целочисленного типа.
Если индекс выходит за границы массива, вместо значения по умолчанию возвращается `NULL`.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, отсчитываемый с конца. Например, `arr[-1]` — это последний элемент массива.

**Синтаксис**

```sql
arrayElementOrNull(arrays)
```

**Аргументы**

* `arrays` — Произвольное количество аргументов типа массив. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает единый объединённый массив из переданных аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Отрицательные индексы**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**Индекс за пределами массива**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```


## arrayEnumerate \{#arrayEnumerate\}

Впервые появилась в: v1.1

Возвращает массив `[1, 2, 3, ..., length (arr)]`

Эта функция обычно используется с предложением [`ARRAY JOIN`](/sql-reference/statements/select/array-join). Она позволяет посчитать что-либо только
один раз для каждого массива после применения `ARRAY JOIN`.
Эту функцию также можно использовать в функциях высшего порядка. Например, вы можете использовать её, чтобы получить индексы элементов массива, которые удовлетворяют условию.

**Синтаксис**

```sql
arrayEnumerate(arr)
```

**Аргументы**

* `arr` — Массив, для которого выполняется нумерация. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив `[1, 2, 3, ..., length (arr)]`. [`Array(UInt32)`](/sql-reference/data-types/array)

**Примеры**

**Простой пример с ARRAY JOIN**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense \{#arrayEnumerateDense\}

Появилась в версии: v18.12

Возвращает массив того же размера, что и исходный массив, указывая позицию первого появления каждого элемента в исходном массиве.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Аргументы**

* `arr` — Массив для перечисления. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же размера, что и `arr`, который для каждого элемента указывает позицию его первого появления во входном массиве [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked \{#arrayEnumerateDenseRanked\}

Впервые представлена в версии v20.1

Возвращает массив того же размера, что и исходный массив, указывающий позицию, в которой каждый элемент впервые встречается в исходном массиве. Позволяет выполнять нумерацию элементов многомерного массива с возможностью задать глубину обхода массива.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

* `clear_depth` — Уровень, на котором элементы перечисляются по отдельности. Должно быть меньше или равно `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — N-мерный массив для перечисления. [`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — Максимальная используемая глубина. Должна быть меньше или равна глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив, указывающий позицию первого появления каждого элемента в исходном массиве. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result is identical to what arrayEnumerateDense would give.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**Применение к многомерному массиву**

```sql title=Query
-- In this example, arrayEnumerateDenseRanked is used to obtain an array indicating, for each element of the
-- multidimensional array, what its position is among elements of the same value.
-- For the first row of the passed array, [10, 10, 30, 20], the corresponding first row of the result is [1, 1, 2, 3],
-- indicating that 10 is the first number encountered in position 1 and 2, 30 the second number encountered in position 3
-- and 20 is the third number encountered in position 4.
-- For the second row, [40, 50, 10, 30], the corresponding second row of the result is [4,5,1,2], indicating that 40
-- and 50 are the fourth and fifth numbers encountered in position 1 and 2 of that row, that another 10
-- (the first encountered number) is in position 3 and 30 (the second number encountered) is in the last position.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**Пример с повышенным значением clear&#95;depth**

```sql title=Query
-- Changing clear_depth=2 results in the enumeration occurring separately for each row anew.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq \{#arrayEnumerateUniq\}

Добавлена в версии v1.1

Возвращает массив того же размера, что и исходный, указывая для каждого элемента его порядковый номер среди элементов с тем же значением.

Эта функция полезна при использовании `ARRAY JOIN` и агрегации элементов массива.

Функция может принимать в качестве аргументов несколько массивов одного размера. В этом случае уникальность определяется для кортежей элементов, находящихся на одинаковых позициях во всех массивах.

**Синтаксис**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**Аргументы**

* `arr1` — первый массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `arr2, ...` — необязательно. Дополнительные массивы того же размера для обеспечения уникальности кортежей. [`Array(UInt32)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, в котором каждый элемент — это позиция среди элементов с тем же значением или кортежем. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**Несколько массивов**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**Агрегирование с помощью ARRAY JOIN**

```sql title=Query
-- Each goal ID has a calculation of the number of conversions (each element in the Goals nested data structure is a goal that was reached, which we refer to as a conversion)
-- and the number of sessions. Without ARRAY JOIN, we would have counted the number of sessions as sum(Sign). But in this particular case,
-- the rows were multiplied by the nested Goals structure, so in order to count each session one time after this, we apply a condition to the
-- value of the arrayEnumerateUniq(Goals.ID) function.

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked \{#arrayEnumerateUniqRanked\}

Впервые появилась в: v20.1

Возвращает массив (или многомерный массив) с теми же размерами, что и исходный массив,
в котором для каждого элемента указана его позиция среди элементов с тем же значением.
Позволяет выполнять нумерацию многомерного массива с возможностью указать, насколько глубоко просматривать массив.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

* `clear_depth` — перечислять элементы на указанном уровне вложенности отдельно. Положительное целое число, меньшее или равное `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — N-мерный массив для перечисления. [`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — максимальная эффективная глубина вложенности. Положительное целое число, меньшее или равное глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает N-мерный массив того же размера, что и `arr`, в котором каждый элемент показывает порядковый номер этого элемента среди других элементов с тем же значением. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniq would give for the same array.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**Пример 2**

```sql title=Query
-- with clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniqwould give for the same array.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**Пример 3**

```sql title=Query
-- In this example, arrayEnumerateUniqRanked is used to obtain an array indicating,
-- for each element of the multidimensional array, what its position is among elements
-- of the same value. For the first row of the passed array, [1, 2, 3], the corresponding
-- result is [1, 1, 1], indicating that this is the first time 1, 2 and 3 are encountered.
-- For the second row of the provided array, [2, 2, 1], the corresponding result is [2, 3, 3],
-- indicating that 2 is encountered for a second and third time, and 1 is encountered
-- for the second time. Likewise, for the third row of the provided array [3] the
-- corresponding result is [2] indicating that 3 is encountered for the second time.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**Пример 4**

```sql title=Query
-- Changing clear_depth=2, results in elements being enumerated separately for each row.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept \{#arrayExcept\}

Добавлена в: v25.9

Возвращает массив, содержащий элементы из `source`, которые отсутствуют в `except`, с сохранением исходного порядка.

Эта функция выполняет операцию разности множеств между двумя массивами. Для каждого элемента в `source` проверяется, существует ли такой элемент в `except` (с использованием точного сравнения). Если нет, элемент включается в результат.

Операция обладает следующими свойствами:

1. Порядок элементов из `source` сохраняется
2. Дубликаты в `source` сохраняются, если их нет в `except`
3. NULL рассматривается как отдельное значение

**Синтаксис**

```sql
arrayExcept(source, except)
```

**Аргументы**

* `source` — исходный массив с элементами для фильтрации.  [`Array(T)`](/sql-reference/data-types/array)
* `except` — массив с элементами, которые нужно исключить из результата.  [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же типа, что и входной массив, содержащий элементы из `source`, которые не были найдены в `except`.  [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**простой пример**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with&#95;nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with&#95;nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**строки**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```


## arrayExists \{#arrayExists\}

Добавлена в версии v1.1

Возвращает `1`, если в исходном массиве есть хотя бы один элемент, для которого `func(x[, y1, y2, ... yN])` возвращает `true`. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает `true` хотя бы для одного элемента, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```


## arrayFill \{#arrayFill\}

Введена в: v20.1

Функция `arrayFill` последовательно обрабатывает исходный массив от первого элемента
до последнего, вычисляя лямбда-условие в каждой позиции с использованием элементов
из исходного и условного массивов. Когда лямбда-функция возвращает false
в позиции i, функция заменяет этот элемент элементом в позиции i-1
из текущего состояния массива. Первый элемент всегда сохраняется
независимо от каких-либо условий.

**Синтаксис**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x [, y1, ..., yN])` — лямбда-функция `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, передающих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив типа [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**Пример с двумя массивами**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```


## arrayFilter \{#arrayFilter\}

Появилась в версии: v1.1

Возвращает массив, содержащий только те элементы исходного массива, для которых лямбда-функция возвращает `true`.

**Синтаксис**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов-условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов-условий, передающих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает подмножество исходного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**Пример 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```


## arrayFirst \{#arrayFirst\}

Впервые появилась в версии: v1.1

Возвращает первый элемент исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает `true`, иначе — значение по умолчанию.

**Синтаксис**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов-условий (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — необязательный параметр: N массивов-условий, передающих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `λ` истинно, в противном случае — значение по умолчанию типа `T`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**Совпадений нет**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayFirstIndex \{#arrayFirstIndex\}

Была добавлена в: v1.1

Возвращает индекс первого элемента исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает true; в противном случае возвращает `0`.

**Синтаксис**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает индекс первого элемента исходного массива, для которого `func` возвращает true, в противном случае возвращает `0` — значение типа [`UInt32`](/sql-reference/data-types/int-uint).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**Совпадений нет**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```


## arrayFirstOrNull \{#arrayFirstOrNull\}

Впервые появилась в: v1.1

Возвращает первый элемент исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает true; если такого элемента нет, возвращает `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, передающих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `func` возвращает `true`, в противном случае возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**Совпадений нет**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayFlatten \{#arrayFlatten\}

Впервые появилась в версии: v20.1

Преобразует массив массивов в плоский массив.

Особенности функции:

* Применяется к массивам с любой степенью вложенности.
* Не изменяет массивы, которые уже являются плоскими.

Плоский массив содержит все элементы из всех исходных массивов.

**Синтаксис**

```sql
arrayFlatten(arr)
```

**Псевдонимы**: `flatten`

**Аргументы**

* `arr` — многомерный массив. [`Array(Array(T))`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает плоский массив, полученный из многомерного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```


## arrayFold \{#arrayFold\}

Добавлена в версии: v23.10

Применяет лямбда-функцию к одному или нескольким массивам одинаковой длины и накапливает результаты в аккумуляторе.

**Синтаксис**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**Аргументы**

* `λ(x, x1 [, x2, x3, ... xN])` — лямбда-функция `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`, где `F` — операция, применяемая к `acc` и значениям массивов `x`, при этом результат снова передаётся как `acc`. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1 [, arr2, arr3, ... arrN]` — N массивов, над которыми выполняется операция. [`Array(T)`](/sql-reference/data-types/array)
* `acc` — аккумулирующее значение того же типа, что и возвращаемый тип лямбда-функции.

**Возвращаемое значение**

Возвращает итоговое значение `acc`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**Последовательность Фибоначчи**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**Пример с несколькими массивами**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```


## arrayIntersect \{#arrayIntersect\}

Впервые появилась в версии: v1.1

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**Аргументы**

* `arrN` — N массивов, из которых формируется новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив уникальных элементов, которые присутствуют во всех N массивах [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex \{#arrayJaccardIndex\}

Появилась в версии: v23.7

Возвращает [индекс Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) для двух массивов.

**Синтаксис**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**Аргументы**

* `arr_x` — первый массив. [`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — второй массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс Жаккара массивов `arr_x` и `arr_y` типа [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin \{#arrayJoin\}

Появилась в: v1.1

Функция `arrayJoin` принимает строку, содержащую массив, и разворачивает этот массив, генерируя несколько строк — по одной для каждого элемента массива.
Это отличается от обычных функций в ClickHouse, которые отображают входные значения в выходные в пределах одной и той же строки,
и агрегатных функций, которые принимают группу строк и «сжимают» или «сводят» их в одну итоговую строку
(или в одно значение внутри итоговой строки, если используются с `GROUP BY`).

Все значения в столбцах просто копируются, за исключением значений в столбце, к которому применяется эта функция;
они заменяются соответствующим значением из массива.

**Синтаксис**

```sql
arrayJoin(arr)
```

**Аргументы**

* `arr` — массив для разворачивания. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает набор строк, полученных при разворачивании `arr`.

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin применяется ко всем частям запроса**

```sql title=Query
-- The arrayJoin function affects all sections of the query, including the WHERE section. Notice the result 2, even though the subquery returned 1 row.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**Использование нескольких вызовов arrayJoin**

```sql title=Query
- A query can use multiple arrayJoin functions. In this case, the transformation is performed multiple times and the rows are multiplied.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**Неожиданные результаты, вызванные оптимизациями**

```sql title=Query
-- Using multiple arrayJoin with the same expression may not produce the expected result due to optimizations.
-- For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.
- e.g. arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set
    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─first_throw─┬─second_throw─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**Использование синтаксиса ARRAY JOIN**

```sql title=Query
-- Note the ARRAY JOIN syntax in the `SELECT` query below, which provides broader possibilities.
-- ARRAY JOIN allows you to convert multiple arrays with the same number of elements at a time.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Использование Tuple**

```sql title=Query
-- You can also use Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast \{#arrayLast\}

Добавлена в версии: v1.1

Возвращает последний элемент исходного массива, для которого лямбда `func(x [, y1, y2, ... yN])` возвращает true, иначе возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — lambda-функция, которая применяется к элементам исходного массива (`x`) и массивам-условиям (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1, ... , condN]` — необязательный параметр. N массивов-условий, передающих дополнительные аргументы в lambda-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого `func` возвращает true, а если такого элемента нет, — значение по умолчанию типа `T`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**Совпадений нет**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayLastIndex \{#arrayLastIndex\}

Появилась в версии: v1.1

Возвращает индекс последнего элемента в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true; в противном случае возвращает &#39;0&#39;.

**Синтаксис**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательно. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс последнего элемента исходного массива, для которого `func` возвращает истину, в противном случае возвращает `0` [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**Совпадений нет**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull \{#arrayLastOrNull\}

Введена в версии: v1.1

Возвращает последний элемент исходного массива, для которого лямбда-выражение `func(x [, y1, y2, ... yN])` возвращает `true`; в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x [, y1, ..., yN])` — лямбда‑функция, которая обрабатывает элементы исходного массива (`x`) и массивов условий (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).

- `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, передающих дополнительные аргументы лямбда‑функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого `λ` не истинно, в противном случае — `NULL`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**Совпадений нет**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance \{#arrayLevenshteinDistance\}

Добавлена в: v25.4

Вычисляет расстояние Левенштейна между двумя массивами.

**Синтаксис**

```sql
arrayLevenshteinDistance(from, to)
```

**Аргументы**

* `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array). - `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```


## arrayLevenshteinDistanceWeighted \{#arrayLevenshteinDistanceWeighted\}

Добавлено в версии: v25.4

Вычисляет расстояние Левенштейна для двух массивов с пользовательскими весами для каждого элемента.
Количество элементов в массиве и количество весов должно совпадать.

**Синтаксис**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**Аргументы**

* `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array). - `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array). - `from_weights` — веса элементов первого массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — веса элементов второго массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами с настраиваемыми весами для каждого элемента [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```


## arrayMap \{#arrayMap\}

Введена в версии v1.1

Возвращает массив, полученный из исходных массивов путём применения лямбда-функции к каждому их элементу.

**Синтаксис**

```sql
arrayMap(func, arr)
```

**Аргументы**

* `func` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов-условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — N массивов для обработки. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив из результатов работы лямбда-функции [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**Создание кортежа элементов из нескольких массивов**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax \{#arrayMax\}

Введена в версии v21.1

Возвращает максимальный элемент в исходном массиве.

Если указана лямбда-функция `func`, возвращает максимальный элемент среди результатов её выполнения.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает максимальный элемент в исходном массиве или максимальный элемент среди результатов лямбда-функции, если она передана.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin \{#arrayMin\}

Добавлена в: v21.1

Возвращает минимальный элемент исходного массива.

Если указана лямбда-функция `func`, возвращает минимальный результат применения этой лямбда-функции.

**Синтаксис**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Функция-лямбда, которая применяется к элементам исходного массива (`x`) и массивов-условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — Необязательный параметр. N массивов-условий, предоставляющих дополнительные аргументы функции-лямбды. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает минимальный элемент исходного массива или минимальный элемент результатов применения функции-лямбды, если она указана.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```


## arrayNormalizedGini \{#arrayNormalizedGini\}

Введена в версии: v25.1

Вычисляет нормализованный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

* `predicted` — Предсказанное значение. [`Array(T)`](/sql-reference/data-types/array)
* `label` — Фактическое значение. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Кортеж, содержащий коэффициент Джини для предсказанных значений, коэффициент Джини для нормализованных значений и нормализованный коэффициент Джини (= отношение первых двух коэффициентов Джини) [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort \{#arrayPartialReverseSort\}

Введена в: v23.2

Эта функция аналогична `arrayReverseSort`, но с дополнительным аргументом `limit`, позволяющим выполнять частичную сортировку.

:::tip
Чтобы оставить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

* `f(arr[, arr1, ... ,arrN])` — лямбда-функция, применяемая к элементам массива `x`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — массив, который требуется упорядочить. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — N дополнительных массивов, когда `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array)
* `limit` — значение индекса, до которого будет выполняться сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, в котором элементы в диапазоне `[1..limit]` отсортированы
по убыванию. Остальные элементы в диапазоне `(limit..N]` находятся в произвольном порядке.

**Примеры**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```


## arrayPartialShuffle \{#arrayPartialShuffle\}

Введена в версии: v23.2

Возвращает массив того же размера, что и исходный массив, в котором элементы в диапазоне `[1..limit]` представляют собой случайное подмножество исходного массива. Оставшиеся элементы `(limit..n]` содержат элементы, не входящие в диапазон `[1..limit]`, в неопределённом порядке.
Значение `limit` должно находиться в диапазоне `[1..n]`. Значения вне этого диапазона эквивалентны выполнению полного вызова `arrayShuffle`:

:::note
Эта функция не материализует константы.

Значение `limit` должно находиться в диапазоне `[1..N]`. Значения вне этого диапазона эквивалентны выполнению полного вызова [`arrayShuffle`](#arrayShuffle).
:::

**Синтаксис**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**Аргументы**

* `arr` — Массив для перемешивания. [`Array(T)`](/sql-reference/data-types/array)
* `seed` — Необязательный параметр. Значение для инициализации генератора случайных чисел. Если не задано, используется случайное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `limit` — Необязательный параметр. Число, ограничивающее количество обменов элементов, в диапазоне `[1..N]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с частично перемешанными элементами. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**no&#95;limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no&#95;limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort \{#arrayPartialSort\}

Введена в версии: v23.2

Эта функция аналогична `arraySort`, но имеет дополнительный аргумент `limit`, который позволяет выполнять частичную сортировку.

:::tip
Чтобы сохранить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

* `f(arr[, arr1, ... ,arrN])` — лямбда-функция, применяемая к элементам массива `x`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — N дополнительных массивов, если `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array)
* `limit` — значение индекса, до которого выполняется сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, в котором элементы в диапазоне `[1..limit]` отсортированы
по возрастанию. Оставшиеся элементы `(limit..N]` могут быть расположены в произвольном порядке.

**Примеры**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```


## arrayPopBack \{#arrayPopBack\}

Появилась в версии: v1.1

Удаляет последний элемент массива.

**Синтаксис**

```sql
arrayPopBack(arr)
```

**Аргументы**

* `arr` — массив, из которого нужно удалить последний элемент. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, совпадающий с `arr`, но без его последнего элемента. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```


## arrayPopFront \{#arrayPopFront\}

Впервые появилась в версии v1.1

Удаляет первый элемент массива.

**Синтаксис**

```sql
arrayPopFront(arr)
```

**Аргументы**

* `arr` — массив, из которого нужно удалить первый элемент. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но без его первого элемента. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```


## arrayProduct \{#arrayProduct\}

Впервые представлена в: v21.1

Возвращает произведение элементов исходного массива.

Если указана лямбда-функция `func`, возвращает произведение значений, полученных при применении этой функции.

**Синтаксис**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный аргумент. Функция-лямбда, которая работает с элементами исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательные аргументы. N массивов условий, предоставляющих дополнительные аргументы функции-лямбды. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает произведение элементов исходного массива или произведение значений, возвращаемых функцией-лямбдой, если она задана. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack \{#arrayPushBack\}

Появилась в версии v1.1

Добавляет один элемент в конец массива.

**Синтаксис**

```sql
arrayPushBack(arr, x)
```

**Аргументы**

* `arr` — массив, в конец которого нужно добавить значение `x`. [`Array(T)`](/sql-reference/data-types/array)
* `x` —
* одно значение, которое нужно добавить в конец массива. [`Array(T)`](/sql-reference/data-types/array).

:::note

* В массив с числами можно добавлять только числа, а в массив строк — только строки.
* При добавлении чисел ClickHouse автоматически приводит тип `x` к типу данных элементов массива.
* Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

Дополнительную информацию о типах данных в ClickHouse см. в разделе [Типы данных](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с дополнительным значением `x` в конце массива [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```


## arrayPushFront \{#arrayPushFront\}

Впервые появилась в версии: v1.1

Добавляет один элемент в начало массива.

**Синтаксис**

```sql
arrayPushFront(arr, x)
```

**Аргументы**

* `arr` — массив, к концу которого нужно добавить значение `x`. [`Array(T)`](/sql-reference/data-types/array).
* `x` — одиночное значение, которое нужно добавить в начало массива. [`Array(T)`](/sql-reference/data-types/array).

:::note

* В массив с числами можно добавлять только числа, а в массив со строками — только строки.
* При добавлении чисел ClickHouse автоматически приводит тип `x` к типу данных элементов массива.
* Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

Дополнительную информацию о типах данных в ClickHouse см. в разделе [Data types](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с дополнительным значением `x` в начале массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```


## arrayROCAUC \{#arrayROCAUC\}

Введена в версии v20.4

Вычисляет площадь под ROC-кривой (receiver operating characteristic).
ROC-кривая строится путём откладывания True Positive Rate (TPR) по оси Y и False Positive Rate (FPR) по оси X для всех пороговых значений.
Результирующее значение лежит в диапазоне от нуля до единицы, при этом более высокое значение указывает на лучшую работу модели.

ROC AUC (также известна просто как AUC) — это понятие в машинном обучении.
Для получения дополнительных сведений см. [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**Псевдонимы**: `arrayAUC`

**Аргументы**

* `scores` — Оценки, которые возвращает модель. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — Метки объектов, обычно 1 для положительного и 0 для отрицательного объекта. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Enum`](/sql-reference/data-types/enum)
* `scale` — Необязательный параметр. Определяет, возвращать ли нормированную площадь. Если `false`, возвращается площадь под кривой TP (true positives, истинно положительные) x FP (false positives, ложно положительные). Значение по умолчанию: `true`. [`Bool`](/sql-reference/data-types/boolean)
* `partial_offsets` —
* Массив из четырех неотрицательных целых чисел для вычисления частичной площади под ROC-кривой (эквивалент вертикальной полосе в ROC-пространстве) вместо полной AUC. Этот параметр полезен для распределенного вычисления ROC AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) из неотрицательных [Integers](../data-types/int-uint.md). Необязательный.
  * `higher_partitions_tp`: Число положительных меток в партициях с более высокими значениями оценок.
  * `higher_partitions_fp`: Число отрицательных меток в партициях с более высокими значениями оценок.
  * `total_positives`: Общее число положительных объектов во всем наборе данных.
  * `total_negatives`: Общее число отрицательных объектов во всем наборе данных.

:::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны представлять только одну партицию всего набора данных, содержащую интервал значений `scores`.
Набор данных должен быть разделен на смежные партиции, где каждая партиция содержит подмножество данных, чьи оценки попадают в определенный диапазон.
Например:

* Одна партиция может содержать все оценки в диапазоне [0, 0.5).
* Другая партиция может содержать оценки в диапазоне [0.5, 1.0].
  :::

**Возвращаемое значение**

Возвращает площадь под ROC-кривой (receiver operating characteristic). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```


## arrayRandomSample \{#arrayRandomSample\}

Введена в версии: v23.10

Возвращает подмножество из `samples` случайных элементов входного массива. Если `samples` превышает размер входного массива, размер выборки ограничивается размером массива, то есть возвращаются все элементы массива, но их порядок не гарантируется. Функция может работать как с плоскими, так и с вложенными массивами.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

* `arr` — Входной массив или многомерный массив, из которого выбираются элементы для выборки. [`Array(T)`](/sql-reference/data-types/array)
* `samples` — Количество элементов, которое необходимо включить в случайную выборку. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив, содержащий случайную выборку элементов из входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**Использование многомерного массива**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```


## arrayReduce \{#arrayReduce\}

Введена в версии: v1.1

Применяет агрегатную функцию к элементам массива и возвращает её результат.
Имя агрегатной функции передаётся в виде строки в одинарных кавычках: `'max'`, `'sum'`.
При использовании параметрических агрегатных функций параметр указывается после имени функции в круглых скобках: `'uniqUpTo(6)'`.

**Синтаксис**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**Аргументы**

* `agg_f` — имя агрегатной функции, которое должно быть константой. [`String`](/sql-reference/data-types/string)
* `arr1 [, arr2, ... , arrN)]` — N массивов, соответствующих аргументам `agg_f`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает результат выполнения агрегатной функции.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**Пример с агрегатной функцией, принимающей несколько аргументов**

```sql title=Query
--If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**Пример с параметризуемой агрегатной функцией**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges \{#arrayReduceInRanges\}

Появилась в версии v20.4

Применяет агрегатную функцию к элементам массива в указанных диапазонах и возвращает массив, содержащий результат для каждого диапазона.
Функция возвращает тот же результат, что и несколько вызовов `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**Аргументы**

* `agg_f` — имя агрегатной функции, которая будет использоваться. [`String`](/sql-reference/data-types/string)
* `ranges` — диапазон, по которому выполняется агрегация. Массив кортежей `(i, r)`, содержащих индекс `i`, с которого начинается агрегация, и диапазон `r`, по которому она выполняется. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T)`](/sql-reference/data-types/tuple)
* `arr1 [, arr2, ... ,arrN)]` — N массивов в качестве аргументов агрегатной функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, содержащий результаты применения агрегатной функции по указанным диапазонам, [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove \{#arrayRemove\}

Появилась в версии: v25.11

Удаляет из массива все элементы, равные заданному значению.
NULL рассматриваются как равные.

**Синтаксис**

```sql
arrayRemove(arr, elem)
```

**Псевдонимы**: `array_remove`

**Аргументы**

* `arr` — Array(T) - `elem` — T

**Возвращаемое значение**

Возвращает подмножество исходного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**Пример 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```


## arrayResize \{#arrayResize\}

Добавлена в: v1.1

Изменяет длину массива.

**Синтаксис**

```sql
arrayResize(arr, size[, extender])
```

**Аргументы**

* `arr` — Массив для изменения размера. [`Array(T)`](/sql-reference/data-types/array)
* `size` —
  * Новая длина массива.
    Если `size` меньше исходного размера массива, массив усекается справа.
    Если `size` больше исходного размера массива, массив расширяется вправо значениями `extender` или значениями по умолчанию для типа данных элементов массива.
* `extender` — Значение, которое используется для расширения массива. Может быть `NULL`.

**Возвращаемое значение**

Массив длины `size`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**Пример 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```


## arrayReverse \{#arrayReverse\}

Введена в: v1.1

Меняет порядок элементов заданного массива на обратный.

:::note
Функция `reverse(arr)` выполняет ту же задачу, но работает и с другими типами данных,
помимо массивов.
:::

**Синтаксис**

```sql
arrayReverse(arr)
```

**Аргументы**

* `arr` — массив, который нужно развернуть. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный, содержащий элементы в обратном порядке [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill \{#arrayReverseFill\}

Появилась в: v20.1

Функция `arrayReverseFill` последовательно обрабатывает исходный массив от
последнего элемента к первому, вычисляя лямбда‑условие на каждой позиции с использованием элементов
из исходного массива и массива условий. Когда условие принимает значение `false` на
позиции i, функция заменяет этот элемент элементом на позиции i+1
из текущего состояния массива. Последний элемент всегда сохраняется,
независимо от условия.

**Синтаксис**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам-условиям (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательные аргументы. N массивов-условий, передающих дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, в котором элементы исходного массива заменены результатами лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**Пример с двумя массивами**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```


## arrayReverseSort \{#arrayReverseSort\}

Введена в версии: v1.1

Сортирует элементы массива в порядке убывания.
Если указана функция `f`, исходный массив сортируется в соответствии с результатом
применения функции к элементам массива, после чего отсортированный массив разворачивается.
Если `f` принимает несколько аргументов, функции `arrayReverseSort` передаётся несколько массивов,
которые будут соответствовать аргументам `f`.

Если сортируемый массив содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**Аргументы**

* `f(y1[, y2 ... yN])` — лямбда-функция, применяемая к элементам массива `x`.
* `arr` — массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ..., yN` — необязательные аргументы. N дополнительных массивов, если `f` принимает несколько аргументов.

**Возвращаемое значение**

Возвращает массив `x`, отсортированный по убыванию, если лямбда-функция не передана; в противном случае
возвращает массив, отсортированный в соответствии с логикой указанной лямбда-функции, а затем перевёрнутый. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**Пример 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```


## arrayReverseSplit \{#arrayReverseSplit\}

Введена в: v20.1

Разбивает исходный массив на несколько массивов. Когда `func(x[, y1, ..., yN])` возвращает ненулевое значение, массив разделяется справа от этого элемента. Массив не разделяется после последнего элемента.

**Синтаксис**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — необязательный аргумент. N массивов условий, передающих дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив массивов. [`Array(Array(T))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft \{#arrayRotateLeft\}

Введена в версии v23.8

Выполняет циклический сдвиг массива влево на указанное количество элементов. Отрицательные значения `n` интерпретируются как сдвиг вправо на абсолютное значение этого числа.

**Синтаксис**

```sql
arrayRotateLeft(arr, n)
```

**Аргументы**

* `arr` — массив, для которого нужно выполнить циклический сдвиг элементов. [`Array(T)`](/sql-reference/data-types/array). - `n` — количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, циклически сдвинутый влево на заданное количество элементов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**Отрицательное значение параметра n**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```


## arrayRotateRight \{#arrayRotateRight\}

Введена в версии: v23.8

Циклически сдвигает массив вправо на указанное количество элементов. Отрицательные значения `n` интерпретируются как сдвиг влево на абсолютное значение величины сдвига.

**Синтаксис**

```sql
arrayRotateRight(arr, n)
```

**Аргументы**

* `arr` — массив, элементы которого нужно циклически сдвинуть. [`Array(T)`](/sql-reference/data-types/array). - `n` — количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, циклически сдвинутый вправо на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**Отрицательное значение параметра n**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```


## arrayShiftLeft \{#arrayShiftLeft\}

Добавлено в v23.8

Сдвигает массив влево на указанное число элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элементов массива.
Если число элементов отрицательное, массив сдвигается вправо.

**Синтаксис**

```sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

* `arr` — массив, элементы которого нужно сдвинуть. [`Array(T)`](/sql-reference/data-types/array)
* `n` — количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `default` — необязательный параметр. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

Массив, сдвинутый влево на заданное количество элементов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**Отрицательное значение параметра n**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**Использование значения по‑умолчанию**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```


## arrayShiftRight \{#arrayShiftRight\}

Добавлена в: v23.8

Сдвигает массив вправо на указанное число элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элементов массива.
Если это число отрицательно, массив сдвигается влево.

**Синтаксис**

```sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

* `arr` — Массив, элементы которого необходимо сдвинуть. [`Array(T)`](/sql-reference/data-types/array)
* `n` — Количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `default` — Необязательный параметр. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

Массив, сдвинутый вправо на указанное количество элементов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**Отрицательное значение параметра n**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**Использование значения по умолчанию**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```


## arrayShingles \{#arrayShingles\}

Впервые появилась в: v24.1

Генерирует массив шинглов (аналог n-грамм для строк), то есть последовательных подмассивов заданной длины исходного массива.

**Синтаксис**

```sql
arrayShingles(arr, l)
```

**Аргументы**

* `arr` — Массив, для которого генерируется массив шинглов. [`Array(T)`](/sql-reference/data-types/array)
* `l` — Длина каждого шингла. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив сгенерированных шинглов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle \{#arrayShuffle\}

Введена в версии v23.2

Возвращает массив того же размера, что и исходный, содержащий элементы в перемешанном порядке.
Элементы переупорядочиваются таким образом, что каждая возможная перестановка элементов равновероятна.

:::note
Эта функция не материализует константы.
:::

**Синтаксис**

```sql
arrayShuffle(arr [, seed])
```

**Аргументы**

* `arr` — Массив для перемешивания. [`Array(T)`](/sql-reference/data-types/array)
* `seed (optional)` — Необязательный параметр. Seed, используемый при генерации случайных чисел. Если не задано, используется случайное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с перемешанными элементами [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример без seed (нестабильный результат)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**Пример без значения seed (стабильный результат)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```


## arraySimilarity \{#arraySimilarity\}

Добавлено в: v25.4

Вычисляет степень сходства двух массивов от `0` до `1` на основе взвешенного расстояния Левенштейна.

**Синтаксис**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**Аргументы**

* `from` — первый массив [`Array(T)`](/sql-reference/data-types/array)
* `to` — второй массив [`Array(T)`](/sql-reference/data-types/array)
* `from_weights` — веса для первого массива [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — веса для второго массива [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает степень сходства двух массивов в диапазоне от `0` до `1` на основе взвешенного расстояния Левенштейна [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```


## arraySlice \{#arraySlice\}

Впервые появилось в версии: v1.1

Возвращает срез массива, включая элементы `NULL`.

**Синтаксис**

```sql
arraySlice(arr, offset [, length])
```

**Аргументы**

* `arr` — Массив, из которого формируется срез. [`Array(T)`](/sql-reference/data-types/array)
* `offset` — Смещение от края массива. Положительное значение задаёт смещение слева, отрицательное — смещение справа. Нумерация элементов массива начинается с `1`. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — Длина требуемого среза. Если указано отрицательное значение, функция возвращает полуоткрытый срез `[offset, array_length - length]`. Если параметр не указан, функция возвращает срез `[offset, the_end_of_array]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает срез массива с `length` элементами, начиная с указанного `offset`, [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```


## arraySort \{#arraySort\}

Введена в версии: v1.1

Сортирует элементы переданного массива по возрастанию.
Если указана лямбда-функция `f`, порядок сортировки определяется результатом
применения этой лямбды к каждому элементу массива.
Если лямбда принимает несколько аргументов, функции `arraySort` передаётся несколько
массивов, аргументы `f` будут соответствовать элементам этих массивов.

Если сортируемый массив содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**Arguments**

* `f(y1[, y2 ... yN])` — лямбда-функция, применяемая к элементам массива `x`. - `arr` — массив для сортировки. [`Array(T)`](/sql-reference/data-types/array) - `arr1, ..., yN` — необязательные: N дополнительных массивов в случае, когда `f` принимает несколько аргументов.

**Returned value**

Возвращает массив `arr`, отсортированный по возрастанию, если лямбда-функция не задана, в противном случае
возвращает массив, отсортированный в соответствии с логикой переданной лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Examples**

**Example 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**Пример 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**Пример 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit \{#arraySplit\}

Появилась в версии: v20.1

Разбивает исходный массив на несколько массивов. Когда `func(x [, y1, ..., yN])` возвращает значение, отличное от нуля, массив будет разделён слева от этого элемента. Массив не будет разделён перед первым элементом.

**Синтаксис**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая работает с элементами исходного массива (`x`) и массивов-условий (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для разбиения [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — необязательные. N массивов-условий, передающих дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив массивов [`Array(Array(T))`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```


## arraySum \{#arraySum\}

Впервые представлена в версии: v21.1

Возвращает сумму элементов исходного массива.

Если указана лямбда-функция `func`, возвращает сумму элементов, полученных в результате применения этой лямбда-функции.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда‑функция, которая работает с элементами исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ... , condN_arr` — Необязательный параметр. N массивов условий, передающих дополнительные аргументы лямбда‑функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает сумму элементов исходного массива или сумму элементов результатов лямбда‑функции, если она указана.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```


## arraySymmetricDifference \{#arraySymmetricDifference\}

Введена в версии: v25.4

Принимает несколько массивов и возвращает массив с элементами, которые есть не во всех исходных массивах. Результат содержит только уникальные значения.

:::note
Симметрическая разность *более чем двух множеств* [математически определяется](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)
как множество всех входных элементов, которые встречаются в нечётном числе входных множеств.
В отличие от этого определения, функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые присутствуют не во всех входных множествах.
:::

**Синтаксис**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**Аргументы**

* `arrN` — N массивов, на основании которых создаётся новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив различных элементов, которые не присутствуют во всех исходных массивах. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion \{#arrayUnion\}

Добавлена в версии v24.10

Принимает несколько массивов и возвращает массив, который содержит все элементы, присутствующие хотя бы в одном из исходных массивов. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

* `arrN` — N массивов, из которых создаётся новый массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, содержащий уникальные элементы исходных массивов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq \{#arrayUniq\}

Добавлена в: v1.1

При передаче одного аргумента функция подсчитывает количество различных элементов в массиве.
При передаче нескольких аргументов она подсчитывает количество различных **кортежей**, составленных из элементов на соответствующих позициях в нескольких массивах.

Например, `SELECT arrayUniq([1,2], [3,4], [5,6])` сформирует следующие кортежи:

* Позиция 1: (1,3,5)
* Позиция 2: (2,4,6)

Затем будет подсчитано количество уникальных кортежей. В данном случае `2`.

Все переданные массивы должны иметь одинаковую длину.

:::tip
Если нужно получить список уникальных элементов в массиве, можно использовать `arrayReduce('groupUniqArray', arr)`.
:::

**Синтаксис**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**Аргументы**

* `arr1` — Массив, для которого считается количество уникальных элементов. [`Array(T)`](/sql-reference/data-types/array)
* `[, arr2, ..., arrN]` — Необязательный. Дополнительные массивы, используемые для подсчёта количества уникальных кортежей элементов на соответствующих позициях в нескольких массивах. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Для одного аргумента возвращает количество уникальных
элементов. Для нескольких аргументов возвращает количество уникальных кортежей, составленных из
элементов на соответствующих позициях во всех массивах.
[`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Один аргумент**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**Несколько аргументов**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```


## arrayWithConstant \{#arrayWithConstant\}

Добавлено в: v20.1

Создаёт массив длины `length`, заполненный значением `x`.

**Синтаксис**

```sql
arrayWithConstant(N, x)
```

**Аргументы**

* `length` — количество элементов в массиве. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `x` — значение, которым заполняются `N` элементов массива, произвольного типа. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив типа [`Array(T)`](/sql-reference/data-types/array) из `N` элементов со значением `x`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```


## arrayZip \{#arrayZip\}

Введена в: v20.1

Объединяет несколько массивов в один массив. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в порядке следования аргументов.

**Синтаксис**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**Аргументы**

* `arr1, arr2, ... , arrN` — N массивов, которые нужно объединить в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, элементы которого представляют собой кортежи, составленные из элементов исходных массивов. Типы данных в кортеже такие же, как типы входных массивов, и следуют в том же порядке, в котором переданы массивы. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned \{#arrayZipUnaligned\}

Добавлена в: v20.1

Объединяет несколько массивов в один массив, при этом допускаются невыравненные массивы (массивы разной длины). Полученный массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

* `arr1, arr2, ..., arrN` — N массивов для объединения в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с элементами исходных массивов, сгруппированными в кортежи. Типы данных в кортеже совпадают с типами входных массивов и расположены в том же порядке, в каком массивы переданы. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual \{#countEqual\}

Появилась в версии: v1.1

Возвращает количество элементов массива, равных `x`. Эквивалентна `arrayCount(elem -> elem = x, arr)`.

Элементы со значением `NULL` считаются отдельными значениями.

**Синтаксис**

```sql
countEqual(arr, x)
```

**Аргументы**

* `arr` — массив для поиска. [`Array(T)`](/sql-reference/data-types/array)
* `x` — значение в массиве, которое нужно посчитать. Любого типа.

**Возвращаемое значение**

Возвращает количество элементов в массиве, равных `x` [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```


## empty \{#empty\}

Впервые появилась в версии v1.1.

Проверяет, является ли входной массив пустым.

Массив считается пустым, если он не содержит ни одного элемента.

:::note
Можно оптимизировать, включив настройку [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подстолбец [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всего столбца массива. Запрос `SELECT empty(arr) FROM TABLE;` преобразуется в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает для значений типа String или UUID.

**Синтаксис**

```sql
empty(arr)
```

**Аргументы**

* `arr` — входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для пустого массива или `0` для непустого массива, тип [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate \{#emptyArrayDate\}

Добавлена в версии: v1.1

Возвращает пустой массив типа Date

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив типа Date. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```


## emptyArrayDateTime \{#emptyArrayDateTime\}

Введена в версии: v1.1

Возвращает пустой массив DateTime

**Синтаксис**

```sql
emptyArrayDateTime()
```

**Аргументы**

* Нет аргументов.

**Возвращаемое значение**

Пустой массив типа DateTime. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```


## emptyArrayFloat32 \{#emptyArrayFloat32\}

Добавлена в: v1.1

Возвращает пустой массив Float32

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив типа Float32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```


## emptyArrayFloat64 \{#emptyArrayFloat64\}

Добавлена в версии: v1.1

Возвращает пустой массив типа Float64

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив Float64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```


## emptyArrayInt16 \{#emptyArrayInt16\}

Появилась в версии: v1.1

Возвращает пустой массив типа Int16

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив типа Int16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```


## emptyArrayInt32 \{#emptyArrayInt32\}

Добавлена в версии v1.1

Возвращает пустой массив Int32

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

* Нет аргументов.

**Возвращаемое значение**

Пустой массив Int32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```


## emptyArrayInt64 \{#emptyArrayInt64\}

Появилась в версии: v1.1

Возвращает пустой массив Int64

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив Int64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```


## emptyArrayInt8 \{#emptyArrayInt8\}

Добавлена в версии: v1.1

Возвращает пустой массив типа Int8

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив Int8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```


## emptyArrayString \{#emptyArrayString\}

Добавлена в версии: v1.1

Возвращает пустой массив типа String

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

* Нет аргументов.

**Возвращаемое значение**

Пустой массив строк. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```


## emptyArrayToSingle \{#emptyArrayToSingle\}

Введена в: v1.1

Принимает пустой массив и возвращает массив с одним элементом, равным значению по умолчанию.

**Синтаксис**

```sql
emptyArrayToSingle(arr)
```

**Аргументы**

* `arr` — пустой массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив с одним значением типа по умолчанию для массива `Array`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Простой пример**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16 \{#emptyArrayUInt16\}

Добавлено в: v1.1

Возвращает пустой массив UInt16

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив типа UInt16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```


## emptyArrayUInt32 \{#emptyArrayUInt32\}

Добавлена в версии v1.1

Возвращает пустой массив UInt32

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив UInt32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```


## emptyArrayUInt64 \{#emptyArrayUInt64\}

Введено в: v1.1

Возвращает пустой массив UInt64

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

* Нет

**Возвращаемое значение**

Пустой массив UInt64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```


## emptyArrayUInt8 \{#emptyArrayUInt8\}

Добавлена в версии: v1.1

Возвращает пустой массив UInt8

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив типа UInt8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```


## has \{#has\}

Введена в: v1.1

Возвращает, содержит ли массив указанный элемент.

Когда первый аргумент — константный массив, а второй аргумент — столбец или выражение, `has(constant_array, column)` ведет себя как `column IN (constant_array)` и может использовать первичный ключ и индексы пропуска данных для оптимизации. Например, `has([1, 10, 100], id)` может задействовать индекс по первичному ключу, если `id` является частью `PRIMARY KEY`.

Эта оптимизация также применяется, когда столбец обернут монотонными функциями (например, `has([...], toDate(ts))`).

**Синтаксис**

```sql
has(arr, x)
```

**Аргументы**

* `arr` — исходный массив. [`Array(T)`](/sql-reference/data-types/array)
* `x` — значение, которое нужно найти в массиве.

**Возвращаемое значение**

Возвращает `1`, если массив содержит указанный элемент, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**Не найдено**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```


## hasAll \{#hasAll\}

Добавлена в версии v1.1

Проверяет, является ли один массив подмножеством другого.

* Пустой массив является подмножеством любого массива.
* `Null` обрабатывается как значение.
* Порядок значений в обоих массивах не имеет значения.

**Синтаксис**

```sql
hasAll(set, subset)
```

**Аргументы**

* `set` — Массив произвольного типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `subset` — Массив произвольного типа, который имеет общий супертип с `set` и содержит элементы, подлежащие проверке на то, что они образуют подмножество `set`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

* `1`, если `set` содержит все элементы из `subset`.
* `0` — в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы `set` и `subset` не имеют общего супертипа.

**Примеры**

**Пустые массивы**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**Массивы, содержащие NULL**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**Массивы, содержащие значения другого типа данных**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**Массивы со значениями типа String**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Массивы без общего типа данных**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Raises a NO_COMMON_TYPE exception
```

**Массив массивов**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```


## hasAny \{#hasAny\}

Добавлена в версии: v1.1

Проверяет, имеют ли два массива общие элементы.

* `Null` обрабатывается как значение.
* Порядок значений в обоих массивах не учитывается.

**Синтаксис**

```sql
hasAny(arr_x, arr_y)
```

**Аргументы**

* `arr_x` — Массив произвольного типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — Массив произвольного типа, имеющий общий супертип с массивом `arr_x`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

* `1`, если `arr_x` и `arr_y` имеют по крайней мере один общий элемент.
* `0` в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если какие-либо элементы двух массивов не имеют общего супертипа.

**Примеры**

**Один массив пустой**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**Массивы, содержащие значения NULL**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**Массивы, содержащие значения разных типов**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**Массивы без единого типа**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

**Массивы массивов**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```


## hasSubstr \{#hasSubstr\}

Впервые представлена в: v20.6

Проверяет, что все элементы массива array2 встречаются в массиве array1 в точно таком же порядке.
Соответственно, функция возвращает `1` тогда и только тогда, когда array1 = prefix + array2 + suffix.

Другими словами, функция проверяет, что все элементы array2 содержатся в array1, как это делает функция `hasAll`.
Дополнительно она проверяет, что элементы идут в одном и том же порядке и в array1, и в array2.

* Функция возвращает `1`, если array2 пуст.
* `Null` обрабатывается как значение. Другими словами, `hasSubstr([1, 2, NULL, 3, 4], [2,3])` вернёт `0`. Однако `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` вернёт `1`.
* Порядок значений в обоих массивах имеет значение.

Вызывает исключение `NO_COMMON_TYPE`, если какой-либо из элементов двух массивов не имеет общего супертипа.

**Синтаксис**

```sql
hasSubstr(arr1, arr2)
```

**Аргументы**

* `arr1` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `arr2` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если массив `arr1` содержит массив `arr2`. В противном случае возвращает `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Оба массива пустые**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**Массивы, содержащие значения NULL**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**Массивы, содержащие элементы другого типа**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**Массивы строк**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Массивы с допустимым порядком элементов**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**Массивы с некорректным порядком**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**Массив массивов**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**Массивы без общего типа элементов**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```


## indexOf \{#indexOf\}

Впервые добавлена в версии: v1.1

Возвращает индекс первого элемента со значением &#39;x&#39; (начиная с 1), если такой элемент есть в массиве.
Если массив не содержит искомого значения, функция возвращает `0`.

Элементы со значением `NULL` обрабатываются как обычные значения.

**Синтаксис**

```sql
indexOf(arr, x)
```

**Аргументы**

* `arr` — Массив, в котором выполняется поиск значения `x`. [`Array(T)`](/sql-reference/data-types/array)
* `x` — Значение первого элемента в `arr`, индекс которого нужно вернуть. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация с единицы) первого элемента `x` в `arr`, если он существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**Массив с NULL-значениями**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```


## indexOfAssumeSorted \{#indexOfAssumeSorted\}

Добавлена в версии: v24.12

Возвращает индекс первого элемента со значением &#39;x&#39; (начиная с `1`), если он присутствует в массиве.
Если массив не содержит искомого значения, функция возвращает `0`.

:::note
В отличие от функции `indexOf`, эта функция предполагает, что массив отсортирован
по возрастанию. Если массив не отсортирован, результат неопределён.
:::

**Синтаксис**

```sql
indexOfAssumeSorted(arr, x)
```

**Аргументы**

* `arr` — отсортированный массив, в котором выполняется поиск. [`Array(T)`](/sql-reference/data-types/array)
* `x` — значение первого совпадающего элемента в отсортированном массиве `arr`, индекс которого нужно вернуть. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация с единицы) первого `x` в `arr`, если такое значение существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```


## length \{#length\}

Введена в: v1.1

Вычисляет длину строки или массива.

* Для аргументов типа String или FixedString: вычисляет количество байт в строке.
* Для аргументов типа Array: вычисляет количество элементов в массиве.
* При применении к аргументу типа FixedString функция является константным выражением.

Обратите внимание, что количество байт в строке не совпадает с количеством
Unicode «code points» и не совпадает с количеством Unicode «grapheme clusters»
(того, что мы обычно называем «символами»), и не совпадает с видимой шириной строки.

В строках допустимы нулевые байты ASCII (NULL), и они также будут учитываться.

**Синтаксис**

```sql
length(x)
```

**Псевдонимы**: `OCTET_LENGTH`

**Аргументы**

* `x` — значение, для которого нужно вычислить количество байт (для String/FixedString) или элементов (для Array). [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество байт в String/FixedString `x` или количество элементов в массиве `x`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример для String**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**Пример с массивом**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**пример constexpr**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**пример с Unicode**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**пример ASCII&#95;vs&#95;UTF8**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty \{#notEmpty\}

Появилась в версии: v1.1

Проверяет, является ли входной массив непустым.

Массив считается непустым, если он содержит хотя бы один элемент.

:::note
Может быть оптимизирована путем включения настройки [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подстолбец [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всего столбца-массива. Запрос `SELECT notEmpty(arr) FROM table` преобразуется в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функция также работает для значений типов String и UUID.

**Синтаксис**

```sql
notEmpty(arr)
```

**Аргументы**

* `arr` — входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для непустого массива или `0` для пустого массива — значение типа [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```


## range \{#range\}

Введена в версии v1.1

Возвращает массив чисел от `start` до `end - 1` с шагом `step`.

Поддерживаемые типы:

* `UInt8/16/32/64`

* `Int8/16/32/64]`

* Все аргументы `start`, `end`, `step` должны иметь один из указанных выше поддерживаемых типов. Элементы возвращаемого массива будут супертипом аргументов.

* Генерируется исключение, если функция возвращает массив с общей длиной, превышающей число элементов, заданное настройкой [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block).

* Возвращает `NULL`, если какой-либо аргумент имеет тип `Nullable(nothing)`. Генерируется исключение, если какой-либо аргумент имеет значение `NULL` (тип `Nullable(T)`).

**Синтаксис**

```sql
range([start, ] end [, step])
```

**Аргументы**

* `start` — Необязательный параметр. Первый элемент массива. Обязателен, если используется `step`. Значение по умолчанию: `0`. - `end` — Обязательный параметр. Число, до которого (не включительно) формируется массив. - `step` — Необязательный параметр. Определяет шаг между элементами массива. Значение по умолчанию: `1`.

**Возвращаемое значение**

Массив чисел от `start` до `end - 1` с шагом `step`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate \{#replicate\}

Появилась в версии v1.1

Создает массив, содержащий одно значение.

**Синтаксис**

```sql
replicate(x, arr)
```

**Аргументы**

* `x` — значение, которым заполняется результирующий массив. [`Any`](/sql-reference/data-types)
* `arr` — массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив той же длины, что и `arr`, заполненный значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse \{#reverse\}

Появился в версии: v1.1

Изменяет порядок элементов во входном массиве или символов во входной строке на обратный.

**Синтаксис**

```sql
reverse(arr | str)
```

**Аргументы**

* `arr | str` — Исходный массив или строка. [`Array(T)`](/sql-reference/data-types/array) или [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив или строку, в которой элементы или символы расположены в обратном порядке.

**Примеры**

**Массив в обратном порядке**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**Обратная строка**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

{/*AUTOGENERATED_END*/ }


## Функции расстояния \{#distance-functions\}

Все поддерживаемые функции описаны в [документации по функциям расстояния](../../sql-reference/functions/distance-functions.md).
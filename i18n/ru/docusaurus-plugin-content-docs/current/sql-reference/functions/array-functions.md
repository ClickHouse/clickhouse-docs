---
description: 'Документация по функциям массивов'
sidebar_label: 'Массивы'
slug: /sql-reference/functions/array-functions
title: 'Функции массивов'
doc_type: 'reference'
---



# Функции для работы с массивами

{/* 
  Внутреннее содержимое тегов ниже при сборке фреймворка документации
  заменяется документацией, сгенерированной из system.functions. Пожалуйста, не изменяйте и не удаляйте эти теги.
  См.: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }


{/*AUTOGENERATED_START*/ }

## array

Появилась в версии: v1.1

Создаёт массив из аргументов функции.

Аргументы должны быть константами и иметь типы, для которых существует общий супертип.
Должен быть передан как минимум один аргумент, иначе будет непонятно, какой тип массива создавать.
Это означает, что вы не можете использовать эту функцию для создания пустого массива. Для этого используйте функцию `emptyArray*`.

Для получения того же результата используйте оператор `[ ]`.

**Синтаксис**

```sql
array(x1 [, x2, ..., xN])
```

**Аргументы**

* `x1` — константное значение любого типа T. Если указан только этот аргумент, массив будет иметь тип T.
* `[, x2, ..., xN]` — дополнительные N константных значений с общим надтипом с `x1`

**Возвращаемое значение**

Возвращает массив, где &#39;T&#39; — наименьший общий тип среди переданных аргументов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Корректное использование**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**Неверное использование**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Получено исключение от сервера (версия 25.4.3):
Код: 386. DB::Exception: Получено от localhost:9000. DB::Exception:
Отсутствует общий супертип для типов Int32, DateTime, Int8 ...
```


## arrayAUCPR

Добавлена в: v20.4

Вычисляет площадь под кривой «точность–полнота» (precision–recall, PR).
Кривая точность–полнота строится путём отображения точности по оси Y и полноты по оси X для всех порогов.
Полученное значение лежит в диапазоне от 0 до 1, при этом большее значение соответствует более высокой эффективности модели.
PR AUC особенно полезна для несбалансированных наборов данных, обеспечивая более наглядное сравнение качества модели по сравнению с ROC AUC в таких случаях.
Для получения дополнительной информации смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**Псевдонимы**: `arrayPRAUC`

**Аргументы**

* `cores` — Оценки, которые выдаёт модель предсказания. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — Метки объектов, обычно 1 для положительного и 0 для отрицательного примера. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Enum)`](/sql-reference/data-types/array)
* `partial_offsets` —
* Необязательный аргумент. [`Array(T)`](/sql-reference/data-types/array) из трёх неотрицательных целых чисел для вычисления частичной площади под PR-кривой (эквивалент вертикальной полосе в PR-пространстве) вместо полной AUC. Этот параметр полезен для распределённого вычисления PR AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`].
  * `higher_partitions_tp`: Количество положительных меток в партициях с более высокими оценками.
  * `higher_partitions_fp`: Количество отрицательных меток в партициях с более высокими оценками.
  * `total_positives`: Общее количество положительных примеров во всём наборе данных.

:::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны представлять только одну партицию всего набора данных, содержащую некоторый интервал оценок.
Набор данных должен быть разделён на смежные партиции, где каждая партиция содержит подмножество данных, оценки которого попадают в определённый диапазон.
Например:

* Одна партиция может содержать все оценки в диапазоне [0, 0.5).
* Другая партиция может содержать оценки в диапазоне [0.5, 1.0].
  :::

**Возвращаемое значение**

Возвращает площадь под кривой «точность–полнота» (PR). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll

Добавлена в версии: v1.1

Возвращает `1`, если лямбда-выражение `func(x [, y1, y2, ... yN])` возвращает `true` для всех элементов. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — Необязательно. N массивов условий, которые передают дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает true для всех элементов, в противном случае — `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Все элементы соответствуют условию**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**Не все элементы совпадают**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg

Введена в версии v21.1

Возвращает среднее значение элементов исходного массива.

Если указана лямбда-функция `func`, возвращает среднее значение результатов её применения к элементам массива.

**Синтаксис**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает среднее значение элементов исходного массива или среднее значение элементов результатов лямбда-функции, если она указана. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Простой пример**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```


## arrayCompact

Впервые представлена в версии v20.1

Удаляет последовательные дублирующиеся элементы из массива, включая значения `null`. Порядок значений в результирующем массиве определяется порядком в исходном массиве.

**Синтаксис**

```sql
arrayCompact(arr)
```

**Аргументы**

* `arr` — массив, из которого нужно удалить дубликаты. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив без дубликатов значений [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```


## arrayConcat

Введён в версии: v1.1

Объединяет массивы, переданные в качестве аргументов.

**Синтаксис**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**Аргументы**

* `arr1 [, arr2, ... , arrN]` — N массивов для конкатенации. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает один объединённый массив из переданных массивов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```


## arrayCount

Появилась в версии: v1.1

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает true.
Если `func` не задана, возвращает количество ненулевых элементов в массиве.

`arrayCount` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayCount([func, ] arr1, ...)
```

**Аргументы**

* `func` — Необязательный параметр. Функция, применяемая к каждому элементу массива/массивов. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1, ..., arrN` — N массивов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество элементов, для которых `func` возвращает значение `true`. В противном случае возвращает количество ненулевых элементов в массиве. [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```


## arrayCumSum

Введена в версии: v1.1

Возвращает массив частичных (нарастающих) сумм элементов исходного массива. Если указана лямбда-функция, сумма вычисляется как сумма результатов применения лямбды к элементам массива в каждой позиции.

**Синтаксис**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

* `func` — необязательный параметр. Лямбда-функция, применяемая к элементам массива для каждой позиции. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — необязательные параметры. Дополнительные массивы того же размера, передаваемые в лямбда-функцию в качестве аргументов, если она указана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов исходного массива. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**С лямбда-функцией**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```


## arrayCumSumNonNegative

Введена в версии: v18.12

Возвращает массив частичных (накопительных) сумм элементов исходного массива, при этом любая промежуточная отрицательная сумма заменяется на ноль. Если указана лямбда-функция, сумма вычисляется на основе результата применения лямбды к элементам массива в каждой позиции.

**Синтаксис**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**Аргументы**

* `func` — Необязательный параметр. Лямбда-функция, применяемая к элементам массива для каждой позиции. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — Исходный массив числовых значений. [`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — Необязательные. Дополнительные массивы того же размера, передаваемые как аргументы лямбда-функции, если она указана. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив частичных сумм элементов исходного массива, при этом любое отрицательное значение накопленной суммы заменяется на ноль. Тип результата соответствует числовому типу входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**С лямбдой**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```


## arrayDifference

Функция появилась в версии v1.1.

Вычисляет массив разностей между соседними элементами массива.
Первый элемент результирующего массива будет 0, второй — `arr[1] - arr[0]`, третий — `arr[2] - arr[1]` и т. д.
Тип элементов результирующего массива определяется правилами вывода типа для операции вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

```sql
arrayDifference(arr)
```

**Аргументы**

* `arr` — Массив, для которого вычисляют разности между соседними элементами. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив разностей между соседними элементами массива [`UInt*`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**Пример переполнения при типе результата Int64**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct

Введена в версии: v1.1

Возвращает массив, содержащий только уникальные элементы исходного массива.

**Синтаксис**

```sql
arrayDistinct(arr)
```

**Аргументы**

* `arr` — Массив, из которого нужно извлечь различные элементы. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, содержащий различные элементы [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct

Добавлена в версии: v23.5

Возвращает скалярное произведение двух массивов.

:::note
Размеры двух векторов должны быть равны. Массивы и кортежи (Tuples) также могут содержать элементы разных типов.
:::

**Синтаксис**

```sql
arrayDotProduct(v1, v2)
```

**Аргументы**

* `v1` — первый вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
* `v2` — второй вектор. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) или [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**Возвращаемое значение**

Скалярное произведение двух векторов.

:::note
Тип возвращаемого значения определяется типом аргументов. Если `Array` или `Tuple` содержат элементы разных типов, тип результата — их супертип.
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) или [`Float*`](/sql-reference/data-types/float) или [`Decimal`](/sql-reference/data-types/decimal)

**Примеры**

**Пример для Array**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**Пример tuple**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement

Впервые появился в версии: v1.1

Возвращает элемент переданного массива с индексом `n`, где `n` может быть целым числом любого типа.
Если индекс выходит за границы массива, возвращается значение по умолчанию (0 для чисел, пустая строка для строк и т. д.),
за исключением случаев, когда аргументом является неконстантный массив, а индекс — константа 0. В этом случае будет выдана ошибка `Array indices are 1-based`.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, нумерация которого ведётся с конца. Например, `arr[-1]` — это последний элемент массива.

Оператор `[n]` обладает той же функциональностью.

**Синтаксис**

```sql
arrayElement(arr, n)
```

**Аргументы**

* `arr` — массив для поиска. [`Array(T)`](/sql-reference/data-types/array). - `n` — позиция извлекаемого элемента. [`(U)Int*`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Возвращает один объединённый массив из переданных аргументов-массивов [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Отрицательные индексы**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**Использование обозначения [n]**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Выход индекса за границы массива**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```


## arrayElementOrNull

Впервые появилась в версии v1.1

Возвращает элемент указанного массива с индексом `n`, где `n` может быть значением любого целочисленного типа.
Если индекс выходит за границы массива, вместо значения по умолчанию возвращается `NULL`.

:::note
Массивы в ClickHouse индексируются с единицы.
:::

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, отсчитываемый с конца массива. Например, `arr[-1]` — это последний элемент массива.

**Синтаксис**

```sql
arrayElementOrNull(arrays)
```

**Аргументы**

* `arrays` — Произвольное количество аргументов-массивов. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает один объединённый массив из переданных массивов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**Отрицательные индексы**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**Индекс выходит за пределы массива**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```


## arrayEnumerate

Введена в версии: v1.1

Возвращает массив `[1, 2, 3, ..., length(arr)]`

Эта функция обычно используется вместе с предложением [`ARRAY JOIN`](/sql-reference/statements/select/array-join). Она позволяет посчитать что-либо только
один раз для каждого массива после применения `ARRAY JOIN`.
Эту функцию также можно использовать во функциях высшего порядка. Например, вы можете использовать её, чтобы получить индексы элементов массива, которые удовлетворяют условию.

**Синтаксис**

```sql
arrayEnumerate(arr)
```

**Аргументы**

* `arr` — массив, который требуется пронумеровать. [`Array`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив `[1, 2, 3, ..., length(arr)]`. [`Array(UInt32)`](/sql-reference/data-types/array)

**Примеры**

**Простейший пример с ARRAY JOIN**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense

Появилась в версии: v18.12

Возвращает массив того же размера, что и исходный, показывающий позицию первого вхождения каждого элемента в исходный массив.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Аргументы**

* `arr` — массив для перебора. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же размера, что и `arr`, в котором указано, где каждый элемент впервые встречается в исходном массиве. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked

Добавлено в версии: v20.1

Возвращает массив того же размера, что и исходный, элементы которого указывают, в каком месте каждый элемент впервые встречается в исходном массиве. Позволяет выполнять нумерацию многомерного массива с возможностью указать глубину обхода массива.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

* `clear_depth` — перечислять элементы на указанном уровне отдельно. Должен быть меньше или равен `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — N-мерный массив для перечисления. [`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — максимальная эффективная глубина. Должна быть меньше или равна глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив, который указывает, где каждый элемент впервые появляется в исходном массиве. [`Array`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
-- При clear_depth=1 и max_array_depth=1 результат идентичен результату функции arrayEnumerateDense.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**Использование с многомерным массивом**

```sql title=Query
-- В этом примере arrayEnumerateDenseRanked используется для получения массива, который показывает для каждого элемента
-- многомерного массива его порядковый номер среди элементов с одинаковым значением.
-- Для первой строки переданного массива [10, 10, 30, 20] соответствующая первая строка результата — [1, 1, 2, 3],
-- что означает: 10 — это первое встреченное число в позициях 1 и 2, 30 — второе встреченное число в позиции 3,
-- а 20 — третье встреченное число в позиции 4.
-- Для второй строки [40, 50, 10, 30] соответствующая вторая строка результата — [4,5,1,2], что означает: 40
-- и 50 — это четвёртое и пятое встреченные числа в позициях 1 и 2 этой строки, ещё одно 10
-- (первое встреченное число) находится в позиции 3, а 30 (второе встреченное число) — в последней позиции.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**Пример с повышенным значением clear&#95;depth**

```sql title=Query
-- Изменение clear_depth=2 приводит к тому, что перечисление выполняется отдельно для каждой строки заново.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq

Появилась в версии: v1.1

Возвращает массив того же размера, что и исходный массив, указывая для каждого элемента его порядковый номер среди элементов с тем же значением.

Эта функция полезна при использовании `ARRAY JOIN` и агрегации элементов массива.

Функция может принимать в качестве аргументов несколько массивов одинакового размера. В этом случае уникальность определяется для кортежей элементов, находящихся на одинаковых позициях во всех массивах.

**Синтаксис**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**Аргументы**

* `arr1` — Первый массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `arr2, ...` — Необязательный параметр. Дополнительные массивы того же размера для обеспечения уникальности кортежей. [`Array(UInt32)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, в котором каждый элемент — это позиция среди элементов с тем же значением или кортежем. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**Несколько массивов**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**Агрегация с ARRAY JOIN**

```sql title=Query
-- Для каждого идентификатора цели вычисляется количество конверсий (каждый элемент во вложенной структуре данных Goals представляет собой достигнутую цель, которую мы называем конверсией)
-- и количество сессий. Без ARRAY JOIN количество сессий подсчитывалось бы как sum(Sign). Однако в данном случае
-- строки умножаются на вложенную структуру Goals, поэтому для подсчёта каждой сессии только один раз применяется условие на
-- значение функции arrayEnumerateUniq(Goals.ID).

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked

Впервые появилась в версии: v20.1

Возвращает массив (или многомерный массив) с теми же размерами, что и исходный массив,
указывая для каждого элемента, какую позицию он занимает среди элементов с тем же значением.
Позволяет выполнять перечисление многомерного массива с возможностью задать глубину просмотра массива.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Аргументы**

* `clear_depth` — Перечислять элементы на указанном уровне по отдельности. Положительное целое число, меньшее или равное `max_arr_depth`. [`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — N-мерный массив для перечисления. [`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — Максимальная эффективная глубина. Положительное целое число, меньшее или равное глубине `arr`. [`UInt*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает N-мерный массив того же размера, что и `arr`, в котором каждый элемент показывает позицию этого элемента среди других элементов с тем же значением. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
-- При clear_depth=1 и max_array_depth=1 результат arrayEnumerateUniqRanked
-- идентичен результату, который вернула бы функция arrayEnumerateUniq для того же массива.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**Пример 2**

```sql title=Query
-- при clear_depth=1 и max_array_depth=1 результат arrayEnumerateUniqRanked
-- идентичен результату, который вернула бы функция arrayEnumerateUniq для того же массива.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**Пример 3**

```sql title=Query
-- В этом примере arrayEnumerateUniqRanked используется для получения массива, который показывает
-- для каждого элемента многомерного массива его порядковый номер среди элементов
-- с таким же значением. Для первой строки переданного массива [1, 2, 3] соответствующий
-- результат — [1, 1, 1], что означает, что значения 1, 2 и 3 встречаются впервые.
-- Для второй строки переданного массива [2, 2, 1] соответствующий результат — [2, 3, 3],
-- что означает, что значение 2 встречается во второй и третий раз, а значение 1 — 
-- во второй раз. Аналогично, для третьей строки переданного массива [3]
-- соответствующий результат — [2], что означает, что значение 3 встречается во второй раз.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**Пример 4**

```sql title=Query
-- Изменение clear_depth=2 приводит к раздельной нумерации элементов для каждой строки.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept

Введена в версии v25.9

Возвращает массив, содержащий элементы из `source`, которые отсутствуют в `except`, при этом сохраняется исходный порядок.

Эта функция выполняет операцию разности множеств между двумя массивами. Для каждого элемента в `source` она проверяет, существует ли этот элемент в `except` (с использованием точного сравнения). Если нет, элемент включается в результат.

Операция обладает следующими свойствами:

1. Порядок элементов из `source` сохраняется
2. Дубликаты в `source` сохраняются, если их нет в `except`
3. NULL обрабатывается как отдельное значение

**Синтаксис**

```sql
arrayExcept(source, except)
```

**Аргументы**

* `source` — исходный массив с элементами, подлежащими фильтрации.  [`Array(T)`](/sql-reference/data-types/array)
* `except` — массив, содержащий элементы, которые нужно исключить из результата.  [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же типа, что и входной массив, содержащий элементы из `source`, отсутствующие в `except`.  [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with&#95;nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with&#95;nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**строки**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['яблоко', 'вишня']
```


## arrayExists

Введена в версии: v1.1

Возвращает `1`, если в исходном массиве есть хотя бы один элемент, для которого `func(x[, y1, y2, ... yN])` возвращает `true`. В противном случае возвращает `0`.

**Синтаксис**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, передающих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если лямбда-функция возвращает значение `true` хотя бы для одного элемента, и `0` в противном случае. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```


## arrayFill

Добавлена в: v20.1

Функция `arrayFill` последовательно обрабатывает исходный массив от первого
элемента до последнего, вычисляя лямбда‑условие на каждой позиции с использованием
элементов из исходного массива и массива условий. Когда лямбда‑функция
возвращает false на позиции i, функция заменяет этот элемент элементом на позиции
i-1 из текущего состояния массива. Первый элемент всегда сохраняется
независимо от каких‑либо условий.

**Синтаксис**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x [, y1, ..., yN])` — лямбда-функция `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`, которая применяется к элементам исходного массива (`x`) и массивов-условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — Необязательные. N массивов-условий, которые передаются как дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**Пример с двумя массивами**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```


## arrayFilter

Появился в версии: v1.1

Возвращает массив, содержащий только те элементы исходного массива, для которых лямбда‑функция возвращает `true`.

**Синтаксис**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает подмассив исходного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**Пример 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```


## arrayFirst

Впервые появилось в версии v1.1

Возвращает первый элемент исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает true, иначе возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая работает с элементами исходного массива (`x`) и массивов условий (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, передающих дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `λ` истинно, в противном случае возвращает значение по умолчанию типа `T`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayFirstIndex

Появилась в версии: v1.1

Возвращает индекс первого элемента исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает `true`, в противном случае возвращает `0`.

**Синтаксис**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — lambda‑функция, которая работает с элементами исходного массива (`x`) и массивов условий (`y`). [Лямбда‑функция](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — необязательные N массивов условий, передающих дополнительные аргументы в lambda‑функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает индекс первого элемента исходного массива, для которого `func` возвращает `true`, в противном случае возвращает `0` [`UInt32`](/sql-reference/data-types/int-uint).

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```


## arrayFirstOrNull

Введена в версии: v1.1

Возвращает первый элемент исходного массива, для которого `func(x[, y1, y2, ... yN])` возвращает `true`, в противном случае — `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов-условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов-условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает первый элемент исходного массива, для которого `func` возвращает истину, иначе возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayFlatten

Введена в версии: v20.1

Преобразует массив массивов в плоский массив.

Функция:

* Применяется к массивам любой глубины вложенности.
* Не изменяет массивы, которые уже являются плоскими.

Плоский массив содержит все элементы из всех исходных массивов.

**Синтаксис**

```sql
arrayFlatten(arr)
```

**Псевдонимы**: `flatten`

**Аргументы**

* `arr` — многомерный массив. [`Array(Array(T))`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает плоский массив, полученный из многомерного массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```


## arrayFold

Появилась в версии: v23.10

Применяет лямбда-функцию к одному или нескольким массивам одинаковой длины и накапливает результат в аккумуляторе.

**Синтаксис**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**Аргументы**

* `λ(x, x1 [, x2, x3, ... xN])` — лямбда-функция `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`, где `F` — операция, применяемая к `acc` и значениям массива `x` с последующим переиспользованием результата `acc`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1 [, arr2, arr3, ... arrN]` — N массивов, над которыми выполняется операция. [`Array(T)`](/sql-reference/data-types/array)
* `acc` — аккумулятор, значение того же типа, что и тип возвращаемого значения лямбда-функции.

**Возвращаемое значение**

Возвращает конечное значение `acc`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**Числа Фибоначчи**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**Пример с несколькими массивами**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```


## arrayIntersect

Появилась в версии: v1.1

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**Аргументы**

* `arrN` — N массивов, из которых создаётся новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив, содержащий уникальные элементы, присутствующие во всех N массивах. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex

Впервые появилась в версии v23.7

Возвращает [индекс Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) двух массивов.

**Синтаксис**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**Аргументы**

* `arr_x` — первый массив. [`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — второй массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс Жаккара для массивов `arr_x` и `arr_y` [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin

Впервые представлено в: v1.1

Функция `arrayJoin` принимает строку, содержащую массив, и разворачивает этот массив, создавая несколько строк — по одной для каждого элемента массива.
В отличие от обычных функций в ClickHouse, которые преобразуют входные значения в выходные в пределах одной строки,
агрегатные функции принимают группу строк и «сжимают» или «сводят» их в одну сводную строку
(или в одно значение в сводной строке, если используются с `GROUP BY`).

Все значения в столбцах просто копируются, за исключением значений в столбце, к которому применяется эта функция;
они заменяются соответствующим значением из массива.

**Синтаксис**

```sql
arrayJoin(arr)
```

**Аргументы**

* `arr` — Массив для разворачивания. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает набор строк, полученных из `arr`.

**Примеры**

**Базовое использование**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin влияет на все части запроса**

```sql title=Query
-- Функция arrayJoin влияет на все секции запроса, включая секцию WHERE. Обратите внимание на результат 2, хотя подзапрос вернул 1 строку.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**Использование нескольких функций arrayJoin**

```sql title=Query
- Запрос может использовать несколько функций arrayJoin. В этом случае преобразование выполняется многократно, и количество строк увеличивается соответственно.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**Неожиданные результаты из-за оптимизаций**

```sql title=Query
-- Использование нескольких arrayJoin с одинаковым выражением может не дать ожидаемого результата из-за оптимизаций.
-- В таких случаях рекомендуется модифицировать повторяющееся выражение массива дополнительными операциями, не влияющими на результат объединения.
- например: arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- технически корректно, но приведёт к уничтожению набора результатов
    arrayJoin(arrayConcat(dice, [])) as second_throw -- выражение намеренно изменено для принудительного повторного вычисления
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─первый_бросок─┬─второй_бросок─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└───────────────┴───────────────┘
```

**Использование синтаксиса ARRAY JOIN**

```sql title=Query
-- Обратите внимание на синтаксис ARRAY JOIN в запросе `SELECT` ниже — он предоставляет более широкие возможности.
-- ARRAY JOIN позволяет одновременно преобразовывать несколько массивов с одинаковым количеством элементов.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Использование типа Tuple**

```sql title=Query
-- Также можно использовать кортеж (Tuple)

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast

Добавлена в версии: v1.1

Возвращает последний элемент исходного массива, для которого лямбда-функция `func(x [, y1, y2, ... yN])` возвращает `true`, в противном случае возвращает значение по умолчанию.

**Синтаксис**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, применяемая к элементам исходного массива (`x`) и массивам условий (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1, ... , condN]` — необязательный параметр. N массивов условий, передающих дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого `func` возвращает `true`, иначе возвращает значение по умолчанию типа `T`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayLastIndex

Добавлена в версии: v1.1

Возвращает индекс последнего элемента в исходном массиве, для которого `func(x[, y1, y2, ... yN])` возвращает true, в противном случае возвращает &#39;0&#39;.

**Синтаксис**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, применяемая к элементам исходного массива (`x`) и массивов-условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов-условий, передающих дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает индекс последнего элемента исходного массива, для которого `func` возвращает `true`, в противном случае возвращает `0` [`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull

Добавлена в версии v1.1

Возвращает последний элемент исходного массива, для которого лямбда `func(x [, y1, y2, ... yN])` возвращает true, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x [, y1, ..., yN])` — лямбда-функция, которая обрабатывает элементы исходного массива (`x`) и массивов условий (`y`). [Лямбда‑функция](/sql-reference/functions/overview#arrow-operator-and-lambda).

- `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — необязательно. N массивов условий, предоставляющих дополнительные аргументы лямбда‑функции. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает последний элемент исходного массива, для которого значение `λ` ложно, иначе возвращает `NULL`.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**Совпадений не найдено**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance

Добавлена в версии: v25.4

Вычисляет расстояние Левенштейна между двумя массивами.

**Синтаксис**

```sql
arrayLevenshteinDistance(from, to)
```

**Аргументы**

* `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array). - `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```


## arrayLevenshteinDistanceWeighted

Введена в версии: v25.4

Вычисляет расстояние Левенштейна для двух массивов с настраиваемыми весами для каждого элемента.
Число элементов в массиве и число весов должно совпадать.

**Синтаксис**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**Аргументы**

* `from` — первый массив. [`Array(T)`](/sql-reference/data-types/array). - `to` — второй массив. [`Array(T)`](/sql-reference/data-types/array). - `from_weights` — веса элементов первого массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — веса элементов второго массива. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Расстояние Левенштейна между первым и вторым массивами с пользовательскими весами для каждого элемента типа [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```


## arrayMap

Введена в версии: v1.1

Возвращает массив, полученный из исходных массивов путём применения лямбда-функции к каждому элементу.

**Синтаксис**

```sql
arrayMap(func, arr)
```

**Аргументы**

* `func` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — N массивов для обработки. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив из результатов выполнения лямбда-функции [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**Создание кортежа из элементов разных массивов**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax

Добавлена в: v21.1

Возвращает максимальный элемент исходного массива.

Если указана лямбда-функция `func`, возвращает максимальный элемент среди результатов её применения.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, передающих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает максимальный элемент исходного массива или максимальный элемент среди результатов лямбда-функции, если она задана.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin

Впервые появилась в версии: v21.1

Возвращает минимальный элемент исходного массива.

Если указана лямбда-функция `func`, возвращает минимальный элемент среди результатов этой функции.

**Синтаксис**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — Необязательные параметры. N массивов условий, предоставляющих дополнительные аргументы для лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает минимальный элемент исходного массива или минимальный элемент среди результатов лямбда-функции, если она задана.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**Использование с лямбда-функцией**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```


## arrayNormalizedGini

Введена в версии: v25.1

Вычисляет нормированный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

* `predicted` — Предсказанное значение. [`Array(T)`](/sql-reference/data-types/array)
* `label` — Фактическое значение. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Кортеж, содержащий коэффициент Джини для предсказанных значений, коэффициент Джини для нормализованных значений и нормализованный коэффициент Джини (= отношение первых двух указанных коэффициентов Джини) [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort

Появилась в версии: v23.2

Эта функция аналогична `arrayReverseSort`, но с дополнительным аргументом `limit`, который позволяет выполнять частичную сортировку.

:::tip
Чтобы сохранить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

* `f(arr[, arr1, ... ,arrN])` — lambda-функция, применяемая к элементам массива `arr`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — Массив, который необходимо отсортировать. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — N дополнительных массивов в случае, если `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array)
* `limit` — Значение индекса, до которого будет выполняться сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, в котором элементы в диапазоне `[1..limit]` отсортированы
по убыванию. Оставшиеся элементы `(limit..N]` находятся в произвольном порядке.

**Примеры**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```


## arrayPartialShuffle

Введено в версии: v23.2

Возвращает массив того же размера, что и исходный, в котором элементы в диапазоне `[1..limit]` представляют собой случайное
подмножество исходного массива. Оставшиеся элементы `(limit..n]` должны содержать элементы, не вошедшие в диапазон `[1..limit]`, в неопределённом порядке.
Значение `limit` должно быть в диапазоне `[1..n]`. Значения вне этого диапазона эквивалентны выполнению полного `arrayShuffle`:

:::note
Эта функция не материализует константы.

Значение `limit` должно быть в диапазоне `[1..N]`. Значения вне этого диапазона эквивалентны выполнению полного [`arrayShuffle`](#arrayShuffle).
:::

**Синтаксис**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**Аргументы**

* `arr` — Массив, который нужно случайным образом перемешать. [`Array(T)`](/sql-reference/data-types/array)
* `seed` — Необязательный параметр. Инициализирующее значение (seed) для генератора случайных чисел. Если не задан, используется случайное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `limit` — Необязательный параметр. Число, ограничивающее количество перестановок элементов, в диапазоне `[1..N]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с частично перемешанными элементами. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**no&#95;limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no&#95;limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort

Добавлена в версии: v23.2

Эта функция аналогична `arraySort`, но с дополнительным аргументом `limit`, который позволяет выполнять частичную сортировку.

:::tip
Чтобы оставить только отсортированные элементы, используйте `arrayResize`.
:::

**Синтаксис**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Аргументы**

* `f(arr[, arr1, ... ,arrN])` — Лямбда-функция, применяемая к элементам массива `x`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — Массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — N дополнительных массивов, если `f` принимает несколько аргументов. [`Array(T)`](/sql-reference/data-types/array)
* `limit` — Значение индекса, до которого (включительно) будет выполняться сортировка. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, в котором элементы в диапазоне `[1..limit]` отсортированы
по возрастанию. Оставшиеся элементы `(limit..N]` находятся в неопределённом порядке.

**Примеры**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```


## arrayPopBack

Добавлена в версии: v1.1

Удаляет последний элемент из массива.

**Синтаксис**

```sql
arrayPopBack(arr)
```

**Аргументы**

* `arr` — массив, у которого нужно удалить последний элемент. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но без его последнего элемента. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```


## arrayPopFront

Впервые появилась в версии: v1.1

Удаляет первый элемент из массива.

**Синтаксис**

```sql
arrayPopFront(arr)
```

**Аргументы**

* `arr` — массив, из которого нужно удалить первый элемент. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив [`Array(T)`](/sql-reference/data-types/array), идентичный `arr`, но без его первого элемента.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```


## arrayProduct

Введена в версии: v21.1

Возвращает произведение элементов исходного массива.

Если указана лямбда-функция `func`, возвращает произведение элементов результатов выполнения этой лямбда-функции.

**Синтаксис**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда‑функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда‑функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает произведение элементов исходного массива или произведение элементов, возвращённых лямбда‑функцией, если она указана. [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Простой пример**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**Использование с функцией Lambda**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack

Добавлена в версии: v1.1

Добавляет один элемент в конец массива.

**Синтаксис**

```sql
arrayPushBack(arr, x)
```

**Аргументы**

* `arr` — массив, в конец которого нужно добавить значение `x`. [`Array(T)`](/sql-reference/data-types/array)
* `x` —
* Отдельное значение, которое нужно добавить в конец массива. [`Array(T)`](/sql-reference/data-types/array).

:::note

* В массив с числами можно добавлять только числа, а в массив со строками — только строки.
* При добавлении чисел ClickHouse автоматически приводит тип `x` к типу данных массива.
* Может быть `NULL`. Функция добавляет элемент `NULL` в массив, а тип элементов массива преобразуется в `Nullable`.

Для получения дополнительной информации о типах данных в ClickHouse см. раздел [Data types](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с добавленным в конец массива значением `x` [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```


## arrayPushFront

Впервые появилась в версии: v1.1

Добавляет один элемент в начало массива.

**Синтаксис**

```sql
arrayPushFront(arr, x)
```

**Аргументы**

* `arr` — Массив, к концу которого нужно добавить значение `x`. [`Array(T)`](/sql-reference/data-types/array). - `x` —
* Одно значение, которое нужно добавить в начало массива. [`Array(T)`](/sql-reference/data-types/array).

:::note

* В массив с числами можно добавлять только числа, а в массив строк — только строки.
* При добавлении чисел ClickHouse автоматически приводит тип `x` к типу данных массива.
* Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

Дополнительную информацию о типах данных в ClickHouse см. в разделе [Типы данных](/sql-reference/data-types).
:::

**Возвращаемое значение**

Возвращает массив, идентичный `arr`, но с дополнительным значением `x` в начале массива [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```


## arrayROCAUC

Появилась в версии: v20.4

Вычисляет площадь под ROC-кривой (Receiver Operating Characteristic).
ROC-кривая строится путем отображения True Positive Rate (TPR) по оси y и False Positive Rate (FPR) по оси x для всех порогов.
Получаемое значение лежит в диапазоне от нуля до единицы, при этом большее значение указывает на лучшую производительность модели.

ROC AUC (также просто AUC) — это понятие в машинном обучении.
Подробнее см. [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**Псевдонимы**: `arrayAUC`

**Аргументы**

* `scores` — оценки (скоры), которые возвращает модель предсказания. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — метки объектов, обычно 1 для положительного примера и 0 для отрицательного. [`Array((U)Int*)`](/sql-reference/data-types/array) или [`Enum`](/sql-reference/data-types/enum)
* `scale` — необязательный параметр. Определяет, нужно ли возвращать нормированную площадь. Если false, вместо этого возвращает площадь под кривой TP (true positives, истинно положительные) × FP (false positives, ложно положительные). Значение по умолчанию: true. [`Bool`](/sql-reference/data-types/boolean)
* `partial_offsets` —
* Массив из четырёх неотрицательных целых чисел для вычисления частичной площади под ROC-кривой (что эквивалентно вертикальной полосе в ROC-пространстве) вместо полного AUC. Эта опция полезна для распределённого вычисления ROC AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) из неотрицательных [Integers](../data-types/int-uint.md). Необязательный параметр.
  * `higher_partitions_tp`: количество положительных меток в разбиениях с более высокими значениями оценок.
  * `higher_partitions_fp`: количество отрицательных меток в разбиениях с более высокими значениями оценок.
  * `total_positives`: общее количество положительных примеров во всём наборе данных.
  * `total_negatives`: общее количество отрицательных примеров во всём наборе данных.

:::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны содержать только часть всего набора данных, соответствующую некоторому интервалу значений оценок.
Набор данных должен быть разделён на смежные разбиения, где каждое разбиение содержит подмножество данных с оценками, попадающими в определённый диапазон.
Например:

* Одно разбиение может содержать все оценки в диапазоне [0, 0.5).
* Другое разбиение может содержать оценки в диапазоне [0.5, 1.0].
  :::

**Возвращаемое значение**

Возвращает площадь под ROC-кривой (receiver operating characteristic). [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```


## arrayRandomSample

Появилась в: v23.10

Возвращает подмножество из `samples` случайных элементов входного массива. Если значение `samples` превышает размер входного массива, размер выборки ограничивается размером массива, то есть возвращаются все элементы массива, но их порядок не гарантируется. Функция может работать как с плоскими, так и с вложенными массивами.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

* `arr` — Входной массив или многомерный массив, из которого выбираются элементы. [`Array(T)`](/sql-reference/data-types/array)
* `samples` — Количество элементов в случайной выборке. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив, содержащий случайную выборку элементов из входного массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**Использование многомерных массивов**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```


## arrayReduce

Введена в версии: v1.1

Применяет агрегатную функцию к элементам массива и возвращает её результат.
Имя агрегатной функции передаётся в виде строки в одинарных кавычках: `'max'`, `'sum'`.
При использовании параметрических агрегатных функций параметр указывается после имени функции в круглых скобках: `'uniqUpTo(6)'`.

**Синтаксис**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**Аргументы**

* `agg_f` — имя агрегатной функции, которое должно быть константой. [`String`](/sql-reference/data-types/string)
* `arr1 [, arr2, ... , arrN)]` — N массивов, соответствующих аргументам функции `agg_f`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает результат агрегатной функции.

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**Пример агрегатной функции с несколькими аргументами**

```sql title=Query
--Если агрегатная функция принимает несколько аргументов, то она должна применяться к нескольким массивам одинакового размера.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**Пример с параметрической агрегатной функцией**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges

Появилась в версии: v20.4

Применяет агрегатную функцию к элементам массива в заданных диапазонах и возвращает массив с результатом для каждого диапазона.
Функция возвращает тот же результат, что и несколько вызовов `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**Аргументы**

* `agg_f` — имя агрегатной функции, которую следует использовать. [`String`](/sql-reference/data-types/string)
* `ranges` — диапазоны, по которым выполняется агрегация. Массив кортежей `(i, r)`, содержащих индекс `i`, с которого нужно начать, и диапазон `r`, по которому выполняется агрегация. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T)`](/sql-reference/data-types/tuple)
* `arr1 [, arr2, ... ,arrN)]` — N массивов в качестве аргументов агрегатной функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с результатами работы агрегатной функции по заданным диапазонам — [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove

Добавлено в версии v25.11

Удаляет из массива все элементы, равные заданному значению.
Значения NULL считаются равными.

**Синтаксис**

```sql
arrayRemove(arr, elem)
```

**Псевдонимы**: `array_remove`

**Аргументы**

* `arr` — Array(T) - `elem` — T

**Возвращаемое значение**

Возвращает подмножество исходного массива типа [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**Пример 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```


## arrayResize

Появилась в версии: v1.1

Изменяет длину массива.

**Синтаксис**

```sql
arrayResize(arr, size[, extender])
```

**Аргументы**

* `arr` — Массив, размер которого нужно изменить. [`Array(T)`](/sql-reference/data-types/array)
* `size` —
  * Новая длина массива.
    Если `size` меньше исходного размера массива, массив усекается справа.
    Если `size` больше исходного размера массива, массив расширяется справа значениями `extender` или значениями по умолчанию для типа данных элементов массива.
* `extender` — Значение, используемое для расширения массива. Может быть `NULL`.

**Возвращаемое значение**

Массив длины `size`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**Пример 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```


## arrayReverse

Добавлена в версии: v1.1

Меняет порядок элементов в заданном массиве на обратный.

:::note
Функция `reverse(arr)` выполняет ту же функцию, но работает и с другими типами данных,
а не только с массивами.
:::

**Синтаксис**

```sql
arrayReverse(arr)
```

**Аргументы**

* `arr` — Массив, который нужно развернуть. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив того же размера, что и исходный массив, с элементами в обратном порядке [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill

Впервые введена в версии: v20.1

Функция `arrayReverseFill` последовательно обрабатывает исходный массив от
последнего элемента к первому, вычисляя лямбда-условие в каждой позиции с
использованием элементов из исходного массива и массива условий. Когда условие
оказывается ложным на позиции i, функция заменяет этот элемент элементом на
позиции i+1 из текущего состояния массива. Последний элемент всегда сохраняется,
независимо от условия.

**Синтаксис**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, передающих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, в котором элементы исходного массива заменены результатами применения лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример с одним массивом**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**Пример с двумя массивами**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```


## arrayReverseSort

Введена в версии v1.1

Сортирует элементы массива в порядке убывания.
Если указана функция `f`, переданный массив сортируется в соответствии с результатом
функции, применённой к элементам массива, после чего отсортированный массив переворачивается.
Если `f` принимает несколько аргументов, в функцию `arrayReverseSort` передаются несколько массивов,
которые будут соответствовать аргументам `f`.

Если сортируемый массив содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**Аргументы**

* `f(y1[, y2 ... yN])` — лямбда-функция, которая применяется к элементам массива `x`.
* `arr` — массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ..., yN` — необязательные N дополнительных массивов, используемых, если `f` принимает несколько аргументов.

**Возвращаемое значение**

Возвращает массив `x`, отсортированный по убыванию, если лямбда-функция не задана; в противном случае
возвращает массив, отсортированный в соответствии с логикой переданной лямбда-функции, после чего порядок элементов в нём инвертируется. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**Пример 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```


## arrayReverseSplit

Появилась в версии: v20.1

Разбивает исходный массив на несколько массивов. Когда `func(x[, y1, ..., yN])` возвращает ненулевое значение, массив будет разделён сразу после этого элемента. После последнего элемента массив не разделяется.

**Синтаксис**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивам условий (`y`). [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — исходный массив для обработки. [`Лямбда-функция`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, передающих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив массивов. [`Array(Array(T))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft

Введена в версии: v23.8

Выполняет циклический сдвиг элементов массива влево на заданное количество позиций. Отрицательные значения `n` рассматриваются как сдвиг вправо на абсолютное значение параметра.

**Синтаксис**

```sql
arrayRotateLeft(arr, n)
```

**Аргументы**

* `arr` — массив, элементы которого нужно циклически сдвинуть. [`Array(T)`](/sql-reference/data-types/array).
* `n` — количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**Возвращаемое значение**

Массив, циклически сдвинутый влево на указанное число элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```


## arrayRotateRight

Введена в версии v23.8

Выполняет циклический сдвиг массива вправо на указанное количество элементов. Отрицательные значения `n` интерпретируются как циклический сдвиг влево на абсолютное значение величины сдвига.

**Синтаксис**

```sql
arrayRotateRight(arr, n)
```

**Аргументы**

* `arr` — массив, для которого выполняется циклический сдвиг элементов. [`Array(T)`](/sql-reference/data-types/array)
* `n` — количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив, циклически сдвинутый вправо на указанное количество элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```


## arrayShiftLeft

Появилась в версии: v23.8

Сдвигает массив влево на заданное количество элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элемента массива.
Если указанное количество элементов отрицательное, массив сдвигается вправо.

**Синтаксис**

```sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

* `arr` — массив, элементы которого необходимо сдвинуть. [`Array(T)`](/sql-reference/data-types/array). - `n` — количество элементов для сдвига. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). - `default` — необязательный параметр. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

Массив, сдвинутый влево на указанное количество элементов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**Использование значения по умолчанию**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```


## arrayShiftRight

Появилась в версии v23.8

Сдвигает массив вправо на указанное количество элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элементов массива.
Если количество элементов отрицательно, массив сдвигается влево.

**Синтаксис**

```sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

* `arr` — Массив, элементы которого сдвигаются. [`Array(T)`](/sql-reference/data-types/array)
* `n` — Число элементов, на которое выполняется сдвиг. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `default` — Необязательный параметр. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

Массив, сдвинутый вправо на указанное число элементов. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**Отрицательное значение n**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**Использование значения по умолчанию**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```


## arrayShingles

Добавлена в версии v24.1

Генерирует массив шинглов (аналогов n-грамм для строк), то есть последовательных подмассивов входного массива заданной длины.

**Синтаксис**

```sql
arrayShingles(arr, l)
```

**Аргументы**

* `arr` — Массив, для которого генерируется массив шинглов. [`Array(T)`](/sql-reference/data-types/array)
* `l` — Длина каждого шингла. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив сгенерированных шинглов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle

Добавлена в версии: v23.2

Возвращает массив того же размера, что и исходный массив, содержащий элементы в перемешанном порядке.
Элементы переставляются таким образом, что каждая возможная перестановка этих элементов имеет равную вероятность появления.

:::note
Эта функция не материализует константы.
:::

**Синтаксис**

```sql
arrayShuffle(arr [, seed])
```

**Аргументы**

* `arr` — Массив для перемешивания. [`Array(T)`](/sql-reference/data-types/array)
* `seed (optional)` — Необязательный параметр. Начальное значение (seed), используемое для генерации случайных чисел. Если не указано, используется случайное значение. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Массив с перемешанными элементами. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример без seed (недетерминированные результаты)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**Пример без заданного seed (стабильные результаты)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```


## arraySimilarity

Появилась в версии: v25.4

Вычисляет меру сходства двух массивов от `0` до `1` на основе взвешенного расстояния Левенштейна.

**Синтаксис**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**Аргументы**

* `from` — первый массив [`Array(T)`](/sql-reference/data-types/array)
* `to` — второй массив [`Array(T)`](/sql-reference/data-types/array)
* `from_weights` — веса для первого массива [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — веса для второго массива [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает меру сходства в диапазоне от `0` до `1` для двух массивов на основе взвешенного расстояния Левенштейна [`Float64`](/sql-reference/data-types/float)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```


## arraySlice

Введена в версии: v1.1

Возвращает срез массива, включая элементы `NULL`.

**Синтаксис**

```sql
arraySlice(arr, offset [, length])
```

**Аргументы**

* `arr` — Массив, из которого берётся срез. [`Array(T)`](/sql-reference/data-types/array)
* `offset` — Смещение относительно края массива. Положительное значение задаёт смещение слева, отрицательное — смещение справа. Нумерация элементов массива начинается с `1`. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — Длина требуемого среза. Если указать отрицательное значение, функция вернёт открытый срез `[offset, array_length - length]`. Если параметр не указан, функция вернёт срез `[offset, the_end_of_array]`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает срез массива из `length` элементов, начиная с указанного `offset` [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```


## arraySort

Введена в версии: v1.1

Сортирует элементы переданного массива по возрастанию.
Если указана лямбда-функция `f`, порядок сортировки определяется результатом
применения лямбды к каждому элементу массива.
Если лямбда принимает несколько аргументов, функции `arraySort` передаётся несколько
массивов, элементам которых будут соответствовать аргументы `f`.

Если сортируемый массив содержит `-Inf`, `NULL`, `NaN` или `Inf`, они будут отсортированы в следующем порядке:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` — это [функция высшего порядка](/sql-reference/functions/overview#higher-order-functions).

**Синтаксис**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**Аргументы**

* `f(y1[, y2 ... yN])` — лямбда-функция, применяемая к элементам массива `x`.
* `arr` — массив, который нужно отсортировать. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ..., yN` — необязательные аргументы. N дополнительных массивов, если `f` принимает несколько аргументов.

**Возвращаемое значение**

Возвращает массив `arr`, отсортированный по возрастанию, если лямбда-функция не задана, в противном случае
возвращает массив, отсортированный в соответствии с логикой, реализованной в переданной лямбда-функции. [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**Пример 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**Пример 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit

Добавлена в версии: v20.1

Разбивает исходный массив на несколько массивов. Когда `func(x [, y1, ..., yN])` возвращает значение, отличное от нуля, массив будет разделён слева от этого элемента. Массив не будет разделён перед первым элементом.

**Синтаксис**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — лямбда-функция, которая обрабатывает элементы исходного массива (`x`) и массивов условий (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).
* `source_arr` — исходный массив для разбиения [`Array(T)`](/sql-reference/data-types/array).
* `[, cond1_arr, ... , condN_arr]` — необязательный параметр. N массивов условий, передающих дополнительные аргументы в лямбда-функцию. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив массивов [`Array(Array(T))`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```


## arraySum

Введена в: v21.1

Возвращает сумму элементов исходного массива.

Если указана лямбда-функция `func`, возвращает сумму элементов, полученных в результате её применения.

**Синтаксис**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Аргументы**

* `func(x[, y1, ..., yN])` — Необязательный параметр. Лямбда-функция, которая применяется к элементам исходного массива (`x`) и массивов условий (`y`). [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — Исходный массив для обработки. [`Array(T)`](/sql-reference/data-types/array)
* `, cond1_arr, ... , condN_arr]` — Необязательный параметр. N массивов условий, предоставляющих дополнительные аргументы лямбда-функции. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает сумму элементов исходного массива или сумму элементов, полученных в результате применения лямбда-функции, если она задана.

**Примеры**

**Базовый пример**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**Использование с функцией Lambda**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```


## arraySymmetricDifference

Добавлено в: v25.4

Принимает несколько массивов и возвращает массив с элементами, которые отсутствуют хотя бы в одном из исходных массивов. Результат содержит только уникальные значения.

:::note
Симметрическая разность *более чем двух множеств* [математически определяется](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)
как множество всех входных элементов, которые встречаются в нечётном числе входных множеств.
В отличие от этого определения, функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые отсутствуют во всех входных множествах одновременно.
:::

**Синтаксис**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**Аргументы**

* `arrN` — N массивов, из которых создаётся новый массив. [`Array(T)`](/sql-reference/data-types/array).

**Возвращаемое значение**

Возвращает массив различных элементов, которые не присутствуют во всех исходных массивах [`Array(T)`](/sql-reference/data-types/array).

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion

Добавлена в: v24.10

Функция принимает несколько массивов и возвращает массив, содержащий все элементы, присутствующие хотя бы в одном из исходных массивов. В результате остаются только уникальные значения.

**Синтаксис**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

* `arrN` — N массивов, из которых формируется новый массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив, содержащий уникальные элементы исходных массивов [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq

Появилась в версии: v1.1

При передаче одного аргумента считает количество различных элементов в массиве.
При передаче нескольких аргументов считает количество различных **кортежей**, составленных из элементов на соответствующих позициях в нескольких массивах.

Например, `SELECT arrayUniq([1,2], [3,4], [5,6])` сформирует следующие кортежи:

* Позиция 1: (1,3,5)
* Позиция 2: (2,4,6)

Затем будет подсчитано количество уникальных кортежей. В данном случае `2`.

Все переданные массивы должны иметь одинаковую длину.

:::tip
Если нужно получить список уникальных элементов в массиве, используйте `arrayReduce('groupUniqArray', arr)`.
:::

**Синтаксис**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**Аргументы**

* `arr1` — Массив, для которого нужно посчитать количество уникальных элементов. [`Array(T)`](/sql-reference/data-types/array)
* `[, arr2, ..., arrN]` — Необязательные аргументы. Дополнительные массивы, используемые для подсчёта количества уникальных кортежей элементов на соответствующих позициях в нескольких массивах. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Для одного аргумента возвращает количество уникальных элементов. Для нескольких аргументов возвращает количество уникальных кортежей, составленных из элементов на соответствующих позициях в массивах.
[`UInt32`](/sql-reference/data-types/int-uint)

**Примеры**

**Один аргумент**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**Несколько аргументов**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```


## arrayWithConstant

Появилась в версии: v20.1

Создаёт массив длины `length`, заполненный константой `x`.

**Синтаксис**

```sql
arrayWithConstant(N, x)
```

**Аргументы**

* `length` — количество элементов в массиве. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `x` — значение `N` элементов в массиве, произвольного типа.

**Возвращаемое значение**

Возвращает массив из `N` элементов со значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```


## arrayZip

Появилась в версии: v20.1

Объединяет несколько массивов в один массив. Полученный массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**Аргументы**

* `arr1, arr2, ... , arrN` — N массивов для объединения в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с элементами исходных массивов, сгруппированными в кортежи. Типы данных в кортеже совпадают с типами входных массивов и следуют в том же порядке, в котором массивы передаются. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned

Впервые добавлена в: v20.1

Объединяет несколько массивов в один, позволяя использовать невыравненные массивы (массивы разной длины). Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в перечисленном порядке аргументов.

**Синтаксис**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

* `arr1, arr2, ..., arrN` — N массивов, которые нужно объединить в один массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив с элементами из исходных массивов, сгруппированными в кортежи. Типы данных в кортеже совпадают с типами входных массивов и следуют в том же порядке, в каком переданы массивы. [`Array(T)`](/sql-reference/data-types/array) или [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**Примеры**

**Пример использования**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual

Появилась в версии: v1.1

Возвращает количество элементов массива, равных `x`. Эквивалентно `arrayCount(elem -> elem = x, arr)`.

Элементы `NULL` рассматриваются как отдельные значения.

**Синтаксис**

```sql
countEqual(arr, x)
```

**Аргументы**

* `arr` — Массив, в котором выполняется поиск. [`Array(T)`](/sql-reference/data-types/array)
* `x` — Значение в массиве, количество вхождений которого нужно посчитать. Любой тип.

**Возвращаемое значение**

Возвращает количество элементов в массиве, равных `x` [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```


## empty

Добавлена в версии: v1.1

Проверяет, является ли входной массив пустым.

Массив считается пустым, если он не содержит ни одного элемента.

:::note
Выполнение запроса можно оптимизировать, включив [настройку `optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подстолбец [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всего столбца с массивами. Запрос `SELECT empty(arr) FROM TABLE;` преобразуется в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает со строками (String) и UUID.

**Синтаксис**

```sql
empty(arr)
```

**Аргументы**

* `arr` — входной массив типа [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для пустого массива и `0` для непустого массива типа [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate

Введена в версии: v1.1

Возвращает пустой массив типа Date

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив типа Date. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```


## emptyArrayDateTime

Впервые представлена в версии v1.1

Возвращает пустой массив значений типа DateTime

**Синтаксис**

```sql
emptyArrayDateTime()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив DateTime. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```


## emptyArrayFloat32

Появилась в версии: v1.1

Возвращает пустой массив типа Float32

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив Float32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```


## emptyArrayFloat64

Добавлена в: v1.1

Возвращает пустой массив типа Float64

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив Float64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```


## emptyArrayInt16

Добавлена в версии: v1.1

Возвращает пустой массив типа Int16

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив типа Int16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```


## emptyArrayInt32

Введена в: v1.1

Возвращает пустой массив типа Int32

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив Int32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```


## emptyArrayInt64

Впервые появилось в: v1.1

Возвращает пустой массив Int64

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив Int64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```


## emptyArrayInt8

Добавлена в версии: v1.1

Возвращает пустой массив типа Int8

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив типа Int8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```


## emptyArrayString

Добавлена в версии: v1.1

Возвращает пустой массив типа String

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

* Нет.

**Возвращаемое значение**

Пустой массив строк. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```


## emptyArrayToSingle

Добавлено в: v1.1

Принимает пустой массив и возвращает одноэлементный массив, содержащий значение по умолчанию.

**Синтаксис**

```sql
emptyArrayToSingle(arr)
```

**Аргументы**

* `arr` — пустой массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Массив с одним значением типа по умолчанию для массива. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Простой пример**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16

Добавлена в: v1.1

Возвращает пустой массив UInt16

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив UInt16. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```


## emptyArrayUInt32

Введено в версии: v1.1

Возвращает пустой массив типа UInt32

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

* Нет аргументов.

**Возвращаемое значение**

Пустой массив UInt32. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```


## emptyArrayUInt64

Добавлена в: v1.1

Возвращает пустой массив UInt64

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив типа UInt64. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```


## emptyArrayUInt8

Добавлена в версии v1.1

Возвращает пустой массив типа UInt8

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

* Отсутствуют.

**Возвращаемое значение**

Пустой массив типа UInt8. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```


## has

Добавлена в: v1.1

Возвращает, содержит ли массив указанный элемент.

**Синтаксис**

```sql
has(arr, x)
```

**Аргументы**

* `arr` — исходный массив. [`Array(T)`](/sql-reference/data-types/array)
* `x` — значение, которое нужно найти в массиве.

**Возвращаемое значение**

Возвращает `1`, если массив содержит указанный элемент, иначе `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Базовое использование**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**Не найдено**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```


## hasAll

Добавлена в версии: v1.1

Проверяет, является ли один массив подмножеством другого.

* Пустой массив является подмножеством любого массива.
* `Null` обрабатывается как значение.
* Порядок значений в обоих массивах не имеет значения.

**Синтаксис**

```sql
hasAll(set, subset)
```

**Аргументы**

* `set` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `subset` — массив любого типа, который имеет общий супертип с `set` и содержит элементы, проверяемые на то, что они образуют подмножество `set`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

* `1`, если `set` содержит все элементы из `subset`.
* `0` — в противном случае.

Генерируется исключение `NO_COMMON_TYPE`, если элементы множества и подмножества не имеют общего супертипа.

**Примеры**

**Пустые массивы**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**Массивы, содержащие значения NULL**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**Массивы, содержащие значения разных типов**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**Массивы, содержащие значения типа String**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Массивы без общего типа данных**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Вызывает исключение NO_COMMON_TYPE
```

**Массив массивов**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```


## hasAny

Добавлена в версии: v1.1

Проверяет, имеют ли два массива пересечение хотя бы по одному элементу.

* `Null` обрабатывается как значение.
* Порядок значений в обоих массивах не важен.

**Синтаксис**

```sql
hasAny(arr_x, arr_y)
```

**Аргументы**

* `arr_x` — массив любого типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — массив любого типа, имеющий общий супертип с массивом `arr_x`. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

* `1`, если `arr_x` и `arr_y` имеют по крайней мере один общий элемент.
* `0` — в противном случае.

Выбрасывает исключение `NO_COMMON_TYPE`, если какие-либо элементы двух массивов не имеют общего супертипа.

**Примеры**

**Один массив пустой**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**Массивы, содержащие значения NULL**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**Массивы, содержащие значения иного типа**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**Массивы без общего типа**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Вызывает исключение `NO_COMMON_TYPE`
```

**Массив массивов**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```


## hasSubstr

Введена в версии: v20.6

Проверяет, встречаются ли все элементы массива array2 в массиве array1 в точно таком же порядке.
Соответственно, функция вернёт `1` тогда и только тогда, когда array1 = prefix + array2 + suffix.

Другими словами, функция проверяет, содержатся ли все элементы массива array2 в массиве array1, аналогично функции `hasAll`.
Кроме того, она проверяет, что элементы расположены в одном и том же порядке в обоих массивах array1 и array2.

* Функция вернёт `1`, если array2 пустой.
* `Null` обрабатывается как значение. Другими словами, `hasSubstr([1, 2, NULL, 3, 4], [2,3])` вернёт `0`. Однако `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` вернёт `1`.
* Порядок значений в обоих массивах имеет значение.

Вызывает исключение `NO_COMMON_TYPE`, если какой-либо из элементов двух массивов не имеет общего супертипа.

**Синтаксис**

```sql
hasSubstr(arr1, arr2)
```

**Аргументы**

* `arr1` — Массив произвольного типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)
* `arr2` — Массив произвольного типа с набором элементов. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1`, если массив `arr1` содержит массив `arr2`. В противном случае возвращает `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Оба массива пусты**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**Массивы, содержащие значения NULL**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**Массивы, содержащие значения разных типов**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**Массивы строк**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Массивы с корректным порядком**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**Массивы с некорректным порядком**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**Массив массивов**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**Массивы без единого типа**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Вызывает исключение `NO_COMMON_TYPE`
```


## indexOf

Добавлена в версии: v1.1

Функция возвращает индекс первого элемента со значением &#39;x&#39; (начиная с 1), если он есть в массиве.
Если массив не содержит искомого значения, функция возвращает `0`.

Элементы со значением `NULL` обрабатываются как обычные значения.

**Синтаксис**

```sql
indexOf(arr, x)
```

**Аргументы**

* `arr` — Массив, в котором выполняется поиск значения `x`. [`Array(T)`](/sql-reference/data-types/array)
* `x` — Значение первого совпадающего элемента в `arr`, индекс которого требуется вернуть. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (отсчёт от единицы) первого вхождения `x` в `arr`, если такое значение существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Простой пример**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**Массив с NULL-значениями**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```


## indexOfAssumeSorted

Добавлено в: v24.12

Возвращает индекс первого элемента со значением &#39;x&#39; (начиная с `1`), если он есть в массиве.
Если массив не содержит искомого значения, функция возвращает `0`.

:::note
В отличие от функции `indexOf`, эта функция предполагает, что массив отсортирован
по возрастанию. Если массив не отсортирован, результаты не определены.
:::

**Синтаксис**

```sql
indexOfAssumeSorted(arr, x)
```

**Аргументы**

* `arr` — отсортированный массив для поиска. [`Array(T)`](/sql-reference/data-types/array)
* `x` — значение первого совпадающего элемента в отсортированном массиве `arr`, индекс которого нужно вернуть. [`UInt64`](/sql-reference/data-types/int-uint)

**Возвращаемое значение**

Возвращает индекс (нумерация с единицы) первого `x` в `arr`, если такой элемент существует. В противном случае возвращает `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Простой пример**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```


## length

Добавлена в: v1.1

Вычисляет длину строки или массива.

* Для аргументов типа String или FixedString: вычисляет количество байт в строке.
* Для аргументов типа Array: вычисляет количество элементов в массиве.
* При применении к аргументу типа FixedString функция является константным выражением.

Обратите внимание, что количество байт в строке не совпадает с количеством
Unicode &quot;code points&quot; (кодовых точек) и не совпадает с количеством Unicode &quot;grapheme clusters&quot;
(того, что мы обычно называем &quot;символами&quot;), и не совпадает с видимой шириной строки.

В строках допустимо наличие нулевых байтов (ASCII NULL), и они также будут учитываться.

**Синтаксис**

```sql
length(x)
```

**Псевдонимы**: `OCTET_LENGTH`

**Аргументы**

* `x` — значение, для которого вычисляется количество байт (для String/FixedString) или элементов (для Array). [`String`](/sql-reference/data-types/string) или [`FixedString`](/sql-reference/data-types/fixedstring) или [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает количество байт в String/FixedString `x` или количество элементов в массиве `x`. Тип: [`UInt64`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример для строки String**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**Пример массива**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**пример constexpr**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**пример Unicode**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**пример ascii&#95;vs&#95;utf8**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty

Добавлена в: v1.1

Проверяет, является ли входной массив непустым.

Массив считается непустым, если он содержит по крайней мере один элемент.

:::note
Её работу можно оптимизировать, включив настройку [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подстолбец [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всего столбца-массива. Запрос `SELECT notEmpty(arr) FROM table` преобразуется в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функцию также можно применять к значениям типов `String` и `UUID`.

**Синтаксис**

```sql
notEmpty(arr)
```

**Аргументы**

* `arr` — входной массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает `1` для непустого массива или `0` для пустого массива. [`UInt8`](/sql-reference/data-types/int-uint)

**Примеры**

**Пример использования**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```


## range

Введена в версии: v1.1

Возвращает массив чисел от `start` до `end - 1` с шагом `step`.

Поддерживаемые типы:

* `UInt8/16/32/64`

* `Int8/16/32/64`

* Все аргументы `start`, `end`, `step` должны быть одним из указанных выше поддерживаемых типов. Элементы возвращаемого массива будут иметь тип — общий супертип аргументов.

* Генерируется исключение, если функция возвращает массив с общей длиной больше числа элементов, указанного настройкой [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block).

* Возвращает `NULL`, если какой-либо аргумент имеет тип Nullable(Nothing). Генерируется исключение, если какой-либо аргумент имеет значение `NULL` (тип Nullable(T)).

**Синтаксис**

```sql
range([start, ] end [, step])
```

**Аргументы**

* `start` — Необязательный параметр. Первый элемент массива. Обязателен, если используется `step`. Значение по умолчанию: `0`. - `end` — Обязательный параметр. Число, до которого (не включительно) строится массив. - `step` — Необязательный параметр. Определяет шаг между элементами массива. Значение по умолчанию: `1`.

**Возвращаемое значение**

Массив чисел от `start` до `end - 1` с шагом `step`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate

Добавлено в: v1.1

Создаёт массив, содержащий одно значение.

**Синтаксис**

```sql
replicate(x, arr)
```

**Аргументы**

* `x` — значение, которым заполняется результирующий массив. [`Any`](/sql-reference/data-types)
* `arr` — массив. [`Array(T)`](/sql-reference/data-types/array)

**Возвращаемое значение**

Возвращает массив той же длины, что и `arr`, заполненный значением `x`. [`Array(T)`](/sql-reference/data-types/array)

**Примеры**

**Пример использования**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse

Добавлена в версии v1.1

Меняет порядок следования элементов во входном массиве или символов во входной строке на обратный.

**Синтаксис**

```sql
reverse(arr | str)
```

**Аргументы**

* `arr | str` — Исходный массив или строка. [`Array(T)`](/sql-reference/data-types/array) или [`String`](/sql-reference/data-types/string)

**Возвращаемое значение**

Возвращает массив или строку, в которой элементы или символы расположены в обратном порядке.

**Примеры**

**Массив в обратном порядке**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**Реверс строки**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

{/*AUTOGENERATED_END*/ }


## Функции расстояния {#distance-functions}

Все поддерживаемые функции описаны в [документации по функциям расстояния](../../sql-reference/functions/distance-functions.md).

---
slug: /cloud/bestpractices/multi-tenancy
sidebar_label: 'Многотенантность'
title: 'Многотенантность'
description: 'Рекомендации по реализации многотенантности'
doc_type: 'guide'
keywords: ['multitenancy', 'isolation', 'best practices', 'architecture', 'multi-tenant']
---

На SaaS‑платформе аналитики данных распространена ситуация, когда несколько арендаторов, таких как организации, клиенты или бизнес‑подразделения, совместно используют одну и ту же инфраструктуру базы данных, при этом поддерживается логическое разделение их данных. Это позволяет разным пользователям безопасно получать доступ только к своим данным в рамках одной платформы.

В зависимости от требований существуют различные способы реализации многотенантности. Ниже приведено руководство по их реализации в ClickHouse Cloud.



## Общая таблица

В этом подходе данные всех арендаторов хранятся в одной общей таблице, а поле (или набор полей) используется для идентификации данных каждого арендатора. Для максимальной производительности это поле должно быть включено в [первичный ключ](/sql-reference/statements/create/table#primary-key). Чтобы гарантировать, что пользователи могут получать доступ только к данным, принадлежащим их арендаторам, мы используем [управление доступом на основе ролей](/operations/access-rights), реализованное через [политики на уровне строк](/operations/access-rights#row-policy-management).

> **Мы рекомендуем этот подход, так как он проще всего в управлении, особенно когда все арендаторы используют одинаковую схему данных, а объемы данных умеренные (&lt; ТБ)**

Объединяя все данные арендаторов в одной таблице, мы повышаем эффективность хранения за счет оптимизированного сжатия данных и уменьшения накладных расходов на метаданные. Кроме того, обновления схемы упрощаются, поскольку все данные централизованно управляются.

Этот метод особенно эффективен при работе с большим количеством арендаторов (потенциально миллионы).

Однако альтернативные подходы могут быть более предпочтительными, если у арендаторов разные схемы данных или ожидается, что они будут расходиться со временем.

В случаях, когда между арендаторами существует значительная разница в объеме данных, небольшие арендаторы могут столкнуться с неоправданным ухудшением производительности запросов. Обратите внимание, что эта проблема в значительной степени смягчается за счет включения поля арендатора в первичный ключ.

### Пример

Ниже приведен пример реализации модели мультиарендности с общей таблицей.

Сначала создадим общую таблицу с полем `tenant_id`, включенным в первичный ключ.

```sql
--- Создаём таблицу events. Используем tenant_id как часть первичного ключа
CREATE TABLE events
(
    tenant_id UInt32,                 -- Идентификатор арендатора
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- Идентификатор пользователя, инициировавшего событие
    data String,                 -- Данные события
)
ORDER BY (tenant_id, timestamp)
```

Добавим фиктивные данные.


```sql
-- Вставим несколько тестовых строк
INSERT INTO events (tenant_id, id, type, timestamp, user_id, data)
VALUES
(1, '7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "настольный компьютер", "location": "Лос-Анджелес"}'),
(1, '846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "телефон", "amount": 799}'),
(1, '6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "настольный компьютер", "location": "Лос-Анджелес"}'),
(2, '7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "мобильное устройство", "location": "Сан-Франциско"}'),
(2, '6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "наушники", "amount": 199}'),
(2, '43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "мобильное устройство", "location": "Сан-Франциско"}'),
(1, '83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "монитор", "amount": 450}'),
(1, '975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "настольный компьютер", "location": "Лос-Анджелес"}'),
(2, 'f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "ноутбук", "amount": 1200}'),
(2, '5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "мобильное устройство", "location": "Сан-Франциско"}'),
```

Теперь создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создать пользователей 
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
```

Мы [создаём политики строк](/sql-reference/statements/create/row-policy), которые ограничивают `user_1` и `user_2` так, чтобы они могли получать доступ только к данным своих арендаторов.

```sql
-- Создаем политики строк
CREATE ROW POLICY user_filter_1 ON default.events USING tenant_id=1 TO user_1
CREATE ROW POLICY user_filter_2 ON default.events USING tenant_id=2 TO user_2
```

Затем с помощью общей роли предоставьте привилегии [`GRANT SELECT`](/sql-reference/statements/grant#usage) на общую таблицу.

```sql
-- Создать роль
CREATE ROLE user_role

-- Предоставить права только на чтение таблицы events.
GRANT SELECT ON default.events TO user_role
GRANT user_role TO user_1
GRANT user_role TO user_2
```

Теперь вы можете подключиться под пользователем `user_1` и выполнить простой запрос SELECT. Будут возвращены только строки первого тенанта.

```sql
-- Выполнен вход пользователем user_1
SELECT *
FROM events
```


┌─tenant_id─┬─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐

1. │ 1 │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login │ 2025-03-19 08:00:00 │ 1001 │ {"device": "desktop", "location": "LA"} │
2. │ 1 │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase │ 2025-03-19 08:05:00 │ 1002 │ {"item": "phone", "amount": 799} │
3. │ 1 │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │ 1001 │ {"device": "desktop", "location": "LA"} │
4. │ 1 │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase │ 2025-03-19 08:45:00 │ 1003 │ {"item": "monitor", "amount": 450} │
5. │ 1 │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login │ 2025-03-19 08:50:00 │ 1004 │ {"device": "desktop", "location": "LA"} │
   └───────────┴──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘

```

```


## Отдельные таблицы

При таком подходе данные каждого арендатора хранятся в отдельной таблице в одной и той же базе данных, что устраняет необходимость в отдельном поле для идентификации арендаторов. Доступ пользователей обеспечивается с помощью [оператора GRANT](/sql-reference/statements/grant), что гарантирует, что каждый пользователь может получать доступ только к тем таблицам, которые содержат данные его арендатора.

> **Использование отдельных таблиц — хороший выбор, когда у арендаторов разные схемы данных.**

Для сценариев с небольшим количеством арендаторов, но с очень большими наборами данных, где производительность запросов критична, этот подход может превосходить модель общей таблицы. Поскольку нет необходимости отфильтровывать данные других арендаторов, запросы могут быть более эффективными. Кроме того, первичные ключи можно дополнительно оптимизировать, так как нет необходимости включать в первичный ключ дополнительное поле (например, идентификатор арендатора).

Обратите внимание, что этот подход не масштабируется на тысячи арендаторов. См. [ограничения использования](/cloud/bestpractices/usage-limits).

### Пример

Ниже приведён пример реализации многопользовательской модели с отдельными таблицами.

Сначала создадим две таблицы: одну для событий от `tenant_1` и одну для событий от `tenant_2`.

```sql
-- Создать таблицу для арендатора 1 
CREATE TABLE events_tenant_1
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- Идентификатор пользователя, инициировавшего событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id) -- Первичный ключ может быть построен по другим атрибутам

-- Создать таблицу для арендатора 2 
CREATE TABLE events_tenant_2
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- Идентификатор пользователя, инициировавшего событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id) -- Первичный ключ может быть построен по другим атрибутам
```

Добавим тестовые данные.

```sql
INSERT INTO events_tenant_1 (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'вход_пользователя', '2025-03-19 08:00:00', 1001, '{"device": "настольный_компьютер", "location": "Лос_Анджелес"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'покупка', '2025-03-19 08:05:00', 1002, '{"item": "телефон", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'выход_пользователя', '2025-03-19 08:10:00', 1001, '{"device": "настольный_компьютер", "location": "Лос_Анджелес"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'покупка', '2025-03-19 08:45:00', 1003, '{"item": "монитор", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'вход_пользователя', '2025-03-19 08:50:00', 1004, '{"device": "настольный_компьютер", "location": "Лос_Анджелес"}')
```


INSERT INTO events_tenant_2 (id, type, timestamp, user_id, data)
VALUES
('7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "mobile", "location": "SF"}'),
('6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "headphones", "amount": 199}'),
('43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "mobile", "location": "SF"}'),
('f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "laptop", "amount": 1200}'),
('5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "mobile", "location": "SF"}')

````

Теперь создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создадим пользователей
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
````

Затем предоставим привилегии `GRANT SELECT` на соответствующую таблицу.

```sql
-- Предоставить права только на чтение таблицы events.
GRANT SELECT ON default.events_tenant_1 TO user_1
GRANT SELECT ON default.events_tenant_2 TO user_2
```

Теперь вы можете подключиться под пользователем `user_1` и выполнить простой запрос SELECT к соответствующей таблице. Будут возвращены только строки из первого тенанта.

```sql
-- Выполнен вход под пользователем user_1
SELECT *
FROM default.events_tenant_1

   ┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐
1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login  │ 2025-03-19 08:00:00 │    1001 │ {"device": "desktop", "location": "LA"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase    │ 2025-03-19 08:05:00 │    1002 │ {"item": "phone", "amount": 799}        │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │    1001 │ {"device": "desktop", "location": "LA"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase    │ 2025-03-19 08:45:00 │    1003 │ {"item": "monitor", "amount": 450}      │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login  │ 2025-03-19 08:50:00 │    1004 │ {"device": "desktop", "location": "LA"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘
```


## Отдельные базы данных

Данные каждого арендатора хранятся в отдельной базе данных в рамках одного сервиса ClickHouse.

> **Этот подход полезен, если каждому арендатору требуется большое количество таблиц и, возможно, материализованных представлений, а также используется своя схема данных. Однако управление таким решением может стать затруднительным, если число арендаторов велико.**

Реализация аналогична подходу с отдельными таблицами, но вместо выдачи привилегий на уровне таблиц привилегии выдаются на уровне баз данных.

Обратите внимание, что этот подход не масштабируется до тысяч арендаторов. См. [ограничения использования](/cloud/bestpractices/usage-limits).

### Пример

Ниже приведён пример реализации многопользовательской модели с отдельными базами данных.

Сначала создадим две базы данных: одну для `tenant_1` и одну для `tenant_2`.

```sql
-- Создать базу данных для tenant_1
CREATE DATABASE tenant_1;

-- Создать базу данных для tenant_2
CREATE DATABASE tenant_2;
```

```sql
-- Создание таблицы для tenant_1
CREATE TABLE tenant_1.events
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- Идентификатор пользователя, вызвавшего событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);

-- Создание таблицы для tenant_2
CREATE TABLE tenant_2.events
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- Идентификатор пользователя, вызвавшего событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);
```

Вставим тестовые данные.

```sql
INSERT INTO tenant_1.events (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'вход_пользователя', '2025-03-19 08:00:00', 1001, '{"device": "настольный_компьютер", "location": "Лос_Анджелес"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'покупка', '2025-03-19 08:05:00', 1002, '{"item": "телефон", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'выход_пользователя', '2025-03-19 08:10:00', 1001, '{"device": "настольный_компьютер", "location": "Лос_Анджелес"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'покупка', '2025-03-19 08:45:00', 1003, '{"item": "монитор", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'вход_пользователя', '2025-03-19 08:50:00', 1004, '{"device": "настольный_компьютер", "location": "Лос_Анджелес"}')
```


INSERT INTO tenant_2.events (id, type, timestamp, user_id, data)
VALUES
('7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "mobile", "location": "SF"}'),
('6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "headphones", "amount": 199}'),
('43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "mobile", "location": "SF"}'),
('f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "laptop", "amount": 1200}'),
('5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "mobile", "location": "SF"}')

````

Теперь создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создание пользователей
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
````

Затем выдадим привилегию `GRANT SELECT` для соответствующей таблицы.

```sql
-- Предоставить доступ только на чтение к таблице events.
GRANT SELECT ON tenant_1.events TO user_1
GRANT SELECT ON tenant_2.events TO user_2
```

Теперь вы можете подключиться под пользователем `user_1` и выполнить простой запрос SELECT к таблице events соответствующей базы данных. Будут возвращены только строки из первого тенанта.

```sql
-- Подключение под пользователем user_1
SELECT *
FROM tenant_1.events

   ┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐
1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192д1 │ user_login  │ 2025-03-19 08:00:00 │    1001 │ {"device": "desktop", "location": "LA"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase    │ 2025-03-19 08:05:00 │    1002 │ {"item": "phone", "amount": 799}        │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │    1001 │ {"device": "desktop", "location": "LA"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase    │ 2025-03-19 08:45:00 │    1003 │ {"item": "monitor", "amount": 450}      │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login  │ 2025-03-19 08:50:00 │    1004 │ {"device": "desktop", "location": "LA"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘
```


## Разделение вычислительных ресурсов {#compute-compute-separation}

Три описанных выше подхода могут быть дополнительно изолированы с помощью [Warehouses](/cloud/reference/warehouses#what-is-a-warehouse). Данные хранятся в общем объектном хранилище, но каждый арендатор может иметь собственный вычислительный сервис благодаря [разделению вычислительных ресурсов](/cloud/reference/warehouses#what-is-compute-compute-separation) с разным соотношением CPU/память. 

Управление пользователями аналогично подходам, описанным выше, поскольку все сервисы в одном Warehouse [совместно используют настройки управления доступом](/cloud/reference/warehouses#database-credentials). 

Обратите внимание, что число дочерних сервисов в одном Warehouse ограничено. См. [ограничения Warehouse](/cloud/reference/warehouses#limitations).



## Отдельный облачный сервис

Наиболее радикальный подход — использовать отдельный сервис ClickHouse для каждого арендатора.

> **Этот менее распространённый метод подойдёт, если данные арендаторов должны храниться в разных регионах — по юридическим причинам, требованиям безопасности или соображениям близости.**

Необходимо создать учётную запись пользователя в каждом сервисе, через которую пользователь получает доступ к данным соответствующего арендатора.

Этот подход сложнее в управлении и приводит к дополнительным накладным расходам для каждого сервиса, поскольку каждому сервису требуется собственная инфраструктура для работы. Управлять сервисами можно через [ClickHouse Cloud API](/cloud/manage/api/api-overview), а оркестрацию также можно реализовать с помощью [официального провайдера Terraform](https://registry.terraform.io/providers/ClickHouse/clickhouse/latest/docs).

### Пример

Ниже приведён пример реализации модели мультиарендности с использованием отдельных сервисов. Обратите внимание, что в примере показано создание таблиц и пользователей в одном сервисе ClickHouse; то же самое потребуется повторить на всех сервисах.

Сначала создадим таблицу `events`

```sql
-- Создать таблицу для tenant_1
CREATE TABLE events
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- Идентификатор пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);
```

Добавим тестовые данные.

```sql
INSERT INTO events (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}')
```

Теперь давайте создадим двух пользователей `user_1`

```sql
-- Создание пользователей 
CREATE USER user_1 IDENTIFIED BY '<password>'
```

Затем предоставьте привилегии `SELECT` на соответствующую таблицу с помощью `GRANT`.

```sql
-- Предоставить только права на чтение таблицы events.
GRANT SELECT ON events TO user_1
```

Теперь вы можете подключиться как `user_1` к сервису для тенанта 1 и выполнить простой запрос `SELECT`. Будут возвращены только строки из первого тенанта.

```sql
-- Выполнен вход под пользователем user_1
SELECT *
FROM events
```


┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐

1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login │ 2025-03-19 08:00:00 │ 1001 │ {"device": "настольный ПК", "location": "Лос-Анджелес"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase │ 2025-03-19 08:05:00 │ 1002 │ {"item": "смартфон", "amount": 799} │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │ 1001 │ {"device": "настольный ПК", "location": "Лос-Анджелес"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase │ 2025-03-19 08:45:00 │ 1003 │ {"item": "монитор", "amount": 450} │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login │ 2025-03-19 08:50:00 │ 1004 │ {"device": "настольный ПК", "location": "Лос-Анджелес"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘

```

```

---
slug: /cloud/bestpractices/multi-tenancy
sidebar_label: 'Многотенантность'
title: 'Многотенантность'
description: 'Лучшие практики реализации многотенантности'
doc_type: 'guide'
keywords: ['multitenancy', 'isolation', 'best practices', 'architecture', 'multi-tenant']
---

В SaaS‑платформе для аналитики данных часто несколько «арендаторов» — например, организации, клиенты или бизнес‑подразделения — используют одну и ту же инфраструктуру базы данных, при этом сохраняя логическое разделение своих данных. Это позволяет разным пользователям безопасно получать доступ к своим данным в рамках одной платформы.

В зависимости от требований многотенантность можно реализовать разными способами. Ниже приведено руководство по реализации этих подходов в ClickHouse Cloud.



## Общая таблица {#shared-table}

При таком подходе данные всех клиентов хранятся в одной общей таблице, а для идентификации данных каждого клиента используется поле (или набор полей). Для максимальной производительности это поле должно быть включено в [первичный ключ](/sql-reference/statements/create/table#primary-key). Чтобы гарантировать, что пользователи могут получать доступ только к данным своих клиентов, используется [управление доступом на основе ролей](/operations/access-rights), реализованное через [политики строк](/operations/access-rights#row-policy-management).

> **Мы рекомендуем этот подход, так как он наиболее прост в управлении, особенно когда все клиенты используют одинаковую схему данных, а объёмы данных умеренные (< ТБ)**

Объединение данных всех клиентов в одну таблицу повышает эффективность хранения за счёт оптимизированного сжатия данных и снижения накладных расходов на метаданные. Кроме того, обновление схемы упрощается, поскольку все данные управляются централизованно.

Этот метод особенно эффективен для работы с большим количеством клиентов (потенциально миллионами).

Однако альтернативные подходы могут быть более подходящими, если у клиентов разные схемы данных или ожидается их расхождение со временем.

В случаях, когда между клиентами существует значительная разница в объёме данных, клиенты с меньшими объёмами могут столкнуться с ненужным снижением производительности запросов. Обратите внимание, что эта проблема в значительной степени смягчается включением поля клиента в первичный ключ.

### Пример {#shared-table-example}

Это пример реализации модели мультиклиентности с общей таблицей.

Сначала создадим общую таблицу с полем `tenant_id`, включённым в первичный ключ.

```sql
--- Создание таблицы events. Используем tenant_id как часть первичного ключа
CREATE TABLE events
(
    tenant_id UInt32,                 -- Идентификатор клиента
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- Идентификатор пользователя, инициировавшего событие
    data String,                 -- Данные события
)
ORDER BY (tenant_id, timestamp)
```

Вставим тестовые данные.


```sql
-- Вставляем несколько тестовых строк
INSERT INTO events (tenant_id, id, type, timestamp, user_id, data)
VALUES
(1, '7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
(1, '846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
(1, '6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
(2, '7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "mobile", "location": "SF"}'),
(2, '6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "headphones", "amount": 199}'),
(2, '43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "mobile", "location": "SF"}'),
(1, '83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
(1, '975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}'),
(2, 'f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "laptop", "amount": 1200}'),
(2, '5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "mobile", "location": "SF"}'),
```

Теперь создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создать пользователей 
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
```

Мы [создаем политики строк](/sql-reference/statements/create/row-policy), которые ограничивают `user_1` и `user_2` доступом только к данным их клиентов.

```sql
-- Create row policies
CREATE ROW POLICY user_filter_1 ON default.events USING tenant_id=1 TO user_1
CREATE ROW POLICY user_filter_2 ON default.events USING tenant_id=2 TO user_2
```

Затем предоставьте привилегии [`GRANT SELECT`](/sql-reference/statements/grant#usage) на общую таблицу, используя общую роль.

```sql
-- Создать роль
CREATE ROLE user_role

-- Предоставить права только на чтение для таблицы events.
GRANT SELECT ON default.events TO user_role
GRANT user_role TO user_1
GRANT user_role TO user_2
```

Теперь вы можете подключиться под пользователем `user_1` и выполнить простой запрос SELECT. Будут возвращены только строки первого арендатора.

```sql
-- Вошли как user_1
SELECT *
FROM events
```


┌─tenant_id─┬─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐

1. │ 1 │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login │ 2025-03-19 08:00:00 │ 1001 │ {"device": "desktop", "location": "LA"} │
2. │ 1 │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase │ 2025-03-19 08:05:00 │ 1002 │ {"item": "phone", "amount": 799} │
3. │ 1 │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │ 1001 │ {"device": "desktop", "location": "LA"} │
4. │ 1 │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase │ 2025-03-19 08:45:00 │ 1003 │ {"item": "monitor", "amount": 450} │
5. │ 1 │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login │ 2025-03-19 08:50:00 │ 1004 │ {"device": "desktop", "location": "LA"} │
   └───────────┴──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘

```

```


## Отдельные таблицы {#separate-tables}

В этом подходе данные каждого арендатора хранятся в отдельной таблице в той же базе данных, что устраняет необходимость в специальном поле для идентификации арендаторов. Доступ пользователей контролируется с помощью [оператора GRANT](/sql-reference/statements/grant/), обеспечивая, чтобы каждый пользователь мог обращаться только к таблицам с данными своих арендаторов.

> **Использование отдельных таблиц — хороший выбор, когда у арендаторов разные схемы данных.**

Для сценариев с небольшим числом арендаторов и очень большими наборами данных, где производительность запросов имеет решающее значение, этот подход может превосходить модель с общей таблицей. Поскольку нет необходимости отфильтровывать данные других арендаторов, запросы выполняются эффективнее. Кроме того, первичные ключи можно дополнительно оптимизировать, не включая в них лишнее поле (например, ID арендатора).

Обратите внимание: этот подход не масштабируется для тысяч арендаторов. См. [лимиты использования](/cloud/bestpractices/usage-limits).

### Пример {#separate-tables-example}

Это пример реализации модели многотенантности с отдельными таблицами.

Сначала создадим две таблицы: одну для событий `tenant_1` и одну для событий `tenant_2`.

```sql
-- Создать таблицу для арендатора 1
CREATE TABLE events_tenant_1
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- ID пользователя, инициировавшего событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id) -- Первичный ключ может быть оптимизирован для других атрибутов

-- Создать таблицу для арендатора 2
CREATE TABLE events_tenant_2
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- ID пользователя, инициировавшего событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id) -- Первичный ключ может быть оптимизирован для других атрибутов
```

Вставим тестовые данные.

```sql
INSERT INTO events_tenant_1 (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}')

```


INSERT INTO events_tenant_2 (id, type, timestamp, user_id, data)
VALUES
('7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "mobile", "location": "SF"}'),
('6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "headphones", "amount": 199}'),
('43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "mobile", "location": "SF"}'),
('f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "laptop", "amount": 1200}'),
('5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "mobile", "location": "SF"}')

````

Затем создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создание пользователей
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
````

Затем предоставим привилегии `GRANT SELECT` на соответствующие таблицы.

```sql
-- Предоставление прав только на чтение для таблицы events.
GRANT SELECT ON default.events_tenant_1 TO user_1
GRANT SELECT ON default.events_tenant_2 TO user_2
```

Теперь можно подключиться как `user_1` и выполнить простой запрос SELECT из таблицы, соответствующей этому пользователю. Возвращаются только строки первого тенанта.

```sql
-- Вход выполнен как user_1
SELECT *
FROM default.events_tenant_1

   ┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐
1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login  │ 2025-03-19 08:00:00 │    1001 │ {"device": "desktop", "location": "LA"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase    │ 2025-03-19 08:05:00 │    1002 │ {"item": "phone", "amount": 799}        │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │    1001 │ {"device": "desktop", "location": "LA"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase    │ 2025-03-19 08:45:00 │    1003 │ {"item": "monitor", "amount": 450}      │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login  │ 2025-03-19 08:50:00 │    1004 │ {"device": "desktop", "location": "LA"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘
```


## Отдельные базы данных {#separate-databases}

Данные каждого арендатора хранятся в отдельной базе данных в рамках одной службы ClickHouse.

> **Этот подход полезен, если каждый арендатор использует большое количество таблиц и, возможно, материализованные представления, а также имеет свою схему данных. Однако при большом количестве арендаторов управление может стать сложным.**

Реализация аналогична подходу с отдельными таблицами, но вместо предоставления привилегий на уровне таблиц привилегии предоставляются на уровне базы данных.

Обратите внимание, что этот подход не масштабируется для тысяч арендаторов. См. [usage limits](/cloud/bestpractices/usage-limits).

### Пример {#separate-databases-example}

Это пример реализации модели мультитенантности с отдельными базами данных.

Сначала создадим две базы данных, одну для `tenant_1` и одну для `tenant_2`.

```sql
-- Создать базу данных для tenant_1
CREATE DATABASE tenant_1;

-- Создать базу данных для tenant_2
CREATE DATABASE tenant_2;
```

```sql
-- Создать таблицу для tenant_1
CREATE TABLE tenant_1.events
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Метка времени события
    user_id UInt32,               -- Идентификатор пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);

-- Создать таблицу для tenant_2
CREATE TABLE tenant_2.events
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Метка времени события
    user_id UInt32,               -- Идентификатор пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);
```

Вставим фиктивные данные.

```sql
INSERT INTO tenant_1.events (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}')

```


INSERT INTO tenant_2.events (id, type, timestamp, user_id, data)
VALUES
('7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "mobile", "location": "SF"}'),
('6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "headphones", "amount": 199}'),
('43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "mobile", "location": "SF"}'),
('f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "laptop", "amount": 1200}'),
('5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "mobile", "location": "SF"}')

````

Затем создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создание пользователей
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
````

Затем предоставим привилегии `GRANT SELECT` на соответствующие таблицы.

```sql
-- Предоставление прав только на чтение таблицы events.
GRANT SELECT ON tenant_1.events TO user_1
GRANT SELECT ON tenant_2.events TO user_2
```

Теперь можно подключиться как `user_1` и выполнить простой запрос SELECT к таблице events соответствующей базы данных. Будут возвращены только строки первого тенанта.

```sql
-- Вход выполнен как user_1
SELECT *
FROM tenant_1.events

   ┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐
1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login  │ 2025-03-19 08:00:00 │    1001 │ {"device": "desktop", "location": "LA"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase    │ 2025-03-19 08:05:00 │    1002 │ {"item": "phone", "amount": 799}        │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │    1001 │ {"device": "desktop", "location": "LA"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase    │ 2025-03-19 08:45:00 │    1003 │ {"item": "monitor", "amount": 450}      │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login  │ 2025-03-19 08:50:00 │    1004 │ {"device": "desktop", "location": "LA"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘
```


## Разделение вычислительных ресурсов {#compute-compute-separation}

Три подхода, описанные выше, можно дополнительно изолировать с помощью [Warehouses](/cloud/reference/warehouses#what-is-a-warehouse). Данные используются совместно через общее объектное хранилище, но каждый арендатор может иметь собственный вычислительный сервис благодаря [разделению вычислительных ресурсов](/cloud/reference/warehouses#what-is-compute-compute-separation) с различным соотношением CPU/памяти.

Управление пользователями аналогично ранее описанным подходам, поскольку все сервисы в warehouse [используют общие средства управления доступом](/cloud/reference/warehouses#database-credentials).

Обратите внимание, что количество дочерних сервисов в warehouse ограничено. См. [Ограничения Warehouse](/cloud/reference/warehouses#limitations).


## Отдельный облачный сервис {#separate-service}

Наиболее радикальный подход — использовать отдельный сервис ClickHouse для каждого тенанта.

> **Этот менее распространённый метод может быть решением, если данные тенантов должны храниться в разных регионах — по юридическим причинам, соображениям безопасности или близости.**

Учётная запись пользователя должна быть создана на каждом сервисе, где пользователь может получить доступ к данным соответствующего тенанта.

Этот подход сложнее в управлении и создаёт дополнительные накладные расходы для каждого сервиса, поскольку каждый из них требует собственной инфраструктуры для работы. Сервисами можно управлять через [ClickHouse Cloud API](/cloud/manage/api/api-overview), также возможна оркестрация с помощью [официального провайдера Terraform](https://registry.terraform.io/providers/ClickHouse/clickhouse/latest/docs).

### Пример {#separate-service-example}

Это пример реализации мультитенантной модели с отдельными сервисами. Обратите внимание, что пример показывает создание таблиц и пользователей на одном сервисе ClickHouse, то же самое необходимо будет повторить на всех сервисах.

Сначала создадим таблицу `events`

```sql
-- Создание таблицы для tenant_1
CREATE TABLE events
(
    id UUID,                    -- Уникальный идентификатор события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- Идентификатор пользователя, инициировавшего событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);
```

Вставим тестовые данные.

```sql
INSERT INTO events (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}')
```

Затем создадим пользователя `user_1`

```sql
-- Создание пользователей
CREATE USER user_1 IDENTIFIED BY '<password>'
```

Затем предоставим привилегии `GRANT SELECT` на соответствующую таблицу.

```sql
-- Предоставление прав только на чтение таблицы events.
GRANT SELECT ON events TO user_1
```

Теперь вы можете подключиться как `user_1` к сервису для тенанта 1 и выполнить простой запрос select. Будут возвращены только строки первого тенанта.

```sql
-- Вход выполнен как user_1
SELECT *
FROM events

```


┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐

1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login │ 2025-03-19 08:00:00 │ 1001 │ {"device": "desktop", "location": "LA"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase │ 2025-03-19 08:05:00 │ 1002 │ {"item": "phone", "amount": 799} │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │ 1001 │ {"device": "desktop", "location": "LA"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase │ 2025-03-19 08:45:00 │ 1003 │ {"item": "monitor", "amount": 450} │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login │ 2025-03-19 08:50:00 │ 1004 │ {"device": "desktop", "location": "LA"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘

```

```

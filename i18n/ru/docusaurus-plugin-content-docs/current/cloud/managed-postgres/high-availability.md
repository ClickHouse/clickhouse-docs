---
slug: /cloud/managed-postgres/high-availability
sidebar_label: 'Высокая доступность'
title: 'Высокая доступность'
description: 'Настройте резервные реплики и режимы репликации для обеспечения высокой доступности в ClickHouse Managed Postgres'
keywords: ['высокая доступность', 'ha', 'standby', 'репликация', 'аварийное переключение', 'postgres ha']
doc_type: 'guide'
---

import PrivatePreviewBadge from '@theme/badges/PrivatePreviewBadge';
import Image from '@theme/IdealImage';

<PrivatePreviewBadge />

В Managed Postgres доступны различные уровни высокой доступности в соответствии с вашими требованиями к надежности и производительности. Вы можете добавить одну или две резервные реплики при создании базы данных или при необходимости позже изменить эту конфигурацию на странице **Settings**.

{/* TODO(kaushik-ubi): Скриншот экрана настройки высокой доступности
    Path: /static/images/cloud/managed-postgres/high-availability-config.png */}


## Варианты высокой доступности \{#high-availability-options\}

### 2 Standbys \{#two-standbys\}

При использовании двух резервных узлов рядом с основным создаются два узла-реплики. Оба резервных узла имеют тот же размер, что и основной, и любой из них может взять на себя нагрузку в случае отказа основного.

Эта конфигурация использует **синхронную репликацию**, при которой основной узел ожидает подтверждения как минимум от одного резервного узла перед подтверждением записи. Это обеспечивает более сильные гарантии сохранности данных по сравнению с асинхронной репликацией. Поскольку требуется только одно подтверждение (а не оба), влияние на производительность менее существенно, чем при синхронной репликации с одним резервным узлом.

### 1 Standby \{#one-standby\}

При использовании одного standby рядом с вашим primary разворачивается узел‑реплика. Standby имеет тот же размер, что и primary, и может принять его роль при отказе primary.

Данные реплицируются на standby с помощью **асинхронной репликации**. Это означает, что операции записи подтверждаются на primary, не дожидаясь подтверждения от standby. Асинхронная репликация обеспечивает высокую доступность, не замедляя операции записи из‑за дополнительной сетевой задержки. Однако это также означает, что на момент отказа primary standby может не содержать самые последние транзакции. Для большинства приложений такой компромисс между производительностью и небольшим риском потери совсем недавних записей оправдан. Если необходима более высокая надежность сохранения записей, рекомендуется использовать 2 standby.

### Без Standby \{#no-standby\}

В этом варианте создаётся только основной узел выбранного размера. Standby-узел не создаётся. Основной узел по‑прежнему отслеживается на предмет сбоев, но восстановление может занять больше времени в зависимости от характера проблемы, поскольку нет реплики, готовой принять нагрузку. Эта конфигурация лучше всего подходит для сред разработки, тестирования или некритичных рабочих нагрузок, где допустим некоторый простой.

## Standbys и read replicas \{#standbys-vs-read-replicas\}

Standbys и read replicas выполняют разные задачи в Managed Postgres и настраиваются отдельно.

**Standbys** предназначены исключительно для обеспечения высокой доступности и автоматического failover. Они реплицируют данные с primary с помощью streaming replication и всегда готовы быть повышены до роли primary в случае его отказа. Standbys не доступны для выполнения запросов на чтение.

**Read replicas** предназначены для масштабирования чтения. Они извлекают данные WAL (Write-Ahead Log) из объектного хранилища и работают в отдельном сетевом окружении со своей собственной конечной точкой подключения. Read replicas позволяют перенести нагрузку на операции чтения с вашего primary, не затрагивая гарантии HA.

### Почему резервные серверы не обслуживают запросы на чтение \{#why-standbys-dont-serve-read-queries\}

Хотя некоторые провайдеры баз данных предоставляют горячие резервные серверы для запросов только на чтение, Managed Postgres сознательно этого не делает. Разрешение выполнения запросов на чтение на резервных серверах может подорвать их основную задачу: быть готовыми немедленно взять на себя роль primary при его отказе.

Есть две основные проблемы:

1. **Конкуренция с WAL replay**: При нагрузках с интенсивной записью запросы на чтение на резервном сервере конкурируют с WAL replay за системные ресурсы. Такая конкуренция может вызывать высокий лаг репликации, из-за чего резервный сервер отстает от primary. Если произойдет failover, пока резервный сервер отстает, у него не будет самых свежих данных, и он может быть не готов корректно принять роль primary.

2. **Помехи работе VACUUM**: Долго выполняющиеся запросы на чтение на резервном сервере могут мешать `VACUUM` (и `AUTOVACUUM`) очищать «мертвые» кортежи на primary. PostgreSQL не может удалять строки, к которым активный запрос на любой реплике все еще может обращаться. Это может приводить к раздуванию таблиц и деградации производительности со временем.

Используя резервные серверы исключительно для задач failover, Managed Postgres обеспечивает, что они всегда синхронизированы и готовы взять на себя нагрузку с минимальной потерей данных и простоем. Для масштабирования чтения используйте вместо этого [реплики для чтения](/cloud/managed-postgres/read-replicas).

## Обработка сбоев \{#handling-failures\}

Все управляемые экземпляры Postgres находятся под непрерывным мониторингом на предмет сбоев, независимо от того, включена ли высокая доступность. Во всех случаях система пытается автоматически восстановиться после сбоев.

Когда доступны резервные реплики (standby), автоматическое восстановление происходит быстрее и проще. Обычно система восстанавливается в течение нескольких минут за счёт повышения резервной реплики до primary. Без резервных реплик восстановление может потребовать ручного вмешательства, что значительно увеличивает длительность любого простоя.
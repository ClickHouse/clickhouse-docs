---
sidebar_label: 'Ключи сортировки'
description: 'Как определять пользовательские ключи сортировки.'
slug: /integrations/clickpipes/postgres/ordering_keys
title: 'Ключи сортировки'
doc_type: 'guide'
keywords: ['clickpipes', 'postgresql', 'cdc', 'data ingestion', 'real-time sync']
---

Ключи сортировки (Ordering Keys, также известные как sorting keys) определяют, как данные упорядочиваются на диске и индексируются в таблице ClickHouse. При репликации из Postgres ClickPipes по умолчанию использует первичный ключ таблицы Postgres в качестве ключа сортировки для соответствующей таблицы в ClickHouse. В большинстве случаев первичный ключ Postgres является достаточным ключом сортировки, так как ClickHouse уже оптимизирован для быстрых сканирований, и пользовательские ключи сортировки часто не требуются.

Как описано в [руководстве по миграции](/migrations/postgresql/data-modeling-techniques), для более крупных сценариев использования в ключ сортировки ClickHouse следует включать дополнительные столбцы помимо первичного ключа Postgres, чтобы оптимизировать запросы. 

По умолчанию при использовании CDC выбор ключа сортировки, отличного от первичного ключа Postgres, может привести к проблемам с дедупликацией данных в ClickHouse. Это происходит потому, что ключ сортировки в ClickHouse выполняет двойную роль: он управляет индексированием и сортировкой данных, одновременно выступая в роли ключа дедупликации. Самый простой способ решить эту проблему — определить обновляемые материализованные представления.



## Использование обновляемых материализованных представлений {#use-refreshable-materialized-views}

Простой способ определения пользовательских ключей сортировки (ORDER BY) — использование [обновляемых материализованных представлений](/materialized-view/refreshable-materialized-view) (МП). Они позволяют периодически (например, каждые 5 или 10 минут) копировать всю таблицу с нужным ключом сортировки.

Ниже приведён пример обновляемого МП с пользовательским ORDER BY и необходимой дедупликацией:

```sql
CREATE MATERIALIZED VIEW posts_final
REFRESH EVERY 10 second ENGINE = ReplacingMergeTree(_peerdb_version)
ORDER BY (owneruserid,id) -- другой ключ сортировки, но с добавленным первичным ключом postgres
AS
SELECT * FROM posts FINAL
WHERE _peerdb_is_deleted = 0; -- выполняет дедупликацию
```


## Пользовательские ключи сортировки без обновляемых материализованных представлений {#custom-ordering-keys-without-refreshable-materialized-views}

Если обновляемые материализованные представления не работают из-за объема данных, вот несколько рекомендаций по определению пользовательских ключей сортировки для больших таблиц и решению проблем, связанных с дедупликацией.

### Выбирайте столбцы ключа сортировки, которые не изменяются для данной строки {#choose-ordering-key-columns-that-dont-change-for-a-given-row}

При добавлении дополнительных столбцов в ключ сортировки для ClickHouse (помимо первичного ключа из Postgres) рекомендуется выбирать столбцы, которые не изменяются для каждой строки. Это помогает предотвратить проблемы с согласованностью данных и дедупликацией при использовании ReplacingMergeTree.

Например, в многопользовательском SaaS-приложении использование (`tenant_id`, `id`) в качестве ключа сортировки является хорошим выбором. Эти столбцы уникально идентифицируют каждую строку, и `tenant_id` остается постоянным для данного `id`, даже если другие столбцы изменяются. Поскольку дедупликация по id эквивалентна дедупликации по (tenant_id, id), это помогает избежать [проблем с дедупликацией данных](https://docs.peerdb.io/mirror/ordering-key-different), которые могли бы возникнуть при изменении tenant_id.

### Установите Replica Identity для таблиц Postgres на пользовательский ключ сортировки {#set-replica-identity-on-postgres-tables-to-custom-ordering-key}

Для корректной работы Postgres CDC важно изменить `REPLICA IDENTITY` таблиц, чтобы включить столбцы ключа сортировки. Это необходимо для точной обработки операций DELETE.

Если `REPLICA IDENTITY` не включает столбцы ключа сортировки, Postgres CDC не будет захватывать значения столбцов, отличных от первичного ключа — это ограничение логического декодирования Postgres. Все столбцы ключа сортировки, кроме первичного ключа в Postgres, будут иметь значения null. Это влияет на дедупликацию, что означает, что предыдущая версия строки может не быть дедуплицирована с последней удаленной версией (где `_peerdb_is_deleted` установлен в 1).

В приведенном выше примере с `owneruserid` и `id`, если первичный ключ не включает `owneruserid`, необходимо создать `UNIQUE INDEX` для (`owneruserid`, `id`) и установить его в качестве `REPLICA IDENTITY` для таблицы. Это гарантирует, что Postgres CDC захватывает необходимые значения столбцов для точной репликации и дедупликации.

Ниже приведен пример того, как это сделать для таблицы events. Убедитесь, что вы применили это ко всем таблицам с измененными ключами сортировки.

```sql
-- Создание UNIQUE INDEX для (owneruserid, id)
CREATE UNIQUE INDEX posts_unique_owneruserid_idx ON posts(owneruserid, id);
-- Установка REPLICA IDENTITY для использования этого индекса
ALTER TABLE posts REPLICA IDENTITY USING INDEX posts_unique_owneruserid_idx;
```

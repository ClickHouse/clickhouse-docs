---
slug: /data-modeling/schema-design
title: 'Проектирование схемы'
description: 'Оптимизация схемы ClickHouse для повышения производительности запросов'
keywords: ['схема', 'проектирование схемы', 'оптимизация запросов']
doc_type: 'guide'
---

import stackOverflowSchema from '@site/static/images/data-modeling/stackoverflow-schema.png';
import schemaDesignIndices from '@site/static/images/data-modeling/schema-design-indices.png';
import Image from '@theme/IdealImage';

Понимание принципов эффективного проектирования схем данных является ключевым фактором оптимизации производительности ClickHouse и предполагает выбор решений, часто связанных с компромиссами; при этом оптимальный подход зависит от выполняемых запросов, а также от таких факторов, как частота обновления данных, требования к задержкам и объём данных. В этом руководстве представлен обзор лучших практик проектирования схем и методов моделирования данных для оптимизации производительности ClickHouse.


## Набор данных Stack Overflow {#stack-overflow-dataset}

В примерах в этом руководстве мы используем подмножество набора данных Stack Overflow. Оно содержит каждое сообщение, голосование, пользователя, комментарий и бейдж, появившиеся на Stack Overflow с 2008 по апрель 2024 года. Эти данные доступны в формате Parquet с использованием приведённых ниже схем в S3-бакете `s3://datasets-documentation/stackoverflow/parquet/`:

> Указанные первичные ключи и связи не обеспечиваются ограничениями (Parquet — это файловый, а не табличный формат) и служат исключительно для указания взаимосвязей данных и уникальных ключей, которыми они обладают.

<Image img={stackOverflowSchema} size="lg" alt="Схема Stack Overflow"/>

<br />

Набор данных Stack Overflow содержит несколько связанных таблиц. В любой задаче моделирования данных мы рекомендуем в первую очередь загружать основную таблицу. Это не обязательно самая большая таблица, а та, по которой вы ожидаете наибольшее число аналитических запросов. Это позволит вам познакомиться с основными концепциями и типами ClickHouse, что особенно важно, если вы в основном работали с OLTP-системами. По мере добавления дополнительных таблиц эту таблицу может потребоваться переработать, чтобы в полной мере использовать возможности ClickHouse и добиться оптимальной производительности.

Приведённая выше схема намеренно не является оптимальной для целей этого руководства.



## Создание начальной схемы

Поскольку таблица `posts` будет основной для большинства аналитических запросов, мы сосредоточимся на определении схемы именно для неё. Эти данные доступны в общедоступном S3‑бакете `s3://datasets-documentation/stackoverflow/parquet/posts/*.parquet`, по одному файлу на каждый год.

> Загрузка данных из S3 в формате Parquet является наиболее распространённым и предпочтительным способом загрузки данных в ClickHouse. ClickHouse оптимизирован для обработки Parquet и потенциально может считывать и вставлять десятки миллионов строк из S3 в секунду.

ClickHouse предоставляет возможность автоматического вывода схемы для определения типов в наборе данных. Это поддерживается для всех форматов данных, включая Parquet. Мы можем использовать эту функцию для определения типов ClickHouse для данных с помощью table function `s3` и команды [`DESCRIBE`](/sql-reference/statements/describe-table). Обратите внимание, что ниже мы используем glob‑шаблон `*.parquet` для чтения всех файлов в каталоге `stackoverflow/parquet/posts`.

```sql
DESCRIBE TABLE s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/posts/*.parquet')
SETTINGS describe_compact_output = 1

┌─name──────────────────┬─type───────────────────────────┐
│ Id                    │ Nullable(Int64)               │
│ PostTypeId            │ Nullable(Int64)               │
│ AcceptedAnswerId      │ Nullable(Int64)               │
│ CreationDate          │ Nullable(DateTime64(3, 'UTC')) │
│ Score                 │ Nullable(Int64)               │
│ ViewCount             │ Nullable(Int64)               │
│ Body                  │ Nullable(String)              │
│ OwnerUserId           │ Nullable(Int64)               │
│ OwnerDisplayName      │ Nullable(String)              │
│ LastEditorUserId      │ Nullable(Int64)               │
│ LastEditorDisplayName │ Nullable(String)              │
│ LastEditDate          │ Nullable(DateTime64(3, 'UTC')) │
│ LastActivityDate      │ Nullable(DateTime64(3, 'UTC')) │
│ Title                 │ Nullable(String)              │
│ Tags                  │ Nullable(String)              │
│ AnswerCount           │ Nullable(Int64)               │
│ CommentCount          │ Nullable(Int64)               │
│ FavoriteCount         │ Nullable(Int64)               │
│ ContentLicense        │ Nullable(String)              │
│ ParentId              │ Nullable(String)              │
│ CommunityOwnedDate    │ Nullable(DateTime64(3, 'UTC')) │
│ ClosedDate            │ Nullable(DateTime64(3, 'UTC')) │
└───────────────────────┴────────────────────────────────┘
```

> [Функция таблицы s3](/sql-reference/table-functions/s3) позволяет выполнять запросы к данным в S3 непосредственно из ClickHouse. Эта функция совместима со всеми форматами файлов, которые поддерживает ClickHouse.

Это дает нам исходную, не оптимизированную схему. По умолчанию ClickHouse отображает их в соответствующие типы Nullable. Мы можем создать таблицу ClickHouse, используя эти типы, с помощью простой команды `CREATE EMPTY AS SELECT`.

```sql
CREATE TABLE posts
ENGINE = MergeTree
ORDER BY () EMPTY AS
SELECT * FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/posts/*.parquet')
```

Несколько важных моментов:

Наша таблица `posts` пуста после выполнения этой команды. Данные не были загружены.
Мы указали `MergeTree` как движок таблицы. `MergeTree` — самый распространённый движок таблиц ClickHouse, который вы, скорее всего, будете использовать. Это многофункциональный инструмент в вашем арсенале ClickHouse, способный обрабатывать петабайты данных и подходящий для большинства аналитических сценариев. Существуют и другие движки таблиц для таких сценариев, как CDC (фиксация изменений данных), которым требуется эффективная поддержка обновлений.

Конструкция `ORDER BY ()` означает, что у нас нет индекса и, более конкретно, нет порядка в наших данных. Об этом позже. Пока достаточно знать, что все запросы будут требовать линейного сканирования.

Чтобы убедиться, что таблица была создана:

```sql
SHOW CREATE TABLE posts
```


CREATE TABLE posts
(
`Id` Nullable(Int64),
`PostTypeId` Nullable(Int64),
`AcceptedAnswerId` Nullable(Int64),
`CreationDate` Nullable(DateTime64(3, &#39;UTC&#39;)),
`Score` Nullable(Int64),
`ViewCount` Nullable(Int64),
`Body` Nullable(String),
`OwnerUserId` Nullable(Int64),
`OwnerDisplayName` Nullable(String),
`LastEditorUserId` Nullable(Int64),
`LastEditorDisplayName` Nullable(String),
`LastEditDate` Nullable(DateTime64(3, &#39;UTC&#39;)),
`LastActivityDate` Nullable(DateTime64(3, &#39;UTC&#39;)),
`Title` Nullable(String),
`Tags` Nullable(String),
`AnswerCount` Nullable(Int64),
`CommentCount` Nullable(Int64),
`FavoriteCount` Nullable(Int64),
`ContentLicense` Nullable(String),
`ParentId` Nullable(String),
`CommunityOwnedDate` Nullable(DateTime64(3, &#39;UTC&#39;)),
`ClosedDate` Nullable(DateTime64(3, &#39;UTC&#39;))
)
ENGINE = MergeTree(&#39;/clickhouse/tables/{uuid}/{shard}&#39;, &#39;{replica}&#39;)
ORDER BY tuple()

````

После определения начальной схемы можно заполнить таблицу данными с помощью `INSERT INTO SELECT`, считывая данные через табличную функцию s3. Следующий запрос загружает данные `posts` примерно за 2 минуты на 8-ядерном экземпляре ClickHouse Cloud.

```sql
INSERT INTO posts SELECT * FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/posts/*.parquet')

0 rows in set. Elapsed: 148.140 sec. Processed 59.82 million rows, 38.07 GB (403.80 thousand rows/s., 257.00 MB/s.)
````

> Приведённый выше запрос загружает 60 млн строк. Хотя это немного для ClickHouse, пользователи с более медленным интернет-соединением могут предпочесть загрузить лишь часть данных. Это можно сделать, просто указав годы, которые нужно загрузить, с помощью glob-шаблона, например `https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/posts/2008.parquet` или `https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/posts/{2008, 2009}.parquet`. Подробнее о том, как использовать glob-шаблоны для выбора подмножеств файлов, см. [здесь](/sql-reference/table-functions/file#globs-in-path).


## Оптимизация типов {#optimizing-types}

Один из секретов производительности запросов в ClickHouse — сжатие.

Меньший объём данных на диске означает меньше операций ввода-вывода (I/O), а значит, более быстрые запросы и вставки. Затраты любого алгоритма сжатия по CPU в большинстве случаев с лихвой компенсируются снижением I/O. Поэтому улучшение степени сжатия данных должно быть первым приоритетом при работе над ускорением запросов в ClickHouse.

> Почему ClickHouse так хорошо сжимает данные, рекомендуем прочитать в [этой статье](https://clickhouse.com/blog/optimize-clickhouse-codecs-compression-schema). Вкратце: как колоночная база данных, ClickHouse записывает значения по столбцам. Если эти значения отсортированы, одинаковые значения будут располагаться рядом. Алгоритмы сжатия используют непрерывные паттерны в данных. Помимо этого, в ClickHouse есть кодеки и более гранулярные типы данных, которые позволяют пользователям дополнительно настраивать технику сжатия.

На сжатие в ClickHouse влияют три основных фактора: ключ сортировки, типы данных и используемые кодеки. Все они настраиваются через схему.

Наибольшего первоначального улучшения по сжатию и производительности запросов можно добиться с помощью простого процесса оптимизации типов. Для оптимизации схемы можно применить несколько простых правил:

- **Используйте строгие типы** — В нашей исходной схеме для многих столбцов, которые явно являются числовыми, использовались типы String. Использование корректных типов гарантирует ожидаемую семантику при фильтрации и агрегации. То же относится и к типам дат, которые корректно заданы в файлах Parquet.
- **Избегайте nullable-столбцов** — По умолчанию вышеуказанные столбцы рассматривались как допускающие Null. Тип Nullable позволяет запросам определять разницу между пустым значением и Null. Для этого создаётся отдельный столбец типа UInt8. Этот дополнительный столбец должен обрабатываться каждый раз, когда пользователь работает с nullable-столбцом. Это приводит к дополнительным затратам по месту хранения и почти всегда негативно влияет на производительность запросов. Используйте Nullable только в том случае, если существует разница между стандартным пустым значением для типа и Null. Например, значение 0 для пустых значений в столбце `ViewCount` скорее всего будет достаточно для большинства запросов и не повлияет на результаты. Если пустые значения должны обрабатываться по‑другому, их часто можно просто исключить из запросов с помощью фильтра.
- **Используйте минимально необходимую точность для числовых типов** — В ClickHouse есть несколько числовых типов, рассчитанных на разные диапазоны значений и точность. Всегда стремитесь минимизировать количество бит, используемых для представления столбца. Помимо целых чисел разного размера, например Int16, ClickHouse предлагает беззнаковые варианты, у которых минимальное значение равно 0. Это позволяет использовать меньше бит для столбца, например, максимальное значение для UInt16 — 65535, что вдвое больше, чем у Int16. По возможности отдавайте предпочтение таким типам вместо более крупных знаковых вариантов.
- **Минимальная требуемая точность для типов дат** — ClickHouse поддерживает несколько типов дат и дат-времени. Date и Date32 можно использовать для хранения чистых дат, при этом Date32 поддерживает больший диапазон значений дат за счёт большего количества бит. DateTime и DateTime64 обеспечивают поддержку дата-время. DateTime ограничен точностью до секунды и использует 32 бита. DateTime64, как следует из названия, использует 64 бита, но поддерживает точность до наносекунд. Как и всегда, выбирайте максимально грубую гранулярность, которая приемлема для ваших запросов, минимизируя количество бит, необходимых для хранения.
- **Используйте LowCardinality** — Числовые, строковые, Date- или DateTime-столбцы с небольшим количеством уникальных значений могут быть закодированы с помощью типа LowCardinality. Этот тип использует словарное кодирование значений, уменьшая размер данных на диске. Рассматривайте его применение для столбцов с менее чем 10k уникальных значений.
- **FixedString для особых случаев** — Строки фиксированной длины могут быть закодированы с помощью типа FixedString, например коды языка и валют. Это эффективно, когда длина данных составляет ровно N байт. Во всех остальных случаях это, скорее всего, снизит эффективность, и предпочтительнее использовать LowCardinality.
- **Enum для валидации данных** — Тип Enum можно использовать для эффективного кодирования перечислимых типов. Enum может занимать 8 или 16 бит, в зависимости от количества уникальных значений, которые требуется хранить. Рассмотрите его использование, если вам нужна либо встроенная валидация при вставке (недекларированные значения будут отвергнуты), либо вы хотите выполнять запросы, использующие естественный порядок значений Enum, например представьте столбец с обратной связью пользователей `Enum(':(' = 1, ':|' = 2, ':)' = 3)`.

> Совет: чтобы найти диапазон значений всех столбцов и количество различных значений, пользователи могут выполнить простой запрос `SELECT * APPLY min, * APPLY  max, * APPLY uniq FROM table FORMAT Vertical`. Рекомендуем выполнять его над небольшим подмножеством данных, так как он может быть дорогим. Для корректного результата в этом запросе числовые значения должны быть как минимум определены как числовые типы, а не как String.

Применяя эти простые правила к нашей таблице posts, мы можем определить оптимальный тип для каждого столбца:



| Столбец                 | Является числом | Минимум, Максимум                                            | Уникальные значения | Значения NULL | Комментарий                                                                                                                 | Оптимизированный тип                                                                                                                                         |
| ----------------------- | --------------- | ------------------------------------------------------------ | ------------------- | ------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `PostTypeId`            | Да              | 1, 8                                                         | 8                   | Нет           |                                                                                                                             | `Enum('Question' = 1, 'Answer' = 2, 'Wiki' = 3, 'TagWikiExcerpt' = 4, 'TagWiki' = 5, 'ModeratorNomination' = 6, 'WikiPlaceholder' = 7, 'PrivilegeWiki' = 8)` |
| `AcceptedAnswerId`      | Да              | 0, 78285170                                                  | 12282094            | Да            | Отличать NULL от значения 0                                                                                                 | UInt32                                                                                                                                                       |
| `CreationDate`          | Нет             | 2008-07-31 21:42:52.667000000, 2024-03-31 23:59:17.697000000 | *                   | Нет           | Точность до миллисекунд не требуется, используйте DateTime                                                                  | DateTime                                                                                                                                                     |
| `Score`                 | Да              | -217, 34970                                                  | 3236                | Нет           |                                                                                                                             | Int32                                                                                                                                                        |
| `ViewCount`             | Да              | 2, 13962748                                                  | 170867              | Нет           |                                                                                                                             | UInt32                                                                                                                                                       |
| `Тело`                  | Нет             | -                                                            | *                   | Нет           |                                                                                                                             | Строка                                                                                                                                                       |
| `OwnerUserId`           | Да              | -1, 4056915                                                  | 6256237             | Да            |                                                                                                                             | Int32                                                                                                                                                        |
| `OwnerDisplayName`      | Нет             | -                                                            | 181251              | Да            | Рассматривать NULL как пустую строку                                                                                        | String                                                                                                                                                       |
| `LastEditorUserId`      | Да              | -1, 9999993                                                  | 1104694             | Да            | 0 — неиспользуемое значение, которое можно использовать для обозначения Null                                                | Int32                                                                                                                                                        |
| `LastEditorDisplayName` | Нет             | *                                                            | 70952               | Да            | Следует считать значение Null пустой строкой. Мы протестировали LowCardinality — выгоды нет.                                | String                                                                                                                                                       |
| `LastEditDate`          | Нет             | 2008-08-01 13:24:35.051000000, 2024-04-06 21:01:22.697000000 | -                   | Нет           | Если точность до миллисекунд не требуется, используйте DateTime                                                             | DateTime                                                                                                                                                     |
| `LastActivityDate`      | Нет             | 2008-08-01 12:19:17.417000000, 2024-04-06 21:01:22.697000000 | *                   | Нет           | Если не требуется точность до миллисекунд, используйте DateTime                                                             | DateTime                                                                                                                                                     |
| `Title`                 | Нет             | -                                                            | *                   | Нет           | Рассматривать NULL как пустую строку                                                                                        | String                                                                                                                                                       |
| `Теги`                  | Нет             | -                                                            | *                   | Нет           | Рассматривать значение Null как пустую строку                                                                               | Строка                                                                                                                                                       |
| `AnswerCount`           | Да              | 0, 518                                                       | 216                 | Нет           | Считать Null и 0 одинаковыми                                                                                                | UInt16                                                                                                                                                       |
| `CommentCount`          | Да              | 0, 135                                                       | 100                 | Нет           | Считать NULL и 0 равнозначными                                                                                              | UInt8                                                                                                                                                        |
| `FavoriteCount`         | Да              | 0, 225                                                       | 6                   | Да            | Считать значения Null и 0 равнозначными                                                                                     | UInt8                                                                                                                                                        |
| `ContentLicense`        | Нет             | -                                                            | 3                   | Нет           | LowCardinality превосходит FixedString по производительности                                                                | LowCardinality(String)                                                                                                                                       |
| `ParentId`              | Нет             | *                                                            | 20696028            | Да            | Считать Null пустой строкой                                                                                                 | Строка                                                                                                                                                       |
| `CommunityOwnedDate`    | Нет             | 2008-08-12 04:59:35.017000000, 2024-04-01 05:36:41.380000000 | -                   | Да            | Используйте значение по умолчанию 1970-01-01 для значений NULL. Точность до миллисекунд не требуется, используйте DateTime. | DateTime                                                                                                                                                     |
| `ClosedDate`            | Нет             | 2008-09-04 20:56:44, 2024-04-06 18:49:25.393000000           | *                   | Да            | Используйте значение по умолчанию 1970-01-01 для значений NULL. Миллисекундная точность не требуется — используйте DateTime | DateTime                                                                                                                                                     |

<br />

В итоге получаем следующую схему:

```sql
CREATE TABLE posts_v2
(
   `Id` Int32,
   `PostTypeId` Enum('Question' = 1, 'Answer' = 2, 'Wiki' = 3, 'TagWikiExcerpt' = 4, 'TagWiki' = 5, 'ModeratorNomination' = 6, 'WikiPlaceholder' = 7, 'PrivilegeWiki' = 8),
   `AcceptedAnswerId` UInt32,
   `CreationDate` DateTime,
   `Score` Int32,
   `ViewCount` UInt32,
   `Body` String,
   `OwnerUserId` Int32,
   `OwnerDisplayName` String,
   `LastEditorUserId` Int32,
   `LastEditorDisplayName` String,
   `LastEditDate` DateTime,
   `LastActivityDate` DateTime,
   `Title` String,
   `Tags` String,
   `AnswerCount` UInt16,
   `CommentCount` UInt8,
   `FavoriteCount` UInt8,
   `ContentLicense`LowCardinality(String),
   `ParentId` String,
   `CommunityOwnedDate` DateTime,
   `ClosedDate` DateTime
)
ENGINE = MergeTree
ORDER BY tuple()
COMMENT 'Оптимизированные типы'
```

Мы можем заполнить эту таблицу с помощью простого запроса `INSERT INTO SELECT`, прочитав данные из нашей предыдущей таблицы и вставив их в эту:

```sql
INSERT INTO posts_v2 SELECT * FROM posts

0 строк в наборе. Прошло: 146.471 сек. Обработано 59.82 млн строк, 83.82 ГБ (408.40 тыс. строк/с., 572.25 МБ/с.)
```

Мы не сохраняем никаких значений `null` в нашей новой схеме. Приведённая выше операция вставки неявно преобразует их в значения по умолчанию для соответствующих типов — 0 для целых чисел и пустое значение для строк. ClickHouse также автоматически приводит любые числовые значения к их целевой точности.
Primary (Ordering) Keys в ClickHouse
Пользователи, приходящие из OLTP-баз данных, часто ищут эквивалентный механизм в ClickHouse.


## Выбор ключа сортировки

В масштабах, в которых часто используется ClickHouse, эффективность использования памяти и диска имеет первостепенное значение. Данные записываются в таблицы ClickHouse блоками, называемыми частями (parts), к которым в фоновом режиме применяются правила слияния. В ClickHouse у каждой части есть свой собственный первичный индекс. Когда части сливаются, первичные индексы результирующей части также сливаются. Первичный индекс для части содержит одну запись индекса на группу строк — этот подход называется разреженным индексированием (sparse indexing).

<Image img={schemaDesignIndices} size="md" alt="Sparse Indexing in ClickHouse" />

Выбранный ключ в ClickHouse будет определять не только индекс, но и порядок, в котором данные записываются на диск. Из‑за этого он может существенно влиять на уровень сжатия, что, в свою очередь, влияет на производительность запросов. Ключ сортировки, который приводит к тому, что значения большинства столбцов записываются в последовательном порядке, позволит выбранному алгоритму сжатия (и кодекам) более эффективно сжимать данные.

> Все столбцы в таблице будут отсортированы на основе значения указанного ключа сортировки, независимо от того, включены ли они в сам ключ. Например, если в качестве ключа используется `CreationDate`, порядок значений во всех остальных столбцах будет соответствовать порядку значений в столбце `CreationDate`. Можно указать несколько ключей сортировки — сортировка будет выполняться с той же семантикой, что и в предложении `ORDER BY` запроса `SELECT`.

Можно применить несколько простых правил, чтобы помочь выбрать ключ сортировки. Следующие правила иногда могут конфликтовать, поэтому учитывайте их по порядку. Пользователи могут определить несколько ключей в результате этого процесса, при этом обычно достаточно 4–5:

* Выбирайте столбцы, которые соответствуют вашим типичным фильтрам. Если столбец часто используется в предложениях `WHERE`, включайте его в ключ с более высоким приоритетом по сравнению с теми, которые используются реже.
  Предпочтительнее столбцы, которые при фильтрации позволяют исключить большой процент от общего числа строк, тем самым уменьшая объем данных, которые необходимо прочитать.
* Предпочитайте столбцы, которые, скорее всего, будут сильно коррелировать с другими столбцами в таблице. Это поможет обеспечить также последовательное хранение этих значений, улучшая сжатие.
  Операции `GROUP BY` и `ORDER BY` для столбцов, входящих в ключ сортировки, могут выполняться более эффективно по памяти.

При выборе подмножества столбцов для ключа сортировки указывайте столбцы в определенном порядке. Этот порядок может существенно повлиять как на эффективность фильтрации по столбцам вторичного ключа в запросах, так и на коэффициент сжатия файлов данных таблицы. В общем случае лучше располагать ключи в порядке возрастания их кардинальности. Это следует сбалансировать с тем фактом, что фильтрация по столбцам, которые находятся позже в ключе сортировки, будет менее эффективной, чем по тем, которые находятся раньше в кортеже. Сбалансируйте эти эффекты и учитывайте ваши паттерны доступа (и самое важное — тестируйте варианты).

### Пример

Применяя приведенные выше рекомендации к нашей таблице `posts`, предположим, что пользователи хотят выполнять аналитику с фильтрацией по дате и типу поста, например:

«Какие вопросы получили больше всего комментариев за последние 3 месяца».

Запрос для этого вопроса, использующий нашу предыдущую таблицу `posts_v2` с оптимизированными типами, но без ключа сортировки:

```sql
SELECT
    Id,
    Title,
    CommentCount
FROM posts_v2
WHERE (CreationDate >= '2024-01-01') AND (PostTypeId = 'Question')
ORDER BY CommentCount DESC
LIMIT 3

┌───────Id─┬─Title─────────────────────────────────────────────────────────────┬─CommentCount─┐
│ 78203063 │ Как избежать инициализации объектов по умолчанию в std::vector?   │               74 │
│ 78183948 │ О барьере памяти                                                  │               52 │
│ 77900279 │ Тест скорости выравнивания буфера: результаты IBM PowerPC по сравнению с моим CPU │        49 │
└──────────┴───────────────────────────────────────────────────────────────────┴──────────────

10 строк в наборе. Прошло: 0.070 с. Обработано 59.82 миллиона строк, 569.21 МБ (852.55 миллиона строк/с, 8.11 ГБ/с.)
Пиковое потребление памяти: 429.38 MiB.
```

> Этот запрос выполняется очень быстро, даже несмотря на то, что все 60 млн строк были просканированы линейно — ClickHouse просто быстрый :) Поверьте нам, задание ключей сортировки того стоит на масштабах терабайтов и петабайтов!

Давайте выберем столбцы `PostTypeId` и `CreationDate` в качестве наших ключей сортировки.


Возможно, в нашем случае мы рассчитываем, что пользователи всегда будут фильтровать по `PostTypeId`. Его кардинальность равна 8, и это логичный выбор для первого элемента в нашем ключе сортировки. Учитывая, что фильтрации по дате с нужной гранулярностью, вероятно, будет достаточно (она по-прежнему будет полезна и для фильтров по datetime), мы используем `toDate(CreationDate)` как 2-й компонент нашего ключа. Это также приведёт к меньшему индексу, поскольку дату можно представить 16-битным числом, что ускорит фильтрацию. Последний элемент ключа — `CommentCount`, чтобы упростить поиск наиболее комментируемых постов (окончательная сортировка).

```sql
CREATE TABLE posts_v3
(
        `Id` Int32,
        `PostTypeId` Enum('Question' = 1, 'Answer' = 2, 'Wiki' = 3, 'TagWikiExcerpt' = 4, 'TagWiki' = 5, 'ModeratorNomination' = 6, 'WikiPlaceholder' = 7, 'PrivilegeWiki' = 8),
        `AcceptedAnswerId` UInt32,
        `CreationDate` DateTime,
        `Score` Int32,
        `ViewCount` UInt32,
        `Body` String,
        `OwnerUserId` Int32,
        `OwnerDisplayName` String,
        `LastEditorUserId` Int32,
        `LastEditorDisplayName` String,
        `LastEditDate` DateTime,
        `LastActivityDate` DateTime,
        `Title` String,
        `Tags` String,
        `AnswerCount` UInt16,
        `CommentCount` UInt8,
        `FavoriteCount` UInt8,
        `ContentLicense` LowCardinality(String),
        `ParentId` String,
        `CommunityOwnedDate` DateTime,
        `ClosedDate` DateTime
)
ENGINE = MergeTree
ORDER BY (PostTypeId, toDate(CreationDate), CommentCount)
COMMENT 'Ключ упорядочивания'

--заполнение таблицы из существующей таблицы

INSERT INTO posts_v3 SELECT * FROM posts_v2

Выбрано 0 строк. Затрачено: 158.074 сек. Обработано 59.82 млн строк, 76.21 ГБ (378.42 тыс. строк/с., 482.14 МБ/с.)
Пиковое использование памяти: 6.41 ГиБ.

Данный запрос улучшает время отклика более чем в 3 раза:

SELECT
    Id,
    Title,
    CommentCount
FROM posts_v3
WHERE (CreationDate >= '2024-01-01') AND (PostTypeId = 'Question')
ORDER BY CommentCount DESC
LIMIT 3

Выбрано 10 строк. Затрачено: 0.020 сек. Обработано 290.09 тыс. строк, 21.03 МБ (14.65 млн строк/с., 1.06 ГБ/с.)
```

Пользователи, которых интересуют улучшения сжатия, достигаемые за счёт использования определённых типов и правильных ключей упорядочивания, могут ознакомиться с разделом [Сжатие в ClickHouse](/data-compression/compression-in-clickhouse). Если необходимо ещё больше улучшить сжатие, мы также рекомендуем раздел [Выбор подходящего кодека сжатия для столбца](/data-compression/compression-in-clickhouse#choosing-the-right-column-compression-codec).


## Далее: техники моделирования данных {#next-data-modeling-techniques}

До сих пор мы мигрировали только одну таблицу. Хотя это позволило нам ввести несколько основных концепций ClickHouse, большинство схем, к сожалению, не настолько просты.

В других руководствах, перечисленных ниже, мы рассмотрим ряд техник по реструктуризации более широкой схемы данных для оптимальных запросов в ClickHouse. На протяжении этого процесса мы стремимся к тому, чтобы `Posts` оставалась нашей центральной таблицей, через которую выполняется большинство аналитических запросов. Хотя к другим таблицам по‑прежнему можно обращаться изолированно, мы предполагаем, что основная часть аналитики будет выполняться в контексте `Posts`.

> В этом разделе мы используем оптимизированные варианты остальных наших таблиц. Хотя мы приводим их схемы, ради краткости мы опускаем обоснование принятых решений. Они основаны на правилах, описанных ранее, а вывод этих решений мы оставляем на усмотрение читателя.

Все указанные ниже подходы нацелены на минимизацию необходимости использования JOIN для оптимизации чтения и повышения производительности запросов. Хотя операции JOIN полностью поддерживаются в ClickHouse, мы рекомендуем использовать их умеренно (JOIN‑запросов с 2–3 таблицами достаточно), чтобы обеспечить оптимальную производительность.

> В ClickHouse нет понятия внешних ключей. Это не запрещает выполнение JOIN, но означает, что управление ссылочной целостностью возлагается на пользователя на уровне приложения. В OLAP‑системах, таких как ClickHouse, целостность данных часто обеспечивается на уровне приложения или в процессе ингестии данных, а не принудительно контролируется самой базой данных, где это влечёт значительные накладные расходы. Такой подход обеспечивает большую гибкость и более быструю вставку данных. Это соответствует фокусу ClickHouse на скорость и масштабируемость запросов на чтение и вставку для очень больших наборов данных.

Чтобы минимизировать использование JOIN во время выполнения запроса, у пользователей есть несколько инструментов и подходов:

- [**Денормализация данных**](/data-modeling/denormalization) — денормализуйте данные путём объединения таблиц и использования сложных типов для отношений, отличных от связи 1:1. Часто это включает перенос всех необходимых JOIN‑операций с момента выполнения запроса на момент вставки.
- [**Dictionaries**](/dictionary) — специфичная для ClickHouse функциональность для обработки прямых JOIN и поиска по ключу.
- [**Incremental Materialized Views**](/materialized-view/incremental-materialized-view) — функциональность ClickHouse для переноса стоимости вычислений с момента выполнения запроса на момент вставки, включая возможность инкрементального вычисления агрегированных значений.
- [**Refreshable Materialized Views**](/materialized-view/refreshable-materialized-view) — аналогично материализованным представлениям, используемым в других СУБД, позволяет периодически вычислять результаты запроса и кэшировать результат.

Мы рассматриваем каждый из этих подходов в отдельных руководствах, показывая, когда каждый из них уместен, с примером того, как его можно применить для решения задач по набору данных Stack Overflow.

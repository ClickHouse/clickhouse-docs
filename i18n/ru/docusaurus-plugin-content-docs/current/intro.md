---
slug: /intro
sidebar_label: 'Что такое ClickHouse?'
description: 'ClickHouse® — это столбцовая система управления базами данных (СУБД) SQL для онлайн-аналитической обработки (OLAP). Она доступна как в виде программного обеспечения с открытым исходным кодом, так и в виде облачного сервиса.'
title: 'Что такое ClickHouse?'
keywords: ['ClickHouse', 'столбцовая база данных', 'OLAP-база данных', 'аналитическая база данных', 'высокопроизводительная база данных']
doc_type: 'guide'
---

import column_example from '@site/static/images/column-oriented-example-query.png';
import row_orientated from '@site/static/images/row-oriented.gif';
import column_orientated from '@site/static/images/column-oriented.gif';
import Image from '@theme/IdealImage';

ClickHouse® — высокопроизводительная колоночная система управления базами данных (СУБД) SQL для онлайн-аналитической обработки (OLAP). Она доступна как в виде [программного обеспечения с открытым исходным кодом](https://github.com/ClickHouse/ClickHouse), так и как [облачный сервис](https://clickhouse.com/cloud).


## Что такое аналитика? {#what-are-analytics}

Аналитика, также известная как OLAP (Online Analytical Processing), — это SQL‑запросы со сложными вычислениями (например, агрегациями, обработкой строк, арифметикой) по очень большим наборам данных.

В отличие от транзакционных запросов (или OLTP, Online Transaction Processing), которые читают и записывают всего несколько строк за запрос и поэтому выполняются за миллисекунды, аналитические запросы обычно обрабатывают миллиарды и триллионы строк.

Во многих вариантах использования [аналитические запросы должны выполняться в режиме реального времени](https://clickhouse.com/engineering-resources/what-is-real-time-analytics), то есть возвращать результат за время менее одной секунды.



## Построчное и колоночное хранение данных

Такой уровень производительности достигается только при правильной «ориентации» данных.

Базы данных хранят данные либо [построчно, либо по столбцам](https://clickhouse.com/engineering-resources/what-is-columnar-database).

В построчной базе данных последовательные строки таблицы хранятся одна за другой. Такое расположение позволяет быстро получать строки, так как значения всех столбцов одной строки хранятся вместе.

ClickHouse — это колоночная база данных. В таких системах таблицы хранятся как набор столбцов, то есть значения каждого столбца располагаются последовательно одно за другим. Это затрудняет восстановление отдельных строк (так как между значениями строк появляются разрывы), но операции над столбцами, такие как фильтрация или агрегация, становятся значительно быстрее, чем в построчной базе данных.

Различие лучше всего проиллюстрировать на примере запроса, выполняемого по 100 миллионам строк [реальных анонимизированных данных веб-аналитики](/getting-started/example-datasets/metrica):

```sql
SELECT MobilePhoneModel, COUNT() AS c
FROM metrica.hits
WHERE
      RegionID = 229
  AND EventDate >= '2013-07-01'
  AND EventDate <= '2013-07-31'
  AND MobilePhone != 0
  AND MobilePhoneModel not in ['', 'iPad']
GROUP BY MobilePhoneModel
ORDER BY c DESC
LIMIT 8;
```

Вы можете [запустить этот запрос в ClickHouse SQL Playground](https://sql.clickhouse.com?query=U0VMRUNUIE1vYmlsZVBob25lTW9kZWwsIENPVU5UKCkgQVMgYyAKRlJPTSBtZXRyaWNhLmhpdHMgCldIRVJFIAogICAgICBSZWdpb25JRCA9IDIyOSAKICBBTkQgRXZlbnREYXRlID49ICcyMDEzLTA3LTAxJyAKICBBTkQgRXZlbnREYXRlIDw9ICcyMDEzLTA3LTMxJyAKICBBTkQgTW9iaWxlUGhvbmUgIT0gMCAKICBBTkQgTW9iaWxlUGhvbmVNb2RlbCBub3QgaW4gWycnLCAnaVBhZCddIApHUk9VUCBCWSBNb2JpbGVQaG9uZU1vZGVsCk9SREVSIEJZIGMgREVTQyAKTElNSVQgODs\&chart=eyJ0eXBlIjoicGllIiwiY29uZmlnIjp7InhheGlzIjoiTW9iaWxlUGhvbmVNb2RlbCIsInlheGlzIjoiYyJ9fQ\&run_query=true), который выбирает и фильтрует [лишь несколько из более чем 100](https://sql.clickhouse.com/?query=U0VMRUNUIG5hbWUKRlJPTSBzeXN0ZW0uY29sdW1ucwpXSEVSRSBkYXRhYmFzZSA9ICdtZXRyaWNhJyBBTkQgdGFibGUgPSAnaGl0cyc7\&tab=results\&run_query=true) существующих столбцов и возвращает результат за миллисекунды:

<Image img={column_example} alt="Пример запроса в колонко-ориентированной базе данных" size="lg" />

Как видно из раздела статистики на диаграмме выше, запрос обработал 100 миллионов строк за 92 миллисекунды, что соответствует пропускной способности примерно чуть более 1 миллиарда строк в секунду или чуть менее 7 ГБ переданных данных в секунду.

**Строко-ориентированная СУБД**

В строко-ориентированной базе данных, даже если приведенный выше запрос обрабатывает только несколько столбцов из существующих, системе все равно необходимо загрузить данные из других существующих столбцов с диска в память. Причина в том, что данные хранятся на диске в фрагментах, называемых [блоками](https://en.wikipedia.org/wiki/Block_\(data_storage\)) (обычно фиксированного размера, например 4 КБ или 8 КБ). Блоки — это наименьшие единицы данных, считываемые с диска в память. Когда приложение или база данных запрашивает данные, подсистема дискового ввода-вывода операционной системы считывает необходимые блоки с диска. Даже если нужна только часть блока, весь блок целиком считывается в память (это связано с устройством дисков и файловых систем):

<Image img={row_orientated} alt="Структура строко-ориентированной базы данных" size="lg" />

**Колонко-ориентированная СУБД**


Поскольку значения каждого столбца хранятся на диске последовательно друг за другом, при выполнении приведённого выше запроса не загружаются лишние данные.
Поскольку блочное хранение и передача данных с диска в память соответствуют характеру доступа к данным в аналитических запросах, с диска читаются только те столбцы, которые требуются для запроса, что позволяет избежать лишних операций ввода-вывода для неиспользуемых данных. Это [намного быстрее](https://benchmark.clickhouse.com/) по сравнению со строчно-ориентированным хранением, при котором считываются целые строки (включая столбцы, не относящиеся к запросу):

<Image img={column_orientated} alt="Структура столбцово-ориентированной базы данных" size="lg"/>



## Репликация данных и их целостность {#data-replication-and-integrity}

ClickHouse использует асинхронную мультимастерную схему репликации, чтобы обеспечивать избыточное хранение данных на нескольких узлах. После записи на любую доступную реплику все остальные реплики в фоновом режиме получают свою копию. Система поддерживает одинаковое состояние данных на разных репликах. Восстановление после большинства сбоев выполняется автоматически или полуавтоматически в более сложных случаях.



## Ролевое управление доступом {#role-based-access-control}

ClickHouse реализует управление учетными записями пользователей посредством SQL‑запросов и позволяет настраивать ролевое управление доступом, аналогичное описанному в стандарте ANSI SQL и реализованному в популярных системах управления реляционными базами данных.



## Поддержка SQL {#sql-support}

ClickHouse поддерживает [декларативный язык запросов, основанный на SQL](/sql-reference), который во многих случаях соответствует стандарту ANSI SQL. Поддерживаемые конструкции запросов включают [GROUP BY](/sql-reference/statements/select/group-by), [ORDER BY](/sql-reference/statements/select/order-by), подзапросы в секции [FROM](/sql-reference/statements/select/from), конструкцию [JOIN](/sql-reference/statements/select/join), оператор [IN](/sql-reference/operators/in), [оконные функции](/sql-reference/window-functions) и скалярные подзапросы.



## Приблизительный расчет {#approximate-calculation}

ClickHouse предоставляет возможности пожертвовать точностью ради производительности. Например, некоторые его агрегатные функции вычисляют приблизительное количество различных значений, медиану и квантили. Кроме того, запросы можно выполнять по выборке данных, чтобы быстро получить приблизительный результат. Наконец, агрегацию можно выполнять с ограниченным числом ключей вместо всех ключей. В зависимости от того, насколько смещено распределение ключей, это может дать достаточно точный результат при существенно меньших затратах ресурсов по сравнению с точным расчетом.



## Адаптивные алгоритмы соединения {#adaptive-join-algorithms}

ClickHouse адаптивно выбирает алгоритм соединения: он начинает с быстрых хеш‑соединений и переходит к merge‑соединениям, если в запросе участвует более одной крупной таблицы.



## Высочайшая производительность запросов {#superior-query-performance}

ClickHouse широко известен своей исключительно высокой скоростью выполнения запросов.
Чтобы узнать, почему ClickHouse такой быстрый, см. руководство [Why is ClickHouse fast?](/concepts/why-clickhouse-is-so-fast.mdx).



<!--
## Что такое OLAP? {#what-is-olap}
Сценарии OLAP требуют получения ответов в режиме реального времени на основе больших наборов данных для сложных аналитических запросов со следующими характеристиками:
- Наборы данных могут быть огромными — миллиарды или триллионы строк
- Данные организованы в таблицы, содержащие множество столбцов
- Для ответа на конкретный запрос выбирается только несколько столбцов
- Результаты должны возвращаться за миллисекунды или секунды




## Колонко-ориентированные и строко-ориентированные базы данных {#column-oriented-vs-row-oriented-databases}
В строко-ориентированной СУБД данные хранятся по строкам, при этом все значения, относящиеся к одной строке, физически располагаются рядом.

В колонко-ориентированной СУБД данные хранятся по столбцам, причем значения одного столбца хранятся вместе.



## Почему колоночные базы данных лучше работают в OLAP-сценариях {#why-column-oriented-databases-work-better-in-the-olap-scenario}

Колоночные базы данных лучше подходят для OLAP-сценариев: они по крайней мере в 100 раз быстрее обрабатывают большинство запросов. Причины подробно рассматриваются ниже, но этот факт проще всего продемонстрировать наглядно:

Видите разницу?

Далее в статье объясняется, почему колоночные базы данных так хорошо работают в этих сценариях и почему именно ClickHouse [опережает по производительности](/concepts/why-clickhouse-is-so-fast/concepts/why-clickhouse-is-so-fast#storage-layer-concurrent-inserts-and-selects-are-isolated) другие решения в этой категории.



## Почему ClickHouse настолько быстр? {#why-is-clickhouse-so-fast}

ClickHouse задействует все доступные системные ресурсы в полной мере, чтобы обрабатывать каждый аналитический запрос как можно быстрее. Это достигается благодаря уникальному сочетанию аналитических возможностей и тщательному вниманию к низкоуровневым деталям, необходимым для реализации самой быстрой OLAP-СУБД.

Полезные материалы для более глубокого изучения этой темы:
- [Производительность ClickHouse](/concepts/why-clickhouse-is-so-fast)
- [Отличительные особенности ClickHouse](/about-us/distinctive-features.md)
- [FAQ: Почему ClickHouse настолько быстр?](/knowledgebase/why-clickhouse-is-so-fast)



## Обработка аналитических запросов в реальном времени {#processing-analytical-queries-in-real-time}

В строково-ориентированной СУБД данные хранятся в следующем порядке:

| Строка | WatchID     | JavaEnable | Title                | GoodEvent | EventTime           |
|--------|-------------|------------|----------------------|-----------|---------------------|
| #0     | 89354350662 | 1          | Investor Relations   | 1         | 2016-05-18 05:19:20 |
| #1     | 90329509958 | 0          | Contact us           | 1         | 2016-05-18 08:10:20 |
| #2     | 89953706054 | 1          | Mission              | 1         | 2016-05-18 07:38:00 |
| #N     | ...         | ...        | ...                  | ...       | ...                 |

Другими словами, все значения, относящиеся к одной строке, физически хранятся рядом друг с другом.

Примеры строково-ориентированных СУБД: MySQL, Postgres и MS SQL Server.

В столбцово-ориентированной СУБД данные хранятся так:

| Строка:     | #0                  | #1                  | #2                  | #N  |
|-------------|---------------------|---------------------|---------------------|-----|
| WatchID:    | 89354350662         | 90329509958         | 89953706054         | ... |
| JavaEnable: | 1                   | 0                   | 1                   | ... |
| Title:      | Investor Relations  | Contact us          | Mission             | ... |
| GoodEvent:  | 1                   | 1                   | 1                   | ... |
| EventTime:  | 2016-05-18 05:19:20 | 2016-05-18 08:10:20 | 2016-05-18 07:38:00 | ... |

Эти примеры показывают только порядок, в котором расположены данные. Значения из разных столбцов хранятся отдельно, а данные из одного и того же столбца хранятся вместе.

Примеры столбцово-ориентированных СУБД: Vertica, Paraccel (Actian Matrix и Amazon Redshift), Sybase IQ, Exasol, Infobright, InfiniDB, MonetDB (VectorWise и Actian Vector), LucidDB, SAP HANA, Google Dremel, Google PowerDrill, Druid и kdb+.

Разные порядки хранения данных лучше подходят для разных сценариев. Под сценарием доступа к данным подразумевается, какие запросы выполняются, как часто и в каких соотношениях; сколько данных читается для каждого типа запроса — строк, столбцов и байт; соотношение между чтением и обновлением данных; рабочий объем данных и то, насколько локально они используются; используются ли транзакции и насколько они изолированы; требования к репликации данных и логической целостности; требования к задержкам и пропускной способности для каждого типа запроса и т. д.

Чем выше нагрузка на систему, тем важнее настроить систему в соответствии с требованиями сценария использования и тем более детальной становится эта настройка. Не существует системы, одинаково хорошо подходящей для существенно разных сценариев. Если система адаптирована к широкому набору сценариев, то при высокой нагрузке она будет обрабатывать все сценарии одинаково плохо или будет хорошо работать только для одного или немногих возможных сценариев.

### Ключевые свойства OLAP-сценария {#key-properties-of-olap-scenario}

- Таблицы «широкие», то есть содержат большое количество столбцов.
- Наборы данных большие, и запросы требуют высокой пропускной способности при обработке одного запроса (до миллиардов строк в секунду на сервер).
- Значения в столбцах достаточно маленькие: числа и короткие строки (например, 60 байт на URL).
- Запросы извлекают большое количество строк, но только небольшой поднабор столбцов.
- Для простых запросов допускаются задержки порядка 50 мс.
- В каждом запросе участвует одна большая таблица; все остальные таблицы маленькие.
- Результат запроса значительно меньше исходных данных. Другими словами, данные фильтруются или агрегируются так, что результат помещается в оперативную память одного сервера.
- Запросы относительно редки (обычно сотни запросов в секунду на сервер или меньше).
- Вставки выполняются достаточно крупными пакетами (\> 1000 строк), а не по одной строке.
- Транзакции не нужны.

Легко заметить, что OLAP-сценарий сильно отличается от других популярных сценариев (таких как OLTP или Key-Value-доступ). Поэтому не имеет смысла пытаться использовать OLTP- или Key-Value-СУБД для обработки аналитических запросов, если вы хотите получить приемлемую производительность. Например, если вы попытаетесь использовать MongoDB или Redis для аналитики, вы получите очень низкую производительность по сравнению с OLAP-базами данных.



### Ввод/вывод {#inputoutput}

1.  Для аналитического запроса требуется прочитать только небольшое количество столбцов таблицы. В столбцовой базе данных можно читать только те данные, которые нужны. Например, если вам нужно 5 столбцов из 100, можно ожидать 20-кратное уменьшение объёма операций ввода-вывода (I/O).
2.  Поскольку данные читаются пакетами, их легче сжимать. Данные в столбцах также легче сжимать. Это ещё больше снижает объём I/O.
3.  За счёт уменьшения I/O в системный кэш помещается больше данных.

Например, запрос «подсчитать число записей по каждой рекламной площадке» требует чтения только одного столбца «идентификатор рекламной площадки», который занимает 1 байт в несжатом виде. Если основной трафик был не с рекламных площадок, можно ожидать как минимум 10-кратное сжатие этого столбца. При использовании быстрого алгоритма сжатия распаковка данных возможна со скоростью не менее нескольких гигабайт несжатых данных в секунду. Другими словами, такой запрос может обрабатываться со скоростью порядка нескольких миллиардов строк в секунду на одном сервере. Такая скорость действительно достигается на практике.

### CPU {#cpu}

Поскольку выполнение запроса требует обработки большого числа строк, полезно выполнять все операции сразу над целыми векторами, а не над отдельными строками, либо реализовать движок запросов так, чтобы накладные расходы на диспетчеризацию были практически нулевыми. Если этого не сделать, при любой сколько-нибудь приличной дисковой подсистеме интерпретатор запросов неизбежно станет узким местом и будет простаивать CPU. Имеет смысл как хранить данные по столбцам, так и по возможности обрабатывать их по столбцам.

Сделать это можно двумя способами:

1.  Векторный движок. Все операции пишутся для векторов, а не для отдельных значений. Это означает, что операции не нужно вызывать очень часто, и затраты на диспетчеризацию пренебрежимо малы. Код операции содержит оптимизированный внутренний цикл.

2.  Генерация кода. Сгенерированный для запроса код уже включает в себя все косвенные вызовы.

В строчно-ориентированных базах данных это, как правило, не делается, так как не имеет смысла при выполнении простых запросов. Однако есть исключения. Например, MemSQL использует генерацию кода для снижения задержек при обработке SQL‑запросов. (Для сравнения, аналитическим СУБД требуется оптимизация пропускной способности, а не задержек.)

Обратите внимание, что для эффективности использования CPU язык запросов должен быть декларативным (SQL или MDX) или, по крайней мере, векторным (J, K). Запрос должен содержать только неявные циклы, что позволяет выполнять оптимизацию.
 -->

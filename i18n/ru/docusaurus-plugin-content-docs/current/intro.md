---
slug: /intro
sidebar_label: 'Что такое ClickHouse?'
description: 'ClickHouse® — это колоночная система управления базами данных (СУБД) SQL для онлайн-аналитической обработки (OLAP). Доступна как в виде программного обеспечения с открытым исходным кодом, так и в виде облачного сервиса.'
title: 'Что такое ClickHouse?'
keywords: ['ClickHouse', 'columnar database', 'OLAP database', 'analytical database', 'high-performance database']
doc_type: 'guide'
---

import column_example from '@site/static/images/column-oriented-example-query.png';
import row_orientated from '@site/static/images/row-oriented.gif';
import column_orientated from '@site/static/images/column-oriented.gif';
import Image from '@theme/IdealImage';

ClickHouse® — это высокопроизводительная колонночная система управления базами данных (СУБД) SQL для онлайн-аналитической обработки (OLAP). Она доступна как в виде [ПО с открытым исходным кодом](https://github.com/ClickHouse/ClickHouse), так и в виде [облачного сервиса](https://clickhouse.com/cloud).


## Что такое аналитика? {#what-are-analytics}

Аналитика, также известная как OLAP (Online Analytical Processing, оперативная аналитическая обработка), — это SQL-запросы со сложными вычислениями (например, агрегация, обработка строк, арифметические операции) над большими объёмами данных.

В отличие от транзакционных запросов (или OLTP, Online Transaction Processing, оперативная обработка транзакций), которые читают и записывают лишь несколько строк на запрос и поэтому выполняются за миллисекунды, аналитические запросы обычно обрабатывают миллиарды и триллионы строк.

Во многих сценариях использования [аналитические запросы должны быть «в реальном времени»](https://clickhouse.com/engineering-resources/what-is-real-time-analytics), то есть возвращать результат менее чем за одну секунду.


## Построчное и поколоночное хранение данных {#row-oriented-vs-column-oriented-storage}

Такой уровень производительности достижим только при правильной «ориентации» данных.

Базы данных хранят данные либо [построчно, либо поколоночно](https://clickhouse.com/engineering-resources/what-is-columnar-database).

В построчной базе данных последовательные строки таблицы хранятся одна за другой. Такая организация позволяет быстро извлекать строки, поскольку значения всех столбцов каждой строки хранятся вместе.

ClickHouse — это поколоночная база данных. В таких системах таблицы хранятся как набор столбцов, то есть значения каждого столбца хранятся последовательно одно за другим. Такая организация усложняет восстановление отдельных строк (поскольку между значениями строк появляются промежутки), но операции со столбцами, такие как фильтрация или агрегация, выполняются значительно быстрее, чем в построчной базе данных.

Разницу лучше всего проиллюстрировать на примере запроса, выполняемого над 100 миллионами строк [реальных анонимизированных данных веб-аналитики](/getting-started/example-datasets/metrica):

```sql
SELECT MobilePhoneModel, COUNT() AS c
FROM metrica.hits
WHERE
      RegionID = 229
  AND EventDate >= '2013-07-01'
  AND EventDate <= '2013-07-31'
  AND MobilePhone != 0
  AND MobilePhoneModel not in ['', 'iPad']
GROUP BY MobilePhoneModel
ORDER BY c DESC
LIMIT 8;
```

Вы можете [выполнить этот запрос в ClickHouse SQL Playground](https://sql.clickhouse.com?query=U0VMRUNUIE1vYmlsZVBob25lTW9kZWwsIENPVU5UKCkgQVMgYyAKRlJPTSBtZXRyaWNhLmhpdHMgCldIRVJFIAogICAgICBSZWdpb25JRCA9IDIyOSAKICBBTkQgRXZlbnREYXRlID49ICcyMDEzLTA3LTAxJyAKICBBTkQgRXZlbnREYXRlIDw9ICcyMDEzLTA3LTMxJyAKICBBTkQgTW9iaWxlUGhvbmUgIT0gMCAKICBBTkQgTW9iaWxlUGhvbmVNb2RlbCBub3QgaW4gWycnLCAnaVBhZCddIApHUk9VUCBCWSBNb2JpbGVQaG9uZU1vZGVsCk9SREVSIEJZIGMgREVTQyAKTElNSVQgODs&chart=eyJ0eXBlIjoicGllIiwiY29uZmlnIjp7InhheGlzIjoiTW9iaWxlUGhvbmVNb2RlbCIsInlheGlzIjoiYyJ9fQ&run_query=true), который выбирает и фильтрует [всего несколько из более чем 100](https://sql.clickhouse.com/?query=U0VMRUNUIG5hbWUKRlJPTSBzeXN0ZW0uY29sdW1ucwpXSEVSRSBkYXRhYmFzZSA9ICdtZXRyaWNhJyBBTkQgdGFibGUgPSAnaGl0cyc7&tab=results&run_query=true) имеющихся столбцов и возвращает результат за миллисекунды:

<Image
  img={column_example}
  alt='Пример запроса в поколоночной базе данных'
  size='lg'
/>

Как видно из раздела статистики на диаграмме выше, запрос обработал 100 миллионов строк за 92 миллисекунды — это пропускная способность более 1 миллиарда строк в секунду или около 7 ГБ передаваемых данных в секунду.

**Построчная СУБД**

В построчной базе данных, даже если приведенный выше запрос обрабатывает только несколько из имеющихся столбцов, системе все равно необходимо загрузить данные из остальных столбцов с диска в память. Причина в том, что данные хранятся на диске фрагментами, называемыми [блоками](<https://en.wikipedia.org/wiki/Block_(data_storage)>) (обычно фиксированного размера, например 4 КБ или 8 КБ). Блоки являются минимальными единицами данных, считываемых с диска в память. Когда приложение или база данных запрашивает данные, подсистема дискового ввода-вывода операционной системы считывает необходимые блоки с диска. Даже если требуется только часть блока, весь блок считывается в память (это обусловлено архитектурой диска и файловой системы):

<Image img={row_orientated} alt='Структура построчной базы данных' size='lg' />

**Поколоночная СУБД**


Поскольку значения каждого столбца хранятся на диске последовательно друг за другом, при выполнении приведённого выше запроса не загружаются лишние данные.
Поскольку блочное хранение и передача данных с диска в память соответствуют типичным шаблонам доступа аналитических запросов, с диска читаются только столбцы, необходимые для запроса, что позволяет избежать лишних операций ввода-вывода для неиспользуемых данных. Это [значительно быстрее](https://benchmark.clickhouse.com/) по сравнению со строковым хранением, при котором считываются целые строки (включая несущественные столбцы):

<Image img={column_orientated} alt="Column-oriented database structure" size="lg"/>



## Репликация и целостность данных {#data-replication-and-integrity}

ClickHouse использует асинхронную схему репликации multi-master для обеспечения избыточного хранения данных на нескольких узлах. После записи на любую доступную реплику все остальные реплики получают свою копию в фоновом режиме. Система поддерживает идентичность данных на разных репликах. Восстановление после большинства сбоев выполняется автоматически, а в сложных случаях — полуавтоматически.


## Управление доступом на основе ролей {#role-based-access-control}

ClickHouse реализует управление учётными записями пользователей с помощью SQL-запросов и позволяет настраивать управление доступом на основе ролей, аналогично стандарту ANSI SQL и популярным системам управления реляционными базами данных.


## Поддержка SQL {#sql-support}

ClickHouse поддерживает [декларативный язык запросов на основе SQL](/sql-reference), который во многих случаях соответствует стандарту ANSI SQL. Поддерживаемые конструкции запросов включают [GROUP BY](/sql-reference/statements/select/group-by), [ORDER BY](/sql-reference/statements/select/order-by), подзапросы в [FROM](/sql-reference/statements/select/from), конструкцию [JOIN](/sql-reference/statements/select/join), оператор [IN](/sql-reference/operators/in), [оконные функции](/sql-reference/window-functions) и скалярные подзапросы.


## Приближённые вычисления {#approximate-calculation}

ClickHouse позволяет жертвовать точностью ради производительности. Например, некоторые агрегатные функции вычисляют количество уникальных значений, медиану и квантили приближённо. Также запросы можно выполнять на выборке данных для быстрого получения приближённого результата. Наконец, агрегации можно выполнять по ограниченному числу ключей вместо всех ключей. В зависимости от степени неравномерности распределения ключей это может дать достаточно точный результат при значительно меньших затратах ресурсов, чем точное вычисление.


## Адаптивные алгоритмы соединения {#adaptive-join-algorithms}

ClickHouse адаптивно выбирает алгоритм соединения: сначала использует быстрые хеш-соединения и переходит на соединения слиянием, если в запросе участвует более одной большой таблицы.


## Превосходная производительность запросов {#superior-query-performance}

ClickHouse хорошо известен своей исключительно высокой скоростью выполнения запросов.
Чтобы узнать, почему ClickHouse настолько быстр, см. руководство [Почему ClickHouse такой быстрый?](/concepts/why-clickhouse-is-so-fast.mdx).


<!--
## Что такое OLAP? {#what-is-olap}
Сценарии OLAP требуют получения ответов в реальном времени при работе с большими наборами данных для сложных аналитических запросов со следующими характеристиками:
- Наборы данных могут быть огромными — миллиарды или триллионы строк
- Данные организованы в таблицы, содержащие множество столбцов
- Для ответа на конкретный запрос выбирается только несколько столбцов
- Результаты должны возвращаться за миллисекунды или секунды




## Колоночные и строковые базы данных {#column-oriented-vs-row-oriented-databases}

В строковых СУБД данные хранятся построчно — все значения, относящиеся к одной строке, физически располагаются рядом друг с другом.

В колоночных СУБД данные хранятся по столбцам — значения из одного столбца располагаются вместе.


## Почему колоночные базы данных лучше работают в сценариях OLAP {#why-column-oriented-databases-work-better-in-the-olap-scenario}

Колоночные базы данных лучше подходят для сценариев OLAP: они обрабатывают большинство запросов как минимум в 100 раз быстрее. Причины подробно объясняются ниже, но этот факт проще продемонстрировать визуально:

Видите разницу?

В остальной части этой статьи объясняется, почему колоночные базы данных хорошо работают в таких сценариях и почему ClickHouse [превосходит](/concepts/why-clickhouse-is-so-fast/concepts/why-clickhouse-is-so-fast#storage-layer-concurrent-inserts-and-selects-are-isolated) другие решения в этой категории.


## Почему ClickHouse такой быстрый? {#why-is-clickhouse-so-fast}

ClickHouse использует все доступные системные ресурсы на полную мощность для максимально быстрой обработки каждого аналитического запроса. Это стало возможным благодаря уникальному сочетанию аналитических возможностей и внимания к низкоуровневым деталям, необходимым для создания самой быстрой OLAP-базы данных.

Полезные статьи для более глубокого погружения в эту тему:

- [Производительность ClickHouse](/concepts/why-clickhouse-is-so-fast)
- [Отличительные особенности ClickHouse](/about-us/distinctive-features.md)
- [FAQ: Почему ClickHouse такой быстрый?](/knowledgebase/why-clickhouse-is-so-fast)


## Обработка аналитических запросов в реальном времени {#processing-analytical-queries-in-real-time}

В строчно-ориентированной СУБД данные хранятся в следующем порядке:

| Строка | WatchID     | JavaEnable | Title              | GoodEvent | EventTime           |
| --- | ----------- | ---------- | ------------------ | --------- | ------------------- |
| #0  | 89354350662 | 1          | Связи с инвесторами | 1         | 2016-05-18 05:19:20 |
| #1  | 90329509958 | 0          | Свяжитесь с нами   | 1         | 2016-05-18 08:10:20 |
| #2  | 89953706054 | 1          | Миссия             | 1         | 2016-05-18 07:38:00 |
| #N  | ...         | ...        | ...                | ...       | ...                 |

Другими словами, все значения, относящиеся к одной строке, физически хранятся рядом друг с другом.

Примерами строчно-ориентированных СУБД являются MySQL, Postgres и MS SQL Server.

В колоночно-ориентированной СУБД данные хранятся следующим образом:

| Строка:     | #0                  | #1                  | #2                  | #N  |
| ----------- | ------------------- | ------------------- | ------------------- | --- |
| WatchID:    | 89354350662         | 90329509958         | 89953706054         | ... |
| JavaEnable: | 1                   | 0                   | 1                   | ... |
| Title:      | Связи с инвесторами | Свяжитесь с нами    | Миссия              | ... |
| GoodEvent:  | 1                   | 1                   | 1                   | ... |
| EventTime:  | 2016-05-18 05:19:20 | 2016-05-18 08:10:20 | 2016-05-18 07:38:00 | ... |

Эти примеры показывают только порядок расположения данных. Значения из разных столбцов хранятся отдельно, а данные из одного столбца хранятся вместе.

Примеры колоночно-ориентированных СУБД: Vertica, Paraccel (Actian Matrix и Amazon Redshift), Sybase IQ, Exasol, Infobright, InfiniDB, MonetDB (VectorWise и Actian Vector), LucidDB, SAP HANA, Google Dremel, Google PowerDrill, Druid и kdb+.

Различные способы хранения данных лучше подходят для разных сценариев. Сценарий доступа к данным определяется тем, какие запросы выполняются, как часто и в каком соотношении; сколько данных читается для каждого типа запроса — строк, столбцов и байтов; соотношением между чтением и обновлением данных; рабочим объёмом данных и степенью их локального использования; используются ли транзакции и насколько они изолированы; требованиями к репликации данных и логической целостности; требованиями к задержке и пропускной способности для каждого типа запроса и так далее.

Чем выше нагрузка на систему, тем важнее настроить её в соответствии с требованиями сценария использования, и тем более детальной становится эта настройка. Не существует системы, которая одинаково хорошо подходит для существенно различающихся сценариев. Если система адаптируется к широкому набору сценариев, то при высокой нагрузке она будет одинаково плохо справляться со всеми сценариями или будет хорошо работать только для одного или нескольких из возможных сценариев.

### Ключевые свойства сценария OLAP {#key-properties-of-olap-scenario}

- Таблицы «широкие», то есть содержат большое количество столбцов.
- Наборы данных большие, и запросы требуют высокой пропускной способности при обработке одного запроса (до миллиардов строк в секунду на сервер).
- Значения в столбцах довольно малы: числа и короткие строки (например, 60 байт на URL).
- Запросы извлекают большое количество строк, но только небольшое подмножество столбцов.
- Для простых запросов допустимы задержки около 50 мс.
- В запросе участвует одна большая таблица; все остальные таблицы малы.
- Результат запроса значительно меньше исходных данных. Другими словами, данные фильтруются или агрегируются, поэтому результат помещается в оперативную память одного сервера.
- Запросы относительно редки (обычно сотни запросов на сервер или меньше в секунду).
- Вставки происходят достаточно большими пакетами (\> 1000 строк), а не по одной строке.
- Транзакции не требуются.

Легко заметить, что сценарий OLAP сильно отличается от других популярных сценариев (таких как OLTP или доступ типа «ключ-значение»). Поэтому не имеет смысла пытаться использовать OLTP или базу данных типа «ключ-значение» для обработки аналитических запросов, если вы хотите получить приемлемую производительность. Например, если вы попытаетесь использовать MongoDB или Redis для аналитики, вы получите очень низкую производительность по сравнению с OLAP-базами данных.


### Ввод/вывод {#inputoutput}

1.  Для аналитического запроса требуется чтение лишь небольшого числа столбцов таблицы. В колоночной базе данных можно читать только необходимые данные. Например, если требуется 5 столбцов из 100, можно ожидать 20-кратного сокращения объёма операций ввода-вывода.
2.  Поскольку данные читаются пакетами, их проще сжимать. Данные в столбцах также сжимаются лучше. Это дополнительно снижает объём операций ввода-вывода.
3.  Благодаря сокращению операций ввода-вывода в системном кэше помещается больше данных.

Например, запрос «подсчитать количество записей для каждой рекламной платформы» требует чтения одного столбца «идентификатор рекламной платформы», который занимает 1 байт в несжатом виде. Если большая часть трафика не связана с рекламными платформами, можно ожидать как минимум 10-кратного сжатия этого столбца. При использовании быстрого алгоритма сжатия декомпрессия данных возможна со скоростью не менее нескольких гигабайт несжатых данных в секунду. Иными словами, такой запрос может обрабатываться со скоростью приблизительно несколько миллиардов строк в секунду на одном сервере. Такая скорость действительно достигается на практике.

### Процессор {#cpu}

Поскольку выполнение запроса требует обработки большого количества строк, целесообразно диспетчеризовать все операции для целых векторов, а не для отдельных строк, или реализовать движок запросов таким образом, чтобы затраты на диспетчеризацию были практически нулевыми. Если этого не сделать, то при любой сколько-нибудь приличной дисковой подсистеме интерпретатор запросов неизбежно станет узким местом для процессора. Имеет смысл как хранить данные в столбцах, так и обрабатывать их, когда это возможно, по столбцам.

Существует два способа это реализовать:

1.  Векторный движок. Все операции реализованы для векторов, а не для отдельных значений. Это означает, что операции не нужно вызывать часто, а затраты на диспетчеризацию незначительны. Код операции содержит оптимизированный внутренний цикл.

2.  Генерация кода. Сгенерированный для запроса код содержит все косвенные вызовы.

В строковых базах данных это не применяется, поскольку не имеет смысла при выполнении простых запросов. Однако есть исключения. Например, MemSQL использует генерацию кода для снижения задержки при обработке SQL-запросов. (Для сравнения: аналитические СУБД требуют оптимизации пропускной способности, а не задержки.)

Обратите внимание, что для эффективности процессора язык запросов должен быть декларативным (SQL или MDX) или хотя бы векторным (J, K). Запрос должен содержать только неявные циклы, что позволяет проводить оптимизацию.
-->

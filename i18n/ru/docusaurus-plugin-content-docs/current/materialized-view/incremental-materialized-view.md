---
slug: /materialized-view/incremental-materialized-view
title: Инкрементные материальные представления
description: Как использовать инкрементные материальные представления для ускорения запросов
keywords: [инкрементные материальные представления, ускорение запросов, оптимизация запросов]
score: 10000
---

import materializedViewDiagram from '@site/static/images/materialized-view/materialized-view-diagram.png';


# Инкрементные материальные представления

Инкрементные материальные представления (Materialized Views) позволяют пользователям сместить стоимость вычислений с времени запроса на время вставки, что приводит к более быстрым запросам `SELECT`.

В отличие от транзакционных баз данных, таких как Postgres, материальное представление ClickHouse — это просто триггер, который выполняет запрос на блоках данных по мере их вставки в таблицу. Результат этого запроса вставляется во вторую "целевую" таблицу. Если будут вставлены дополнительные строки, результаты снова будут отправлены в целевую таблицу, где промежуточные результаты будут обновлены и объединены. Этот объединенный результат эквивалентен выполнению запроса по всем оригинальным данным.

Основная мотивация для материальных представлений заключается в том, что результаты, вставленные в целевую таблицу, представляют собой результаты агрегации, фильтрации или преобразования строк. Эти результаты часто будут меньшей репрезентацией оригинальных данных (частичный эскиз в случае агрегаций). Это, вместе с тем, что запрос для чтения результатов из целевой таблицы является простым, обеспечивает более быстрое время запросов, чем если бы то же самое вычисление выполнялось на оригинальных данных, смещая вычисления (и, следовательно, задержку запроса) с времени запроса на время вставки.

Материальные представления в ClickHouse обновляются в реальном времени по мере поступления данных в основанную на них таблицу, что делает их более похожими на постоянно обновляемые индексы. Это контрастирует с другими базами данных, в которых материальные представления обычно являются статическими снимками запроса, которые должны быть обновлены (аналогично ClickHouse [обновляемым материальным представлениям](/sql-reference/statements/create/view#refreshable-materialized-view)).

<img src={materializedViewDiagram}
     class="image"
     alt="Диаграмма материального представления"
     style={{width: '500px'}} />

## Пример {#example}

Предположим, что мы хотим получить количество голосов за и против в день за пост.

```sql
CREATE TABLE votes
(
    `Id` UInt32,
    `PostId` Int32,
    `VoteTypeId` UInt8,
    `CreationDate` DateTime64(3, 'UTC'),
    `UserId` Int32,
    `BountyAmount` UInt8
)
ENGINE = MergeTree
ORDER BY (VoteTypeId, CreationDate, PostId)

INSERT INTO votes SELECT * FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/votes/*.parquet')

0 rows in set. Elapsed: 29.359 sec. Processed 238.98 million rows, 2.13 GB (8.14 million rows/s., 72.45 MB/s.)
```

Это reasonably simple query в ClickHouse благодаря функции [`toStartOfDay`](/sql-reference/functions/date-time-functions#tostartofday):

```sql
SELECT toStartOfDay(CreationDate) AS day,
       countIf(VoteTypeId = 2) AS UpVotes,
       countIf(VoteTypeId = 3) AS DownVotes
FROM votes
GROUP BY day
ORDER BY day ASC
LIMIT 10

┌─────────────────day─┬─UpVotes─┬─DownVotes─┐
│ 2008-07-31 00:00:00 │   	6 │     	0 │
│ 2008-08-01 00:00:00 │ 	182 │    	50 │
│ 2008-08-02 00:00:00 │ 	436 │   	107 │
│ 2008-08-03 00:00:00 │ 	564 │   	100 │
│ 2008-08-04 00:00:00 │	1306 │   	259 │
│ 2008-08-05 00:00:00 │	1368 │   	269 │
│ 2008-08-06 00:00:00 │	1701 │   	211 │
│ 2008-08-07 00:00:00 │	1544 │   	211 │
│ 2008-08-08 00:00:00 │	1241 │   	212 │
│ 2008-08-09 00:00:00 │ 	576 │    	46 │
└─────────────────────┴─────────┴───────────┘

10 rows in set. Elapsed: 0.133 sec. Processed 238.98 million rows, 2.15 GB (1.79 billion rows/s., 16.14 GB/s.)
Peak memory usage: 363.22 MiB.
```

Этот запрос уже быстрый благодаря ClickHouse, но можем ли мы сделать лучше?

Если мы хотим вычислить это во время вставки с помощью материального представления, нам нужна таблица, чтобы принимать результаты. Эта таблица должна хранить только 1 строку за день. Если получено обновление для существующего дня, остальные столбцы должны быть объединены с существующей строкой дня. Для того, чтобы это объединение инкрементальных состояний произошло, частичные состояния должны быть сохранены для других столбцов.

Это требует специального типа движка в ClickHouse: [SummingMergeTree](/engines/table-engines/mergetree-family/summingmergetree). Он заменяет все строки с одинаковым ключом упорядочения на одну строку, которая содержит суммированные значения для числовых столбцов. Следующая таблица будет объединять любые строки с одной и той же датой, суммируя любые числовые столбцы:

```sql
CREATE TABLE up_down_votes_per_day
(
  `Day` Date,
  `UpVotes` UInt32,
  `DownVotes` UInt32
)
ENGINE = SummingMergeTree
ORDER BY Day
```

Чтобы продемонстрировать наше материальное представление, предположим, что наша таблица голосов пуста и еще не получила никаких данных. Наше материальное представление выполняет вышеуказанный `SELECT` на данных, вставленных в `votes`, с результатами, отправленными в `up_down_votes_per_day`:

```sql
CREATE MATERIALIZED VIEW up_down_votes_per_day_mv TO up_down_votes_per_day AS
SELECT toStartOfDay(CreationDate)::Date AS Day,
       countIf(VoteTypeId = 2) AS UpVotes,
       countIf(VoteTypeId = 3) AS DownVotes
FROM votes
GROUP BY Day
```

Клаузула `TO` здесь важна, указывая, куда будут отправлены результаты, т.е. в `up_down_votes_per_day`.

Мы можем восстановить нашу таблицу голосов из нашего предыдущего вставки:

```sql
INSERT INTO votes SELECT toUInt32(Id) AS Id, toInt32(PostId) AS PostId, VoteTypeId, CreationDate, UserId, BountyAmount
FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/votes/*.parquet')

0 rows in set. Elapsed: 111.964 sec. Processed 477.97 million rows, 3.89 GB (4.27 million rows/s., 34.71 MB/s.)
Peak memory usage: 283.49 MiB.
```

После завершения мы можем подтвердить размер нашего `up_down_votes_per_day` - у нас должно быть 1 строка на день:

```sql
SELECT count()
FROM up_down_votes_per_day
FINAL

┌─count()─┐
│	5723 │
└─────────┘
```

Мы эффективно снизили количество строк здесь с 238 миллионов (в `votes`) до 5000, сохранив результат нашего запроса. Однако ключевым моментом здесь является то, что если новые голоса будут вставлены в таблицу `votes`, новые значения будут отправлены в `up_down_votes_per_day` за соответствующий день, где они будут автоматически объединены асинхронно в фоновом режиме, сохраняя только одну строку на день. Таким образом, `up_down_votes_per_day` всегда будет как малым, так и актуальным.

Поскольку объединение строк происходит асинхронно, может быть более одного голоса за день, когда пользователь выполняет запрос. Чтобы убедиться, что любые ожидающие строки объединены во время выполнения запроса, у нас есть два варианта:

- Использовать модификатор `FINAL` в имени таблицы. Мы сделали это для запроса подсчета выше.
- Аггрегировать по ключу упорядочения, использованному в нашей финальной таблице, т.е. `CreationDate` и суммировать метрики. Обычно это более эффективно и гибко (таблица может использоваться для других целей), но первое может быть проще для некоторых запросов. Мы показываем оба ниже:

```sql
SELECT
	Day,
	UpVotes,
	DownVotes
FROM up_down_votes_per_day
FINAL
ORDER BY Day ASC
LIMIT 10

10 rows in set. Elapsed: 0.004 sec. Processed 8.97 thousand rows, 89.68 KB (2.09 million rows/s., 20.89 MB/s.)
Peak memory usage: 289.75 KiB.

SELECT Day, sum(UpVotes) AS UpVotes, sum(DownVotes) AS DownVotes
FROM up_down_votes_per_day
GROUP BY Day
ORDER BY Day ASC
LIMIT 10
┌────────Day─┬─UpVotes─┬─DownVotes─┐
│ 2008-07-31 │   	6 │     	0 │
│ 2008-08-01 │ 	182 │    	50 │
│ 2008-08-02 │ 	436 │   	107 │
│ 2008-08-03 │ 	564 │   	100 │
│ 2008-08-04 │	1306 │   	259 │
│ 2008-08-05 │	1368 │   	269 │
│ 2008-08-06 │	1701 │   	211 │
│ 2008-08-07 │	1544 │   	211 │
│ 2008-08-08 │	1241 │   	212 │
│ 2008-08-09 │ 	576 │    	46 │
└────────────┴─────────┴───────────┘

10 rows in set. Elapsed: 0.010 sec. Processed 8.97 thousand rows, 89.68 KB (907.32 thousand rows/s., 9.07 MB/s.)
Peak memory usage: 567.61 KiB.
```

Это ускорило наш запрос с 0.133с до 0.004с – более чем в 25 раз улучшение!

:::important Важно: `ORDER BY` = `GROUP BY`
В большинстве случаев столбцы, используемые в предложении `GROUP BY` трансформации материальных представлений, должны быть согласованы с теми, которые используются в предложении `ORDER BY` целевой таблицы, если используется движок таблицы `SummingMergeTree` или `AggregatingMergeTree`. Эти движки зависят от столбцов `ORDER BY` для объединения строк с одинаковыми значениями во время фоновых операций объединения. Несоответствие между столбцами `GROUP BY` и `ORDER BY` может привести к неэффективной производительности запросов, неоптимальным объединениям или даже несоответствиям данных.
:::

### Более сложный пример {#a-more-complex-example}

Вышеуказанный пример использует материальные представления для вычисления и хранения двух сумм за день. Суммы представляют собой самую простую форму агрегации, для которой можно сохранять частичные состояния - мы просто можем добавлять новые значения к существующим значениям, когда они приходят. Тем не менее, материальные представления ClickHouse могут использоваться для любого типа агрегации.

Предположим, мы хотим вычислить некоторые статистики для постов за каждый день: 99.9-й процентиль для `Score` и среднее значение `CommentCount`. Запрос для вычисления этого может выглядеть следующим образом:

```sql
SELECT
	toStartOfDay(CreationDate) AS Day,
	quantile(0.999)(Score) AS Score_99th,
	avg(CommentCount) AS AvgCommentCount
FROM posts
GROUP BY Day
ORDER BY Day DESC
LIMIT 10

	┌─────────────────Day─┬────────Score_99th─┬────AvgCommentCount─┐
 1. │ 2024-03-31 00:00:00 │  5.23700000000008 │ 1.3429811866859624 │
 2. │ 2024-03-30 00:00:00 │             	5 │ 1.3097158891616976 │
 3. │ 2024-03-29 00:00:00 │  5.78899999999976 │ 1.2827635327635327 │
 4. │ 2024-03-28 00:00:00 │             	7 │  1.277746158224246 │
 5. │ 2024-03-27 00:00:00 │ 5.738999999999578 │ 1.2113264918282023 │
 6. │ 2024-03-26 00:00:00 │             	6 │ 1.3097536945812809 │
 7. │ 2024-03-25 00:00:00 │             	6 │ 1.2836721018539201 │
 8. │ 2024-03-24 00:00:00 │ 5.278999999999996 │ 1.2931667891256429 │
 9. │ 2024-03-23 00:00:00 │ 6.253000000000156 │  1.334061135371179 │
10. │ 2024-03-22 00:00:00 │ 9.310999999999694 │ 1.2388059701492538 │
	└─────────────────────┴───────────────────┴────────────────────┘

10 rows in set. Elapsed: 0.113 sec. Processed 59.82 million rows, 777.65 MB (528.48 million rows/s., 6.87 GB/s.)
Peak memory usage: 658.84 MiB.
```

Как и прежде, мы можем создать материальное представление, которое выполняет вышеуказанный запрос по мере вставки новых постов в нашу таблицу `posts`.

Для примера, и чтобы избежать загрузки данных постов из S3, мы создадим дублирующую таблицу `posts_null` с той же схемой, что и `posts`. Однако эта таблица не будет хранить никаких данных и просто будет использоваться материальным представлением, когда строки вставляются. Чтобы предотвратить хранение данных, мы можем использовать тип движка таблицы [`Null`](/engines/table-engines/special/null).

```sql
CREATE TABLE posts_null AS posts ENGINE = Null
```

Движок таблицы Null — это мощная оптимизация - подумайте об этом как о `/dev/null`. Наше материальное представление будет вычислять и хранить наши сводные статистики, когда в таблицу `posts_null` поступают строки во время вставки — это просто триггер. Однако, сырые данные не будут храниться. Хотя в нашем случае мы, вероятно, все еще хотим хранить оригинальные посты, этот подход может быть использован для вычисления агрегатов, избегая накладных расходов на хранение сырых данных.

Таким образом, материальное представление становится:

```sql
CREATE MATERIALIZED VIEW post_stats_mv TO post_stats_per_day AS
       SELECT toStartOfDay(CreationDate) AS Day,
       quantileState(0.999)(Score) AS Score_quantiles,
       avgState(CommentCount) AS AvgCommentCount
FROM posts_null
GROUP BY Day
```

Обратите внимание, как мы добавляем суффикс `State` к концу наших агрегатных функций. Это гарантирует, что состояние агрегата функции будет возвращено вместо окончательного результата. Это будет содержать дополнительную информацию, позволяющую этому частичному состоянию объединяться с другими состояниями. Например, в случае среднего, это будет включать счет и сумму столбца.

> Частичные состояния агрегации необходимы для вычисления правильных результатов. Например, для вычисления среднего, простое усреднение средних значений поддиапазонов дает неправильные результаты.

Теперь мы создаем целевую таблицу для этого представления `post_stats_per_day`, которая хранит эти частичные агрегатные состояния:

```sql
CREATE TABLE post_stats_per_day
(
  `Day` Date,
  `Score_quantiles` AggregateFunction(quantile(0.999), Int32),
  `AvgCommentCount` AggregateFunction(avg, UInt8)
)
ENGINE = AggregatingMergeTree
ORDER BY Day
```

Хотя раньше `SummingMergeTree` был достаточен для хранения подсчетов, теперь нам нужен более продвинутый тип движка для других функций: [`AggregatingMergeTree`](/engines/table-engines/mergetree-family/aggregatingmergetree).
Чтобы гарантировать, что ClickHouse знает, что будут храниться агрегатные состояния, мы определяем `Score_quantiles` и `AvgCommentCount` как тип `AggregateFunction`, указывая функцию источника частичных состояний и тип их исходных столбцов. Как и в случае с `SummingMergeTree`, строки с одинаковым значением `ORDER BY` будут объединены (в данном примере это `Day`).

Чтобы заполнить нашу `post_stats_per_day` через наше материальное представление, мы просто можем вставить все строки из `posts` в `posts_null`:

```sql
INSERT INTO posts_null SELECT * FROM posts

0 rows in set. Elapsed: 13.329 sec. Processed 119.64 million rows, 76.99 GB (8.98 million rows/s., 5.78 GB/s.)
```

> В производственной среде вы, вероятно, прикрепите материальное представление к таблице `posts`. Мы использовали `posts_null` здесь, чтобы продемонстрировать таблицу null.

Наш финальный запрос должен использовать суффикс `Merge` для наших функций (так как столбцы хранят частичные состояния агрегации):

```sql
SELECT
	Day,
	quantileMerge(0.999)(Score_quantiles),
	avgMerge(AvgCommentCount)
FROM post_stats_per_day
GROUP BY Day
ORDER BY Day DESC
LIMIT 10
```

Обратите внимание, что мы используем `GROUP BY` здесь вместо `FINAL`.

## Использование таблицы источника в фильтрах и соединениях в материальных представлениях {#using-source-table-in-filters-and-joins-in-materialized-views}

Работая с материальными представлениями в ClickHouse, важно понимать, как таблица источника обрабатывается во время выполнения запроса материального представления. В частности, таблица источника в запросе материального представления заменяется вставленным блоком данных. Это поведение может привести к неожиданным результатам, если его не правильно понять.

### Пример сценария {#example-scenario}

Рассмотрим следующую настройку:

```sql
CREATE TABLE t0 (`c0` Int) ENGINE = Memory;
CREATE TABLE mvw1_inner (`c0` Int) ENGINE = Memory;
CREATE TABLE mvw2_inner (`c0` Int) ENGINE = Memory;

CREATE VIEW vt0 AS SELECT * FROM t0;

CREATE MATERIALIZED VIEW mvw1 TO mvw1_inner
AS SELECT count(*) AS c0
    FROM t0
    LEFT JOIN ( SELECT * FROM t0 ) AS x ON t0.c0 = x.c0;


CREATE MATERIALIZED VIEW mvw2 TO mvw2_inner
AS SELECT count(*) AS c0
    FROM t0
    LEFT JOIN vt0 ON t0.c0 = vt0.c0;

INSERT INTO t0 VALUES (1),(2),(3);

INSERT INTO t0 VALUES (1),(2),(3),(4),(5);

SELECT * FROM mvw1;
   ┌─c0─┐
1. │  3 │
2. │  5 │
   └────┘

SELECT * FROM mvw2;
   ┌─c0─┐
1. │  3 │
2. │  8 │
   └────┘
```

### Объяснение {#explanation}

В приведенном выше примере у нас есть два материальных представления `mvw1` и `mvw2`, которые выполняют аналогичные операции, но слегка различаются в том, как они ссылаются на таблицу источника `t0`.

В `mvw1` таблица `t0` напрямую ссылается внутри подзапроса `(SELECT * FROM t0)` с правой стороны JOIN. Когда данные вставляются в `t0`, запрос материального представления выполняется с вставленным блоком данных, заменяющим `t0`. Это означает, что операция соединения выполняется только над вновь вставленными строками, а не над всей таблицей.

Во втором случае, при соединении с `vt0`, представление читает все данные из `t0`. Это гарантирует, что операция соединения учитывает все строки в `t0`, а не только вновь вставленный блок.

### Почему это работает именно так {#why-this-works-like-that}

Ключевое различие заключается в том, как ClickHouse обрабатывает таблицу источника в запросе материального представления. Когда материальное представление вызывается вставкой, таблица источника (`t0` в данном случае) заменяется вставленным блоком данных. Это поведение может быть использовано для оптимизации запросов, но также требует внимательного рассмотрения, чтобы избежать неожиданных результатов.

### Случаи использования и предостережения {#use-cases-and-caveats}


На практике вы можете использовать это поведение для оптимизации материальных представлений, которые должны обрабатывать лишь подмножество данных таблицы источника. Например, вы можете использовать подзапрос для фильтрации таблицы источника перед тем, как соединить ее с другими таблицами. Это может помочь уменьшить объем данных, обрабатываемых материальным представлением, и улучшить производительность.

```sql
CREATE TABLE t0 (id UInt32, value String) ENGINE = MergeTree() ORDER BY id;
CREATE TABLE t1 (id UInt32, description String) ENGINE = MergeTree() ORDER BY id;
INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, 'C');

CREATE TABLE mvw1_target_table (id UInt32, value String, description String) ENGINE = MergeTree() ORDER BY id;

CREATE MATERIALIZED VIEW mvw1 TO mvw1_target_table AS
SELECT t0.id, t0.value, t1.description
FROM t0
JOIN (SELECT * FROM t1 WHERE t1.id IN (SELECT id FROM t0)) AS t1
ON t0.id = t1.id;
```

В этом примере множество `BUILD` из подзапроса `IN (SELECT id FROM t0)` содержит только вновь вставленные строки, что может помочь отфильтровать `t1` по ним.

## Другие применения {#other-applications}

Вышеизложенное в основном сосредоточено на использовании материальных представлений для инкрементального обновления частичных агрегатов данных, тем самым перемещая вычисления с времени запроса на время вставки. Помимо этого распространенного случая использования, у материальных представлений есть множество других применений.

### Фильтрация и преобразование {#filtering-and-transformation}

В некоторых ситуациях мы можем захотеть вставить только подмножество строк и колонок при вставке. В этом случае наша таблица `posts_null` могла бы получать вставки, с запросом `SELECT`, фильтрующим строки перед вставкой в таблицу `posts`. Например, предположим, что мы хотим преобразовать колонку `Tags` в нашей таблице `posts`. Она содержит список имен тегов, разделенных символом ' | '. Преобразовав их в массив, мы можем более легко агрегировать по отдельным значениям тегов.

> Мы могли бы выполнить это преобразование при выполнении `INSERT INTO SELECT`. Материальное представление позволяет нам инкапсулировать эту логику в DDL ClickHouse и сохранить наши вставки простыми, применяя преобразование к любым новым строкам.

Наше материальное представление для этого преобразования показано ниже:

```sql
CREATE MATERIALIZED VIEW posts_mv TO posts AS
   	SELECT * EXCEPT Tags, arrayFilter(t -> (t != ''), splitByChar('|', Tags)) as Tags FROM posts_null
```

### Таблица справочников {#lookup-table}

Пользователи должны учитывать свои паттерны доступа при выборе ключа упорядочения ClickHouse, при этом столбцы, которые часто используются в фильтрах и агрегатных предписаниях, используются. Это может ограничивать сценарии, когда у пользователей есть более разнообразные паттерны доступа, которые не могут быть заключены в одном наборе колонок. Например, рассмотрим следующую таблицу `comments`:

```sql
CREATE TABLE comments
(
	`Id` UInt32,
	`PostId` UInt32,
	`Score` UInt16,
	`Text` String,
	`CreationDate` DateTime64(3, 'UTC'),
	`UserId` Int32,
	`UserDisplayName` LowCardinality(String)
)
ENGINE = MergeTree
ORDER BY PostId

0 rows in set. Elapsed: 46.357 sec. Processed 90.38 million rows, 11.14 GB (1.95 million rows/s., 240.22 MB/s.)
```

Ключ упорядочения здесь оптимизирует таблицу для запросов, фильтрующих по `PostId`.

Предположим, пользователь хочет отфильтровать по конкретному `UserId` и вычислить его средний `Score`:

```sql
SELECT avg(Score)
FROM comments
WHERE UserId = 8592047

   ┌──────────avg(Score)─┐
1. │ 0.18181818181818182 │
   └─────────────────────┘

1 row in set. Elapsed: 0.778 sec. Processed 90.38 million rows, 361.59 MB (116.16 million rows/s., 464.74 MB/s.)
Peak memory usage: 217.08 MiB.
```

Хотя это быстро (данные небольшие для ClickHouse), мы можем сказать, что это требует полного сканирования таблицы по количеству обработанных строк — 90.38 миллиона. Для более крупных наборов данных мы можем использовать материальное представление, чтобы получить значения ключа упорядочения `PostId` для фильтрации по колонке `UserId`. Эти значения могут затем использоваться для выполнения эффективного поиска.

В этом примере наше материальное представление может быть очень простым, выбирая только `PostId` и `UserId` из `comments` при вставке. Эти результаты в свою очередь отправляются в таблицу `comments_posts_users`, которая упорядочена по `UserId`. Мы создаем версию null таблицы `Comments` ниже и используем это для наполнения нашего представления и таблицы `comments_posts_users`:

```sql
CREATE TABLE comments_posts_users (
  PostId UInt32,
  UserId Int32
) ENGINE = MergeTree ORDER BY UserId


CREATE TABLE comments_null AS comments
ENGINE = Null

CREATE MATERIALIZED VIEW comments_posts_users_mv TO comments_posts_users AS
SELECT PostId, UserId FROM comments_null

INSERT INTO comments_null SELECT * FROM comments

0 rows in set. Elapsed: 5.163 sec. Processed 90.38 million rows, 17.25 GB (17.51 million rows/s., 3.34 GB/s.)
```

Теперь мы можем использовать это представление в подзапросе, чтобы ускорить наш предыдущий запрос:

```sql
SELECT avg(Score)
FROM comments
WHERE PostId IN (
	SELECT PostId
	FROM comments_posts_users
	WHERE UserId = 8592047
) AND UserId = 8592047


   ┌──────────avg(Score)─┐
1. │ 0.18181818181818182 │
   └─────────────────────┘

1 row in set. Elapsed: 0.012 sec. Processed 88.61 thousand rows, 771.37 KB (7.09 million rows/s., 61.73 MB/s.)
```

### Цепочка {#chaining}

Материальные представления могут быть объединены в цепочку, что позволяет установить сложные рабочие процессы. Для практического примера мы рекомендуем этот [блог](https://clickhouse.com/blog/chaining-materialized-views).

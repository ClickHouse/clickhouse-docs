---
alias: []
description: 'Документация по формату DWARF'
input_format: true
keywords: ['DWARF']
output_format: false
slug: /interfaces/formats/DWARF
title: 'DWARF'
doc_type: 'reference'
---

| Входные данные | Выходные данные | Псевдоним |
|----------------|-----------------|-----------|
| ✔              | ✗               |           |

## Описание {#description}

Формат `DWARF` разбирает отладочные символы DWARF из ELF-файла (исполняемого файла, библиотеки или объектного файла). 
Он аналогичен `dwarfdump`, но гораздо быстрее (сотни МБ/с) и поддерживает SQL. 
Он формирует одну строку для каждой Debug Information Entry (DIE) в секции `.debug_info` 
и включает «нулевые» записи, которые кодировка DWARF использует для завершения списков дочерних элементов в дереве.

:::info
`.debug_info` состоит из *unit*-ов, которые соответствуют единицам компиляции: 

- Каждый unit — это дерево *DIE* с `compile_unit` DIE в качестве корня. 
- Каждый DIE имеет *tag* и список *attributes*. 
- Каждый attribute имеет *name* и *value* (а также *form*, который определяет, как закодировано значение). 

Записи DIE представляют сущности из исходного кода, и их *tag* указывает, что это за сущность. Например, есть:

- функции (tag = `subprogram`)
- классы/структуры/перечисления (`class_type`/`structure_type`/`enumeration_type`)
- переменные (`variable`)
- аргументы функций (`formal_parameter`).

Древовидная структура отражает соответствующий исходный код. Например, `class_type` DIE может содержать `subprogram` DIE, представляющие методы класса.
:::

Формат `DWARF` выводит следующие столбцы:

- `offset` — позиция DIE в секции `.debug_info`
- `size` — количество байт в закодированном DIE (включая атрибуты)
- `tag` — тип DIE; традиционный префикс `DW_TAG_` опущен
- `unit_name` — имя единицы компиляции, содержащей данный DIE
- `unit_offset` — позиция единицы компиляции, содержащей этот DIE, в секции `.debug_info`
- `ancestor_tags` — массив тегов предков текущего DIE в дереве, в порядке от самого внутреннего к самому внешнему
- `ancestor_offsets` — смещения предков, параллельные `ancestor_tags`
- несколько распространённых атрибутов, продублированных из массива атрибутов для удобства:
  - `name`
  - `linkage_name` — преобразованное (mangled) полностью квалифицированное имя; обычно оно есть только у функций (и не у всех)
  - `decl_file` — имя файла исходного кода, в котором эта сущность была объявлена
  - `decl_line` — номер строки в исходном коде, в которой эта сущность была объявлена
- параллельные массивы, описывающие атрибуты:
  - `attr_name` — имя атрибута; традиционный префикс `DW_AT_` опущен
  - `attr_form` — то, как атрибут закодирован и интерпретируется; традиционный префикс `DW_FORM_` опущен
  - `attr_int` — целочисленное значение атрибута; 0, если атрибут не имеет числового значения
  - `attr_str` — строковое значение атрибута; пустая строка, если атрибут не имеет строкового значения

## Пример использования {#example-usage}

Формат `DWARF` можно использовать, чтобы найти единицы компиляции, которые содержат наибольшее число определений функций (включая инстанцирования шаблонов и функции из подключаемых заголовочных файлов):

```sql title="Query"
SELECT
    unit_name,
    count() AS c
FROM file('programs/clickhouse', DWARF)
WHERE tag = 'subprogram' AND NOT has(attr_name, 'declaration')
GROUP BY unit_name
ORDER BY c DESC
LIMIT 3
```

```text title="Response"
┌─unit_name──────────────────────────────────────────────────┬─────c─┐
│ ./src/Core/Settings.cpp                                    │ 28939 │
│ ./src/AggregateFunctions/AggregateFunctionSumMap.cpp       │ 23327 │
│ ./src/AggregateFunctions/AggregateFunctionUniqCombined.cpp │ 22649 │
└────────────────────────────────────────────────────────────┴───────┘

3 строки в наборе. Затрачено: 1.487 сек. Обработано 139.76 млн строк, 1.12 ГБ (93.97 млн строк/с., 752.77 МБ/с.)
Пиковое использование памяти: 271.92 МиБ.
```

## Параметры формата {#format-settings}
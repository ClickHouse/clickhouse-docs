---
slug: /use-cases/observability/clickstack/materialized_views
title: 'ClickStack - Materialized Views'
sidebar_label: 'Materialized Views'
description: 'Оптимизация производительности ClickStack с использованием materialized views'
doc_type: 'guide'
keywords: ['clickstack', 'обсервабилити', 'materialized views', 'производительность', 'оптимизация', 'визуализации', 'агрегации']
---

import BetaBadge from '@theme/badges/BetaBadge';
import Image from '@theme/IdealImage';
import materializedViewDiagram from '@site/static/images/materialized-view/materialized-view-diagram.png';
import edit_source from '@site/static/images/clickstack/materialized_views/edit_source.png';
import add_view from '@site/static/images/clickstack/materialized_views/add_view.png';
import select_metrics from '@site/static/images/clickstack/materialized_views/select_metrics.png';
import select_time_granularity from '@site/static/images/clickstack/materialized_views/select_time_granularity.png';
import select_min_time from '@site/static/images/clickstack/materialized_views/select_min_time.png';
import save_source from '@site/static/images/clickstack/materialized_views/save_source.png';
import generated_sql from '@site/static/images/clickstack/materialized_views/generated_sql.png';
import accelerated_visual from '@site/static/images/clickstack/materialized_views/accelerated_visual.png';

<BetaBadge />


## Введение \{#introduction\}

ClickStack может использовать [Incremental Materialized Views (IMV)](/materialized-view/incremental-materialized-view) для ускорения визуализаций, которые зависят от ресурсоёмких агрегатных запросов, например, вычисления средней продолжительности запроса в минуту во времени. Эта функция может существенно повысить производительность запросов и, как правило, наиболее полезна для крупных развертываний — порядка 10 TB данных в день и более, — позволяя масштабироваться до диапазона PB в день. Incremental materialized views находятся на стадии Beta и должны использоваться с осторожностью.

:::note
Оповещения также могут выигрывать от использования materialized views и будут применять их автоматически.
Это может снизить вычислительные накладные расходы при выполнении большого количества оповещений, особенно с учётом того, что они обычно запускаются очень часто.
Сокращение времени выполнения может быть полезно как с точки зрения отзывчивости системы, так и с точки зрения потребления ресурсов.
:::

## Что такое incremental materialized views \{#what-are-incremental-materialized-views\}

Incremental materialized views позволяют перенести затраты на вычисления с времени выполнения запроса на время вставки, что приводит к значительно более быстрым `SELECT`-запросам.

В отличие от транзакционных баз данных, таких как Postgres, materialized view в ClickHouse не является сохранённым снимком. Вместо этого она действует как триггер, который выполняет запрос над блоками данных по мере их вставки в исходную таблицу. Результат этого запроса записывается в отдельную целевую таблицу. По мере вставки дополнительных данных новые частичные результаты добавляются и сливаются в целевой таблице. Объединённый результат эквивалентен выполнению агрегации над всем исходным набором данных.

Основная мотивация использования materialized views состоит в том, что данные, записываемые в целевую таблицу, представляют собой результат агрегации, фильтрации или трансформации. В ClickStack они используются исключительно для агрегаций. Эти результаты обычно намного меньше необработанных исходных данных и часто представляют собой частичные состояния агрегации. В сочетании с простотой выполнения запросов к предагрегированной целевой таблице это приводит к существенно меньшей задержке запросов по сравнению с выполнением тех же вычислений над сырыми данными во время запроса.

Materialized views в ClickHouse обновляются непрерывно по мере поступления данных в исходную таблицу, ведя себя скорее как всегда актуальные индексы. Это отличается от многих других баз данных, где materialized views являются статическими снимками, которые необходимо периодически обновлять, аналогично ClickHouse [Refreshable Materialized Views](/materialized-view/refreshable-materialized-view).

<Image img={materializedViewDiagram} size="md" alt="Схема работы materialized view"/>

Incremental materialized views вычисляют только изменения представления по мере поступления новых данных, перенося вычисления на время вставки. Поскольку ClickHouse сильно оптимизирован под ингестию, дополнительные затраты на поддержку представления для каждого вставленного блока невелики по сравнению с выигрышем при выполнении запроса. Затраты на вычисление агрегации распределяются между вставками, а не оплачиваются многократно при каждом чтении. Запрос к предагрегированным результатам поэтому значительно дешевле их повторного пересчёта, что приводит к снижению операционных затрат и обеспечивает практически режим реального времени для последующих визуализаций, даже в масштабах петабайт.

Эта модель принципиально отличается от систем, которые полностью пересчитывают представления при каждом обновлении или полагаются на запланированные обновления. Более подробное объяснение того, как работают materialized views и как их создавать, приведено в руководстве по ссылке выше.

Каждая materialized view добавляет накладные расходы во время вставки, поэтому их следует использовать выборочно.

:::tip
Создавайте представления только для самых часто используемых дашбордов и визуализаций.
Ограничьте использование не более чем 20 представлениями, пока функция находится в бета-версии.
Ожидается, что этот порог будет увеличен в последующих релизах.
:::

:::note
Одна materialized view может вычислять несколько метрик для разных группировок, например минимальную, максимальную и p95 длительность по имени сервиса в одноминутных интервалах. Это позволяет одному представлению обслуживать множество визуализаций, а не только одну. Поэтому консолидация метрик в общих представлениях важна для максимизации ценности каждого представления и обеспечения их повторного использования в дашбордах и рабочих процессах.
:::

Прежде чем двигаться дальше, рекомендуется более подробно ознакомиться с materialized views в ClickHouse.
См. наше руководство по [Incremental materialized views](/materialized-view/incremental-materialized-view) для получения дополнительных подробностей.

## Выбор визуализаций для ускорения \{#selecting-visualizatons-for-acceleration\}

Прежде чем создавать какие-либо materialized views, важно понять, какие визуализации вы хотите ускорить и какие рабочие процессы наиболее критичны для ваших пользователей.

В ClickStack materialized views предназначены для **ускорения визуализаций с большим объёмом агрегаций**, то есть запросов, которые вычисляют одну или несколько метрик во времени. Например, **среднюю длительность запроса в минуту**, **количество запросов по сервисам** или **частоту ошибок во времени**. materialized view всегда должен содержать агрегацию и группировку по времени, так как он предназначен для построения визуализаций временных рядов.

В общем случае рекомендуется следующее:

### Определите наиболее значимые визуализации \{#identify-high-impact-visualizations\}

Лучшие кандидаты для ускорения обычно относятся к одной из следующих категорий:

- Визуализации на дашбордах, которые часто обновляются и постоянно отображаются, например, высокоуровневые мониторинговые дашборды на настенных экранах.
- Диагностические сценарии в runbook-ах, где к определённым графикам неоднократно обращаются во время реагирования на инциденты и которым нужно быстро возвращать результаты.
- Ключевые сценарии работы в HyperDX, включая:
  * Гистограммы на странице поиска.
  * Визуализации, используемые в преднастроенных дашбордах, таких как APM, Services или представления Kubernetes.

Эти визуализации часто многократно запускаются разными пользователями и для разных диапазонов времени, что делает их идеальными кандидатами для переноса вычислений с момента выполнения запроса на момент вставки данных.

### Соотнесите пользу с затратами на вставку \{#balance-benefit-against-insert-time-cost\}

Materialized views добавляют дополнительную работу во время вставки данных, поэтому их следует создавать выборочно и обдуманно. Не каждая визуализация выигрывает от предагрегации, и ускорение редко используемых графиков обычно не оправдывает накладные расходы. Рекомендуется удерживать общее число materialized views не выше 20.

:::note
Перед выводом в продакшен всегда проверяйте ресурсные накладные расходы, связанные с использованием materialized views, в частности потребление CPU, дисковый I/O и [merge activity](/docs/tips-and-tricks/too-many-parts). Каждая materialized view увеличивает объём работы при вставке и добавляет дополнительные части, поэтому важно убедиться, что операции слияния успевают обрабатывать вставки и количество частей остаётся стабильным. За этим можно следить через [system tables](/operations/system-tables/tables) и [встроенную панель обсервабилити](/operations/monitoring#built-in-advanced-observability-dashboard) в открытой версии ClickHouse или используя встроенные метрики и [панели мониторинга в ClickHouse Cloud](/cloud/manage/monitor/advanced-dashboard). См. раздел [Too many parts](/knowledgebase/exception-too-many-parts) для рекомендаций по диагностике и снижению избыточного количества частей.
:::

После того как вы определили наиболее важные визуализации, следующим шагом будет их консолидация.

### Объединение визуализаций в общие представления \{#consolidate-visualizations-into-shared-views\}

Все materialized view в ClickStack должны группировать данные по временным интервалам, используя функции, такие как [`toStartOfMinute`](/sql-reference/functions/date-time-functions#toStartOfMinute). Однако многие визуализации также используют дополнительные ключи группировки, такие как имя сервиса, имя span или код статуса. Когда несколько визуализаций используют одни и те же измерения группировки, их часто может обслуживать один materialized view.

Например (для трассировок):

* Средняя длительность по имени сервиса в динамике — `SELECT avg(Duration), toStartOfMinute(Timestamp) as time, ServiceName FROM otel_traces GROUP BY ServiceName, time`
* Количество запросов по имени сервиса в динамике — `SELECT count() count, toStartOfMinute(Timestamp) as time, ServiceName FROM otel_traces GROUP BY ServiceName, time`
* Средняя длительность по коду статуса в динамике — `SELECT avg(Duration), toStartOfMinute(Timestamp) as time, StatusCode FROM otel_traces GROUP BY StatusCode, time`
* Количество запросов по коду статуса в динамике — `SELECT count() count, toStartOfMinute(Timestamp) as time, StatusCode FROM otel_traces GROUP BY StatusCode, time`

Вместо того чтобы создавать отдельные materialized view для каждого запроса и графика, вы можете объединить их в одно представление, агрегирующее по имени сервиса и коду статуса. Это единое представление может вычислять несколько метрик, таких как количество, средняя длительность, максимальная длительность, а также перцентили, которые затем можно повторно использовать в нескольких визуализациях. Пример запроса, объединяющего приведённые выше, показан ниже:

```sql
SELECT avg(Duration), max(Duration), count(), quantiles(0.95,0.99)(Duration), toStartOfMinute(Timestamp) as time, ServiceName, StatusCode
FROM otel_traces
GROUP BY time, ServiceName, StatusCode
```

Объединение представлений таким образом снижает накладные расходы на вставку, ограничивает общее количество materialized view, уменьшает проблемы с количеством частей и упрощает последующее сопровождение.

На этом этапе **сосредоточьтесь на запросах**, которые будут выполняться средствами визуализации, работу которых вы хотите ускорить. В следующем разделе вы увидите пример, показывающий, как несколько агрегирующих запросов могут быть объединены в одну materialized view.


## Создание materialized view \{#creating-a-materialized-view\}

После того как вы определили визуализацию или набор визуализаций, которые хотите ускорить, следующим шагом является определение используемых запросов. На практике это означает изучение конфигурации визуализации и просмотр сгенерированного SQL, с особым вниманием к используемым метрикам агрегации и применённым функциям.

<Image img={generated_sql} size="lg" alt="Сгенерированный SQL"/>

:::note
Если для компонента в HyperDX недоступна отладочная панель, пользователи могут просмотреть консоль браузера, где логируются все запросы.
:::

После того как вы собрали необходимые запросы, вам следует ознакомиться с [**функциями агрегатных состояний**](/sql-reference/data-types/aggregatefunction) в ClickHouse. Materialized view опираются на эти функции, чтобы перенести вычисления с времени выполнения запроса на время вставки данных. Вместо хранения окончательных агрегированных значений materialized view вычисляют и хранят **промежуточные состояния агрегации**, которые затем объединяются и финализируются при выполнении запроса. Как правило, они значительно меньше исходной таблицы. Эти состояния имеют отдельные типы данных и должны быть явно описаны в схеме целевой таблицы.

Для справки, в документации ClickHouse представлен подробный обзор и примеры функций агрегатных состояний, а также движка таблицы, используемого для их хранения — `AggregatingMergeTree`:

- [Aggregate functions and states](/sql-reference/aggregate-functions)
- [AggregatingMergeTree engine](/engines/table-engines/mergetree-family/aggregatingmergetree)

В видео ниже вы можете увидеть пример использования AggregatingMergeTree и Aggregate-функций:

<div class='vimeo-container'>
<iframe width="1030" height="579" src="https://www.youtube.com/embed/pryhI4F_zqQ" title="Aggregation States in ClickHouse" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

**Настоятельно рекомендуется** ознакомиться с этими концепциями, прежде чем переходить к следующим шагам.

### Пример materialized view \{#example-materialized-view\}

Рассмотрим следующий исходный запрос, который вычисляет среднюю длительность, максимальную длительность, количество событий и перцентили по минутам, сгруппированным по названию сервиса и коду статуса:

```sql
SELECT
    toStartOfMinute(Timestamp),
    ServiceName,
    StatusCode,
    count() AS count,
    avg(Duration),
    max(Duration),
    quantiles(0.95, 0.99)(Duration)
FROM otel_traces
GROUP BY
    time,
    ServiceName,
    StatusCode
```

Чтобы ускорить выполнение этого запроса, создайте целевую таблицу `otel_traces_1m`, которая будет хранить соответствующие состояния агрегации:

```sql
CREATE TABLE otel_traces_1m
(
    `Timestamp` DateTime,
    `ServiceName` LowCardinality(String),
    `StatusCode` LowCardinality(String),
    `count` SimpleAggregateFunction(sum, UInt64),
    `avg__Duration` AggregateFunction(avg, UInt64),
    `max__Duration` SimpleAggregateFunction(max, Int64),
    `quantiles__Duration` AggregateFunction(quantiles(0.95, 0.99), Int64)
)
ENGINE = AggregatingMergeTree
ORDER BY (Timestamp, ServiceName, StatusCode);
```

Определение materialized view `otel_traces_1m_mv` затем вычисляет и записывает эти состояния по мере вставки новых данных:

```sql
CREATE MATERIALIZED VIEW otel_traces_1m_mv TO otel_traces_1m
AS
SELECT
    toStartOfMinute(Timestamp) AS Timestamp,
    ServiceName,
    StatusCode,
    count() AS count,
    avgState(Duration) AS avg__Duration,
    maxSimpleState(Duration) AS max__Duration,
    quantilesState(0.95, 0.99)(Duration) AS quantiles__Duration
FROM otel_v2.otel_traces
GROUP BY
    Timestamp,
    ServiceName,
    StatusCode;
```

Этот materialized view состоит из двух частей:

1. Целевая таблица, которая определяет схему и типы агрегатных состояний, используемых для хранения промежуточных результатов. Для корректного фонового слияния этих состояний требуется движок [AggregatingMergeTree](/engines/table-engines/mergetree-family/aggregatingmergetree).
2. Запрос materialized view выполняется автоматически при вставке. По сравнению с исходным запросом он использует state‑функции, такие как `avgState` и `quantilesState`, вместо финальных агрегирующих функций.

В результате получается компактная таблица, которая хранит поминутные агрегатные состояния для каждой пары «имя сервиса / код статуса». Ее размер предсказуемо растет со временем и кардинальностью, а после фоновых слияний она дает тот же результат, что и выполнение исходной агрегации по сырым данным. Запросы к этой таблице существенно дешевле, чем агрегация напрямую из исходной таблицы трассировок, что обеспечивает быструю и стабильную производительность визуализаций при масштабировании.


## Использование materialized view в ClickStack \{#materialized-view-usage-in-clickstack\}

После создания materialized view в ClickHouse их необходимо зарегистрировать в ClickStack, чтобы визуализации, дашборды и алерты могли автоматически их использовать.

### Регистрация materialized view для использования \{#registering-a-view\}

Materialized view необходимо зарегистрировать для **source** в HyperDX, который соответствует **исходной таблице**, из которой была получена эта view.

<VerticalStepper headerLevel="h4">

#### Редактирование source \{#edit-the-source\}

Перейдите к соответствующему **source** в HyperDX и откройте диалоговое окно **Edit configuration**. Пролистайте до раздела для materialized views.

<Image img={edit_source} size="lg" alt="Редактирование источников"/>

#### Добавление materialized view \{#add-the-materialized-view\}

Выберите **Add materialized view**, затем укажите базу данных и целевую таблицу, которые лежат в основе этой materialized view.

<Image img={add_view} size="lg" alt="Редактирование источников"/>

#### Выбор метрик \{#select-metrics\}

В большинстве случаев столбцы с метками времени, размерностями и метриками будут определены автоматически. Если этого не произошло, укажите их вручную.

Для метрик необходимо сопоставить:
- исходное имя столбца, например `Duration`, с
- соответствующим агрегирующим столбцом в materialized view, например `avg__Duration`

Для размерностей укажите все столбцы, кроме метки времени, по которым materialized view выполняет группировку.

<Image img={select_metrics} size="lg" alt="Выбор метрик"/>

#### Выбор временной детализации \{#select-time-granularity\}

Выберите **time granularity** для materialized view, например одну минуту.

<Image img={select_time_granularity} size="lg" alt="Выбор временной детализации"/>

#### Выбор минимальной даты \{#specify-the-minimum-date\}

Укажите минимальную дату, для которой materialized view содержит данные. Это соответствует самой ранней метке времени, доступной в view, и обычно совпадает с моментом её создания при условии непрерывной ингестии.

:::note
Materialized views **не заполняются задним числом автоматически** при создании, поэтому они будут содержать только строки, сгенерированные из данных, вставленных после создания.
Полное руководство по заполнению materialized views задним числом приведено в разделе ["Backfilling Data."](/data-modeling/backfilling#scenario-2-adding-materialized-views-to-existing-tables)
:::

<Image img={select_min_time} size="lg" alt="Выбор минимального времени"/>

Если точное время начала неизвестно, вы можете определить его, выполнив запрос минимальной метки времени в целевой таблице, например:

```sql
SELECT min(Timestamp) FROM otel_traces_1m
```

#### Сохранение source \{#save-the-source\}

Сохраните конфигурацию source.

<Image img={save_source} size="lg" alt="Сохранение источника"/>

</VerticalStepper>

После регистрации materialized view она автоматически используется ClickStack всякий раз, когда запрос может быть ускорен с её помощью, без необходимости изменять дашборды, визуализации или алерты. ClickStack оценивает каждый запрос во время выполнения и определяет, может ли быть применена materialized view.

### Проверка ускорения в дашбордах и визуализациях \{#verifying-acceleration-in-dashboards-and-visualizations\}

Важно помнить, что incremental materialized views содержат только данные, вставленные **после создания представления**. Они не заполняются задним числом автоматически, что делает их легковесными и недорогими в обслуживании. По этой причине пользователи должны явно указывать допустимый временной диапазон для представления при его регистрации.

:::note
ClickStack будет использовать materialized view только в том случае, если его минимальная метка времени меньше или равна началу временного диапазона запроса, что гарантирует, что представление содержит все необходимые данные. Хотя запросы внутренне разбиваются на подзапросы по времени, materialized views применяются либо ко всему запросу, либо не применяются вовсе. В будущих версиях может появиться возможность выборочного использования представлений для подходящих подзапросов.
:::

ClickStack предоставляет наглядные визуальные индикаторы для подтверждения того, используется ли materialized view.

1. **Проверьте статус оптимизации.** При просмотре дашборда или визуализации найдите значок молнии или метку `Accelerated`:

- **Зелёная молния** означает, что запрос ускорен с помощью materialized view.
- **Оранжевая молния** означает, что запрос выполняется по исходной таблице.

<Image img={accelerated_visual} size="lg" alt="Ускоренная визуализация"/>

2. **Изучите детали оптимизации.** Нажмите на значок молнии, чтобы открыть панель с подробностями, где отображаются:

- **Активная materialized view**: представление, выбранное для запроса, включая оценочное количество строк.
- **Пропущенные materialized views**: совместимые представления, которые не были выбраны, вместе с оценочными объёмами сканирования.
- **Несовместимые materialized views**: представления, которые не удалось использовать, и конкретная причина, почему.

3. **Разберитесь в распространённых причинах несовместимости.** Materialized view может не использоваться, если:

- **Временной диапазон запроса** начинается раньше минимальной метки времени представления.
- **Гранулярность визуализации** не является кратной гранулярности представления.
- **Агрегирующая функция**, запрошенная в запросе, отсутствует в представлении.
- В запросе используются **пользовательские выражения для подсчёта**, такие как `count(if(...))`, которые не могут быть выведены из агрегирующих состояний представления.

Эти индикаторы упрощают проверку того, ускорена ли визуализация, помогают понять, почему было выбрано конкретное представление, и диагностировать, почему представление оказалось непригодным.

### Как выбираются materialized view для визуализаций \{#how-views-are-selected\}

Когда выполняется визуализация, в ClickStack может быть несколько доступных вариантов, включая базовую таблицу и несколько materialized view. Чтобы обеспечить оптимальную производительность, ClickStack автоматически оценивает и выбирает наиболее эффективный вариант с использованием механизма ClickHouse [`EXPLAIN ESTIMATE`](/sql-reference/statements/explain#explain-estimate).

Процесс выбора выполняется по чётко определённой последовательности:

1. **Проверка совместимости**
   Сначала ClickStack определяет, может ли materialized view быть использован для запроса, проверяя:
   - **Покрытие по времени**: временной диапазон запроса должен полностью попадать в диапазон доступных данных materialized view.
   - **Гранулярность**: временной бакет визуализации должен быть равен или крупнее гранулярности представления.
   - **Агрегации**: запрошенные метрики должны присутствовать в представлении и вычисляться из его состояний агрегации.

2. **Преобразование запроса**
   Для совместимых materialized view ClickStack переписывает запрос так, чтобы он обращался к таблице materialized view:
   - Функции агрегации отображаются на соответствующие материализованные столбцы.
   - К состояниям агрегации применяются комбинаторы `-Merge`.
   - Временные бакеты корректируются, чтобы соответствовать гранулярности представления.

3. **Выбор лучшего кандидата**
   Если доступно несколько совместимых materialized view, ClickStack выполняет запрос [`EXPLAIN ESTIMATE`](/sql-reference/statements/explain#explain-estimate) для каждого кандидата и сравнивает оценочное количество строк и гранул для сканирования. Выбирается представление с наименьшей оценочной стоимостью сканирования.

4. **Прозрачный откат**
   Если ни один materialized view не совместим, ClickStack автоматически возвращается к выполнению запроса к исходной таблице.

Такой подход стабильно минимизирует объём сканируемых данных и обеспечивает предсказуемую производительность с низкой задержкой без необходимости изменять определения визуализаций.

Materialized view остаются применимыми даже тогда, когда визуализации включают фильтры, поисковые ограничения или разбиение по времени, при условии, что все необходимые размерности присутствуют в представлении. Это позволяет использовать представления для ускорения дашбордов, гистограмм и фильтрованных графиков без необходимости изменять определения визуализаций.

#### Пример выбора materialized views \{#example-of-choosing-materialized-view\}

Рассмотрим две materialized view, созданные на одном и том же источнике трассировок:

* `otel_traces_1m`, сгруппированная по минуте, `ServiceName` и `StatusCode`
* `otel_traces_1m_v2`, сгруппированная по минуте, `ServiceName`, `StatusCode` и `SpanName`

Вторая materialized view содержит дополнительные ключи группировки и, следовательно, генерирует больше строк и сканирует больше данных.

Если визуализация запрашивает **среднюю длительность по сервисам во времени**, обе materialized view технически корректны. ClickStack выполняет запрос [`EXPLAIN ESTIMATE`](/sql-reference/statements/explain#explain-estimate) для каждого кандидата и сравнивает оценочное количество гранул, то есть:

```sql
EXPLAIN ESTIMATE
SELECT
    toStartOfHour(Timestamp) AS hour,
    ServiceName,
    avgMerge(avg__Duration) AS avg__Duration
FROM otel_v2.otel_traces_1m
GROUP BY
    hour,
    ServiceName
ORDER BY hour DESC

┌─database─┬─table──────────┬─parts─┬──rows─┬─marks─┐
│ otel_v2  │ otel_traces_1m │     1 │ 49385 │     6 │
└──────────┴────────────────┴───────┴───────┴───────┘

1 row in set. Elapsed: 0.009 sec.

EXPLAIN ESTIMATE
SELECT
    toStartOfHour(Timestamp) AS hour,
    ServiceName,
    avgMerge(avg__Duration) AS avg__Duration
FROM otel_v2.otel_traces_1m_v2
GROUP BY
    hour,
    ServiceName
ORDER BY hour DESC

┌─database─┬─table─────────────┬─parts─┬───rows─┬─marks─┐
│ otel_v2  │ otel_traces_1m_v2 │     1 │ 212519 │    26 │
└──────────┴───────────────────┴───────┴────────┴───────┘

1 row in set. Elapsed: 0.004 sec.
```

Поскольку `otel_traces_1m` компактнее и при запросах сканирует меньше гранул, он выбирается автоматически.

Оба materialized view по-прежнему работают быстрее, чем запрос к базовой таблице напрямую, но выбор наименьшего подходящего materialized view обеспечивает наилучшую производительность.


### Оповещения \{#alerts\}

Запросы оповещений автоматически используют materialized views, когда это возможно. Применяется та же логика оптимизации, обеспечивающая более быструю оценку оповещений.

## Заполнение materialized view историческими данными \{#backfilling-a-materialized-view\}

Как отмечалось ранее, incremental materialized view содержат только данные, вставленные **после создания представления**, и не заполняются задним числом автоматически. Такой подход делает представления лёгкими и недорогими в обслуживании, но также означает, что их нельзя использовать для запросов, которым нужны данные ранее минимальной метки времени этого представления.

В большинстве случаев это приемлемо. Типичные нагрузки ClickStack сосредоточены на недавних данных, например за последние 24 часа, поэтому новое представление становится полностью пригодным к использованию в течение суток после создания. Однако для запросов, охватывающих более длительные временные диапазоны, представление может оставаться непригодным к использованию, пока не пройдёт достаточно времени.

В таких случаях пользователи могут рассмотреть возможность **заполнения задним числом (backfilling)** materialized view историческими данными.

Такое заполнение может быть **вычислительно дорогостоящим**. При нормальной работе materialized view заполняются инкрементально по мере поступления данных, равномерно распределяя вычислительные затраты во времени.

Заполнение задним числом сжимает этот объём работы в гораздо более короткий период, **значительно увеличивая использование CPU и памяти в единицу времени.**

В зависимости от размера набора данных и окна хранения это может потребовать временного масштабирования кластера — вертикального, а в ClickHouse Cloud также и горизонтального, — чтобы завершить заполнение в разумные сроки.

Если дополнительные ресурсы не будут выделены, заполнение может негативно повлиять на рабочие нагрузки в production, включая задержку запросов и пропускную способность приёма. Для **очень больших наборов данных или длинных исторических диапазонов заполнение может быть непрактичным** или вовсе невыполнимым.

Подводя итог, заполнение задним числом зачастую не оправдывает затраты и операционные риски. Его следует рассматривать только в исключительных случаях, когда ускорение исторических запросов критично. Если вы решите продолжить, рекомендуется следовать контролируемому подходу, изложенному ниже, чтобы сбалансировать производительность, стоимость и влияние на production.

### Подходы к бэкфиллу \{#backfilling-approaches\}

:::note Избегайте POPULATE
Использование команды [POPULATE](/sql-reference/statements/create/view#materialized-view) не рекомендуется для бэкфилла materialized view, за исключением небольших наборов данных, для которых приём приостановлен. Этот оператор может пропускать строки, вставленные в исходную таблицу, если materialized view создаётся после завершения вычисления хеша POPULATE. Кроме того, эта операция выполняется по всем данным и уязвима к прерываниям или ограничениям по памяти на больших наборах данных.
:::

Предположим, вам нужно выполнить бэкфилл materialized view, соответствующей следующей агрегации, которая вычисляет поминутные метрики, сгруппированные по имени сервиса и коду статуса:

```sql
SELECT
    toStartOfMinute(Timestamp),
    ServiceName,
    StatusCode,
    count() AS count,
    avg(Duration),
    max(Duration),
    quantiles(0.95, 0.99)(Duration)
FROM otel_traces
GROUP BY
    time,
    ServiceName,
    StatusCode
```

Как уже обсуждалось ранее, incremental materialized views не заполняются данными задним числом автоматически. Для безопасного дозаполнения исторических данных при сохранении инкрементального поведения для новых данных рекомендуются следующие процессы.


#### Прямое дозаполнение с помощью `INSERT INTO SELECT` \{#direct-backfill\}

Этот подход наилучшим образом подходит для **небольших наборов данных** или **относительно лёгких агрегирующих запросов**, когда полное дозаполнение может быть выполнено за разумное время без исчерпания ресурсов кластера. Обычно он уместен, когда запрос дозаполнения может выполняться несколько минут или, в крайнем случае, несколько часов, и когда временное увеличение использования CPU и I/O является приемлемым. Для больших наборов данных или более дорогих агрегаций вместо этого рассмотрите инкрементальные или блочные подходы к дозаполнению, описанные ниже.

<VerticalStepper headerLevel="h5">

##### Определите текущий охват представления \{#determine-current-coverage-of-view\}

Прежде чем выполнять какое-либо дозаполнение, сначала определите, какие данные уже содержит materialized view. Это делается путём выполнения запроса минимального значения метки времени, присутствующей в целевой таблице:

```sql
SELECT min(Timestamp)
FROM otel_traces_1m;
```

Эта метка времени представляет собой самую раннюю точку, начиная с которой представление может обслуживать запросы. Любой запрос из ClickStack, запрашивающий данные раньше этой метки времени, будет обращаться к базовой таблице.

##### Решите, необходимо ли дозаполнение \{#decide-whether-backfilling-is-neccessary\}

В большинстве развертываний ClickStack запросы сосредоточены на недавних данных, например за последние 24 часа. В таких случаях вновь созданные представления становятся полностью пригодными для использования вскоре после создания, и дозаполнение не требуется.

Если метка времени, возвращённая на предыдущем шаге, достаточно старая для ваших сценариев использования, дозаполнение не нужно. К нему следует прибегать только в следующих случаях:

- Запросы часто охватывают большие исторические диапазоны.
- Представление критично для производительности в этих диапазонах.
- Размер набора данных и стоимость агрегации делают дозаполнение выполнимым.

##### Заполните отсутствующие исторические данные \{#backfill-missing-historical-data\}

Если дозаполнение требуется, заполните целевую таблицу materialized view для меток времени, более ранних текущего минимума, с помощью запроса из представления, модифицированного так, чтобы читать только данные старше зафиксированной выше метки времени. Поскольку целевая таблица использует AggregatingMergeTree, запрос дозаполнения **должен вставлять состояния агрегации, а не финальные значения**.

:::warning
Этот запрос может обрабатывать большие объёмы данных и быть ресурсоёмким. Всегда проверяйте доступные ресурсы CPU, памяти и I/O перед запуском дозаполнения. Полезный приём — сначала выполнить запрос с `FORMAT Null`, чтобы оценить время выполнения и использование ресурсов.

Если ожидается, что сам запрос будет выполняться много часов, этот подход **не рекомендуется**.
:::

Обратите внимание, что следующий запрос добавляет предложение `WHERE`, чтобы ограничить агрегацию данными, которые старше самой ранней метки времени, присутствующей в представлении:

```sql
INSERT INTO otel_traces_1m
SELECT
    toStartOfMinute(Timestamp) AS Timestamp,
    ServiceName,
    StatusCode,
    count() AS count,
    avgState(Duration) AS avg__Duration,
    maxSimpleState(Duration) AS max__Duration,
    quantilesState(0.95, 0.99)(Duration) AS quantiles__Duration
FROM otel_traces
WHERE Timestamp < (
    SELECT min(Timestamp) FROM otel_traces_1m
)
GROUP BY
    Timestamp,
    ServiceName,
    StatusCode;
```
</VerticalStepper>

#### Инкрементальное заполнение с использованием таблицы Null \{#incremental-backfill-null-table\}

Для больших наборов данных или более ресурсоёмких агрегирующих запросов прямое заполнение с помощью одного `INSERT INTO SELECT` может быть непрактичным или небезопасным. В таких случаях рекомендуется подход **инкрементального заполнения**. Этот метод ближе к тому, как обычно работают incremental materialized view: данные обрабатываются управляемыми блоками вместо агрегирования всего исторического набора данных за один раз.

Этот подход уместен, когда:

- Запрос для заполнения в противном случае выполнялся бы много часов.
- Пиковое потребление памяти при полной агрегации слишком высоко.
- Вам требуется жёстко контролировать использование CPU и памяти во время заполнения.
- Вам нужен более устойчивый процесс, который можно безопасно перезапустить в случае прерывания.

Ключевая идея — использовать [**таблицу Null**](/engines/table-engines/special/null) в качестве буфера приёма. Хотя таблица Null не хранит данные, любые materialized view, прикреплённые к ней, всё равно будут выполняться, что позволяет инкрементально вычислять агрегирующие состояния по мере прохождения данных.

<VerticalStepper headerLevel="h5">

##### Создайте таблицу Null для заполнения \{#create-null-table\}

Создайте лёгкую таблицу Null, которая содержит только столбцы, необходимые для агрегации в materialized view. Это минимизирует I/O и использование памяти.

```sql
CREATE TABLE otel_traces_backfill
(
    Timestamp DateTime64(9),
    ServiceName LowCardinality(String),
    StatusCode LowCardinality(String),
    Duration UInt64
)
ENGINE = Null;
```

##### Прикрепите materialized view к таблице Null \{#attach-mv-to-null-table\}

Далее создайте materialized view на таблице Null, который будет записывать данные в ту же агрегирующую таблицу, что и ваш основной materialized view.

```sql
CREATE MATERIALIZED VIEW otel_traces_1m_mv_backfill
TO otel_traces_1m
AS
SELECT
    toStartOfMinute(Timestamp) AS Timestamp,
    ServiceName,
    StatusCode,
    count() AS count,
    avgState(Duration) AS avg__Duration,
    maxSimpleState(Duration) AS max__Duration,
    quantilesState(0.95, 0.99)(Duration) AS quantiles__Duration
FROM otel_traces_backfill
GROUP BY
    Timestamp,
    ServiceName,
    StatusCode;
```

Этот materialized view будет выполняться инкрементально по мере вставки строк в таблицу Null, формируя агрегирующие состояния небольшими блоками.

##### Заполняйте данные инкрементально \{#incremental-backfill\}

Наконец, вставьте исторические данные в таблицу Null. Materialized view будет обрабатывать данные блок за блоком, отправляя агрегирующие состояния в целевую таблицу без сохранения «сырых» строк.

```sql
INSERT INTO otel_traces_backfill
SELECT
    Timestamp,
    ServiceName,
    StatusCode,
    Duration
FROM otel_traces
WHERE Timestamp < (
    SELECT min(Timestamp) FROM otel_traces_1m
);
```

Поскольку данные обрабатываются инкрементально, использование памяти остаётся ограниченным и предсказуемым, во многом напоминая обычное поведение при ингестии данных.

:::note
Для дополнительной надёжности рассмотрите возможность направить backfill materialized view во временную целевую таблицу (например, `otel_traces_1m_v2`). После успешного завершения заполнения [партиции могут быть перемещены](/sql-reference/statements/alter/partition#move-partition-to-table) в основную целевую таблицу, например `ALTER TABLE otel_traces_1m_v2 MOVE PARTITION '2026-01-02' TO otel_traces_1m`. Это упрощает восстановление, если заполнение будет прервано или завершится сбоем из‑за ограничений ресурсов.
:::

Для получения дополнительных подробностей по настройке этого процесса, включая повышение производительности вставки и снижение и контроль потребления ресурсов, см. раздел ["Backfilling."](/data-modeling/backfilling#tuning-performance--resources)

</VerticalStepper>

## Рекомендации \{#recommendations\}

Ниже приведены рекомендации, обобщающие лучшие практики проектирования и эксплуатации materialized views в ClickStack. Соблюдение этих рекомендаций поможет сделать materialized views эффективными, предсказуемыми и экономически эффективными.

### Выбор и выравнивание детализации \{#granularity-selection-and-alignment\}

Materialized views используются только в том случае, если детализация визуализации или алерта является **точным кратным** детализации самой materialized view. То, как определяется эта детализация, зависит от типа графика:

- **Временные графики** (линейные или столбчатые графики со временем по оси X):
  Явно заданная детализация графика должна быть кратна детализации materialized view.
  Например, график с детализацией 10 минут может использовать materialized views с детализацией 10, 5, 2 или 1 минута, но не 20 или 3 минуты.

- **Невременные графики** (числовые, табличные или сводные графики):
  Эффективная детализация вычисляется как `(time range / 80)` с округлением вверх до ближайшей детализации, поддерживаемой HyperDX. Эта вычисленная детализация также должна быть кратна детализации materialized view.

Из-за этих правил:

- **Не создавайте materialized views с детализацией 10 минут**.
  ClickStack поддерживает детализацию 15 минут для графиков и алертов, но не 10 минут. Поэтому materialized view с детализацией 10 минут будет несовместима с распространёнными 15-минутными визуализациями и алертами.
- Предпочитайте детализацию **1 минута** или **1 час**, которые хорошо сочетаются с большинством конфигураций графиков и алертов.

Более грубая детализация (например, 1 час) даёт меньший размер materialized views и снижает накладные расходы на хранение, в то время как более тонкая детализация (например, 1 минута) обеспечивает большую гибкость для детализированного анализа. Выберите наименьшую детализацию, которая поддерживает ваши критически важные рабочие процессы.

### Ограничивайте количество materialized view и объединяйте их \{#limit-and-consolidate-materialized-views\}

Каждая materialized view создаёт дополнительную нагрузку при вставке данных и увеличивает нагрузку на операции с частями и их слияние (parts и merges).
Рекомендуются следующие ориентиры:

- **Не более 20 materialized view** для одного источника.
- **Около 10 materialized view** обычно является оптимальным значением.
- Объединяйте несколько визуализаций в одну materialized view, если у них общие измерения (dimensions).

По возможности вычисляйте несколько метрик и поддерживайте несколько графиков на основе одной materialized view.

### Тщательно выбирайте измерения \{#choose-dimensions-carefully\}

Включайте только те измерения, которые часто используются для группировки или фильтрации:

- Каждый дополнительный столбец группировки увеличивает размер представления.
- Уравновешивайте гибкость запросов с затратами на хранение и вставку данных.
- Фильтры по столбцам, отсутствующим в представлении, приведут к тому, что ClickStack будет обращаться к исходной таблице.

:::note Tip
Распространённой и почти всегда полезной базовой конфигурацией является materialized view, сгруппированное по **именам сервисов с метрикой count**, что обеспечивает быстрые гистограммы и обзоры на уровне сервисов при поиске и в дашбордах.
:::

### Соглашения об именовании столбцов агрегации \{#naming-conventions-for-aggregation-columns\}

Столбцы агрегации в materialized view должны строго соответствовать соглашению об именовании, чтобы обеспечить автоматический вывод:

- Шаблон имени: `<aggFn>__<sourceColumn>`
- Примеры:
  - `avg__Duration`
  - `max__Duration`
  - `count__` для подсчёта строк

ClickStack полагается на это соглашение, чтобы корректно сопоставлять запросы со столбцами materialized view.

### Квантили и выбор скетча \{#quantiles-and-sketch-selection\}

Разные функции квантилей имеют различные характеристики производительности и объёма хранимых данных:

- `quantiles` создаёт более крупные скетчи на диске, но их дешевле вычислять при вставке.
- `quantileTDigest` дороже вычислять при вставке, но он создаёт меньшие скетчи, что часто приводит к более быстрым запросам к материализованным представлениям.

Вы можете задавать размер скетча (например, `quantile(0.5)`) при вставке для обеих функций. Полученный скетч по-прежнему можно использовать для запросов других значений квантилей, например `quantile(0.95)`. Рекомендуется поэкспериментировать, чтобы найти оптимальный баланс для вашей нагрузки.

### Постоянно проверяйте эффективность \{#validate-effectiveness-continously\}

Всегда убеждайтесь, что materialized views дают реальный эффект:

- Проверяйте использование через индикаторы ускорения в UI.
- Сравнивайте производительность запросов до и после включения view.
- Отслеживайте использование ресурсов и поведение операций слияния.

Относитесь к materialized views как к оптимизациям производительности, которые требуют периодического пересмотра и настройки по мере изменения шаблонов запросов.

### Расширенные конфигурации \{#advanced-configurations\}

Для более сложных нагрузок можно использовать несколько materialized views для поддержки разных сценариев доступа. Примеры включают:

- **Данные с высокой детализацией за недавний период и укрупнённые представления за исторический период**
- **Представления на уровне сервисов для обзора и представления на уровне эндпоинтов для глубокой диагностики**

Эти подходы могут значительно улучшить производительность при выборочном применении, но их следует использовать только после проверки более простых конфигураций.

Следование этим рекомендациям поможет обеспечить, что materialized views останутся эффективными, удобными в сопровождении и согласованными с моделью выполнения ClickStack.

## Ограничения \{#limitations\}

### Распространённые причины несовместимости \{#common-incompatibility-reasons\}

materialized view **не будет** использоваться, если выполняется любое из следующих условий:

- **Диапазон времени запроса**  
  Начало временного диапазона запроса предшествует минимальной временной метке materialized view. Поскольку представления не заполняются историческими данными автоматически, они могут обслуживать только запросы для тех временных диапазонов, которые полностью покрывают.

- **Несоответствие гранулярности**  
  Эффективная гранулярность визуализации должна быть целым кратным гранулярности materialized view. В частности:

  * Для **временных графиков** (линейных или столбчатых графиков с временем по оси x) выбранная гранулярность графика должна быть кратна гранулярности представления. Например, 10-минутный график может использовать materialized view с гранулярностью 10, 5, 2 или 1 минута, но не 20 минут или 3 минуты.
  * Для **невременных графиков** (графики-числа или таблицы) эффективная гранулярность вычисляется как `(time range / 80)`, округляется вверх до ближайшей гранулярности, поддерживаемой HyperDX, и также должна быть кратна гранулярности представления.

- **Неподдерживаемые агрегирующие функции**  
  В запросе запрашивается агрегация, которая отсутствует в materialized view. Можно использовать только те агрегации, которые явно вычисляются и хранятся в представлении.

- **Пользовательские выражения подсчёта**  
  Запросы, использующие выражения вида `count(if(...))` или другие условные подсчёты, не могут быть получены из стандартных состояний агрегации и поэтому не могут использовать materialized view.

### Проектные и эксплуатационные ограничения \{#design-and-operational-constraints\}

- **Отсутствие автоматического backfilling**
  Incremental materialized views содержат только данные, вставленные после их создания. Для ускорения запросов по историческим данным требуется явный backfilling, который может быть дорогостоящим или непрактичным для крупных наборов данных.

- **Компромиссы по гранулярности**
  Представления с очень высокой гранулярностью увеличивают размер хранилища данных и накладные расходы на вставку, в то время как представления с грубой гранулярностью уменьшают гибкость. Гранулярность необходимо тщательно подбирать в соответствии с ожидаемыми шаблонами запросов.

- **Взрыв размерности**
  Добавление большого числа группирующих измерений значительно увеличивает размер представления и может снизить его эффективность. Представления должны включать только часто используемые столбцы для группировки и фильтрации.

- **Ограниченная масштабируемость по количеству представлений**
  Каждое materialized view добавляет накладные расходы при вставке и увеличивает нагрузку на слияния. Создание слишком большого числа представлений может негативно повлиять на ингестию и фоновые слияния.

Понимание этих ограничений помогает применять materialized views там, где они дают реальную выгоду, и избегать конфигураций, которые незаметно приводят к переключению на более медленные запросы к исходной таблице.

## Устранение неполадок \{#troubleshooting\}

### materialized view не используется \{#materialied-view-not-being-used\}

**Проверка 1: диапазон дат**

- Откройте модальное окно оптимизации и проверьте, не отображается ли сообщение «Date range not supported».
- Убедитесь, что диапазон дат запроса начинается после минимальной даты materialized view.
- Уберите минимальную дату, если materialized view содержит все исторические данные.

**Проверка 2: гранулярность**

- Проверьте, что гранулярность графика кратна гранулярности MV.
- Попробуйте установить для графика значение «Auto» или вручную выбрать совместимую гранулярность.

**Проверка 3: агрегации**

- Проверьте, использует ли график агрегации, которые есть в MV.
- Просмотрите «Available aggregated columns» в модальном окне оптимизации.

**Проверка 4: измерения**

- Убедитесь, что столбцы из `GROUP BY` присутствуют в столбцах измерений MV.
- Проверьте «Available group/filter columns» в модальном окне оптимизации.

### Медленные запросы к materialized view \{#slow-mv-queries\}

**Проблема 1: слишком мелкая гранулярность materialized view**

- У materialized view слишком много строк из-за слишком мелкой гранулярности (например, 1 секунда).
- Решение: создайте более крупную materialized view (например, с гранулярностью 1 минута или 1 час).

**Проблема 2: слишком много измерений**

- У materialized view высокая кардинальность из-за большого числа столбцов измерений.
- Решение: сократите количество столбцов измерений до наиболее часто используемых.

**Проблема 3: несколько materialized view с большим количеством строк**

- Система выполняет `EXPLAIN` для каждой materialized view.
- Решение: удалите materialized view, которые редко используются или всегда пропускаются.

### Ошибки конфигурации \{#config-errors\}

**Ошибка: "At least one aggregated column is required"**

- Добавьте по крайней мере один агрегированный столбец в конфигурацию MV.

**Ошибка: "Source column is required for non-count aggregations"**

- Укажите, какой столбец агрегировать (только для count можно не указывать исходный столбец).

**Ошибка: "Invalid granularity format"**

- Используйте одну из предустановленных гранулярностей из выпадающего списка.
- Формат должен быть допустимым SQL-интервалом (например, `1 hour`, а не `1 h`).
---
title: 'Введение'
description: 'Использование ClickHouse как платформы для наблюдаемости'
slug: /use-cases/observability/introduction
keywords: ['observability', 'logs', 'traces', 'metrics', 'OpenTelemetry', 'Grafana', 'OTel']
show_related_blogs: true
doc_type: 'guide'
---

import observability_1 from '@site/static/images/use-cases/observability/observability-1.png';
import observability_2 from '@site/static/images/use-cases/observability/observability-2.png';
import Image from '@theme/IdealImage';


# Использование ClickHouse для задач наблюдаемости



## Введение {#introduction}

Это руководство предназначено для пользователей, которые хотят создать собственное решение для наблюдаемости на основе SQL с использованием ClickHouse, с акцентом на логи и трассировки. Оно охватывает все аспекты создания собственного решения, включая вопросы приёма данных, оптимизации схем под ваши паттерны доступа и извлечения структуры из неструктурированных логов.

ClickHouse сам по себе не является готовым решением для наблюдаемости. Однако он может использоваться как высокоэффективный движок хранения данных наблюдаемости, обеспечивающий непревзойдённые коэффициенты сжатия и молниеносное время отклика на запросы. Для использования ClickHouse в решении для наблюдаемости требуются как пользовательский интерфейс, так и фреймворк сбора данных. В настоящее время мы рекомендуем использовать **Grafana** для визуализации сигналов наблюдаемости и **OpenTelemetry** для сбора данных (обе интеграции официально поддерживаются).

<Image img={observability_1} alt='Simple OTel' size='md' />

<br />

:::note Не только OpenTelemetry
Хотя мы рекомендуем использовать проект OpenTelemetry (OTel) для сбора данных, аналогичные архитектуры могут быть построены с использованием других фреймворков и инструментов, например Vector и Fluentd (см. [пример](https://clickhouse.com/blog/kubernetes-logs-to-clickhouse-fluent-bit) с Fluent Bit). Также существуют альтернативные инструменты визуализации, включая Superset и Metabase.
:::


## Почему стоит использовать ClickHouse? {#why-use-clickhouse}

Наиболее важной особенностью любого централизованного хранилища данных наблюдаемости является его способность быстро агрегировать, анализировать и осуществлять поиск в огромных объёмах журналов из различных источников. Такая централизация упрощает устранение неполадок, облегчая выявление первопричин сбоев в работе сервисов.

Поскольку пользователи становятся всё более чувствительными к ценам и считают стоимость готовых решений высокой и непредсказуемой по сравнению с приносимой ими ценностью, экономичное и предсказуемое хранилище журналов с приемлемой производительностью запросов ценится как никогда.

Благодаря своей производительности и экономической эффективности ClickHouse стал де-факто стандартом для движков хранения журналов и трассировок в продуктах наблюдаемости.

Более конкретно, следующие характеристики делают ClickHouse идеально подходящим для хранения данных наблюдаемости:

- **Сжатие** — данные наблюдаемости обычно содержат поля, значения которых берутся из ограниченного набора, например HTTP-коды или имена сервисов. Колоночное хранилище ClickHouse, где значения хранятся отсортированными, обеспечивает исключительно эффективное сжатие этих данных — особенно в сочетании с набором специализированных кодеков для данных временных рядов. В отличие от других хранилищ данных, которые требуют столько же места, сколько занимают исходные данные, обычно в формате JSON, ClickHouse сжимает журналы и трассировки в среднем в 14 раз. Помимо значительной экономии места для крупных установок наблюдаемости, это сжатие способствует ускорению запросов, поскольку с диска требуется считывать меньше данных.
- **Быстрые агрегации** — решения наблюдаемости обычно активно используют визуализацию данных с помощью графиков, например линий, показывающих частоту ошибок, или столбчатых диаграмм, отображающих источники трафика. Агрегации, или GROUP BY, являются основой для построения этих графиков, которые также должны быть быстрыми и отзывчивыми при применении фильтров в рабочих процессах диагностики проблем. Колоночный формат ClickHouse в сочетании с векторизованным движком выполнения запросов идеально подходит для быстрых агрегаций, а разреженная индексация позволяет быстро фильтровать данные в ответ на действия пользователей.
- **Быстрое линейное сканирование** — в то время как альтернативные технологии полагаются на инвертированные индексы для быстрого запроса журналов, это неизменно приводит к высокой нагрузке на диск и ресурсы. Хотя ClickHouse предоставляет инвертированные индексы в качестве дополнительного опционального типа индекса, линейное сканирование выполняется с высокой степенью параллелизма и использует все доступные ядра на машине (если не настроено иначе). Это потенциально позволяет сканировать десятки ГБ/с (в сжатом виде) для поиска совпадений с помощью [высокооптимизированных операторов сопоставления текста](/sql-reference/functions/string-search-functions).
- **Знакомство с SQL** — SQL является повсеместно распространённым языком, с которым знакомы все инженеры. За более чем 50 лет развития он зарекомендовал себя как де-факто язык для аналитики данных и остаётся [третьим по популярности языком программирования](https://clickhouse.com/blog/the-state-of-sql-based-observability#lingua-franca). Наблюдаемость — это просто ещё одна задача работы с данными, для которой SQL идеально подходит.
- **Аналитические функции** — ClickHouse расширяет ANSI SQL аналитическими функциями, разработанными для упрощения написания SQL-запросов. Они необходимы пользователям, выполняющим анализ первопричин, где данные нужно разрезать и анализировать с разных сторон.
- **Вторичные индексы** — ClickHouse поддерживает вторичные индексы, такие как фильтры Блума, для ускорения определённых профилей запросов. Их можно опционально включить на уровне столбца, предоставляя пользователю детальный контроль и позволяя оценить соотношение затрат и производительности.
- **Открытый исходный код и открытые стандарты** — как база данных с открытым исходным кодом, ClickHouse поддерживает открытые стандарты, такие как OpenTelemetry. Возможность вносить вклад и активно участвовать в проектах привлекательна, при этом позволяя избежать проблем привязки к поставщику.


## Когда следует использовать ClickHouse для наблюдаемости {#when-should-you-use-clickhouse-for-observability}

Использование ClickHouse для данных наблюдаемости требует от пользователей перехода на наблюдаемость на основе SQL. Рекомендуем ознакомиться с [этой статьёй в блоге](https://clickhouse.com/blog/the-state-of-sql-based-observability), чтобы узнать историю наблюдаемости на основе SQL, но вкратце:

Наблюдаемость на основе SQL подходит вам, если:

- Вы или ваша команда знакомы с SQL (или хотите его освоить)
- Вы предпочитаете придерживаться открытых стандартов, таких как OpenTelemetry, чтобы избежать привязки к поставщику и обеспечить расширяемость.
- Вы готовы работать с экосистемой, основанной на инновациях с открытым исходным кодом — от сбора до хранения и визуализации.
- Вы ожидаете роста до средних или больших объёмов управляемых данных наблюдаемости (или даже очень больших объёмов)
- Вы хотите контролировать TCO (совокупную стоимость владения) и избежать неконтролируемого роста затрат на наблюдаемость.
- Вы не можете или не хотите ограничиваться короткими периодами хранения данных наблюдаемости только ради управления затратами.

Наблюдаемость на основе SQL может не подойти вам, если:

- Изучение (или генерация!) SQL не привлекает вас или вашу команду.
- Вы ищете готовое комплексное решение для наблюдаемости.
- Ваши объёмы данных наблюдаемости слишком малы, чтобы иметь существенное значение (например, &lt;150 ГиБ), и не ожидается их рост.
- Ваш сценарий использования ориентирован на метрики и требует PromQL. В этом случае вы всё равно можете использовать ClickHouse для логов и трассировки наряду с Prometheus для метрик, объединяя их на уровне представления с помощью Grafana.
- Вы предпочитаете подождать, пока экосистема станет более зрелой, а наблюдаемость на основе SQL — более готовой к использованию.


## Логи и трассировки {#logs-and-traces}

Сценарий использования Observability включает три основных направления: логирование, трассировку и метрики. Каждое из них имеет свои типы данных и паттерны доступа.

В настоящее время мы рекомендуем использовать ClickHouse для хранения двух типов данных observability:

- **Логи** — логи представляют собой записи событий с временными метками, происходящих в системе, и фиксируют подробную информацию о различных аспектах работы программного обеспечения. Данные в логах обычно неструктурированы или полуструктурированы и могут включать сообщения об ошибках, журналы активности пользователей, изменения системы и другие события. Логи критически важны для устранения неполадок, обнаружения аномалий и понимания конкретных событий, приводящих к проблемам в системе.

```response
54.36.149.41 - - [22/Jan/2019:03:56:14 +0330] "GET
/filter/27|13%20%D9%85%DA%AF%D8%A7%D9%BE%DB%8C%DA%A9%D8%B3%D9%84,27|%DA%A9%D9%85%D8%AA%D8%B1%20%D8%A7%D8%B2%205%20%D9%85%DA%AF%D8%A7%D9%BE%DB%8C%DA%A9%D8%B3%D9%84,p53 HTTP/1.1" 200 30577 "-" "Mozilla/5.0 (compatible; AhrefsBot/6.1; +http://ahrefs.com/robot/)" "-"
```

- **Трассировки** — трассировки фиксируют путь запросов при их прохождении через различные сервисы в распределённой системе, детализируя маршрут и производительность этих запросов. Данные в трассировках высоко структурированы и состоят из спанов и трассировок, которые отображают каждый шаг запроса, включая информацию о времени выполнения. Трассировки предоставляют ценную информацию о производительности системы, помогая выявлять узкие места, проблемы с задержками и оптимизировать эффективность микросервисов.

:::note Метрики
Хотя ClickHouse можно использовать для хранения данных метрик, это направление менее развито в ClickHouse, и ожидается поддержка таких функций, как формат данных Prometheus и PromQL.
:::

### Распределённая трассировка {#distributed-tracing}

Распределённая трассировка является критически важной функцией Observability. Распределённая трассировка, или просто трассировка, отображает путь запроса через систему. Запрос исходит от конечного пользователя или приложения и распространяется по всей системе, обычно приводя к потоку действий между микросервисами. Записывая эту последовательность и позволяя коррелировать последующие события, она даёт возможность пользователю observability или SRE диагностировать проблемы в потоке приложения независимо от того, насколько сложной или бессерверной является архитектура.

Каждая трассировка состоит из нескольких спанов, при этом начальный спан, связанный с запросом, называется корневым спаном. Этот корневой спан фиксирует весь запрос от начала до конца. Последующие спаны под корневым предоставляют подробную информацию о различных шагах или операциях, которые происходят во время запроса. Без трассировки диагностика проблем производительности в распределённой системе может быть чрезвычайно сложной. Трассировка упрощает процесс отладки и понимания распределённых систем, детализируя последовательность событий в запросе по мере его прохождения через систему.

Большинство поставщиков решений observability визуализируют эту информацию в виде каскада, где относительное время показано с помощью горизонтальных полос пропорционального размера. Например, в Grafana:

<Image img={observability_2} alt='Example trace' size='lg' border />

Для пользователей, которым необходимо глубоко ознакомиться с концепциями логов и трассировок, мы настоятельно рекомендуем [документацию OpenTelemetry](https://opentelemetry.io/docs/concepts/).

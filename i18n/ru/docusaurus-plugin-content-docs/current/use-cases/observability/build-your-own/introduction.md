---
title: 'Введение'
description: 'Использование ClickHouse как решения для наблюдаемости'
slug: /use-cases/observability/introduction
keywords: ['наблюдаемость', 'логи', 'трейсы', 'метрики', 'OpenTelemetry', 'Grafana', 'OTel']
show_related_blogs: true
doc_type: 'guide'
---

import observability_1 from '@site/static/images/use-cases/observability/observability-1.png';
import observability_2 from '@site/static/images/use-cases/observability/observability-2.png';
import Image from '@theme/IdealImage';


# Использование ClickHouse для задач наблюдаемости



## Введение {#introduction}

Это руководство предназначено для пользователей, которые хотят построить собственное решение для наблюдаемости на основе SQL с использованием ClickHouse, с фокусом на логах и трейcах. В нём рассматриваются все аспекты построения собственного решения, включая вопросы, связанные с ингестией, оптимизацией схем под ваши сценарии доступа и извлечением структуры из неструктурированных логов.

Сам по себе ClickHouse не является готовым решением для наблюдаемости «из коробки». Однако его можно использовать в качестве высокоэффективного движка хранения данных для наблюдаемости, обеспечивающего непревзойдённые уровни сжатия и молниеносное время отклика на запросы. Чтобы пользователи могли использовать ClickHouse в составе решения наблюдаемости, необходимы и пользовательский интерфейс, и фреймворк для сбора данных. В настоящее время мы рекомендуем использовать **Grafana** для визуализации сигналов наблюдаемости и **OpenTelemetry** для сбора данных (обе интеграции официально поддерживаются).

<Image img={observability_1} alt="Простой OTel" size="md"/>

<br />

:::note Не только OpenTelemetry
Хотя мы и рекомендуем использовать проект OpenTelemetry (OTel) для сбора данных, похожие архитектуры можно реализовать с помощью других фреймворков и инструментов, например, Vector и Fluentd (см. [пример](https://clickhouse.com/blog/kubernetes-logs-to-clickhouse-fluent-bit) c Fluent Bit). Существуют и альтернативные средства визуализации, включая Superset и Metabase.
:::



## Зачем использовать ClickHouse? {#why-use-clickhouse}

Наиболее важная особенность любого централизованного хранилища данных наблюдаемости — его способность быстро агрегировать, анализировать и искать огромные объемы логов из разнообразных источников. Такая централизация упрощает устранение неполадок, позволяя легче находить первопричины сбоев сервисов.

Поскольку пользователи становятся все более чувствительными к цене и воспринимают стоимость готовых решений как высокую и непредсказуемую по сравнению с получаемой ценностью, экономичное и предсказуемое хранилище логов с приемлемой производительностью запросов становится важнее, чем когда-либо прежде.

Благодаря своей производительности и эффективности с точки зрения затрат ClickHouse стал де-факто стандартом для движков хранения логов и трейсов в продуктах для наблюдаемости.

Более конкретно, следующие свойства делают ClickHouse идеальным для хранения данных наблюдаемости:

- **Сжатие** — Данные Observability обычно содержат поля, значения которых берутся из ограниченного набора, например HTTP-коды или имена сервисов. Колонко-ориентированное хранение ClickHouse, при котором значения хранятся в отсортированном виде, приводит к тому, что такие данные очень хорошо сжимаются — особенно в сочетании с набором специализированных кодеков для временных рядов. В отличие от других хранилищ данных, которым требуется объем, сопоставимый с исходным размером данных (как правило, в формате JSON), ClickHouse в среднем сжимает логи и трейсы до 14 раз. Помимо существенной экономии дискового пространства для крупных установок Observability, это сжатие ускоряет выполнение запросов, так как с диска нужно читать меньше данных.
- **Быстрые агрегации** — Решения для Observability, как правило, широко используют визуализацию данных в виде графиков, например линий с показателями ошибок или столбчатых диаграмм с источниками трафика. Агрегации, или GROUP BY, лежат в основе таких графиков, которые также должны быть быстрыми и отзывчивыми при применении фильтров в рабочих процессах диагностики инцидентов. Колонко-ориентированный формат ClickHouse в сочетании с векторизированным движком выполнения запросов оптимален для быстрых агрегаций, а разреженная индексация обеспечивает быстрое фильтрование данных в ответ на действия пользователей.
- **Быстрые линейные сканирования** — В то время как альтернативные технологии полагаются на инвертированные индексы для быстрого поиска по логам, это неизбежно приводит к высокому использованию диска и ресурсов. Хотя ClickHouse предоставляет инвертированные индексы как дополнительный опциональный тип индекса, линейные сканирования сильно распараллелены и используют все доступные ядра машины (если не настроено иначе). Это потенциально позволяет сканировать десятки ГБ/с (в сжатом виде) в поиске совпадений с использованием [высокооптимизированных операторов для поиска по тексту](/sql-reference/functions/string-search-functions).
- **Привычность SQL** — SQL — повсеместный язык, с которым знакомы все инженеры. За более чем 50 лет развития он зарекомендовал себя как де-факто язык для аналитики данных и остается [3-м по популярности языком программирования](https://clickhouse.com/blog/the-state-of-sql-based-observability#lingua-franca). Observability — всего лишь еще одна задача работы с данными, для которой SQL идеально подходит.
- **Аналитические функции** — ClickHouse расширяет ANSI SQL аналитическими функциями, призванными упростить и облегчить написание SQL-запросов. Они необходимы пользователям, выполняющим анализ первопричин, когда данные нужно исследовать под разными разрезами.
- **Вторичные индексы** — ClickHouse поддерживает вторичные индексы, такие как фильтры Блума, для ускорения конкретных профилей запросов. Их можно опционально включать на уровне отдельных колонок, предоставляя пользователю тонкий контроль и позволяя оценивать баланс между стоимостью и производительностью.
- **Open-source и открытые стандарты** — Будучи базой данных с открытым исходным кодом, ClickHouse следует открытым стандартам, таким как OpenTelemetry. Возможность вносить вклад и активно участвовать в развитии проектов привлекает пользователей, при этом удается избежать проблем зависимости от конкретного вендора.



## Когда стоит использовать ClickHouse для наблюдаемости {#when-should-you-use-clickhouse-for-observability}

Использование ClickHouse для данных наблюдаемости предполагает переход к наблюдаемости на основе SQL. Для ознакомления с историей такого подхода рекомендуем [эту статью в блоге](https://clickhouse.com/blog/the-state-of-sql-based-observability), а вкратце:

Наблюдаемость на основе SQL подходит вам, если:

- Вы или ваша команда (команды) знакомы с SQL (или хотите его изучить).
- Вы предпочитаете придерживаться открытых стандартов, таких как OpenTelemetry, чтобы избежать привязки к вендору и обеспечить расширяемость.
- Вы готовы использовать и развивать экосистему, основанную на инновациях open source, от сбора до хранения и визуализации.
- Вы ожидаете рост до средних или больших объемов данных наблюдаемости (или даже очень больших объемов).
- Вы хотите контролировать TCO (total cost of ownership — совокупную стоимость владения) и избегать неконтролируемого роста затрат на наблюдаемость.
- Вы не можете или не хотите мириться с короткими сроками хранения данных наблюдаемости только ради снижения затрат.

Наблюдаемость на основе SQL может не подойти вам, если:

- Изучение (или генерация!) SQL не привлекает вас или вашу команду (команды).
- Вы ищете готовое, комплексное решение для наблюдаемости.
- Объемы ваших данных наблюдаемости слишком малы, чтобы давать какой-либо существенный эффект (например, &lt;150 GiB), и не ожидается их рост.
- Ваш сценарий сильно ориентирован на метрики и требует PromQL. В этом случае вы всё ещё можете использовать ClickHouse для логов и трассировок вместе с Prometheus для метрик, объединяя всё на уровне представления с помощью Grafana.
- Вы предпочитаете подождать, пока экосистема станет более зрелой, а наблюдаемость на основе SQL — более готовой «из коробки».



## Логи и трейсы

Сценарий Observability опирается на три основных компонента: логирование, трассировку и метрики. У каждого из них свои типы данных и модели доступа.

В настоящее время мы рекомендуем использовать ClickHouse для хранения двух типов данных наблюдаемости:

* **Logs** — логи — это записи событий с временными метками, происходящих в системе, фиксирующие детальную информацию о различных аспектах работы программного обеспечения. Данные в логах, как правило, неструктурированные или полуструктурированные и могут включать сообщения об ошибках, логи пользовательской активности, изменения в системе и другие события. Логи критически важны для устранения неполадок, обнаружения аномалий и понимания конкретных событий, предшествовавших возникновению проблем в системе.

```response
54.36.149.41 - - [22/Jan/2019:03:56:14 +0330] "GET
/filter/27|13%20%D9%85%DA%AF%D8%A7%D9%BE%DB%8C%DA%A9%D8%B3%D9%84,27|%DA%A9%D9%85%D8%AA%D8%B1%20%D8%A7%D8%B2%205%20%D9%85%DA%AF%D8%A7%D9%BE%DB%8C%DA%A9%D8%B3%D9%84,p53 HTTP/1.1" 200 30577 "-" "Mozilla/5.0 (compatible; AhrefsBot/6.1; +http://ahrefs.com/robot/)" "-"
```

* **Трейсы** — Трейсы фиксируют путь запросов через различные сервисы в распределённой системе, детализируя маршрут и характеристики производительности этих запросов. Данные в трейсах строго структурированы и состоят из спанов и трейсов, которые отображают каждый шаг выполнения запроса, включая временные характеристики. Трейсы предоставляют ценные сведения о производительности системы, помогая выявлять узкие места, проблемы с задержками и оптимизировать эффективность микросервисов.

:::note Metrics
Хотя ClickHouse может использоваться для хранения метрик, этот аспект наблюдаемости в ClickHouse пока менее развит: ожидается поддержка таких возможностей, как работа с форматом данных Prometheus и PromQL.
:::

### Распределённая трассировка

Распределённая трассировка — критически важная функция наблюдаемости. Распределённый трейс, который обычно называют просто трейсом, отображает путь запроса через систему. Запрос может исходить от конечного пользователя или приложения и распространяться по системе, что обычно приводит к цепочке действий между микросервисами. Благодаря записи этой последовательности и возможности последующей корреляции событий пользователь системы наблюдаемости или SRE может диагностировать проблемы в потоке выполнения приложения независимо от того, насколько сложна архитектура или насколько она основана на бессерверных (serverless) компонентах.

Каждый трейс состоит из нескольких спанов, при этом исходный спан, связанный с запросом, называется корневым (root span). Этот корневой спан охватывает весь запрос от начала до конца. Последующие спаны под корнем дают детализированное представление о различных шагах или операциях, которые выполняются в ходе обработки запроса. Без трассировки диагностика проблем с производительностью в распределённой системе может быть чрезвычайно сложной. Трассировка упрощает отладку и понимание распределённых систем, детализируя последовательность событий в рамках запроса по мере его прохождения через систему.

Большинство вендоров решений для наблюдаемости визуализируют эту информацию в виде каскада (waterfall‑диаграммы), при этом относительные временные интервалы отображаются горизонтальными полосами пропорциональной длины. Например, в Grafana:

<Image img={observability_2} alt="Пример трейса" size="lg" border />

Пользователям, которым необходимо более глубоко ознакомиться с концепциями логов и трейсов, мы настоятельно рекомендуем [документацию OpenTelemetry](https://opentelemetry.io/docs/concepts/).

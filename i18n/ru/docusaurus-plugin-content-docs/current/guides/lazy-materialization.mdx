---
slug: /optimize/lazy-materialization
sidebar_label: 'Ленивая материализация'
description: 'Статья, описывающая, что такое ленивая материализация в ClickHouse'
title: 'Ленивая материализация'
doc_type: 'guide'
keywords: ['оптимизация', 'ленивая материализация']
---

В этой статье описывается, как работает ленивая материализация и как она вписывается в более широкий стек оптимизаций ввода-вывода ClickHouse.
Приводится практический пример, демонстрирующий, как ленивая материализация повышает производительность запросов.

:::tip[Доступно начиная с версии 25.4]
Ленивая материализация была представлена в версии 25.4 ClickHouse и включена по умолчанию.
:::

## Обзор \{#overview\}

За прошедшие годы ClickHouse внедрил ряд многоуровневых оптимизаций для агрессивного снижения объёма операций ввода-вывода (I/O).
Эти подходы составляют основу его скорости и эффективности:

| Optimization | Description |
|---|---|
| [**Columnar storage**](/intro#row-oriented-vs-column-oriented-storage) | Позволяет пропускать целые столбцы, которые не нужны для запроса, а также обеспечивает высокую степень сжатия за счёт группировки похожих значений, минимизируя I/O при загрузке данных. |
| [**Sparse primary indexes**](/guides/best-practices/sparse-primary-indexes) \| [**secondary data-skipping indexes**](/optimize/skipping-indexes) \| [**projections**](/data-modeling/projections) | Отбрасывают нерелевантные данные, определяя, какие [granules](/concepts/glossary#granule) (блоки строк) могут соответствовать фильтрам по _индексированным столбцам_. Эти методы работают на уровне гранул и могут использоваться по отдельности или в комбинации. |
| [**PREWHERE**](/sql-reference/statements/select/prewhere) | Также проверяет совпадения для фильтров по _неиндексированным_ столбцам, чтобы как можно раньше пропускать данные, которые в противном случае были бы загружены и затем отброшены. Может работать независимо или уточнять гранулы, выбранные индексами, дополняя отсечение гранул пропуском строк, которые не соответствуют _всем_ фильтрам по столбцам. |
| [**Query condition cache**](/operations/query-condition-cache) | Ускоряет повторяющиеся запросы, запоминая, какие гранулы в прошлый раз соответствовали всем фильтрам. Благодаря этому ClickHouse может пропускать чтение и фильтрацию гранул, которые не совпали, даже если форма запроса изменилась. |

Хотя перечисленные выше оптимизации I/O могут существенно сократить объём читаемых данных, они по-прежнему предполагают, что все столбцы для строк, прошедших условие `WHERE`, должны быть загружены до выполнения таких операций, как сортировка, агрегация или `LIMIT`. Но что, если некоторые столбцы не нужны до более позднего этапа, или часть данных, хотя и проходит условие `WHERE`, на самом деле никогда не требуется?
Здесь вступает в действие отложенная материализация (lazy materialization). Это ортогональное улучшение, завершающее стек оптимизаций I/O:

- Индексация вместе с `PREWHERE` гарантирует, что обрабатываются только строки, соответствующие фильтрам по столбцам в `WHERE`.
- Отложенная материализация развивает этот подход, откладывая чтение столбцов до тех пор, пока они действительно не понадобятся в соответствии с планом выполнения запроса.
  Даже после фильтрации сразу загружаются только те столбцы, которые нужны для следующей операции — например, сортировки.
  Остальные откладываются и, благодаря `LIMIT`, часто читаются лишь частично — ровно настолько, насколько нужно для получения итогового результата.
  Это делает отложенную материализацию особенно эффективной для запросов класса Top N, когда для итогового результата может потребоваться всего несколько строк из некоторых, часто очень больших, столбцов.

## Подробный пример \{#worked-example\}

Мы настоятельно рекомендуем публикацию в блоге [&quot;ClickHouse gets lazier (and faster): Introducing lazy materialization&quot;](https://clickhouse.com/blog/clickhouse-gets-lazier-and-faster-introducing-lazy-materialization#speed-without-filters-lazy-materialization-in-isolation)
для детального разбора ленивой материализации. Приведённый ниже пример взят из упомянутого блог-поста и приведён здесь, чтобы продемонстрировать, как время выполнения запроса в ClickHouse может сократиться с 219 секунд до всего 139 миллисекунд (ускорение в 1576 раз) благодаря ленивой материализации.

Чтобы получить преимущества от индексации и `PREWHERE`, запросу нужны фильтры: по столбцам первичного ключа для индексации и по любым столбцам для `PREWHERE`.
Ленивая материализация органично дополняет эти механизмы, но, в отличие от других упомянутых ранее оптимизаций, она может ускорять запросы и вообще без фильтров по столбцам.

Рассмотрим следующий пример запроса, который находит отзывы Amazon с наибольшим числом голосов «полезно», независимо от даты, товара, оценки или статуса верификации, и возвращает топ-3 вместе с их заголовком, подзаголовком и полным текстом.

Сначала выполним запрос (с холодным файловым кэшем) при отключённой ленивой материализации (с использованием [`query_plan_optimize_lazy_materialization`](/operations/settings/settings#query_plan_optimize_lazy_materialization)):

```sql title="Query"
SELECT
    helpful_votes,
    product_title,
    review_headline,
    review_body
FROM amazon.amazon_reviews
ORDER BY helpful_votes DESC
LIMIT 3
FORMAT Vertical
SETTINGS
    query_plan_optimize_lazy_materialization = false;
```

```response title="Response"
Row 1:
──────
helpful_votes:   47524
product_title:   Kindle: Amazon's Original Wireless Reading Device (1st generation)
review_headline: Why and how the Kindle changes everything
review_body:     This is less a \"pros and cons\" review than a hopefully use...

Row 2:
──────
helpful_votes:   41393
product_title:   BIC Cristal For Her Ball Pen, 1.0mm, Black, 16ct (MSLP16-Blk)
review_headline: FINALLY!
review_body:     Someone has answered my gentle prayers and FINALLY designed ...

Row 3:
──────
helpful_votes:   41278
product_title:   The Mountain Kids 100% Cotton Three Wolf Moon T-Shirt
review_headline: Dual Function Design
review_body:     This item has wolves on it which makes it intrinsically swee...

# highlight-start
0 rows in set. Elapsed: 219.071 sec. Processed 150.96 million rows, 71.38 GB (689.08 thousand rows/s., 325.81 MB/s.)
Peak memory usage: 1.11 GiB.
# highlight-end
```

Затем запрос выполняется повторно (снова с холодным файловым кэшем), но теперь с включённой отложенной материализацией:

```sql title="Query"
SELECT
    helpful_votes,
    product_title,
    review_headline,
    review_body
FROM amazon.amazon_reviews
ORDER BY helpful_votes DESC
LIMIT 3
FORMAT Vertical
SETTINGS
-- highlight-next-line
query_plan_optimize_lazy_materialization = true;
```

:::tip
Обычно вам не нужно явно устанавливать `query_plan_optimize_lazy_materialization = true`, чтобы воспользоваться преимуществами ленивой материализации.
Этот параметр включён по умолчанию.
:::

```response title="Response"
Row 1:
──────
helpful_votes:   47524
product_title:   Kindle: Amazon's Original Wireless Reading Device (1st generation)
review_headline: Why and how the Kindle changes everything
review_body:     This is less a \"pros and cons\" review than a hopefully use...

Row 2:
──────
helpful_votes:   41393
product_title:   BIC Cristal For Her Ball Pen, 1.0mm, Black, 16ct (MSLP16-Blk)
review_headline: FINALLY!
review_body:     Someone has answered my gentle prayers and FINALLY designed ...

Row 3:
──────
helpful_votes:   41278
product_title:   The Mountain Kids 100% Cotton Three Wolf Moon T-Shirt
review_headline: Dual Function Design
review_body:     This item has wolves on it which makes it intrinsically swee...

# highlight-start
0 rows in set. Elapsed: 0.139 sec. Processed 150.96 million rows, 1.81 GB (1.09 billion rows/s., 13.06 GB/s.)
Peak memory usage: 3.80 MiB.
# highlight-end
```

Рассмотрим разницу в производительности при выключенной и включённой отложенной материализации:


| Метрика | Ленивая материализация выключена | Ленивая материализация включена | Улучшение |
|---|---|---|---|
| Время выполнения | 219.071 sec | 0.139 sec | ~1576× быстрее |
| Объём прочитанных данных | 71.38 GB | 1.81 GB | ~40× меньше |
| Пиковое потребление памяти | 1.11 GiB | 3.80 MiB | ~300× меньше |

## Как подтвердить ленивую материализацию в плане выполнения запроса \{#confirm-lazy-materialization\}

Вы можете убедиться, что для предыдущего запроса используется ленивая материализация, проанализировав его логический план выполнения с помощью предложения [`EXPLAIN`](/sql-reference/statements/explain):

```sql
EXPLAIN actions = 1
SELECT
    helpful_votes,
    product_title,
    review_headline,
    review_body
FROM amazon.amazon_reviews
ORDER BY helpful_votes DESC
LIMIT 3
SETTINGS
    query_plan_optimize_lazy_materialization = true;
```

```response
...
# highlight-next-line
Lazily read columns: review_headline, review_body, product_title
  Limit
    Sorting
      ReadFromMergeTree
```

Вы можете читать план операторов снизу вверх и увидеть, что ClickHouse откладывает чтение трёх больших столбцов типа String до выполнения сортировки и ограничения.

---
slug: /optimize/prewhere
sidebar_label: 'Оптимизация PREWHERE'
sidebar_position: 21
description: 'PREWHERE снижает объем операций ввода-вывода, избегая чтения лишних данных столбцов.'
title: 'Как работает оптимизация PREWHERE?'
doc_type: 'guide'
keywords: ['prewhere', 'query optimization', 'performance', 'filtering', 'best practices']
---

import visual01 from '@site/static/images/guides/best-practices/prewhere_01.gif';
import visual02 from '@site/static/images/guides/best-practices/prewhere_02.gif';
import visual03 from '@site/static/images/guides/best-practices/prewhere_03.gif';
import visual04 from '@site/static/images/guides/best-practices/prewhere_04.gif';
import visual05 from '@site/static/images/guides/best-practices/prewhere_05.gif';

import Image from '@theme/IdealImage';


# Как работает оптимизация PREWHERE?

[Клауза PREWHERE](/sql-reference/statements/select/prewhere) — это оптимизация выполнения запросов в ClickHouse. Она сокращает операции ввода-вывода и повышает скорость выполнения запросов за счёт избежания ненужного чтения данных и отфильтровывания несущественных данных до чтения не фильтрующих столбцов с диска.

В этом руководстве объясняется, как работает PREWHERE, как измерить её влияние и как настроить её для достижения наилучшей производительности.



## Обработка запроса без оптимизации PREWHERE {#query-processing-without-prewhere-optimization}

Начнем с того, как обрабатывается запрос к таблице [uk_price_paid_simple](/parts) без использования PREWHERE:

<Image
  img={visual01}
  size='md'
  alt='Обработка запроса без оптимизации PREWHERE'
/>

<br />
<br />① Запрос содержит фильтр по столбцу `town`, который входит в состав первичного ключа таблицы и, следовательно, также является частью первичного индекса.

② Для ускорения запроса ClickHouse загружает первичный индекс таблицы в память.

③ Он сканирует записи индекса, чтобы определить, какие гранулы столбца town могут содержать строки, удовлетворяющие условию.

④ Эти потенциально релевантные гранулы загружаются в память вместе с позиционно выровненными гранулами из всех остальных столбцов, необходимых для выполнения запроса.

⑤ Остальные фильтры применяются в процессе выполнения запроса.

Как видите, без PREWHERE все потенциально релевантные столбцы загружаются до применения фильтрации, даже если условию фактически соответствует лишь несколько строк.


## Как PREWHERE повышает эффективность запросов {#how-prewhere-improves-query-efficiency}

Следующие анимации демонстрируют, как обрабатывается приведённый выше запрос с применением клаузы PREWHERE ко всем предикатам запроса.

Первые три этапа обработки остаются такими же, как и ранее:

<Image
  img={visual02}
  size='md'
  alt='Обработка запроса с оптимизацией PREWHERE'
/>

<br />
<br />① Запрос включает фильтр по столбцу `town`, который является частью
первичного ключа таблицы — и, следовательно, также частью первичного индекса.

② Аналогично выполнению без клаузы PREWHERE, для ускорения запроса ClickHouse загружает первичный индекс в память,

③ затем сканирует записи индекса, чтобы определить, какие гранулы столбца `town` могут содержать строки, соответствующие предикату.

Теперь, благодаря клаузе PREWHERE, следующий этап отличается: вместо чтения всех релевантных столбцов заранее ClickHouse фильтрует данные столбец за столбцом, загружая только то, что действительно необходимо. Это значительно сокращает операции ввода-вывода, особенно для широких таблиц.

На каждом этапе загружаются только те гранулы, которые содержат хотя бы одну строку, прошедшую — то есть соответствующую — предыдущему фильтру. В результате количество гранул для загрузки и оценки на каждом фильтре монотонно уменьшается:

**Этап 1: Фильтрация по town**<br/>
ClickHouse начинает обработку PREWHERE с ① чтения выбранных гранул столбца `town` и проверки, какие из них действительно содержат строки, соответствующие `London`.

В нашем примере все выбранные гранулы соответствуют условию, поэтому ② соответствующие позиционно выровненные гранулы для следующего столбца фильтрации — `date` — затем выбираются для обработки:

<Image img={visual03} size='md' alt='Этап 1: Фильтрация по town' />

<br />
<br />
**Этап 2: Фильтрация по date**
<br />
Далее ClickHouse ① читает выбранные гранулы столбца `date` для оценки
фильтра `date > '2024-12-31'`.

В данном случае две из трёх гранул содержат соответствующие строки, поэтому ② только их позиционно выровненные гранулы из следующего столбца фильтрации — `price` — выбираются для дальнейшей обработки:

<Image img={visual04} size='md' alt='Этап 2: Фильтрация по date' />

<br />
<br />
**Этап 3: Фильтрация по price**
<br />
Наконец, ClickHouse ① читает две выбранные гранулы столбца `price` для
оценки последнего фильтра `price > 10_000`.

Только одна из двух гранул содержит соответствующие строки, поэтому ② только её позиционно выровненная гранула из столбца `SELECT` — `street` — должна быть загружена для дальнейшей обработки:

<Image img={visual05} size='md' alt='Этап 3: Фильтрация по price' />

<br />
<br />
К финальному этапу загружается только минимальный набор гранул столбцов, содержащих
соответствующие строки. Это приводит к меньшему использованию памяти, меньшему количеству операций ввода-вывода на диске и
более быстрому выполнению запросов.

:::note PREWHERE сокращает объём читаемых данных, а не количество обрабатываемых строк
Обратите внимание, что ClickHouse обрабатывает одинаковое количество строк как в версии запроса с PREWHERE, так и без неё. Однако при применении оптимизаций PREWHERE не все значения столбцов необходимо загружать для каждой обрабатываемой строки.
:::


## Оптимизация PREWHERE применяется автоматически {#prewhere-optimization-is-automatically-applied}

Секцию PREWHERE можно добавить вручную, как показано в примере выше. Однако делать это необязательно. Когда настройка [`optimize_move_to_prewhere`](/operations/settings/settings#optimize_move_to_prewhere) включена (по умолчанию true), ClickHouse автоматически перемещает условия фильтрации из WHERE в PREWHERE, отдавая приоритет тем условиям, которые максимально сократят объём читаемых данных.

Идея заключается в том, что столбцы меньшего размера сканируются быстрее, и к моменту обработки более крупных столбцов большинство гранул уже отфильтровано. Поскольку все столбцы содержат одинаковое количество строк, размер столбца в первую очередь определяется его типом данных — например, столбец `UInt8` обычно значительно меньше столбца `String`.

ClickHouse следует этой стратегии по умолчанию начиная с версии [23.2](https://clickhouse.com/blog/clickhouse-release-23-02#multi-stage-prewhere--alexander-gololobov), сортируя столбцы с фильтрами PREWHERE для многоэтапной обработки в порядке возрастания несжатого размера.

Начиная с версии [23.11](https://clickhouse.com/blog/clickhouse-release-23-11#column-statistics-for-prewhere), опциональная статистика по столбцам позволяет дополнительно улучшить этот процесс, выбирая порядок обработки фильтров на основе фактической селективности данных, а не только размера столбцов.


## Как измерить влияние PREWHERE {#how-to-measure-prewhere-impact}

Чтобы убедиться, что PREWHERE улучшает производительность ваших запросов, можно сравнить их выполнение с включенной и выключенной настройкой `optimize_move_to_prewhere`.

Начнем с выполнения запроса с отключенной настройкой `optimize_move_to_prewhere`:

```sql
SELECT
    street
FROM
   uk.uk_price_paid_simple
WHERE
   town = 'LONDON' AND date > '2024-12-31' AND price < 10_000
SETTINGS optimize_move_to_prewhere = false;
```

```txt
   ┌─street──────┐
1. │ MOYSER ROAD │
2. │ AVENUE ROAD │
3. │ AVENUE ROAD │
   └─────────────┘

Получено 3 строки. Затрачено: 0.056 сек. Обработано 2.31 млн строк, 23.36 МБ (41.09 млн строк/сек., 415.43 МБ/сек.)
Пиковое использование памяти: 132.10 МиБ.
```

ClickHouse прочитал **23.36 МБ** данных столбцов при обработке 2.31 млн строк для этого запроса.

Далее выполним запрос с включенной настройкой `optimize_move_to_prewhere`. (Обратите внимание, что указывать эту настройку необязательно, так как она включена по умолчанию):

```sql
SELECT
    street
FROM
   uk.uk_price_paid_simple
WHERE
   town = 'LONDON' AND date > '2024-12-31' AND price < 10_000
SETTINGS optimize_move_to_prewhere = true;
```

```txt
   ┌─street──────┐
1. │ MOYSER ROAD │
2. │ AVENUE ROAD │
3. │ AVENUE ROAD │
   └─────────────┘

Получено 3 строки. Затрачено: 0.017 сек. Обработано 2.31 млн строк, 6.74 МБ (135.29 млн строк/сек., 394.44 МБ/сек.)
Пиковое использование памяти: 132.11 МиБ.
```

Было обработано то же количество строк (2.31 млн), но благодаря PREWHERE ClickHouse прочитал более чем в три раза меньше данных столбцов — всего 6.74 МБ вместо 23.36 МБ, что сократило общее время выполнения в 3 раза.

Для более глубокого понимания того, как ClickHouse применяет PREWHERE, используйте EXPLAIN и журналы трассировки.

Проверим логический план запроса с помощью оператора [EXPLAIN](/sql-reference/statements/explain#explain-plan):

```sql
EXPLAIN PLAN actions = 1
SELECT
    street
FROM
   uk.uk_price_paid_simple
WHERE
   town = 'LONDON' and date > '2024-12-31' and price < 10_000;
```

```txt
...
Информация Prewhere
  Столбец фильтра Prewhere:
    and(greater(__table1.date, '2024-12-31'_String),
    less(__table1.price, 10000_UInt16),
    equals(__table1.town, 'LONDON'_String))
...
```

Мы опускаем большую часть вывода плана, так как он довольно объемный. По сути, он показывает, что все три предиката столбцов были автоматически перенесены в PREWHERE.

При самостоятельном воспроизведении вы также увидите в плане запроса, что порядок этих предикатов основан на размерах типов данных столбцов. Поскольку мы не включили статистику столбцов, ClickHouse использует размер в качестве резервного критерия для определения порядка обработки PREWHERE.

Если вы хотите углубиться еще больше, можно наблюдать каждый отдельный шаг обработки PREWHERE, указав ClickHouse возвращать все записи журнала тестового уровня во время выполнения запроса:

```sql
SELECT
    street
FROM
   uk.uk_price_paid_simple
WHERE
   town = 'LONDON' AND date > '2024-12-31' AND price < 10_000
SETTINGS send_logs_level = 'test';
```

```txt
...
<Trace> ... Условие greater(date, '2024-12-31'_String) перенесено в PREWHERE
<Trace> ... Условие less(price, 10000_UInt16) перенесено в PREWHERE
<Trace> ... Условие equals(town, 'LONDON'_String) перенесено в PREWHERE
...
<Test> ... Выполнение действий prewhere на блоке: greater(__table1.date, '2024-12-31'_String)
<Test> ... Выполнение действий prewhere на блоке: less(__table1.price, 10000_UInt16)
...
```


## Ключевые выводы {#key-takeaways}

- PREWHERE позволяет избежать чтения данных столбцов, которые будут отфильтрованы, экономя операции ввода-вывода и память.
- Работает автоматически при включённой настройке `optimize_move_to_prewhere` (по умолчанию).
- Порядок фильтрации имеет значение: небольшие и селективные столбцы должны идти первыми.
- Используйте `EXPLAIN` и логи для проверки применения PREWHERE и понимания его эффекта.
- PREWHERE наиболее эффективен для широких таблиц и больших сканирований с селективными фильтрами.

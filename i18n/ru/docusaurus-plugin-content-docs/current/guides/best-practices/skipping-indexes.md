---
slug: /optimize/skipping-indexes
sidebar_label: 'Индексы пропуска данных'
sidebar_position: 2
description: 'Индексы пропуска позволяют ClickHouse пропускать чтение значительных фрагментов данных, которые гарантированно не содержат подходящих значений.'
title: 'Индексы пропуска данных в ClickHouse'
doc_type: 'guide'
keywords: ['skipping indexes', 'data skipping', 'performance', 'indexing', 'best practices']
---

import simple_skip from '@site/static/images/guides/best-practices/simple_skip.png';
import bad_skip from '@site/static/images/guides/best-practices/bad_skip.png';
import Image from '@theme/IdealImage';


# Индексы пропуска данных в ClickHouse



## Введение {#introduction}

На производительность запросов ClickHouse влияет множество факторов. Критическим элементом в большинстве сценариев является то, может ли ClickHouse использовать первичный ключ при вычислении условия WHERE в запросе. Соответственно, выбор первичного ключа, применимого к наиболее распространенным шаблонам запросов, является важнейшим аспектом эффективного проектирования таблиц.

Тем не менее, независимо от того, насколько тщательно настроен первичный ключ, неизбежно возникнут сценарии использования запросов, которые не смогут эффективно его применять. Пользователи часто используют ClickHouse для работы с данными временных рядов, но при этом нередко хотят анализировать те же данные по другим бизнес-измерениям, таким как идентификатор клиента, URL веб-сайта или номер продукта. В таких случаях производительность запросов может быть значительно хуже, поскольку для применения условия WHERE может потребоваться полное сканирование каждого значения столбца. Хотя ClickHouse остается относительно быстрым в подобных обстоятельствах, обработка миллионов или миллиардов отдельных значений приведет к тому, что «неиндексированные» запросы будут выполняться гораздо медленнее, чем запросы, основанные на первичном ключе.

В традиционных реляционных базах данных одним из подходов к решению этой проблемы является добавление к таблице одного или нескольких «вторичных» индексов. Это структура b-дерева, которая позволяет базе данных находить все совпадающие строки на диске за время O(log(n)) вместо O(n) (полное сканирование таблицы), где n — количество строк. Однако такой тип вторичного индекса не работает для ClickHouse (и других колоночных баз данных), поскольку на диске отсутствуют отдельные строки, которые можно было бы добавить в индекс.

Вместо этого ClickHouse предоставляет другой тип индекса, который в определенных обстоятельствах может значительно повысить скорость выполнения запросов. Эти структуры называются индексами пропуска (Skip indexes), поскольку они позволяют ClickHouse пропускать чтение значительных фрагментов данных, которые гарантированно не содержат совпадающих значений.


## Основные принципы работы {#basic-operation}

Индексы пропуска данных можно использовать только с таблицами семейства MergeTree. Каждый индекс пропуска данных имеет четыре основных аргумента:

- Имя индекса. Имя индекса используется для создания файла индекса в каждой партиции. Также оно требуется в качестве параметра при удалении или материализации индекса.
- Выражение индекса. Выражение индекса используется для вычисления набора значений, хранящихся в индексе. Оно может представлять собой комбинацию столбцов, простых операторов и/или подмножества функций, определяемых типом индекса.
- TYPE. Тип индекса управляет вычислением, которое определяет, можно ли пропустить чтение и обработку каждого блока индекса.
- GRANULARITY. Каждый индексированный блок состоит из GRANULARITY гранул. Например, если гранулярность первичного индекса таблицы составляет 8192 строки, а гранулярность индекса равна 4, каждый индексированный «блок» будет содержать 32768 строк.

При создании индекса пропуска данных в каждом каталоге части данных таблицы создаются два дополнительных файла:

- `skp_idx_{index_name}.idx`, который содержит упорядоченные значения выражения
- `skp_idx_{index_name}.mrk2`, который содержит соответствующие смещения в связанных файлах столбцов данных.

Если при выполнении запроса и чтении соответствующих файлов столбцов какая-либо часть условия фильтрации в предложении WHERE совпадает с выражением индекса пропуска, ClickHouse использует данные файла индекса для определения того, должен ли каждый соответствующий блок данных быть обработан или может быть пропущен (при условии, что блок не был уже исключен при применении первичного ключа). Для наглядности рассмотрим упрощенный пример со следующей таблицей, заполненной предсказуемыми данными.

```sql
CREATE TABLE skip_table
(
  my_key UInt64,
  my_value UInt64
)
ENGINE MergeTree primary key my_key
SETTINGS index_granularity=8192;

INSERT INTO skip_table SELECT number, intDiv(number,4096) FROM numbers(100000000);
```

При выполнении простого запроса, который не использует первичный ключ, сканируются все 100 миллионов записей в столбце `my_value`:

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.079 sec. Processed 100.00 million rows, 800.10 MB (1.26 billion rows/s., 10.10 GB/s.
```

Теперь добавим базовый индекс пропуска:

```sql
ALTER TABLE skip_table ADD INDEX vix my_value TYPE set(100) GRANULARITY 2;
```

Обычно индексы пропуска применяются только к вновь вставляемым данным, поэтому простое добавление индекса не повлияет на приведенный выше запрос.

Чтобы проиндексировать уже существующие данные, используйте следующую команду:

```sql
ALTER TABLE skip_table MATERIALIZE INDEX vix;
```

Повторно выполним запрос с только что созданным индексом:

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.051 sec. Processed 32.77 thousand rows, 360.45 KB (643.75 thousand rows/s., 7.08 MB/s.)
```

Вместо обработки 100 миллионов строк объемом 800 мегабайт ClickHouse прочитал и проанализировал только 32768 строк объемом 360 килобайт — четыре гранулы по 8192 строки каждая.

В более наглядной форме показано, как были прочитаны и выбраны 4096 строк со значением `my_value` равным 125, и как последующие строки были пропущены без чтения с диска:

<Image img={simple_skip} size='md' alt='Simple Skip' />

Пользователи могут получить подробную информацию об использовании индексов пропуска, включив трассировку при выполнении запросов. В clickhouse-client установите параметр `send_logs_level`:

```sql
SET send_logs_level='trace';
```

Это предоставит полезную отладочную информацию при настройке SQL-запросов и индексов таблиц. В приведенном выше примере журнал отладки показывает, что индекс пропуска отбросил все гранулы, кроме двух:


```sql
<Debug> default.skip_table (933d4b2c-8cea-4bf9-8c93-c56e900eefd1) (SelectExecutor): Индекс `vix` отбросил 6102/6104 гранул.
```

## Типы индексов с пропуском данных {#skip-index-types}

<!-- vale off -->

### minmax {#minmax}

<!-- vale on -->

Этот легковесный тип индекса не требует параметров. Он сохраняет минимальное и максимальное значения индексного выражения для каждого блока (если выражение является кортежем, значения для каждого элемента кортежа сохраняются отдельно). Этот тип идеален для столбцов, которые имеют тенденцию к приблизительной сортировке по значению. Применение этого типа индекса при обработке запросов обычно требует наименьших затрат.

Этот тип индекса корректно работает только со скалярными выражениями или выражениями-кортежами — индекс никогда не будет применяться к выражениям, возвращающим массив или тип данных map.

<!-- vale off -->

### set {#set}

<!-- vale on -->

Этот легковесный тип индекса принимает единственный параметр max_size — максимальный размер набора значений на блок (значение 0 разрешает неограниченное количество уникальных значений). Этот набор содержит все значения в блоке (или остается пустым, если количество значений превышает max_size). Этот тип индекса хорошо работает со столбцами с низкой кардинальностью внутри каждого набора гранул (по сути, со значениями, «сгруппированными вместе»), но с более высокой кардинальностью в целом.

Стоимость, производительность и эффективность этого индекса зависят от кардинальности внутри блоков. Если каждый блок содержит большое количество уникальных значений, то либо проверка условия запроса по большому набору индекса будет очень затратной, либо индекс не будет применен, поскольку он окажется пустым из-за превышения max_size.

### Типы фильтров Блума {#bloom-filter-types}

_Фильтр Блума_ — это структура данных, которая позволяет эффективно по памяти проверять принадлежность к множеству ценой небольшой вероятности ложноположительных срабатываний. Ложноположительное срабатывание не является серьезной проблемой в случае индексов с пропуском данных, поскольку единственным недостатком является чтение нескольких лишних блоков. Однако возможность ложноположительных срабатываний означает, что индексное выражение должно ожидаемо быть истинным, иначе корректные данные могут быть пропущены.

Поскольку фильтры Блума могут более эффективно обрабатывать проверку большого количества дискретных значений, они подходят для условных выражений, которые генерируют больше значений для проверки. В частности, индекс на основе фильтра Блума может применяться к массивам, где проверяется каждое значение массива, и к типу map путем преобразования ключей или значений в массив с помощью функций mapKeys или mapValues.

Существует три типа индексов с пропуском данных на основе фильтров Блума:

- Базовый **bloom_filter**, который принимает единственный необязательный параметр — допустимую частоту «ложноположительных срабатываний» от 0 до 1 (если не указан, используется значение 0,025).

- Специализированный **tokenbf_v1**. Он принимает три параметра, все связанные с настройкой используемого фильтра Блума: (1) размер фильтра в байтах (большие фильтры имеют меньше ложноположительных срабатываний за счет увеличения объема хранения), (2) количество применяемых хеш-функций (опять же, большее количество хеш-функций уменьшает ложноположительные срабатывания) и (3) начальное значение (seed) для хеш-функций фильтра Блума. См. калькулятор [здесь](https://hur.st/bloomfilter/) для получения более подробной информации о том, как эти параметры влияют на функциональность фильтра Блума.
  Этот индекс работает только с типами данных String, FixedString и Map. Входное выражение разбивается на последовательности символов, разделенные неалфавитно-цифровыми символами. Например, значение столбца `This is a candidate for a "full text" search` будет содержать токены `This`, `is`, `a`, `candidate`, `for`, `full`, `text`, `search`. Он предназначен для использования в операторах LIKE, EQUALS, IN, hasToken() и аналогичных поисках слов и других значений внутри более длинных строк. Например, одним из возможных применений может быть поиск небольшого количества имен классов или номеров строк в столбце со свободно форматированными строками журнала приложения.

- Специализированный **ngrambf_v1**. Этот индекс функционирует так же, как токеновый индекс. Он принимает один дополнительный параметр перед настройками фильтра Блума — размер n-грамм для индексирования. N-грамма — это строка символов длиной `n` из любых символов, поэтому строка `A short string` с размером n-граммы 4 будет проиндексирована как:
  ```text
  'A sh', ' sho', 'shor', 'hort', 'ort ', 'rt s', 't st', ' str', 'stri', 'trin', 'ring'
  ```
  Этот индекс также может быть полезен для текстового поиска, особенно в языках без разделителей слов, таких как китайский.


## Функции индексов с пропуском данных {#skip-index-functions}

Основная цель индексов с пропуском данных — ограничить объём данных, анализируемых популярными запросами. Учитывая аналитический характер данных ClickHouse, паттерн таких запросов в большинстве случаев включает функциональные выражения. Соответственно, индексы с пропуском данных должны корректно взаимодействовать с распространёнными функциями для обеспечения эффективности. Это может происходить в следующих случаях:

- при вставке данных, когда индекс определён как функциональное выражение (результат выражения сохраняется в файлах индекса), или
- при обработке запроса, когда выражение применяется к сохранённым значениям индекса для определения того, следует ли исключить блок.

Каждый тип индекса с пропуском данных работает с подмножеством доступных функций ClickHouse, соответствующих реализации индекса, перечисленных
[здесь](/engines/table-engines/mergetree-family/mergetree/#functions-support). В целом, индексы множеств и индексы на основе фильтра Блума (другой тип индекса множеств) являются неупорядоченными и поэтому не работают с диапазонами. В отличие от них, индексы minmax особенно хорошо работают с диапазонами, поскольку определение пересечения диапазонов выполняется очень быстро. Эффективность функций частичного совпадения LIKE, startsWith, endsWith и hasToken зависит от используемого типа индекса, выражения индекса и конкретной формы данных.


## Настройки индексов пропуска {#skip-index-settings}

Для индексов пропуска доступны две настройки.

- **use_skip_indexes** (0 или 1, по умолчанию 1). Не все запросы могут эффективно использовать индексы пропуска. Если определённое условие фильтрации
  скорее всего включает большинство гранул, применение индекса пропуска данных приводит к ненужным и иногда значительным затратам. Установите значение
  0 для запросов, которые вряд ли выиграют от использования индексов пропуска.
- **force_data_skipping_indices** (список имён индексов через запятую). Эта настройка может использоваться для предотвращения некоторых видов неэффективных
  запросов. В ситуациях, когда выполнение запроса к таблице слишком затратно без использования индекса пропуска, применение этой настройки с одним или несколькими именами
  индексов вернёт исключение для любого запроса, который не использует указанный индекс. Это предотвратит потребление серверных ресурсов плохо написанными запросами.


## Рекомендации по использованию skip-индексов {#skip-best-practices}

Skip-индексы неинтуитивны, особенно для пользователей, привыкших к вторичным построчным индексам из мира РСУБД или инвертированным индексам из документоориентированных хранилищ. Чтобы получить какую-либо выгоду от применения skip-индекса ClickHouse, необходимо избежать достаточного количества чтений гранул, чтобы компенсировать затраты на вычисление индекса. Критически важно понимать: если значение встречается хотя бы один раз в индексированном блоке, это означает, что весь блок должен быть прочитан в память и обработан, и затраты на индекс оказываются напрасными.

Рассмотрим следующее распределение данных:

<Image img={bad_skip} size='md' alt='Bad Skip' />

Предположим, что первичный ключ/ключ ORDER BY — это `timestamp`, и существует индекс на `visitor_id`. Рассмотрим следующий запрос:

```sql
SELECT timestamp, url FROM table WHERE visitor_id = 1001`
```

Традиционный вторичный индекс был бы очень выгоден при таком распределении данных. Вместо чтения всех 32768 строк для поиска
5 строк с запрошенным visitor_id вторичный индекс содержал бы только пять местоположений строк, и только эти пять строк были бы
прочитаны с диска. Для skip-индекса ClickHouse верно прямо противоположное. Все 32768 значений в столбце `visitor_id` будут проверены
независимо от типа skip-индекса.

Соответственно, естественное желание ускорить запросы ClickHouse простым добавлением индекса к ключевым
столбцам часто ошибочно. Эту продвинутую функциональность следует использовать только после изучения других альтернатив, таких как изменение первичного ключа (см. [Как выбрать первичный ключ](../best-practices/sparse-primary-indexes.md)), использование проекций или материализованных представлений. Даже когда skip-индекс уместен, часто потребуется тщательная настройка как индекса, так и таблицы.

В большинстве случаев полезный skip-индекс требует сильной корреляции между первичным ключом и целевым непервичным столбцом/выражением.
Если корреляции нет (как на диаграмме выше), вероятность того, что условие фильтрации будет выполнено хотя бы одной из строк в
блоке из нескольких тысяч значений, высока, и мало блоков будет пропущено. Напротив, если диапазон значений первичного ключа (например, время
суток) сильно связан со значениями в потенциальном индексируемом столбце (например, возраст телезрителей), то индекс типа minmax,
скорее всего, будет полезен. Обратите внимание, что можно увеличить эту корреляцию при вставке данных, либо включив дополнительные
столбцы в ключ сортировки/ORDER BY, либо группируя вставки таким образом, чтобы значения, связанные с первичным ключом, группировались при вставке. Например,
все события для конкретного site_id могут быть сгруппированы и вставлены вместе процессом загрузки, даже если первичный ключ
является временной меткой, содержащей события с большого числа сайтов. Это приведет к тому, что многие гранулы будут содержать только несколько site_id, поэтому многие
блоки могут быть пропущены при поиске по конкретному значению site_id.

Еще один хороший кандидат для skip-индекса — это выражения с высокой кардинальностью, где любое отдельное значение относительно разрежено в данных. Одним из примеров
может быть платформа наблюдаемости, которая отслеживает коды ошибок в API-запросах. Определенные коды ошибок, хотя и редки в данных, могут быть особенно
важны для поиска. Skip-индекс типа set на столбце error_code позволит обойти подавляющее большинство блоков, которые не содержат
ошибок, и, следовательно, значительно улучшит запросы, ориентированные на ошибки.

Наконец, ключевая рекомендация — тестировать, тестировать и еще раз тестировать. Опять же, в отличие от вторичных индексов b-tree или инвертированных индексов для поиска документов,
поведение skip-индексов трудно предсказуемо. Их добавление к таблице влечет значительные затраты как при загрузке данных, так и при выполнении запросов,
которые по разным причинам не получают выгоды от индекса. Их всегда следует тестировать на реальных данных, и тестирование должно
включать вариации типа, размера гранулярности и других параметров. Тестирование часто выявляет закономерности и подводные камни, которые не очевидны при
одних только мысленных экспериментах.


## Связанные документы {#related-docs}

- [Руководство по рекомендациям](/best-practices/use-data-skipping-indices-where-appropriate)
- [Примеры индексов пропуска данных](/optimize/skipping-indexes/examples)
- [Управление индексами пропуска данных](/sql-reference/statements/alter/skipping-index)
- [Информация в системных таблицах](/operations/system-tables/data_skipping_indices)

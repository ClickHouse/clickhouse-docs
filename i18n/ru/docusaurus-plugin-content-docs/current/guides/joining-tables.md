---
title: 'Использование JOIN-ов в ClickHouse'
description: 'Как выполнять соединения таблиц в ClickHouse'
keywords: ['joins', 'join tables']
slug: /guides/joining-tables
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import joins_1 from '@site/static/images/guides/joins-1.png';
import joins_2 from '@site/static/images/guides/joins-2.png';
import joins_3 from '@site/static/images/guides/joins-3.png';
import joins_4 from '@site/static/images/guides/joins-4.png';
import joins_5 from '@site/static/images/guides/joins-5.png';

ClickHouse обладает [полной поддержкой `JOIN`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1) с широким выбором алгоритмов соединения. Для максимальной производительности мы рекомендуем следовать рекомендациям по оптимизации соединений, приведённым в этом руководстве.

* Для оптимальной производительности пользователям следует стремиться уменьшить количество `JOIN` в запросах, особенно для аналитических нагрузок в реальном времени, где требуется отклик на уровне миллисекунд. Старайтесь не превышать 3–4 соединения в одном запросе. Мы подробно рассматриваем ряд подходов, позволяющих минимизировать количество соединений, в [разделе моделирования данных](/data-modeling/schema-design), включая денормализацию, словари и материализованные представления.
* В настоящее время ClickHouse не меняет порядок соединений. Всегда следите за тем, чтобы самая маленькая таблица находилась справа от `JOIN`. Для большинства алгоритмов соединения она будет размещаться в памяти, что обеспечит минимальные накладные расходы по памяти для запроса.
* Если вашему запросу требуется прямое соединение, т. е. `LEFT ANY JOIN`, как показано ниже, мы рекомендуем по возможности использовать [словарей](/dictionary).

<Image img={joins_1} size="sm" alt="Левое соединение типа ANY" />

* При выполнении внутренних соединений зачастую более эффективно записывать их в виде подзапросов с использованием оператора `IN`. Рассмотрите следующие запросы, которые функционально эквивалентны. Оба находят количество записей в таблице `posts`, в которых в вопросе не упоминается ClickHouse, но упоминается в `comments`.

```sql
SELECT count()
FROM stackoverflow.posts AS p
ANY INNER `JOIN` stackoverflow.comments AS c ON p.Id = c.PostId
WHERE (p.Title != '') AND (p.Title NOT ILIKE '%clickhouse%') AND (p.Body NOT ILIKE '%clickhouse%') AND (c.Text ILIKE '%clickhouse%')

┌─count()─┐
│       86 │
└─────────┘

1 строка в наборе. Затрачено: 8.209 сек. Обработано 150.20 млн строк, 56.05 ГБ (18.30 млн строк/с., 6.83 ГБ/с.)
Пиковое использование памяти: 1.23 ГиБ.
```

Обратите внимание, что мы используем `ANY INNER JOIN`, а не просто `INNER JOIN`, так как нам не нужен декартов произведение, то есть нам необходимо только одно совпадение для каждого поста.

Этот JOIN можно переписать, используя подзапрос, что значительно улучшит производительность:

```sql
SELECT count()
FROM stackoverflow.posts
WHERE (Title != '') AND (Title NOT ILIKE '%clickhouse%') AND (Body NOT ILIKE '%clickhouse%') AND (Id IN (
        SELECT PostId
        FROM stackoverflow.comments
        WHERE Text ILIKE '%clickhouse%'
))
┌─count()─┐
│       86 │
└─────────┘

1 строка в наборе. Затрачено: 2.284 сек. Обработано 150.20 млн строк, 16.61 ГБ (65.76 млн строк/с., 7.27 ГБ/с.)
Пиковое использование памяти: 323.52 МиБ.
```

Хотя ClickHouse пытается проталкивать условия во все предложения `JOIN` и подзапросы, мы рекомендуем пользователям всегда вручную применять условия ко всем подвыражениям, где это возможно — тем самым минимизируя объем данных для `JOIN`. Рассмотрим следующий пример, где мы хотим посчитать количество голосов «за» для постов, связанных с Java, начиная с 2020 года.

Наивный запрос, с большей таблицей слева, выполняется за 56 секунд:

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.posts AS p
INNER JOIN stackoverflow.votes AS v ON p.Id = v.PostId
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘
```


1 строка в наборе. Прошло: 56.642 сек. Обработано 252.30 млн строк, 1.62 GB (4.45 млн строк/с, 28.60 MB/с.)

````

Изменение порядка этого соединения значительно улучшает производительность до 1,5 с:

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.votes AS v
INNER JOIN stackoverflow.posts AS p ON v.PostId = p.Id
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘

1 строка в наборе. Затрачено: 1.519 сек. Обработано 252.30 млн строк, 1.62 ГБ (166.06 млн строк/с., 1.07 ГБ/с.)
````

Добавление фильтра к таблице слева дополнительно улучшает производительность, сокращая время до 0,5 с.

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.votes AS v
INNER JOIN stackoverflow.posts AS p ON v.PostId = p.Id
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01') AND (v.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘

Получена 1 строка. Затрачено: 0,597 сек. Обработано 81,14 млн строк, 1,31 ГБ (135,82 млн строк/с., 2,19 ГБ/с.)
Пиковое использование памяти: 249,42 МиБ.
```

Этот запрос можно ещё больше оптимизировать, вынеся `INNER JOIN` во вложенный подзапрос, как отмечалось ранее, при этом сохранив фильтр и во внешнем, и во внутреннем запросе.

```sql
SELECT count() AS upvotes
FROM stackoverflow.votes
WHERE (VoteTypeId = 2) AND (PostId IN (
        SELECT Id
        FROM stackoverflow.posts
        WHERE (CreationDate >= '2020-01-01') AND has(arrayFilter(t -> (t != ''), splitByChar('|', Tags)), 'java')
))

┌─upvotes─┐
│  261915 │
└─────────┘

1 строка в наборе. Затрачено: 0.383 сек. Обработано 99.64 млн строк, 804.55 МБ (259.85 млн строк/с., 2.10 ГБ/с.)
Пиковое использование памяти: 250.66 МиБ.
```


## Выбор алгоритма JOIN {#choosing-a-join-algorithm}

ClickHouse поддерживает несколько [алгоритмов соединения](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1). Эти алгоритмы обычно обменивают использование памяти на производительность. Ниже представлен обзор алгоритмов соединения ClickHouse на основе их относительного потребления памяти и времени выполнения:

<br />

<Image img={joins_2} size='lg' alt='скорость в зависимости от памяти для соединений' />

<br />

Эти алгоритмы определяют способ планирования и выполнения запроса соединения. По умолчанию ClickHouse использует алгоритм прямого или хеш-соединения в зависимости от используемого типа соединения, строгости и движка соединяемых таблиц. Альтернативно, ClickHouse можно настроить на адаптивный выбор и динамическое изменение алгоритма соединения во время выполнения в зависимости от доступности и использования ресурсов: при `join_algorithm=auto` ClickHouse сначала пробует алгоритм хеш-соединения, и если лимит памяти этого алгоритма превышен, алгоритм переключается на лету на частичное соединение слиянием. Вы можете отследить, какой алгоритм был выбран, через журналирование трассировки. ClickHouse также позволяет пользователям самостоятельно указать желаемый алгоритм соединения через настройку `join_algorithm`.

Поддерживаемые типы `JOIN` для каждого алгоритма соединения показаны ниже и должны быть учтены перед оптимизацией:

<br />

<Image img={joins_3} size='lg' alt='возможности соединений' />

<br />

Полное подробное описание каждого алгоритма `JOIN` можно найти [здесь](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2), включая их преимущества, недостатки и свойства масштабирования.

Выбор подходящего алгоритма соединения зависит от того, оптимизируете ли вы использование памяти или производительность.


## Оптимизация производительности JOIN {#optimizing-join-performance}

Если ключевой метрикой оптимизации является производительность и вы хотите выполнить соединение максимально быстро, используйте следующее дерево решений для выбора подходящего алгоритма соединения:

<br />

<Image img={joins_4} size='lg' alt='блок-схема соединений' />

<br />

- **(1)** Если данные из правой таблицы можно предварительно загрузить в низколатентную структуру данных типа ключ-значение в памяти, например словарь, и если ключ соединения совпадает с ключевым атрибутом базового хранилища ключ-значение, и если семантика `LEFT ANY JOIN` подходит — тогда применим **direct join**, который обеспечивает самый быстрый подход.

- **(2)** Если [физический порядок строк](/guides/best-practices/sparse-primary-indexes#data-is-stored-on-disk-ordered-by-primary-key-columns) вашей таблицы соответствует порядку сортировки ключа соединения, то всё зависит от ситуации. В этом случае **full sorting merge join** [пропускает](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3#utilizing-physical-row-order) фазу сортировки, что приводит к значительному снижению использования памяти и, в зависимости от размера данных и распределения значений ключа соединения, к более быстрому времени выполнения по сравнению с некоторыми алгоритмами хеш-соединения.

- **(3)** Если правая таблица помещается в память, даже с учётом [дополнительных накладных расходов памяти](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#summary) **parallel hash join**, то этот алгоритм или хеш-соединение могут работать быстрее. Это зависит от размера данных, типов данных и распределения значений столбцов ключа соединения.

- **(4)** Если правая таблица не помещается в память, то снова всё зависит от ситуации. ClickHouse предлагает три алгоритма соединения, не ограниченных памятью. Все три временно сбрасывают данные на диск. **Full sorting merge join** и **partial merge join** требуют предварительной сортировки данных. **Grace hash join** вместо этого строит хеш-таблицы из данных. В зависимости от объёма данных, типов данных и распределения значений столбцов ключа соединения могут быть сценарии, когда построение хеш-таблиц из данных быстрее, чем сортировка данных. И наоборот.

Partial merge join оптимизирован для минимизации использования памяти при соединении больших таблиц за счёт скорости соединения, которая является довольно низкой. Это особенно актуально, когда физический порядок строк левой таблицы не соответствует порядку сортировки ключа соединения.

Grace hash join является наиболее гибким из трёх алгоритмов соединения, не ограниченных памятью, и обеспечивает хороший контроль использования памяти относительно скорости соединения с помощью настройки [grace_hash_join_initial_buckets](https://github.com/ClickHouse/ClickHouse/blob/23.5/src/Core/Settings.h#L759). В зависимости от объёма данных grace hash может работать быстрее или медленнее алгоритма partial merge, когда количество [корзин](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#description-2) выбрано таким образом, что использование памяти обоими алгоритмами примерно одинаково. Когда использование памяти grace hash join настроено так, чтобы быть примерно одинаковым с использованием памяти full sorting merge, то full sorting merge всегда работал быстрее в наших тестовых запусках.

Какой из трёх алгоритмов, не ограниченных памятью, является самым быстрым, зависит от объёма данных, типов данных и распределения значений столбцов ключа соединения. Всегда лучше провести тестирование производительности с реалистичными объёмами реалистичных данных, чтобы определить, какой алгоритм работает быстрее всего.


## Оптимизация использования памяти {#optimizing-for-memory}

Если вы хотите оптимизировать соединение для минимального использования памяти, а не для максимальной скорости выполнения, используйте следующее дерево решений:

<br />

<Image img={joins_5} size='lg' alt='Дерево решений для оптимизации памяти при соединениях' />

<br />

- **(1)** Если физический порядок строк в таблице соответствует порядку сортировки ключа соединения, то использование памяти для **full sorting merge join** будет минимальным. Дополнительным преимуществом является высокая скорость соединения, поскольку фаза сортировки [отключается](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3#utilizing-physical-row-order).
- **(2)** **Grace hash join** можно настроить для очень низкого использования памяти путем [конфигурирования](https://github.com/ClickHouse/ClickHouse/blob/23.5/src/Core/Settings.h#L759) большого количества [корзин](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#description-2) за счет скорости соединения. **Partial merge join** намеренно использует небольшой объем оперативной памяти. **Full sorting merge join** с включенной внешней сортировкой обычно использует больше памяти, чем partial merge join (при условии, что порядок строк не соответствует порядку сортировки ключа), но при этом обеспечивает значительно лучшее время выполнения соединения.

Пользователям, которым требуется более подробная информация по данной теме, рекомендуем ознакомиться со следующей [серией статей в блоге](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1).

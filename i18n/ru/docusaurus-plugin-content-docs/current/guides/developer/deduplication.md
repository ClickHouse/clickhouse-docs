---
slug: /guides/developer/deduplication
sidebar_label: Стратегии дедупликации
sidebar_position: 3
description: Используйте дедупликацию, когда вам нужно часто выполнять upserts, обновления и удаления.
---

import deduplication from '@site/static/images/guides/developer/de_duplication.png';


# Стратегии дедупликации

**Дедупликация** относится к процессу ***удаления дублирующихся строк в наборе данных***. В OLTP базе данных это делается легко, потому что каждая строка имеет уникальный первичный ключ, но за счет более медленной вставки. Каждая вставленная строка сначала должна быть найдена, и при наличии ее необходимо заменить.

ClickHouse создан для скорости, когда дело доходит до вставки данных. Файлы хранилища неизменяемы, и ClickHouse не проверяет существующий первичный ключ перед вставкой строки, поэтому дедупликация требует чуть больше усилий. Это также означает, что дедупликация не является немедленной – она **окончательная**, что имеет несколько побочных эффектов:

- В любой момент времени в вашей таблице все еще могут быть дубликаты (строки с тем же ключом сортировки)
- Фактическое удаление дублирующихся строк происходит во время объединения parts
- Ваши запросы должны учитывать возможность дубликатов

<div class='transparent-table'>

|||
|------|----|
|<img src={deduplication} class="image" alt="Cassandra logo" style={{width: '16rem', 'background-color': 'transparent'}}/>|ClickHouse предоставляет бесплатное обучение по дедупликации и многим другим темам. Модуль обучения [Удаление и обновление данных](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse&utm_medium=docs) является хорошей отправной точкой.|

</div>

## Опции для дедупликации {#options-for-deduplication}

Дедупликация реализована в ClickHouse с использованием следующих движков таблиц:

1. Движок таблицы `ReplacingMergeTree`: с этим движком таблицы дублирующиеся строки с одинаковым ключом сортировки удаляются во время объединений. `ReplacingMergeTree` является хорошим вариантом для эмуляции поведения upsert (где вы хотите, чтобы запросы возвращали последнюю вставленную строку).

2. Сокращение строк: движки таблиц `CollapsingMergeTree` и `VersionedCollapsingMergeTree` используют логику, где существующая строка "отменяется", а новая строка вставляется. Их сложнее реализовать, чем `ReplacingMergeTree`, но ваши запросы и агрегаты могут быть проще для написания, не беспокоясь о том, были ли данные еще объединены. Эти два движка таблиц полезны, когда вам нужно часто обновлять данные.

Мы рассмотрим обе эти техники ниже. Для получения дополнительной информации загляните в наш бесплатный по запросу [модуль обучения по удалению и обновлению данных](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse&utm_medium=docs).

## Использование ReplacingMergeTree для Upserts {#using-replacingmergetree-for-upserts}

Давайте рассмотрим простой пример, когда таблица содержит комментарии Hacker News с колонкой views, представляющей количество раз, когда комментарий был просмотрен. Предположим, что мы вставляем новую строку, когда статья публикуется, и обновляем новую строку раз в день с общим количеством просмотров, если значение увеличивается:

```sql
CREATE TABLE hackernews_rmt (
    id UInt32,
    author String,
    comment String,
    views UInt64
)
ENGINE = ReplacingMergeTree
PRIMARY KEY (author, id)
```

Давайте вставим две строки:

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'Это пост #1', 0),
   (2, 'ch_fan', 'Это пост #2', 0)
```

Чтобы обновить колонку `views`, вставьте новую строку с тем же первичным ключом (обратите внимание на новые значения колонки `views`):

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'Это пост #1', 100),
   (2, 'ch_fan', 'Это пост #2', 200)
```

Теперь в таблице 4 строки:

```sql
SELECT *
FROM hackernews_rmt
```

```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │     0 │
│  1 │ ricardo │ Это пост #1     │     0 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │   200 │
│  1 │ ricardo │ Это пост #1     │   100 │
└────┴─────────┴─────────────────┴───────┘
```

Отдельные блоки выше в выводе демонстрируют две части за кулисами - эти данные еще не были объединены, поэтому дублирующие строки еще не были удалены. Давайте используем ключевое слово `FINAL` в запросе `SELECT`, что приведет к логическому объединению результата запроса:

```sql
SELECT *
FROM hackernews_rmt
FINAL
```

```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │   200 │
│  1 │ ricardo │ Это пост #1     │   100 │
└────┴─────────┴─────────────────┴───────┘
```

Результат содержит только 2 строки, и последняя вставленная строка - это строка, которая возвращается.

:::note
Использование `FINAL` нормально работает, если у вас небольшое количество данных. Если вы работаете с большим объемом данных, использование `FINAL` вероятно, не лучший вариант. Давайте обсудим лучший вариант для нахождения последнего значения колонки…
:::

### Избежание FINAL {#avoiding-final}

Давайте снова обновим колонку `views` для обеих уникальных строк:

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'Это пост #1', 150),
   (2, 'ch_fan', 'Это пост #2', 250)
```

В таблице теперь 6 строк, потому что фактическое объединение еще не произошло (только объединение во время запроса, когда мы использовали `FINAL`).

```sql
SELECT *
FROM hackernews_rmt
```

```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │   200 │
│  1 │ ricardo │ Это пост #1     │   100 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │     0 │
│  1 │ ricardo │ Это пост #1     │     0 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │   250 │
│  1 │ ricardo │ Это пост #1     │   150 │
└────┴─────────┴─────────────────┴───────┘
```

Вместо того чтобы использовать `FINAL`, давайте используем некоторую бизнес-логику - мы знаем, что колонка `views` всегда увеличивается, так что мы можем выбрать строку с наибольшим значением, используя функцию `max`, после группировки по желаемым колонкам:

```sql
SELECT
    id,
    author,
    comment,
    max(views)
FROM hackernews_rmt
GROUP BY (id, author, comment)
```

```response
┌─id─┬─author──┬─comment─────────┬─max(views)─┐
│  2 │ ch_fan  │ Это пост #2     │        250 │
│  1 │ ricardo │ Это пост #1     │        150 │
└────┴─────────┴─────────────────┴────────────┘
```

Группировка, показанная в запросе выше, может быть на самом деле более эффективной (с точки зрения производительности запроса), чем использование ключевого слова `FINAL`.

Наш [модуль обучения по удалению и обновлению данных](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse&utm_medium=docs) расширяет этот пример, включая то, как использовать колонку `version` с `ReplacingMergeTree`.

## Использование CollapsingMergeTree для частого обновления колонок {#using-collapsingmergetree-for-updating-columns-frequently}

Обновление колонки включает удаление существующей строки и замена ее новыми значениями. Как вы уже видели, такой тип мутации в ClickHouse происходит _в конечном итоге_ - во время объединений. Если вам нужно обновить много строк, на самом деле может быть эффективнее избежать `ALTER TABLE..UPDATE` и просто вставить новые данные вместе с существующими. Мы могли бы добавить колонку, которая обозначает, являются ли данные устаревшими или новыми... и на самом деле есть движок таблицы, который уже очень хорошо реализует это поведение, особенно учитывая, что он автоматически удаляет устаревшие данные за вас. Давайте посмотрим, как это работает.

Предположим, мы отслеживаем количество просмотров, которое имеет комментарий Hacker News, используя внешнюю систему, и каждые несколько часов мы отправляем данные в ClickHouse. Мы хотим, чтобы старые строки были удалены, а новые строки представляли новое состояние каждого комментария Hacker News. Мы можем использовать `CollapsingMergeTree`, чтобы реализовать это поведение.

Давайте определим таблицу, чтобы хранить количество просмотров:

```sql
CREATE TABLE hackernews_views (
    id UInt32,
    author String,
    views UInt64,
    sign Int8
)
ENGINE = CollapsingMergeTree(sign)
PRIMARY KEY (id, author)
```

Обратите внимание, что таблица `hackernews_views` имеет колонку `Int8` с именем sign, которая называется **колонка sign**. Имя колонки sign произвольное, но тип данных `Int8` обязателен, и обращаю внимание, что имя колонки было передано в конструктор таблицы `CollapsingMergeTree`.

Что же представляет собой колонка sign таблицы `CollapsingMergeTree`? Она представляет _состояние_ строки, и колонка sign может быть только 1 или -1. Вот как это работает:

- Если две строки имеют одинаковый первичный ключ (или порядок сортировки, если это отличается от первичного ключа), но разные значения колонки sign, то последняя вставленная строка с +1 становится строкой состояния, а остальные строки отменяют друг друга.
- Строки, которые отменяют друг друга, удаляются во время объединений.
- Строки, которые не имеют соответствующей пары, сохраняются.

Давайте добавим строку в таблицу `hackernews_views`. Поскольку это единственная строка для этого первичного ключа, мы устанавливаем ее состояние в 1:

```sql
INSERT INTO hackernews_views VALUES
   (123, 'ricardo', 0, 1)
```

Теперь предположим, что мы хотим изменить колонку views. Вы вставляете две строки: одну, которая отменяет существующую строку, и одну, которая содержит новое состояние строки:

```sql
INSERT INTO hackernews_views VALUES
   (123, 'ricardo', 0, -1),
   (123, 'ricardo', 150, 1)
```

Теперь в таблице 3 строки с первичным ключом `(123, 'ricardo')`:

```sql
SELECT *
FROM hackernews_views
```

```response
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │     0 │   -1 │
│ 123 │ ricardo │   150 │    1 │
└─────┴─────────┴───────┴──────┘
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │     0 │    1 │
└─────┴─────────┴───────┴──────┘
```

Обратите внимание, что добавление `FINAL` возвращает текущую строку состояния:

```sql
SELECT *
FROM hackernews_views
FINAL
```

```response
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │   150 │    1 │
└─────┴─────────┴───────┴──────┘
```

Но, конечно, использование `FINAL` не рекомендуется для больших таблиц.

:::note
Значение, переданное в колонку `views` в нашем примере, на самом деле не обязательно, и не обязательно соответствовать текущему значению `views` старой строки. На самом деле, вы можете отменить строку, используя только первичный ключ и -1:

```sql
INSERT INTO hackernews_views(id, author, sign) VALUES
   (123, 'ricardo', -1)
```
:::

## Обновления в реальном времени из нескольких потоков {#real-time-updates-from-multiple-threads}

С таблицей `CollapsingMergeTree` строки отменяют друг друга, используя колонку sign, и состояние строки определяется последней вставленной строкой. Но это может быть проблематично, если вы вставляете строки из различных потоков, где строки могут вставляться вне порядка. Использование "последней" строки не работает в этой ситуации.

Здесь на помощь приходит `VersionedCollapsingMergeTree` - он сокращает строки так же, как `CollapsingMergeTree`, но вместо того, чтобы удерживать последнюю вставленную строку, он сохраняет строку с наибольшим значением указанной вами колонки version.

Давайте рассмотрим пример. Допустим, мы хотим отслеживать количество просмотров наших комментариев Hacker News, и данные обновляются часто. Мы хотим, чтобы отчеты использовали последние значения, не вызывая и не дожидаясь объединений. Мы начинаем с таблицы, аналогичной `CollapsedMergeTree`, за исключением того, что добавляем колонку для хранения версии состояния строки:

```sql
CREATE TABLE hackernews_views_vcmt (
    id UInt32,
    author String,
    views UInt64,
    sign Int8,
    version UInt32
)
ENGINE = VersionedCollapsingMergeTree(sign, version)
PRIMARY KEY (id, author)
```

Обратите внимание, что таблица использует `VersionedCollapsingMergeTree` в качестве движка и передает в него **колонку sign** и **колонку version**. Вот как работает таблица:

- Она удаляет каждую пару строк, которые имеют одинаковый первичный ключ и версию и разные sign.
- Порядок вставки строк не имеет значения.
- Обратите внимание, что если колонка version не является частью первичного ключа, ClickHouse добавляет ее в первичный ключ неявно как последнее поле.

Вы используете такую же логику при написании запросов - группируйтесь по первичному ключу и используйте умную логику, чтобы избегать строк, которые были отменены, но еще не удалены. Давайте добавим некоторые строки в таблицу `hackernews_views_vcmt`:

```sql
INSERT INTO hackernews_views_vcmt VALUES
   (1, 'ricardo', 0, 1, 1),
   (2, 'ch_fan', 0, 1, 1),
   (3, 'kenny', 0, 1, 1)
```

Теперь мы обновляем две из строк и удаляем одну из них. Чтобы отменить строку, обязательно укажите предыдущий номер версии (поскольку он является частью первичного ключа):

```sql
INSERT INTO hackernews_views_vcmt VALUES
   (1, 'ricardo', 0, -1, 1),
   (1, 'ricardo', 50, 1, 2),
   (2, 'ch_fan', 0, -1, 1),
   (3, 'kenny', 0, -1, 1),
   (3, 'kenny', 1000, 1, 2)
```

Мы выполним тот же запрос, что и раньше, который умно добавляет и вычитает значения на основе колонки sign:

```sql
SELECT
    id,
    author,
    sum(views * sign)
FROM hackernews_views_vcmt
GROUP BY (id, author)
HAVING sum(sign) > 0
ORDER BY id ASC
```

Результат - две строки:

```response
┌─id─┬─author──┬─sum(multiply(views, sign))─┐
│  1 │ ricardo │                         50 │
│  3 │ kenny   │                       1000 │
└────┴─────────┴────────────────────────────┘
```

Давайте принудительно объединим таблицу:

```sql
OPTIMIZE TABLE hackernews_views_vcmt
```

В результате должно остаться только две строки:

```sql
SELECT *
FROM hackernews_views_vcmt
```

```response
┌─id─┬─author──┬─views─┬─sign─┬─version─┐
│  1 │ ricardo │    50 │    1 │       2 │
│  3 │ kenny   │  1000 │    1 │       2 │
└────┴─────────┴───────┴──────┴─────────┘
```

Таблица `VersionedCollapsingMergeTree` весьма полезна, когда вы хотите реализовать дедупликацию при вставке строк от нескольких клиентов и/или потоков.

## Почему мои строки не дедуплицируются? {#why-arent-my-rows-being-deduplicated}

Одной из причин, по которой вставленные строки могут не дедуплицироваться, является использование неидемпотентной функции или выражения в вашем операторе `INSERT`. Например, если вы вставляете строки со столбцом `createdAt DateTime64(3) DEFAULT now()`, ваши строки гарантированно будут уникальными, потому что каждая строка будет иметь уникальное значение по умолчанию для столбца `createdAt`. Движок таблицы MergeTree / ReplicatedMergeTree не будет знать о необходимости дедупликации строк, так как каждая вставленная строка будет генерировать уникальную контрольную сумму.

В этом случае вы можете указать свой собственный `insert_deduplication_token` для каждой группы строк, чтобы гарантировать, что множественные вставки одной и той же группы не приведут к повторному вставлению одних и тех же строк. Пожалуйста, обратитесь к [документации по `insert_deduplication_token`](/operations/settings/settings#insert_deduplication_token) для получения дополнительной информации о том, как использовать эту настройку.

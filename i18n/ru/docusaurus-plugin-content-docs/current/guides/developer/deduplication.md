---
slug: /guides/developer/deduplication
sidebar_label: 'Стратегии дедупликации'
sidebar_position: 3
description: 'Используйте дедупликацию при необходимости частого выполнения операций upsert, обновления и удаления.'
title: 'Стратегии дедупликации'
keywords: ['стратегии дедупликации', 'дедупликация данных', 'операции upsert', 'обновления и удаления', 'руководство разработчика']
doc_type: 'guide'
---

import deduplication from '@site/static/images/guides/developer/de_duplication.png';
import Image from '@theme/IdealImage';


# Стратегии дедупликации

**Дедупликация** — это процесс ***удаления дублирующихся строк из набора данных***. В OLTP-базах данных это делается легко, поскольку каждая строка имеет уникальный первичный ключ, но ценой более медленных вставок. Каждую вставляемую строку необходимо сначала найти и, если она существует, заменить.

ClickHouse создан для высокой скорости вставки данных. Файлы хранения неизменяемы, и ClickHouse не проверяет наличие существующего первичного ключа перед вставкой строки — поэтому дедупликация требует несколько больше усилий. Это также означает, что дедупликация происходит не мгновенно, а **постепенно**, что имеет несколько побочных эффектов:

- В любой момент времени ваша таблица может содержать дубликаты (строки с одинаковым ключом сортировки)
- Фактическое удаление дублирующихся строк происходит во время слияния частей
- Ваши запросы должны учитывать возможность наличия дубликатов

<div class='transparent-table'>

|||
|------|----|
|<Image img={deduplication}  alt="Deduplication Logo" size="sm"/>|ClickHouse предоставляет бесплатное обучение по дедупликации и многим другим темам. [Учебный модуль по удалению и обновлению данных](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse&utm_medium=docs) — хорошая отправная точка.|

</div>



## Варианты дедупликации {#options-for-deduplication}

Дедупликация в ClickHouse реализуется с использованием следующих движков таблиц:

1. Движок таблиц `ReplacingMergeTree`: при использовании этого движка дублирующиеся строки с одинаковым ключом сортировки удаляются во время слияний. `ReplacingMergeTree` — хороший вариант для эмуляции поведения upsert (когда требуется, чтобы запросы возвращали последнюю вставленную строку).

2. Схлопывание строк: движки таблиц `CollapsingMergeTree` и `VersionedCollapsingMergeTree` используют логику, при которой существующая строка «отменяется» и вставляется новая строка. Они сложнее в реализации, чем `ReplacingMergeTree`, но запросы и агрегации могут быть проще в написании, так как не нужно беспокоиться о том, были ли данные уже слиты. Эти два движка полезны, когда необходимо часто обновлять данные.

Ниже мы рассмотрим оба этих метода. Для получения более подробной информации ознакомьтесь с нашим бесплатным обучающим модулем [Deleting and Updating Data](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse&utm_medium=docs), доступным по запросу.


## Использование ReplacingMergeTree для операций Upsert {#using-replacingmergetree-for-upserts}

Рассмотрим простой пример, где таблица содержит комментарии Hacker News со столбцом views, представляющим количество просмотров комментария. Предположим, мы вставляем новую строку при публикации статьи и выполняем upsert новой строки раз в день с общим количеством просмотров, если значение увеличивается:

```sql
CREATE TABLE hackernews_rmt (
    id UInt32,
    author String,
    comment String,
    views UInt64
)
ENGINE = ReplacingMergeTree
PRIMARY KEY (author, id)
```

Вставим две строки:

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'This is post #1', 0),
   (2, 'ch_fan', 'This is post #2', 0)
```

Чтобы обновить столбец `views`, вставьте новую строку с тем же первичным ключом (обратите внимание на новые значения столбца `views`):

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'This is post #1', 100),
   (2, 'ch_fan', 'This is post #2', 200)
```

Теперь в таблице 4 строки:

```sql
SELECT *
FROM hackernews_rmt
```

```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ This is post #2 │     0 │
│  1 │ ricardo │ This is post #1 │     0 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ This is post #2 │   200 │
│  1 │ ricardo │ This is post #1 │   100 │
└────┴─────────┴─────────────────┴───────┘
```

Отдельные блоки в выводе выше демонстрируют две части внутреннего устройства — эти данные еще не были объединены, поэтому дублирующиеся строки еще не удалены. Используем ключевое слово `FINAL` в запросе `SELECT`, что приводит к логическому слиянию результата запроса:

```sql
SELECT *
FROM hackernews_rmt
FINAL
```

```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ This is post #2 │   200 │
│  1 │ ricardo │ This is post #1 │   100 │
└────┴─────────┴─────────────────┴───────┘
```

Результат содержит только 2 строки, и возвращается последняя вставленная строка.

:::note
Использование `FINAL` работает приемлемо, если у вас небольшой объем данных. Если вы работаете с большим объемом данных,
использование `FINAL`, вероятно, не лучший вариант. Рассмотрим более эффективный способ
получения последнего значения столбца.
:::

### Как избежать использования FINAL {#avoiding-final}

Обновим столбец `views` снова для обеих уникальных строк:

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'This is post #1', 150),
   (2, 'ch_fan', 'This is post #2', 250)
```

Теперь в таблице 6 строк, потому что фактическое слияние еще не произошло (только слияние во время выполнения запроса, когда мы использовали `FINAL`).

```sql
SELECT *
FROM hackernews_rmt
```


```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ This is post #2 │   200 │
│  1 │ ricardo │ This is post #1 │   100 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ This is post #2 │     0 │
│  1 │ ricardo │ This is post #1 │     0 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ This is post #2 │   250 │
│  1 │ ricardo │ This is post #1 │   150 │
└────┴─────────┴─────────────────┴───────┘
```

Вместо использования `FINAL` применим бизнес-логику — мы знаем, что значения в столбце `views` всегда возрастают, поэтому можем выбрать строку с максимальным значением с помощью функции `max` после группировки по нужным столбцам:

```sql
SELECT
    id,
    author,
    comment,
    max(views)
FROM hackernews_rmt
GROUP BY (id, author, comment)
```

```response
┌─id─┬─author──┬─comment─────────┬─max(views)─┐
│  2 │ ch_fan  │ Это пост №2 │        250 │
│  1 │ ricardo │ Это пост №1 │        150 │
└────┴─────────┴─────────────────┴────────────┘
```

Группировка, показанная в запросе выше, на самом деле может быть более эффективной (с точки зрения производительности запроса), чем использование ключевого слова `FINAL`.

Наш [учебный модуль по удалению и обновлению данных](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse\&utm_medium=docs) развивает этот пример, включая то, как использовать столбец `version` с `ReplacingMergeTree`.


## Использование CollapsingMergeTree для частого обновления столбцов {#using-collapsingmergetree-for-updating-columns-frequently}

Обновление столбца включает удаление существующей строки и замену её новыми значениями. Как вы уже видели, этот тип мутации в ClickHouse происходит _в конечном счёте_ — во время слияний. Если у вас много строк для обновления, может оказаться более эффективным избегать `ALTER TABLE..UPDATE` и вместо этого просто вставлять новые данные вместе с существующими. Мы могли бы добавить столбец, который указывает, являются ли данные устаревшими или новыми... и на самом деле существует движок таблиц, который уже реализует такое поведение очень удачно, особенно учитывая, что он автоматически удаляет устаревшие данные. Давайте посмотрим, как это работает.

Предположим, мы отслеживаем количество просмотров комментария Hacker News с помощью внешней системы и каждые несколько часов загружаем данные в ClickHouse. Мы хотим, чтобы старые строки удалялись, а новые строки представляли актуальное состояние каждого комментария Hacker News. Для реализации такого поведения можно использовать `CollapsingMergeTree`.

Давайте определим таблицу для хранения количества просмотров:

```sql
CREATE TABLE hackernews_views (
    id UInt32,
    author String,
    views UInt64,
    sign Int8
)
ENGINE = CollapsingMergeTree(sign)
PRIMARY KEY (id, author)
```

Обратите внимание, что таблица `hackernews_views` содержит столбец `Int8` с именем sign, который называется столбцом **знака**. Имя столбца знака произвольное, но тип данных `Int8` обязателен, и обратите внимание, что имя столбца передаётся в конструктор таблицы `CollapsingMergeTree`.

Что такое столбец знака таблицы `CollapsingMergeTree`? Он представляет _состояние_ строки, и столбец знака может принимать только значения 1 или -1. Вот как это работает:

- Если две строки имеют одинаковый первичный ключ (или порядок сортировки, если он отличается от первичного ключа), но разные значения столбца знака, то последняя вставленная строка со значением +1 становится строкой состояния, а остальные строки взаимно аннулируются
- Строки, которые взаимно аннулируются, удаляются во время слияний
- Строки, не имеющие соответствующей пары, сохраняются

Давайте добавим строку в таблицу `hackernews_views`. Поскольку это единственная строка для данного первичного ключа, устанавливаем её состояние равным 1:

```sql
INSERT INTO hackernews_views VALUES
   (123, 'ricardo', 0, 1)
```

Теперь предположим, что мы хотим изменить столбец views. Вставляем две строки: одну, которая аннулирует существующую строку, и одну, которая содержит новое состояние строки:

```sql
INSERT INTO hackernews_views VALUES
   (123, 'ricardo', 0, -1),
   (123, 'ricardo', 150, 1)
```

Теперь в таблице есть 3 строки с первичным ключом `(123, 'ricardo')`:

```sql
SELECT *
FROM hackernews_views
```

```response
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │     0 │   -1 │
│ 123 │ ricardo │   150 │    1 │
└─────┴─────────┴───────┴──────┘
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │     0 │    1 │
└─────┴─────────┴───────┴──────┘
```

Обратите внимание, что добавление `FINAL` возвращает текущую строку состояния:

```sql
SELECT *
FROM hackernews_views
FINAL
```

```response
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │   150 │    1 │
└─────┴─────────┴───────┴──────┘
```

Но, конечно, использование `FINAL` не рекомендуется для больших таблиц.

:::note
Значение, переданное для столбца `views` в нашем примере, на самом деле не требуется, и оно не обязано совпадать с текущим значением `views` старой строки. Фактически, вы можете аннулировать строку, указав только первичный ключ и -1:

```sql
INSERT INTO hackernews_views(id, author, sign) VALUES
   (123, 'ricardo', -1)
```

:::


## Обновления в реальном времени из нескольких потоков {#real-time-updates-from-multiple-threads}

В таблице `CollapsingMergeTree` строки взаимно аннулируются с помощью столбца знака, а состояние строки определяется последней вставленной строкой. Однако это может вызвать проблемы при вставке строк из разных потоков, когда строки могут быть вставлены не по порядку. В такой ситуации использование "последней" строки не работает.

Здесь на помощь приходит `VersionedCollapsingMergeTree` — он сворачивает строки так же, как `CollapsingMergeTree`, но вместо сохранения последней вставленной строки сохраняет строку с наибольшим значением указанного вами столбца версии.

Рассмотрим пример. Предположим, мы хотим отслеживать количество просмотров наших комментариев на Hacker News, и данные часто обновляются. Мы хотим, чтобы в отчетах использовались актуальные значения без принудительного выполнения или ожидания слияний. Начнем с таблицы, похожей на `CollapsingMergeTree`, но добавим столбец для хранения версии состояния строки:

```sql
CREATE TABLE hackernews_views_vcmt (
    id UInt32,
    author String,
    views UInt64,
    sign Int8,
    version UInt32
)
ENGINE = VersionedCollapsingMergeTree(sign, version)
PRIMARY KEY (id, author)
```

Обратите внимание, что таблица использует `VersionedCollapsingMergeTree` в качестве движка и передает **столбец знака** и **столбец версии**. Вот как работает таблица:

- Она удаляет каждую пару строк с одинаковым первичным ключом и версией, но разными знаками
- Порядок вставки строк не имеет значения
- Обратите внимание: если столбец версии не является частью первичного ключа, ClickHouse неявно добавляет его в первичный ключ как последнее поле

При написании запросов используется та же логика — группировка по первичному ключу и применение специальной логики для исключения строк, которые были аннулированы, но еще не удалены. Добавим несколько строк в таблицу `hackernews_views_vcmt`:

```sql
INSERT INTO hackernews_views_vcmt VALUES
   (1, 'ricardo', 0, 1, 1),
   (2, 'ch_fan', 0, 1, 1),
   (3, 'kenny', 0, 1, 1)
```

Теперь обновим две строки и удалим одну из них. Чтобы аннулировать строку, обязательно укажите предыдущий номер версии (поскольку он является частью первичного ключа):

```sql
INSERT INTO hackernews_views_vcmt VALUES
   (1, 'ricardo', 0, -1, 1),
   (1, 'ricardo', 50, 1, 2),
   (2, 'ch_fan', 0, -1, 1),
   (3, 'kenny', 0, -1, 1),
   (3, 'kenny', 1000, 1, 2)
```

Выполним тот же запрос, что и ранее, который складывает и вычитает значения на основе столбца знака:

```sql
SELECT
    id,
    author,
    sum(views * sign)
FROM hackernews_views_vcmt
GROUP BY (id, author)
HAVING sum(sign) > 0
ORDER BY id ASC
```

Результат — две строки:

```response
┌─id─┬─author──┬─sum(multiply(views, sign))─┐
│  1 │ ricardo │                         50 │
│  3 │ kenny   │                       1000 │
└────┴─────────┴────────────────────────────┘
```

Принудительно выполним слияние таблицы:

```sql
OPTIMIZE TABLE hackernews_views_vcmt
```

В результате должно остаться только две строки:

```sql
SELECT *
FROM hackernews_views_vcmt
```

```response
┌─id─┬─author──┬─views─┬─sign─┬─version─┐
│  1 │ ricardo │    50 │    1 │       2 │
│  3 │ kenny   │  1000 │    1 │       2 │
└────┴─────────┴───────┴──────┴─────────┘
```

Таблица `VersionedCollapsingMergeTree` очень удобна, когда необходимо реализовать дедупликацию при вставке строк из нескольких клиентов и/или потоков.


## Почему мои строки не дедуплицируются? {#why-arent-my-rows-being-deduplicated}

Одна из причин, по которой вставленные строки могут не дедуплицироваться — использование неидемпотентной функции или выражения в операторе `INSERT`. Например, при вставке строк со столбцом `createdAt DateTime64(3) DEFAULT now()` строки гарантированно будут уникальными, поскольку каждая строка получит уникальное значение по умолчанию для столбца `createdAt`. Движок таблиц MergeTree / ReplicatedMergeTree не сможет дедуплицировать строки, так как каждая вставленная строка будет генерировать уникальную контрольную сумму.

В этом случае можно указать собственный `insert_deduplication_token` для каждого пакета строк, чтобы многократные вставки одного и того же пакета не приводили к повторной вставке одних и тех же строк. Подробнее об использовании этой настройки см. в [документации по `insert_deduplication_token`](/operations/settings/settings#insert_deduplication_token).

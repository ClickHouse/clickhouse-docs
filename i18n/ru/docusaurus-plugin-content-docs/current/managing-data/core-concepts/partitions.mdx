---
slug: /partitions
title: 'Партиции таблиц'
description: 'Что такое партиции таблиц в ClickHouse'
keywords: ['партиции', 'partition by']
doc_type: 'guide'
---

import partitions from '@site/static/images/managing-data/core-concepts/partitions.png';
import merges_with_partitions from '@site/static/images/managing-data/core-concepts/merges_with_partitions.png';
import partition_pruning from '@site/static/images/managing-data/core-concepts/partition-pruning.png';
import Image from '@theme/IdealImage';


## Что такое партиции таблиц в ClickHouse? \{#what-are-table-partitions-in-clickhouse\}

<br/>

Партиции объединяют [части данных](/parts) таблицы в [семействе движков MergeTree](/engines/table-engines/mergetree-family) в упорядоченные логические единицы — это способ организации данных, который имеет понятный смысл и привязан к конкретным критериям, таким как временные диапазоны, категории или другие ключевые атрибуты. Такие логические единицы упрощают управление данными, выполнение запросов и их оптимизацию.

### PARTITION BY

Партиционирование можно включить при создании таблицы с помощью [конструкции PARTITION BY](/engines/table-engines/mergetree-family/custom-partitioning-key). В ней может быть указано SQL-выражение по любым столбцам, результат которого определяет, к какой партиции относится строка.

Чтобы продемонстрировать это, мы [расширим](https://sql.clickhouse.com/?query=U0hPVyBDUkVBVEUgVEFCTEUgdWsudWtfcHJpY2VfcGFpZF9zaW1wbGVfcGFydGl0aW9uZWQ\&run_query=true\&tab=results) пример таблицы из раздела [What are table parts](/parts), добавив конструкцию `PARTITION BY toStartOfMonth(date)`, которая группирует части данных таблицы по месяцам продаж недвижимости:

```sql
CREATE TABLE uk.uk_price_paid_simple_partitioned
(
    date Date,
    town LowCardinality(String),
    street LowCardinality(String),
    price UInt32
)
ENGINE = MergeTree
ORDER BY (town, street)
PARTITION BY toStartOfMonth(date);
```

Вы можете [выполнить запрос к этой таблице](https://sql.clickhouse.com/?query=U0VMRUNUICogRlJPTSB1ay51a19wcmljZV9wYWlkX3NpbXBsZV9wYXJ0aXRpb25lZA\&run_query=true\&tab=results) в нашей песочнице ClickHouse SQL.


### Структура на диске \{#structure-on-disk\}

Каждый раз, когда в таблицу вставляют набор строк, вместо создания (как [минимум](/operations/settings/settings#max_insert_block_size)) одного единственного фрагмента данных, содержащего все вставленные строки (как описано [здесь](/parts)), ClickHouse создает новый фрагмент данных для каждого уникального значения ключа партиционирования среди вставленных строк:

<Image img={partitions} size="lg"  alt="ОБРАБОТКА INSERT" />

<br/>

Сервер ClickHouse сначала разбивает строки из примерной операции INSERT с 4 строками, показанной на схеме выше, по значению ключа партиционирования `toStartOfMonth(date)`.
Затем для каждой найденной партиции строки обрабатываются [обычным образом](/parts), проходя несколько последовательных шагов (① Сортировка, ② Разделение на столбцы, ③ Сжатие, ④ Запись на диск).

Обратите внимание, что при включённом партиционировании ClickHouse автоматически создает индексы [MinMax](https://github.com/ClickHouse/ClickHouse/blob/dacc8ebb0dac5bbfce5a7541e7fc70f26f7d5065/src/Storages/MergeTree/IMergeTreeDataPart.h#L341) для каждого фрагмента данных. Это просто файлы для каждого столбца таблицы, используемого в выражении ключа партиционирования, содержащие минимальное и максимальное значения этого столбца внутри данного фрагмента данных.

### Слияния по разделам \{#per-partition-merges\}

При включённом партиционировании ClickHouse [сливает](/merges) части данных только внутри разделов, но не между ними. Ниже это показано на примере нашей таблицы из предыдущего раздела:

<Image img={merges_with_partitions} size="lg"  alt="СЛИЯНИЯ ЧАСТЕЙ ПО РАЗДЕЛАМ" />

<br/>

Как показано на схеме выше, части, относящиеся к разным разделам, никогда не сливаются. Если выбран ключ партиционирования с высокой кардинальностью, части, распределённые по тысячам разделов, никогда не станут кандидатами на слияние — будут превышены предустановленные лимиты, что приведёт к печально известной ошибке `Too many ^^parts^^`. Решение этой проблемы простое: выберите разумный ключ партиционирования с [кардинальностью в пределах 1000–10000](https://github.com/ClickHouse/ClickHouse/blob/ffc5b2c56160b53cf9e5b16cfb73ba1d956f7ce4/src/Storages/MergeTree/MergeTreeDataWriter.cpp#L121).

## Мониторинг партиций

Вы можете [получить](https://sql.clickhouse.com/?query=U0VMRUNUIERJU1RJTkNUIF9wYXJ0aXRpb25fdmFsdWUgQVMgcGFydGl0aW9uCkZST00gdWsudWtfcHJpY2VfcGFpZF9zaW1wbGVfcGFydGl0aW9uZWQKT1JERVIgQlkgcGFydGl0aW9uIEFTQw\&run_query=true\&tab=results) список всех уникальных партиций таблицы из нашего примера, используя [виртуальный столбец](/engines/table-engines#table_engines-virtual_columns) `_partition_value`:

```sql runnable
SELECT DISTINCT _partition_value AS partition
FROM uk.uk_price_paid_simple_partitioned
ORDER BY partition ASC;
```

Кроме того, ClickHouse отслеживает все парты и партиции всех таблиц в системной таблице [system.parts](/operations/system-tables/parts), и следующий запрос [возвращает](https://sql.clickhouse.com/?query=U0VMRUNUCiAgICBwYXJ0aXRpb24sCiAgICBjb3VudCgpIEFTIHBhcnRzLAogICAgc3VtKHJvd3MpIEFTIHJvd3MKRlJPTSBzeXN0ZW0ucGFydHMKV0hFUkUgKGRhdGFiYXNlID0gJ3VrJykgQU5EIChgdGFibGVgID0gJ3VrX3ByaWNlX3BhaWRfc2ltcGxlX3BhcnRpdGlvbmVkJykgQU5EIGFjdGl2ZQpHUk9VUCBCWSBwYXJ0aXRpb24KT1JERVIgQlkgcGFydGl0aW9uIEFTQzs\&run_query=true\&tab=results) для приведённой выше примерной таблицы список всех партиций, а также текущее количество активных партов и сумму строк в этих партах по каждой партиции:

```sql runnable
SELECT
    partition,
    count() AS parts,
    sum(rows) AS rows
FROM system.parts
WHERE (database = 'uk') AND (`table` = 'uk_price_paid_simple_partitioned') AND active
GROUP BY partition
ORDER BY partition ASC;
```


## Для чего используются разделы таблиц? \{#what-are-table-partitions-used-for\}

### Управление данными

В ClickHouse партиционирование в первую очередь является механизмом управления данными. Логически организуя данные на основе выражения партиционирования, можно управлять каждой партицией независимо. Например, схема партиционирования в приведённой выше таблице позволяет реализовать сценарий, когда в основной таблице хранятся только данные за последние 12 месяцев, а более старые данные автоматически удаляются с помощью [правила TTL](/guides/developer/ttl) (см. добавленную последнюю строку DDL-запроса):

```sql
CREATE TABLE uk.uk_price_paid_simple_partitioned
(
    date Date,
    town LowCardinality(String),
    street LowCardinality(String),
    price UInt32
)
ENGINE = MergeTree
PARTITION BY toStartOfMonth(date)
ORDER BY (town, street)
TTL date + INTERVAL 12 MONTH DELETE;
```

Поскольку таблица партиционирована по `toStartOfMonth(date)`, целые партиции (наборы [частей таблицы](/parts)), удовлетворяющие условию TTL, будут удалены, что делает операцию очистки более эффективной — [без необходимости перезаписывать части](/sql-reference/statements/alter#mutations).

Аналогично, вместо удаления старых данных их можно автоматически и эффективно перемещать на более экономичный [уровень хранилища](/integrations/s3#storage-tiers):

```sql
CREATE TABLE uk.uk_price_paid_simple_partitioned
(
    date Date,
    town LowCardinality(String),
    street LowCardinality(String),
    price UInt32
)
ENGINE = MergeTree
PARTITION BY toStartOfMonth(date)
ORDER BY (town, street)
TTL date + INTERVAL 12 MONTH TO VOLUME 'slow_but_cheap';
```


### Оптимизация запросов

Разбиение данных на партиции может помочь с производительностью запросов, но это сильно зависит от характера доступа к данным. Если запросы обращаются только к нескольким партициям (в идеале к одной), производительность может улучшиться. Это обычно полезно только в том случае, если ключ партиционирования не входит в первичный ключ и вы фильтруете по нему, как показано в примере запроса ниже.

```sql runnable
SELECT MAX(price) AS highest_price
FROM uk.uk_price_paid_simple_partitioned
WHERE date >= '2020-12-01'
  AND date <= '2020-12-31'
  AND town = 'LONDON';
```

Запрос выполняется над приведённой выше примерной таблицей и [вычисляет](https://sql.clickhouse.com/?query=U0VMRUNUIE1BWChwcmljZSkgQVMgaGlnaGVzdF9wcmljZQpGUk9NIHVrLnVrX3ByaWNlX3BhaWRfc2ltcGxlX3BhcnRpdGlvbmVkCldIRVJFIGRhdGUgPj0gJzIwMjAtMTItMDEnCiAgQU5EIGRhdGUgPD0gJzIwMjAtMTItMzEnCiAgQU5EIHRvd24gPSAnTE9ORE9OJzs\&run_query=true\&tab=results) наивысшую цену среди всех проданных объектов недвижимости в Лондоне в декабре 2020 года, фильтруя по столбцу (`date`), используемому в ключе партиционирования таблицы, и по столбцу (`town`), используемому в первичном ключе таблицы (при этом `date` не является частью первичного ключа).

ClickHouse обрабатывает этот запрос, последовательно применяя методы отсечения данных, чтобы избежать обработки нерелевантных данных:

<Image img={partition_pruning} size="lg" alt="PART MERGES 2" />

<br />

① **Отсечение партиций (partition pruning)**: [MinMax-индексы](/partitions#what-are-table-partitions-in-clickhouse) используются для игнорирования целых партиций (наборов частей), которые логически не могут удовлетворять фильтру запроса по столбцам, используемым в ключе партиционирования таблицы.

② **Отсечение гранул (granule pruning)**: для оставшихся после шага ① частей данных их [первичный индекс](/guides/best-practices/sparse-primary-indexes) используется для игнорирования всех [гранул](/guides/best-practices/sparse-primary-indexes#data-is-organized-into-granules-for-parallel-data-processing) (блоков строк), которые логически не могут удовлетворять фильтру запроса по столбцам, используемым в первичном ключе таблицы.

Мы можем наблюдать эти шаги отсечения данных, [изучая](https://sql.clickhouse.com/?query=RVhQTEFJTiBpbmRleGVzID0gMQpTRUxFQ1QgTUFYKHByaWNlKSBBUyBoaWdoZXN0X3ByaWNlCkZST00gdWsudWtfcHJpY2VfcGFpZF9zaW1wbGVfcGFydGl0aW9uZWQKV0hFUkUgZGF0ZSA-PSAnMjAyMC0xMi0wMScKICBBTkQgZGF0ZSA8PSAnMjAyMC0xMi0zMScKICBBTkQgdG93biA9ICdMT05ET04nOw\&run_query=true\&tab=results) физический план выполнения запроса для нашего примерного запроса выше с помощью оператора [EXPLAIN](/sql-reference/statements/explain):


```sql style="fontSize:13px"
EXPLAIN indexes = 1
SELECT MAX(price) AS highest_price
FROM uk.uk_price_paid_simple_partitioned
WHERE date >= '2020-12-01'
  AND date <= '2020-12-31'
  AND town = 'LONDON';

    ┌─explain──────────────────────────────────────────────────────────────────────────────────────────────────────┐
 1. │ Expression ((Project names + Projection))                                                                    │
 2. │   Aggregating                                                                                                │
 3. │     Expression (Before GROUP BY)                                                                             │
 4. │       Expression                                                                                             │
 5. │         ReadFromMergeTree (uk.uk_price_paid_simple_partitioned)                                              │
 6. │         Indexes:                                                                                             │
 7. │           MinMax                                                                                             │
 8. │             Keys:                                                                                            │
 9. │               date                                                                                           │
10. │             Condition: and((date in (-Inf, 18627]), (date in [18597, +Inf)))                                 │
11. │             Parts: 1/436                                                                                     │
12. │             Granules: 11/3257                                                                                │
13. │           Partition                                                                                          │
14. │             Keys:                                                                                            │
15. │               toStartOfMonth(date)                                                                           │
16. │             Condition: and((toStartOfMonth(date) in (-Inf, 18597]), (toStartOfMonth(date) in [18597, +Inf))) │
17. │             Parts: 1/1                                                                                       │
18. │             Granules: 11/11                                                                                  │
19. │           PrimaryKey                                                                                         │
20. │             Keys:                                                                                            │
21. │               town                                                                                           │
22. │             Condition: (town in ['LONDON', 'LONDON'])                                                        │
23. │             Parts: 1/1                                                                                       │
24. │             Granules: 1/11                                                                                   │
    └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

Вывод выше показывает:

① Отсечение партиций (partition pruning): строки с 7 по 18 вывода EXPLAIN, показанного выше, показывают, что ClickHouse сначала использует [MinMax-индекс](/partitions#what-are-table-partitions-in-clickhouse) поля `date`, чтобы найти 11 из 3257 существующих [гранул](/guides/best-practices/sparse-primary-indexes#data-is-organized-into-granules-for-parallel-data-processing) (блоков строк), которые хранятся в 1 из 436 существующих активных частей данных (data parts) и содержат строки, удовлетворяющие `date`‑фильтру запроса.

② Отсечение гранул (granule pruning): строки с 19 по 24 вывода EXPLAIN, показанного выше, указывают, что ClickHouse затем использует [первичный индекс](/guides/best-practices/sparse-primary-indexes) (созданный по полю `town`) части данных, определённой на шаге ①, чтобы далее сократить число гранул (которые содержат строки, потенциально также удовлетворяющие `town`‑фильтру запроса) с 11 до 1. Это также отражено в выводе ClickHouse-client, который мы привели выше для выполненного запроса:

```response
... Затрачено: 0.006 сек. Обработано 8.19 тыс. строк, 57.34 КБ (1.36 млн строк/с., 9.49 МБ/с.)
Пиковое потребление памяти: 2.73 МиБ.
```

Это означает, что ClickHouse просканировал и обработал одну гранулу (блок из [8192](/operations/settings/merge-tree-settings#index_granularity) строк) за 6 миллисекунд при вычислении результата запроса.


### Партиционирование — в первую очередь механизм управления данными

Имейте в виду, что выполнение запроса по всем партициям обычно медленнее, чем выполнение того же запроса по непартиционированной таблице.

При партиционировании данные, как правило, распределяются по большему числу партиций и частей данных, что часто приводит к тому, что ClickHouse сканирует и обрабатывает больший объём данных.

Мы можем продемонстрировать это, запустив один и тот же запрос как для примерной таблицы из раздела [What are table parts](/parts) (без включённого партиционирования), так и для нашей текущей примерной таблицы выше (с включённым партиционированием). Обе таблицы [содержат](https://sql.clickhouse.com/?query=U0VMRUNUCiAgICB0YWJsZSwKICAgIHN1bShyb3dzKSBBUyByb3dzCkZST00gc3lzdGVtLnBhcnRzCldIRVJFIChkYXRhYmFzZSA9ICd1aycpIEFORCAoYHRhYmxlYCBJTiBbJ3VrX3ByaWNlX3BhaWRfc2ltcGxlJywgJ3VrX3ByaWNlX3BhaWRfc2ltcGxlX3BhcnRpdGlvbmVkJ10pIEFORCBhY3RpdmUKR1JPVVAgQlkgdGFibGU7\&run_query=true\&tab=results) одни и те же данные и одинаковое количество строк:

```sql runnable
SELECT
    table,
    sum(rows) AS rows
FROM system.parts
WHERE (database = 'uk') AND (table IN ['uk_price_paid_simple', 'uk_price_paid_simple_partitioned']) AND active
GROUP BY table;
```

Однако таблица с включёнными партициями [имеет](https://sql.clickhouse.com/?query=U0VMRUNUCiAgICB0YWJsZSwKICAgIGNvdW50KCkgQVMgcGFydHMKRlJPTSBzeXN0ZW0ucGFydHMKV0hFUkUgKGRhdGFiYXNlID0gJ3VrJykgQU5EIChgdGFibGVgIElOIFsndWtfcHJpY2VfcGFpZF9zaW1wbGUnLCAndWtfcHJpY2VfcGFpZF9zaW1wbGVfcGFydGl0aW9uZWQnXSkgQU5EIGFjdGl2ZQpHUk9VUCBCWSB0YWJsZTs\&run_query=true\&tab=results) больше активных [частей данных](/parts), потому что, как уже упоминалось выше, ClickHouse [сливает](/parts) части данных только внутри одной партиции, но не между партициями:

```sql runnable
SELECT
    table,
    count() AS parts
FROM system.parts
WHERE (database = 'uk') AND (table IN ['uk_price_paid_simple', 'uk_price_paid_simple_partitioned']) AND active
GROUP BY table;

```

Как показано выше, секционированная таблица `uk_price_paid_simple_partitioned` имеет более 600 секций, то есть 600 306 активных частей данных. Тогда как для нашей несекционированной таблицы `uk_price_paid_simple` все [исходные](/parts) части данных могли быть объединены фоновыми слияниями в одну активную часть.

Если мы [проверим](https://sql.clickhouse.com/?query=RVhQTEFJTiBpbmRleGVzID0gMQpTRUxFQ1QgTUFYKHByaWNlKSBBUyBoaWdoZXN0X3ByaWNlCkZST00gdWsudWtfcHJpY2VfcGFpZF9zaW1wbGVfcGFydGl0aW9uZWQKV0hFUkUgdG93biA9ICdMT05ET04nOw\&run_query=true\&tab=results) физический план выполнения запроса с предложением [EXPLAIN](/sql-reference/statements/explain) для нашего приведённого выше примера запроса без фильтра по секции, выполняемого над секционированной таблицей, мы видим в строках 19 и 20 приведённого ниже вывода, что ClickHouse определил 671 из 3257 существующих [гранул](/guides/best-practices/sparse-primary-indexes#data-is-organized-into-granules-for-parallel-data-processing) (блоков строк), распределённых по 431 из 436 существующих активных частей данных, которые потенциально содержат строки, удовлетворяющие фильтру запроса, и, следовательно, будут просканированы и обработаны движком запросов:


```sql
EXPLAIN indexes = 1
SELECT MAX(price) AS highest_price
FROM uk.uk_price_paid_simple_partitioned
WHERE town = 'LONDON';

    ┌─explain─────────────────────────────────────────────────────────┐
 1. │ Expression ((Project names + Projection))                       │
 2. │   Aggregating                                                   │
 3. │     Expression (Before GROUP BY)                                │
 4. │       Expression                                                │
 5. │         ReadFromMergeTree (uk.uk_price_paid_simple_partitioned) │
 6. │         Indexes:                                                │
 7. │           MinMax                                                │
 8. │             Condition: true                                     │
 9. │             Parts: 436/436                                      │
10. │             Granules: 3257/3257                                 │
11. │           Partition                                             │
12. │             Condition: true                                     │
13. │             Parts: 436/436                                      │
14. │             Granules: 3257/3257                                 │
15. │           PrimaryKey                                            │
16. │             Keys:                                               │
17. │               town                                              │
18. │             Condition: (town in ['LONDON', 'LONDON'])           │
19. │             Parts: 431/436                                      │
20. │             Granules: 671/3257                                  │
    └─────────────────────────────────────────────────────────────────┘
```

Физический план выполнения запроса для того же примерного запроса, выполняемого по таблице без секционирования, [показывает](https://sql.clickhouse.com/?query=RVhQTEFJTiBpbmRleGVzID0gMQpTRUxFQ1QgTUFYKHByaWNlKSBBUyBoaWdoZXN0X3ByaWNlCkZST00gdWsudWtfcHJpY2VfcGFpZF9zaW1wbGUKV0hFUkUgdG93biA9ICdMT05ET04nOw\&run_query=true\&tab=results) в строках 11 и 12 приведённого ниже вывода, что ClickHouse определил 241 из 3083 существующих блоков строк в единственной активной части данных таблицы, которые потенциально содержат строки, удовлетворяющие фильтру запроса:

```sql
EXPLAIN indexes = 1
SELECT MAX(price) AS highest_price
FROM uk.uk_price_paid_simple
WHERE town = 'LONDON';

    ┌─explain───────────────────────────────────────────────┐
 1. │ Expression ((Project names + Projection))             │
 2. │   Aggregating                                         │
 3. │     Expression (Before GROUP BY)                      │
 4. │       Expression                                      │
 5. │         ReadFromMergeTree (uk.uk_price_paid_simple)   │
 6. │         Indexes:                                      │
 7. │           PrimaryKey                                  │
 8. │             Keys:                                     │
 9. │               town                                    │
10. │             Condition: (town in ['LONDON', 'LONDON']) │
11. │             Parts: 1/1                                │
12. │             Granules: 241/3083                        │
    └───────────────────────────────────────────────────────┘
```

При [выполнении](https://sql.clickhouse.com/?query=U0VMRUNUIE1BWChwcmljZSkgQVMgaGlnaGVzdF9wcmljZQpGUk9NIHVrLnVrX3ByaWNlX3BhaWRfc2ltcGxlX3BhcnRpdGlvbmVkCldIRVJFIHRvd24gPSAnTE9ORE9OJzs\&run_query=true\&tab=results) запроса для секционированной версии таблицы ClickHouse сканирует и обрабатывает 671 блок строк (~ 5,5 миллиона строк) за 90 миллисекунд:

```sql
SELECT MAX(price) AS highest_price
FROM uk.uk_price_paid_simple_partitioned
WHERE town = 'LONDON';

┌─highest_price─┐
│     594300000 │ -- 594,30 млн
└───────────────┘

Получена 1 строка. Затрачено: 0,090 сек. Обработано 5,48 млн строк, 27,95 МБ (60,66 млн строк/сек., 309,51 МБ/сек.)
Пиковое использование памяти: 163,44 МиБ.
```


А при [выполнении](https://sql.clickhouse.com/?query=U0VMRUNUIE1BWChwcmljZSkgQVMgaGlnaGVzdF9wcmljZQpGUk9NIHVrLnVrX3ByaWNlX3BhaWRfc2ltcGxlCldIRVJFIHRvd24gPSAnTE9ORE9OJzs\&run_query=true\&tab=results) запроса по таблице без партиционирования ClickHouse сканирует и обрабатывает 241 блок (~ 2 миллиона строк) за 12 миллисекунд:

```sql
SELECT MAX(price) AS highest_price
FROM uk.uk_price_paid_simple
WHERE town = 'LONDON';

┌─highest_price─┐
│     594300000 │ -- 594,30 млн
└───────────────┘

Получена 1 строка. Затрачено: 0,012 сек. Обработано 1,97 млн строк, 9,87 МБ (162,23 млн строк/сек., 811,17 МБ/сек.)
Пиковое использование памяти: 62,02 МиБ.
```

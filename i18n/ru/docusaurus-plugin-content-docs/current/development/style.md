---
description: 'Рекомендации по стилю кода для разработки ClickHouse на C++'
sidebar_label: 'Руководство по стилю кода на C++'
sidebar_position: 70
slug: /development/style
title: 'Руководство по стилю кода на C++'
doc_type: 'guide'
---



# Руководство по стилю C++



## Общие рекомендации {#general-recommendations}

Далее приведены рекомендации, а не требования.
Если вы редактируете код, имеет смысл следовать форматированию существующего кода.
Стиль кода необходим для обеспечения единообразия. Единообразие облегчает чтение кода и упрощает поиск в нём.
Многие из этих правил не имеют логического обоснования; они продиктованы сложившейся практикой.


## Форматирование {#formatting}

**1.** Большая часть форматирования выполняется автоматически с помощью `clang-format`.

**2.** Отступы составляют 4 пробела. Настройте среду разработки так, чтобы табуляция добавляла четыре пробела.

**3.** Открывающая и закрывающая фигурные скобки должны находиться на отдельных строках.

```cpp
inline void readBoolText(bool & x, ReadBuffer & buf)
{
    char tmp = '0';
    readChar(tmp, buf);
    x = tmp != '0';
}
```

**4.** Если всё тело функции представляет собой одну инструкцию (`statement`), её можно разместить на одной строке. Добавляйте пробелы вокруг фигурных скобок (кроме пробела в конце строки).

```cpp
inline size_t mask() const                { return buf_size() - 1; }
inline size_t place(HashValue x) const    { return x & mask(); }
```

**5.** Для функций не ставьте пробелы вокруг круглых скобок.

```cpp
void reinsert(const Value & x)
```

```cpp
memcpy(&buf[place_value], &x, sizeof(x));
```

**6.** В выражениях `if`, `for`, `while` и других пробел вставляется перед открывающей круглой скобкой (в отличие от вызовов функций).

```cpp
for (size_t i = 0; i < rows; i += storage.index_granularity)
```

**7.** Добавляйте пробелы вокруг бинарных операторов (`+`, `-`, `*`, `/`, `%`, ...) и тернарного оператора `?:`.

```cpp
UInt16 year = (s[0] - '0') * 1000 + (s[1] - '0') * 100 + (s[2] - '0') * 10 + (s[3] - '0');
UInt8 month = (s[5] - '0') * 10 + (s[6] - '0');
UInt8 day = (s[8] - '0') * 10 + (s[9] - '0');
```

**8.** Если выполняется перенос строки, размещайте оператор на новой строке и увеличивайте отступ перед ним.

```cpp
if (elapsed_ns)
    message << " ("
        << rows_read_on_server * 1000000000 / elapsed_ns << " rows/s., "
        << bytes_read_on_server * 1000.0 / elapsed_ns << " MB/s.) ";
```

**9.** При желании можно использовать пробелы для выравнивания внутри строки.

```cpp
dst.ClickLogID         = click.LogID;
dst.ClickEventID       = click.EventID;
dst.ClickGoodEvent     = click.GoodEvent;
```

**10.** Не используйте пробелы вокруг операторов `.`, `->`.

При необходимости оператор можно перенести на следующую строку. В этом случае отступ перед ним увеличивается.

**11.** Не используйте пробел для отделения унарных операторов (`--`, `++`, `*`, `&`, ...) от аргумента.

**12.** Ставьте пробел после запятой, но не перед ней. То же правило применяется к точке с запятой внутри выражения `for`.

**13.** Не используйте пробелы для отделения оператора `[]`.

**14.** В выражении `template <...>` используйте пробел между `template` и `<`; не ставьте пробелы после `<` или перед `>`.

```cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
{}
```

**15.** В классах и структурах пишите `public`, `private` и `protected` на том же уровне, что и `class/struct`, и делайте отступ для остального кода.

```cpp
template <typename T>
class MultiVersion
{
public:
    /// Версия объекта для использования. shared_ptr управляет временем жизни версии.
    using Version = std::shared_ptr<const T>;
    ...
}
```

**16.** Если одно и то же пространство имён `namespace` используется для всего файла и нет ничего другого значимого, отступ внутри `namespace` не требуется.

**17.** Если блок для выражения `if`, `for`, `while` или другого состоит из одной инструкции (`statement`), фигурные скобки необязательны. Вместо этого размещайте инструкцию на отдельной строке. Это правило также действует для вложенных `if`, `for`, `while`, ...

Но если внутренняя инструкция (`statement`) содержит фигурные скобки или `else`, внешний блок должен быть заключён в фигурные скобки.

```cpp
/// Завершение записи.
for (auto & stream : streams)
    stream.second->finalize();
```

**18.** В конце строк не должно быть пробелов.

**19.** Исходные файлы имеют кодировку UTF-8.


**20.** В строковых литералах можно использовать символы, не входящие в ASCII.

```cpp
<< ", " << (timer.elapsed() / chunks_stats.hits) << " μsec/hit.";
```

**21.** Не пишите несколько выражений в одной строке.

**22.** Группируйте фрагменты кода внутри функций и разделяйте их не более чем одной пустой строкой.

**23.** Разделяйте функции, классы и т. д. одной или двумя пустыми строками.

**24.** `A const` (относящийся к значению) следует писать перед именем типа.

```cpp
//корректно
const char * pos
const std::string & s
//некорректно
char const * pos
```

**25.** При объявлении указателя или ссылки символы `*` и `&` должны быть отделены пробелами с обеих сторон.

```cpp
//правильно
const char * pos
//неправильно
const char* pos
const char *pos
```

**26.** При использовании шаблонных типов задавайте им псевдонимы с помощью ключевого слова `using` (кроме самых простых случаев).

Другими словами, параметры шаблона указываются только в `using` и далее не повторяются в коде.

`using` может объявляться локально, например внутри функции.

```cpp
//корректно
using FileStreams = std::map<std::string, std::shared_ptr<Stream>>;
FileStreams streams;
//некорректно
std::map<std::string, std::shared_ptr<Stream>> streams;
```

**27.** Не объявляйте несколько переменных разных типов в одном объявлении.

```cpp
//некорректно
int x, *y;
```

**28.** Не используйте приведения типов в стиле C.

```cpp
//неверно
std::cerr << (int)c <<; std::endl;
//верно
std::cerr << static_cast<int>(c) << std::endl;
```

**29.** В классах и структурах группируйте поля и функции раздельно внутри каждой области видимости.

**30.** Для небольших классов и структур нет необходимости отделять объявление метода от его реализации.

То же самое относится к небольшим методам в любых классах или структурах.

Для шаблонных классов и структур не отделяйте объявления методов от реализации (в противном случае они должны быть определены в одной и той же единице трансляции).

**31.** Можно переносить строки при достижении 140 символов вместо 80.

**32.** Всегда используйте операторы префиксного инкремента/декремента, если постфиксный вариант не требуется.

```cpp
for (Names::const_iterator it = column_names.begin(); it != column_names.end(); ++it)
```


## Комментарии {#comments}

**1.** Обязательно добавляйте комментарии ко всем нетривиальным частям кода.

Это очень важно. Написание комментария может помочь вам осознать, что код не нужен или что он спроектирован неправильно.

```cpp
/** Часть участка памяти, которая может быть использована.
  * Например, если internal_buffer составляет 1 МБ, а из файла для чтения в буфер было загружено только 10 байт,
  * то working_buffer будет иметь размер всего 10 байт
  * (working_buffer.end() будет указывать на позицию сразу после этих 10 байт, доступных для чтения).
  */
```

**2.** Комментарии могут быть настолько подробными, насколько это необходимо.

**3.** Размещайте комментарии перед кодом, который они описывают. В редких случаях комментарии могут идти после кода на той же строке.

```cpp
/** Разбирает и выполняет запрос.
*/
void executeQuery(
    ReadBuffer & istr, /// Откуда читать запрос (и данные для INSERT, если применимо)
    WriteBuffer & ostr, /// Куда записывать результат
    Context & context, /// БД, таблицы, типы данных, движки, функции, агрегатные функции...
    BlockInputStreamPtr & query_plan, /// Здесь может быть записано описание того, как был выполнен запрос
    QueryProcessingStage::Enum stage = QueryProcessingStage::Complete /// До какой стадии обрабатывать запрос SELECT
    )
```

**4.** Комментарии должны быть написаны только на английском языке.

**5.** Если вы пишете библиотеку, включите подробные комментарии с объяснениями в основной заголовочный файл.

**6.** Не добавляйте комментарии, которые не предоставляют дополнительной информации. В частности, не оставляйте пустые комментарии вроде этого:

```cpp
/*
* Имя процедуры:
* Исходное имя процедуры:
* Автор:
* Дата создания:
* Даты изменения:
* Авторы изменений:
* Исходное имя файла:
* Назначение:
* Намерение:
* Обозначение:
* Используемые классы:
* Константы:
* Локальные переменные:
* Параметры:
* Дата создания:
* Назначение:
*/
```

Пример заимствован из ресурса http://home.tamk.fi/~jaalto/course/coding-style/doc/unmaintainable-code/.

**7.** Не пишите мусорные комментарии (автор, дата создания и т. д.) в начале каждого файла.

**8.** Однострочные комментарии начинаются с трёх косых черт: `///`, а многострочные комментарии начинаются с `/**`. Эти комментарии считаются «документацией».

Примечание: Вы можете использовать Doxygen для генерации документации из этих комментариев. Но Doxygen обычно не используется, потому что удобнее навигировать по коду в IDE.

**9.** Многострочные комментарии не должны содержать пустых строк в начале и конце (за исключением строки, которая закрывает многострочный комментарий).

**10.** Для закомментирования кода используйте обычные комментарии, а не «документирующие» комментарии.

**11.** Удаляйте закомментированные части кода перед коммитом.

**12.** Не используйте ненормативную лексику в комментариях или коде.

**13.** Не используйте заглавные буквы. Не используйте избыточную пунктуацию.

```cpp
/// ЧТО ЗА ПРОВАЛ???
```

**14.** Не используйте комментарии для создания разделителей.

```cpp
///******************************************************
```

**15.** Не начинайте обсуждения в комментариях.

```cpp
/// Зачем ты это сделал?
```

**16.** Нет необходимости писать комментарий в конце блока с описанием того, о чём он был.

```cpp
/// for
```


## Имена {#names}

**1.** Используйте строчные буквы с подчеркиваниями в именах переменных и членов класса.

```cpp
size_t max_block_size;
```

**2.** Для имен функций (методов) используйте camelCase, начинающийся со строчной буквы.

```cpp
std::string getName() const override { return "Memory"; }
```

**3.** Для имен классов (структур) используйте CamelCase, начинающийся с заглавной буквы. Префиксы, отличные от I, не используются для интерфейсов.

```cpp
class StorageMemory : public IStorage
```

**4.** Директивы `using` именуются так же, как классы.

**5.** Имена аргументов типов шаблонов: в простых случаях используйте `T`; `T`, `U`; `T1`, `T2`.

В более сложных случаях либо следуйте правилам для имен классов, либо добавьте префикс `T`.

```cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
```

**6.** Имена константных аргументов шаблонов: либо следуйте правилам для имен переменных, либо используйте `N` в простых случаях.

```cpp
template <bool without_www>
struct ExtractDomain
```

**7.** Для абстрактных классов (интерфейсов) можно добавить префикс `I`.

```cpp
class IProcessor
```

**8.** Если переменная используется локально, можно использовать короткое имя.

Во всех остальных случаях используйте имя, описывающее смысл.

```cpp
bool info_successfully_loaded = false;
```

**9.** Имена `define` и глобальных констант используют ALL_CAPS с подчеркиваниями.

```cpp
#define MAX_SRC_TABLE_NAMES_TO_STORE 1000
```

**10.** Имена файлов должны соответствовать стилю их содержимого.

Если файл содержит один класс, назовите файл так же, как класс (CamelCase).

Если файл содержит одну функцию, назовите файл так же, как функцию (camelCase).

**11.** Если имя содержит аббревиатуру, то:

- Для имен переменных аббревиатура должна быть записана строчными буквами `mysql_connection` (не `mySQL_connection`).
- Для имен классов и функций сохраняйте заглавные буквы в аббревиатуре `MySQLConnection` (не `MySqlConnection`).

**12.** Аргументы конструктора, которые используются только для инициализации членов класса, должны именоваться так же, как члены класса, но с подчеркиванием в конце.

```cpp
FileQueueProcessor(
    const std::string & path_,
    const std::string & prefix_,
    std::shared_ptr<FileHandler> handler_)
    : path(path_),
    prefix(prefix_),
    handler(handler_),
    log(&Logger::get("FileQueueProcessor"))
{
}
```

Суффикс подчеркивания можно опустить, если аргумент не используется в теле конструктора.

**13.** Нет различий в именах локальных переменных и членов класса (префиксы не требуются).

```cpp
timer (не m_timer)
```

**14.** Для констант в `enum` используйте CamelCase с заглавной буквы. ALL_CAPS также допустимо. Если `enum` не является локальным, используйте `enum class`.

```cpp
enum class CompressionMethod
{
    QuickLZ = 0,
    LZ4     = 1,
};
```

**15.** Все имена должны быть на английском языке. Транслитерация слов на иврите не допускается.

    не T_PAAMAYIM_NEKUDOTAYIM

**16.** Аббревиатуры допустимы, если они общеизвестны (когда вы можете легко найти значение аббревиатуры в Википедии или в поисковой системе).

    `AST`, `SQL`.

    Не `NVDH` (случайный набор букв)

Неполные слова допустимы, если сокращенная версия находится в общем употреблении.

Вы также можете использовать аббревиатуру, если полное название указано рядом с ней в комментариях.

**17.** Имена файлов с исходным кодом C++ должны иметь расширение `.cpp`. Заголовочные файлы должны иметь расширение `.h`.


## Как писать код {#how-to-write-code}

**1.** Управление памятью.

Ручное освобождение памяти (`delete`) может использоваться только в библиотечном коде.

В библиотечном коде оператор `delete` может использоваться только в деструкторах.

В коде приложения память должна освобождаться тем объектом, которому она принадлежит.

Примеры:

- Самый простой способ — разместить объект в стеке или сделать его членом другого класса.
- Для большого количества небольших объектов используйте контейнеры.
- Для автоматического освобождения небольшого количества объектов, находящихся в куче, используйте `shared_ptr/unique_ptr`.

**2.** Управление ресурсами.

Используйте `RAII` и см. выше.

**3.** Обработка ошибок.

Используйте исключения. В большинстве случаев достаточно только выбросить исключение, перехватывать его не нужно (благодаря `RAII`).

В приложениях для автономной обработки данных часто допустимо не перехватывать исключения.

В серверах, обрабатывающих пользовательские запросы, обычно достаточно перехватывать исключения на верхнем уровне обработчика соединений.

В функциях потоков следует перехватывать и сохранять все исключения, чтобы повторно выбросить их в основном потоке после `join`.

```cpp
/// Если вычислений еще не было, вычислить первый блок синхронно
if (!started)
{
    calculate();
    started = true;
}
else /// Если вычисления уже выполняются, дождаться результата
    pool.wait();

if (exception)
    exception->rethrow();
```

Никогда не скрывайте исключения без обработки. Никогда не записывайте все исключения в лог вслепую.

```cpp
//Неправильно
catch (...) {}
```

Если нужно игнорировать некоторые исключения, делайте это только для конкретных и повторно выбрасывайте остальные.

```cpp
catch (const DB::Exception & e)
{
    if (e.code() == ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION)
        return nullptr;
    else
        throw;
}
```

При использовании функций с кодами возврата или `errno` всегда проверяйте результат и выбрасывайте исключение в случае ошибки.

```cpp
if (0 != close(fd))
    throw ErrnoException(ErrorCodes::CANNOT_CLOSE_FILE, "Невозможно закрыть файл {}", file_name);
```

Вы можете использовать assert для проверки инвариантов в коде.

**4.** Типы исключений.

Нет необходимости использовать сложную иерархию исключений в коде приложения. Текст исключения должен быть понятен системному администратору.

**5.** Выброс исключений из деструкторов.

Это не рекомендуется, но допускается.

Используйте следующие варианты:

- Создайте функцию (`done()` или `finalize()`), которая заранее выполнит всю работу, способную привести к исключению. Если эта функция была вызвана, в деструкторе позже не должно возникать исключений.
- Слишком сложные задачи (такие как отправка сообщений по сети) можно поместить в отдельный метод, который пользователь класса должен будет вызвать перед уничтожением объекта.
- Если в деструкторе возникает исключение, лучше записать его в лог, чем скрывать (если логгер доступен).
- В простых приложениях допустимо полагаться на `std::terminate` (для случаев `noexcept` по умолчанию в C++11) для обработки исключений.

**6.** Анонимные блоки кода.

Вы можете создать отдельный блок кода внутри одной функции, чтобы сделать определенные переменные локальными и обеспечить вызов деструкторов при выходе из блока.

```cpp
Block block = data.in->read();

{
    std::lock_guard<std::mutex> lock(mutex);
    data.ready = true;
    data.block = block;
}

ready_any.set();
```

**7.** Многопоточность.

В программах автономной обработки данных:

- Старайтесь получить максимально возможную производительность на одном ядре процессора. При необходимости вы можете распараллелить свой код.

В серверных приложениях:

- Используйте пул потоков для обработки запросов. На данный момент у нас не было задач, требующих переключения контекста в пространстве пользователя.

Fork не используется для распараллеливания.

**8.** Синхронизация потоков.

Часто можно сделать так, чтобы разные потоки использовали разные ячейки памяти (еще лучше: разные строки кэша) и не использовать никакой синхронизации потоков (кроме `joinAll`).

Если требуется синхронизация, в большинстве случаев достаточно использовать mutex с `lock_guard`.

В других случаях используйте системные примитивы синхронизации. Не используйте активное ожидание.

Атомарные операции следует использовать только в самых простых случаях.

Не пытайтесь реализовывать неблокирующие структуры данных, если это не ваша основная область экспертизы.

**9.** Указатели и ссылки.

В большинстве случаев предпочитайте ссылки.

**10.** `const`.

Используйте константные ссылки, указатели на константы, `const_iterator` и `const`-методы.

Считайте `const` значением по умолчанию и используйте не-`const` только при необходимости.


При передаче переменных по значению использование `const` обычно не имеет смысла.

**11.** unsigned.

Используйте `unsigned`, если это необходимо.

**12.** Числовые типы.

Используйте типы `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32` и `Int64`, а также `size_t`, `ssize_t` и `ptrdiff_t`.

Не используйте для чисел следующие типы: `signed/unsigned long`, `long long`, `short`, `signed/unsigned char`, `char`.

**13.** Передача аргументов.

Передавайте сложные объекты по значению, если они будут перемещаться, и используйте std::move; передавайте по ссылке, если вы хотите обновлять значение в цикле.

Если функция принимает на себя владение объектом, созданным в куче, сделайте тип аргумента `shared_ptr` или `unique_ptr`.

**14.** Возвращаемые значения.

В большинстве случаев просто используйте `return`. Не пишите `return std::move(res)`.

Если функция выделяет объект в куче и возвращает его, используйте `shared_ptr` или `unique_ptr`.

В редких случаях (обновление значения в цикле) может потребоваться возвращать значение через аргумент. В этом случае аргумент должен быть ссылкой.

```cpp
using AggregateFunctionPtr = std::shared_ptr<IAggregateFunction>;

/** Позволяет создавать агрегатную функцию по её имени.
  */
class AggregateFunctionFactory
{
public:
    AggregateFunctionFactory();
    AggregateFunctionPtr get(const String & name, const DataTypes & argument_types) const;
```

**15.** `namespace`.

Нет необходимости использовать отдельный `namespace` для кода приложения.

Небольшим библиотекам это также не требуется.

Для библиотек среднего и большого размера имеет смысл поместить всё в один `namespace`.

В `.h`-файле библиотеки можно использовать `namespace detail` для сокрытия деталей реализации, которые не нужны коду приложения.

В `.cpp`-файле можно использовать `static` или анонимный `namespace` для сокрытия символов.

Также `namespace` можно использовать для `enum`, чтобы предотвратить попадание соответствующих имён во внешний `namespace` (но лучше использовать `enum class`).

**16.** Отложенная инициализация.

Если для инициализации требуются аргументы, обычно не следует писать конструктор по умолчанию.

Если позже вам понадобится откладывать инициализацию, можно добавить конструктор по умолчанию, который будет создавать объект в невалидном состоянии. Или, для небольшого числа объектов, можно использовать `shared_ptr/unique_ptr`.

```cpp
Loader(DB::Connection * connection_, const std::string & query, size_t max_block_size_);

/// Для отложенной инициализации
Loader() {}
```

**17.** Виртуальные функции.

Если класс не предназначен для полиморфного использования, не нужно делать функции виртуальными. Это также относится к деструктору.

**18.** Кодировки.

Используйте UTF-8 везде. Используйте `std::string` и `char *`. Не используйте `std::wstring` и `wchar_t`.

**19.** Логирование.

См. примеры во всём коде.

Перед коммитом удаляйте весь бессмысленный и отладочный лог, а также любые другие виды отладочного вывода.

Логирования в циклах следует избегать, даже на уровне Trace.

Логи должны быть читаемыми на любом уровне логирования.

Логирование в основном следует использовать только в прикладном коде.

Сообщения лога должны быть написаны на английском языке.

Лог должен быть по возможности понятен системному администратору.

Не используйте ненормативную лексику в логе.

Используйте кодировку UTF-8 в логе. В редких случаях можно использовать не-ASCII-символы в логе.

**20.** Ввод-вывод.

Не используйте `iostreams` во внутренних циклах, критичных для производительности приложения (и никогда не используйте `stringstream`).

Вместо этого используйте библиотеку `DB/IO`.

**21.** Дата и время.

См. библиотеку `DateLUT`.

**22.** include.

Всегда используйте `#pragma once` вместо include guards.

**23.** using.

`using namespace` не используется. Можно использовать `using` с чем-то конкретным. Но делайте это локально, внутри класса или функции.

**24.** Не используйте `trailing return type` для функций без необходимости.

```cpp
auto f() -> void
```

**25.** Объявление и инициализация переменных.

```cpp
//правильный способ
std::string s = "Hello";
std::string s{"Hello"};

//неправильный способ
auto s = std::string{"Hello"};
```

**26.** Для виртуальных функций пишите `virtual` в базовом классе, а в производных классах вместо `virtual` пишите `override`.


## Неиспользуемые возможности C++ {#unused-features-of-c}

**1.** Виртуальное наследование не используется.

**2.** Конструкции, для которых в современном C++ существует удобный синтаксический сахар, например:

```cpp
// Традиционный способ без синтаксического сахара
template <typename G, typename = std::enable_if_t<std::is_same<G, F>::value, void>> // SFINAE через std::enable_if, использование ::value
std::pair<int, int> func(const E<G> & e) // явно указанный возвращаемый тип
{
    if (elements.count(e)) // проверка принадлежности через .count()
    {
        // ...
    }

    elements.erase(
        std::remove_if(
            elements.begin(), elements.end(),
            [&](const auto x){
                return x == 1;
            }),
        elements.end()); // идиома remove-erase

    return std::make_pair(1, 2); // создание пары через make_pair()
}

// С синтаксическим сахаром (C++14/17/20)
template <typename G>
requires std::same_v<G, F> // SFINAE через концепт C++20, использование псевдонима шаблона C++14
auto func(const E<G> & e) // автовыведение возвращаемого типа (C++14)
{
    if (elements.contains(e)) // проверка принадлежности через .contains в C++20
    {
        // ...
    }

    elements.erase_if(
        elements,
        [&](const auto x){
            return x == 1;
        }); // std::erase_if из C++20

    return {1, 2}; // или: return std::pair(1, 2); // создание пары через список инициализации или прямую инициализацию (C++17)
}
```


## Платформа {#platform}

**1.** Мы пишем код для конкретной платформы.

Но при прочих равных условиях предпочтение отдается кроссплатформенному или переносимому коду.

**2.** Язык: C++20 (см. список доступных [возможностей C++20](https://en.cppreference.com/w/cpp/compiler_support#C.2B.2B20_features)).

**3.** Компилятор: `clang`. На момент написания (март 2025 года) код компилируется с использованием clang версии >= 19.

Используется стандартная библиотека (`libc++`).

**4.** ОС: Linux Ubuntu не старше версии Precise.

**5.** Код написан для архитектуры процессора x86_64.

Набор инструкций процессора — это минимальный поддерживаемый набор среди наших серверов. В настоящее время это SSE 4.2.

**6.** Используйте флаги компиляции `-Wall -Wextra -Werror -Weverything` с несколькими исключениями.

**7.** Используйте статическую компоновку со всеми библиотеками, за исключением тех, которые сложно подключить статически (см. вывод команды `ldd`).

**8.** Код разрабатывается и отлаживается с настройками релиза.


## Инструменты {#tools}

**1.** KDevelop — хорошая IDE.

**2.** Для отладки используйте `gdb`, `valgrind` (`memcheck`), `strace`, `-fsanitize=...` или `tcmalloc_minimal_debug`.

**3.** Для профилирования используйте `Linux Perf`, `valgrind` (`callgrind`) или `strace -cf`.

**4.** Исходный код хранится в Git.

**5.** Для сборки используется `CMake`.

**6.** Программы выпускаются в виде `deb`-пакетов.

**7.** Коммиты в master не должны нарушать сборку.

Хотя работоспособными считаются только отдельные ревизии.

**8.** Делайте коммиты как можно чаще, даже если код готов лишь частично.

Для этого используйте ветки.

Если ваш код в ветке `master` ещё не собирается, исключите его из сборки перед выполнением `push`. Вам нужно будет завершить его или удалить в течение нескольких дней.

**9.** Для нетривиальных изменений используйте ветки и публикуйте их на сервере.

**10.** Неиспользуемый код удаляется из репозитория.


## Библиотеки {#libraries}

**1.** Используется стандартная библиотека C++20 (допускаются экспериментальные расширения), а также фреймворки `boost` и `Poco`.

**2.** Запрещается использовать библиотеки из пакетов операционной системы. Также запрещается использовать предустановленные библиотеки. Все библиотеки должны размещаться в виде исходного кода в каталоге `contrib` и собираться вместе с ClickHouse. Подробности см. в разделе [Руководство по добавлению новых сторонних библиотек](/development/contrib#adding-and-maintaining-third-party-libraries).

**3.** Предпочтение всегда отдается уже используемым библиотекам.


## Общие рекомендации {#general-recommendations-1}

**1.** Пишите как можно меньше кода.

**2.** Используйте самое простое решение.

**3.** Не пишите код, пока не поймёте, как он будет работать и как будет функционировать внутренний цикл.

**4.** В простейших случаях используйте `using` вместо классов или структур.

**5.** По возможности не пишите конструкторы копирования, операторы присваивания, деструкторы (кроме виртуального, если класс содержит хотя бы одну виртуальную функцию), конструкторы перемещения или операторы присваивания перемещением. Другими словами, сгенерированные компилятором функции должны работать корректно. Можно использовать `default`.

**6.** Упрощение кода приветствуется. Сокращайте размер кода там, где это возможно.


## Дополнительные рекомендации {#additional-recommendations}

**1.** Явное указание `std::` для типов из `stddef.h`

не рекомендуется. Другими словами, рекомендуется писать `size_t` вместо `std::size_t`, так как это короче.

Допускается добавление `std::`.

**2.** Явное указание `std::` для функций из стандартной библиотеки C

не рекомендуется. Другими словами, пишите `memcpy` вместо `std::memcpy`.

Причина в том, что существуют похожие нестандартные функции, например `memmem`. Мы используем эти функции время от времени. Эти функции отсутствуют в `namespace std`.

Если везде писать `std::memcpy` вместо `memcpy`, то `memmem` без `std::` будет выглядеть странно.

Тем не менее, можно использовать `std::`, если вы предпочитаете такой стиль.

**3.** Использование функций из C, когда аналогичные функции доступны в стандартной библиотеке C++.

Это допустимо, если это более эффективно.

Например, используйте `memcpy` вместо `std::copy` для копирования больших блоков памяти.

**4.** Многострочные аргументы функций.

Допускается любой из следующих стилей переноса:

```cpp
function(
  T1 x1,
  T2 x2)
```

```cpp
function(
  size_t left, size_t right,
  const & RangesInDataParts ranges,
  size_t limit)
```

```cpp
function(size_t left, size_t right,
  const & RangesInDataParts ranges,
  size_t limit)
```

```cpp
function(size_t left, size_t right,
      const & RangesInDataParts ranges,
      size_t limit)
```

```cpp
function(
      size_t left,
      size_t right,
      const & RangesInDataParts ranges,
      size_t limit)
```

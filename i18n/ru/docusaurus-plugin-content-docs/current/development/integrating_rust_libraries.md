---
description: 'Руководство по интеграции библиотек на Rust в ClickHouse'
sidebar_label: 'Библиотеки Rust'
slug: /development/integrating_rust_libraries
title: 'Интеграция библиотек Rust'
doc_type: 'guide'
---

# Библиотеки Rust

Интеграция библиотек Rust будет описана на примере интеграции хеш-функции BLAKE3.

Первый шаг интеграции — добавление библиотеки в каталог /rust. Для этого необходимо создать пустой проект Rust и подключить требуемую библиотеку в Cargo.toml. Также нужно настроить компиляцию новой библиотеки как статической, добавив `crate-type = ["staticlib"]` в Cargo.toml.

Далее необходимо связать библиотеку с CMake с помощью библиотеки Corrosion. Сначала нужно добавить каталог библиотеки в CMakeLists.txt внутри каталога /rust. После этого следует добавить файл CMakeLists.txt в каталог библиотеки. В нём нужно вызвать функцию импорта Corrosion. Для импорта BLAKE3 использовались следующие строки:

```CMake
corrosion_import_crate(MANIFEST_PATH Cargo.toml NO_STD)

target_include_directories(_ch_rust_blake3 INTERFACE include)
add_library(ch_rust::blake3 ALIAS _ch_rust_blake3)
```

Таким образом, мы создадим правильную цель CMake с помощью Corrosion, а затем дадим ей более удобное имя. Обратите внимание, что имя `_ch_rust_blake3` берётся из Cargo.toml, где оно используется в качестве имени проекта (`name = "_ch_rust_blake3"`).

Поскольку типы данных Rust несовместимы с типами данных C/C++, мы будем использовать наш пустой библиотечный проект для создания вспомогательных (shim-)методов, которые выполняют преобразование данных, полученных из C/C++, вызывают методы библиотеки и выполняют обратное преобразование выходных данных. Например, для BLAKE3 был написан следующий метод:

```rust
#[no_mangle]
pub unsafe extern "C" fn blake3_apply_shim(
    begin: *const c_char,
    _size: u32,
    out_char_data: *mut u8,
```

```rust
#[no_mangle]
pub unsafe extern "C" fn blake3_apply_shim(
    begin: *const c_char,
    _size: u32,
    out_char_data: *mut u8,
) -> *mut c_char {
    if begin.is_null() {
        let err_str = CString::new("входные данные представляют собой нулевой указатель").unwrap();
        return err_str.into_raw();
    }
    let mut hasher = blake3::Hasher::new();
    let input_bytes = CStr::from_ptr(begin);
    let input_res = input_bytes.to_bytes();
    hasher.update(input_res);
    let mut reader = hasher.finalize_xof();
    reader.fill(std::slice::from_raw_parts_mut(out_char_data, blake3::OUT_LEN));
    std::ptr::null_mut()
}
```

Этот метод принимает C-совместимую строку, её размер и указатель на выходную строку. Затем он преобразует C-совместимые входные данные в типы, которые используются реальными методами библиотеки, и вызывает их. После этого он должен преобразовать результаты методов библиотеки обратно в C-совместимый тип. В данном случае библиотека поддерживала прямую запись по указателю методом `fill()`, поэтому преобразование не требовалось. Основная рекомендация здесь — создавать как можно меньше методов, чтобы при каждом вызове приходилось выполнять меньше преобразований и не возникало значительных накладных расходов.

Стоит отметить, что атрибут `#[no_mangle]` и `extern "C"` являются обязательными для всех таких методов. Без них корректная C/C++-совместимая компиляция будет невозможна. Более того, они необходимы для следующего шага интеграции.

После написания кода для shim-методов нужно подготовить заголовочный файл для библиотеки. Это можно сделать вручную либо использовать библиотеку cbindgen для автогенерации. В случае использования cbindgen потребуется написать скрипт сборки `build.rs` и подключить cbindgen как зависимость сборки.

Пример скрипта сборки, который может автоматически сгенерировать заголовочный файл:

```rust
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    let package_name = env::var("CARGO_PKG_NAME").unwrap();
    let output_file = ("include/".to_owned() + &format!("{}.h", package_name)).to_string();

    match cbindgen::generate(&crate_dir) {
        Ok(header) => {
            header.write_to_file(&output_file);
        }
        Err(err) => {
            panic!("{}", err)
        }
    }
```

Также следует использовать атрибут #[no&#95;mangle] и `extern "C"` для каждого C-совместимого атрибута. В противном случае библиотека может быть скомпилирована некорректно, и cbindgen не сможет выполнить автогенерацию заголовочных файлов.


После выполнения всех этих шагов вы можете протестировать свою библиотеку в небольшом проекте, чтобы выявить все проблемы с совместимостью или генерацией заголовков. Если при генерации заголовков возникают какие-либо проблемы, вы можете попробовать настроить этот процесс с помощью файла cbindgen.toml (шаблон можно найти здесь: [https://github.com/eqrion/cbindgen/blob/master/template.toml](https://github.com/eqrion/cbindgen/blob/master/template.toml)).

Стоит отметить проблему, которая возникла при интеграции BLAKE3:
MemorySanitizer может выдавать ложно-положительные отчёты, так как он не всегда может определить, инициализированы ли некоторые переменные в Rust. Это было решено написанием метода с более явным заданием значений для некоторых переменных, хотя такая реализация метода работает медленнее и используется только для исправления сборок с MemorySanitizer.
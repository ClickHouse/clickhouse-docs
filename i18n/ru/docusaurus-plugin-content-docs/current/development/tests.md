---
description: 'Руководство по тестированию ClickHouse и запуску набора тестов'
sidebar_label: 'Тестирование'
sidebar_position: 40
slug: /development/tests
title: 'Тестирование ClickHouse'
doc_type: 'guide'
---



# Тестирование ClickHouse



## Функциональные тесты {#functional-tests}

Функциональные тесты — самые простые и удобные в использовании.
Большинство возможностей ClickHouse можно протестировать с помощью функциональных тестов, и они обязательны для каждого изменения в коде ClickHouse, которое можно протестировать таким образом.

Каждый функциональный тест отправляет один или несколько запросов на работающий сервер ClickHouse и сравнивает результат с эталонным.

Тесты находятся в директории `./tests/queries`.

Каждый тест может быть одного из двух типов: `.sql` и `.sh`.

- Тест `.sql` — это простой SQL-скрипт, который передается в `clickhouse-client`.
- Тест `.sh` — это скрипт, который запускается самостоятельно.

SQL-тесты, как правило, предпочтительнее тестов `.sh`.
Используйте тесты `.sh` только тогда, когда необходимо протестировать функциональность, которую невозможно проверить с помощью чистого SQL, например, передачу входных данных в `clickhouse-client` или тестирование `clickhouse-local`.

:::note
Распространенная ошибка при тестировании типов данных `DateTime` и `DateTime64` — предположение, что сервер использует определенный часовой пояс (например, "UTC"). Это не так, часовые пояса в тестовых запусках CI намеренно рандомизируются. Самый простой способ обойти это — явно указать часовой пояс для тестовых значений, например, `toDateTime64(val, 3, 'Europe/Amsterdam')`.
:::

### Локальный запуск теста {#running-a-test-locally}

Запустите сервер ClickHouse локально, прослушивающий порт по умолчанию (9000).
Чтобы запустить, например, тест `01428_hash_set_nan_key`, перейдите в папку репозитория и выполните следующую команду:

```sh
PATH=<path to clickhouse-client>:$PATH tests/clickhouse-test 01428_hash_set_nan_key
```

Результаты теста (`stderr` и `stdout`) записываются в файлы `01428_hash_set_nan_key.[stderr|stdout]`, которые находятся рядом с самим тестом (для `queries/0_stateless/foo.sql` вывод будет в `queries/0_stateless/foo.stdout`).

Смотрите `tests/clickhouse-test --help` для всех опций `clickhouse-test`.
Вы можете запустить все тесты или подмножество тестов, указав фильтр для имен тестов: `./clickhouse-test substring`.
Также доступны опции для запуска тестов параллельно или в случайном порядке.

### Добавление нового теста {#adding-a-new-test}

Чтобы добавить новый тест, сначала создайте файл `.sql` или `.sh` в директории `queries/0_stateless`.
Затем сгенерируйте соответствующий файл `.reference` с помощью `clickhouse-client < 12345_test.sql > 12345_test.reference` или `./12345_test.sh > ./12345_test.reference`.

Тесты должны только создавать, удалять, выбирать данные и т.д. из таблиц в базе данных `test`, которая автоматически создается заранее.
Допускается использование временных таблиц.

Чтобы настроить локально такое же окружение, как в CI, установите тестовые конфигурации (они будут использовать имитацию Zookeeper и настроят некоторые параметры)

```sh
cd <repository>/tests/config
sudo ./install.sh
```

:::note
Тесты должны быть

- минимальными: создавать только минимально необходимые таблицы, столбцы и сложность,
- быстрыми: выполняться не дольше нескольких секунд (лучше: доли секунды),
- корректными и детерминированными: завершаться неудачей тогда и только тогда, когда тестируемая функциональность не работает,
- изолированными/без состояния: не зависеть от окружения и времени выполнения,
- исчерпывающими: охватывать граничные случаи, такие как нули, null-значения, пустые множества, исключения (негативные тесты, используйте для этого синтаксис `-- { serverError xyz }` и `-- { clientError xyz }`),
- очищать таблицы в конце теста (на случай остатков),
- убедитесь, что другие тесты не тестируют то же самое (т.е. сначала используйте grep).
  :::

### Ограничение запуска тестов {#restricting-test-runs}

Тест может иметь ноль или более _тегов_, указывающих ограничения, в каких контекстах тест запускается в CI.

Для тестов `.sql` теги размещаются в первой строке в виде SQL-комментария:

```sql
-- Tags: no-fasttest, no-replicated-database
-- no-fasttest: <provide_a_reason_for_the_tag_here>
-- no-replicated-database: <provide_a_reason_here>

SELECT 1
```

Для тестов `.sh` теги записываются в виде комментария во второй строке:


```bash
#!/usr/bin/env bash
# Tags: no-fasttest, no-replicated-database
# - no-fasttest: <укажите_причину_использования_тега>
# - no-replicated-database: <укажите_причину>
```

Список доступных тегов:

| Название тега                     | Описание                                                                | Пример использования                                          |
| --------------------------------- | ----------------------------------------------------------------------- | ------------------------------------------------------------- |
| `disabled`                        | Тест не выполняется                                                     |                                                               |
| `long`                            | Время выполнения теста увеличивается с 1 до 10 минут                   |                                                               |
| `deadlock`                        | Тест выполняется в цикле в течение длительного времени                  |                                                               |
| `race`                            | То же, что и `deadlock`. Рекомендуется использовать `deadlock`          |                                                               |
| `shard`                           | Требуется, чтобы сервер прослушивал `127.0.0.*`                         |                                                               |
| `distributed`                     | То же, что и `shard`. Рекомендуется использовать `shard`                |                                                               |
| `global`                          | То же, что и `shard`. Рекомендуется использовать `shard`                |                                                               |
| `zookeeper`                       | Для выполнения теста требуется Zookeeper или ClickHouse Keeper          | Тест использует `ReplicatedMergeTree`                         |
| `replica`                         | То же, что и `zookeeper`. Рекомендуется использовать `zookeeper`        |                                                               |
| `no-fasttest`                     | Тест не выполняется в режиме [Fast test](continuous-integration.md#fast-test)  | Тест использует движок таблиц `MySQL`, который отключен в Fast test |
| `fasttest-only`                   | Тест выполняется только в режиме [Fast test](continuous-integration.md#fast-test) |                                                               |
| `no-[asan, tsan, msan, ubsan]`    | Отключает тесты в сборках с [санитайзерами](#sanitizers)                | Тест выполняется под QEMU, который не работает с санитайзерами |
| `no-replicated-database`          |                                                                         |                                                               |
| `no-ordinary-database`            |                                                                         |                                                               |
| `no-parallel`                     | Отключает параллельное выполнение других тестов с данным тестом          | Тест читает из таблиц `system`, и инварианты могут быть нарушены |
| `no-parallel-replicas`            |                                                                         |                                                               |
| `no-debug`                        |                                                                         |                                                               |
| `no-stress`                       |                                                                         |                                                               |
| `no-polymorphic-parts`            |                                                                         |                                                               |
| `no-random-settings`              |                                                                         |                                                               |
| `no-random-merge-tree-settings`   |                                                                         |                                                               |
| `no-backward-compatibility-check` |                                                                         |                                                               |
| `no-cpu-x86_64`                   |                                                                         |                                                               |
| `no-cpu-aarch64`                  |                                                                         |                                                               |
| `no-cpu-ppc64le`                  |                                                                         |                                                               |
| `no-s3-storage`                   |                                                                         |                                                               |

Помимо перечисленных настроек, вы можете использовать флаги `USE_*` из `system.build_options` для определения использования конкретных функций ClickHouse.
Например, если ваш тест использует таблицу MySQL, следует добавить тег `use-mysql`.

### Указание ограничений для случайных настроек {#specifying-limits-for-random-settings}

Тест может указывать минимальные и максимальные допустимые значения для настроек, которые могут быть рандомизированы во время выполнения теста.

Для тестов `.sh` ограничения записываются в виде комментария на строке рядом с тегами или на второй строке, если теги не указаны:


```bash
#!/usr/bin/env bash
# Tags: no-fasttest
# Ограничения случайных настроек: max_block_size=(1000, 10000); index_granularity=(100, None)
```

Для `.sql` тестов теги размещаются в виде SQL-комментария в строке с тегами или в первой строке:

```sql
-- Tags: no-fasttest
-- Ограничения случайных настроек: max_block_size=(1000, 10000); index_granularity=(100, None)
SELECT 1
```

Если необходимо указать только одно ограничение, для другого можно использовать `None`.

### Выбор имени теста {#choosing-the-test-name}

Имя теста начинается с пятизначного префикса, за которым следует описательное имя, например `00422_hash_function_constexpr.sql`.
Чтобы выбрать префикс, найдите наибольший префикс, уже присутствующий в каталоге, и увеличьте его на единицу.

```sh
ls tests/queries/0_stateless/[0-9]*.reference | tail -n 1
```

За это время могут быть добавлены другие тесты с тем же числовым префиксом, но это нормально и не приводит к проблемам — менять его позже не нужно.

### Проверка ожидаемой ошибки {#checking-for-an-error-that-must-occur}

Иногда требуется проверить, что для некорректного запроса возникает ошибка сервера. Для этого в SQL-тестах поддерживаются специальные аннотации следующего вида:

```sql
SELECT x; -- { serverError 49 }
```

Этот тест проверяет, что сервер возвращает ошибку с кодом 49 о неизвестном столбце `x`.
Если ошибка не возникает или возникает другая ошибка, тест завершится неудачей.
Если необходимо проверить, что ошибка возникает на стороне клиента, используйте аннотацию `clientError`.

Не проверяйте конкретную формулировку сообщения об ошибке — она может измениться в будущем, и тест будет ломаться без необходимости.
Проверяйте только код ошибки.
Если существующий код ошибки недостаточно точен для ваших целей, рассмотрите возможность добавления нового.

### Тестирование распределенного запроса {#testing-a-distributed-query}

Если необходимо использовать распределенные запросы в функциональных тестах, можно использовать табличную функцию `remote` с адресами `127.0.0.{1..2}`, чтобы сервер запрашивал сам себя, или использовать предопределенные тестовые кластеры в конфигурационном файле сервера, такие как `test_shard_localhost`.
Не забудьте добавить слова `shard` или `distributed` в имя теста, чтобы он запускался в CI с правильными конфигурациями, где сервер настроен на поддержку распределенных запросов.

### Работа с временными файлами {#working-with-temporary-files}

Иногда в shell-тесте может потребоваться создать файл на лету для работы с ним.
Учитывайте, что некоторые проверки CI запускают тесты параллельно, поэтому если вы создаете или удаляете временный файл в скрипте без уникального имени, это может привести к сбою некоторых проверок CI, таких как Flaky.
Чтобы избежать этого, используйте переменную окружения `$CLICKHOUSE_TEST_UNIQUE_NAME` для присвоения временным файлам имени, уникального для выполняемого теста.
Таким образом, вы можете быть уверены, что файл, который создается при настройке или удаляется при очистке, используется только этим тестом, а не каким-либо другим параллельно выполняемым тестом.


## Известные ошибки {#known-bugs}

Если нам известны ошибки, которые можно легко воспроизвести с помощью функциональных тестов, мы размещаем подготовленные функциональные тесты в каталоге `tests/queries/bugs`.
Эти тесты будут перемещены в `tests/queries/0_stateless` после устранения ошибок.


## Интеграционные тесты {#integration-tests}

Интеграционные тесты позволяют тестировать ClickHouse в кластерной конфигурации и взаимодействие ClickHouse с другими серверами, такими как MySQL, Postgres, MongoDB.
Они полезны для эмуляции сетевых разделений, потери пакетов и т. д.
Эти тесты запускаются в Docker и создают несколько контейнеров с различным программным обеспечением.

Инструкции по запуску этих тестов см. в `tests/integration/README.md`.

Обратите внимание, что интеграция ClickHouse со сторонними драйверами не тестируется.
Кроме того, в настоящее время у нас нет интеграционных тестов для наших драйверов JDBC и ODBC.


## Модульные тесты {#unit-tests}

Модульные тесты полезны, когда требуется протестировать не ClickHouse в целом, а отдельную изолированную библиотеку или класс.
Сборку тестов можно включить или отключить с помощью опции CMake `ENABLE_TESTS`.
Модульные тесты (и другие тестовые программы) расположены в подкаталогах `tests` в различных частях кодовой базы.
Для запуска модульных тестов выполните команду `ninja test`.
Некоторые тесты используют `gtest`, другие представляют собой программы, возвращающие ненулевой код завершения при неудачном выполнении теста.

Модульные тесты не обязательны, если код уже покрыт функциональными тестами (функциональные тесты обычно гораздо проще в использовании).

Отдельные проверки gtest можно запускать, вызывая исполняемый файл напрямую, например:

```bash
$ ./src/unit_tests_dbms --gtest_filter=LocalAddress*
```


## Тесты производительности {#performance-tests}

Тесты производительности позволяют измерять и сравнивать производительность отдельных компонентов ClickHouse на синтетических запросах.
Тесты производительности находятся в директории `tests/performance/`.
Каждый тест представлен файлом `.xml` с описанием тестового сценария.
Тесты запускаются с помощью инструмента `docker/test/performance-comparison`. Информацию о запуске см. в файле readme.

Каждый тест выполняет один или несколько запросов (возможно, с различными комбинациями параметров) в цикле.

Если вы хотите улучшить производительность ClickHouse в определённом сценарии, и если улучшения можно наблюдать на простых запросах, настоятельно рекомендуется написать тест производительности.
Также рекомендуется писать тесты производительности при добавлении или изменении SQL-функций, которые являются относительно изолированными и не слишком специфичными.
Всегда имеет смысл использовать `perf top` или другие инструменты `perf` во время тестирования.


## Инструменты и скрипты для тестирования {#test-tools-and-scripts}

Некоторые программы в каталоге `tests` не являются готовыми тестами, а представляют собой инструменты для тестирования.
Например, для `Lexer` существует инструмент `src/Parsers/tests/lexer`, который выполняет токенизацию stdin и выводит результат с цветовым выделением в stdout.
Вы можете использовать такие инструменты в качестве примеров кода, а также для исследования и ручного тестирования.


## Прочие тесты {#miscellaneous-tests}

Тесты для моделей машинного обучения находятся в `tests/external_models`.
Эти тесты не обновляются и должны быть перенесены в интеграционные тесты.

Существует отдельный тест для вставок с кворумом.
Этот тест запускает кластер ClickHouse на отдельных серверах и эмулирует различные сценарии сбоев: разделение сети, потерю пакетов (между узлами ClickHouse, между ClickHouse и ZooKeeper, между сервером ClickHouse и клиентом и т. д.), `kill -9`, `kill -STOP` и `kill -CONT`, подобно [Jepsen](https://aphyr.com/tags/Jepsen). Затем тест проверяет, что все подтверждённые вставки были записаны, а все отклонённые — нет.

Тест кворума был написан отдельной командой до того, как ClickHouse стал проектом с открытым исходным кодом.
Эта команда больше не работает с ClickHouse.
Тест был случайно написан на Java.
По этим причинам тест кворума должен быть переписан и перенесён в интеграционные тесты.


## Ручное тестирование {#manual-testing}

При разработке новой функциональности рекомендуется также протестировать её вручную.
Для этого выполните следующие шаги:

Соберите ClickHouse. Запустите ClickHouse из терминала: перейдите в каталог `programs/clickhouse-server` и запустите его командой `./clickhouse-server`. По умолчанию будет использоваться конфигурация (`config.xml`, `users.xml` и файлы в каталогах `config.d` и `users.d`) из текущего каталога. Для подключения к серверу ClickHouse выполните команду `programs/clickhouse-client/clickhouse-client`.

Обратите внимание, что все инструменты ClickHouse (server, client и т. д.) являются символическими ссылками на единый исполняемый файл с именем `clickhouse`.
Этот исполняемый файл находится в `programs/clickhouse`.
Все инструменты также можно вызывать как `clickhouse tool` вместо `clickhouse-tool`.

Альтернативный вариант — установить пакет ClickHouse: либо стабильный релиз из репозитория ClickHouse, либо собрать пакет самостоятельно с помощью `./release` в корневом каталоге исходных кодов ClickHouse.
Затем запустите сервер командой `sudo clickhouse start` (или `stop` для остановки сервера).
Логи находятся в `/etc/clickhouse-server/clickhouse-server.log`.

Если ClickHouse уже установлен в вашей системе, вы можете собрать новый исполняемый файл `clickhouse` и заменить существующий:

```bash
$ sudo clickhouse stop
$ sudo cp ./clickhouse /usr/bin/
$ sudo clickhouse start
```

Также можно остановить системный clickhouse-server и запустить собственный с той же конфигурацией, но с выводом логов в терминал:

```bash
$ sudo clickhouse stop
$ sudo -u clickhouse /usr/bin/clickhouse server --config-file /etc/clickhouse-server/config.xml
```

Пример с gdb:

```bash
$ sudo -u clickhouse gdb --args /usr/bin/clickhouse server --config-file /etc/clickhouse-server/config.xml
```

Если системный clickhouse-server уже запущен и вы не хотите его останавливать, можно изменить номера портов в `config.xml` (или переопределить их в файле в каталоге `config.d`), указать соответствующий путь к данным и запустить его.

Исполняемый файл `clickhouse` практически не имеет зависимостей и работает на широком спектре дистрибутивов Linux.
Для быстрого тестирования ваших изменений на сервере можно просто скопировать свежесобранный исполняемый файл `clickhouse` на сервер с помощью `scp` и затем запустить его, как показано в примерах выше.


## Тесты сборки {#build-tests}

Тесты сборки позволяют проверить, что сборка не ломается на различных альтернативных конфигурациях и на некоторых сторонних системах.
Эти тесты также автоматизированы.

Примеры:

- кросс-компиляция для Darwin x86_64 (macOS)
- кросс-компиляция для FreeBSD x86_64
- кросс-компиляция для Linux AArch64
- сборка на Ubuntu с библиотеками из системных пакетов (не рекомендуется)
- сборка с динамической компоновкой библиотек (не рекомендуется)

Например, сборка с системными пакетами является плохой практикой, поскольку мы не можем гарантировать, какая именно версия пакетов будет установлена в системе.
Однако это действительно необходимо сопровождающим Debian.
По этой причине мы должны поддерживать как минимум этот вариант сборки.
Другой пример: динамическая компоновка является распространённым источником проблем, но она необходима некоторым энтузиастам.

Хотя мы не можем запускать все тесты для всех вариантов сборки, мы хотим проверить хотя бы то, что различные варианты сборки не ломаются.
Для этой цели мы используем тесты сборки.

Мы также проверяем, что нет единиц трансляции, которые слишком долго компилируются или требуют слишком много оперативной памяти.

Мы также проверяем отсутствие слишком больших кадров стека.


## Тестирование совместимости протокола {#testing-for-protocol-compatibility}

При расширении сетевого протокола ClickHouse мы вручную проверяем, что старый clickhouse-client работает с новым clickhouse-server, а новый clickhouse-client работает со старым clickhouse-server (просто запуская бинарные файлы из соответствующих пакетов).

Мы также автоматически тестируем некоторые сценарии с помощью интеграционных тестов:

- успешно ли читаются новой версией данные, записанные старой версией ClickHouse;
- работают ли распределённые запросы в кластере с разными версиями ClickHouse.


## Помощь от компилятора {#help-from-the-compiler}

Основной код ClickHouse (который находится в директории `src`) собирается с флагами `-Wall -Wextra -Werror` и с некоторыми дополнительными включёнными предупреждениями.
Однако эти опции не включены для сторонних библиотек.

Clang имеет ещё больше полезных предупреждений — вы можете посмотреть их с помощью `-Weverything` и выбрать что-то для сборки по умолчанию.

Мы всегда используем clang для сборки ClickHouse как для разработки, так и для production.

Вы можете собирать на своей машине в режиме отладки (чтобы сэкономить заряд батареи ноутбука), но обратите внимание, что компилятор способен генерировать больше предупреждений с флагом `-O3` благодаря улучшенному анализу потока управления и межпроцедурному анализу.

При сборке с clang в режиме отладки используется отладочная версия `libc++`, которая позволяет обнаруживать больше ошибок во время выполнения.


## Санитайзеры {#sanitizers}

:::note
Если процесс (сервер или клиент ClickHouse) аварийно завершается при запуске локально, может потребоваться отключить рандомизацию размещения адресного пространства: `sudo sysctl kernel.randomize_va_space=0`
:::

### Address Sanitizer {#address-sanitizer}

Мы запускаем функциональные, интеграционные, стресс-тесты и модульные тесты под ASan для каждого коммита.

### Thread Sanitizer {#thread-sanitizer}

Мы запускаем функциональные, интеграционные, стресс-тесты и модульные тесты под TSan для каждого коммита.

### Memory Sanitizer {#memory-sanitizer}

Мы запускаем функциональные, интеграционные, стресс-тесты и модульные тесты под MSan для каждого коммита.

### Undefined Behaviour Sanitizer {#undefined-behaviour-sanitizer}

Мы запускаем функциональные, интеграционные, стресс-тесты и модульные тесты под UBSan для каждого коммита.
Код некоторых сторонних библиотек не проверяется на неопределённое поведение.

### Valgrind (memcheck) {#valgrind-memcheck}

Ранее мы запускали функциональные тесты под Valgrind в ночном режиме, но больше этого не делаем.
Это занимает несколько часов.
В настоящее время известно одно ложное срабатывание в библиотеке `re2`, см. [эту статью](https://research.swtch.com/sparse).


## Фаззинг {#fuzzing}

Фаззинг ClickHouse реализован с использованием [libFuzzer](https://llvm.org/docs/LibFuzzer.html) и случайных SQL-запросов.
Все фаззинг-тестирование должно выполняться с санитайзерами (Address и Undefined).

LibFuzzer используется для изолированного фаззинг-тестирования кода библиотек.
Фаззеры реализованы как часть тестового кода и имеют постфикс "\_fuzzer" в имени.
Пример фаззера можно найти в `src/Parsers/fuzzers/lexer_fuzzer.cpp`.
Конфигурации, словари и корпус, специфичные для LibFuzzer, хранятся в `tests/fuzz`.
Мы рекомендуем писать фаззинг-тесты для каждой функциональности, обрабатывающей пользовательский ввод.

Фаззеры не собираются по умолчанию.
Для сборки фаззеров необходимо установить оба параметра: `-DENABLE_FUZZING=1` и `-DENABLE_TESTS=1`.
Мы рекомендуем отключить Jemalloc при сборке фаззеров.
Конфигурация для интеграции фаззинга ClickHouse с
Google OSS-Fuzz находится в `docker/fuzz`.

Мы также используем простой фаззинг-тест для генерации случайных SQL-запросов и проверки того, что сервер не завершается аварийно при их выполнении.
Его можно найти в `00746_sql_fuzzy.pl`.
Этот тест должен выполняться непрерывно (в течение ночи и дольше).

Мы также используем сложный фаззер запросов на основе AST, который способен находить большое количество граничных случаев.
Он выполняет случайные перестановки и подстановки в AST запросов.
Он запоминает узлы AST из предыдущих тестов, чтобы использовать их для фаззинга последующих тестов, обрабатывая их в случайном порядке.
Подробнее об этом фаззере можно узнать в [этой статье блога](https://clickhouse.com/blog/fuzzing-click-house).


## Нагрузочное тестирование {#stress-test}

Нагрузочные тесты — это ещё один вид фаззинг-тестирования.
Они запускают все функциональные тесты параллельно в случайном порядке на одном сервере.
Результаты тестов не проверяются.

Проверяется следующее:

- сервер не падает, не срабатывают ловушки отладчика или санитайзеров;
- отсутствуют взаимные блокировки (deadlocks);
- структура базы данных остаётся согласованной;
- сервер может успешно остановиться после теста и запуститься снова без исключений.

Существует пять вариантов (Debug, ASan, TSan, MSan, UBSan).


## Thread fuzzer {#thread-fuzzer}

Thread Fuzzer (не путайте с Thread Sanitizer) — это ещё один вид фаззинга, который позволяет рандомизировать порядок выполнения потоков.
Это помогает находить ещё больше особых случаев.


## Аудит безопасности {#security-audit}

Наша команда по безопасности провела базовый анализ возможностей ClickHouse с точки зрения безопасности.


## Статические анализаторы {#static-analyzers}

Мы запускаем `clang-tidy` при каждом коммите.
Также включены проверки `clang-static-analyzer`.
`clang-tidy` также используется для проверки стиля кода.

Мы протестировали `clang-tidy`, `Coverity`, `cppcheck`, `PVS-Studio`, `tscancode`, `CodeQL`.
Инструкции по использованию можно найти в директории `tests/instructions/`.

Если вы используете `CLion` в качестве IDE, вы можете воспользоваться некоторыми проверками `clang-tidy` без дополнительной настройки.

Мы также используем `shellcheck` для статического анализа shell-скриптов.


## Усиление защиты {#hardening}

В отладочной сборке используется пользовательский аллокатор, который выполняет ASLR для выделений памяти на уровне пользователя.

Также вручную защищаются области памяти, которые должны быть доступны только для чтения после выделения.

В отладочной сборке также используется модифицированная версия libc, которая гарантирует, что не вызываются «вредные» (устаревшие, небезопасные, не потокобезопасные) функции.

Отладочные утверждения используются повсеместно.

В отладочной сборке, если выбрасывается исключение с кодом «логическая ошибка» (что указывает на баг), программа досрочно завершается.
Это позволяет использовать исключения в релизной сборке, но превращать их в утверждения в отладочной сборке.

Для отладочных сборок используется отладочная версия jemalloc.
Для отладочных сборок используется отладочная версия libc++.


## Проверки целостности во время выполнения {#runtime-integrity-checks}

Данные, хранящиеся на диске, защищены контрольными суммами.
Данные в таблицах MergeTree защищены контрольными суммами тремя способами одновременно\* (сжатые блоки данных, несжатые блоки данных, общая контрольная сумма по блокам).
Данные, передаваемые по сети между клиентом и сервером или между серверами, также защищены контрольными суммами.
Репликация обеспечивает побитовую идентичность данных на репликах.

Это необходимо для защиты от неисправного оборудования (деградация битов на носителях данных, инверсия битов в оперативной памяти сервера, инверсия битов в оперативной памяти сетевого контроллера, инверсия битов в оперативной памяти сетевого коммутатора, инверсия битов в оперативной памяти клиента, инверсия битов в канале передачи данных).
Обратите внимание, что инверсия битов — распространённое явление, которое может происходить даже при использовании памяти ECC и наличии контрольных сумм TCP (если вы управляете тысячами серверов, обрабатывающих петабайты данных ежедневно).
[Смотрите видео (на русском языке)](https://www.youtube.com/watch?v=ooBAQIe0KlQ).

ClickHouse предоставляет средства диагностики, которые помогут эксплуатационным инженерам обнаружить неисправное оборудование.

\* и это не замедляет работу.


## Стиль кода {#code-style}

Правила стиля кода описаны [здесь](style.md).

Для проверки наиболее распространённых нарушений стиля можно использовать скрипт `utils/check-style`.

Для приведения кода к правильному стилю можно использовать `clang-format`.
Файл `.clang-format` находится в корневой директории исходного кода.
Он в основном соответствует нашему фактическому стилю кода.
Однако не рекомендуется применять `clang-format` к существующим файлам, так как это ухудшает форматирование.
Вы можете использовать инструмент `clang-format-diff`, который можно найти в репозитории исходного кода clang.

В качестве альтернативы можно попробовать инструмент `uncrustify` для переформатирования кода.
Конфигурация находится в файле `uncrustify.cfg` в корневой директории исходного кода.
Он протестирован в меньшей степени, чем `clang-format`.

`CLion` имеет собственный форматировщик кода, который необходимо настроить под наш стиль кода.

Мы также используем `codespell` для поиска опечаток в коде.
Эта проверка также автоматизирована.


## Покрытие тестами {#test-coverage}

Мы также отслеживаем покрытие тестами, но только для функциональных тестов и только для clickhouse-server.
Это выполняется на ежедневной основе.


## Тесты для тестов {#tests-for-tests}

Существует автоматическая проверка на нестабильные тесты.
Она запускает все новые тесты 100 раз (для функциональных тестов) или 10 раз (для интеграционных тестов).
Если тест не прошёл хотя бы один раз, он считается нестабильным.


## Автоматизация тестирования {#test-automation}

Мы запускаем тесты с помощью [GitHub Actions](https://github.com/features/actions).

Задачи сборки и тесты выполняются в Sandbox для каждого коммита.
Полученные пакеты и результаты тестов публикуются на GitHub и могут быть загружены по прямым ссылкам.
Артефакты хранятся в течение нескольких месяцев.
Когда вы отправляете pull request на GitHub, мы помечаем его как «can be tested», и наша система CI соберёт для вас пакеты ClickHouse (release, debug, с address sanitizer и т. д.).

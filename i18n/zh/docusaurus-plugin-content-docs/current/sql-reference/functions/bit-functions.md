---
description: '位运算函数文档'
sidebar_label: '位运算'
slug: /sql-reference/functions/bit-functions
title: '位运算函数'
doc_type: 'reference'
---



# 位函数

位函数适用于 `UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64`、`Float32` 或 `Float64` 类型的任意组合。部分函数支持 `String` 和 `FixedString` 类型。

结果类型为整数,其位数等于参数中的最大位数。如果至少有一个参数为有符号数,则结果为有符号数。如果参数为浮点数,则会被转换为 Int64。

<!--
以下标签内的内容在文档框架构建时会被
从 system.functions 生成的文档替换。请勿修改或删除这些标签。
参见:https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## bitAnd {#bitAnd}

引入版本：v1.1

对两个值执行按位与运算。

**语法**

```sql
bitAnd(a, b)
```

**参数**

- `a` — 第一个值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)
- `b` — 第二个值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回按位运算 `a AND b` 的结果。

**示例**

**使用示例**

```sql title=查询
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitAnd(a, b)
FROM bits
```

```response title=响应
┌─a─┬─b─┬─bitAnd(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            0 │
│ 1 │ 0 │            0 │
│ 1 │ 1 │            1 │
└───┴───┴──────────────┘
```


## bitCount {#bitCount}

引入版本：v20.3

计算数字二进制表示中值为 1 的比特位数量。

**语法**

```sql
bitCount(x)
```

**参数**

- `x` — 整数或浮点数值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回 `x` 中值为 1 的比特位数量。[`UInt8`](../data-types/int-uint.md)。

:::note
该函数不会将输入值转换为更大的类型（[符号扩展](https://en.wikipedia.org/wiki/Sign_extension)）。
例如：`bitCount(toUInt8(-1)) = 8`。
:::

**示例**

**使用示例**

```sql title=Query
SELECT bin(333), bitCount(333);
```

```response title=Response
┌─bin(333)─────────┬─bitCount(333)─┐
│ 0000000101001101 │             5 │
└──────────────────┴───────────────┘
```


## bitHammingDistance {#bitHammingDistance}

引入版本：v21.1

返回两个数字的位表示之间的[汉明距离](https://en.wikipedia.org/wiki/Hamming_distance)。
可与 [`SimHash`](../../sql-reference/functions/hash-functions.md#ngramSimHash) 函数配合使用，用于检测半重复字符串。
距离越小，字符串相似度越高。

**语法**

```sql
bitHammingDistance(x, y)
```

**参数**

- `x` — 汉明距离计算的第一个数字。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)
- `y` — 汉明距离计算的第二个数字。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回 `x` 和 `y` 之间的汉明距离。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT bitHammingDistance(111, 121);
```

```response title=响应
┌─bitHammingDistance(111, 121)─┐
│                            3 │
└──────────────────────────────┘
```


## bitNot {#bitNot}

引入版本:v1.1

执行按位 NOT 运算。

**语法**

```sql
bitNot(a)
```

**参数**

- `a` — 要对其执行按位 NOT 运算的值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float) 或 [`String`](/sql-reference/data-types/string)

**返回值**

返回 `~a` 的结果,即对 `a` 的各位取反后的值。

**示例**

**使用示例**

```sql title=查询
SELECT
    CAST('5', 'UInt8') AS original,
    bin(original) AS original_binary,
    bitNot(original) AS result,
    bin(bitNot(original)) AS result_binary;
```

```response title=响应
┌─original─┬─original_binary─┬─result─┬─result_binary─┐
│        5 │ 00000101        │    250 │ 11111010      │
└──────────┴─────────────────┴────────┴───────────────┘
```


## bitOr {#bitOr}

引入版本:v1.1

对两个值执行按位或(OR)运算。

**语法**

```sql
bitOr(a, b)
```

**参数**

- `a` — 第一个值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)
- `b` — 第二个值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回按位或运算 `a OR b` 的结果。

**示例**

**使用示例**

```sql title=查询
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitOr(a, b)
FROM bits;
```

```response title=响应
┌─a─┬─b─┬─bitOr(a, b)─┐
│ 0 │ 0 │           0 │
│ 0 │ 1 │           1 │
│ 1 │ 0 │           1 │
│ 1 │ 1 │           1 │
└───┴───┴─────────────┘
```


## bitRotateLeft {#bitRotateLeft}

引入版本:v1.1

将二进制位向左循环移位指定的位数。移出的位会循环到右侧。

**语法**

```sql
bitRotateLeft(a, N)
```

**参数**

- `a` — 要进行循环移位的值。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `N` — 向左循环移位的位数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

返回循环移位后的值,类型与 `a` 相同。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT 99 AS a, bin(a), bitRotateLeft(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=响应
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       141 │ 10001101       │
└────┴──────────┴───────────┴────────────────┘
```


## bitRotateRight {#bitRotateRight}

引入版本:v1.1

将二进制位向右循环移位指定的位数。移出的位会回绕到左侧。

**语法**

```sql
bitRotateRight(a, N)
```

**参数**

- `a` — 要进行循环移位的值。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `N` — 向右循环移位的位数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

返回循环移位后的值,类型与 `a` 相同。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT 99 AS a, bin(a), bitRotateRight(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=响应
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       216 │ 11011000       │
└────┴──────────┴───────────┴────────────────┘
```


## bitShiftLeft {#bitShiftLeft}

引入版本：v1.1

将值的二进制表示向左移动指定的位数。

`FixedString` 或 `String` 被视为单个多字节值。

`FixedString` 值的位在移出时会丢失。
相反，`String` 值会通过额外的字节进行扩展，因此不会丢失任何位。

**语法**

```sql
bitShiftLeft(a, N)
```

**参数**

- `a` — 要移位的值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `N` — 要移位的位数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

返回移位后的值，其类型与 `a` 的类型相同。

**示例**

**二进制编码使用示例**

```sql title=查询
SELECT 99 AS a, bin(a), bitShiftLeft(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=响应
┌──a─┬─bin(99)──┬─a_shifted─┬─bin(bitShiftLeft(99, 2))─┐
│ 99 │ 01100011 │       140 │ 10001100                 │
└────┴──────────┴───────────┴──────────────────────────┘
```

**十六进制编码使用示例**

```sql title=查询
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=响应
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftLeft('abc', 4))─┐
│ abc │ 616263     │ &0        │ 06162630                    │
└─────┴────────────┴───────────┴─────────────────────────────┘
```

**固定字符串编码使用示例**

```sql title=查询
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=响应
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftLeft(toFixedString('abc', 3), 4))─┐
│ abc │ 616263                       │ &0        │ 162630                                        │
└─────┴──────────────────────────────┴───────────┴───────────────────────────────────────────────┘
```


## bitShiftRight {#bitShiftRight}

引入版本：v1.1

将值的二进制表示向右移动指定的位数。

`FixedString` 或 `String` 被视为单个多字节值。

`FixedString` 值的位在移出时会丢失。
相反，`String` 值会通过额外的字节进行扩展，因此不会丢失任何位。

**语法**

```sql
bitShiftRight(a, N)
```

**参数**

- `a` — 要移位的值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `N` — 要移位的位数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

返回移位后的值,其类型与 `a` 的类型相同。

**示例**

**二进制编码的使用示例**

```sql title=查询
SELECT 101 AS a, bin(a), bitShiftRight(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=响应
┌───a─┬─bin(101)─┬─a_shifted─┬─bin(bitShiftRight(101, 2))─┐
│ 101 │ 01100101 │        25 │ 00011001                   │
└─────┴──────────┴───────────┴────────────────────────────┘
```

**十六进制编码的使用示例**

```sql title=查询
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=响应
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftRight('abc', 12))─┐
│ abc │ 616263     │           │ 0616                          │
└─────┴────────────┴───────────┴───────────────────────────────┘
```

**固定字符串编码的使用示例**

```sql title=查询
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftRight(a, 12) AS a_shifted, hex(a_shifted);
```

```response title=响应
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftRight(toFixedString('abc', 3), 12))─┐
│ abc │ 616263                       │           │ 000616                                          │
└─────┴──────────────────────────────┴───────────┴─────────────────────────────────────────────────┘
```


## bitSlice {#bitSlice}

引入版本：v22.2

返回从 'offset' 索引位开始、长度为 'length' 位的子字符串。

**语法**

```sql
bitSlice(s, offset[, length])
```

**参数**

- `s` — 要切片的字符串或固定长度字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `offset` —
  起始位位置(基于 1 的索引)。
- 正值：从字符串开头开始计数。
- 负值：从字符串末尾开始计数。

         [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

- `length` —
  可选。要提取的位数。
- 正值：提取 `length` 位。
- 负值：从偏移量提取到 `(string_length - |length|)`。
- 省略：从偏移量提取到字符串末尾。
- 如果长度不是 8 的倍数，结果将在右侧用零填充。
  [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回包含提取位的字符串，以二进制序列表示。结果始终填充到字节边界(8 位的倍数) [`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 8));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 2));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 9));
SELECT bin('Hello'), bin(bitSlice('Hello', -4, 8));
```

```response title=Response
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 8))─┐
│ 0100100001100101011011000110110001101111 │ 01001000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 2))─┐
│ 0100100001100101011011000110110001101111 │ 01000000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 9))─┐
│ 0100100001100101011011000110110001101111 │ 0100100000000000             │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', -4, 8))─┐
│ 0100100001100101011011000110110001101111 │ 11110000                      │
└──────────────────────────────────────────┴───────────────────────────────┘
```


## bitTest {#bitTest}

引入版本：v1.1

接受任意数字并将其转换为[二进制形式](https://en.wikipedia.org/wiki/Binary_number)，然后返回指定位置的位值。位的计数从右到左进行，起始位置为 0。

**语法**

```sql
bitTest(a, i)
```

**参数**

- `a` — 要转换的数字。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)
- `i` — 要返回的位位置。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回 `a` 的二进制表示中位置 `i` 处的位值 [`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT bin(2), bitTest(2, 1);
```

```response title=响应
┌─bin(2)───┬─bitTest(2, 1)─┐
│ 00000010 │             1 │
└──────────┴───────────────┘
```


## bitTestAll {#bitTestAll}

引入版本：v1.1

返回给定位置上所有位的[逻辑与](https://en.wikipedia.org/wiki/Logical_conjunction)（AND 运算符）结果。
从右到左计数，从 0 开始。

两个位之间的逻辑与运算当且仅当两个输入位都为真时结果才为真。

**语法**

```sql
bitTestAll(a, index1[, index2, ... , indexN])
```

**参数**

- `a` — 整数值。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `index1, ...` — 一个或多个位的位置。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

返回逻辑与运算的结果 [`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例 1**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(43, 0, 1, 3, 5)─┐
│ 00101011 │                          1 │
└──────────┴────────────────────────────┘
```

**使用示例 2**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(4⋯1, 3, 5, 2)─┐
│ 00101011 │                        0 │
└──────────┴──────────────────────────┘
```


## bitTestAny {#bitTestAny}

引入版本:v1.1

返回数字中指定位置上所有位的[逻辑析取](https://en.wikipedia.org/wiki/Logical_disjunction)(OR 运算符)结果。
位置从右到左计数,起始位置为 0。

当至少有一个输入位为真时,两个位之间的逻辑 OR 结果为真。

**语法**

```sql
bitTestAny(a, index1[, index2, ... , indexN])
```

**参数**

- `a` — 整数值。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `index1, ...` — 一个或多个位位置。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

返回逻辑析取的结果 [`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例 1**

```sql title=Query
SELECT bitTestAny(43, 0, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAny(43, 0, 2)─┐
│ 00101011 │                    1 │
└──────────┴──────────────────────┘
```

**使用示例 2**

```sql title=Query
SELECT bitTestAny(43, 4, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAny(43, 4, 2)─┐
│ 00101011 │                    0 │
└──────────┴──────────────────────┘
```


## bitXor {#bitXor}

引入版本:v1.1

对两个值执行按位异或(XOR)运算。

**语法**

```sql
bitXor(a, b)
```

**参数**

- `a` — 第一个值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)
- `b` — 第二个值。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回按位运算 `a XOR b` 的结果。

**示例**

**使用示例**

```sql title=查询
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitXor(a, b)
FROM bits;
```

```response title=响应
┌─a─┬─b─┬─bitXor(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            1 │
│ 1 │ 0 │            1 │
│ 1 │ 1 │            0 │
└───┴───┴──────────────┘
```

<!--AUTOGENERATED_END-->

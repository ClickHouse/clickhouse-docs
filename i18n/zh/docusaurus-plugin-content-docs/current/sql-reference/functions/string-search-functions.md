---
description: '用于在字符串中搜索的函数文档'
sidebar_label: '字符串搜索函数'
slug: /sql-reference/functions/string-search-functions
title: '字符串搜索函数'
doc_type: 'reference'
---

# 在字符串中搜索的函数 {#functions-for-searching-in-strings}

本节中的所有函数默认执行区分大小写的搜索。不区分大小写的搜索通常通过单独的函数变体提供。

:::note
不区分大小写的搜索遵循英语的大小写规则。例如，英语中小写字母 `i` 的大写形式是 `I`，而在土耳其语中则是 `İ` —— 因此对于非英语语言，结果可能与预期不符。
:::

本节中的函数还假定被搜索的字符串（在本节中称为 `haystack`）和搜索字符串（在本节中称为 `needle`）是单字节编码文本。如果不满足这一假设，将不会抛出异常，且结果未定义。对 UTF-8 编码字符串的搜索通常通过单独的函数变体提供。同样地，如果使用了 UTF-8 函数变体而输入字符串不是 UTF-8 编码文本，也不会抛出异常，且结果未定义。请注意，不会执行自动的 Unicode 规范化，不过您可以使用 [normalizeUTF8*()](https://clickhouse.com../functions/string-functions/) 函数来实现这一点。

[通用字符串函数](string-functions.md) 和 [字符串替换函数](string-replace-functions.md) 在单独的文档中进行说明。

:::note
下面的文档是从 `system.functions` 系统表生成的。
:::

{/* 
  下面标签的内部内容会在文档框架构建时，
  被 system.functions 生成的文档所替换。
  请不要修改或删除这些标签。
  参见：https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## countMatches {#countMatches}

引入于：v21.1

返回正则表达式在字符串中的匹配次数。

:::note Version dependent behavior
该函数的行为依赖于 ClickHouse 版本：

* 在 &lt; v25.6 的版本中，即使模式允许，函数在遇到第一个空匹配时就会停止计数。
* 在 &gt;= 25.6 的版本中，函数在出现空匹配时会继续执行。可以通过设置 `count_matches_stop_at_empty_match = true` 恢复旧行为。
  :::

**语法**

```sql
countMatches(haystack, pattern)
```

**参数**

* `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 正则表达式模式。[`String`](/sql-reference/data-types/string)

**返回值**

返回匹配到的次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**统计数字序列**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```



## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

Introduced in: v21.1


Like [`countMatches`](#countMatches) but performs case-insensitive matching.
    

**Syntax**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**Arguments**

- `haystack` — The string to search in. [`String`](/sql-reference/data-types/string)
- `pattern` — Regular expression pattern. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns the number of matches found. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive count**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```



## countSubstrings {#countSubstrings}

Introduced in: v21.1

Returns how often a substring `needle` occurs in a string `haystack`.

**Syntax**

```sql
countSubstrings(干草堆, 针[, 起始位置])
```

**Arguments**

- `haystack` — String in which the search is performed. [String](../../sql-reference/data-types/string.md) or [Enum](../../sql-reference/data-types/enum.md). - `needle` — Substring to be searched. [String](../../sql-reference/data-types/string.md). - `start_pos` — Position (1-based) in `haystack` at which the search starts. [UInt](../../sql-reference/data-types/int-uint.md). Optional. 

**Returned value**

The number of occurrences. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**With start_pos argument**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```



## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

Introduced in: v21.1

Like [`countSubstrings`](#countSubstrings) but counts case-insensitively.

**Syntax**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`Enum`](/sql-reference/data-types/enum)
- `needle` — Substring to be searched. [`String`](/sql-reference/data-types/string)
- `start_pos` — Optional. Position (1-based) in `haystack` at which the search starts. [`UInt*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the number of occurrences of the neddle in the haystack. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**With start_pos argument**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```



## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

Introduced in: v21.1


Like [`countSubstrings`](#countSubstrings) but counts case-insensitively and assumes that haystack is a UTF-8 string.
    

**Syntax**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Arguments**

- `haystack` — UTF-8 string in which the search is performed. [`String`](/sql-reference/data-types/string) or [`Enum`](/sql-reference/data-types/enum)
- `needle` — Substring to be searched. [`String`](/sql-reference/data-types/string)
- `start_pos` — Optional. Position (1-based) in `haystack` at which the search starts. [`UInt*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the number of occurrences of the needle in the haystack. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**With start_pos argument**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```



## extract {#extract}

Introduced in: v1.1


Extracts the first match of a regular expression in a string.
If 'haystack' doesn't match 'pattern', an empty string is returned.

This function uses the RE2 regular expression library. Please refer to [re2](https://github.com/google/re2/wiki/Syntax) for supported syntax.

If the regular expression has capturing groups (sub-patterns), the function matches the input string against the first capturing group.
    

**Syntax**

```sql
extract(haystack, pattern)
```

**Arguments**

- `haystack` — String from which to extract. [`String`](/sql-reference/data-types/string)
- `pattern` — Regular expression, typically containing a capturing group. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns extracted fragment as a string. [`String`](/sql-reference/data-types/string)

**Examples**

**Extract domain from email**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**No match returns empty string**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```



## extractAll {#extractAll}

Introduced in: v1.1


Like [`extract`](#extract), but returns an array of all matches of a regular expression in a string.
If 'haystack' doesn't match the 'pattern' regex, an empty array is returned.

If the regular expression has capturing groups (sub-patterns), the function matches the input string against the first capturing group.
    

**Syntax**

```sql
extractAll(haystack, pattern)
```

**Arguments**

- `haystack` — String from which to extract fragments. [`String`](/sql-reference/data-types/string)
- `pattern` — Regular expression, optionally containing capturing groups. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns array of extracted fragments. [`Array(String)`](/sql-reference/data-types/array)

**Examples**

**Extract all numbers**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**Extract using capturing group**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```



## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

Introduced in: v20.5


Matches all groups of a string using the provided regular expression and returns an array of arrays, where each array contains all captures from the same capturing group, organized by group number.


**Syntax**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**Arguments**

- `s` — Input string to extract from. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — Regular expression to match by. [`const String`](/sql-reference/data-types/string) or [`const FixedString`](/sql-reference/data-types/fixedstring)


**Returned value**

Returns an array of arrays, where each inner array contains all captures from one capturing group across all matches. The first inner array contains all captures from group 1, the second from group 2, etc. If no matches are found, returns an empty array. [`Array(Array(String))`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```



## extractGroups {#extractGroups}

Introduced in: v20.5


Extracts all groups from non-overlapping substrings matched by a regular expression.
    

**Syntax**

```sql
extractAllGroups(s, regexp)
```

**Arguments**

- `s` — Input string to extract from. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — Regular expression. Constant. [`const String`](/sql-reference/data-types/string) or [`const FixedString`](/sql-reference/data-types/fixedstring)


**Returned value**

If the function finds at least one matching group, it returns Array(Array(String)) column, clustered by group_id (`1` to `N`, where `N` is number of capturing groups in regexp). If there is no matching group, it returns an empty array. [`Array(Array(String))`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['服务器','nginx'],['日期','Tue, 22 Jan 2019 00:26:14 GMT'],['内容类型','text/html; charset=UTF-8'],['连接方式','keep-alive']]
```



## hasAllTokens {#hasAllTokens}

Introduced in: v25.10


Like [`hasAnyTokens`](#hasAnyTokens), but returns 1, if all tokens in the `needle` string or array match the `input` string, and 0 otherwise. If `input` is a column, returns all rows that satisfy this condition.

:::note
Column `input` should have a [text index](../../engines/table-engines/mergetree-family/invertedindexes) defined for optimal performance.
If no text index is defined, the function performs a brute-force column scan which is orders of magnitude slower than an index lookup.
:::

Prior to searching, the function tokenizes
- the `input` argument (always), and
- the `needle` argument (if given as a [String](../../sql-reference/data-types/string.md))
using the tokenizer specified for the text index.
If the column has no text index defined, the `splitByNonAlpha` tokenizer is used instead.
If the `needle` argument is of type [Array(String)](../../sql-reference/data-types/array.md), each array element is treated as a token — no additional tokenization takes place.

Duplicate tokens are ignored.
For example, needles = ['ClickHouse', 'ClickHouse'] is treated the same as ['ClickHouse'].
    

**Syntax**

```sql
hasAllTokens(input, needles)
```

**Aliases**: `hasAllToken`

**Arguments**

- `input` — The input column. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring) or [`Array(String)`](/sql-reference/data-types/array) or [`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — Tokens to be searched. Supports at most 64 tokens. [`String`](/sql-reference/data-types/string) or [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns 1, if all needles match. 0, otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example for a string column**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Specify needles to be searched for AS-IS (no tokenization) in an array**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Generate needles using the `tokens` function**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Usage examples for array and map columns**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**Example with an array column**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Example with mapKeys**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Example with mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```



## hasAnyTokens {#hasAnyTokens}

Introduced in: v25.10


Returns 1, if at least one token in the `needle` string or array matches the `input` string, and 0 otherwise. If `input` is a column, returns all rows that satisfy this condition.

:::note
Column `input` should have a [text index](../../engines/table-engines/mergetree-family/invertedindexes) defined for optimal performance.
If no text index is defined, the function performs a brute-force column scan which is orders of magnitude slower than an index lookup.
:::

Prior to searching, the function tokenizes
- the `input` argument (always), and
- the `needle` argument (if given as a [String](../../sql-reference/data-types/string.md))
using the tokenizer specified for the text index.
If the column has no text index defined, the `splitByNonAlpha` tokenizer is used instead.
If the `needle` argument is of type [Array(String)](../../sql-reference/data-types/array.md), each array element is treated as a token — no additional tokenization takes place.

Duplicate tokens are ignored.
For example, ['ClickHouse', 'ClickHouse'] is treated the same as ['ClickHouse'].
    

**Syntax**

```sql
hasAnyTokens(input, needles)
```

**Aliases**: `hasAnyToken`

**Arguments**

- `input` — The input column. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring) or [`Array(String)`](/sql-reference/data-types/array) or [`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — Tokens to be searched. Supports at most 64 tokens. [`String`](/sql-reference/data-types/string) or [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns `1`, if there was at least one match. `0`, otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example for a string column**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Specify needles to be searched for AS-IS (no tokenization) in an array**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Generate needles using the `tokens` function**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Usage examples for array and map columns**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**Example with an array column**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Example with mapKeys**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**Example with mapValues**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```



## hasSubsequence {#hasSubsequence}

Introduced in: v23.7


Checks if a needle is a subsequence of a haystack.
A subsequence of a string is a sequence that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.
    

**Syntax**

```sql
hasSubsequence(haystack, needle)
```

**Arguments**

- `haystack` — String in which to search for the subsequence. [`String`](/sql-reference/data-types/string)
- `needle` — Subsequence to be searched. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if needle is a subsequence of haystack, `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Basic subsequence check**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**No subsequence found**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```



## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

Introduced in: v23.7

Like [`hasSubsequence`](#hasSubsequence) but searches case-insensitively.

**Syntax**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — Subsequence to be searched. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns 1, if needle is a subsequence of haystack, 0 otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```



## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

Introduced in: v23.7

Like [`hasSubsequenceUTF8`](#hasSubsequenceUTF8) but searches case-insensitively.

**Syntax**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**Arguments**

- `haystack` — UTF8-encoded string in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — UTF8-encoded subsequence string to be searched. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns 1, if needle is a subsequence of haystack, 0 otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```



## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

Introduced in: v23.7


Like [`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence) but assumes haystack and needle are UTF-8 encoded strings.
    

**Syntax**

```sql
hasSubsequenceUTF8(主串, 子串)
```

**Arguments**

- `haystack` — The string in which to search. [`String`](/sql-reference/data-types/string)
- `needle` — The subsequence to search for. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if `needle` is a subsequence of `haystack`, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**Non-matching subsequence**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```



## hasToken {#hasToken}

Introduced in: v20.1


Checks if the given token is present in the haystack.

A token is defined as the longest possible sub-sequence of consecutive characters `[0-9A-Za-z_]`, i.e. numbers, ASCII letters and underscore.
    

**Syntax**

```sql
hasToken(haystack, token)
```

**Arguments**

- `haystack` — String to be searched. [`String`](/sql-reference/data-types/string)
- `token` — Token to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the token is found, `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Token search**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```



## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

Introduced in: v

Performs case insensitive lookup of needle in haystack using tokenbf_v1 index.

**Syntax**

```sql
```

**Arguments**

- None.

**Returned value**



**Examples**



## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

Introduced in: v

Performs case insensitive lookup of needle in haystack using tokenbf_v1 index. Returns null if needle is ill-formed.

**Syntax**

```sql
```

**Arguments**

- None.

**Returned value**



**Examples**



## hasTokenOrNull {#hasTokenOrNull}

Introduced in: v20.1


Like [`hasToken`](#hasToken) but returns null if token is ill-formed.
    

**Syntax**

```sql
hasTokenOrNull(haystack, token)
```

**Arguments**

- `haystack` — String to be searched. Must be constant. [`String`](/sql-reference/data-types/string)
- `token` — Token to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the token is found, `0` otherwise, null if token is ill-formed. [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**Examples**

**Usage example**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```



## ilike {#ilike}

Introduced in: v20.6

Like [`like`](#like) but searches case-insensitively.

**Syntax**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — LIKE pattern to match against. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the string matches the LIKE pattern (case-insensitive), otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```



## like {#like}

Introduced in: v1.1


Returns whether string `haystack` matches the `LIKE` expression `pattern`.

A `LIKE` expression can contain normal characters and the following metasymbols:

- `%` indicates an arbitrary number of arbitrary characters (including zero characters).
- `_` indicates a single arbitrary character.
- `\` is for escaping literals `%`, `_` and `\`.

Matching is based on UTF-8, e.g. `_` matches the Unicode code point `¥` which is represented in UTF-8 using two bytes.

If the haystack or the `LIKE` expression are not valid UTF-8, the behavior is undefined.

No automatic Unicode normalization is performed, you can use the `normalizeUTF8*` functions for that.

To match against literal `%`, `_` and `\` (which are `LIKE` metacharacters), prepend them with a backslash: `\%`, `\_` and `\\`.
The backslash loses its special meaning (i.e. is interpreted literally) if it prepends a character different than `%`, `_` or `\`.

:::note
ClickHouse requires backslashes in strings [to be quoted as well](../syntax.md#string), so you would actually need to write `\\%`, `\\_` and `\\\\`.
:::

For `LIKE` expressions of the form `%needle%`, the function is as fast as the `position` function.
All other LIKE expressions are internally converted to a regular expression and executed with a performance similar to function `match`.
   

**Syntax**

```sql
like(haystack, pattern)
-- haystack LIKE 模式字符串
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — `LIKE` pattern to match against. Can contain `%` (matches any number of characters), `_` (matches single character), and `\` for escaping. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the string matches the `LIKE` pattern, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**Single character wildcard**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**Non-matching pattern**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```



## locate {#locate}

Introduced in: v18.16


Like [`position`](#position) but with arguments `haystack` and `locate` switched.

:::note Version dependent behavior
The behavior of this function depends on the ClickHouse version:
- in versions < v24.3, `locate` was an alias of function `position` and accepted arguments `(haystack, needle[, start_pos])`.
- in versions >= 24.3, `locate` is an individual function (for better compatibility with MySQL) and accepts arguments `(needle, haystack[, start_pos])`.
The previous behavior can be restored using setting `function_locate_has_mysql_compatible_argument_order = false`.
:::
    

**Syntax**

```sql
locate(needle, haystack[, start_pos])
```

**Arguments**

- `needle` — Substring to be searched. [`String`](/sql-reference/data-types/string)
- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`Enum`](/sql-reference/data-types/enum)
- `start_pos` — Optional. Position (1-based) in `haystack` at which the search starts. [`UInt`](/sql-reference/data-types/int-uint)


**Returned value**

Returns starting position in bytes and counting from 1, if the substring was found, `0`, if the substring was not found. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Basic usage**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```



## match {#match}

Introduced in: v1.1


Checks if a provided string matches the provided regular expression pattern.

This function uses the RE2 regular expression library. Please refer to [re2](https://github.com/google/re2/wiki/Syntax) for supported syntax.

Matching works under UTF-8 assumptions, e.g. `¥` uses two bytes internally but matching treats it as a single codepoint.
The regular expression must not contain NULL bytes.
If the haystack or the pattern are not valid UTF-8, the behavior is undefined.

Unlike re2's default behavior, `.` matches line breaks. To disable this, prepend the pattern with `(?-s)`.

The pattern is automatically anchored at both ends (as if the pattern started with '^' and ended with '$').

If you only like to find substrings, you can use functions [`like`](#like) or [`position`](#position) instead - they work much faster than this function.

Alternative operator syntax: `haystack REGEXP pattern`.
    

**Syntax**

```sql
match(haystack, pattern)
```

**Aliases**: `REGEXP_MATCHES`

**Arguments**

- `haystack` — String in which the pattern is searched. [`String`](/sql-reference/data-types/string)
- `pattern` — Regular expression pattern. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the pattern matches, `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Basic pattern matching**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**Pattern not matching**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```



## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

Introduced in: v20.1

Like [`multiFuzzyMatchAny`](#multiFuzzyMatchAny) but returns the array of all indices in any order that match the haystack within a constant [edit distance](https://en.wikipedia.org/wiki/Edit_distance).

**Syntax**

```sql
multiFuzzyMatchAllIndices(干草堆, 距离, [模式1, 模式2, ..., 模式N])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `distance` — The maximum edit distance for fuzzy matching. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — Array of patterns to match against. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns an array of all indices (starting from 1) that match the haystack within the specified edit distance in any order. Returns an empty array if no matches are found. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```



## multiFuzzyMatchAny {#multiFuzzyMatchAny}

Introduced in: v20.1


Like [`multiMatchAny`](#multiMatchAny) but returns 1 if any pattern matches the haystack within a constant [edit distance](https://en.wikipedia.org/wiki/Edit_distance).
This function relies on the experimental feature of [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) library, and can be slow for some edge cases.
The performance depends on the edit distance value and patterns used, but it's always more expensive compared to non-fuzzy variants.

:::note
`multiFuzzyMatch*()` function family do not support UTF-8 regular expressions (it treats them as a sequence of bytes) due to restrictions of hyperscan.
:::
    

**Syntax**

```sql
multiFuzzyMatchAny(草堆, 距离, [模式1, 模式2, ..., 模式N])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `distance` — The maximum edit distance for fuzzy matching. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — Optional. An array of patterns to match against. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns `1` if any pattern matches the haystack within the specified edit distance, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```



## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

Introduced in: v20.1

Like [`multiFuzzyMatchAny`](#multiFuzzyMatchAny) but returns any index that matches the haystack within a constant [edit distance](https://en.wikipedia.org/wiki/Edit_distance).

**Syntax**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `distance` — The maximum edit distance for fuzzy matching. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — Array of patterns to match against. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the index (starting from 1) of any pattern that matches the haystack within the specified edit distance, otherwise `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```



## multiMatchAllIndices {#multiMatchAllIndices}

Introduced in: v20.1

Like [`multiMatchAny`](#multiMatchAny) but returns the array of all indices that match the haystack in any order.

**Syntax**

```sql
multiMatchAllIndices(干草堆, [模式1, 模式2, ..., 模式n])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `pattern` — Regular expressions to match against. [`String`](/sql-reference/data-types/string)


**Returned value**

Array of all indices (starting from 1) that match the haystack in any order. Returns an empty array if no matches are found. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```



## multiMatchAny {#multiMatchAny}

Introduced in: v20.1


Check if at least one of multiple regular expression patterns matches a haystack.

If you only want to search multiple substrings in a string, you can use function [`multiSearchAny`](#multiSearchAny) instead - it works much faster than this function.
    

**Syntax**

```sql
multiMatchAny(干草堆, 模式1[, 模式2, ...])
```

**Arguments**

- `haystack` — String in which patterns are searched. [`String`](/sql-reference/data-types/string)
- `pattern1[, pattern2, ...]` — An array of one or more regular expression patterns. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns `1` if any pattern matches, `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Multiple pattern matching**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**No patterns match**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```



## multiMatchAnyIndex {#multiMatchAnyIndex}

Introduced in: v20.1

Like [`multiMatchAny`](#multiMatchAny) but returns any index that matches the haystack.

**Syntax**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `pattern` — Regular expressions to match against. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the index (starting from 1) of the first pattern that matches, or 0 if no match is found. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```



## multiSearchAllPositions {#multiSearchAllPositions}

Introduced in: v20.1


Like [`position`](#position) but returns an array of positions (in bytes, starting at 1) for multiple `needle` substrings in a `haystack` string.

All `multiSearch*()` functions only support up to 2^8 needles.
    

**Syntax**

```sql
multiSearchAllPositions(主串, 针1[, 针2, ...])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — An array of one or more substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns array of the starting position in bytes and counting from 1, if the substring was found, `0`, if the substring was not found. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Multiple needle search**

```sql title=Query
SELECT multiSearchAllPositions('你好，世界！', ['你好', '！', '世界'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```



## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

Introduced in: v20.1


Like [`multiSearchAllPositions`](#multiSearchAllPositions) but ignores case.
    

**Syntax**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — An array of one or more substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns array of the starting position in bytes and counting from 1 (if the substring was found), `0` if the substring was not found. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Case insensitive multi-search**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```



## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

Introduced in: v20.1

Like [`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8) but ignores case.

**Syntax**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(主串, [子串1, 子串2, ..., 子串N])
```

**Arguments**

- `haystack` — UTF-8 encoded string in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — UTF-8 encoded substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Array of the starting position in bytes and counting from 1 (if the substring was found). Returns 0 if the substring was not found. [`Array`](/sql-reference/data-types/array)

**Examples**

**Case-insensitive UTF-8 search**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```



## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

Introduced in: v20.1


Like [`multiSearchAllPositions`](#multiSearchAllPositions) but assumes `haystack` and the `needle` substrings are UTF-8 encoded strings.
    

**Syntax**

```sql
multiSearchAllPositionsUTF8(主串, 模式1[, 模式2, ...])
```

**Arguments**

- `haystack` — UTF-8 encoded string in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — An array of UTF-8 encoded substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns array of the starting position in bytes and counting from 1 (if the substring was found), `0` if the substring was not found. [`Array`](/sql-reference/data-types/array)

**Examples**

**UTF-8 multi-search**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```



## multiSearchAny {#multiSearchAny}

Introduced in: v20.1


Checks if at least one of a number of needle strings matches the haystack string.

Functions [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive), [`multiSearchAnyUTF8`](#multiSearchAnyUTF8) and [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) provide case-insensitive and/or UTF-8 variants of this function.
    

**Syntax**

```sql
multiSearchAny(干草堆, needle1[, needle2, ...])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — An array of substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns `1`, if there was at least one match, otherwise `0`, if there was not at least one match. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Any match search**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```



## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

Introduced in: v20.1


Like [multiSearchAny](#multiSearchAny) but ignores case.
    

**Syntax**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — Substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns `1`, if there was at least one case-insensitive match, otherwise `0`, if there was not at least one case-insensitive match. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive search**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```



## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

Introduced in: v20.1


Like [multiSearchAnyUTF8](#multiSearchAnyUTF8) but ignores case.
    

**Syntax**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — UTF-8 string in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — UTF-8 substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns `1`, if there was at least one case-insensitive match, otherwise `0`, if there was not at least one case-insensitive match. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Given a UTF-8 string 'Здравствуйте', check if character 'з' (lowercase) is present**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```



## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

Introduced in: v20.1


Like [multiSearchAny](#multiSearchAny) but assumes `haystack` and the `needle` substrings are UTF-8 encoded strings.
    

**Syntax**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — UTF-8 string in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — UTF-8 substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns `1`, if there was at least one match, otherwise `0`, if there was not at least one match. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Given '你好，世界' ('Hello, world') as a UTF-8 string, check if there are any 你 or 界 characters in the string**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```



## multiSearchFirstIndex {#multiSearchFirstIndex}

Introduced in: v20.1

Searches for multiple needle strings in a haystack string (case-sensitive) and returns the 1-based index of the first needle found.

**Syntax**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — The string to search in. [`String`](/sql-reference/data-types/string)
- `needles` — Array of strings to search for. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the 1-based index (position in the needles array) of the first needle found in the haystack. Returns 0 if no needles are found. The search is case-sensitive. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**Case-sensitive behavior**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**No match found**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```



## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

Introduced in: v20.1


Returns the index `i` (starting from 1) of the leftmost found needle_i in the string `haystack` and 0 otherwise.
Ignores case.
    

**Syntax**

```sql
multiSearchFirstIndexCaseInsensitive(主串, [子串1, 子串2, ..., 子串N]
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — Substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the index (starting from 1) of the leftmost found needle. Otherwise `0`, if there was no match. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```



## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

Introduced in: v20.1

Searches for multiple needle strings in a haystack string, case-insensitively with UTF-8 encoding support, and returns the 1-based index of the first needle found.

**Syntax**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — The string to search in. [`String`](/sql-reference/data-types/string)
- `needles` — Array of strings to search for. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the 1-based index (position in the needles array) of the first needle found in the haystack. Returns 0 if no needles are found. The search is case-insensitive and respects UTF-8 character encoding. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8 case handling**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**No match found**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```



## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

Introduced in: v20.1


Returns the index `i` (starting from 1) of the leftmost found needle_i in the string `haystack` and 0 otherwise.
Assumes `haystack` and `needle` are UTF-8 encoded strings.
    

**Syntax**

```sql
multiSearchFirstIndexUTF8(主串, [子串1, 子串2, ..., 子串N])
```

**Arguments**

- `haystack` — UTF-8 string in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — Array of UTF-8 substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the index (starting from 1) of the leftmost found needle. Otherwise 0, if there was no match. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```



## multiSearchFirstPosition {#multiSearchFirstPosition}

Introduced in: v20.1


Like [`position`](#position) but returns the leftmost offset in a `haystack` string which matches any of multiple `needle` strings.

Functions [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive), [`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8) and [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) provide case-insensitive and/or UTF-8 variants of this function.
    

**Syntax**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — An array of one or more substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the leftmost offset in a `haystack` string which matches any of multiple `needle` strings, otherwise `0`, if there was no match. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**First position search**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```



## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

Introduced in: v20.1


Like [multiSearchFirstPosition](#multiSearchFirstPosition) but ignores case.
    

**Syntax**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — Array of substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the leftmost offset in a `haystack` string which matches any of multiple `needle` strings. Returns `0`, if there was no match. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive first position**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```



## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

Introduced in: v20.1


Like [multiSearchFirstPosition](#multiSearchFirstPosition) but assumes `haystack` and `needle` to be UTF-8 strings and ignores case.
    

**Syntax**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — UTF-8 string in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — Array of UTF-8 substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Returns the leftmost offset in a `haystack` string which matches any of multiple `needle` strings, ignoring case. Returns `0`, if there was no match. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Find the leftmost offset in UTF-8 string 'Здравствуй, мир' ('Hello, world') which matches any of the given needles**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```



## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

Introduced in: v20.1


Like [multiSearchFirstPosition](#multiSearchFirstPosition) but assumes `haystack` and `needle` to be UTF-8 strings.
    

**Syntax**

```sql
multiSearchFirstPositionUTF8(大串, [模式1, 模式2, ..., 模式N])
```

**Arguments**

- `haystack` — UTF-8 string in which the search is performed. [`String`](/sql-reference/data-types/string)
- `needle` — Array of UTF-8 substrings to be searched. [`Array(String)`](/sql-reference/data-types/array)


**Returned value**

Leftmost offset in a `haystack` string which matches any of multiple `needle` strings. Returns `0`, if there was no match. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Find the leftmost offset in UTF-8 string 'Здравствуй, мир' ('Hello, world') which matches any of the given needles**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```



## ngramDistance {#ngramDistance}

Introduced in: v20.1


Calculates the 4-gram distance between two strings.
For this, it counts the symmetric difference between two multisets of 4-grams and normalizes it by the sum of their cardinalities.
The smaller the returned value, the more similar the strings are.

For case-insensitive search or/and in UTF8 format use functions [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive), [`ngramDistanceUTF8`](#ngramDistanceUTF8), [`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8).
    

**Syntax**

```sql
ngramDistance(大海, 针)
```

**Arguments**

- `haystack` — String for comparison. [`String`](/sql-reference/data-types/string)
- `needle` — String for comparison. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns a Float32 number between `0` and `1`. The smaller the returned value, the more similar the strings are. [`Float32`](/sql-reference/data-types/float)

**Examples**

**Calculate 4-gram distance**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```



## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

Introduced in: v20.1


Provides a case-insensitive variant of [`ngramDistance`](#ngramDistance).
Calculates the 4-gram distance between two strings, ignoring case.
The smaller the returned value, the more similar the strings are.
    

**Syntax**

```sql
ngramDistanceCaseInsensitive(大海, 针)
```

**Arguments**

- `haystack` — First comparison string. [`String`](/sql-reference/data-types/string)
- `needle` — Second comparison string. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns a Float32 number between `0` and `1`. [`Float32`](/sql-reference/data-types/float)

**Examples**

**Case-insensitive 4-gram distance**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```



## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

Introduced in: v20.1


Provides a case-insensitive UTF-8 variant of [`ngramDistance`](#ngramDistance).
Assumes that `needle` and `haystack` strings are UTF-8 encoded strings and ignores case.
Calculates the 3-gram distance between two UTF-8 strings, ignoring case.
The smaller the returned value, the more similar the strings are.
    

**Syntax**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**Arguments**

- `haystack` — First UTF-8 encoded comparison string. [`String`](/sql-reference/data-types/string)
- `needle` — Second UTF-8 encoded comparison string. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns a Float32 number between `0` and `1`. [`Float32`](/sql-reference/data-types/float)

**Examples**

**Case-insensitive UTF-8 3-gram distance**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```



## ngramDistanceUTF8 {#ngramDistanceUTF8}

Introduced in: v20.1


Provides a UTF-8 variant of [`ngramDistance`](#ngramDistance).
Assumes that `needle` and `haystack` strings are UTF-8 encoded strings.
Calculates the 3-gram distance between two UTF-8 strings.
The smaller the returned value, the more similar the strings are.
    

**Syntax**

```sql
ngramDistanceUTF8(haystack, needle)
```

**Arguments**

- `haystack` — First UTF-8 encoded comparison string. [`String`](/sql-reference/data-types/string)
- `needle` — Second UTF-8 encoded comparison string. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns a Float32 number between `0` and `1`. [`Float32`](/sql-reference/data-types/float)

**Examples**

**UTF-8 3-gram distance**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```



## ngramSearch {#ngramSearch}

Introduced in: v20.1


Checks if the 4-gram distance between two strings is less than or equal to a given threshold.

For case-insensitive search or/and in UTF8 format use functions `ngramSearchCaseInsensitive`, `ngramSearchUTF8`, `ngramSearchCaseInsensitiveUTF8`.
    

**Syntax**

```sql
ngramSearch(干草堆, 针)
```

**Arguments**

- `haystack` — String for comparison. [`String`](/sql-reference/data-types/string)
- `needle` — String for comparison. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the 4-gram distance between the strings is less than or equal to a threshold (`1.0` by default), `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Search using 4-grams**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```



## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

Introduced in: v20.1


Provides a case-insensitive variant of [`ngramSearch`](#ngramSearch).
Calculates the non-symmetric difference between a needle string and a haystack string, i.e. the number of n-grams from the needle minus the common number of n-grams normalized by the number of needle n-grams.
Checks if the 4-gram distance between two strings is less than or equal to a given threshold, ignoring case.
    

**Syntax**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**Arguments**

- `haystack` — String for comparison. [`String`](/sql-reference/data-types/string)
- `needle` — String for comparison. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the 4-gram distance between the strings is less than or equal to a threshold (`1.0` by default), `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Case-insensitive search using 4-grams**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```



## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

Introduced in: v20.1


Provides a case-insensitive UTF-8 variant of [`ngramSearch`](#ngramSearch).
Assumes `haystack` and `needle` to be UTF-8 strings and ignores case.
Checks if the 3-gram distance between two UTF-8 strings is less than or equal to a given threshold, ignoring case.
    

**Syntax**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**Arguments**

- `haystack` — UTF-8 string for comparison. [`String`](/sql-reference/data-types/string)
- `needle` — UTF-8 string for comparison. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the 3-gram distance between the strings is less than or equal to a threshold (`1.0` by default), `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Case-insensitive UTF-8 search using 3-grams**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```



## ngramSearchUTF8 {#ngramSearchUTF8}

Introduced in: v20.1


Provides a UTF-8 variant of `ngramSearch`.
Assumes `haystack` and `needle` to be UTF-8 strings.
Checks if the 3-gram distance between two UTF-8 strings is less than or equal to a given threshold.
    

**Syntax**

```sql
ngramSearchUTF8(haystack, needle)
```

**Arguments**

- `haystack` — UTF-8 string for comparison. [`String`](/sql-reference/data-types/string)
- `needle` — UTF-8 string for comparison. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the 3-gram distance between the strings is less than or equal to a threshold (`1.0` by default), `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**UTF-8 search using 3-grams**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```



## notILike {#notILike}

Introduced in: v20.6

Checks whether a string does not match a pattern, case-insensitive. The pattern can contain special characters `%` and `_` for SQL LIKE matching.

**Syntax**

```sql
notILike(大串, 模式)
```

**Arguments**

- `haystack` — The input string to search in. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — The SQL LIKE pattern to match against. `%` matches any number of characters (including zero), `_` matches exactly one character. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the string does not match the pattern (case-insensitive), otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```



## notLike {#notLike}

Introduced in: v1.1

Similar to [`like`](#like) but negates the result.

**Syntax**

```sql
notLike(haystack, pattern)
-- haystack 不匹配 LIKE 模式 pattern
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — LIKE pattern to match against. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the string does not match the `LIKE` pattern, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**Non-matching pattern**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```



## position {#position}

Introduced in: v1.1


Returns the position (in bytes, starting at 1) of a substring `needle` in a string `haystack`.

If substring `needle` is empty, these rules apply:
- if no `start_pos` was specified: return `1`
- if `start_pos = 0`: return `1`
- if `start_pos >= 1` and `start_pos <= length(haystack) + 1`: return `start_pos`
- otherwise: return `0`

The same rules also apply to functions [`locate`](#locate), [`positionCaseInsensitive`](#positionCaseInsensitive), [`positionUTF8`](#positionUTF8) and [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8).
    

**Syntax**

```sql
position(haystack, needle[, start_pos])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`Enum`](/sql-reference/data-types/enum)
- `needle` — Substring to be searched. [`String`](/sql-reference/data-types/string)
- `start_pos` — Position (1-based) in `haystack` at which the search starts. Optional. [`UInt`](/sql-reference/data-types/int-uint)


**Returned value**

Returns starting position in bytes and counting from 1, if the substring was found, otherwise `0`, if the substring was not found. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Basic usage**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**With start_pos argument**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Needle IN haystack syntax**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**Empty needle substring**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```



## positionCaseInsensitive {#positionCaseInsensitive}

Introduced in: v1.1


Like [`position`](#position) but case-insensitive.
    

**Syntax**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**Aliases**: `instr`

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`Enum`](/sql-reference/data-types/enum)
- `needle` — Substring to be searched. [`String`](/sql-reference/data-types/string)
- `start_pos` — Optional. Position (1-based) in `haystack` at which the search starts. [`UInt*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns starting position in bytes and counting from 1, if the substring was found, otherwise `0`, if the substring was not found. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive search**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```



## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

Introduced in: v1.1


Like [`positionUTF8`](#positionUTF8) but searches case-insensitively.
    

**Syntax**

```sql
positionCaseInsensitiveUTF8(主串, 子串[, 起始位置])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`Enum`](/sql-reference/data-types/enum)
- `needle` — Substring to be searched. [`String`](/sql-reference/data-types/string)
- `start_pos` — Optional. Position (1-based) in `haystack` at which the search starts. [`UInt*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns starting position in bytes and counting from 1, if the substring was found, otherwise `0`, if the substring was not found. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive UTF-8 search**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```



## positionUTF8 {#positionUTF8}

Introduced in: v1.1


Like [`position`](#position) but assumes `haystack` and `needle` are UTF-8 encoded strings.
    

**Syntax**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**Arguments**

- `haystack` — String in which the search is performed. [`String`](/sql-reference/data-types/string) or [`Enum`](/sql-reference/data-types/enum)
- `needle` — Substring to be searched. [`String`](/sql-reference/data-types/string)
- `start_pos` — Optional. Position (1-based) in `haystack` at which the search starts. [`UInt*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns starting position in bytes and counting from 1, if the substring was found, otherwise `0`, if the substring was not found. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**UTF-8 character counting**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

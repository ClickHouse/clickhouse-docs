---
description: '字符串搜索函数文档'
sidebar_label: '字符串搜索'
slug: /sql-reference/functions/string-search-functions
title: '字符串搜索函数'
doc_type: 'reference'
---



# 字符串搜索函数

本节中的所有函数默认执行区分大小写的搜索。不区分大小写的搜索通常由单独的函数变体提供。

:::note
不区分大小写的搜索遵循英语的大小写转换规则。例如,英语中 `i` 的大写形式是 `I`,而在土耳其语中是 `İ` - 对于英语以外的语言,搜索结果可能不符合预期。
:::

本节中的函数还假定被搜索的字符串(在本节中称为 `haystack`)和搜索字符串(在本节中称为 `needle`)均为单字节编码文本。如果违反此假设,不会抛出异常,但结果是未定义的。对 UTF-8 编码字符串的搜索通常由单独的函数变体提供。同样,如果使用 UTF-8 函数变体但输入字符串不是 UTF-8 编码文本,不会抛出异常,但结果是未定义的。请注意,系统不会自动执行 Unicode 规范化,但您可以使用 [normalizeUTF8\*()](https://clickhouse.com../functions/string-functions/) 函数来实现此功能。

[通用字符串函数](string-functions.md)和[字符串替换函数](string-replace-functions.md)将单独介绍。

:::note
以下文档是从 `system.functions` 系统表自动生成的。
:::

<!--
以下标签内的内容在文档框架构建时会被替换为从 system.functions 生成的文档。请勿修改或删除这些标签。
参见:https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## countMatches {#countMatches}

Introduced in: v21.1

返回字符串中正则表达式的匹配次数。

:::note 版本相关行为
此函数的行为取决于 ClickHouse 版本:

- 在版本 < v25.6 中,即使模式匹配成功,函数也会在第一个空匹配处停止计数。
- 在版本 >= 25.6 中,当出现空匹配时函数会继续执行。可以通过设置 `count_matches_stop_at_empty_match = true` 来恢复旧版行为;
  :::

**语法**

```sql
countMatches(haystack, pattern)
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `pattern` — 正则表达式模式。[`String`](/sql-reference/data-types/string)

**返回值**

返回找到的匹配次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**统计数字序列**

```sql title=查询
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=响应
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```


## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

引入版本:v21.1

类似于 [`countMatches`](#countMatches),但执行不区分大小写的匹配。

**语法**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `pattern` — 正则表达式模式。[`const String`](/sql-reference/data-types/string)

**返回值**

返回找到的匹配项数量。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的计数**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```


## countSubstrings {#countSubstrings}

引入版本:v21.1

返回子字符串 `needle` 在字符串 `haystack` 中出现的次数。

**语法**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**参数**

- `haystack` — 要搜索的字符串。[String](../../sql-reference/data-types/string.md) 或 [Enum](../../sql-reference/data-types/enum.md)。- `needle` — 要查找的子字符串。[String](../../sql-reference/data-types/string.md)。- `start_pos` — 在 `haystack` 中开始搜索的位置(从 1 开始计数)。[UInt](../../sql-reference/data-types/int-uint.md)。可选。

**返回值**

出现次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**使用 start_pos 参数**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```


## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

引入版本:v21.1

类似于 [`countSubstrings`](#countSubstrings),但不区分大小写进行计数。

**语法**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 要查找的子字符串。[`String`](/sql-reference/data-types/string)
- `start_pos` — 可选参数。在 `haystack` 中开始搜索的位置(从 1 开始)。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回 needle 在 haystack 中出现的次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=响应
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**使用 start_pos 参数**

```sql title=查询
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=响应
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```


## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

引入版本：v21.1

类似于 [`countSubstrings`](#countSubstrings)，但不区分大小写进行计数，并假定 haystack 为 UTF-8 字符串。

**语法**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**参数**

- `haystack` — 执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
- `start_pos` — 可选参数。`haystack` 中开始搜索的位置（从 1 开始计数）。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回 needle 在 haystack 中出现的次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=响应
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**使用 start_pos 参数**

```sql title=查询
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=响应
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```


## extract {#extract}

引入版本：v1.1

从字符串中提取正则表达式的首次匹配结果。
如果 'haystack' 不匹配 'pattern'，则返回空字符串。

此函数使用 RE2 正则表达式库。支持的语法请参阅 [re2](https://github.com/google/re2/wiki/Syntax)。

如果正则表达式包含捕获组（子模式），该函数将针对第一个捕获组匹配输入字符串。

**语法**

```sql
extract(haystack, pattern)
```

**参数**

- `haystack` — 待提取的字符串。[`String`](/sql-reference/data-types/string)
- `pattern` — 正则表达式，通常包含捕获组。[`const String`](/sql-reference/data-types/string)

**返回值**

以字符串形式返回提取的片段。[`String`](/sql-reference/data-types/string)

**示例**

**从电子邮件中提取域名**

```sql title=查询
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=响应
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**无匹配项时返回空字符串**

```sql title=查询
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=响应
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```


## extractAll {#extractAll}

引入版本:v1.1

类似于 [`extract`](#extract),但返回字符串中正则表达式的所有匹配项组成的数组。
如果 'haystack' 不匹配 'pattern' 正则表达式,则返回空数组。

如果正则表达式包含捕获组(子模式),该函数将针对第一个捕获组匹配输入字符串。

**语法**

```sql
extractAll(haystack, pattern)
```

**参数**

- `haystack` — 要从中提取片段的字符串。[`String`](/sql-reference/data-types/string)
- `pattern` — 正则表达式,可选择性地包含捕获组。[`const String`](/sql-reference/data-types/string)

**返回值**

返回提取片段组成的数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**提取所有数字**

```sql title=查询
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=响应
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**使用捕获组提取**

```sql title=查询
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=响应
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```


## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

引入版本:v20.5

使用提供的正则表达式匹配字符串中的所有分组,返回一个二维数组,其中每个数组包含同一捕获组在所有匹配中的捕获内容,按组编号组织。

**语法**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**参数**

- `s` — 待提取的输入字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — 用于匹配的正则表达式。[`const String`](/sql-reference/data-types/string) 或 [`const FixedString`](/sql-reference/data-types/fixedstring)

**返回值**

返回一个二维数组,其中每个内部数组包含一个捕获组在所有匹配中的所有捕获内容。第一个内部数组包含组 1 的所有捕获内容,第二个包含组 2 的内容,依此类推。如果未找到匹配项,则返回空数组。[`Array(Array(String))`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```


## extractGroups {#extractGroups}

引入版本：v20.5

从正则表达式匹配的非重叠子字符串中提取所有捕获组。

**语法**

```sql
extractAllGroups(s, regexp)
```

**参数**

- `s` — 待提取的输入字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — 正则表达式。常量。[`const String`](/sql-reference/data-types/string) 或 [`const FixedString`](/sql-reference/data-types/fixedstring)

**返回值**

如果函数找到至少一个匹配的捕获组,则返回 Array(Array(String)) 列,按 group_id 分组(`1` 到 `N`,其中 `N` 是正则表达式中捕获组的数量)。如果没有匹配的捕获组,则返回空数组。[`Array(Array(String))`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```


## hasAllTokens {#hasAllTokens}

引入版本：v25.10

类似于 [`hasAnyTokens`](#hasAnyTokens)，但如果 `needle` 字符串或数组中的所有标记都与 `input` 字符串匹配，则返回 1，否则返回 0。如果 `input` 是列，则返回满足此条件的所有行。

:::note
为获得最佳性能，列 `input` 应定义[文本索引](../../engines/table-engines/mergetree-family/invertedindexes)。
如果未定义文本索引，该函数将执行全列扫描，其速度比索引查找慢几个数量级。
:::

在搜索之前，该函数会对以下内容进行标记化：

- `input` 参数（始终进行），以及
- `needle` 参数（如果作为 [String](../../sql-reference/data-types/string.md) 类型给出）
  使用为文本索引指定的标记器。
  如果列未定义文本索引，则使用 `splitByNonAlpha` 标记器。
  如果 `needle` 参数的类型为 [Array(String)](../../sql-reference/data-types/array.md)，则每个数组元素都被视为一个标记——不会进行额外的标记化。

重复的标记会被忽略。
例如，needles = ['ClickHouse', 'ClickHouse'] 与 ['ClickHouse'] 的处理方式相同。

**语法**

```sql
hasAllTokens(input, needles)
```

**别名**：`hasAllToken`

**参数**

- `input` — 输入列。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring) 或 [`Array(String)`](/sql-reference/data-types/array) 或 [`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — 要搜索的标记。最多支持 64 个标记。[`String`](/sql-reference/data-types/string) 或 [`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果所有 needles 都匹配，则返回 1。否则返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**字符串列的使用示例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**在数组中指定要按原样搜索的 needles（不进行标记化）**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**使用 `tokens` 函数生成 needles**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**数组和映射列的使用示例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response

```

**数组列示例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys 示例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```


```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapValues 示例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```


## hasAnyTokens {#hasAnyTokens}

引入版本：v25.10

如果 `needle` 字符串或数组中至少有一个词元与 `input` 字符串匹配，则返回 1，否则返回 0。如果 `input` 是列，则返回满足此条件的所有行。

:::note
为获得最佳性能，列 `input` 应定义[文本索引](../../engines/table-engines/mergetree-family/invertedindexes)。
如果未定义文本索引，该函数将执行全列扫描，其速度比索引查找慢几个数量级。
:::

在搜索之前，该函数会对以下内容进行分词：

- `input` 参数（始终分词），以及
- `needle` 参数（如果作为 [String](../../sql-reference/data-types/string.md) 类型给出）
  使用为文本索引指定的分词器。
  如果列未定义文本索引，则使用 `splitByNonAlpha` 分词器。
  如果 `needle` 参数的类型为 [Array(String)](../../sql-reference/data-types/array.md)，则每个数组元素都被视为一个词元——不会进行额外的分词。

重复的词元会被忽略。
例如，['ClickHouse', 'ClickHouse'] 与 ['ClickHouse'] 的处理方式相同。

**语法**

```sql
hasAnyTokens(input, needles)
```

**别名**：`hasAnyToken`

**参数**

- `input` — 输入列。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring) 或 [`Array(String)`](/sql-reference/data-types/array) 或 [`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — 要搜索的词元。最多支持 64 个词元。[`String`](/sql-reference/data-types/string) 或 [`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少有一个匹配，则返回 `1`。否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**字符串列的使用示例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**在数组中按原样指定要搜索的词元（不进行分词）**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**使用 `tokens` 函数生成词元**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**数组和映射列的使用示例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response

```

**数组列示例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys 示例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```


```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**mapValues 示例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```


## hasSubsequence {#hasSubsequence}

引入版本:v23.7

检查 needle 是否为 haystack 的子序列。
字符串的子序列是指从另一个字符串中删除部分或不删除任何字符(但保持剩余字符的顺序不变)后得到的序列。

**语法**

```sql
hasSubsequence(haystack, needle)
```

**参数**

- `haystack` — 要在其中搜索子序列的字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的子序列。[`String`](/sql-reference/data-types/string)

**返回值**

如果 needle 是 haystack 的子序列则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本子序列检查**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**未找到子序列**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```


## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

引入版本:v23.7

类似于 [`hasSubsequence`](#hasSubsequence),但不区分大小写进行搜索。

**语法**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**参数**

- `haystack` — 在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的子序列。[`String`](/sql-reference/data-types/string)

**返回值**

如果 needle 是 haystack 的子序列则返回 1,否则返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```


## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

引入版本:v23.7

类似于 [`hasSubsequenceUTF8`](#hasSubsequenceUTF8),但不区分大小写进行搜索。

**语法**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**参数**

- `haystack` — 在其中执行搜索的 UTF8 编码字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的 UTF8 编码子序列字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果 needle 是 haystack 的子序列则返回 1,否则返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```


## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

引入版本:v23.7

类似于 [`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence),但假定 haystack 和 needle 为 UTF-8 编码字符串。

**语法**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要查找的子序列。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `needle` 是 `haystack` 的子序列,则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**不匹配的子序列**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```


## hasToken {#hasToken}

引入版本:v20.1

检查给定的 token 是否存在于 haystack 中。

token 定义为由连续字符 `[0-9A-Za-z_]` 组成的最长子序列,即数字、ASCII 字母和下划线。

**语法**

```sql
hasToken(haystack, token)
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `token` — 要搜索的 token。[`const String`](/sql-reference/data-types/string)

**返回值**

如果找到 token 则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**Token 搜索**

```sql title=查询
SELECT hasToken('clickhouse test', 'test')
```

```response title=响应
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```


## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

引入版本:v

使用 tokenbf_v1 索引在 haystack 中对 needle 执行不区分大小写的查找。

**语法**

```sql

```

**参数**

- 无。

**返回值**

**示例**


## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

引入版本：v

使用 tokenbf_v1 索引在字符串中执行不区分大小写的词元查找。如果查找词元格式不正确，则返回 null。

**语法**

```sql

```

**参数**

- 无。

**返回值**

**示例**


## hasTokenOrNull {#hasTokenOrNull}

引入版本:v20.1

类似于 [`hasToken`](#hasToken),但当 token 格式不正确时返回 null。

**语法**

```sql
hasTokenOrNull(haystack, token)
```

**参数**

- `haystack` — 要搜索的字符串。必须为常量。[`String`](/sql-reference/data-types/string)
- `token` — 要搜索的 token。[`const String`](/sql-reference/data-types/string)

**返回值**

如果找到 token 则返回 `1`,否则返回 `0`;如果 token 格式不正确则返回 null。[`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**示例**

**使用示例**

```sql title=查询
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=响应
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```


## ilike {#ilike}

引入版本:v20.6

类似于 [`like`](#like),但不区分大小写进行搜索。

**语法**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — 用于匹配的 LIKE 模式。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串匹配 LIKE 模式(不区分大小写),则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT ilike('ClickHouse', '%house%');
```

```response title=响应
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```


## like {#like}

引入版本：v1.1

返回字符串 `haystack` 是否匹配 `LIKE` 表达式 `pattern`。

`LIKE` 表达式可以包含普通字符和以下元符号：

- `%` 表示任意数量的任意字符（包括零个字符）。
- `_` 表示单个任意字符。
- `\` 用于转义字面量 `%`、`_` 和 `\`。

匹配基于 UTF-8，例如 `_` 匹配 Unicode 码点 `¥`，该字符在 UTF-8 中使用两个字节表示。

如果 haystack 或 `LIKE` 表达式不是有效的 UTF-8，则行为未定义。

不会自动执行 Unicode 规范化，您可以使用 `normalizeUTF8*` 函数来实现。

要匹配字面量 `%`、`_` 和 `\`（它们是 `LIKE` 元字符），请在它们前面加上反斜杠：`\%`、`\_` 和 `\\`。
如果反斜杠位于 `%`、`_` 或 `\` 以外的字符之前，则反斜杠会失去其特殊含义（即被解释为字面量）。

:::note
ClickHouse 要求字符串中的反斜杠[也需要转义](../syntax.md#string)，因此您实际上需要写成 `\\%`、`\\_` 和 `\\\\`。
:::

对于形式为 `%needle%` 的 `LIKE` 表达式，该函数的速度与 `position` 函数一样快。
所有其他 LIKE 表达式在内部会被转换为正则表达式，并以类似于 `match` 函数的性能执行。

**语法**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**参数**

- `haystack` — 执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — 要匹配的 `LIKE` 模式。可以包含 `%`（匹配任意数量的字符）、`_`（匹配单个字符）和用于转义的 `\`。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串匹配 `LIKE` 模式则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**单字符通配符**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**不匹配的模式**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```


## locate {#locate}

引入版本:v18.16

类似于 [`position`](#position),但 `haystack` 和 `needle` 参数位置互换。

:::note 版本相关行为
此函数的行为取决于 ClickHouse 版本:

- 在 v24.3 之前的版本中,`locate` 是函数 `position` 的别名,接受参数 `(haystack, needle[, start_pos])`。
- 在 v24.3 及更高版本中,`locate` 是一个独立函数(为了更好地兼容 MySQL),接受参数 `(needle, haystack[, start_pos])`。
  可以通过设置 `function_locate_has_mysql_compatible_argument_order = false` 来恢复之前的行为。
  :::

**语法**

```sql
locate(needle, haystack[, start_pos])
```

**参数**

- `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
- `haystack` — 执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
- `start_pos` — 可选。在 `haystack` 中开始搜索的位置(从 1 开始)。[`UInt`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串,返回起始位置(以字节为单位,从 1 开始计数);如果未找到子字符串,返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基本用法**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```


## match {#match}

引入版本:v1.1

检查给定字符串是否匹配指定的正则表达式模式。

此函数使用 RE2 正则表达式库。支持的语法请参阅 [re2](https://github.com/google/re2/wiki/Syntax)。

匹配基于 UTF-8 编码,例如 `¥` 内部使用两个字节,但匹配时将其视为单个码点。
正则表达式不得包含 NULL 字节。
如果 haystack 或 pattern 不是有效的 UTF-8 编码,则行为未定义。

与 re2 的默认行为不同,`.` 可以匹配换行符。要禁用此行为,请在模式前添加 `(?-s)`。

模式会自动在两端锚定(相当于模式以 '^' 开头并以 '$' 结尾)。

如果只需要查找子字符串,可以使用 [`like`](#like) 或 [`position`](#position) 函数代替 - 它们的执行速度比此函数快得多。

替代运算符语法:`haystack REGEXP pattern`。

**语法**

```sql
match(haystack, pattern)
```

**别名**:`REGEXP_MATCHES`

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `pattern` — 正则表达式模式。[`const String`](/sql-reference/data-types/string)

**返回值**

如果模式匹配则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本模式匹配**

```sql title=查询
SELECT match('Hello World', 'Hello.*')
```

```response title=响应
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**模式不匹配**

```sql title=查询
SELECT match('Hello World', 'goodbye.*')
```

```response title=响应
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```


## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

引入版本：v20.1

类似于 [`multiFuzzyMatchAny`](#multiFuzzyMatchAny)，但返回在指定[编辑距离](https://en.wikipedia.org/wiki/Edit_distance)内与待搜索字符串匹配的所有索引数组，顺序任意。

**语法**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**参数**

- `haystack` — 待搜索的字符串。[`String`](/sql-reference/data-types/string)
- `distance` — 模糊匹配的最大编辑距离。[`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — 待匹配的模式数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在指定编辑距离内与待搜索字符串匹配的所有索引（从 1 开始）的数组，顺序任意。如果未找到匹配项，则返回空数组。[`Array(UInt64)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=响应
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```


## multiFuzzyMatchAny {#multiFuzzyMatchAny}

引入版本:v20.1

类似于 [`multiMatchAny`](#multiMatchAny),但如果任何模式在指定的[编辑距离](https://en.wikipedia.org/wiki/Edit_distance)内与待搜索字符串匹配,则返回 1。
此函数依赖于 [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) 库的实验性功能,在某些边界情况下可能会较慢。
性能取决于使用的编辑距离值和模式,但与非模糊匹配变体相比,其开销始终更大。

:::note
由于 hyperscan 的限制,`multiFuzzyMatch*()` 函数族不支持 UTF-8 正则表达式(会将其视为字节序列)。
:::

**语法**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**参数**

- `haystack` — 执行搜索的字符串。[`String`](/sql-reference/data-types/string)
- `distance` — 模糊匹配的最大编辑距离。[`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — 可选。要匹配的模式数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果任何模式在指定的编辑距离内与待搜索字符串匹配,则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```


## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

引入版本:v20.1

类似于 [`multiFuzzyMatchAny`](#multiFuzzyMatchAny),但返回在指定[编辑距离](https://en.wikipedia.org/wiki/Edit_distance)内与待搜索字符串匹配的任意模式的索引。

**语法**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**参数**

- `haystack` — 待搜索的字符串。[`String`](/sql-reference/data-types/string)
- `distance` — 模糊匹配的最大编辑距离。[`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — 用于匹配的模式数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在指定编辑距离内与待搜索字符串匹配的任意模式的索引(从 1 开始),如果没有匹配则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```


## multiMatchAllIndices {#multiMatchAllIndices}

引入版本:v20.1

类似于 [`multiMatchAny`](#multiMatchAny),但返回所有匹配项的索引数组,顺序任意。

**语法**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `pattern` — 用于匹配的正则表达式。[`String`](/sql-reference/data-types/string)

**返回值**

所有匹配项的索引数组(从 1 开始),顺序任意。如果未找到匹配项,则返回空数组。[`Array(UInt64)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=响应
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```


## multiMatchAny {#multiMatchAny}

引入版本:v20.1

检查多个正则表达式模式中是否至少有一个与目标字符串匹配。

如果您只需要在字符串中搜索多个子字符串,可以使用函数 [`multiSearchAny`](#multiSearchAny) 代替 - 它的运行速度比此函数快得多。

**语法**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**参数**

- `haystack` — 要在其中搜索模式的字符串。[`String`](/sql-reference/data-types/string)
- `pattern1[, pattern2, ...]` — 一个或多个正则表达式模式的数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果任何模式匹配则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**多模式匹配**

```sql title=查询
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=响应
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**无模式匹配**

```sql title=查询
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=响应
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```


## multiMatchAnyIndex {#multiMatchAnyIndex}

引入版本：v20.1

类似于 [`multiMatchAny`](#multiMatchAny)，但返回与输入字符串匹配的任意模式的索引。

**语法**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `pattern` — 用于匹配的正则表达式数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回第一个匹配模式的索引（从 1 开始），如果未找到匹配则返回 0。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=响应
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```


## multiSearchAllPositions {#multiSearchAllPositions}

引入版本:v20.1

类似于 [`position`](#position),但返回 `haystack` 字符串中多个 `needle` 子串的位置数组(以字节为单位,从 1 开始)。

所有 `multiSearch*()` 函数最多支持 2^8 个搜索子串。

**语法**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 要搜索的一个或多个子串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回起始位置数组(以字节为单位,从 1 开始计数)。如果找到子串则返回其位置,如果未找到则返回 `0`。[`Array(UInt64)`](/sql-reference/data-types/array)

**示例**

**多子串搜索**

```sql title=查询
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=响应
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```


## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

引入版本:v20.1

与 [`multiSearchAllPositions`](#multiSearchAllPositions) 类似,但不区分大小写。

**语法**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**参数**

- `haystack` — 要执行搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 要搜索的一个或多个子字符串组成的数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回一个包含起始位置的数组(以字节为单位,从 1 开始计数)。如果找到子字符串,则返回其位置;如果未找到子字符串,则返回 `0`。[`Array(UInt64)`](/sql-reference/data-types/array)

**示例**

**不区分大小写的多重搜索**

```sql title=查询
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=响应
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```


## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

引入版本:v20.1

类似于 [`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8),但不区分大小写。

**语法**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 执行搜索的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的 UTF-8 编码子字符串。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回一个数组,包含各子字符串的起始位置(以字节为单位,从 1 开始计数)。如果未找到子字符串,则返回 0。[`Array`](/sql-reference/data-types/array)

**示例**

**不区分大小写的 UTF-8 搜索**

```sql title=查询
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=响应
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```


## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

引入版本:v20.1

类似于 [`multiSearchAllPositions`](#multiSearchAllPositions),但假定 `haystack` 和 `needle` 子字符串均为 UTF-8 编码字符串。

**语法**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**参数**

- `haystack` — 执行搜索的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 要搜索的 UTF-8 编码子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回起始位置数组,以字节为单位且从 1 开始计数(如果找到子字符串),如果未找到子字符串则返回 `0`。[`Array`](/sql-reference/data-types/array)

**示例**

**UTF-8 多重搜索**

```sql title=查询
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=响应
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```


## multiSearchAny {#multiSearchAny}

引入版本：v20.1

检查多个待查找字符串中是否至少有一个与被搜索字符串匹配。

函数 [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive)、[`multiSearchAnyUTF8`](#multiSearchAnyUTF8) 和 [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) 提供了此函数的不区分大小写和/或 UTF-8 变体。

**语法**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**参数**

- `haystack` — 被搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 要搜索的子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少有一个匹配则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**任意匹配搜索**

```sql title=查询
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=响应
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```


## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

引入版本:v20.1

类似于 [multiSearchAny](#multiSearchAny),但忽略大小写。

**语法**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的子字符串。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少存在一个不区分大小写的匹配项,则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的搜索**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```


## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

引入版本:v20.1

类似于 [multiSearchAnyUTF8](#multiSearchAnyUTF8),但不区分大小写。

**语法**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 要执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的 UTF-8 子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少存在一个不区分大小写的匹配项,则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**给定 UTF-8 字符串 'Здравствуйте',检查字符 'з'(小写)是否存在**

```sql title=查询
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=响应
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

引入版本：v20.1

类似于 [multiSearchAny](#multiSearchAny)，但假定 `haystack` 和 `needle` 子字符串均为 UTF-8 编码字符串。

**语法**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 要执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的 UTF-8 子字符串。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少存在一个匹配项则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**给定 UTF-8 字符串 '你好，世界'（'Hello, world'），检查字符串中是否包含 你 或 界 字符**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstIndex {#multiSearchFirstIndex}

引入版本：v20.1

在字符串中搜索多个子串(区分大小写),并返回找到的第一个子串的索引(从 1 开始)。

**语法**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needles` — 要搜索的字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在 haystack 中找到的第一个 needle 的索引(从 1 开始,表示在 needles 数组中的位置)。如果未找到任何 needle,则返回 0。搜索区分大小写。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=响应
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**区分大小写行为**

```sql title=查询
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=响应
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**未找到匹配项**

```sql title=查询
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=响应
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```


## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

引入版本：v20.1

返回在字符串 `haystack` 中找到的最左侧 needle_i 的索引 `i`(从 1 开始),如果未找到则返回 0。
不区分大小写。

**语法**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要查找的子字符串。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回找到的最左侧 needle 的索引(从 1 开始)。如果没有匹配则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=响应
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

引入版本：v20.1

在目标字符串中搜索多个子字符串，不区分大小写且支持 UTF-8 编码，返回找到的第一个子字符串的索引（从 1 开始）。

**语法**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 要搜索的目标字符串。[`String`](/sql-reference/data-types/string)
- `needles` — 要搜索的子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在目标字符串中找到的第一个子字符串的索引（从 1 开始，对应其在 needles 数组中的位置）。如果未找到任何子字符串，则返回 0。搜索不区分大小写并遵循 UTF-8 字符编码。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=响应
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8 大小写处理**

```sql title=查询
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=响应
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**未找到匹配**

```sql title=查询
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=响应
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```


## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

引入版本：v20.1

返回字符串 `haystack` 中找到的最左侧 needle_i 的索引 `i`(从 1 开始),否则返回 0。
假定 `haystack` 和 `needle` 均为 UTF-8 编码字符串。

**语法**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 要执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的 UTF-8 子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回找到的最左侧 needle 的索引(从 1 开始)。如果没有匹配项则返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstPosition {#multiSearchFirstPosition}

引入版本:v20.1

类似于 [`position`](#position),但返回 `haystack` 字符串中与多个 `needle` 字符串中任意一个匹配的最左侧偏移量。

函数 [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive)、[`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8) 和 [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) 提供了此函数的不区分大小写和/或 UTF-8 变体。

**语法**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**参数**

- `haystack` — 执行搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 要搜索的一个或多个子字符串的数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回 `haystack` 字符串中与多个 `needle` 字符串中任意一个匹配的最左侧偏移量,如果没有匹配则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**首次位置搜索**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

引入版本：v20.1

类似于 [multiSearchFirstPosition](#multiSearchFirstPosition)，但不区分大小写。

**语法**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 要执行搜索的字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回 `haystack` 字符串中与多个 `needle` 字符串中任意一个匹配的最左侧偏移量。如果没有匹配项，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的首次位置**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

引入版本:v20.1

类似于 [multiSearchFirstPosition](#multiSearchFirstPosition),但假定 `haystack` 和 `needle` 为 UTF-8 字符串,并忽略大小写。

**语法**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 要搜索的 UTF-8 子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回 `haystack` 字符串中与多个 `needle` 字符串中任意一个匹配的最左侧偏移量,忽略大小写。如果没有匹配则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**在 UTF-8 字符串 'Здравствуй, мир'('Hello, world')中查找与给定 needle 中任意一个匹配的最左侧偏移量**

```sql title=查询
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=响应
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

引入版本：v20.1

类似于 [multiSearchFirstPosition](#multiSearchFirstPosition)，但假定 `haystack` 和 `needle` 为 UTF-8 编码字符串。

**语法**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

- `haystack` — 执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 待搜索的 UTF-8 子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

`haystack` 字符串中与任意 `needle` 字符串匹配的最左侧偏移量。如果没有匹配项则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**在 UTF-8 字符串 'Здравствуй, мир'（'Hello, world'）中查找与任意给定 needle 匹配的最左侧偏移量**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```


## ngramDistance {#ngramDistance}

引入版本:v20.1

计算两个字符串之间的 4-gram 距离。
该函数计算两个 4-gram 多重集之间的对称差,并通过它们基数之和进行归一化。
返回值越小,表示字符串越相似。

对于不区分大小写的搜索或 UTF8 格式,请使用函数 [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive)、[`ngramDistanceUTF8`](#ngramDistanceUTF8)、[`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8)。

**语法**

```sql
ngramDistance(haystack, needle)
```

**参数**

- `haystack` — 用于比较的字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 用于比较的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个介于 `0` 和 `1` 之间的 Float32 数值。返回值越小,表示字符串越相似。[`Float32`](/sql-reference/data-types/float)

**示例**

**计算 4-gram 距离**

```sql title=查询
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=响应
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```


## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

引入版本：v20.1

提供 [`ngramDistance`](#ngramDistance) 的不区分大小写变体。
计算两个字符串之间的 4-gram 距离，忽略大小写。
返回值越小，表示字符串越相似。

**语法**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**参数**

- `haystack` — 第一个比较字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 第二个比较字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个介于 `0` 和 `1` 之间的 Float32 数值。[`Float32`](/sql-reference/data-types/float)

**示例**

**不区分大小写的 4-gram 距离**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```


## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

引入版本：v20.1

提供 [`ngramDistance`](#ngramDistance) 的不区分大小写 UTF-8 变体。
假设 `needle` 和 `haystack` 字符串为 UTF-8 编码字符串，并忽略大小写。
计算两个 UTF-8 字符串之间的 3-gram 距离，忽略大小写。
返回值越小，表示字符串越相似。

**语法**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**参数**

- `haystack` — 第一个 UTF-8 编码的比较字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 第二个 UTF-8 编码的比较字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个介于 `0` 和 `1` 之间的 Float32 数值。[`Float32`](/sql-reference/data-types/float)

**示例**

**不区分大小写的 UTF-8 3-gram 距离**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```


## ngramDistanceUTF8 {#ngramDistanceUTF8}

引入版本：v20.1

提供 [`ngramDistance`](#ngramDistance) 的 UTF-8 变体。
假设 `needle` 和 `haystack` 字符串为 UTF-8 编码字符串。
计算两个 UTF-8 字符串之间的 3-gram 距离。
返回值越小，表示字符串越相似。

**语法**

```sql
ngramDistanceUTF8(haystack, needle)
```

**参数**

- `haystack` — 第一个 UTF-8 编码的比较字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 第二个 UTF-8 编码的比较字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个介于 `0` 和 `1` 之间的 Float32 数值。[`Float32`](/sql-reference/data-types/float)

**示例**

**UTF-8 3-gram 距离**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```


## ngramSearch {#ngramSearch}

引入版本:v20.1

检查两个字符串之间的 4-gram 距离是否小于或等于给定阈值。

对于不区分大小写的搜索或 UTF8 格式,请使用函数 `ngramSearchCaseInsensitive`、`ngramSearchUTF8`、`ngramSearchCaseInsensitiveUTF8`。

**语法**

```sql
ngramSearch(haystack, needle)
```

**参数**

- `haystack` — 待比较的字符串。 [`String`](/sql-reference/data-types/string)
- `needle` — 待比较的字符串。 [`String`](/sql-reference/data-types/string)

**返回值**

如果字符串之间的 4-gram 距离小于或等于阈值(默认为 `1.0`),则返回 `1`,否则返回 `0`。 [`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用 4-gram 进行搜索**

```sql title=查询
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=响应
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```


## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

引入版本:v20.1

提供 [`ngramSearch`](#ngramSearch) 的不区分大小写版本。
计算 needle 字符串和 haystack 字符串之间的非对称差异,即从 needle 的 n-gram 数量中减去公共 n-gram 数量,然后按 needle 的 n-gram 数量进行归一化。
检查两个字符串之间的 4-gram 距离是否小于或等于给定阈值,忽略大小写。

**语法**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**参数**

- `haystack` — 用于比较的字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 用于比较的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串之间的 4-gram 距离小于或等于阈值(默认为 `1.0`),则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用 4-gram 进行不区分大小写搜索**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```


## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

引入版本：v20.1

提供 [`ngramSearch`](#ngramSearch) 的不区分大小写 UTF-8 变体。
假定 `haystack` 和 `needle` 为 UTF-8 字符串并忽略大小写。
检查两个 UTF-8 字符串之间的 3-gram 距离是否小于或等于给定阈值（忽略大小写）。

**语法**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**参数**

- `haystack` — 用于比较的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 用于比较的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串之间的 3-gram 距离小于或等于阈值（默认为 `1.0`），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用 3-gram 进行不区分大小写的 UTF-8 搜索**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```


## ngramSearchUTF8 {#ngramSearchUTF8}

引入版本：v20.1

提供 `ngramSearch` 的 UTF-8 变体。
假设 `haystack` 和 `needle` 为 UTF-8 字符串。
检查两个 UTF-8 字符串之间的 3-gram 距离是否小于或等于给定的阈值。

**语法**

```sql
ngramSearchUTF8(haystack, needle)
```

**参数**

- `haystack` — 用于比较的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
- `needle` — 用于比较的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串之间的 3-gram 距离小于或等于阈值（默认为 `1.0`），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用 3-gram 进行 UTF-8 搜索**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```


## notILike {#notILike}

引入版本：v20.6

检查字符串是否不匹配指定模式（不区分大小写）。模式可以包含用于 SQL LIKE 匹配的特殊字符 `%` 和 `_`。

**语法**

```sql
notILike(haystack, pattern)
```

**参数**

- `haystack` — 要搜索的输入字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — 要匹配的 SQL LIKE 模式。`%` 匹配任意数量的字符（包括零个字符），`_` 匹配恰好一个字符。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串不匹配模式（不区分大小写），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT notILike('ClickHouse', '%house%');
```

```response title=响应
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```


## notLike {#notLike}

引入版本：v1.1

类似于 [`like`](#like)，但对结果取反。

**语法**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — 用于匹配的 LIKE 模式。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串不匹配 `LIKE` 模式则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT notLike('ClickHouse', '%House%');
```

```response title=响应
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**不匹配的模式**

```sql title=查询
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=响应
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```


## position {#position}

引入版本:v1.1

返回子字符串 `needle` 在字符串 `haystack` 中的位置(以字节为单位,从 1 开始计数)。

如果子字符串 `needle` 为空,则适用以下规则:

- 如果未指定 `start_pos`:返回 `1`
- 如果 `start_pos = 0`:返回 `1`
- 如果 `start_pos >= 1` 且 `start_pos <= length(haystack) + 1`:返回 `start_pos`
- 否则:返回 `0`

相同的规则也适用于函数 [`locate`](#locate)、[`positionCaseInsensitive`](#positionCaseInsensitive)、[`positionUTF8`](#positionUTF8) 和 [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8)。

**语法**

```sql
position(haystack, needle[, start_pos])
```

**参数**

- `haystack` — 执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
- `start_pos` — 在 `haystack` 中开始搜索的位置(从 1 开始计数)。可选。[`UInt`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串,则返回以字节为单位、从 1 开始计数的起始位置;如果未找到子字符串,则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基本用法**

```sql title=查询
SELECT position('Hello, world!', '!')
```

```response title=响应
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**使用 start_pos 参数**

```sql title=查询
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=响应
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Needle IN haystack 语法**

```sql title=查询
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=响应
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**空 needle 子字符串**

```sql title=查询
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=响应
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```


## positionCaseInsensitive {#positionCaseInsensitive}

引入版本：v1.1

类似于 [`position`](#position)，但不区分大小写。

**语法**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**别名**：`instr`

**参数**

- `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
- `start_pos` — 可选参数。在 `haystack` 中开始搜索的位置（从 1 开始计数）。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串，返回以字节为单位、从 1 开始计数的起始位置；如果未找到子字符串，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的搜索**

```sql title=查询
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=响应
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```


## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

引入版本：v1.1

类似于 [`positionUTF8`](#positionUTF8)，但不区分大小写进行搜索。

**语法**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**参数**

- `haystack` — 要搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 要查找的子字符串。[`String`](/sql-reference/data-types/string)
- `start_pos` — 可选。搜索起始位置（从 1 开始）。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串，返回其起始位置（以字节为单位，从 1 开始计数）；否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的 UTF-8 搜索**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```


## positionUTF8 {#positionUTF8}

引入版本:v1.1

类似于 [`position`](#position),但假定 `haystack` 和 `needle` 为 UTF-8 编码字符串。

**语法**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**参数**

- `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
- `start_pos` — 可选。在 `haystack` 中开始搜索的位置(从 1 开始计数)。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串,返回以字节为单位、从 1 开始计数的起始位置;否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**UTF-8 字符计数**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

<!--AUTOGENERATED_END-->

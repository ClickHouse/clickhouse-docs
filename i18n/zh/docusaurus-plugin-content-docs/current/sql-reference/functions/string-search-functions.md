---
description: '字符串搜索函数文档'
sidebar_label: '字符串搜索'
slug: /sql-reference/functions/string-search-functions
title: '字符串搜索函数'
doc_type: 'reference'
---

# 在字符串中搜索的函数 {#functions-for-searching-in-strings}

本节中的所有函数默认执行区分大小写的搜索。不区分大小写的搜索通常通过单独的函数变体提供。

:::note
不区分大小写的搜索遵循英语的小写与大写规则。例如，在英语中，小写 `i` 的大写形式是 `I`，而在土耳其语中则是 `İ` —— 因此对于英语以外的语言，结果可能不符合预期。
:::

本节中的函数还假定被搜索的字符串（在本节中称为 `haystack`）和搜索字符串（在本节中称为 `needle`）是单字节编码文本。如果不满足这一假设，将不会抛出异常，且结果未定义。对 UTF-8 编码字符串的搜索通常通过单独的函数变体提供。同样地，如果使用的是 UTF-8 函数变体，而输入字符串不是 UTF-8 编码文本，也不会抛出异常，结果未定义。请注意，不会自动执行 Unicode 规范化，不过可以使用
[normalizeUTF8*()](/sql-reference/functions/string-functions#normalizeUTF8NFC) 函数来执行该操作。

[通用字符串函数](string-functions.md)和[字符串替换函数](string-replace-functions.md)在单独的章节中介绍。

:::note
下文的文档是从 `system.functions` 系统表生成的。
:::

{/* 
  以下标签内部的内容会在文档框架构建时被替换为
  根据 system.functions 生成的文档。请不要修改或移除这些标签。
  参见：https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## countMatches {#countMatches}

自 v21.1 起可用

返回字符串中某个正则表达式的匹配次数。

:::note 版本相关行为
该函数的行为取决于 ClickHouse 版本：

* 在 &lt; v25.6 的版本中，即使模式仍可匹配，函数在遇到第一个空匹配时就会停止计数。
* 在 &gt;= 25.6 的版本中，函数在出现空匹配时会继续执行。可以通过设置 `count_matches_stop_at_empty_match = true` 来恢复旧行为。
  :::

**语法**

```sql
countMatches(haystack, pattern)
```

**参数**

* `haystack` — 要在其中搜索的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 正则表达式模式。[`String`](/sql-reference/data-types/string)

**返回值**

返回匹配项的数量。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**统计数字序列个数**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```

## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

引入于：v21.1

类似于 [`countMatches`](#countMatches)，但进行不区分大小写的匹配。

**语法**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**参数**

* `haystack` — 要在其中搜索的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 正则表达式模式。[`const String`](/sql-reference/data-types/string)

**返回值**

返回匹配到的次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的计数**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```

## countSubstrings {#countSubstrings}

自 v21.1 起引入

返回子字符串 `needle` 在字符串 `haystack` 中出现的次数。

**语法**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**参数**

* `haystack` — 执行搜索的字符串。[String](../../sql-reference/data-types/string.md) 或 [Enum](../../sql-reference/data-types/enum.md)。- `needle` — 要搜索的子字符串。[String](../../sql-reference/data-types/string.md)。- `start_pos` — 在 `haystack` 中开始搜索的起始位置（从 1 开始计数）。[UInt](../../sql-reference/data-types/int-uint.md)。可选。

**返回值**

出现的次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**使用 start&#95;pos 参数**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```

## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

自 v21.1 起引入。

与 [`countSubstrings`](#countSubstrings) 类似，但以不区分大小写的方式计数。

**语法**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
* `start_pos` — 可选。在 `haystack` 中开始搜索的位置（从 1 开始）。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回 `haystack` 中 `needle` 出现的次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**使用 start&#95;pos 参数**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```

## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

引入版本：v21.1

类似于 [`countSubstrings`](#countSubstrings)，但以不区分大小写的方式计数，并假定 haystack 是 UTF-8 编码的字符串。

**语法**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**参数**

* `haystack` — 用于执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
* `start_pos` — 可选。在 `haystack` 中开始搜索的位置（从 1 开始计数）。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回 `needle` 在 `haystack` 中出现的次数。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**使用 start&#95;pos 参数**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```

## extract {#extract}

引入版本：v1.1

从字符串中提取正则表达式的第一个匹配结果。
如果 &#39;haystack&#39; 不匹配 &#39;pattern&#39;，则返回空字符串。

此函数使用 RE2 正则表达式库。有关支持的语法，请参阅 [re2](https://github.com/google/re2/wiki/Syntax)。

如果正则表达式包含捕获组（子模式），函数会仅根据第一个捕获组来匹配输入字符串。

**语法**

```sql
extract(haystack, pattern)
```

**参数**

* `haystack` — 要从中提取内容的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 正则表达式，通常包含一个捕获组。[`const String`](/sql-reference/data-types/string)

**返回值**

以字符串形式返回提取出的片段。[`String`](/sql-reference/data-types/string)

**示例**

**从电子邮件地址中提取域名**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**如果没有匹配，则返回空字符串**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```

## extractAll {#extractAll}

引入版本：v1.1

与 [`extract`](#extract) 类似，但返回字符串中正则表达式所有匹配项组成的数组。
如果 &#39;haystack&#39; 不匹配 &#39;pattern&#39; 正则表达式，则返回空数组。

如果正则表达式包含捕获组（子模式），该函数只会针对第一个捕获组对输入字符串进行匹配。

**语法**

```sql
extractAll(haystack, pattern)
```

**参数**

* `haystack` — 要从中提取片段的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 正则表达式，可以包含捕获组。[`const String`](/sql-reference/data-types/string)

**返回值**

返回一个包含提取片段的数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**提取所有数字**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**使用捕获组提取**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```

## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

引入版本：v20.5

使用提供的正则表达式匹配字符串中的所有捕获组，并返回一个二维数组，其中每个子数组包含同一捕获组的所有捕获结果，按组号排列。

**语法**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**参数**

* `s` — 要从中提取内容的输入字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 用于匹配的正则表达式。[`const String`](/sql-reference/data-types/string) 或 [`const FixedString`](/sql-reference/data-types/fixedstring)

**返回值**

返回一个二维数组，其中每个内层数组包含某个捕获组在所有匹配中的全部捕获结果。第一个内层数组包含第 1 组的所有捕获，第二个内层数组包含第 2 组的所有捕获，依此类推。如果未找到任何匹配，则返回空数组。[`Array(Array(String))`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```

## extractGroups {#extractGroups}

自 v20.5 版本引入

从与正则表达式匹配的非重叠子串中提取所有分组。

**语法**

```sql
extractAllGroups(s, regexp)
```

**参数**

* `s` — 要从中提取的输入字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 正则表达式，常量。[`const String`](/sql-reference/data-types/string) 或 [`const FixedString`](/sql-reference/data-types/fixedstring)

**返回值**

如果函数找到至少一个匹配的捕获组，则返回一个按 group&#95;id（从 `1` 到 `N`，其中 `N` 是 regexp 中捕获组的数量）组织的 Array(Array(String)) 列。如果没有任何匹配组，则返回空数组。[`Array(Array(String))`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## hasAllTokens {#hasAllTokens}

引入版本:v25.10

类似于 [`hasAnyTokens`](#hasAnyTokens),但仅当 `needle` 字符串或数组中的所有标记都与 `input` 字符串匹配时返回 1,否则返回 0。如果 `input` 是列,则返回满足此条件的所有行。

:::note
列 `input` 应定义[文本索引](../../engines/table-engines/mergetree-family/textindexes)以获得最佳性能。
如果未定义文本索引,该函数将执行暴力扫描列,其速度比索引查找慢几个数量级。
:::

在搜索之前,函数会先进行分词

* `input` 参数（始终需要），以及
* `needle` 参数（如果以 [String](../../sql-reference/data-types/string.md) 类型传入）
  将使用为该文本索引指定的 tokenizer 进行分词。
  如果该列未定义文本索引，则会改用 `splitByNonAlpha` tokenizer。
  如果 `needle` 参数的类型为 [Array(String)](../../sql-reference/data-types/array.md)，则数组的每个元素都被视为一个 token —— 不会进行额外的分词处理。

重复的 token 将被忽略。
例如，needles = [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] 与 [&#39;ClickHouse&#39;] 的处理方式相同。

**语法**

```sql
hasAllTokens(input, needles)
```

**别名**：`hasAllToken`

**参数**

* `input` — 输入列。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring) 或 [`Array(String)`](/sql-reference/data-types/array) 或 [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — 要搜索的标记（token）。最多支持 64 个标记。[`String`](/sql-reference/data-types/string) 或 [`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果所有 needle 均匹配则返回 1,否则返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**字符串列使用示例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**在数组中指定要按原样搜索的目标字符串(不进行分词处理)**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**使用 `tokens` 函数生成针（needles）**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**数组和映射列的使用示例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**数组列示例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys 示例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapValues 示例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```

## hasAnyTokens {#hasAnyTokens}

引入版本：v25.10

如果 `needle` 字符串或数组中至少有一个 token 与 `input` 字符串匹配，则返回 1，否则返回 0。若 `input` 是一列，则返回所有满足该条件的行。

:::note
为获得最佳性能，应为列 `input` 定义一个 [text index](../../engines/table-engines/mergetree-family/textindexes)。
如果未定义 text index，函数将对整列进行直接扫描，其性能将比通过索引查询慢多个数量级。
:::

在执行搜索之前，函数会进行分词处理：

* `input` 参数（始终），以及
* `needle` 参数（如果以 [String](../../sql-reference/data-types/string.md) 形式给出），
  使用为 text index 指定的 tokenizer。
  如果该列未定义 text index，则会改用 `splitByNonAlpha` tokenizer。
  如果 `needle` 参数的类型为 [Array(String)](../../sql-reference/data-types/array.md)，则数组中的每个元素都被视为一个 token——不会进行额外的分词。

重复的 token 会被忽略。
例如，[&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] 与 [&#39;ClickHouse&#39;] 的处理结果相同。

**语法**

```sql
hasAnyTokens(input, needles)
```

**别名**: `hasAnyToken`

**参数**

* `input` — 输入列。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring) 或 [`Array(String)`](/sql-reference/data-types/array) 或 [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — 要搜索的 token。最多支持 64 个 token。[`String`](/sql-reference/data-types/string) 或 [`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少存在一个匹配项，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**字符串列的用法示例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**指定在数组中要按原样（不进行分词）搜索的字符串**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**使用 `tokens` FUNCTION 生成 needle 集合**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**数组列和 Map 列的使用示例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**带数组列的示例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys 使用示例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**mapValues 示例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

## hasSubsequence {#hasSubsequence}

引入版本：v23.7

检查参数 `needle` 是否为参数 `haystack` 的子序列。
字符串的子序列是指可以通过从另一个字符串中删除零个或多个字符且不改变其余字符顺序而得到的序列。

**语法**

```sql
hasSubsequence(haystack, needle)
```

**参数**

* `haystack` — 要在其中搜索子序列的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的子序列。[`String`](/sql-reference/data-types/string)

**返回值**

当 `needle` 是 `haystack` 的子序列时返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本子序列检查**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**未找到子序列**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

引入版本：v23.7

与 [`hasSubsequence`](#hasSubsequence) 类似，但执行不区分大小写的搜索。

**语法**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**参数**

* `haystack` — 要在其中搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要查找的子序列。[`String`](/sql-reference/data-types/string)

**返回值**

如果 needle 是 haystack 的子序列，则返回 1，否则返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

自 v23.7 引入

与 [`hasSubsequenceUTF8`](#hasSubsequenceUTF8) 类似，但进行不区分大小写的查找。

**语法**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**参数**

* `haystack` — 要在其中执行搜索的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的 UTF-8 编码子序列字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `needle` 是 `haystack` 的子序列，则返回 1，否则返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```

## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

引入自：v23.7 版本

与 [`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence) 类似，但假定 haystack 和 needle 是 UTF-8 编码的字符串。

**语法**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**参数**

* `haystack` — 在其中进行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要查找的子序列。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `needle` 是 `haystack` 的子序列，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**未匹配的子序列**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```

## hasToken {#hasToken}

引入版本：v20.1

检查在 haystack 中是否存在给定的 token。

token 定义为由连续字符 `[0-9A-Za-z_]` 构成的最长可能子序列，即数字、ASCII 字母和下划线。

**语法**

```sql
hasToken(haystack, token)
```

**参数**

* `haystack` — 被搜索的字符串。[`String`](/sql-reference/data-types/string)
* `token` — 要查找的标记。[`const String`](/sql-reference/data-types/string)

**返回值**

如果找到该标记则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**标记搜索**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```

## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

引入于：v

在 haystack 中使用 tokenbf&#95;v1 索引对 needle 进行大小写不敏感的查找。

**语法**

```sql
```

**参数**

* 无。

**返回值**

**示例**

## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

引入版本：v

使用 `tokenbf_v1` 索引在 `haystack` 中对 `needle` 执行不区分大小写的查找。如果 `needle` 格式不正确，则返回 NULL。

**语法**

```sql
```

**参数**

* 无。

**返回值**

**示例**

## hasTokenOrNull {#hasTokenOrNull}

自 v20.1 起引入

与 [`hasToken`](#hasToken) 类似，但在 token 格式不合法时返回 null。

**语法**

```sql
hasTokenOrNull(haystack, token)
```

**参数**

* `haystack` — 要搜索的字符串。必须为常量。[`String`](/sql-reference/data-types/string)
* `token` — 要搜索的 token。[`const String`](/sql-reference/data-types/string)

**返回值**

如果找到 token 则返回 `1`，否则返回 `0`，如果 token 非法则返回 `null`。[`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**示例**

**用法示例**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```

## ilike {#ilike}

引入版本：v20.6

与 [`like`](#like) 类似，但执行不区分大小写的搜索。

**语法**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**参数**

* `haystack` — 要在其中搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 要匹配的 LIKE 模式。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串匹配 LIKE 模式（不区分大小写），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```

## like {#like}

引入版本：v1.1

返回字符串 `haystack` 是否匹配 `LIKE` 表达式 `pattern`。

`LIKE` 表达式可以包含普通字符以及以下元字符：

* `%` 表示任意数量的任意字符（包括零个字符）。
* `_` 表示单个任意字符。
* `\` 用于转义字面量 `%`、`_` 和 `\`。

匹配基于 UTF-8，例如 `_` 可以匹配 Unicode 码点 `¥`，该字符在 UTF-8 中由两个字节表示。

如果 `haystack` 或 `LIKE` 表达式不是有效的 UTF-8，则行为未定义。

不会自动进行 Unicode 规范化，你可以使用 `normalizeUTF8*` 函数来完成该操作。

要匹配字面量 `%`、`_` 和 `\`（它们是 `LIKE` 元字符），请在它们前面添加反斜杠：`\%`、`\_` 和 `\\`。
如果反斜杠前缀的字符不是 `%`、`_` 或 `\`，则反斜杠会失去其特殊含义（即被按字面解释）。

:::note
ClickHouse 要求字符串中的反斜杠[同样需要转义](../syntax.md#string)，因此实际需要写成 `\\%`、`\\_` 和 `\\\\`。
:::

对于形式为 `%needle%` 的 `LIKE` 表达式，该函数的速度与 `position` 函数相同。
所有其他 `LIKE` 表达式在内部会被转换为正则表达式，并以与函数 `match` 类似的性能执行。

**语法**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 要匹配的 `LIKE` 模式。可以包含 `%`（匹配任意数量的字符）、`_`（匹配单个字符）以及用于转义的 `\`。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串匹配 `LIKE` 模式则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**单个字符通配符**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**未匹配的模式**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```

## locate {#locate}

自 v18.16 引入

与 [`position`](#position) 类似，但参数 `haystack` 和 `needle` 的顺序互换。

:::note Version dependent behavior
该函数的行为取决于 ClickHouse 的版本：

* 在 &lt; v24.3 的版本中，`locate` 是函数 `position` 的别名，并接受参数 `(haystack, needle[, start_pos])`。
* 在 &gt;= 24.3 的版本中，`locate` 是一个独立函数（为了更好地兼容 MySQL），并接受参数 `(needle, haystack[, start_pos])`。
  可以通过设置 `function_locate_has_mysql_compatible_argument_order = false` 恢复之前的行为。
  :::

**语法**

```sql
locate(needle, haystack[, start_pos])
```

**参数**

* `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
* `haystack` — 执行搜索的目标字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
* `start_pos` — 可选。在 `haystack` 中开始搜索的位置（从 1 开始计数）。[`UInt`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串，则返回其起始位置（按字节计算，从 1 开始计数）；如果未找到子字符串，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基本用法**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```

## match {#match}

引入版本：v1.1

检查给定字符串是否匹配给定的正则表达式模式。

此函数使用 RE2 正则表达式库。有关支持的语法，请参阅 [re2](https://github.com/google/re2/wiki/Syntax)。

匹配是在 UTF-8 前提下进行的，例如 `¥` 在内部使用两个字节，但在匹配时被视为单个码点（codepoint）。
正则表达式中不能包含 NULL 字节。
如果 haystack 或模式不是有效的 UTF-8，行为是未定义的。

与 re2 的默认行为不同，`.` 会匹配换行符。要禁用此行为，请在模式前添加 `(?-s)`。

模式会在两端自动锚定（就像模式以 `^` 开始并以 `$` 结束一样）。

如果你只想查找子串，可以使用函数 [`like`](#like) 或 [`position`](#position) —— 它们的执行速度比此函数快得多。

替代运算符语法：`haystack REGEXP pattern`。

**语法**

```sql
match(haystack, pattern)
```

**别名**: `REGEXP_MATCHES`

**参数**

* `haystack` — 要在其中搜索匹配模式的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 正则表达式模式。[`const String`](/sql-reference/data-types/string)

**返回值**

如果模式匹配则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本模式匹配**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**未匹配到模式**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```

## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

引入于：v20.1

类似于 [`multiFuzzyMatchAny`](#multiFuzzyMatchAny)，但返回一个数组，其中包含所有在给定固定[编辑距离](https://en.wikipedia.org/wiki/Edit_distance)内与 haystack 匹配的索引，顺序不定。

**语法**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**参数**

* `haystack` — 执行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `distance` — 模糊匹配的最大编辑距离。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 用于匹配的模式数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，包含所有在指定编辑距离内与 `haystack` 匹配的索引（从 1 开始），顺序不限。如果未找到匹配项，则返回空数组。[`Array(UInt64)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```

## multiFuzzyMatchAny {#multiFuzzyMatchAny}

引入版本：v20.1

类似于 [`multiMatchAny`](#multiMatchAny)，但如果任意模式在给定的常量[编辑距离](https://en.wikipedia.org/wiki/Edit_distance)内与 haystack 匹配，则返回 1。
该函数依赖于 [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) 库的实验性特性，在某些极端情况下可能会比较慢。
性能取决于编辑距离的取值以及所用模式，但相较于非模糊版本，它的开销始终更大。

:::note
由于 hyperscan 的限制，`multiFuzzyMatch*()` 函数族不支持 UTF-8 正则表达式（只会将其视为字节序列）。
:::

**语法**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**参数**

* `haystack` — 要在其中进行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `distance` — 模糊匹配允许的最大编辑距离。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 可选。要进行匹配的一组模式字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果任意一个模式在指定的编辑距离内与 `haystack` 匹配，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```

## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

引入版本：v20.1

类似于 [`multiFuzzyMatchAny`](#multiFuzzyMatchAny)，但返回在给定[编辑距离](https://en.wikipedia.org/wiki/Edit_distance)常量范围内与 haystack 匹配的任意索引位置。

**语法**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**参数**

* `haystack` — 要在其中搜索的字符串。[`String`](/sql-reference/data-types/string)
* `distance` — 用于模糊匹配的最大编辑距离。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 要匹配的模式数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在指定编辑距离内，与 `haystack` 匹配的任意模式的索引（从 1 开始），否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```

## multiMatchAllIndices {#multiMatchAllIndices}

引入自：v20.1

类似于 [`multiMatchAny`](#multiMatchAny)，但返回一个数组，包含在 `haystack` 中匹配到的所有索引，顺序任意。

**语法**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 用于匹配的正则表达式。[`String`](/sql-reference/data-types/string)

**返回值**

一个包含所有匹配项索引（从 1 开始，顺序不限）的数组。如果未找到匹配项，则返回空数组。[`Array(UInt64)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```

## multiMatchAny {#multiMatchAny}

引入版本：v20.1

检查多个正则表达式模式中是否至少有一个与目标字符串匹配。

如果只是需要在字符串中搜索多个子字符串，可以改用函数 [`multiSearchAny`](#multiSearchAny) —— 它的性能比本函数高得多。

**语法**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**参数**

* `haystack` — 用于搜索模式的字符串。[`String`](/sql-reference/data-types/string)
* `pattern1[, pattern2, ...]` — 由一个或多个正则表达式模式组成的数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果任意模式匹配则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**多模式匹配**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**没有匹配的模式**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```

## multiMatchAnyIndex {#multiMatchAnyIndex}

引入版本：v20.1

与 [`multiMatchAny`](#multiMatchAny) 类似，但返回在 haystack（被搜索字符串）中匹配到的任意索引。

**语法**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 要进行匹配的正则表达式数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回第一个匹配成功的模式的索引（从 1 开始计数），如果没有匹配则返回 0。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```

## multiSearchAllPositions {#multiSearchAllPositions}

引入版本：v20.1

类似于 [`position`](#position)，但会返回一个数组，包含多个 `needle` 子字符串在 `haystack` 字符串中的所有位置（以字节为单位，从 1 开始计数）。

所有 `multiSearch*()` 函数最多支持 2^8 个 `needle`。

**语法**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 由一个或多个要搜索的子字符串构成的数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其中的元素为在找到子字符串时的起始位置（以字节为单位，从 1 开始计数）；如果未找到子字符串，则为 `0`。[`Array(UInt64)`](/sql-reference/data-types/array)

**示例**

**多个 needle 的搜索**

```sql title=Query
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

自 v20.1 起引入

与 [`multiSearchAllPositions`](#multiSearchAllPositions) 类似，但不区分大小写。

**语法**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**参数**

* `haystack` — 执行搜索操作的字符串。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 要搜索的一个或多个子字符串组成的数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其中的元素为子字符串的起始位置（以字节为单位，从 1 开始计数；若找到子字符串），如果未找到则为 `0`。[`Array(UInt64)`](/sql-reference/data-types/array)

**示例**

**不区分大小写的多重搜索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

自 v20.1 引入

与 [`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8) 类似，但忽略大小写。

**语法**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 要执行搜索的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的 UTF-8 编码子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

一个起始位置数组，位置以字节为单位并从 1 开始计数（当找到子字符串时）。如果未找到子字符串，则返回 0。[`Array`](/sql-reference/data-types/array)

**示例**

**不区分大小写的 UTF-8 搜索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```

## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

引入于：v20.1

类似于 [`multiSearchAllPositions`](#multiSearchAllPositions)，但假定 `haystack` 和 `needle` 子串是 UTF-8 编码的字符串。

**语法**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**参数**

* `haystack` — 要在其中进行搜索的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 要搜索的 UTF-8 编码子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其中的元素为从 1 开始计数的起始字节位置（如果找到子字符串），如果未找到子字符串则为 `0`。[`Array`](/sql-reference/data-types/array)

**示例**

**UTF-8 多模式搜索**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```

## multiSearchAny {#multiSearchAny}

引入版本：v20.1

判断在多个 needle 字符串中，是否至少有一个能与 haystack 字符串匹配。

函数 [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive)、[`multiSearchAnyUTF8`](#multiSearchAnyUTF8) 和 [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) 提供此函数的不区分大小写和/或 UTF-8 变体。

**语法**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 要搜索的子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少有一个匹配，则返回 `1`；如果没有任何匹配，则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**任意匹配搜索**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

引入版本：v20.1

与 [multiSearchAny](#multiSearchAny) 类似，但不区分大小写。

**语法**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 待搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要查找的子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果存在至少一个不区分大小写的匹配，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的搜索**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

自 v20.1 引入

与 [multiSearchAnyUTF8](#multiSearchAnyUTF8) 类似，但忽略大小写。

**语法**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 执行搜索的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的 UTF-8 编码子串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少存在一个不区分大小写的匹配，则返回 `1`；否则（不存在任何不区分大小写的匹配时）返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**给定 UTF-8 字符串 &#39;Здравствуйте&#39;，检查其中是否包含字符 &#39;з&#39;（小写）**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

自 v20.1 引入

与 [multiSearchAny](#multiSearchAny) 类似，但假定 `haystack` 和 `needle` 子串是 UTF-8 编码的字符串。

**语法**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的 UTF-8 子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

如果至少有一个匹配则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**给定 “你好，世界”（“Hello, world”）这一 UTF-8 字符串，检查字符串中是否存在字符“你”或“界”**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndex {#multiSearchFirstIndex}

引入版本：v20.1

在一个字符串中搜索多个子串（区分大小写），并返回首次匹配子串的从 1 开始计数的索引。

**语法**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 要在其中搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needles` — 要搜索的字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在 `haystack` 中找到的第一个元素在 `needles` 数组中的从 1 开始计数的索引（位置）。如果未找到任何元素，则返回 0。搜索区分大小写。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**大小写敏感的行为**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**未找到匹配结果**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

引入版本：v20.1

返回在字符串 `haystack` 中找到的最左侧 needle&#95;i 的编号 `i`（从 1 开始），否则返回 0。
比较时忽略大小写。

**语法**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回最左侧匹配到的 needle 的索引（从 1 开始）。如果没有匹配，则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

引入于：v20.1

在一个目标字符串中，以不区分大小写并支持 UTF-8 编码的方式搜索多个待查字符串，并返回首次匹配到的待查字符串的从 1 开始的索引。

**语法**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 要在其中进行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needles` — 要搜索的字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在 `haystack` 中找到的第一个 `needle` 在 `needles` 数组中的从 1 开始的索引（位置）。如果未找到任何 `needle`，则返回 0。搜索不区分大小写，并按 UTF-8 编码处理字符。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8 大小写处理**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**未找到匹配结果**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

引入版本：v20.1

返回在字符串 `haystack` 中找到的最左侧子串 `needle&#95;i` 的索引 `i`（从 1 开始计数），如果未找到则返回 0。
假设 `haystack` 和 `needle` 为 UTF-8 编码字符串。

**语法**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 在其中执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的 UTF-8 子串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回最左侧匹配到的 `needle` 的索引（从 1 开始计数）。如果没有匹配，则返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstPosition {#multiSearchFirstPosition}

引入于：v20.1

类似于 [`position`](#position)，但返回在 `haystack` 字符串中，与多个 `needle` 字符串中任意一个匹配的最左侧偏移量。

函数 [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive)、[`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8) 和 [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) 提供了该函数的不区分大小写和/或 UTF-8 变体。

**语法**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**参数**

* `haystack` — 用于执行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 一个或多个待搜索子字符串组成的数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在 `haystack` 字符串中，与任意一个 `needle` 字符串匹配的最左侧偏移量；如果没有匹配，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**首个位置搜索**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

引入于：v20.1

与 [multiSearchFirstPosition](#multiSearchFirstPosition) 类似，但不区分大小写。

**语法**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 要在其中进行搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在 `haystack` 字符串中，与 `needle` 数组中任意一个字符串匹配的最左侧偏移量。如果没有匹配，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的首次位置**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

引入版本：v20.1

与 [multiSearchFirstPosition](#multiSearchFirstPosition) 类似，但假设 `haystack` 和 `needle` 为 UTF-8 字符串，并且不区分大小写。

**语法**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 进行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的 UTF-8 子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

返回在 `haystack` 字符串中，与多个 `needle` 字符串中任意一个匹配的最左侧位置偏移量，忽略大小写。如果没有匹配，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**查找 UTF-8 字符串 &#39;Здравствуй, мир&#39;（&#39;Hello, world&#39;）中与给定的任意一个 `needle` 匹配的最左侧偏移量**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

引入版本：v20.1

与 [multiSearchFirstPosition](#multiSearchFirstPosition) 类似，但假设 `haystack` 和 `needle` 为 UTF-8 编码的字符串。

**语法**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**参数**

* `haystack` — 要在其中执行搜索的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的 UTF-8 子字符串数组。[`Array(String)`](/sql-reference/data-types/array)

**返回值**

在 `haystack` 字符串中，与任意一个 `needle` 字符串匹配的最左侧偏移量。如果没有匹配，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**在 UTF-8 字符串 &#39;Здравствуй, мир&#39;（&#39;Hello, world&#39;）中查找与给定任一 needle 匹配的最左侧偏移量**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```

## ngramDistance {#ngramDistance}

自 v20.1 版本引入

计算两个字符串之间的 4-gram 距离。
为此，它会统计两个 4-gram 多重集合之间的对称差，并用它们基数之和对该值进行归一化。
返回值越小，字符串越相似。

对于不区分大小写的搜索和/或 UTF-8 格式，请使用函数 [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive)、[`ngramDistanceUTF8`](#ngramDistanceUTF8)、[`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8)。

**语法**

```sql
ngramDistance(haystack, needle)
```

**参数**

* `haystack` — 用于比较的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 用于比较的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回介于 `0` 和 `1` 之间的 Float32 类型数值。返回值越小，字符串越相似。[`Float32`](/sql-reference/data-types/float)

**示例**

**计算 4-gram 距离**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

引入于：v20.1

提供 [`ngramDistance`](#ngramDistance) 的不区分大小写版本。
计算两个字符串之间的 4-gram 距离（忽略大小写）。
返回值越小，字符串越相似。

**语法**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**参数**

* `haystack` — 第一个用于比较的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 第二个用于比较的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个介于 `0` 和 `1` 之间的 Float32 数值。[`Float32`](/sql-reference/data-types/float)

**示例**

**不区分大小写的 4-gram 距离**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

引入于：v20.1

提供 [`ngramDistance`](#ngramDistance) 的不区分大小写 UTF-8 版本。
假定 `needle` 和 `haystack` 是 UTF-8 编码的字符串，比较时不区分大小写。
计算两个 UTF-8 字符串之间的 3-gram 距离，忽略大小写。
返回值越小，字符串越相似。

**语法**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**参数**

* `haystack` — 第一个 UTF-8 编码的待比较字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 第二个 UTF-8 编码的待比较字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回介于 `0` 和 `1` 之间的 Float32 类型数值。[`Float32`](/sql-reference/data-types/float)

**示例**

**不区分大小写的 UTF-8 3-gram 距离**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```

## ngramDistanceUTF8 {#ngramDistanceUTF8}

引入版本：v20.1

提供 [`ngramDistance`](#ngramDistance) 的 UTF-8 变体。
假定 `needle` 和 `haystack` 为 UTF-8 编码的字符串。
计算两个 UTF-8 字符串之间的 3-gram 距离。
返回值越小，字符串越相似。

**语法**

```sql
ngramDistanceUTF8(haystack, needle)
```

**参数**

* `haystack` — 第一个 UTF-8 编码的比较字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 第二个 UTF-8 编码的比较字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个介于 `0` 和 `1` 之间的 Float32 类型值。[`Float32`](/sql-reference/data-types/float)

**示例**

**UTF-8 3-gram 距离**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```

## ngramSearch {#ngramSearch}

引入于：v20.1

检查两个字符串之间的 4-gram 距离是否小于或等于给定阈值。

对于不区分大小写的搜索和/或 UTF-8 编码，请使用函数 `ngramSearchCaseInsensitive`、`ngramSearchUTF8`、`ngramSearchCaseInsensitiveUTF8`。

**语法**

```sql
ngramSearch(haystack, needle)
```

**参数**

* `haystack` — 被搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要搜索的子串。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串之间的 4-gram 距离小于或等于阈值（默认 `1.0`），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用 4-gram 搜索**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```

## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

引入版本：v20.1

提供 [`ngramSearch`](#ngramSearch) 的不区分大小写变体。
计算 needle 字符串与 haystack 字符串之间的非对称差异，即 needle 中的 n-gram 数量减去共有 n-gram 的数量，再除以 needle 的 n-gram 数量进行归一化。
在忽略大小写的情况下，检查两个字符串之间的 4-gram 距离是否小于或等于给定的阈值。

**语法**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**参数**

* `haystack` — 被搜索的字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 要查找的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果两个字符串之间的 4-gram 距离小于或等于阈值（默认值为 `1.0`），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用 4-gram 的大小写不敏感搜索**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

引入于：v20.1

提供 [`ngramSearch`](#ngramSearch) 的不区分大小写的 UTF-8 变体。
假定 `haystack` 和 `needle` 为 UTF-8 字符串，并在比较时忽略大小写。
在忽略大小写的情况下，检查两个 UTF-8 字符串之间的 3-gram 距离是否小于或等于给定阈值。

**语法**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**参数**

* `haystack` — 用于比较的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 用于比较的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串之间的 3-gram 距离小于或等于阈值（默认值为 `1.0`），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用 3-gram 的不区分大小写 UTF-8 搜索**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```

## ngramSearchUTF8 {#ngramSearchUTF8}

自 v20.1 版本引入

提供 `ngramSearch` 的 UTF-8 变体。
假定 `haystack` 和 `needle` 为 UTF-8 字符串。
检查两个 UTF-8 字符串之间的 3-gram 距离是否小于或等于给定阈值。

**语法**

```sql
ngramSearchUTF8(haystack, needle)
```

**参数**

* `haystack` — 用于比较的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string)
* `needle` — 用于比较的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果两个字符串之间的 3-gram 距离小于或等于阈值（默认 `1.0`），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用 3-gram 的 UTF-8 搜索**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```

## notILike {#notILike}

引入自：v20.6

检测字符串是否与指定模式不匹配（不区分大小写）。该模式可以包含用于 SQL LIKE 匹配的特殊字符 `%` 和 `_`。

**语法**

```sql
notILike(haystack, pattern)
```

**参数**

* `haystack` — 要在其中搜索的输入字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 要匹配的 SQL LIKE 模式。`%` 匹配任意数量的字符（包括 0 个），`_` 精确匹配 1 个字符。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串与模式不匹配（不区分大小写），则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```

## notLike {#notLike}

引入于：v1.1

与 [`like`](#like) 类似，但返回相反的结果。

**语法**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 用于匹配的 LIKE 模式。[`String`](/sql-reference/data-types/string)

**返回值**

如果字符串与 `LIKE` 模式不匹配，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**未匹配的模式**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```

## position {#position}

自 v1.1 版本引入

返回子字符串 `needle` 在字符串 `haystack` 中的位置（以字节为单位，从 1 开始计数）。

如果子字符串 `needle` 为空，适用以下规则：

* 如果未指定 `start_pos`：返回 `1`
* 如果 `start_pos = 0`：返回 `1`
* 如果 `start_pos >= 1` 且 `start_pos <= length(haystack) + 1`：返回 `start_pos`
* 否则：返回 `0`

相同规则也适用于函数 [`locate`](#locate)、[`positionCaseInsensitive`](#positionCaseInsensitive)、[`positionUTF8`](#positionUTF8) 和 [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8)。

**语法**

```sql
position(haystack, needle[, start_pos])
```

**参数**

* `haystack` — 要在其中进行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 要查找的子字符串。[`String`](/sql-reference/data-types/string)
* `start_pos` — 在 `haystack` 中开始搜索的位置（从 1 开始计数）。可选。[`UInt`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串，则返回起始位置（以字节为单位，从 1 开始计数）；如果未找到子字符串，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基本用法**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**使用 start&#95;pos 参数**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**needle IN haystack 语法**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**空 needle 子字符串**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```

## positionCaseInsensitive {#positionCaseInsensitive}

自 v1.1 引入

与 [`position`](#position) 类似，但不区分大小写。

**语法**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**别名**: `instr`

**参数**

* `haystack` — 要在其中进行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
* `start_pos` — 可选。在 `haystack` 中开始搜索的位置（从 1 开始计数）。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串，则返回其起始位置（按字节计算，并从 1 开始计数）；如果未找到，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的搜索**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```

## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

引入版本：v1.1

与 [`positionUTF8`](#positionUTF8) 类似，但执行大小写不敏感的搜索。

**语法**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 要查找的子字符串。[`String`](/sql-reference/data-types/string)
* `start_pos` — 可选。在 `haystack` 中开始搜索的位置（从 1 开始计数）。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

如果找到子字符串，则返回起始位置（以字节为单位，从 1 开始计数）；如果未找到子字符串，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**不区分大小写的 UTF-8 搜索**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```

## positionUTF8 {#positionUTF8}

自 v1.1 起引入

与 [`position`](#position) 类似，但假定 `haystack` 和 `needle` 为 UTF-8 编码的字符串。

**语法**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**参数**

* `haystack` — 要在其中执行搜索的字符串。[`String`](/sql-reference/data-types/string) 或 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 要搜索的子字符串。[`String`](/sql-reference/data-types/string)
* `start_pos` — 可选。在 `haystack` 中开始搜索的位置（从 1 开始计数）。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

若找到子字符串，则返回其起始位置（按字节计数，从 1 开始）；若未找到子字符串，则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**UTF-8 字符计数**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

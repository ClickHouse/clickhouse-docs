---
description: '自省函数参考文档'
sidebar_label: '自省'
slug: /sql-reference/functions/introspection
title: '自省函数'
doc_type: 'reference'
---



# 自省函数

您可以使用本章介绍的函数对 [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) 和 [DWARF](https://en.wikipedia.org/wiki/DWARF) 进行自省，用于查询分析。

:::note
这些函数较慢，并且可能带来安全风险。
:::

要使自省函数正常工作：

* 安装 `clickhouse-common-static-dbg` 软件包。

* 将 [allow&#95;introspection&#95;functions](../../operations/settings/settings.md#allow_introspection_functions) 设置为 1。

  出于安全原因，自省函数默认是禁用的。

ClickHouse 会将分析器生成的报告保存到 [trace&#95;log](/operations/system-tables/trace_log) 系统表中。请确保该表和分析器已正确配置。

{/*
  下面标签内的内容会在文档框架构建期间
  被基于 system.functions 自动生成的文档替换。请不要修改或删除这些标签。
  参见：https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }


{/*AUTOGENERATED_START*/ }

## demangle

自 v20.1 引入

将符号解码为 C++ 函数名。
该符号通常由 `addressToSymbol` 函数返回。

**语法**

```sql
demangle(符号)
```

**参数**

* `symbol` — 来自目标文件的符号。[`String`](/sql-reference/data-types/string)

**返回值**

返回 C++ 函数的名称，如果符号无效则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**从 `trace_log` 系统表中选取第一条字符串**

```sql title=Query
SELECT * FROM system.trace_log LIMIT 1 \G;
```

```response title=Response
-- `trace` 字段包含采样时刻的堆栈跟踪信息。
第 1 行：
──────
event_date:    2019-11-20
event_time:    2019-11-20 16:57:59
revision:      54429
timer_type:    Real
thread_number: 48
query_id:      724028bf-f550-45aa-910d-2af6212b94ac
trace:         [94138803686098,94138815010911,94138815096522,94138815101224,94138815102091,94138814222988,94138806823642,94138814457211,94138806823642,94138814457211,94138806823642,94138806795179,94138806796144,94138753770094,94138753771646,94138753760572,94138852407232,140399185266395,140399178045583]
```

**获取单个地址对应的函数名**

```sql title=Query
SET allow_introspection_functions=1;
SELECT demangle(addressToSymbol(94138803686098)) \G;
```

```response title=Response
第 1 行：
──────
demangle(addressToSymbol(94138803686098)): DB::IAggregateFunctionHelper<DB::AggregateFunctionSum<unsigned long, unsigned long, DB::AggregateFunctionSumData<unsigned long> > >::addBatchSinglePlace(unsigned long, char*, DB::IColumn const**, DB::Arena*) const
```

**将函数应用于整个调用栈**

```sql title=Query
SET allow_introspection_functions=1;

-- arrayMap 函数允许使用 demangle 函数处理 trace 数组中的每个元素。
-- 处理结果将显示在输出的 trace_functions 列中。

SELECT
    arrayStringConcat(arrayMap(x -> demangle(addressToSymbol(x)), trace), '\n') AS trace_functions
FROM system.trace_log
LIMIT 1
\G
```


```response title=Response
第 1 行：
──────
trace_functions: DB::IAggregateFunctionHelper<DB::AggregateFunctionSum<unsigned long, unsigned long, DB::AggregateFunctionSumData<unsigned long> > >::addBatchSinglePlace(unsigned long, char*, DB::IColumn const**, DB::Arena*) const
DB::Aggregator::executeWithoutKeyImpl(char*&, unsigned long, DB::Aggregator::AggregateFunctionInstruction*, DB::Arena*) const
DB::Aggregator::executeOnBlock(std::vector<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::allocator<COW<DB::IColumn>::immutable_ptr<DB::IColumn> > >, unsigned long, DB::AggregatedDataVariants&, std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> >&, std::vector<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> >, std::allocator<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> > > >&, bool&)
DB::Aggregator::executeOnBlock(DB::Block const&, DB::AggregatedDataVariants&, std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> >&, std::vector<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> >, std::allocator<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> > > >&, bool&)
DB::Aggregator::execute(std::shared_ptr<DB::IBlockInputStream> const&, DB::AggregatedDataVariants&)
DB::AggregatingBlockInputStream::readImpl()
DB::IBlockInputStream::read()
DB::ExpressionBlockInputStream::readImpl()
DB::IBlockInputStream::read()
DB::ExpressionBlockInputStream::readImpl()
DB::IBlockInputStream::read()
DB::AsynchronousBlockInputStream::calculate()
std::_Function_handler<void (), DB::AsynchronousBlockInputStream::next()::{lambda()#1}>::_M_invoke(std::_Any_data const&)
ThreadPoolImpl<ThreadFromGlobalPool>::worker(std::_List_iterator<ThreadFromGlobalPool>)
ThreadFromGlobalPool::ThreadFromGlobalPool<ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::function<void ()>, int, std::optional<unsigned long>)::{lambda()#3}>(ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::function<void ()>, int, std::optional<unsigned long>)::{lambda()#3}&&)::{lambda()#1}::operator()() const
ThreadPoolImpl<std::thread>::worker(std::_List_iterator<std::thread>)
execute_native_thread_routine
start_thread
clone
```


## isMergeTreePartCoveredBy

引入版本：v25.6

用于检查第一个参数中的数据部分是否被第二个参数中的数据部分所覆盖的函数。

**语法**

```sql
isMergeTreePartCoveredBy(nested_part, covering_part)
```

**参数**

* `nested_part` — 预期嵌套部分的名称。[`String`](/sql-reference/data-types/string)
* `covering_part` — 预期覆盖部分的名称。[`String`](/sql-reference/data-types/string)

**返回值**

如果满足覆盖关系则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本示例**

```sql title=Query
WITH 'all_12_25_7_4' AS lhs, 'all_7_100_10_20' AS rhs
SELECT isMergeTreePartCoveredBy(rhs, lhs), isMergeTreePartCoveredBy(lhs, rhs);
```

```response title=Response
┌─isMergeTreePartCoveredBy(rhs, lhs)─┬─isMergeTreePartCoveredBy(lhs, rhs)─┐
│                                  0 │                                  1 │
└────────────────────────────────────┴────────────────────────────────────┘
```


## logTrace

自 v20.12 起引入

为每个 [Block](/development/architecture/#block) 向服务器日志输出一条跟踪日志消息。

**语法**

```sql
logTrace(message)
```

**参数**

* `message` — 写入服务器日志的消息。[`const String`](/sql-reference/data-types/string)

**返回值**

始终返回值为 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本示例**

```sql title=Query
SELECT logTrace('logTrace 消息');
```

```response title=Response
┌─logTrace('logTrace message')─┐
│                            0 │
└──────────────────────────────┘
```


## mergeTreePartInfo

引入版本：v25.6

用于从 `MergeTree` 分片名称中提取有用值的函数。

**语法**

```sql
mergeTreePartInfo(part_name)
```

**参数**

* `part_name` — 要解包的 part 的名称。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含以下子列的 Tuple：`partition_id`、`min_block`、`max_block`、`level`、`mutation`。[`Tuple`](/sql-reference/data-types/tuple)

**示例**

**基本示例**

```sql title=Query
WITH mergeTreePartInfo('all_12_25_7_4') AS info
SELECT info.partition_id, info.min_block, info.max_block, info.level, info.mutation;
```

```response title=Response
┌─info.partition_id─┬─info.min_block─┬─info.max_block─┬─info.level─┬─info.mutation─┐
│ all               │             12 │             25 │          7 │             4 │
└───────────────────┴────────────────┴────────────────┴────────────┴───────────────┘
```


## tid

引入自：v20.12

返回正在处理当前 [Block](/development/architecture/#block) 的线程 ID。

**语法**

```sql
tid()
```

**参数**

* 无。

**返回值**

返回当前线程 ID。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT tid();
```

```response title=Response
┌─tid()─┐
│  3878 │
└───────┘
```

{/*AUTOGENERATED_END*/ }

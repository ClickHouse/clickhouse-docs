---
description: '数组函数文档'
sidebar_label: '数组'
slug: /sql-reference/functions/array-functions
title: '数组函数'
doc_type: 'reference'
---



# 数组函数

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## array {#array}

Introduced in: v1.1

从函数参数创建数组。

参数必须是常量,且类型需具有共同的超类型。
至少需要传递一个参数,否则无法确定要创建的数组类型。
这意味着不能使用此函数创建空数组。如需创建空数组,请使用 `emptyArray*` 函数。

使用 `[ ]` 运算符可实现相同功能。

**语法**

```sql
array(x1 [, x2, ..., xN])
```

**参数**

- `x1` — 任意类型 T 的常量值。如果仅提供此参数,数组类型将为 T。- `[, x2, ..., xN]` — 与 `x1` 具有共同超类型的额外 N 个常量值

**返回值**

返回一个数组,其中 'T' 是所传递参数的最小公共类型。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**有效用法**

```sql title=查询
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=响应
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**无效用法**

```sql title=查询
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=响应
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```


## arrayAUCPR {#arrayAUCPR}

引入版本:v20.4

计算精确率-召回率(PR)曲线下的面积。
精确率-召回率曲线通过在所有阈值下以精确率为纵轴、召回率为横轴绘制而成。
结果值范围为 0 到 1,值越高表示模型性能越好。
PR AUC 对于不平衡数据集特别有用,相比 ROC AUC,它能在这些情况下提供更清晰的性能对比。
更多详情,请参见[此处](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[此处](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)和[此处](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)。

**语法**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**别名**:`arrayPRAUC`

**参数**

- `scores` — 预测模型给出的分数。[`Array((U)Int*)`](/sql-reference/data-types/array) 或 [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — 样本的标签,通常正样本为 1,负样本为 0。[`Array((U)Int*)`](/sql-reference/data-types/array) 或 [`Array(Enum)`](/sql-reference/data-types/array)
- `partial_offsets` —
- 可选。一个包含三个非负整数的 [`Array(T)`](/sql-reference/data-types/array),用于计算 PR 曲线下的部分面积(相当于 PR 空间的垂直带)而非整个 AUC。此选项对于 PR AUC 的分布式计算很有用。数组必须包含以下元素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]。
  - `higher_partitions_tp`:高分分区中正标签的数量。
  - `higher_partitions_fp`:高分分区中负标签的数量。
  - `total_positives`:整个数据集中正样本的总数。

:::note
当使用 `arr_partial_offsets` 时,`arr_scores` 和 `arr_labels` 应该只是整个数据集的一个分区,包含一个分数区间。
数据集应该被划分为连续的分区,每个分区包含分数落在特定范围内的数据子集。
例如:

- 一个分区可以包含范围 [0, 0.5) 内的所有分数。
- 另一个分区可以包含范围 [0.5, 1.0] 内的分数。
  :::

**返回值**

返回精确率-召回率(PR)曲线下的面积。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=查询
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=响应
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll {#arrayAll}

引入版本:v1.1

如果 lambda 函数 `func(x [, y1, y2, ... yN])` 对所有元素返回 true,则返回 `1`。否则返回 `0`。

**语法**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

如果 lambda 函数对所有元素返回 true 则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**所有元素匹配**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**并非所有元素匹配**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg {#arrayAvg}

引入版本：v21.1

返回源数组中元素的平均值。

如果指定了 lambda 函数 `func`，则返回 lambda 函数结果的平均值。

**语法**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。对源数组（`x`）和条件数组（`y`）元素进行操作的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 待处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中元素的平均值，如果提供了 lambda 函数，则返回 lambda 函数结果的平均值。[`Float64`](/sql-reference/data-types/float)

**示例**

**基本示例**

```sql title=查询
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=响应
2.5
```

**使用 lambda 函数**

```sql title=查询
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=响应
6.5
```


## arrayCompact {#arrayCompact}

引入版本:v20.1

从数组中移除连续的重复元素,包括 `null` 值。结果数组中值的顺序由源数组中的顺序决定。

**语法**

```sql
arrayCompact(arr)
```

**参数**

- `arr` — 要移除重复项的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回不含重复值的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```


## arrayConcat {#arrayConcat}

引入版本:v1.1

合并作为参数传入的数组。

**语法**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**参数**

- `arr1 [, arr2, ... , arrN]` — 要连接的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回由提供的数组参数合并而成的单个数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=响应
[1, 2, 3, 4, 5, 6]
```


## arrayCount {#arrayCount}

引入版本:v1.1

返回使 `func(arr1[i], ..., arrN[i])` 返回 true 的元素数量。
如果未指定 `func`,则返回数组中非零元素的数量。

`arrayCount` 是一个[高阶函数](/sql-reference/functions/overview#higher-order-functions)。

**语法**

```sql
arrayCount([func, ] arr1, ...)
```

**参数**

- `func` — 可选。应用于数组各元素的函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1, ..., arrN` — N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回使 `func` 返回 true 的元素数量。否则,返回数组中非零元素的数量。[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=响应
5
```


## arrayCumSum {#arrayCumSum}

引入版本：v1.1

返回源数组中元素的累计和数组。如果指定了 lambda 函数，则对每个位置的数组元素应用 lambda 函数后计算累计和。

**语法**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**参数**

- `func` — 可选。应用于每个位置的数组元素的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — 数值类型的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — 可选。大小相同的附加数组，如果指定了 lambda 函数，则作为参数传递给该函数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中元素的累计和数组。结果类型与输入数组的数值类型一致。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**基本用法**

```sql title=查询
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=响应
[1, 2, 3, 4]
```

**使用 lambda**

```sql title=查询
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=响应
[2, 6, 12]
```


## arrayCumSumNonNegative {#arrayCumSumNonNegative}

引入版本：v18.12

返回源数组元素的部分（累计）和数组，将任何负的累计和替换为零。如果指定了 lambda 函数，则通过对每个位置的数组元素应用 lambda 函数来计算总和。

**语法**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**参数**

- `func` — 可选。应用于每个位置的数组元素的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — 数值类型的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — 可选。相同大小的附加数组，如果指定了 lambda 函数，则作为参数传递给该函数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组元素的部分和数组，任何负的累计和都被替换为零。结果类型与输入数组的数值类型一致。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**基本用法**

```sql title=查询
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=响应
[1, 2, 0, 1]
```

**使用 lambda**

```sql title=查询
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=响应
[2, 0, 6]
```


## arrayDifference {#arrayDifference}

引入版本：v1.1

计算数组中相邻元素之间的差值数组。
结果数组的第一个元素为 0，第二个元素为 `arr[1] - arr[0]`，第三个元素为 `arr[2] - arr[1]`，以此类推。
结果数组中元素的类型由减法的类型推断规则确定(例如 `UInt8` - `UInt8` = `Int16`)。

**语法**

```sql
arrayDifference(arr)
```

**参数**

- `arr` — 要计算相邻元素差值的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回相邻数组元素之间的差值数组 [`UInt*`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=响应
[0,1,1,1]
```

**由于结果类型为 Int64 导致溢出的示例**

```sql title=查询
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=响应
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct {#arrayDistinct}

引入版本:v1.1

返回一个仅包含数组中去重元素的数组。

**语法**

```sql
arrayDistinct(arr)
```

**参数**

- `arr` — 需要提取去重元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回包含去重元素的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct {#arrayDotProduct}

引入版本：v23.5

返回两个数组的点积（内积）。

:::note
两个向量的大小必须相等。数组和元组也可以包含混合元素类型。
:::

**语法**

```sql
arrayDotProduct(v1, v2)
```

**参数**

- `v1` — 第一个向量。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) 或 [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
- `v2` — 第二个向量。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) 或 [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**返回值**

两个向量的点积。

:::note
返回类型由参数类型决定。如果数组或元组包含混合元素类型，则结果类型为超类型。
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)

**示例**

**数组示例**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**元组示例**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement {#arrayElement}

引入版本:v1.1

获取提供的数组中索引为 `n` 的元素,其中 `n` 可以是任意整数类型。
如果索引超出数组边界,则返回默认值(数字返回 0,字符串返回空字符串等),
但非常量数组参数和常量索引 0 的情况除外。此时会抛出错误 `Array indices are 1-based`。

:::note
ClickHouse 中的数组索引从 1 开始。
:::

支持负索引。此时会选择从末尾开始计数的相应元素。例如,`arr[-1]` 表示数组中的最后一个元素。

运算符 `[n]` 提供相同的功能。

**语法**

```sql
arrayElement(arr, n)
```

**参数**

- `arr` — 要查询的数组。[`Array(T)`](/sql-reference/data-types/array)。
- `n` — 要获取的元素位置。[`(U)Int*`](/sql-reference/data-types/int-uint)。

**返回值**

返回数组中指定位置的元素 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=响应
2
```

**负索引**

```sql title=查询
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=响应
3
```

**使用 [n] 表示法**

```sql title=查询
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=响应
2
```

**索引超出数组边界**

```sql title=查询
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=响应
0
```


## arrayElementOrNull {#arrayElementOrNull}

引入版本:v1.1

获取提供的数组中索引为 `n` 的元素,其中 `n` 可以是任意整数类型。
如果索引超出数组边界,则返回 `NULL` 而不是默认值。

:::note
ClickHouse 中的数组索引从 1 开始。
:::

支持负索引。在这种情况下,它会从末尾开始选择相应编号的元素。例如,`arr[-1]` 是数组中的最后一个元素。

**语法**

```sql
arrayElementOrNull(arrays)
```

**参数**

- `arrays` — 任意数量的数组参数。[`Array`](/sql-reference/data-types/array)

**返回值**

返回提供的数组参数中指定索引位置的元素。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=响应
2
```

**负索引**

```sql title=查询
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=响应
3
```

**索引超出数组边界**

```sql title=查询
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=响应
NULL
```


## arrayEnumerate {#arrayEnumerate}

引入版本:v1.1

返回数组 `[1, 2, 3, ..., length (arr)]`

此函数通常与 [`ARRAY JOIN`](/sql-reference/statements/select/array-join) 子句配合使用。它允许在应用 `ARRAY JOIN` 后对每个数组仅计数一次。
此函数也可用于高阶函数。例如,可以使用它获取满足条件的元素的数组索引。

**语法**

```sql
arrayEnumerate(arr)
```

**参数**

- `arr` — 要枚举的数组。[`Array`](/sql-reference/data-types/array)

**返回值**

返回数组 `[1, 2, 3, ..., length (arr)]`. [`Array(UInt32)`](/sql-reference/data-types/array)

**示例**

**ARRAY JOIN 基本示例**

```sql title=查询
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=响应
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense {#arrayEnumerateDense}

引入版本:v18.12

返回与源数组大小相同的数组,指示每个元素在源数组中首次出现的位置。

**语法**

```sql
arrayEnumerateDense(arr)
```

**参数**

- `arr` — 要枚举的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回与 `arr` 大小相同的数组,指示每个元素在源数组中首次出现的位置。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

引入版本:v20.1

返回一个与源数组大小相同的数组,指示每个元素在源数组中首次出现的位置。该函数允许对多维数组进行枚举,并可以指定数组内部的查找深度。

**语法**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**参数**

- `clear_depth` — 在指定层级单独枚举元素。必须小于或等于 `max_arr_depth`。[`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — 要枚举的 N 维数组。[`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — 最大有效深度。必须小于或等于 `arr` 的深度。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个数组,表示每个元素在源数组中首次出现的位置 [`Array`](/sql-reference/data-types/array)

**示例**

**基本用法**

```sql title=Query
-- 当 clear_depth=1 且 max_array_depth=1 时,结果与 arrayEnumerateDense 的结果相同。

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**多维数组的用法**

```sql title=Query
-- 在此示例中,arrayEnumerateDenseRanked 用于获取一个数组,该数组指示多维数组中每个元素
-- 在相同值的元素中所处的位置。
-- 对于传入数组的第一行 [10, 10, 30, 20],结果的对应第一行是 [1, 1, 2, 3],
-- 表示 10 是在位置 1 和 2 遇到的第一个数字,30 是在位置 3 遇到的第二个数字,
-- 20 是在位置 4 遇到的第三个数字。
-- 对于第二行 [40, 50, 10, 30],结果的对应第二行是 [4,5,1,2],表示 40
-- 和 50 是在该行位置 1 和 2 遇到的第四个和第五个数字,另一个 10
-- (第一个遇到的数字)在位置 3,30(第二个遇到的数字)在最后位置。

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**增加 clear_depth 的示例**

```sql title=Query
-- 将 clear_depth 设置为 2 会导致每一行单独重新进行枚举。

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq {#arrayEnumerateUniq}

引入版本:v1.1

返回一个与源数组大小相同的数组,指示每个元素在所有相同值的元素中的位置序号。

此函数在使用 `ARRAY JOIN` 和数组元素聚合时非常有用。

该函数可以接受多个相同大小的数组作为参数。在这种情况下,唯一性是基于所有数组中相同位置的元素组成的元组来判断的。

**语法**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**参数**

- `arr1` — 要处理的第一个数组。[`Array(T)`](/sql-reference/data-types/array)
- `arr2, ...` — 可选。用于元组唯一性判断的相同大小的附加数组。[`Array(UInt32)`](/sql-reference/data-types/array)

**返回值**

返回一个数组,其中每个元素表示该元素在所有相同值或元组中的位置序号。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**基本用法**

```sql title=查询
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=响应
[1, 1, 2, 1]
```

**多个数组**

```sql title=查询
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=响应
[1,2,1,1,2,1]
```

**ARRAY JOIN 聚合**

```sql title=查询
-- 每个目标 ID 都计算了转化次数(Goals 嵌套数据结构中的每个元素都是一个已达成的目标,我们称之为转化)
-- 以及会话数。如果没有 ARRAY JOIN,我们会将会话数计为 sum(Sign)。但在这种特殊情况下,
-- 行数被嵌套的 Goals 结构所扩展,因此为了在此之后只计算每个会话一次,我们对
-- arrayEnumerateUniq(Goals.ID) 函数的值应用一个条件。

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=响应
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

引入版本:v20.1

返回一个与源数组维度相同的数组(或多维数组),
指示每个元素在所有相同值的元素中的位置。
该函数允许对多维数组进行枚举,并可以指定在数组内部查找的深度。

**语法**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**参数**

- `clear_depth` — 在指定层级单独枚举元素。小于或等于 `max_arr_depth` 的正整数。[`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — 要枚举的 N 维数组。[`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — 最大有效深度。小于或等于 `arr` 深度的正整数。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个与 `arr` 大小相同的 N 维数组,每个元素显示该元素相对于其他相同值元素的位置。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**示例 1**

```sql title=查询
-- 当 clear_depth=1 且 max_array_depth=1 时,arrayEnumerateUniqRanked 的结果
-- 与 arrayEnumerateUniq 对相同数组给出的结果相同。

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=响应
[1, 1, 2]
```

**示例 2**

```sql title=查询
-- 当 clear_depth=1 且 max_array_depth=1 时,arrayEnumerateUniqRanked 的结果
-- 与 arrayEnumerateUniq 对相同数组给出的结果相同。

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=响应
[1, 1, 2]
```

**示例 3**

```sql title=查询
-- 在此示例中,arrayEnumerateUniqRanked 用于获取一个数组,该数组指示
-- 多维数组中每个元素在所有相同值的元素中的位置。对于传入数组的第一行 [1, 2, 3],
-- 对应的结果是 [1, 1, 1],表示这是第一次遇到 1、2 和 3。
-- 对于传入数组的第二行 [2, 2, 1],对应的结果是 [2, 3, 2],
-- 表示 2 第二次和第三次出现,1 第二次出现。
-- 同样,对于传入数组的第三行 [3],
-- 对应的结果是 [2],表示 3 第二次出现。

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=响应
[[1, 1, 1], [2, 3, 2], [2]]
```

**示例 4**

```sql title=查询
-- 将 clear_depth 更改为 2,会使每行的元素单独枚举。
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=响应
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept {#arrayExcept}

引入版本:v25.9

返回一个数组,包含 `source` 中不存在于 `except` 中的元素,保留原始顺序。

此函数对两个数组执行集合差集运算。对于 `source` 中的每个元素,检查该元素是否存在于 `except` 中(使用精确比较)。如果不存在,则将该元素包含在结果中。

该运算具有以下特性:

1. 保留 `source` 中元素的顺序
2. 如果 `source` 中的重复元素不存在于 `except` 中,则保留这些重复元素
3. NULL 作为独立值处理

**语法**

```sql
arrayExcept(source, except)
```

**参数**

- `source` — 包含待过滤元素的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `except` — 包含要从结果中排除的元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回与输入数组相同类型的数组,包含 `source` 中不存在于 `except` 中的元素。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**basic**

```sql title=查询
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=响应
[1, 2, 2, 4]
```

**with_nulls1**

```sql title=查询
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=响应
[1, NULL, NULL]
```

**with_nulls2**

```sql title=查询
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=响应
[1]
```

**strings**

```sql title=查询
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=响应
['apple', 'cherry']
```


## arrayExists {#arrayExists}

引入版本:v1.1

如果源数组中至少有一个元素使 `func(x[, y1, y2, ... yN])` 返回 true,则返回 `1`。否则返回 `0`。

**语法**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组元素 (`x`) 和条件数组 (`y`) 进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

如果 lambda 函数对至少一个元素返回 true,则返回 `1`,否则返回 `0` [`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```


## arrayFill {#arrayFill}

引入版本:v20.1

`arrayFill` 函数从第一个元素到最后一个元素顺序处理源数组,在每个位置使用源数组和条件数组的元素对 lambda 条件进行求值。当 lambda 函数在位置 i 求值为 false 时,该函数会将该位置的元素替换为数组当前状态中位置 i-1 的元素。无论条件如何,第一个元素始终保持不变。

**语法**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x [, y1, ..., yN])` — 一个 lambda 函数 `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`,对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。N 个条件数组,为 lambda 函数提供额外参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**单数组示例**

```sql title=查询
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=响应
[1, 1, 2, 2]
```

**多数组示例**

```sql title=查询
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=响应
[5, 5, 6, 6]
```


## arrayFilter {#arrayFilter}

引入版本：v1.1

返回一个数组，仅包含源数组中使 lambda 函数返回 true 的元素。

**语法**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组元素（`x`）和条件数组（`y`）进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。N 个条件数组，为 lambda 函数提供额外参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组的子集 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**示例 1**

```sql title=查询
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=响应
['abc World']
```

**示例 2**

```sql title=查询
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=响应
[2]
```


## arrayFirst {#arrayFirst}

引入版本:v1.1

返回源数组中第一个使 `func(x[, y1, y2, ... yN])` 返回 true 的元素,否则返回默认值。

**语法**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组元素 (`x`) 和条件数组 (`y`) 进行操作的 lambda 函数。[Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中第一个使 `λ` 为 true 的元素,否则返回 `T` 的默认值。

**示例**

**使用示例**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**无匹配项**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayFirstIndex {#arrayFirstIndex}

引入版本:v1.1

返回源数组中第一个使 `func(x[, y1, y2, ... yN])` 返回 true 的元素的索引,否则返回 `0`。

**语法**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 一个 lambda 函数,对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作。[Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。N 个条件数组,为 lambda 函数提供额外的参数。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中第一个使 `func` 为 true 的元素的索引,否则返回 `0`。[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=响应
2
```

**无匹配项**

```sql title=查询
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=响应
0
```


## arrayFirstOrNull {#arrayFirstOrNull}

引入版本：v1.1

返回源数组中第一个使 `func(x[, y1, y2, ... yN])` 返回 true 的元素，否则返回 `NULL`。

**语法**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 待处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。N 个条件数组，为 lambda 函数提供额外参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中第一个使 `func` 为 true 的元素，否则返回 `NULL`。

**示例**

**使用示例**

```sql title=查询
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=响应
b
```

**无匹配结果**

```sql title=查询
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=响应
NULL Nullable(UInt8)
```


## arrayFlatten {#arrayFlatten}

引入版本:v20.1

将嵌套数组转换为扁平数组。

功能:

- 适用于任意深度的嵌套数组。
- 不会改变已经扁平化的数组。

扁平化后的数组包含所有源数组中的全部元素。

**语法**

```sql
arrayFlatten(arr)
```

**别名**: `flatten`

**参数**

- `arr` — 多维数组。[`Array(Array(T))`](/sql-reference/data-types/array)

**返回值**

返回多维数组扁平化后的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=响应
[1, 2, 3]
```


## arrayFold {#arrayFold}

引入版本：v23.10

对一个或多个大小相等的数组应用 lambda 函数，并将结果收集到累加器中。

**语法**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**参数**

- `λ(x, x1 [, x2, x3, ... xN])` — lambda 函数 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`，其中 `F` 是应用于 `acc` 和来自 `x` 的数组值的操作，`acc` 的结果会被重复使用。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1 [, arr2, arr3, ... arrN]` — 要操作的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)
- `acc` — 累加器值，其类型与 Lambda 函数的返回类型相同。

**返回值**

返回最终的 `acc` 值。

**示例**

**使用示例**

```sql title=查询
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=响应
23
```

**斐波那契数列**

```sql title=查询
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=响应
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**使用多个数组的示例**

```sql title=查询
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=响应
300
```


## arrayIntersect {#arrayIntersect}

引入版本:v1.1

接受多个数组,返回一个包含所有源数组共有元素的数组。结果仅包含唯一值。

**语法**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**参数**

- `arrN` — 用于生成新数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回一个包含所有 N 个数组共有的不同元素的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex {#arrayJaccardIndex}

引入版本：v23.7

返回两个数组的 [Jaccard 系数](https://en.wikipedia.org/wiki/Jaccard_index)。

**语法**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**参数**

- `arr_x` — 第一个数组。[`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — 第二个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回 `arr_x` 和 `arr_y` 的 Jaccard 系数。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin {#arrayJoin}

引入版本:v1.1

`arrayJoin` 函数接收包含数组的行并将其展开,为数组中的每个元素生成一行。
这与 ClickHouse 中的常规函数不同,常规函数在同一行内将输入值映射到输出值,
而聚合函数则接收一组行并将它们"压缩"或"归约"为单个汇总行
(或在使用 `GROUP BY` 时归约为汇总行中的单个值)。

除应用此函数的列外,其他列中的所有值都会被简单复制;
应用函数的列中的值会被替换为相应的数组元素值。

**语法**

```sql
arrayJoin(arr)
```

**参数**

- `arr` — 要展开的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回从 `arr` 展开的行集合。

**示例**

**基本用法**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin 影响查询的所有部分**

```sql title=Query
-- arrayJoin 函数影响查询的所有部分,包括 WHERE 子句。注意结果为 2,尽管子查询只返回了 1 行。

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**使用多个 arrayJoin 函数**

```sql title=Query
-- 查询可以使用多个 arrayJoin 函数。在这种情况下,转换会执行多次,行数会相乘。

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**由于优化导致的意外结果**

```sql title=Query
-- 由于优化,对同一表达式使用多个 arrayJoin 可能不会产生预期结果。
-- 对于这些情况,请考虑通过不影响连接结果的额外操作来修改重复的数组表达式。
-- 例如 arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- 技术上是正确的,但会导致结果集为空
    arrayJoin(arrayConcat(dice, [])) as second_throw -- 有意更改表达式以强制重新求值
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─第一次投掷─┬─第二次投掷─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**使用 ARRAY JOIN 语法**

```sql title=Query
-- 注意下面 `SELECT` 查询中的 ARRAY JOIN 语法,它提供了更广泛的功能。
-- ARRAY JOIN 允许您同时转换具有相同元素数量的多个数组。

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Tuple 的使用**

```sql title=Query
-- 也可以使用 Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast {#arrayLast}

引入版本：v1.1

返回源数组中使 lambda 函数 `func(x [, y1, y2, ... yN])` 返回 true 的最后一个元素，否则返回默认值。

**语法**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组元素（`x`）和条件数组（`y`）进行操作的 lambda 函数。[Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1, ... , condN]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中使 `func` 返回 true 的最后一个元素，否则返回 `T` 类型的默认值。

**示例**

**使用示例**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**无匹配项**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayLastIndex {#arrayLastIndex}

引入版本:v1.1

返回源数组中最后一个使 `func(x[, y1, y2, ... yN])` 返回 true 的元素的索引,否则返回 0。

**语法**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 待处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中最后一个使 `func` 为 true 的元素的索引,否则返回 `0`。[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**无匹配项**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull {#arrayLastOrNull}

引入版本:v1.1

返回源数组中使 lambda 函数 `func(x [, y1, y2, ... yN])` 返回 true 的最后一个元素,否则返回 `NULL`。

**语法**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x [, y1, ..., yN])` — 对源数组元素 (`x`) 和条件数组 (`y`) 进行操作的 lambda 函数。[Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。 - `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)。 - `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中使 `λ` 返回 true 的最后一个元素,否则返回 `NULL`。

**示例**

**使用示例**

```sql title=查询
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=响应
c
```

**无匹配**

```sql title=查询
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=响应
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance {#arrayLevenshteinDistance}

引入版本：v25.4

计算两个数组的 Levenshtein 距离。

**语法**

```sql
arrayLevenshteinDistance(from, to)
```

**参数**

- `from` — 第一个数组。[`Array(T)`](/sql-reference/data-types/array)。
- `to` — 第二个数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

第一个数组和第二个数组之间的 Levenshtein 距离。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```


## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

引入版本：v25.4

计算两个数组之间的 Levenshtein 距离,可为每个元素指定自定义权重。
数组的元素数量应与其对应的权重数量相匹配。

**语法**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**参数**

- `from` — 第一个数组。[`Array(T)`](/sql-reference/data-types/array)。
- `to` — 第二个数组。[`Array(T)`](/sql-reference/data-types/array)。
- `from_weights` — 第一个数组的权重。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — 第二个数组的权重。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**返回值**

第一个数组和第二个数组之间的 Levenshtein 距离,每个元素使用自定义权重。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=查询
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=响应
14
```


## arrayMap {#arrayMap}

引入版本: v1.1

通过对原始数组的每个元素应用 lambda 函数,返回一个新数组。

**语法**

```sql
arrayMap(func, arr)
```

**参数**

- `func` — 对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — 要处理的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回由 lambda 函数结果组成的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**从不同数组创建元素元组**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax {#arrayMax}

引入版本:v21.1

返回源数组中的最大元素。

如果指定了 lambda 函数 `func`,则返回 lambda 结果的最大值。

**语法**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。对源数组元素 (`x`) 和条件数组 (`y`) 进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中的最大元素,如果提供了 lambda 函数,则返回 lambda 结果的最大值。

**示例**

**基本示例**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**使用 lambda 函数**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin {#arrayMin}

引入版本:v21.1

返回源数组中的最小元素。

如果指定了 lambda 函数 `func`,则返回 lambda 结果的最小值。

**语法**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。对源数组元素 (`x`) 和条件数组 (`y`) 进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中的最小元素,如果提供了 lambda 函数,则返回 lambda 结果的最小值。

**示例**

**基本示例**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**使用 lambda 函数**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```


## arrayNormalizedGini {#arrayNormalizedGini}

引入版本:v25.1

计算归一化基尼系数。

**语法**

```sql
arrayNormalizedGini(predicted, label)
```

**参数**

- `predicted` — 预测值。[`Array(T)`](/sql-reference/data-types/array)
- `label` — 实际值。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

包含预测值的基尼系数、归一化值的基尼系数以及归一化基尼系数(= 前两个基尼系数的比率)的元组 [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**示例**

**使用示例**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort {#arrayPartialReverseSort}

引入版本：v23.2

此函数与 `arrayReverseSort` 相同，但增加了 `limit` 参数以支持部分排序。

:::tip
若要仅保留已排序的元素，请使用 `arrayResize`。
:::

**语法**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**参数**

- `f(arr[, arr1, ... ,arrN])` — 应用于数组 `x` 元素的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — 待排序的数组。[`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — 当 `f` 接受多个参数时的 N 个附加数组。[`Array(T)`](/sql-reference/data-types/array)
- `limit` — 排序执行的截止索引值。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回与原数组大小相同的数组，其中范围 `[1..limit]` 内的元素按降序排序。其余元素 `(limit..N]` 的顺序不确定。

**示例**

**simple_int**

```sql title=查询
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=响应
[9, 5, 1, 3]
```

**simple_string**

```sql title=查询
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=响应
['lasso','gladly','expenses','embolism']
```

**retain_sorted**

```sql title=查询
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=响应
[9, 5]
```

**lambda_simple**

```sql title=查询
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=响应
[1, 3, 5, 9]
```

**lambda_complex**

```sql title=查询
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=响应
[0, 1, 2]
```


## arrayPartialShuffle {#arrayPartialShuffle}

引入版本:v23.2

返回一个与原数组大小相同的数组,其中范围 `[1..limit]` 内的元素是原数组的随机子集。剩余的 `(limit..n]` 范围将包含不在 `[1..limit]` 范围内的元素,顺序不确定。limit 的值应在 `[1..n]` 范围内。超出该范围的值等同于执行完整的 `arrayShuffle`:

:::note
此函数不会物化常量。

`limit` 的值应在 `[1..N]` 范围内。超出该范围的值等同于执行完整的 [`arrayShuffle`](#arrayShuffle)。
:::

**语法**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**参数**

- `arr` — 要打乱的数组。[`Array(T)`](/sql-reference/data-types/array)
- `seed` — 可选。用于随机数生成的种子。如果未提供,则使用随机种子。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `limit` — 可选。限制元素交换的数量,范围为 `[1..N]`。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

部分打乱元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**no_limit1**

```sql title=查询
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=响应
[2, 4, 3, 1]
```

**no_limit2**

```sql title=查询
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=响应
[4, 1, 3, 2]
```

**random_seed**

```sql title=查询
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=响应
[3, 4, 1, 2]
```

**explicit_seed**

```sql title=查询
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=响应
[3, 2, 1, 4]
```

**materialize**

```sql title=查询
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=响应
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort {#arrayPartialSort}

引入版本：v23.2

此函数与 `arraySort` 相同，但增加了一个 `limit` 参数以支持部分排序。

:::tip
若要仅保留已排序的元素，请使用 `arrayResize`。
:::

**语法**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**参数**

- `f(arr[, arr1, ... ,arrN])` — 应用于数组 `x` 元素的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — 待排序的数组。[`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — 当 `f` 接受多个参数时的 N 个附加数组。[`Array(T)`](/sql-reference/data-types/array)
- `limit` — 排序执行到的索引值。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回与原数组大小相同的数组，其中范围 `[1..limit]` 内的元素按升序排序。其余元素 `(limit..N]` 的顺序不确定。

**示例**

**simple_int**

```sql title=查询
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=响应
[1, 3, 5, 9]
```

**simple_string**

```sql title=查询
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=响应
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain_sorted**

```sql title=查询
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=响应
[1, 3]
```

**lambda_simple**

```sql title=查询
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=响应
[9, 5, 1, 3]
```

**lambda_complex**

```sql title=查询
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=响应
[2, 1, 0]
```


## arrayPopBack {#arrayPopBack}

引入版本:v1.1

从数组中移除最后一个元素。

**语法**

```sql
arrayPopBack(arr)
```

**参数**

- `arr` — 要移除最后一个元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回与 `arr` 相同但不包含最后一个元素的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```


## arrayPopFront {#arrayPopFront}

引入版本:v1.1

移除数组的第一个元素。

**语法**

```sql
arrayPopFront(arr)
```

**参数**

- `arr` — 需要移除第一个元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回与 `arr` 相同但不包含第一个元素的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```


## arrayProduct {#arrayProduct}

引入版本:v21.1

返回源数组中所有元素的乘积。

如果指定了 lambda 函数 `func`,则返回 lambda 函数结果的乘积。

**语法**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中所有元素的乘积,如果提供了 lambda 函数,则返回 lambda 函数结果的乘积。[`Float64`](/sql-reference/data-types/float)

**示例**

**基本示例**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**使用 lambda 函数**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack {#arrayPushBack}

引入版本:v1.1

向数组末尾添加一个元素。

**语法**

```sql
arrayPushBack(arr, x)
```

**参数**

- `arr` — 要在末尾添加值 `x` 的数组。[`Array(T)`](/sql-reference/data-types/array)
- `x` — 要添加到数组末尾的单个值。[`Array(T)`](/sql-reference/data-types/array)。

:::note

- 数字数组只能添加数字,字符串数组只能添加字符串。
- 添加数字时,ClickHouse 会自动将 `x` 的类型设置为数组的数据类型。
- 可以为 `NULL`。该函数会向数组添加一个 `NULL` 元素,数组元素的类型将转换为 `Nullable`。

有关 ClickHouse 中数据类型的更多信息,请参阅[数据类型](/sql-reference/data-types)。
:::

**返回值**

返回一个与 `arr` 相同的数组,但在数组末尾添加了额外的值 `x` [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=响应
['a','b']
```


## arrayPushFront {#arrayPushFront}

引入版本：v1.1

在数组开头添加一个元素。

**语法**

```sql
arrayPushFront(arr, x)
```

**参数**

- `arr` — 要在其开头添加值 `x` 的数组。[`Array(T)`](/sql-reference/data-types/array)。
- `x` — 要添加到数组开头的单个值。[`Array(T)`](/sql-reference/data-types/array)。

:::note

- 数字数组只能添加数字，字符串数组只能添加字符串。
- 添加数字时，ClickHouse 会自动将 `x` 的类型设置为数组的数据类型。
- 可以为 `NULL`。该函数会向数组添加一个 `NULL` 元素，并且数组元素的类型会转换为 `Nullable`。

有关 ClickHouse 中数据类型的更多信息，请参阅[数据类型](/sql-reference/data-types)。
:::

**返回值**

返回一个与 `arr` 相同的数组，但在数组开头添加了额外的值 `x`。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=响应
['a','b']
```


## arrayROCAUC {#arrayROCAUC}

引入版本：v20.4

计算接收者操作特征（ROC）曲线下的面积。
ROC 曲线通过在所有阈值下，将真正例率（TPR）绘制在 y 轴、假正例率（FPR）绘制在 x 轴来创建。
结果值范围从零到一，值越高表示模型性能越好。

ROC AUC（也简称为 AUC）是机器学习中的一个概念。
更多详细信息，请参见[此处](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[此处](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)和[此处](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)。

**语法**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**别名**：`arrayAUC`

**参数**

- `scores` — 预测模型给出的分数。[`Array((U)Int*)`](/sql-reference/data-types/array) 或 [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — 样本的标签，通常正样本为 1，负样本为 0。[`Array((U)Int*)`](/sql-reference/data-types/array) 或 [`Enum`](/sql-reference/data-types/enum)
- `scale` — 可选。决定是否返回归一化面积。如果为 false，则返回 TP（真正例）x FP（假正例）曲线下的面积。默认值：true。[`Bool`](/sql-reference/data-types/boolean)
- `partial_offsets` —
- 一个包含四个非负整数的数组，用于计算 ROC 曲线下的部分面积（相当于 ROC 空间的垂直带）而不是整个 AUC。此选项对于 ROC AUC 的分布式计算很有用。数组必须包含以下元素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]。非负[整数](../data-types/int-uint.md)的[数组](/sql-reference/data-types/array)。可选。
  - `higher_partitions_tp`：高分分区中正标签的数量。
  - `higher_partitions_fp`：高分分区中负标签的数量。
  - `total_positives`：整个数据集中正样本的总数。
  - `total_negatives`：整个数据集中负样本的总数。

:::note
当使用 `arr_partial_offsets` 时，`arr_scores` 和 `arr_labels` 应该只是整个数据集的一个分区，包含一个分数区间。
数据集应该被划分为连续的分区，其中每个分区包含分数落在特定范围内的数据子集。
例如：

- 一个分区可以包含范围 [0, 0.5) 内的所有分数。
- 另一个分区可以包含范围 [0.5, 1.0] 内的分数。
:::

**返回值**

返回接收者操作特征（ROC）曲线下的面积。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```


## arrayRandomSample {#arrayRandomSample}

引入版本：v23.10

返回包含输入数组中 `samples` 个随机元素的子集。如果 `samples` 超过输入数组的大小，则样本大小将限制为数组的大小，即返回所有数组元素，但不保证其顺序。该函数可以处理一维数组和嵌套数组。

**语法**

```sql
arrayRandomSample(arr, samples)
```

**参数**

- `arr` — 要从中抽取元素的输入数组或多维数组。[`Array(T)`](/sql-reference/data-types/array)
- `samples` — 随机样本中要包含的元素数量。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

一个包含从输入数组中随机抽取的元素的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=响应
['cherry','apple']
```

**使用多维数组**

```sql title=查询
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=响应
[[3,4],[5,6]]
```


## arrayReduce {#arrayReduce}

引入版本:v1.1

对数组元素应用聚合函数并返回其结果。
聚合函数的名称以单引号字符串形式传递,例如 `'max'`、`'sum'`。
使用参数化聚合函数时,参数在函数名称后的括号中指定,例如 `'uniqUpTo(6)'`。

**语法**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**参数**

- `agg_f` — 聚合函数的名称,必须是常量。[`String`](/sql-reference/data-types/string)
- `arr1 [, arr2, ... , arrN)]` — 与 `agg_f` 的参数对应的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回聚合函数的结果

**示例**

**使用示例**

```sql title=查询
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=响应
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**使用多参数聚合函数的示例**

```sql title=查询
--如果聚合函数接受多个参数,则必须将此函数应用于多个大小相同的数组。

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=响应
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**使用参数化聚合函数的示例**

```sql title=查询
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=响应
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges {#arrayReduceInRanges}

引入版本：v20.4

对给定范围内的数组元素应用聚合函数，并返回包含每个范围对应结果的数组。
该函数返回的结果与多次调用 `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)` 相同。

**语法**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**参数**

- `agg_f` — 要使用的聚合函数名称。[`String`](/sql-reference/data-types/string)
- `ranges` — 聚合的范围。元组数组 `(i, r)`，其中 `i` 为起始索引，`r` 为聚合范围长度。[`Array(T)`](/sql-reference/data-types/array) 或 [`Tuple(T)`](/sql-reference/data-types/tuple)
- `arr1 [, arr2, ... ,arrN)]` — 传递给聚合函数的 N 个数组参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回包含指定范围内聚合函数结果的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=响应
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove {#arrayRemove}

引入版本:v25.11

从数组中移除所有等于给定值的元素。
NULL 值被视为相等。

**语法**

```sql
arrayRemove(arr, elem)
```

**别名**:`array_remove`

**参数**

- `arr` — Array(T) - `elem` — T

**返回值**

返回源数组的子集 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**示例 1**

```sql title=查询
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=响应
[1, 3]
```

**示例 2**

```sql title=查询
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=响应
['a', 'b']
```


## arrayResize {#arrayResize}

引入版本：v1.1

更改数组的长度。

**语法**

```sql
arrayResize(arr, size[, extender])
```

**参数**

- `arr` — 要调整大小的数组。[`Array(T)`](/sql-reference/data-types/array)
- `size` — 数组的新长度。
  如果 `size` 小于数组的原始大小,则从右侧截断数组。
  如果 `size` 大于数组的初始大小,则使用 `extender` 值或数组元素数据类型的默认值从右侧扩展数组。
- `extender` — 用于扩展数组的值。可以为 `NULL`。

**返回值**

长度为 `size` 的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**示例 1**

```sql title=查询
SELECT arrayResize([1], 3);
```

```response title=响应
[1,0,0]
```

**示例 2**

```sql title=查询
SELECT arrayResize([1], 3, NULL);
```

```response title=响应
[1,NULL,NULL]
```


## arrayReverse {#arrayReverse}

引入版本:v1.1

反转给定数组的元素顺序。

:::note
函数 `reverse(arr)` 具有相同的功能,但除了数组外还支持其他数据类型。
:::

**语法**

```sql
arrayReverse(arr)
```

**参数**

- `arr` — 要反转的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个与原数组大小相同的数组,包含逆序排列的元素 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill {#arrayReverseFill}

引入版本：v20.1

`arrayReverseFill` 函数从源数组的最后一个元素开始逆向处理至第一个元素，在每个位置使用源数组和条件数组的元素对 lambda 条件进行求值。当条件在位置 i 求值为 false 时，该函数将该位置的元素替换为数组当前状态中位置 i+1 的元素。无论条件如何，最后一个元素始终保持不变。

**语法**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组（`x`）和条件数组（`y`）的元素进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其中源数组的元素被 lambda 函数的结果替换。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**单数组示例**

```sql title=查询
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=响应
[1, 2, 2, NULL]
```

**双数组示例**

```sql title=查询
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=响应
[5, 6, 6, 2]
```


## arrayReverseSort {#arrayReverseSort}

引入版本：v1.1

按降序对数组元素进行排序。
如果指定了函数 `f`，则根据该函数应用于数组元素后的结果对提供的数组进行排序，然后将排序后的数组反转。
如果 `f` 接受多个参数，则需要向 `arrayReverseSort` 函数传递多个数组，这些数组将对应于 `func` 的参数。

如果待排序的数组包含 `-Inf`、`NULL`、`NaN` 或 `Inf`，它们将按以下顺序排序：

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` 是一个[高阶函数](/sql-reference/functions/overview#higher-order-functions)。

**语法**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**参数**

- `f(y1[, y2 ... yN])` — 应用于数组 `x` 元素的 lambda 函数。
- `arr` — 待排序的数组。[`Array(T)`](/sql-reference/data-types/array)
- `arr1, ..., yN` — 可选。当 `f` 接受多个参数时，需要提供 N 个额外的数组。

**返回值**

如果未提供 lambda 函数，则返回按降序排序的数组 `x`；否则返回根据提供的 lambda 函数逻辑排序后再反转的数组。[`Array(T)`](/sql-reference/data-types/array)。

**示例**

**示例 1**

```sql title=查询
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=响应
[5,3,4]
```

**示例 2**

```sql title=查询
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=响应
[4,3,5]
```


## arrayReverseSplit {#arrayReverseSplit}

引入版本：v20.1

将源数组拆分为多个数组。当 `func(x[, y1, ..., yN])` 返回非零值时，数组将在该元素的右侧进行拆分。数组不会在最后一个元素之后拆分。

**语法**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组元素（`x`）和条件数组（`y`）进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回数组的数组。[`Array(Array(T))`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft {#arrayRotateLeft}

引入版本:v23.8

将数组向左旋转指定数量的元素。`n` 为负值时,将按其绝对值向右旋转。

**语法**

```sql
arrayRotateLeft(arr, n)
```

**参数**

- `arr` — 要旋转元素的数组。[`Array(T)`](/sql-reference/data-types/array)。
- `n` — 要旋转的元素数量。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**返回值**

向左旋转指定数量元素后的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=响应
[3,4,5,6,1,2]
```

**n 为负值**

```sql title=查询
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=响应
[5,6,1,2,3,4]
```


## arrayRotateRight {#arrayRotateRight}

引入版本：v23.8

将数组向右旋转指定数量的元素。当 `n` 为负值时，将按其绝对值向左旋转。

**语法**

```sql
arrayRotateRight(arr, n)
```

**参数**

- `arr` — 要旋转元素的数组。[`Array(T)`](/sql-reference/data-types/array)。
- `n` — 要旋转的元素数量。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**返回值**

向右旋转指定数量元素后的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=响应
[5,6,1,2,3,4]
```

**n 为负值**

```sql title=查询
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=响应
[3,4,5,6,1,2]
```


## arrayShiftLeft {#arrayShiftLeft}

引入版本:v23.8

将数组向左移动指定数量的元素。
新元素使用提供的参数填充,如果未提供则使用数组元素类型的默认值。
如果元素数量为负数,则数组向右移动。

**语法**

```sql
arrayShiftLeft(arr, n[, default])
```

**参数**

- `arr` — 要移动元素的数组。[`Array(T)`](/sql-reference/data-types/array)。 - `n` — 要移动的元素数量。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。 - `default` — 可选。新元素的默认值。

**返回值**

向左移动指定数量元素后的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=响应
[3,4,5,6,0,0]
```

**n 为负值**

```sql title=查询
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=响应
[0,0,1,2,3,4]
```

**使用默认值**

```sql title=查询
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=响应
[3,4,5,6,42,42]
```


## arrayShiftRight {#arrayShiftRight}

引入版本:v23.8

将数组向右移动指定数量的元素。
新元素使用提供的参数填充,如未提供则使用数组元素类型的默认值。
如果元素数量为负数,则数组向左移动。

**语法**

```sql
arrayShiftRight(arr, n[, default])
```

**参数**

- `arr` — 要移动元素的数组。[`Array(T)`](/sql-reference/data-types/array)
- `n` — 要移动的元素数量。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `default` — 可选。新元素的默认值。

**返回值**

向右移动指定数量元素后的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=响应
[0, 0, 1, 2, 3, 4]
```

**n 为负值**

```sql title=查询
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=响应
[3, 4, 5, 6, 0, 0]
```

**使用默认值**

```sql title=查询
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=响应
[42, 42, 1, 2, 3, 4]
```


## arrayShingles {#arrayShingles}

引入版本:v24.1

生成一个 shingle 数组(类似于字符串的 ngram),即从输入数组中提取指定长度的连续子数组。

**语法**

```sql
arrayShingles(arr, l)
```

**参数**

- `arr` — 用于生成 shingle 数组的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `l` — 每个 shingle 的长度。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

由生成的 shingle 组成的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle {#arrayShuffle}

引入版本：v23.2

返回一个与原数组大小相同的数组，其中包含随机打乱顺序的元素。
元素重新排序的方式确保了这些元素的每种可能排列都有相同的出现概率。

:::note
此函数不会物化常量。
:::

**语法**

```sql
arrayShuffle(arr [, seed])
```

**参数**

- `arr` — 要打乱的数组。[`Array(T)`](/sql-reference/data-types/array)
- `seed (可选)` — 可选参数。用于随机数生成的种子。如果未提供，则使用随机种子。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

元素已打乱的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**不使用种子的示例（结果不稳定）**

```sql title=查询
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=响应
[1,4,2,3]
```

**使用种子的示例（结果稳定）**

```sql title=查询
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=响应
[3,2,1,4]
```


## arraySimilarity {#arraySimilarity}

引入版本:v25.4

基于加权 Levenshtein 距离计算两个数组的相似度,返回值范围为 `0` 到 `1`。

**语法**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**参数**

- `from` — 第一个数组 [`Array(T)`](/sql-reference/data-types/array)
- `to` — 第二个数组 [`Array(T)`](/sql-reference/data-types/array)
- `from_weights` — 第一个数组的权重 [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — 第二个数组的权重 [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**返回值**

基于加权 Levenshtein 距离返回两个数组的相似度,取值范围为 `0` 到 `1` [`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```


## arraySlice {#arraySlice}

引入版本：v1.1

返回数组的切片，包括 `NULL` 元素。

**语法**

```sql
arraySlice(arr, offset [, length])
```

**参数**

- `arr` — 要切片的数组。[`Array(T)`](/sql-reference/data-types/array)
- `offset` — 从数组边缘的偏移量。正值表示从左侧偏移，负值表示从右侧偏移。数组元素的编号从 `1` 开始。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `length` — 所需切片的长度。如果指定负值，函数返回开区间切片 `[offset, array_length - length]`。如果省略该值，函数返回切片 `[offset, the_end_of_array]`。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回从指定 `offset` 开始、包含 `length` 个元素的数组切片 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=响应
[2, NULL, 4]
```


## arraySort {#arraySort}

引入版本：v1.1

对提供的数组元素按升序排序。
如果指定了 lambda 函数 `f`，则排序顺序由该 lambda 函数应用于数组每个元素后的结果决定。
如果 lambda 函数接受多个参数，则需要向 `arraySort` 函数传递多个数组，这些数组将分别对应 `f` 的各个参数。

如果待排序的数组包含 `-Inf`、`NULL`、`NaN` 或 `Inf`，它们将按以下顺序排序：

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` 是一个[高阶函数](/sql-reference/functions/overview#higher-order-functions)。

**语法**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**参数**

- `f(y1[, y2 ... yN])` — 应用于数组 `x` 元素的 lambda 函数。
- `arr` — 待排序的数组。[`Array(T)`](/sql-reference/data-types/array)
- `arr1, ..., yN` — 可选。当 `f` 接受多个参数时，需要提供 N 个额外的数组。

**返回值**

如果未提供 lambda 函数，则返回按升序排序的数组 `arr`；否则返回根据提供的 lambda 函数逻辑排序后的数组。[`Array(T)`](/sql-reference/data-types/array)。

**示例**

**示例 1**

```sql title=查询
SELECT arraySort([1, 3, 3, 0]);
```

```response title=响应
[0,1,3,3]
```

**示例 2**

```sql title=查询
SELECT arraySort(['hello', 'world', '!']);
```

```response title=响应
['!','hello','world']
```

**示例 3**

```sql title=查询
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=响应
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit {#arraySplit}

引入版本:v20.1

将源数组拆分为多个数组。当 `func(x [, y1, ..., yN])` 返回非零值时,数组将在该元素的左侧进行拆分。数组不会在第一个元素之前拆分。

**语法**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 对源数组元素 (`x`) 和条件数组 (`y`) 进行操作的 Lambda 函数。[Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要拆分的源数组 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。为 Lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回数组的数组 [`Array(Array(T))`](/sql-reference/data-types/array)。

**示例**

**使用示例**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```


## arraySum {#arraySum}

引入版本:v21.1

返回源数组中所有元素的总和。

如果指定了 lambda 函数 `func`,则返回 lambda 函数结果的总和。

**语法**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
- `, cond1_arr, ... , condN_arr]` — 可选。为 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中所有元素的总和,如果提供了 lambda 函数,则返回 lambda 函数结果的总和。

**示例**

**基本示例**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**使用 lambda 函数**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```


## arraySymmetricDifference {#arraySymmetricDifference}

引入版本:v25.4

接受多个数组,返回一个包含不在所有源数组中同时存在的元素的数组。结果仅包含唯一值。

:::note
_两个以上集合_的对称差在[数学上定义](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)为在奇数个输入集合中出现的所有输入元素的集合。
相比之下,函数 `arraySymmetricDifference` 仅返回不在所有输入集合中同时出现的输入元素的集合。
:::

**语法**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**参数**

- `arrN` — 用于生成新数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回一个包含不在所有源数组中同时存在的不同元素的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion {#arrayUnion}

引入版本：v24.10

接受多个数组并返回一个包含所有源数组中存在的元素的数组。结果仅包含唯一值。

**语法**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**参数**

- `arrN` — 用于构造新数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个包含源数组中所有不重复元素的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=响应
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq {#arrayUniq}

引入版本：v1.1

当传入单个参数时，计算数组中不同元素的数量。
当传入多个参数时，计算由多个数组中对应位置的元素组成的不同**元组**的数量。

例如 `SELECT arrayUniq([1,2], [3,4], [5,6])` 将形成以下元组：

- 位置 1：(1,3,5)
- 位置 2：(2,4,6)

然后计算唯一元组的数量。在本例中为 `2`。

所有传入的数组必须具有相同的长度。

:::tip
如果您想获取数组中唯一项的列表，可以使用 `arrayReduce('groupUniqArray', arr)`。
:::

**语法**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**参数**

- `arr1` — 要计算唯一元素数量的数组。[`Array(T)`](/sql-reference/data-types/array)
- `[, arr2, ..., arrN]` — 可选。用于计算多个数组中对应位置元素组成的唯一元组数量的附加数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

对于单个参数，返回唯一元素的数量。对于多个参数，返回由数组中对应位置的元素组成的唯一元组的数量。
[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**单个参数**

```sql title=查询
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=响应
2
```

**多个参数**

```sql title=查询
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=响应
3
```


## arrayWithConstant {#arrayWithConstant}

引入版本:v20.1

创建一个长度为 `length` 的数组,并用常量 `x` 填充。

**语法**

```sql
arrayWithConstant(N, x)
```

**参数**

- `length` — 数组中的元素数量。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `x` — 数组中 `N` 个元素的值,可以是任意类型。

**返回值**

返回一个包含 `N` 个值为 `x` 的元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayWithConstant(3, 1)
```

```response title=响应
[1, 1, 1]
```


## arrayZip {#arrayZip}

引入版本:v20.1

将多个数组合并为单个数组。结果数组包含源数组的对应元素,这些元素按参数列出的顺序组合成元组。

**语法**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**参数**

- `arr1, arr2, ... , arrN` — 要合并为单个数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组,其元素来自源数组并组合成元组。元组中的数据类型与输入数组的类型相同,且顺序与传入数组的顺序一致。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=响应
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned {#arrayZipUnaligned}

引入版本：v20.1

将多个数组合并为单个数组，支持长度不一致的数组。结果数组包含源数组的对应元素，这些元素按参数列出的顺序组合成元组。

**语法**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**参数**

- `arr1, arr2, ..., arrN` — 要合并为单个数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其元素来自源数组并组合成元组。元组中的数据类型与输入数组的类型相同，顺序也与传入数组的顺序一致。[`Array(T)`](/sql-reference/data-types/array) 或 [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**示例**

**使用示例**

```sql title=查询
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=响应
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual {#countEqual}

引入版本:v1.1

返回数组中等于 `x` 的元素个数。等价于 `arrayCount(elem -> elem = x, arr)`。

`NULL` 元素被视为独立的值。

**语法**

```sql
countEqual(arr, x)
```

**参数**

- `arr` — 要搜索的数组。[`Array(T)`](/sql-reference/data-types/array)
- `x` — 要统计的数组中的值。任意类型。

**返回值**

返回数组中等于 `x` 的元素个数 [`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=响应
2
```


## empty {#empty}

引入版本:v1.1

检查输入数组是否为空。

如果数组不包含任何元素,则视为空数组。

:::note
可以通过启用 [`optimize_functions_to_subcolumns` 设置](/operations/settings/settings#optimize_functions_to_subcolumns)进行优化。当 `optimize_functions_to_subcolumns = 1` 时,该函数仅读取 [size0](/sql-reference/data-types/array#array-size) 子列,而不读取和处理整个数组列。查询 `SELECT empty(arr) FROM TABLE;` 将转换为 `SELECT arr.size0 = 0 FROM TABLE;`。
:::

该函数也适用于字符串或 UUID 类型。

**语法**

```sql
empty(arr)
```

**参数**

- `arr` — 输入数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

空数组返回 `1`,非空数组返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate {#emptyArrayDate}

引入版本:v1.1

返回一个空的 Date 数组

**语法**

```sql
emptyArrayDate()
```

**参数**

- 无。

**返回值**

一个空的 Date 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```


## emptyArrayDateTime {#emptyArrayDateTime}

引入版本:v1.1

返回一个空的 DateTime 数组

**语法**

```sql
emptyArrayDateTime()
```

**参数**

- 无。

**返回值**

一个空的 DateTime 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT emptyArrayDateTime
```

```response title=响应
[]
```


## emptyArrayFloat32 {#emptyArrayFloat32}

引入版本：v1.1

返回一个空的 Float32 数组

**Syntax**

```sql
emptyArrayFloat32()
```

**参数**

- 无。

**返回值**

一个空的 Float32 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```


## emptyArrayFloat64 {#emptyArrayFloat64}

引入版本：v1.1

返回一个空的 Float64 数组

**语法**

```sql
emptyArrayFloat64()
```

**参数**

- 无。

**返回值**

一个空的 Float64 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT emptyArrayFloat64
```

```response title=响应
[]
```


## emptyArrayInt16 {#emptyArrayInt16}

引入版本：v1.1

返回一个空的 Int16 数组

**语法**

```sql
emptyArrayInt16()
```

**参数**

- 无。

**返回值**

一个空的 Int16 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```


## emptyArrayInt32 {#emptyArrayInt32}

引入版本：v1.1

返回一个空的 Int32 数组

**Syntax**

```sql
emptyArrayInt32()
```

**参数**

- 无。

**返回值**

空的 Int32 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```


## emptyArrayInt64 {#emptyArrayInt64}

引入版本:v1.1

返回一个空的 Int64 数组

**Syntax**

```sql
emptyArrayInt64()
```

**参数**

- 无。

**返回值**

空的 Int64 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```


## emptyArrayInt8 {#emptyArrayInt8}

引入版本：v1.1

返回一个空的 Int8 数组

**Syntax**

```sql
emptyArrayInt8()
```

**参数**

- 无。

**返回值**

空的 Int8 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```


## emptyArrayString {#emptyArrayString}

引入版本:v1.1

返回一个空字符串数组

**语法**

```sql
emptyArrayString()
```

**参数**

- 无。

**返回值**

一个空字符串数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT emptyArrayString
```

```response title=响应
[]
```


## emptyArrayToSingle {#emptyArrayToSingle}

引入版本:v1.1

接受一个空数组并返回一个包含单个元素的数组,该元素为数组类型的默认值。

**语法**

```sql
emptyArrayToSingle(arr)
```

**参数**

- `arr` — 空数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

包含数组默认类型单个值的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**基本示例**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16 {#emptyArrayUInt16}

引入版本：v1.1

返回一个空的 UInt16 数组

**语法**

```sql
emptyArrayUInt16()
```

**参数**

- 无。

**返回值**

一个空的 UInt16 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT emptyArrayUInt16
```

```response title=响应
[]
```


## emptyArrayUInt32 {#emptyArrayUInt32}

引入版本:v1.1

返回一个空的 UInt32 数组

**语法**

```sql
emptyArrayUInt32()
```

**参数**

- 无。

**返回值**

一个空的 UInt32 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT emptyArrayUInt32
```

```response title=响应
[]
```


## emptyArrayUInt64 {#emptyArrayUInt64}

引入版本：v1.1

返回一个空的 UInt64 数组

**语法**

```sql
emptyArrayUInt64()
```

**参数**

- 无。

**返回值**

一个空的 UInt64 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT emptyArrayUInt64
```

```response title=响应
[]
```


## emptyArrayUInt8 {#emptyArrayUInt8}

引入版本：v1.1

返回一个空的 UInt8 数组

**语法**

```sql
emptyArrayUInt8()
```

**参数**

- 无。

**返回值**

一个空的 UInt8 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT emptyArrayUInt8
```

```response title=响应
[]
```


## has {#has}

引入版本:v1.1

返回数组是否包含指定的元素。

**语法**

```sql
has(arr, x)
```

**参数**

- `arr` — 源数组。[`Array(T)`](/sql-reference/data-types/array)
- `x` — 要在数组中查找的值。

**返回值**

如果数组包含指定的元素则返回 `1`,否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本用法**

```sql title=查询
SELECT has([1, 2, 3], 2)
```

```response title=响应
1
```

**未找到元素**

```sql title=查询
SELECT has([1, 2, 3], 4)
```

```response title=响应
0
```


## hasAll {#hasAll}

引入版本:v1.1

检查一个数组是否为另一个数组的子集。

- 空数组是任何数组的子集。
- `Null` 被视为一个值处理。
- 两个数组中值的顺序不影响结果。

**语法**

```sql
hasAll(set, subset)
```

**参数**

- `set` — 包含一组元素的任意类型数组。[`Array(T)`](/sql-reference/data-types/array)
- `subset` — 与 `set` 共享公共超类型的任意类型数组,包含需要测试是否为 `set` 子集的元素。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

- `1`,如果 `set` 包含 `subset` 中的所有元素。
- `0`,否则。

如果 set 和 subset 元素不共享公共超类型,则抛出 `NO_COMMON_TYPE` 异常。

**示例**

**空数组**

```sql title=查询
SELECT hasAll([], [])
```

```response title=响应
1
```

**包含 NULL 值的数组**

```sql title=查询
SELECT hasAll([1, Null], [Null])
```

```response title=响应
1
```

**包含不同类型值的数组**

```sql title=查询
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=响应
1
```

**包含字符串值的数组**

```sql title=查询
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=响应
1
```

**没有公共类型的数组**

```sql title=查询
SELECT hasAll([1], ['a'])
```

```response title=响应
抛出 NO_COMMON_TYPE 异常
```

**数组的数组**

```sql title=查询
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=响应
0
```


## hasAny {#hasAny}

引入版本：v1.1

检查两个数组是否有交集元素。

- `Null` 被视为一个值进行处理。
- 两个数组中值的顺序不影响结果。

**语法**

```sql
hasAny(arr_x, arr_y)
```

**参数**

- `arr_x` — 任意类型的数组，包含一组元素。[`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — 任意类型的数组,与数组 `arr_x` 共享公共超类型。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

- `1`，如果 `arr_x` 和 `arr_y` 至少有一个相同元素。
- `0`，否则。

如果两个数组的元素不共享公共超类型,则抛出 `NO_COMMON_TYPE` 异常。

**示例**

**一个数组为空**

```sql title=查询
SELECT hasAny([1], [])
```

```response title=响应
0
```

**包含 NULL 值的数组**

```sql title=查询
SELECT hasAny([Null], [Null, 1])
```

```response title=响应
1
```

**包含不同类型值的数组**

```sql title=查询
SELECT hasAny([-128, 1., 512], [1])
```

```response title=响应
1
```

**没有公共类型的数组**

```sql title=查询
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=响应
抛出 `NO_COMMON_TYPE` 异常
```

**数组的数组**

```sql title=查询
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=响应
1
```


## hasSubstr {#hasSubstr}

引入版本:v20.6

检查 array2 的所有元素是否按完全相同的顺序出现在 array1 中。
因此,当且仅当 array1 = prefix + array2 + suffix 时,该函数返回 `1`。

换句话说,该函数会像 `hasAll` 函数一样检查 array2 的所有元素是否包含在 array1 中。
此外,它还会检查这些元素在 array1 和 array2 中的顺序是否一致。

- 如果 array2 为空,该函数返回 `1`。
- `Null` 被视为一个值。换句话说,`hasSubstr([1, 2, NULL, 3, 4], [2,3])` 返回 `0`。但是,`hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` 返回 `1`
- 两个数组中值的顺序很重要。

如果两个数组的任何元素不共享公共超类型,则抛出 `NO_COMMON_TYPE` 异常。

**语法**

```sql
hasSubstr(arr1, arr2)
```

**参数**

- `arr1` — 包含一组元素的任意类型数组。[`Array(T)`](/sql-reference/data-types/array)
- `arr2` — 包含一组元素的任意类型数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

如果数组 `arr1` 包含数组 `arr2`,则返回 `1`。否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**两个数组都为空**

```sql title=查询
SELECT hasSubstr([], [])
```

```response title=响应
1
```

**包含 NULL 值的数组**

```sql title=查询
SELECT hasSubstr([1, Null], [Null])
```

```response title=响应
1
```

**包含不同类型值的数组**

```sql title=查询
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=响应
0
```

**包含字符串的数组**

```sql title=查询
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=响应
1
```

**顺序有效的数组**

```sql title=查询
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=响应
1
```

**顺序无效的数组**

```sql title=查询
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=响应
0
```

**数组的数组**

```sql title=查询
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=响应
1
```

**没有公共类型的数组**

```sql title=查询
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=响应
抛出 `NO_COMMON_TYPE` 异常
```


## indexOf {#indexOf}

引入版本:v1.1

返回数组中第一个值为 'x' 的元素的索引(从 1 开始计数)。
如果数组不包含要查找的值,函数返回 `0`。

`NULL` 元素会被当作普通值处理。

**语法**

```sql
indexOf(arr, x)
```

**参数**

- `arr` — 要搜索 `x` 的数组。[`Array(T)`](/sql-reference/data-types/array)
- `x` — 要查找的值,返回其在 `arr` 中第一次出现的索引。[`UInt64`](/sql-reference/data-types/int-uint)

**返回值**

如果 `x` 存在于 `arr` 中,返回第一个 `x` 的索引(从 1 开始编号)。否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基本示例**

```sql title=查询
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=响应
4
```

**包含 null 值的数组**

```sql title=查询
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=响应
3
```


## indexOfAssumeSorted {#indexOfAssumeSorted}

引入版本:v24.12

返回数组中值为 'x' 的第一个元素的索引(从 `1` 开始)。
如果数组中不包含要查找的值,函数返回 `0`。

:::note
与 `indexOf` 函数不同,此函数假设数组已按升序排序。如果数组未排序,结果是未定义的。
:::

**语法**

```sql
indexOfAssumeSorted(arr, x)
```

**参数**

- `arr` — 要搜索的已排序数组。[`Array(T)`](/sql-reference/data-types/array)
- `x` — 要在已排序数组 `arr` 中查找的值,函数将返回第一个匹配元素的索引。[`UInt64`](/sql-reference/data-types/int-uint)

**返回值**

如果 `arr` 中存在 `x`,则返回第一个 `x` 的索引(从 1 开始编号)。否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基本示例**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```


## length {#length}

引入版本:v1.1

计算字符串或数组的长度。

- 对于 String 或 FixedString 参数:计算字符串中的字节数。
- 对于 Array 参数:计算数组中的元素数量。
- 如果应用于 FixedString 参数,该函数是常量表达式。

请注意,字符串中的字节数与 Unicode "码点"数量不同,也与 Unicode "字形簇"数量(我们通常称之为"字符")不同,更与可见字符串宽度不同。

字符串中可以包含 ASCII NULL 字节,它们也会被计入。

**语法**

```sql
length(x)
```

**别名**:`OCTET_LENGTH`

**参数**

- `x` — 要计算字节数(对于 String/FixedString)或元素数量(对于 Array)的值。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring) 或 [`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回 String/FixedString `x` 中的字节数 / 数组 `x` 中的元素数量 [`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**字符串示例**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**数组示例**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**常量表达式示例**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**Unicode 示例**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ASCII 与 UTF-8 示例**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty {#notEmpty}

引入版本：v1.1

检查输入数组是否非空。

如果数组至少包含一个元素，则认为该数组非空。

:::note
可以通过启用 [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns) 设置来优化。当 `optimize_functions_to_subcolumns = 1` 时，该函数仅读取 [size0](/sql-reference/data-types/array#array-size) 子列，而不是读取和处理整个数组列。查询 `SELECT notEmpty(arr) FROM table` 会转换为 `SELECT arr.size0 != 0 FROM TABLE`。
:::

该函数也适用于字符串或 UUID。

**语法**

```sql
notEmpty(arr)
```

**参数**

- `arr` — 输入数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

对于非空数组返回 `1`，对于空数组返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT notEmpty([1,2]);
```

```response title=响应
1
```


## range {#range}

引入版本：v1.1

返回一个从 `start` 到 `end - 1` 的数字数组,步长为 `step`。

支持的类型包括:

- `UInt8/16/32/64`
- `Int8/16/32/64]`

- 所有参数 `start`、`end`、`step` 必须是上述支持的类型之一。返回数组的元素类型将是参数类型的超类型。
- 如果函数返回的数组总长度超过设置 [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block) 指定的元素数量,将抛出异常。
- 如果任何参数的类型为 Nullable(nothing),则返回 `NULL`。如果任何参数的值为 `NULL`(Nullable(T) 类型),将抛出异常。

**语法**

```sql
range([start, ] end [, step])
```

**参数**

- `start` — 可选。数组的第一个元素。如果使用 `step` 则为必需。默认值:`0`。
- `end` — 必需。数组构造的上界(不包含该值)。
- `step` — 可选。数组中每个元素之间的增量步长。默认值:`1`。

**返回值**

从 `start` 到 `end - 1` 的数字数组,步长为 `step`。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=响应
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate {#replicate}

引入版本:v1.1

创建一个使用单个值填充的数组。

**语法**

```sql
replicate(x, arr)
```

**参数**

- `x` — 用于填充结果数组的值。[`Any`](/sql-reference/data-types)
- `arr` — 数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个与 `arr` 长度相同、使用值 `x` 填充的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=查询
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=响应
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse {#reverse}

引入版本:v1.1

反转输入数组中元素的顺序或输入字符串中字符的顺序。

**语法**

```sql
reverse(arr | str)
```

**参数**

- `arr | str` — 源数组或字符串。[`Array(T)`](/sql-reference/data-types/array) 或 [`String`](/sql-reference/data-types/string)

**返回值**

返回元素或字符顺序反转后的数组或字符串。

**示例**

**反转数组**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**反转字符串**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

<!--AUTOGENERATED_END-->


## 距离函数 {#distance-functions}

所有支持的函数详见[距离函数文档](../../sql-reference/functions/distance-functions.md)。

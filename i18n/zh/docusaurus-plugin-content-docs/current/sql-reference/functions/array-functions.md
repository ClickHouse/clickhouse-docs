---
description: '数组函数文档'
sidebar_label: '数组'
slug: /sql-reference/functions/array-functions
title: '数组函数'
doc_type: 'reference'
---



# 数组函数 {#array-functions}

{/* 
  以下标签的内部内容会在文档框架构建时
  被从 system.functions 生成的文档替换。请不要修改或删除这些标签。
  参见：https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }


{/*AUTOGENERATED_START*/ }

## array {#array}

首次引入于：v1.1

根据函数参数创建一个数组。

参数应为常量，且其类型应具有一个共同的超类型。
必须至少传入一个参数，否则无法确定要创建哪种类型的数组。
这意味着你不能使用此函数来创建空数组。要创建空数组，请使用 `emptyArray*` 函数。

可以使用 `[ ]` 运算符实现相同的功能。

**语法**

```sql
array(x1 [, x2, ..., xN])
```

**参数**

* `x1` — 任意类型 T 的常量值。如果只提供该参数，数组的类型将为 T。
* `[, x2, ..., xN]` — 其他 N 个与 `x1` 具有共同超类型的常量值

**返回值**

返回一个数组，其中 &#39;T&#39; 是所有传入参数的最小共同类型。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**有效用法**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**用法无效**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
从服务器接收到异常（版本 25.4.3）：
代码：386. DB::Exception：从 localhost:9000 接收。DB::Exception：
类型 Int32、DateTime、Int8 没有超类型...
```


## arrayAUCPR {#arrayAUCPR}

Introduced in: v20.4

计算精确率-召回率（PR）曲线下的面积。
通过在所有阈值上将精确率绘制在 y 轴、召回率绘制在 x 轴，即可得到精确率-召回率曲线。
结果值范围为 0 到 1，值越高表示模型性能越好。
在类别分布不平衡的数据集上，PR AUC 尤其有用，相比 ROC AUC 能在这类场景下提供更清晰的性能对比。
更多详情请参阅[此处](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[此处](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)和[此处](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)。

**语法**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**别名**: `arrayPRAUC`

**参数**

* `cores` — 预测模型给出的评分。[`Array((U)Int*)`](/sql-reference/data-types/array) 或 [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — 样本的标签，通常正样本为 1，负样本为 0。[`Array((U)Int*)`](/sql-reference/data-types/array) 或 [`Array(Enum)`](/sql-reference/data-types/array)
* `partial_offsets` —
* 可选。一个由三个非负整数组成的 [`Array(T)`](/sql-reference/data-types/array)，用于计算 PR 曲线下的部分面积（等价于 PR 空间中的一个垂直带状区域），而不是整个 AUC。此选项在分布式计算 PR AUC 时非常有用。数组必须包含以下元素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]。
  * `higher_partitions_tp`：得分更高的分区中正标签的数量。
  * `higher_partitions_fp`：得分更高的分区中负标签的数量。
  * `total_positives`：整个数据集中正样本的总数。

:::note
当使用 `arr_partial_offsets` 时，`arr_scores` 和 `arr_labels` 应仅表示整个数据集的一个分区，包含某个分数区间。
数据集应被划分为若干连续分区，每个分区包含其分数落在特定范围内的数据子集。
例如：

* 一个分区可以包含区间 [0, 0.5) 内的所有分数。
* 另一个分区可以包含区间 [0.5, 1.0] 内的分数。
  :::

**返回值**

返回精确率-召回率（PR）曲线下的面积。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll {#arrayAll}

引入版本：v1.1

如果 lambda 表达式 `func(x [, y1, y2, ... yN])` 对所有元素都返回 true，则返回 `1`，否则返回 `0`。

**语法**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 作用于源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — 可选。用于为 lambda 函数提供附加参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

如果 lambda 函数对所有元素都返回 true，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**所有元素均满足条件**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**并非所有元素都匹配**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg {#arrayAvg}

引入版本：v21.1

返回原始数组中元素的平均值。

如果指定了 lambda 函数 `func`，则返回对每个元素应用该 lambda 函数后所得结果的平均值。

**语法**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 可选。作用于源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 可选。提供给 lambda 函数额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组元素的平均值；如果提供了 lambda 函数，则返回其结果元素的平均值。[`Float64`](/sql-reference/data-types/float)

**示例**

**基础示例**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**结合 lambda 函数的用法**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```


## arrayCompact {#arrayCompact}

自 v20.1 引入

从数组中移除连续重复的元素，包括 `null` 值。结果数组中各值的顺序与源数组中的顺序一致。

**语法**

```sql
arrayCompact(arr)
```

**参数**

* `arr` — 要去重的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回不含重复值的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```


## arrayConcat {#arrayConcat}

自 v1.1 起引入

将作为参数传入的数组合并为一个数组。

**语法**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**参数**

* `arr1 [, arr2, ... , arrN]` — N 个要连接的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个由提供的数组参数合并得到的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```


## arrayCount {#arrayCount}

引入版本：v1.1

返回使 `func(arr1[i], ..., arrN[i])` 返回 true 的元素个数。
如果未指定 `func`，则返回数组中非零元素的个数。

`arrayCount` 是一个[高阶函数](/sql-reference/functions/overview#higher-order-functions)。

**语法**

```sql
arrayCount([func, ] arr1, ...)
```

**参数**

* `func` — 可选。应用到数组中每个元素上的函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1, ..., arrN` — N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回使 `func` 求值为 true 的元素个数。否则（未指定 `func` 时），返回数组中非零元素的个数。[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```


## arrayCumSum {#arrayCumSum}

引入于：v1.1

返回一个数组，其元素为源数组各元素的前缀和（累计和）。如果指定了 lambda 函数，则先对数组中每个位置的元素应用该 lambda，再对结果计算累计和。

**语法**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**参数**

* `func` — 可选。应用于数组中各位置元素的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — 数值类型的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — 可选。与 `arr1` 大小相同的其他数组，如果提供，则作为参数传递给 lambda 函数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，包含源数组元素的部分和。结果类型与输入数组的数值类型相同。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**基本用法**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**使用 lambda 表达式**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```


## arrayCumSumNonNegative {#arrayCumSumNonNegative}

引入版本：v18.12

返回一个数组，该数组包含源数组元素的逐步累积和，并将任何为负的累积和替换为 0。若指定了 lambda 函数，则在每个位置先将该 lambda 应用于数组元素，再对结果计算累积和。

**语法**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**参数**

* `func` — 可选。应用于数组中每个位置元素的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — 数值类型的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — 可选。相同长度的其他数组，如果指定了 lambda 函数，这些数组将作为参数传递给该函数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其中包含源数组元素的前缀和（部分和），并将其中任何为负的累计和替换为零。结果类型与输入数组的数值类型一致。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**基本用法**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**使用 lambda**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```


## arrayDifference {#arrayDifference}

引入版本：v1.1

计算由相邻数组元素差值构成的数组。
结果数组的第一个元素为 0，第二个元素为 `arr[1] - arr[0]`，第三个元素为 `arr[2] - arr[1]`，以此类推。
结果数组中元素的类型由减法的类型推断规则决定（例如 `UInt8` - `UInt8` = `Int16`）。

**语法**

```sql
arrayDifference(arr)
```

**参数**

* `arr` — 要计算相邻元素差值的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个由相邻数组元素差值组成的数组。[`UInt*`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**结果类型为 Int64 导致溢出的示例**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct {#arrayDistinct}

引入版本：v1.1

返回一个只包含原数组中不重复元素的新数组。

**语法**

```sql
arrayDistinct(arr)
```

**参数**

* `arr` — 要从中提取不同元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个只包含不同元素的数组 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct {#arrayDotProduct}

引入于：v23.5

返回两个数组的点积。

:::note
两个向量的长度必须相同。`Array` 和 `Tuple` 的元素类型也可以是混合的。
:::

**语法**

```sql
arrayDotProduct(v1, v2)
```

**参数**

* `v1` — 第一个向量。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) 或 [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
* `v2` — 第二个向量。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) 或 [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**返回值**

两个向量的点积。

:::note
返回类型由参数类型决定。如果 `Array` 或 `Tuple` 中包含混合元素类型，则结果类型为它们的超类型。
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float) 或 [`Decimal`](/sql-reference/data-types/decimal)

**示例**

**Array 示例**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**元组示例**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement {#arrayElement}

引入于：v1.1

获取指定数组中索引为 `n` 的元素，其中 `n` 可以是任意整数类型。
如果索引超出了数组范围，则返回默认值（数字为 0，字符串为空字符串等），
但当数组参数为非常量且索引为常量 0 时除外。在这种情况下会报错 `Array indices are 1-based`。

:::note
ClickHouse 中的数组从 1 开始计数。
:::

支持负索引。在这种情况下，将从数组末尾开始编号并选择对应元素。例如，`arr[-1]` 是数组中的最后一个元素。

运算符 `[n]` 提供相同的功能。

**语法**

```sql
arrayElement(arr, n)
```

**参数**

* `arr` — 要查询的数组。[`Array(T)`](/sql-reference/data-types/array). - `n` — 要获取的元素位置。[`(U)Int*`](/sql-reference/data-types/int-uint).

**返回值**

从提供的数组参数中返回一个由其合并而成的单一数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**负索引**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**使用 [n] 表示法**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**数组下标越界**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```


## arrayElementOrNull {#arrayElementOrNull}

引入版本：v1.1

获取给定数组中索引为 `n` 的元素，其中 `n` 可以是任意整数类型。
如果索引超出了数组范围，将返回 `NULL`，而不是默认值。

:::note
ClickHouse 中的数组下标从 1 开始。
:::

支持负索引。在这种情况下，它会从数组末尾开始计数选择对应的元素。例如，`arr[-1]` 是数组中的最后一个元素。

**语法**

```sql
arrayElementOrNull(arrays)
```

**参数**

* `arrays` — 任意数量的数组参数。[`Array`](/sql-reference/data-types/array)

**返回值**

返回由提供的数组参数合并而成的单个数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**负数索引**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**数组下标越界**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```


## arrayEnumerate {#arrayEnumerate}

自 v1.1 版本起提供

返回形如 `[1, 2, 3, ..., length(arr)]` 的数组。

此函数通常与 [`ARRAY JOIN`](/sql-reference/statements/select/array-join) 子句一起使用，这样可以在应用 `ARRAY JOIN` 之后，对每个数组只统计一次。
此函数也可以用于高阶函数。例如，可用它来获取满足某个条件的元素的数组索引。

**语法**

```sql
arrayEnumerate(arr)
```

**参数**

* `arr` — 要枚举的数组。[`Array`](/sql-reference/data-types/array)

**返回值**

返回数组 `[1, 2, 3, ..., length(arr)]`。[`Array(UInt32)`](/sql-reference/data-types/array)

**示例**

**ARRAY JOIN 的基本示例**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense {#arrayEnumerateDense}

引入版本：v18.12

返回一个与源数组大小相同的数组，用于表示源数组中每个元素首次出现的位置。

**语法**

```sql
arrayEnumerateDense(arr)
```

**参数**

* `arr` — 要枚举的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个与 `arr` 长度相同的数组，用于标明每个元素在源数组中首次出现的位置。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

引入版本：v20.1

返回一个与源数组大小相同的数组，用于指示每个元素在源数组中首次出现的位置。该函数允许对多维数组进行枚举，并可指定在数组中向内遍历的深度。

**语法**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**参数**

* `clear_depth` — 对指定层级的元素单独枚举。必须小于或等于 `max_arr_depth`。[`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — 需要枚举的 N 维数组。[`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — 最大有效深度。必须小于或等于 `arr` 的深度。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个数组，表示源数组中每个元素首次出现的位置。[`Array`](/sql-reference/data-types/array)

**示例**

**基本用法**

```sql title=Query
-- 当 clear_depth=1 且 max_array_depth=1 时,结果与 arrayEnumerateDense 给出的结果相同。

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**多维数组的用法**

```sql title=Query
-- 在此示例中,arrayEnumerateDenseRanked 用于获取一个数组,该数组指示多维数组中每个元素在具有相同值的元素中的排名位置。
-- 对于传入数组的第一行 [10, 10, 30, 20],结果的对应第一行是 [1, 1, 2, 3],
-- 表示 10 是第一个遇到的数字,出现在位置 1 和 2,30 是第二个遇到的数字,出现在位置 3,
-- 20 是第三个遇到的数字,出现在位置 4。
-- 对于第二行 [40, 50, 10, 30],结果的对应第二行是 [4,5,1,2],表示 40
-- 和 50 是第四个和第五个遇到的数字,分别出现在该行的位置 1 和 2,另一个 10
-- (第一个遇到的数字)出现在位置 3,30(第二个遇到的数字)出现在最后位置。

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**使用更大 clear&#95;depth 的示例**

```sql title=Query
-- 将 clear_depth=2 会导致每行的枚举单独重新开始。

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq {#arrayEnumerateUniq}

引入版本：v1.1

返回一个与源数组大小相同的数组，对每个元素表示它在所有具有相同值的元素中的位置。

在使用 `ARRAY JOIN` 并对数组元素进行聚合时，此函数非常有用。

该函数可以接收多个大小相同的数组作为参数。在这种情况下，唯一性是针对所有数组中相同位置元素组成的元组来判断的。

**语法**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**参数**

* `arr1` — 要处理的第一个数组。[`Array(T)`](/sql-reference/data-types/array)
* `arr2, ...` — 可选。用于确定元组唯一性的、与 `arr1` 大小相同的附加数组。[`Array(UInt32)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其中每个元素表示在所有具有相同值或元组的元素中的位置。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**基本用法**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**多个数组**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**ARRAY JOIN 聚合**

```sql title=Query
-- 每个目标 ID 都计算了转化次数(Goals 嵌套数据结构中的每个元素代表一个已达成的目标,我们称之为转化)
-- 以及会话数。如果没有 ARRAY JOIN,我们会用 sum(Sign) 来统计会话数。但在这种特定情况下,
-- 由于嵌套的 Goals 结构使行数成倍增加,为了在此之后对每个会话只计数一次,我们对
-- arrayEnumerateUniq(Goals.ID) 函数的值应用了一个条件。

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

自 v20.1 引入

返回一个与源数组维度相同的一维或多维数组，
对于每个元素，指示其在具有相同值的元素中的位置（序号）。
它支持对多维数组进行枚举，并且可以指定在数组中向内展开的深度。

**语法**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**参数**

* `clear_depth` — 在指定层级单独枚举元素。正整数，且小于等于 `max_arr_depth`。[`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — 要枚举的 N 维数组。[`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — 最大有效深度。正整数，且小于等于 `arr` 的深度。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个与 `arr` 大小相同的 N 维数组，其中每个元素表示该元素在所有相同值元素中的位置。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**示例 1**

```sql title=Query
-- 当 clear_depth=1 且 max_array_depth=1 时,arrayEnumerateUniqRanked 的结果
-- 与 arrayEnumerateUniq 对同一数组给出的结果相同。

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**示例 2**

```sql title=Query
-- 当 clear_depth=1 且 max_array_depth=1 时,arrayEnumerateUniqRanked 的结果
-- 与 arrayEnumerateUniq 对同一数组给出的结果相同。

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**示例 3**

```sql title=Query
-- 在此示例中,arrayEnumerateUniqRanked 用于获取一个数组,该数组指示
-- 多维数组中每个元素在具有相同值的元素中的位置。对于传入数组的第一行 [1, 2, 3],对应的
-- 结果是 [1, 1, 1],表示这是首次遇到 1、2 和 3。
-- 对于传入数组的第二行 [2, 2, 1],对应的结果是 [2, 3, 3],
-- 表示 2 是第二次和第三次遇到,1 是第二次遇到。
-- 同样,对于传入数组的第三行 [3],
-- 对应的结果是 [2],表示 3 是第二次遇到。

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**示例 4**

```sql title=Query
-- 将 clear_depth 改为 2,会导致每行的元素被单独枚举。
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept {#arrayExcept}

引入版本：v25.9

返回一个数组，其中包含来自 `source` 且不在 `except` 中出现的元素，并保留其原始顺序。

此函数对两个数组执行差集运算。对于 `source` 中的每个元素，它会检查该元素是否存在于 `except` 中（使用精确比较）。如果不存在，则将该元素包含在结果中。

该操作具有以下性质：

1. 保留来自 `source` 的元素顺序
2. 如果 `source` 中的重复元素在 `except` 中不存在，则保留这些重复元素
3. 将 NULL 作为一个单独的值进行处理

**语法**

```sql
arrayExcept(source, except)
```

**参数**

* `source` — 包含待过滤元素的源数组。  [`Array(T)`](/sql-reference/data-types/array)
* `except` — 包含需要从结果中排除的元素的数组。  [`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回与输入数组类型相同的数组，其中包含 `source` 中未在 `except` 中出现的元素。  [`Array(T)`](/sql-reference/data-types/array)

**示例**

**基础用法**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with&#95;nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with&#95;nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**字符串**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```


## arrayExists {#arrayExists}

引入于：v1.1

如果源数组中至少有一个元素使得 `func(x[, y1, y2, ... yN])` 返回 true，则返回 `1`，否则返回 `0`。

**语法**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 一个 lambda 函数，用于对源数组 (`x`) 和条件数组 (`y`) 的元素进行运算。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 可选。提供给 lambda 函数的 N 个条件数组，作为额外参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

如果 lambda 函数对至少一个元素返回 true，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```


## arrayFill {#arrayFill}

自 v20.1 版本引入

`arrayFill` 函数按顺序处理源数组，从第一个元素到最后一个元素，在每个位置上使用源数组和条件数组中的元素来计算一个 lambda 条件表达式。当该 lambda 函数在位置 i 上的结果为 false 时，函数会将该元素替换为当前数组状态下位置 i-1 处的元素。第一个元素始终会被保留，不受任何条件影响。

**语法**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x [, y1, ..., yN])` — 一个 lambda 函数 `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`，用于处理源数组 (`x`) 和条件数组 (`y`) 中的元素。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Lambda 函数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — 可选。提供给 lambda 函数的 N 个条件数组，作为附加参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个 [`Array(T)`](/sql-reference/data-types/array) 类型的数组

**示例**

**单数组示例**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**两个数组的示例**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```


## arrayFilter {#arrayFilter}

引入版本：v1.1

返回一个数组，其中仅包含源数组中那些使 lambda 函数返回 true 的元素。

**语法**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**参数**

* `func(x[, y1, ..., yN])` — 作用于源数组 `x` 中元素和条件数组 `y` 的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 可选。由 N 个条件数组组成，为 lambda 函数提供额外参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组的一个子集，[`Array(T)`](/sql-reference/data-types/array)

**示例**

**示例 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**示例 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```


## arrayFirst {#arrayFirst}

首次引入于：v1.1

返回源数组中第一个使 `func(x[, y1, y2, ... yN])` 返回 true 的元素，否则返回默认值。

**语法**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 一个对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)。- `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)。- `[, cond1_arr, ... , condN_arr]` — 可选。提供给 lambda 函数的附加参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回第一个使 `λ` 为真 的源数组元素，否则返回类型 `T` 的默认值。

**示例**

**使用示例**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**未找到匹配项**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayFirstIndex {#arrayFirstIndex}

引入自：v1.1

返回源数组中第一个使 `func(x[, y1, y2, ... yN])` 返回 true 的元素的索引，否则返回 &#39;0&#39;。

**语法**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 一个作用于源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — 可选。向 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回第一个使 `func` 为 true 的源数组元素的索引，否则返回 `0`。[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**无匹配结果**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```


## arrayFirstOrNull {#arrayFirstOrNull}

引入版本：v1.1

返回源数组中第一个使 `func(x[, y1, y2, ... yN])` 返回 true 的元素，否则返回 `NULL`。

**语法**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 作用于源数组元素 (`x`) 和条件数组 (`y`) 的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 可选。向 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回使 `func` 为 true 的源数组中的第一个元素；如果没有这样的元素，则返回 `NULL`。

**示例**

**用法示例**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**未找到匹配项**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayFlatten {#arrayFlatten}

引入版本：v20.1

将嵌套数组转换为扁平数组。

功能：

* 适用于任意深度的嵌套数组。
* 不会改变已经是扁平结构的数组。

扁平化后的数组包含所有源数组中的元素。

**语法**

```sql
arrayFlatten(arr)
```

**别名**: `flatten`

**参数**

* `arr` — 多维数组。[`Array(Array(T))`](/sql-reference/data-types/array)

**返回值**

从多维数组返回一个展平后的一维数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```


## arrayFold {#arrayFold}

自 v23.10 版本引入

对一个或多个长度相同的数组应用一个 lambda 函数，并将结果汇总到累加器中。

**语法**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**参数**

* `λ(x, x1 [, x2, x3, ... xN])` — 一个 Lambda 函数 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`，其中 `F` 是一个操作，作用于 `acc` 和来自 `x` 的数组值，其结果会再次作为 `acc` 使用。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1 [, arr2, arr3, ... arrN]` — 要进行操作的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)
* `acc` — 累加器值，其类型与 Lambda 函数的返回类型相同。

**返回值**

返回最终的 `acc` 值。

**示例**

**用法示例**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**斐波那契数列**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**多个数组的示例**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```


## arrayIntersect {#arrayIntersect}

引入版本：v1.1

接受多个数组并返回一个数组，其中包含在所有源数组中都存在的元素。结果仅包含唯一值。

**语法**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**参数**

* `arrN` — 用于构造新数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回一个数组，其中包含所有 N 个数组中共同存在的、不重复的元素 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex {#arrayJaccardIndex}

自 v23.7 版本引入。

返回两个数组的 [Jaccard 指数](https://en.wikipedia.org/wiki/Jaccard_index)。

**语法**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**参数**

* `arr_x` — 第一个数组。[`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — 第二个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回 `arr_x` 和 `arr_y` 的 Jaccard 指数 [`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin {#arrayJoin}

引入版本：v1.1

`arrayJoin` 函数接收一行包含数组的记录并将其展开，生成多行——数组中每个元素对应一行。
这与 ClickHouse 中的常规函数不同，后者是在同一行内将输入值映射为输出值，
而聚合函数则对一组行进行“压缩”或“归约”，将其转换为一行汇总结果
（或者在使用 `GROUP BY` 时，转换为汇总行中的单个值）。

除了应用此函数的那一列外，其他列中的所有值都会被直接复制；
被应用函数的那一列中的值则会被相应的数组元素值所替代。

**语法**

```sql
arrayJoin(arr)
```

**参数**

* `arr` — 要展开的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回由 `arr` 展开得到的一组行。

**示例**

**基本用法**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin 会影响查询的各个部分**

```sql title=Query
-- arrayJoin 函数会影响查询的所有部分,包括 WHERE 部分。请注意结果为 2,即使子查询仅返回了 1 行。

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**使用多个 arrayJoin 函数**

```sql title=Query
- 一个查询可以使用多个 arrayJoin 函数。在这种情况下,转换会执行多次,行会被相应地扩展。

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**优化导致的意外结果**

```sql title=Query
-- 对同一表达式使用多个 arrayJoin 可能由于优化而无法产生预期结果。
-- 对于这些情况,建议通过不影响连接结果的额外操作来修改重复的数组表达式。
- 例如 arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- 技术上正确,但会清空结果集
    arrayJoin(arrayConcat(dice, [])) as second_throw -- 有意更改表达式以强制重新求值
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─第一次投掷─┬─第二次投掷─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**使用 ARRAY JOIN 语法**

```sql title=Query
-- 注意下面 `SELECT` 查询中的 ARRAY JOIN 语法,它提供了更广泛的功能。
-- ARRAY JOIN 允许您同时转换多个具有相同元素数量的数组。

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**使用元组**

```sql title=Query
-- 您也可以使用元组

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast {#arrayLast}

引入版本：v1.1

返回源数组中最后一个使 lambda `func(x [, y1, y2, ... yN])` 返回 `true` 的元素；如果不存在这样的元素，则返回一个默认值。

**语法**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 一个对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。- `source` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)。- `[, cond1, ... , condN]` — 可选。N 个条件数组，作为传递给 lambda 函数的附加参数。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回使 `func` 为 true 的源数组的最后一个元素，否则返回类型 `T` 的默认值。

**示例**

**使用示例**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**未找到匹配项**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayLastIndex {#arrayLastIndex}

引入于：v1.1

返回源数组中最后一个使 `func(x[, y1, y2, ... yN])` 返回 true 的元素的索引，否则返回 &#39;0&#39;。

**语法**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 一个用于对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 可选。提供给 lambda 函数附加参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中使 `func` 为 true 的最后一个元素的索引，否则返回 `0`，类型为 [`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**无匹配结果**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull {#arrayLastOrNull}

引入于：v1.1

返回源数组中最后一个使 lambda `func(x [, y1, y2, ... yN])` 返回 true 的元素，否则返回 `NULL`。

**语法**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x [, y1, ..., yN])` — 在源数组 (`x`) 和条件数组 (`y`) 的元素上进行操作的 lambda 函数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)。
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)。
* `[, cond1_arr, ... , condN_arr]` — 可选。向 lambda 函数提供附加参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中最后一个使 `λ` 不成立的元素，否则返回 `NULL`。

**示例**

**用法示例**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**无匹配项**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance {#arrayLevenshteinDistance}

在 v25.4 中引入

计算两个数组之间的 Levenshtein 距离。

**语法**

```sql
arrayLevenshteinDistance(from, to)
```

**参数**

* `from` — 第一个数组。[`Array(T)`](/sql-reference/data-types/array). - `to` — 第二个数组。[`Array(T)`](/sql-reference/data-types/array).

**返回值**

第一个数组和第二个数组之间的 Levenshtein 距离。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```


## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

自 v25.4 引入

为两个数组计算 Levenshtein 距离，并为每个元素使用自定义权重。
数组的元素数量应当与其权重数组的元素数量一致。

**语法**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**参数**

* `from` — 第一个数组。[`Array(T)`](/sql-reference/data-types/array). - `to` — 第二个数组。[`Array(T)`](/sql-reference/data-types/array). - `from_weights` — 第一个数组中各元素的权重。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — 第二个数组中各元素的权重。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**返回值**

第一个数组和第二个数组之间的 Levenshtein 距离，对每个元素使用自定义权重。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```


## arrayMap {#arrayMap}

自 v1.1 引入

通过对原始数组中的每个元素应用一个 lambda 函数，返回得到的数组。

**语法**

```sql
arrayMap(func, arr)
```

**参数**

* `func` — 在源数组（`x`）和条件数组（`y`）的元素上进行操作的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — 需要处理的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个由 lambda 结果构成的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**从不同数组中创建元素元组**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax {#arrayMax}

引入于：v21.1

返回源数组中的最大元素。

如果指定了 lambda 函数 `func`，则返回应用该函数后结果中的最大元素。

**语法**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 可选。对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 可选。向 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中的最大元素；如果提供了 lambda 函数，则返回其结果中的最大元素。

**示例**

**基础示例**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**与 lambda 函数配合使用**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin {#arrayMin}

引入版本：v21.1

返回源数组中的最小元素。

如果指定了 lambda 函数 `func`，则返回该 lambda 函数结果中的最小元素。

**语法**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 可选。对源数组 (`x`) 和条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — 可选。为 lambda 函数提供附加参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中的最小元素；如果提供了 lambda 函数，则返回 lambda 结果中的最小元素。

**示例**

**基础示例**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**与 lambda 函数一起使用**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```


## arrayNormalizedGini {#arrayNormalizedGini}

引入于：v25.1

计算归一化的 Gini 系数。

**语法**

```sql
arrayNormalizedGini(predicted, label)
```

**参数**

* `predicted` — 预测值。[`Array(T)`](/sql-reference/data-types/array)
* `label` — 实际值。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

一个元组，其中包含预测值的 Gini 系数、归一化后值的 Gini 系数，以及归一化 Gini 系数（= 前两者 Gini 系数的比值）[`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**示例**

**用法示例**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort {#arrayPartialReverseSort}

自 v23.2 引入

此函数与 `arrayReverseSort` 相同，但增加了一个 `limit` 参数，用于只对部分元素进行排序。

:::tip
若只保留已排序的元素，请使用 `arrayResize`。
:::

**语法**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**参数**

* `f(arr[, arr1, ... ,arrN])` — 应用于数组 `x` 各元素的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — 要排序的数组。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — 当 `f` 接受多个参数时的 N 个额外数组。[`Array(T)`](/sql-reference/data-types/array)
* `limit` — 执行排序的索引上界值（排序会进行到该索引为止）。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个与原数组大小相同的数组，其中区间 `[1..limit]` 内的元素按降序排序。其余元素 `(limit..N]` 的顺序未定义。

**示例**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```


## arrayPartialShuffle {#arrayPartialShuffle}

引入版本：v23.2

返回一个与原始数组大小相同的数组，其中区间 `[1..limit]` 内的元素是原始数组的一个随机子集。其余区间 `(limit..n]` 将以未定义的顺序包含未出现在 `[1..limit]` 区间内的元素。
`limit` 的取值必须在 `[1..n]` 范围内。超出该范围的取值等价于执行完整的 `arrayShuffle`：

:::note
此函数不会物化常量。

`limit` 的值应在 `[1..N]` 范围内。超出该范围的取值等价于执行完整的 [`arrayShuffle`](#arrayShuffle)。
:::

**语法**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**参数**

* `arr` — 要打乱顺序的数组。[`Array(T)`](/sql-reference/data-types/array)
* `seed` — 可选。用于随机数生成的种子。若未提供，则使用随机种子。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `limit` — 可选。用于限制元素交换次数的数值，取值范围为 `[1..N]`。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

元素被部分打乱顺序的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**no&#95;limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no&#95;limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**物化**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort {#arrayPartialSort}

自 v23.2 引入

该函数与 `arraySort` 类似，但额外增加了一个 `limit` 参数，用于实现部分排序。

:::tip
如只需保留已排序的元素，请使用 `arrayResize`。
:::

**语法**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**参数**

* `f(arr[, arr1, ... ,arrN])` — 应用于数组 `x` 元素的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — 要排序的数组。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — 当 `f` 接受多个参数时使用的额外 N 个数组。[`Array(T)`](/sql-reference/data-types/array)
* `limit` — 用于限定排序范围的索引值。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个与原始数组大小相同的数组，其中 `[1..limit]` 范围内的元素按升序排序。
其余元素 `(limit..N]` 的顺序不作保证。

**示例**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```


## arrayPopBack {#arrayPopBack}

自 v1.1 起引入

从数组中移除最后一个元素。

**语法**

```sql
arrayPopBack(arr)
```

**参数**

* `arr` — 要移除其最后一个元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个与 `arr` 相同但去掉了其最后一个元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```


## arrayPopFront {#arrayPopFront}

在 v1.1 中引入

从数组中移除第一个元素。

**语法**

```sql
arrayPopFront(arr)
```

**参数**

* `arr` — 要移除第一个元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个与 `arr` 相同但去除了其第一个元素的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```


## arrayProduct {#arrayProduct}

引入于：v21.1

返回源数组中所有元素的乘积。

如果指定了 lambda 函数 `func`，则返回该 lambda 结果数组中所有元素的乘积。

**语法**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 可选。对源数组 (`x`) 和条件数组 (`y`) 的元素进行处理的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 可选。提供给 lambda 函数作为附加参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中各元素的乘积；如果提供了 lambda 函数，则返回其结果数组各元素的乘积。[`Float64`](/sql-reference/data-types/float)

**示例**

**基本示例**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**与 lambda FUNCTION 一起使用**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack {#arrayPushBack}

引入版本：v1.1

在数组末尾添加一个元素。

**语法**

```sql
arrayPushBack(arr, x)
```

**参数**

* `arr` — 要在其末尾添加值 `x` 的数组。[`Array(T)`](/sql-reference/data-types/array)
* `x` —
* 要添加到数组末尾的单个值。[`Array(T)`](/sql-reference/data-types/array)。

:::note

* 只能向数值数组中添加数值，且只能向字符串数组中添加字符串。
* 在添加数值时，ClickHouse 会根据数组的数据类型自动确定 `x` 的类型。
* 可以为 `NULL`。该函数会向数组中添加一个 `NULL` 元素，并将数组元素的类型转换为 `Nullable`。

有关 ClickHouse 中数据类型的更多信息，请参阅 [Data types](/sql-reference/data-types)。
:::

**返回值**

返回一个与 `arr` 相同、但在数组末尾额外包含值 `x` 的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```


## arrayPushFront {#arrayPushFront}

自 v1.1 起引入。

在数组开头添加一个元素。

**语法**

```sql
arrayPushFront(arr, x)
```

**参数**

* `arr` — 要在末尾添加值 `x` 的数组。[`Array(T)`](/sql-reference/data-types/array)。
* `x` — 要添加到数组开头的单个值。[`Array(T)`](/sql-reference/data-types/array)。

:::note

* 对于数值数组只能添加数值，对于字符串数组只能添加字符串。
* 在添加数值时，ClickHouse 会自动将 `x` 的类型设置为数组的数据类型。
* 可以为 `NULL`。该函数会向数组添加一个 `NULL` 元素，并将数组元素的类型转换为 `Nullable`。

有关 ClickHouse 中数据类型的更多信息，请参阅 [Data types](/sql-reference/data-types)。
:::

**返回值**

返回一个与 `arr` 相同但在数组开头额外多一个值 `x` 的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```


## arrayROCAUC {#arrayROCAUC}

首次引入于：v20.4

计算 ROC（受试者工作特征）曲线下的面积。
ROC 曲线是通过在所有阈值上，将真正率（TPR）作为 y 轴、假正率（FPR）作为 x 轴绘制而成的。
结果值范围为 0 到 1，值越高表示模型性能越好。

ROC AUC（也常简称为 AUC）是机器学习中的一个概念。
更多详细信息请参见[此处](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[此处](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)以及[此处](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)。

**语法**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**别名**：`arrayAUC`

**参数**

* `scores` — 预测模型给出的分数。[`Array((U)Int*)`](/sql-reference/data-types/array) 或 [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — 样本标签，通常正样本为 1，负样本为 0。[`Array((U)Int*)`](/sql-reference/data-types/array) 或 [`Enum`](/sql-reference/data-types/enum)
* `scale` — 可选。决定是否返回归一化后的面积。如果为 false，则返回 TP（真阳性）与 FP（假阳性）曲线下的面积。默认值：true。[`Bool`](/sql-reference/data-types/boolean)
* `partial_offsets` —
* 一个包含四个非负整数的数组，用于计算 ROC 曲线下的局部面积（等价于 ROC 空间中的一条垂直带），而不是整个 AUC。此选项对 ROC AUC 的分布式计算非常有用。数组必须包含如下元素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]。由非负[整数](../data-types/int-uint.md)组成的 [Array](/sql-reference/data-types/array)。可选。
  * `higher_partitions_tp`：较高得分分区中正标签的数量。
  * `higher_partitions_fp`：较高得分分区中负标签的数量。
  * `total_positives`：整个数据集中正样本的总数。
  * `total_negatives`：整个数据集中负样本的总数。

:::note
当使用 `arr_partial_offsets` 时，`arr_scores` 和 `arr_labels` 只应包含整个数据集中的一个分区，对应某个分数区间。
数据集应被划分为若干连续的分区，每个分区包含分数落在特定范围内的数据子集。
例如：

* 一个分区可以包含区间 [0, 0.5) 内的所有分数。
* 另一个分区可以包含区间 [0.5, 1.0] 内的所有分数。
  :::

**返回值**

返回 ROC（受试者工作特征）曲线下的面积。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```


## arrayRandomSample {#arrayRandomSample}

引入版本：v23.10

返回输入数组中由 `samples` 个随机元素组成的一个子集。如果 `samples` 大于输入数组的大小，则样本数量会被限制为数组大小，即会返回数组的所有元素，但不保证其顺序。该函数可以处理一维数组和嵌套数组。

**语法**

```sql
arrayRandomSample(arr, samples)
```

**参数**

* `arr` — 要从中抽取样本元素的输入数组或多维数组。[`Array(T)`](/sql-reference/data-types/array)
* `samples` — 随机样本中包含的元素数量。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

一个数组，包含从输入数组中随机抽取的样本元素。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**使用多维数组**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```


## arrayReduce {#arrayReduce}

自 v1.1 引入

对数组元素应用聚合函数并返回其结果。
聚合函数的名称以单引号括起来的字符串形式传入，如 `'max'`、`'sum'`。
当使用参数化聚合函数时，在函数名后面的括号中指定参数，例如 `'uniqUpTo(6)'`。

**语法**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**参数**

* `agg_f` — 聚合函数的名称，必须是常量。[`String`](/sql-reference/data-types/string)
* `arr1 [, arr2, ... , arrN)]` — 与 `agg_f` 的参数相对应的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回该聚合函数的结果。

**示例**

**用法示例**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**包含多个参数的聚合函数示例**

```sql title=Query
--如果聚合函数接受多个参数,则必须将该函数应用于多个大小相同的数组。

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**参数化聚合函数示例**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges {#arrayReduceInRanges}

引入于：v20.4

在给定的各个范围内对数组元素应用聚合函数，并返回一个数组，其中包含每个范围对应的结果。
该函数的返回结果等价于多次调用 `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`。

**语法**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**参数**

* `agg_f` — 要使用的聚合函数名称。[`String`](/sql-reference/data-types/string)
* `ranges` — 要进行聚合的范围。是一个由元组 `(i, r)` 组成的数组，每个元组包含起始位置索引 `i` 以及在其上进行聚合的范围 `r`。[`Array(T)`](/sql-reference/data-types/array) 或 [`Tuple(T)`](/sql-reference/data-types/tuple)
* `arr1 [, arr2, ... ,arrN)]` — 作为聚合函数参数的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，包含在指定范围上应用聚合函数得到的结果。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove {#arrayRemove}

引入自：v25.11

从数组中移除所有等于给定值的元素。
将 NULL 视为彼此相等。

**语法**

```sql
arrayRemove(arr, elem)
```

**别名**: `array_remove`

**参数**

* `arr` — Array(T)，`elem` — T

**返回值**

返回源数组 [`Array(T)`](/sql-reference/data-types/array) 的一个子集

**示例**

**示例 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**示例 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```


## arrayResize {#arrayResize}

在 v1.1 中引入

更改数组的长度。

**语法**

```sql
arrayResize(arr, size[, extender])
```

**参数**

* `arr` — 要调整大小的数组。[`Array(T)`](/sql-reference/data-types/array)
* `size` —
  * 数组的新长度。
    如果 `size` 小于数组的原始大小，数组会从右侧截断。
    如果 `size` 大于数组的初始大小，数组会在右侧使用 `extender` 的值或数组元素数据类型的默认值进行扩展。
* `extender` — 用于扩展数组的值。可以为 `NULL`。

**返回值**

长度为 `size` 的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**示例 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**示例 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```


## arrayReverse {#arrayReverse}

引入版本：v1.1

反转给定数组中元素的顺序。

:::note
函数 `reverse(arr)` 具有相同的功能，但除了数组之外，还适用于其他数据类型。
:::

**语法**

```sql
arrayReverse(arr)
```

**参数**

* `arr` — 要反转的数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个与原数组大小相同、其中元素按相反顺序排列的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill {#arrayReverseFill}

引入版本：v20.1

`arrayReverseFill` 函数会依次从源数组的最后一个元素向前处理到第一个元素，在每个位置使用源数组和条件数组中的元素来对一个 lambda 条件进行求值。当条件在位置 i 的求值结果为 false 时，函数会将该元素替换为当前数组状态中位置 i+1 的元素。无论条件如何，最后一个元素始终会被保留。

**语法**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 一个作用于源数组 (`x`) 及条件数组 (`y`) 各元素的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 可选。提供给 lambda 函数的 N 个条件数组，作为附加参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其中源数组的元素被 lambda 的计算结果所替换。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**单个数组示例**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**两个数组的示例**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```


## arrayReverseSort {#arrayReverseSort}

首次引入版本：v1.1

对数组元素进行降序排序。
如果指定了函数 `f`，则根据该函数应用到数组元素后的结果对数组进行排序，然后将排序后的数组反转。
如果 `f` 接受多个参数，则会向 `arrayReverseSort` 函数传递多个数组，这些数组分别对应 `func` 的各个参数。

如果待排序数组包含 `-Inf`、`NULL`、`NaN` 或 `Inf`，它们将按如下顺序排序：

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` 是一个[高阶函数](/sql-reference/functions/overview#higher-order-functions)。

**语法**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**参数**

* `f(y1[, y2 ... yN])` — 应用于数组 `x` 各元素的 lambda 函数。
* `arr` — 要排序的数组。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ..., arrN` — 可选。当 `f` 接受多个参数时，提供的第 N 个附加数组。

**返回值**

如果未提供 lambda 函数，则返回按降序排序后的数组 `x`；否则返回根据所提供 lambda 函数的逻辑排序后再反转的数组。[`Array(T)`](/sql-reference/data-types/array)。

**示例**

**示例 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**示例 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```


## arrayReverseSplit {#arrayReverseSplit}

自 v20.1 起引入

将源数组拆分为多个数组。当 `func(x[, y1, ..., yN])` 返回非零值时，数组会在该元素之后被拆分。数组不会在最后一个元素之后被拆分。

**语法**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 在源数组（`x`）及条件数组（`y`）的元素上进行操作的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — 可选。向 lambda 函数提供额外参数的 N 个条件数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其元素也是数组。[`Array(Array(T))`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft {#arrayRotateLeft}

引入版本：v23.8

将数组向左旋转指定的元素个数。`n` 为负值时，视为向右旋转，旋转步数为该负值的绝对值。

**语法**

```sql
arrayRotateLeft(arr, n)
```

**参数**

* `arr` — 其元素需要旋转的数组。[`Array(T)`](/sql-reference/data-types/array)
* `n` — 要旋转的元素个数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

向左旋转指定数量元素后的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**n 为负数**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```


## arrayRotateRight {#arrayRotateRight}

自 v23.8 版本引入

将数组向右旋转指定数量的元素。`n` 为负时，表示将数组向左旋转 `|n|` 个元素。

**语法**

```sql
arrayRotateRight(arr, n)
```

**参数**

* `arr` — 其元素需要被旋转的数组。[`Array(T)`](/sql-reference/data-types/array)。- `n` — 要旋转（向右移动）的元素个数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**返回值**

向右旋转指定元素个数后的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**负的 n 值**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```


## arrayShiftLeft {#arrayShiftLeft}

首次引入于：v23.8

将数组向左偏移指定数量的元素。
新位置的元素使用提供的参数值或数组元素类型的默认值进行填充。
如果指定的元素数量为负数，则数组向右偏移。

**语法**

```sql
arrayShiftLeft(arr, n[, default])
```

**参数**

* `arr` — 要进行元素移位的数组。[`Array(T)`](/sql-reference/data-types/array). - `n` — 要移位的元素个数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). - `default` — 可选。新元素的默认值。

**返回值**

按指定元素个数向左移位后的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**n 为负值**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**使用默认值**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```


## arrayShiftRight {#arrayShiftRight}

引入于：v23.8

将数组向右移动指定数量的元素。
新位置的元素使用提供的参数，或数组元素类型的默认值进行填充。
如果指定的元素数量为负数，则将数组向左移动。

**语法**

```sql
arrayShiftRight(arr, n[, default])
```

**参数**

* `arr` — 要右移元素的数组。[`Array(T)`](/sql-reference/data-types/array)
* `n` — 要右移的元素个数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `default` — 可选。新元素的默认值。

**返回值**

向右移动指定数量元素后的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**n 为负数**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**使用默认值**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```


## arrayShingles {#arrayShingles}

在 v24.1 中引入

生成一个由 shingle 组成的数组（类似于字符串的 n-gram），即由输入数组中具有指定长度的连续子数组构成。

**语法**

```sql
arrayShingles(arr, l)
```

**参数**

* `arr` — 用于生成 shingle 数组的数组。[`Array(T)`](/sql-reference/data-types/array)
* `l` — 每个 shingle 的长度。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

生成的 shingle 组成的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle {#arrayShuffle}

引入版本：v23.2

返回一个与原始数组大小相同的数组，其中元素的顺序已被打乱。
元素会被重新排序，使得这些元素的每一种排列出现的概率都相同。

:::note
此函数不会将常量物化。
:::

**语法**

```sql
arrayShuffle(arr [, seed])
```

**参数**

* `arr` — 要打乱顺序的数组。[`Array(T)`](/sql-reference/data-types/array)
* `seed (optional)` — 可选。用于随机数生成的种子。如果未提供，则使用随机种子。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

元素顺序被打乱的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**未指定 seed 的示例（结果不稳定）**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**未设置种子的示例（结果稳定）**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```


## arraySimilarity {#arraySimilarity}

引入版本：v25.4

基于加权 Levenshtein 距离计算两个数组在 `0` 到 `1` 区间内的相似度。

**语法**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**参数**

* `from` — 第一个数组 [`Array(T)`](/sql-reference/data-types/array)
* `to` — 第二个数组 [`Array(T)`](/sql-reference/data-types/array)
* `from_weights` — 第一个数组的权重 [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — 第二个数组的权重 [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**返回值**

返回基于加权 Levenshtein 距离计算的两个数组之间的相似度，取值范围在 `0` 到 `1` 之间 [`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```


## arraySlice {#arraySlice}

引入版本：v1.1

返回数组的一个切片，其中包含 `NULL` 元素。

**语法**

```sql
arraySlice(arr, offset [, length])
```

**参数**

* `arr` — 要进行切片的数组。[`Array(T)`](/sql-reference/data-types/array)
* `offset` — 相对于数组边界的偏移量。正值表示从左侧开始的偏移，负值表示从右侧开始的偏移。数组元素从 `1` 开始编号。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 所需切片的长度。如果指定负值，函数返回从 `offset` 开始到 `array_length - length` 结束的切片 `[offset, array_length - length]`。如果省略该值，函数返回从 `offset` 一直到数组末尾的切片 `[offset, the_end_of_array]`。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

从指定的 `offset` 开始，返回包含 `length` 个元素的数组切片。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```


## arraySort {#arraySort}

引入版本：v1.1

按升序对给定数组的元素进行排序。
如果指定了 lambda 函数 `f`，则排序顺序由将该 lambda 应用于数组中每个元素所得到的结果决定。
如果 lambda 接受多个参数，`arraySort` 函数会传入多个数组，与 `f` 的各个参数一一对应。

如果要排序的数组包含 `-Inf`、`NULL`、`NaN` 或 `Inf`，它们将按以下顺序排序：

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` 是一个[高阶函数](/sql-reference/functions/overview#higher-order-functions)。

**语法**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**参数**

* `f(y1[, y2 ... yN])` — 应用于数组 `x` 元素的 lambda 函数。
* `arr` — 要排序的数组。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ..., yN` — 可选。当 `f` 接受多个参数时，额外的 N 个数组。

**返回值**

如果未提供 lambda 函数，则返回按升序排序的数组 `arr`；否则，返回根据所提供 lambda 函数逻辑排序后的数组。[`Array(T)`](/sql-reference/data-types/array)。

**示例**

**示例 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**示例 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**示例 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit {#arraySplit}

引入版本：v20.1

将源数组拆分为多个数组。当 `func(x [, y1, ..., yN])` 返回非零值时，数组会在该元素左侧被拆分。数组不会在第一个元素之前被拆分。

**语法**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 作用于源数组（`x`）及条件数组（`y`）元素的 lambda 函数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)。- `source_arr` — 要拆分的源数组 [`Array(T)`](/sql-reference/data-types/array)。- `[, cond1_arr, ... , condN_arr]` — 可选。N 个条件数组，为 lambda 函数提供附加参数。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回一个数组的数组 [`Array(Array(T))`](/sql-reference/data-types/array)。

**示例**

**使用示例**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```


## arraySum {#arraySum}

引入自：v21.1

返回源数组中各元素的总和。

如果指定了 lambda 函数 `func`，则返回该 lambda 函数结果数组中各元素的总和。

**语法**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

* `func(x[, y1, ..., yN])` — 可选。用于对源数组 (`x`) 及条件数组 (`y`) 的元素进行操作的 lambda 函数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 要处理的源数组。[`Array(T)`](/sql-reference/data-types/array)
* `, cond1_arr, ... , condN_arr]` — 可选。提供给 lambda 函数的 N 个条件数组作为附加参数。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回源数组中元素之和；如果提供了 lambda 函数，则返回其结果数组中元素之和。

**示例**

**基础示例**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**与 lambda 函数配合使用**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```


## arraySymmetricDifference {#arraySymmetricDifference}

引入版本：v25.4

接受多个数组，返回一个由**未在所有源数组中同时出现的元素**组成的数组。结果仅包含唯一值。

:::note
*多于两个集合*的对称差，[在数学上被定义](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)为：所有在输入集合中出现了奇数次的输入元素所组成的集合。
相比之下，`arraySymmetricDifference` 函数只返回那些未在所有输入集合中出现的输入元素所组成的集合。
:::

**语法**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**参数**

* `arrN` — 用于构造新数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回一个数组，包含那些未在所有源数组中同时出现的去重元素。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion {#arrayUnion}

引入版本：v24.10

接收多个数组并返回一个数组，其中包含任一源数组中出现的所有元素。结果中只包含不重复的值。

**语法**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**参数**

* `arrN` — 用于构建新数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个包含源数组中不重复元素的数组 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq {#arrayUniq}

引入版本：v1.1

当只传入一个参数时，统计数组中不同元素的数量。
当传入多个参数时，统计由多个数组在对应位置上的元素组成的不同**元组**的数量。

例如 `SELECT arrayUniq([1,2], [3,4], [5,6])` 将形成以下元组：

* 位置 1: (1,3,5)
* 位置 2: (2,4,6)

然后会统计唯一元组的数量。在这个例子中为 `2`。

所有传入的数组长度必须相同。

:::tip
如果需要获取数组中不重复元素的列表，可以使用 `arrayReduce('groupUniqArray', arr)`。
:::

**语法**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**参数**

* `arr1` — 要统计其唯一元素数量的数组。[`Array(T)`](/sql-reference/data-types/array)
* `[, arr2, ..., arrN]` — 可选。用于统计在多个数组中对应位置元素所组成的唯一元组数量的其他数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

对于单个参数，返回唯一元素的数量；对于多个参数，返回由各数组中对应位置元素组成的唯一元组的数量。
[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**单个参数**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**多个参数**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```


## arrayWithConstant {#arrayWithConstant}

自 v20.1 引入。

创建一个长度为 `length`、由常量 `x` 填充的数组。

**语法**

```sql
arrayWithConstant(N, x)
```

**参数**

* `length` — 数组中的元素数量。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `x` — 数组中 `N` 个元素的值，类型可以为任意类型。

**返回值**

返回一个包含 `N` 个值为 `x` 的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```


## arrayZip {#arrayZip}

自 v20.1 引入

将多个数组合并为一个数组。结果数组包含源数组中对应位置的元素，并按照参数的列出顺序将这些元素分组成元组。

**语法**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**参数**

* `arr1, arr2, ... , arrN` — 要合并成一个数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其元素为将源数组的元素分组为元组后的结果。元组中的数据类型与输入数组的类型相同，且顺序与数组传入的顺序一致。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned {#arrayZipUnaligned}

引入自：v20.1

将多个数组合并为单个数组，支持长度不一致的数组（未对齐的数组）。结果数组按参数给出的顺序，将源数组中对应位置的元素分组为元组。

**语法**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**参数**

* `arr1, arr2, ..., arrN` — 要合并为单个数组的 N 个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个数组，其中包含将源数组的元素按元组分组后的结果。元组中的数据类型与输入数组的类型相同，且顺序与传入数组的顺序一致。[`Array(T)`](/sql-reference/data-types/array) 或 [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**示例**

**使用示例**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual {#countEqual}

引入版本：v1.1

返回数组中等于 `x` 的元素数量。等价于 `arrayCount(elem -> elem = x, arr)`。

`NULL` 元素会被视为单独的取值。

**语法**

```sql
countEqual(arr, x)
```

**参数**

* `arr` — 要搜索的数组。[`Array(T)`](/sql-reference/data-types/array)
* `x` — 在数组中需要计数的值。任意类型。

**返回值**

返回数组中等于 `x` 的元素数量。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```


## empty {#empty}

引入版本：v1.1

检查输入数组是否为空。

如果数组不包含任何元素，则认为该数组为空。

:::note
可以通过启用 [`optimize_functions_to_subcolumns` 设置](/operations/settings/settings#optimize_functions_to_subcolumns)来进行优化。当 `optimize_functions_to_subcolumns = 1` 时，函数只会读取 [size0](/sql-reference/data-types/array#array-size) 子列，而不是读取并处理整个数组列。查询 `SELECT empty(arr) FROM TABLE;` 会被转换为 `SELECT arr.size0 = 0 FROM TABLE;`。
:::

该函数同样适用于 String 或 UUID。

**语法**

```sql
empty(arr)
```

**参数**

* `arr` — 输入数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

空数组返回 `1`，非空数组返回 `0`，返回类型为 [`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate {#emptyArrayDate}

引入于：v1.1

返回一个空的 Date 类型数组

**语法**

```sql
emptyArrayDate()
```

**参数**

* 无。

**返回值**

一个空的 Date 类型数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```


## emptyArrayDateTime {#emptyArrayDateTime}

引入于：v1.1

返回一个空的 DateTime 数组

**语法**

```sql
emptyArrayDateTime()
```

**参数**

* 无。

**返回值**

一个空的 DateTime 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```


## emptyArrayFloat32 {#emptyArrayFloat32}

在 v1.1 中引入

返回一个空的 Float32 类型数组

**语法**

```sql
emptyArrayFloat32()
```

**参数**

* 无。

**返回值**

一个空的 Float32 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```


## emptyArrayFloat64 {#emptyArrayFloat64}

自 v1.1 起提供

返回一个空的 Float64 数组

**语法**

```sql
emptyArrayFloat64()
```

**参数**

* 无。

**返回值**

一个空的 Float64 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```


## emptyArrayInt16 {#emptyArrayInt16}

自 v1.1 引入

返回一个空的 Int16 数组

**语法**

```sql
emptyArrayInt16()
```

**参数**

* 无。

**返回值**

一个空的 Int16 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```


## emptyArrayInt32 {#emptyArrayInt32}

引入于：v1.1

返回一个空的 Int32 数组

**语法**

```sql
emptyArrayInt32()
```

**参数**

* 无参数。

**返回值**

空的 Int32 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```


## emptyArrayInt64 {#emptyArrayInt64}

自 v1.1 引入

返回空的 Int64 数组

**语法**

```sql
emptyArrayInt64()
```

**参数**

* 无。

**返回值**

Int64 类型的空数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```


## emptyArrayInt8 {#emptyArrayInt8}

自 v1.1 起引入

返回一个空的 Int8 数组。

**语法**

```sql
emptyArrayInt8()
```

**参数**

* 无。

**返回值**

空的 Int8 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```


## emptyArrayString {#emptyArrayString}

自 v1.1 引入

返回一个空的 String 数组

**语法**

```sql
emptyArrayString()
```

**参数**

* 无。

**返回值**

空的 String 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```


## emptyArrayToSingle {#emptyArrayToSingle}

引入版本：v1.1

接受一个空数组，并返回一个包含单个元素的数组，该元素为该类型的默认值。

**语法**

```sql
emptyArrayToSingle(arr)
```

**参数**

* `arr` — 一个空数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

包含一个该数组元素类型默认值的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**基础示例**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16 {#emptyArrayUInt16}

引入版本：v1.1

返回一个空的 UInt16 数组

**语法**

```sql
emptyArrayUInt16()
```

**参数**

* 无。

**返回值**

一个空的 UInt16 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```


## emptyArrayUInt32 {#emptyArrayUInt32}

引入版本：v1.1

返回一个空的 UInt32 类型数组

**语法**

```sql
emptyArrayUInt32()
```

**参数**

* 无。

**返回值**

空的 UInt32 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```


## emptyArrayUInt64 {#emptyArrayUInt64}

首次引入于：v1.1

返回一个空的 UInt64 数组

**语法**

```sql
emptyArrayUInt64()
```

**参数**

* 无。

**返回值**

一个空的 UInt64 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```


## emptyArrayUInt8 {#emptyArrayUInt8}

引入版本：v1.1

返回一个空的 UInt8 数组

**语法**

```sql
emptyArrayUInt8()
```

**参数**

* 无。

**返回值**

一个空的 UInt8 数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```


## has {#has}

自 v1.1 版本引入

返回数组是否包含指定元素。

**语法**

```sql
has(arr, x)
```

**参数**

* `arr` — 源数组。[`Array(T)`](/sql-reference/data-types/array)
* `x` — 在数组中要搜索的值。

**返回值**

如果数组包含指定元素，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本用法**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**未找到**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```


## hasAll {#hasAll}

引入版本：v1.1

检查一个数组是否为另一个数组的子集。

* 空数组是任何数组的子集。
* 将 `Null` 作为一个值进行处理。
* 两个数组中值的顺序无关紧要。

**语法**

```sql
hasAll(set, subset)
```

**参数**

* `set` — 任意类型元素组成的数组。[`Array(T)`](/sql-reference/data-types/array)
* `subset` — 与 `set` 具有共同超类型的任意类型数组，包含需要测试是否为 `set` 子集的元素。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

* 如果 `set` 包含 `subset` 中的所有元素，则为 `1`。
* 否则为 `0`。

当 `set` 和 `subset` 的元素不具有共同超类型时，会抛出 `NO_COMMON_TYPE` 异常。

**示例**

**空数组**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**包含 NULL 值的数组**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**包含不同类型元素的数组**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**包含 String 类型值的数组**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**没有共同类型的数组**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
抛出 NO_COMMON_TYPE 异常
```

**数组的数组（嵌套数组）**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```


## hasAny {#hasAny}

引入版本：v1.1

检查两个数组是否存在共同元素（是否有交集）。

* 将 `Null` 视为普通值进行处理。
* 两个数组中值的顺序无关紧要。

**语法**

```sql
hasAny(arr_x, arr_y)
```

**参数**

* `arr_x` — 任意类型的数组，包含一组元素。[`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — 任意类型的数组，其元素与数组 `arr_x` 具有共同的超类型。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

* 若 `arr_x` 和 `arr_y` 至少有一个相同元素，则为 `1`。
* 否则为 `0`。

如果两个数组中有任意元素之间不存在共同的超类型，则抛出 `NO_COMMON_TYPE` 异常。

**示例**

**其中一个数组为空**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**包含 NULL 值的数组**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**包含不同类型元素的数组**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**元素类型不统一的数组**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
抛出 `NO_COMMON_TYPE` 异常
```

**嵌套数组**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```


## hasSubstr {#hasSubstr}

引入版本：v20.6

检查 `array2` 的所有元素是否以完全相同的顺序出现在 `array1` 中。
因此，当且仅当 `array1 = prefix + array2 + suffix` 时，该函数返回 `1`。

换句话说，该函数会像 `hasAll` 函数一样检查，`array2` 的所有元素是否全部包含在 `array1` 中。
此外，它还会检查在 `array1` 和 `array2` 中，这些元素是否以相同的顺序出现。

* 如果 `array2` 为空，则函数返回 `1`。
* `Null` 会作为一个值进行处理。换句话说，`hasSubstr([1, 2, NULL, 3, 4], [2,3])` 将返回 `0`。然而，`hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` 将返回 `1`。
* 两个数组中值的顺序会影响结果。

如果两个数组中存在任意元素对不共享公共超类型，则抛出 `NO_COMMON_TYPE` 异常。

**语法**

```sql
hasSubstr(arr1, arr2)
```

**参数**

* `arr1` — 任意类型的数组，包含一组元素。[`Array(T)`](/sql-reference/data-types/array)
* `arr2` — 任意类型的数组，包含一组元素。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

当数组 `arr1` 包含数组 `arr2` 时返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**两个数组都为空**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**包含 NULL 值的数组**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**包含不同类型元素的数组**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**字符串数组**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**具有有效顺序的数组**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**具有无效排序的数组**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**数组的数组**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**没有共同类型的数组**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
抛出 `NO_COMMON_TYPE` 异常
```


## indexOf {#indexOf}

首次引入版本：v1.1

如果数组中包含值为 &#39;x&#39; 的元素，则返回其首次出现的元素索引（从 1 开始计数）。
如果数组不包含要查找的值，函数返回 `0`。

值为 `NULL` 的元素会被当作普通值处理。

**语法**

```sql
indexOf(arr, x)
```

**参数**

* `arr` — 要在其中搜索 `x` 的数组。[`Array(T)`](/sql-reference/data-types/array)
* `x` — 要查找的值，函数将返回 `arr` 中首个与之匹配元素的索引。[`UInt64`](/sql-reference/data-types/int-uint)

**返回值**

如果存在，则返回 `arr` 中第一个 `x` 的索引（从 1 开始编号）。否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基础示例**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**包含 NULL 的数组**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```


## indexOfAssumeSorted {#indexOfAssumeSorted}

引入于：v24.12

如果数组中包含值为 &#39;x&#39; 的元素，则返回第一个此类元素在数组中的索引（从 `1` 开始计数）。
如果数组中不包含要查找的值，则函数返回 `0`。

:::note
与 `indexOf` 函数不同，此函数假定数组已按升序排序。
如果数组未排序，则结果未定义。
:::

**语法**

```sql
indexOfAssumeSorted(arr, x)
```

**参数**

* `arr` — 要搜索的已排序数组。[`Array(T)`](/sql-reference/data-types/array)
* `x` — 要在已排序的 `arr` 中查找的值，返回第一个匹配元素的索引。[`UInt64`](/sql-reference/data-types/int-uint)

**返回值**

如果存在，则返回 `arr` 中第一个 `x` 的索引（从 1 开始编号）。否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基本示例**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```


## length {#length}

引入版本：v1.1

计算字符串或数组的长度。

* 对于 String 或 FixedString 参数：计算字符串中的字节数。
* 对于 Array 参数：计算数组中的元素个数。
* 如果作用于 FixedString 参数，该函数是一个常量表达式。

请注意，字符串中的字节数不同于 Unicode &quot;code points&quot; 的数量，也不同于 Unicode &quot;grapheme clusters&quot;（我们通常称为&quot;字符&quot;）的数量，也不同于可见字符串宽度。

字符串中允许包含 ASCII NULL 字节，并且这些字节同样会被计入长度。

**语法**

```sql
length(x)
```

**别名**: `OCTET_LENGTH`

**参数**

* `x` — 要计算其字节数（对于 String/FixedString）或元素个数（对于 Array）的值。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring) 或 [`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回 String/FixedString `x` 中的字节数，或数组 `x` 中的元素个数，类型为 [`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**String 示例**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**数组示例**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**constexpr 示例**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**Unicode 示例**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ascii&#95;vs&#95;utf8 示例**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty {#notEmpty}

引入自：v1.1

检查输入数组是否非空。

如果数组至少包含一个元素，则认为该数组是非空的。

:::note
可以通过启用 [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns) SETTING 来进行优化。将 `optimize_functions_to_subcolumns = 1` 设置为开启时，函数只读取 [size0](/sql-reference/data-types/array#array-size) 子列，而不是读取并处理整个数组列。查询 `SELECT notEmpty(arr) FROM table` 会被转换为 `SELECT arr.size0 != 0 FROM TABLE`。
:::

该函数同样适用于 String 或 UUID 类型。

**语法**

```sql
notEmpty(arr)
```

**参数**

* `arr` — 输入数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

非空数组返回 `1`，空数组返回 `0`，类型为 [`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```


## range {#range}

引入版本：v1.1

按 `step` 步长返回一个从 `start` 到 `end - 1` 的数字数组。

支持的类型为：

* `UInt8/16/32/64`

* `Int8/16/32/64]`

* 所有参数 `start`、`end`、`step` 必须是上述支持类型之一。返回数组的元素类型将是这些参数类型的超类型。

* 如果函数返回的数组总长度超过设置项 [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block) 指定的元素数量，将抛出异常。

* 如果任一参数的类型为 Nullable(nothing)，则返回 `NULL`。如果任一参数具有 `NULL` 值（Nullable(T) 类型），将抛出异常。

**语法**

```sql
range([start, ] end [, step])
```

**参数**

* `start` — 可选。数组的第一个元素。如果使用 `step`，则必须指定。默认值：`0`。 - `end` — 必填。构造数组时的上界（不包含该值）。 - `step` — 可选。决定数组中各元素之间的递增步长。默认值：`1`。

**返回值**

从 `start` 到 `end - 1`，步长为 `step` 的数字数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate {#replicate}

引入于：v1.1

创建一个仅包含单个值的数组。

**语法**

```sql
replicate(x, arr)
```

**参数**

* `x` — 用于填充结果数组的值。[`Any`](/sql-reference/data-types)
* `arr` — 一个数组。[`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个与 `arr` 长度相同、用值 `x` 填充的数组。[`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse {#reverse}

自 v1.1 版本起引入。

反转输入数组中元素的顺序或输入字符串中字符的顺序。

**语法**

```sql
reverse(arr | str)
```

**参数**

* `arr | str` — 输入数组或字符串。[`Array(T)`](/sql-reference/data-types/array) 或 [`String`](/sql-reference/data-types/string)

**返回值**

返回一个数组或字符串，其中元素或字符的顺序被反转。

**示例**

**反转数组**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**反转字符串**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

{/*AUTOGENERATED_END*/ }


## 距离函数 {#distance-functions}

所有受支持的函数均在[距离函数文档](../../sql-reference/functions/distance-functions.md)中进行了说明。

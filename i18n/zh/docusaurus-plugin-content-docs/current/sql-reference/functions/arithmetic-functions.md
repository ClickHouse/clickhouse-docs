---
description: '算术函数文档'
sidebar_label: '算术'
slug: /sql-reference/functions/arithmetic-functions
title: '算术函数'
doc_type: 'reference'
---



# 算术函数



## 概述 {#overview}

算术函数适用于类型为 `UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64`、`Float32` 或 `Float64` 的任意两个操作数。

在执行运算之前,两个操作数都会被转换为结果类型。结果类型按以下规则确定(除非下文的函数文档中另有说明):

- 如果两个操作数的位宽均不超过 32 位,则结果类型的大小将是两个操作数中较大者的下一级更大类型的大小(整数大小提升)。例如,`UInt8 + UInt16 = UInt32` 或 `Float32 * Float32 = Float64`。
- 如果其中一个操作数的位宽为 64 位或更多,则结果类型的大小将与两个操作数中较大者的大小相同。例如,`UInt32 + UInt128 = UInt128` 或 `Float32 * Float64 = Float64`。
- 如果其中一个操作数是有符号的,则结果类型也将是有符号的,否则将是无符号的。例如,`UInt32 * Int32 = Int64`。

这些规则确保结果类型是能够表示所有可能结果的最小类型。虽然这会在值范围边界处引入溢出风险,但它保证了使用 64 位的最大原生整数宽度快速执行计算。这种行为还确保了与许多其他数据库的兼容性,这些数据库提供 64 位整数(BIGINT)作为最大的整数类型。

示例:

```sql
SELECT toTypeName(0), toTypeName(0 + 0), toTypeName(0 + 0 + 0), toTypeName(0 + 0 + 0 + 0)
```

```text
┌─toTypeName(0)─┬─toTypeName(plus(0, 0))─┬─toTypeName(plus(plus(0, 0), 0))─┬─toTypeName(plus(plus(plus(0, 0), 0), 0))─┐
│ UInt8         │ UInt16                 │ UInt32                          │ UInt64                                   │
└───────────────┴────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┘
```

溢出的产生方式与 C++ 中相同。

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## abs {#abs}

引入版本:v1.1

计算 `x` 的绝对值。如果 `x` 为无符号类型,则无影响。如果 `x` 为有符号类型,则返回无符号数。

**语法**

```sql
abs(x)
```

**参数**

- `x` — 需要计算绝对值的值

**返回值**

`x` 的绝对值

**示例**

**使用示例**

```sql title=查询
SELECT abs(-0.5)
```

```response title=响应
0.5
```


## avg2 {#avg2}

引入版本:v25.11

计算并返回所提供参数的平均值。
支持数值和时间类型。

**语法**

```sql
avg2(x1, x2])
```

**参数**

- `x1, x2]` — 接受两个值用于求平均值。

**返回值**

返回所提供参数的平均值,类型提升为最大兼容类型。

**示例**

**数值类型**

```sql title=Query
SELECT avg2(toUInt8(3), 1.0) AS result, toTypeName(result) AS type;
-- 返回类型为 Float64,因为 UInt8 必须提升为 64 位才能进行比较。
```

```response title=Response
┌─result─┬─type────┐
│      2 │ Float64 │
└────────┴─────────┘
```

**Decimal 类型**

```sql title=Query
SELECT avg2(toDecimal32(1, 2), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Date 类型**

```sql title=Query
SELECT avg2(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**DateTime 类型**

```sql title=Query
SELECT avg2(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Time64 类型**

```sql title=Query
SELECT avg2(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```


## byteSwap {#byteSwap}

引入版本:v23.10

反转整数的字节顺序,即改变其[字节序](https://en.wikipedia.org/wiki/Endianness)。

下面的示例可以按以下方式理解:

1. 将十进制整数转换为大端格式的十六进制表示,即 3351772109 -> C7 C7 FB CD(4 字节)
2. 反转字节顺序,即 C7 C7 FB CD -> CD FB C7 C7
3. 假设为大端格式,将结果转换回整数,即 CD FB C7 C7 -> 3455829959
   此函数的一个使用场景是反转 IPv4 地址:

```result
┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
│ 199.199.251.205                                       │
└───────────────────────────────────────────────────────┘
```

**语法**

```sql
byteSwap(x)
```

**参数**

- `x` — 整数值。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回字节顺序反转后的 `x`。[`(U)Int*`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=查询
SELECT byteSwap(3351772109)
```

```response title=响应
3455829959
```

**8 位**

```sql title=查询
SELECT byteSwap(54)
```

```response title=响应
54
```

**16 位**

```sql title=查询
SELECT byteSwap(4135)
```

```response title=响应
10000
```

**32 位**

```sql title=查询
SELECT byteSwap(3351772109)
```

```response title=响应
3455829959
```

**64 位**

```sql title=查询
SELECT byteSwap(123294967295)
```

```response title=响应
18439412204227788800
```


## divide {#divide}

引入版本:v1.1

计算两个值 `a` 和 `b` 的商。结果类型始终为 [Float64](/sql-reference/data-types/float)。
整数除法请使用 `intDiv` 函数。

:::note
除以 `0` 会返回 `inf`、`-inf` 或 `nan`。
:::

**语法**

```sql
divide(x, y)
```

**参数**

- `x` — 被除数
- `y` — 除数

**返回值**

x 和 y 的商

**示例**

**两数相除**

```sql title=Query
SELECT divide(25,5) AS quotient, toTypeName(quotient)
```

```response title=Response
5 Float64
```

**除以零**

```sql title=Query
SELECT divide(25,0)
```

```response title=Response
inf
```


## divideDecimal {#divideDecimal}

引入版本:v22.12

对两个十进制数执行除法运算。结果值的类型为 [Decimal256](/sql-reference/data-types/decimal)。
结果的小数位数可以通过 `result_scale` 参数显式指定(范围为 `[0, 76]` 的常量整数)。如果未指定,结果的小数位数为给定参数中的最大小数位数。

:::note
此函数的运行速度明显慢于常规的 `divide` 函数。
如果您不需要精确控制精度和/或需要快速计算,请考虑使用 [divide](#divide)。
:::

**语法**

```sql
divideDecimal(x, y[, result_scale])
```

**参数**

- `x` — 第一个值:[Decimal](/sql-reference/data-types/decimal)。
- `y` — 第二个值:[Decimal](/sql-reference/data-types/decimal)。
- `result_scale` — 结果的小数位数。类型为 [Int/UInt](/sql-reference/data-types/int-uint)。

**返回值**

具有给定小数位数的除法结果。[`Decimal256`](/sql-reference/data-types/decimal)

**示例**

**示例 1**

```sql title=Query
divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)
```

```response title=Response
┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐
│                                                -5.7142857142 │
└──────────────────────────────────────────────────────────────┘
```

**示例 2**

```sql title=Query
SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);
SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);
```

```response title=Response
┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐
│                                             -5.7 │
└──────────────────────────────────────────────────┘
┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐
│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
```


## divideOrNull {#divideOrNull}

引入版本:v25.5

与 `divide` 相同,但在除以零时返回 NULL。

**语法**

```sql
divideOrNull(x, y)
```

**参数**

- `x` — 被除数
- `y` — 除数

**返回值**

返回 x 除以 y 的商,如果除以零则返回 NULL。

**示例**

**除以零**

```sql title=Query
SELECT divideOrNull(25, 0)
```

```response title=Response
\N
```


## gcd {#gcd}

引入版本：v1.1

返回两个值 a 和 b 的最大公约数。

当除以零或将最小负数除以负一时会抛出异常。

**语法**

```sql
gcd(x, y)
```

**参数**

- `x` — 第一个整数
- `y` — 第二个整数

**返回值**

`x` 和 `y` 的最大公约数。

**示例**

**使用示例**

```sql title=Query
SELECT gcd(12, 18)
```

```response title=Response
6
```


## ifNotFinite {#ifNotFinite}

引入版本:v20.3

检查浮点数值是否为有限值。

您可以使用[三元运算符](/sql-reference/functions/conditional-functions#if)获得类似的结果:`isFinite(x) ? x : y`。

**语法**

```sql
ifNotFinite(x,y)
```

**参数**

- `x` — 要检查是否为有限值的值。[`Float*`](/sql-reference/data-types/float)
- `y` — 回退值。[`Float*`](/sql-reference/data-types/float)

**返回值**

- 如果 `x` 为有限值,则返回 `x`。
- 如果 `x` 不是有限值,则返回 `y`。

**示例**

**使用示例**

```sql title=Query
SELECT 1/0 AS infimum, ifNotFinite(infimum,42)
```

```response title=Response
inf  42
```


## intDiv {#intDiv}

引入版本：v1.1

对两个值 `x` 和 `y` 执行整数除法。换句话说,它计算商并向下舍入到最接近的较小整数。

结果的位宽与被除数(第一个参数)相同。

当除以零、商超出被除数的数值范围或将最小负数除以负一时,将抛出异常。

**语法**

```sql
intDiv(x, y)
```

**参数**

- `x` — 左操作数。- `y` — 右操作数。

**返回值**

`x` 和 `y` 的整数除法结果

**示例**

**两个浮点数的整数除法**

```sql title=Query
SELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)
```

```response title=Response
┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐
│ 1000 │ Int64                                   │
└──────┴─────────────────────────────────────────┘
```

**商超出被除数的数值范围**

```sql title=Query
SELECT
intDiv(1, 0.001) AS res,
toTypeName(res)
```

```response title=Response
Received exception from server (version 23.2.1):
Code: 153. DB::Exception: Received from localhost:9000. DB::Exception:
Cannot perform integer division, because it will produce infinite or too
large number: While processing intDiv(1, 0.001) AS res, toTypeName(res).
(ILLEGAL_DIVISION)
```


## intDivOrNull {#intDivOrNull}

引入版本:v25.5

与 `intDiv` 相同,但在除以零或将最小负数除以 -1 时返回 NULL。

**语法**

```sql
intDivOrNull(x, y)
```

**参数**

- `x` — 左操作数。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — 右操作数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

`x` 和 `y` 的整数除法结果,或 NULL。

**示例**

**整数除以零**

```sql title=查询
SELECT intDivOrNull(1, 0)
```

```response title=响应
\N
```

**将最小负数除以 -1**

```sql title=查询
SELECT intDivOrNull(-9223372036854775808, -1)
```

```response title=响应
\N
```


## intDivOrZero {#intDivOrZero}

引入版本:v1.1

与 `intDiv` 相同,但在除以零或将最小负数除以 -1 时返回零。

**语法**

```sql
intDivOrZero(a, b)
```

**参数**

- `a` — 左操作数。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `b` — 右操作数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

a 和 b 的整数除法结果,或零。

**示例**

**整数除以零**

```sql title=Query
SELECT intDivOrZero(1, 0)
```

```response title=Response
0
```

**将最小负数除以 -1**

```sql title=Query
SELECT intDivOrZero(0.05, -1)
```

```response title=Response
0
```


## isFinite {#isFinite}

引入版本：v1.1

如果 Float32 或 Float64 参数不是无穷大且不是 `NaN`，则返回 `1`，
否则返回 `0`。

**语法**

```sql
isFinite(x)
```

**参数**

- `x` — 要检查是否有限的数值。[`Float*`](/sql-reference/data-types/float)

**返回值**

如果 x 不是无穷大且不是 `NaN`，则为 `1`，否则为 `0`。

**示例**

**测试数值是否有限**

```sql title=查询
SELECT isFinite(inf)
```

```response title=响应
0
```


## isInfinite {#isInfinite}

引入版本:v1.1

    如果 Float32 或 Float64 参数为无穷大,则返回 `1`,否则返回 `0`。
    注意:对于 `NaN` 值返回 `0`。

**语法**

```sql
isInfinite(x)
```

**参数**

- `x` — 要检查是否为无穷大的数字。[`Float*`](/sql-reference/data-types/float)

**返回值**

如果 x 为无穷大则返回 `1`,否则返回 `0`(包括 `NaN`)。

**示例**

**测试数字是否为无穷大**

```sql title=查询
SELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))
```

```response title=响应
1 0 0
```


## isNaN {#isNaN}

引入版本:v1.1

如果 Float32 或 Float64 类型的参数为 `NaN`,则返回 `1`,否则返回 `0`。

**语法**

```sql
isNaN(x)
```

**参数**

- `x` — 待检测是否为 `NaN` 的参数。[`Float*`](/sql-reference/data-types/float)

**返回值**

若为 `NaN` 则返回 `1`,否则返回 `0`

**示例**

**使用示例**

```sql title=查询
SELECT isNaN(NaN)
```

```response title=响应
1
```


## lcm {#lcm}

引入版本：v1.1

返回两个值 `x` 和 `y` 的最小公倍数。

当除以零或将最小负数除以负一时会抛出异常。

**语法**

```sql
lcm(x, y)
```

**参数**

- `x` — 第一个整数。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — 第二个整数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回 `x` 和 `y` 的最小公倍数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT lcm(6, 8)
```

```response title=Response
24
```


## max2 {#max2}

引入版本：v21.11

    返回两个数值 `x` 和 `y` 中的较大值。

**语法**

```sql
max2(x, y)
```

**参数**

- `x` — 第一个值。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float) 或 [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 第二个值。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float) 或 [`Decimal`](/sql-reference/data-types/decimal)

**返回值**

返回 `x` 和 `y` 中的较大值。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=查询
SELECT max2(-1, 2)
```

```response title=响应
2
```


## midpoint {#midpoint}

引入版本：v25.11

计算并返回所提供参数的平均值。
支持数值和时间类型。

**语法**

```sql
midpoint(x1[, x2, ...])
```

**参数**

- `x1[, x2, ...]` — 接受单个值或多个值用于计算平均值。

**返回值**

返回所提供参数的平均值，类型提升为最大兼容类型。

**示例**

**数值类型**

```sql title=Query
SELECT midpoint(1, toUInt8(3), 0.5) AS result, toTypeName(result) AS type;
-- 返回类型为 Float64,因为 UInt8 必须提升为 64 位进行计算。
```

```response title=Response
┌─result─┬─type────┐
│    1.5 │ Float64 │
└────────┴─────────┘
```

**Decimal 类型**

```sql title=Query
SELECT midpoint(toDecimal32(1.5, 2), toDecimal32(1, 1), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Date 类型**

```sql title=Query
SELECT midpoint(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**DateTime 类型**

```sql title=Query
SELECT midpoint(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Time64 类型**

```sql title=Query
SELECT midpoint(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```


## min2 {#min2}

引入版本：v21.11

返回两个数值 `x` 和 `y` 中的较小值。

**语法**

```sql
min2(x, y)
```

**参数**

- `x` — 第一个值。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float) 或 [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 第二个值。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float) 或 [`Decimal`](/sql-reference/data-types/decimal)

**返回值**

返回 `x` 和 `y` 中的较小值。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=Query
SELECT min2(-1, 2)
```

```response title=Response
-1
```


## minus {#minus}

引入版本:v1.1

计算两个值 `a` 和 `b` 的差值。结果始终为有符号数。
与 plus 类似,可以从日期或日期时间中减去整数。
此外,还支持日期时间之间的减法运算,结果为它们之间的时间差。

**语法**

```sql
minus(x, y)
```

**参数**

- `x` — 被减数。
- `y` — 减数。

**返回值**

x 减去 y

**示例**

**两个数字相减**

```sql title=查询
SELECT minus(10, 5)
```

```response title=响应
5
```

**整数与日期相减**

```sql title=查询
SELECT minus(toDate('2025-01-01'),5)
```

```response title=响应
2024-12-27
```


## modulo {#modulo}

引入版本:v1.1

计算两个值 a 除以 b 的余数。

如果两个输入都是整数,结果类型为整数。如果其中一个输入是浮点数,结果类型为 Float64。

余数的计算方式与 C++ 中相同。对于负数使用截断除法。

当除以零或将最小负数除以负一时,会抛出异常。

**语法**

```sql
modulo(a, b)
```

**别名**:`mod`

**参数**

- `a` — 被除数
- `b` — 除数(模数)

**返回值**

a % b 的余数

**示例**

**使用示例**

```sql title=Query
SELECT modulo(5, 2)
```

```response title=Response
1
```


## moduloOrNull {#moduloOrNull}

引入版本:v25.5

计算 `a` 除以 `b` 的余数。与 `modulo` 函数类似,但当右侧参数为 0 时,`moduloOrNull` 将返回 NULL。

**语法**

```sql
moduloOrNull(x, y)
```

**别名**:`modOrNull`

**参数**

- `x` — 被除数。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)
- `y` — 除数(模数)。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回 `x` 除以 `y` 的余数,当除数为零时返回 null。

**示例**

**moduloOrNull 除以零**

```sql title=查询
SELECT moduloOrNull(5, 0)
```

```response title=响应
\N
```


## moduloOrZero {#moduloOrZero}

引入版本:v20.3

类似于取模运算,但当除数为零时返回零,而不是像 modulo 函数那样抛出异常。

**语法**

```sql
moduloOrZero(a, b)
```

**参数**

- `a` — 被除数。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)
- `b` — 除数(模数)。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float)

**返回值**

返回 a % b 的余数,当除数为 `0` 时返回 `0`。

**示例**

**使用示例**

```sql title=查询
SELECT moduloOrZero(5, 0)
```

```response title=响应
0
```


## multiply {#multiply}

引入版本:v1.1

计算两个值 `x` 和 `y` 的乘积。

**语法**

```sql
multiply(x, y)
```

**参数**

- `x` — 乘数. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 乘数. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)

**返回值**

返回 x 和 y 的乘积。

**示例**

**两数相乘**

```sql title=查询
SELECT multiply(5,5)
```

```response title=响应
25
```


## multiplyDecimal {#multiplyDecimal}

引入版本：v22.12

对两个十进制数执行乘法运算。结果值的类型为 [Decimal256](/sql-reference/data-types/decimal)。
可以通过 `result_scale` 参数显式指定结果的标度（范围为 `[0, 76]` 的常量整数）。如果未指定，结果标度为给定参数中的最大标度。

:::note
这些函数的运行速度明显慢于常规的 `multiply` 函数。
如果您不需要精确控制精度和/或需要快速计算，请考虑使用 [multiply](#multiply)
:::

**语法**

```sql
multiplyDecimal(a, b[, result_scale])
```

**参数**

- `a` — 第一个值。[`Decimal`](/sql-reference/data-types/decimal)
- `b` — 第二个值。[`Decimal`](/sql-reference/data-types/decimal)
- `result_scale` — 结果的标度。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

具有给定标度的乘法结果。类型：[`Decimal256`](/sql-reference/data-types/decimal)

**示例**

**使用示例**

```sql title=查询
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=响应
25.2
```

**与常规乘法的区别**

```sql title=查询
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=响应
┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                               -26.8609633 │
└───────────────────────────────────────────────────────────┘
┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                                         -26.8609 │
└──────────────────────────────────────────────────────────────────┘
```

**十进制溢出**

```sql title=查询
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    multiplyDecimal(a, b);
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    a * b;
```

```response title=响应
┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐
│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │
└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘
从服务器接收到异常（版本 22.11.1）：
代码：407. DB::Exception: 从 localhost:9000 接收。DB::Exception: 十进制数学溢出：
处理 toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b 时。(DECIMAL_OVERFLOW)
```


## negate {#negate}

引入版本：v1.1

对参数 `x` 取反。结果始终为有符号数。

**语法**

```sql
negate(x)
```

**参数**

- `x` — 要取反的值。

**返回值**

返回 x 的相反数 -x

**示例**

**使用示例**

```sql title=查询
SELECT negate(10)
```

```response title=响应
-10
```


## plus {#plus}

引入版本：v1.1

计算两个值 `x` 和 `y` 的和。别名：`x + y`（运算符）。
可以将整数与日期或日期时间相加。前者操作会增加日期的天数，后者操作会增加日期时间的秒数。

**语法**

```sql
plus(x, y)
```

**参数**

- `x` — 左操作数。
- `y` — 右操作数。

**返回值**

返回 x 和 y 的和

**示例**

**两个数字相加**

```sql title=查询
SELECT plus(5,5)
```

```response title=响应
10
```

**整数与日期相加**

```sql title=查询
SELECT plus(toDate('2025-01-01'),5)
```

```response title=响应
2025-01-06
```


## positiveModulo {#positiveModulo}

引入版本：v22.11

计算 `x` 除以 `y` 的余数。与 `modulo` 函数类似，但 `positiveModulo` 始终返回非负数。

**语法**

```sql
positiveModulo(x, y)
```

**别名**：`positive_modulo`、`pmod`

**参数**

- `x` — 被除数。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float) 或 [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 除数（模数）。[`(U)Int*`](/sql-reference/data-types/int-uint) 或 [`Float*`](/sql-reference/data-types/float) 或 [`Decimal`](/sql-reference/data-types/decimal)

**返回值**

返回 `x` 与不大于 `x` 且能被 `y` 整除的最近整数之间的差值。

**示例**

**使用示例**

```sql title=查询
SELECT positiveModulo(-1, 10)
```

```response title=响应
9
```


## positiveModuloOrNull {#positiveModuloOrNull}

引入版本:v25.5

计算 `a` 除以 `b` 的余数。与函数 `positiveModulo` 类似,但当右侧参数为 0 时,`positiveModuloOrNull` 将返回 NULL。

**语法**

```sql
positiveModuloOrNull(x, y)
```

**别名**:`positive_modulo_or_null`、`pmodOrNull`

**参数**

- `x` — 被除数。[`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float)。
- `y` — 除数(模数)。[`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float)。

**返回值**

返回 `x` 与不大于 `x` 且能被 `y` 整除的最接近整数之间的差值,当除数为零时返回 `null`。

**示例**

**positiveModuloOrNull**

```sql title=查询
SELECT positiveModuloOrNull(5, 0)
```

```response title=响应
\N
```

<!--AUTOGENERATED_END-->

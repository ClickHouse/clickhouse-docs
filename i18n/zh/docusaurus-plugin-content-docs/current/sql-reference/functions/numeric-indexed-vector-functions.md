---
description: 'NumericIndexedVector 及其函数的文档'
sidebar_label: 'NumericIndexedVector'
slug: /sql-reference/functions/numeric-indexed-vector-functions
title: 'NumericIndexedVector 函数'
doc_type: 'reference'
---

# NumericIndexedVector

NumericIndexedVector 是一种抽象数据结构，它封装了向量，并实现向量聚合和按元素运算。Bit-Sliced Index 是其存储方式。关于理论基础和使用场景，请参考论文 [Large-Scale Metric Computation in Online Controlled Experiment Platform](https://arxiv.org/pdf/2405.08411)。

## BSI {#bit-sliced-index}

在 BSI（Bit-Sliced Index，位切片索引）存储方式中，数据首先以 [Bit-Sliced Index](https://dl.acm.org/doi/abs/10.1145/253260.253268) 形式存储，然后再使用 [Roaring Bitmap](https://github.com/RoaringBitmap/RoaringBitmap) 进行压缩。聚合运算和逐点运算可以直接在压缩数据上执行，从而显著提升存储与查询效率。

一个向量包含索引及其对应的值。以下是该数据结构在 BSI 存储模式下的一些特性与约束：

- 索引类型可以是 `UInt8`、`UInt16` 或 `UInt32` 之一。**注意：** 考虑到 Roaring Bitmap 的 64 位实现性能，BSI 格式不支持 `UInt64`/`Int64`。
- 值类型可以是 `Int8`、`Int16`、`Int32`、`Int64`、`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Float32` 或 `Float64` 之一。**注意：** 值类型不会自动提升。例如，如果你使用 `UInt8` 作为值类型，任何超过 `UInt8` 容量的求和结果都会发生溢出，而不会自动提升为更高精度类型；同样，整数运算将产生整数结果（例如除法不会自动转换为浮点结果）。因此，提前规划和设计值类型非常重要。在实际场景中，通常使用浮点类型（`Float32`/`Float64`）。
- 只有索引类型和值类型都相同的两个向量才能进行运算。
- 底层存储使用 Bit-Sliced Index，其中位图用于存储索引。Roaring Bitmap 被用作位图的具体实现。最佳实践是尽可能将索引集中到少数几个 Roaring Bitmap 容器中，以最大化压缩率和查询性能。
- Bit-Sliced Index 机制会将值转换为二进制。对于浮点类型，会使用定点表示进行转换，这可能导致精度损失。可以通过自定义用于小数部分的位数来调整精度，默认是 24 位，这在大多数场景下已经足够。在使用带有 `-State` 的聚合函数 groupNumericIndexedVector 构建 NumericIndexedVector 时，可以自定义整数位数和小数位数。
- 索引的取值情况有三种：非零值、零值和不存在。在 NumericIndexedVector 中，只会存储非零值和零值。此外，在两个 NumericIndexedVector 之间进行逐点运算时，不存在的索引的值会被视为 0。在除法场景下，当除数为 0 时结果为 0。

## 创建 numericIndexedVector 对象 {#create-numeric-indexed-vector-object}

有两种方式可以创建这种结构：一种是使用聚合函数 `groupNumericIndexedVector` 的 `-State` 变体。
你可以添加后缀 `-if` 以接收一个额外的条件。
聚合函数只会处理满足该条件的行。
另一种方式是使用 `numericIndexedVectorBuild` 从一个 map 构建它。
`groupNumericIndexedVectorState` 函数允许通过参数自定义整数位和小数位的数量，而 `numericIndexedVectorBuild` 则不支持。

## groupNumericIndexedVector

从两列数据构造一个 NumericIndexedVector，并以 `Float64` 类型返回所有值之和。如果添加后缀 `State`，则返回一个 NumericIndexedVector 对象。

**语法**

```sql
groupNumericIndexedVectorState(col1, col2)
groupNumericIndexedVectorState(type, integer_bit_num, fraction_bit_num)(col1, col2)
```

**参数**

* `type`：字符串，可选。指定存储格式。目前仅支持 `'BSI'`。
* `integer_bit_num`：`UInt32`，可选。在 `'BSI'` 存储格式下生效，该参数表示整数部分使用的位数。当索引类型为整数类型时，默认值对应于存储该索引类型所需的位数。例如，如果索引类型为 UInt16，则默认的 `integer_bit_num` 为 16。对于 Float32 和 Float64 索引类型，`integer_bit_num` 的默认值为 40，因此可表示的数据整数部分范围为 `[-2^39, 2^39 - 1]`。合法范围为 `[0, 64]`。
* `fraction_bit_num`：`UInt32`，可选。在 `'BSI'` 存储格式下生效，该参数表示小数部分使用的位数。当值类型为整数时，默认值为 0；当值类型为 Float32 或 Float64 时，默认值为 24。合法范围为 `[0, 24]`。
* 另有约束：`integer_bit_num + fraction_bit_num` 的有效范围为 `[0, 64]`。
* `col1`：索引列。支持的类型：`UInt8`/`UInt16`/`UInt32`/`Int8`/`Int16`/`Int32`。
* `col2`：数值列。支持的类型：`Int8`/`Int16`/`Int32`/`Int64`/`UInt8`/`UInt16`/`UInt32`/`UInt64`/`Float32`/`Float64`。

**返回值**

一个 `Float64` 值，表示所有数值的和。

**示例**

测试数据：

```text
用户ID  游戏时长
1       10
2       20
3       30
```

查询与结果：

```sql
SELECT groupNumericIndexedVector(UserID, PlayTime) AS num FROM t;
┌─num─┐
│  60 │
└─────┘

SELECT groupNumericIndexedVectorState(UserID, PlayTime) as res, toTypeName(res), numericIndexedVectorAllValueSum(res) FROM t;
┌─res─┬─toTypeName(res)─────────────────────────────────────────────┬─numericIndexedVectorAllValueSum(res)──┐
│     │ AggregateFunction(groupNumericIndexedVector, UInt8, UInt8)  │ 60                                    │
└─────┴─────────────────────────────────────────────────────────────┴───────────────────────────────────────┘

SELECT groupNumericIndexedVectorStateIf(UserID, PlayTime, day = '2025-04-22') as res, toTypeName(res), numericIndexedVectorAllValueSum(res) FROM t;
┌─res─┬─toTypeName(res)────────────────────────────────────────────┬─numericIndexedVectorAllValueSum(res)──┐
│     │ AggregateFunction(groupNumericIndexedVector, UInt8, UInt8) │ 30                                    │
└─────┴────────────────────────────────────────────────────────────┴───────────────────────────────────────┘

SELECT groupNumericIndexedVectorStateIf('BSI', 32, 0)(UserID, PlayTime, day = '2025-04-22') as res, toTypeName(res), numericIndexedVectorAllValueSum(res) FROM t;
┌─res─┬─toTypeName(res)──────────────────────────────────────────────────────────┬─numericIndexedVectorAllValueSum(res)──┐
│     │ AggregateFunction('BSI', 32, 0)(groupNumericIndexedVector, UInt8, UInt8) │ 30                                    │
└─────┴──────────────────────────────────────────────────────────────────────────┴───────────────────────────────────────┘
```

:::note
以下文档内容由 `system.functions` 系统表生成。
:::

{/* 
  下面的标签用于从 system 表生成文档，不应删除。
  更多详细信息请参见 https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

{/*AUTOGENERATED_END*/ }

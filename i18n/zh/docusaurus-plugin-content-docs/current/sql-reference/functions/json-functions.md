---
description: 'JSON 函数文档'
sidebar_label: 'JSON'
slug: /sql-reference/functions/json-functions
title: 'JSON 函数'
doc_type: 'reference'
---

## JSON 函数的类型 \{#types-of-functions\}

用于解析 JSON 的函数分为两类：

- [`simpleJSON*` (`visitParam*`)](#simplejson-visitparam-functions)：用于以极高速度解析受限的 JSON 子集。
- [`JSONExtract*`](#jsonextract-functions)：用于解析常规 JSON。

### simpleJSON (visitParam) 函数 \{#simplejson-visitparam-functions\}

ClickHouse 提供了用于处理简化 JSON 的特殊函数。所有这些 JSON 函数都基于对 JSON 结构的强假设设计，力求在完成任务的前提下尽可能少做工作，以获得尽可能高的执行速度。

这些假设包括：

1.  字段名（函数参数）必须是常量。
2.  字段名在 JSON 中必须以某种规范形式编码。例如：`simpleJSONHas('{"abc":"def"}', 'abc') = 1`，但 `simpleJSONHas('{"\\u0061\\u0062\\u0063":"def"}', 'abc') = 0`
3.  字段会在任意嵌套层级上被无差别地搜索。如果存在多个匹配字段，则使用第一个出现的字段。
4.  JSON 在字符串字面量之外不包含空格字符。

### JSONExtract 函数 \{#jsonextract-functions\}

这些函数基于 [simdjson](https://github.com/lemire/simdjson) 实现，适用于更复杂的 JSON 解析场景。

### 不区分大小写的 JSONExtract 函数 \

这些函数在从 JSON 对象中提取值时，会基于 ASCII 进行不区分大小写的键匹配。
它们的行为与对应的区分大小写版本完全相同，只是对象键在匹配时不考虑大小写。
当存在多个仅大小写不同但均能匹配的键时，将返回第一个匹配项。

:::note
这些函数的性能可能低于对应的区分大小写版本，因此如有可能，请优先使用常规的 JSONExtract 函数。
:::

{/* 
  下面标签内的内容会在文档框架构建期间，
  被 system.functions 生成的文档替换。请不要修改或删除这些标签。
  参见：https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }


## JSONAllPaths

自 v24.8 引入

返回 JSON 列中每行所存储的所有路径列表。

**语法**

```sql
JSONAllPaths(json)
```

**参数**

* `json` — JSON 列。[`JSON`](/sql-reference/data-types/newjson)

**返回值**

返回由 JSON 列中所有路径组成的数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPaths(json)─┐
│ {"a":"42"}                           │ ['a']              │
│ {"b":"Hello"}                        │ ['b']              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a','c']          │
└──────────────────────────────────────┴────────────────────┘
```


## JSONAllPathsWithTypes

自 v24.8 起引入

返回 JSON 列中每一行所存储的所有路径及其数据类型列表。

**语法**

```sql
JSONAllPathsWithTypes(json)
```

**参数**

* `json` — JSON 列。[`JSON`](/sql-reference/data-types/newjson)

**返回值**

返回 JSON 列中所有路径及其对应数据类型的映射关系。[`Map(String, String)`](/sql-reference/data-types/map)

**示例**

**用法示例**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPathsWithTypes(json)───────────────┐
│ {"a":"42"}                           │ {'a':'Int64'}                             │
│ {"b":"Hello"}                        │ {'b':'String'}                            │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))','c':'Date'} │
└──────────────────────────────────────┴───────────────────────────────────────────┘
```


## JSONArrayLength

自 v23.2 起引入

返回最外层 JSON 数组中的元素数量。
如果输入的 JSON 字符串无效，则函数返回 `NULL`。

**语法**

```sql
JSONArrayLength(json)
```

**别名**: `JSON_ARRAY_LENGTH`

**参数**

* `json` — 包含有效 JSON 的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `json` 是有效的 JSON 数组字符串，则返回数组元素的数量，否则返回 `NULL`。[`Nullable(UInt64)`](/sql-reference/data-types/nullable)

**示例**

**用法示例**

```sql title=Query
SELECT
    JSONArrayLength(''),
    JSONArrayLength('[1,2,3]');
```

```response title=Response
┌─JSONArrayLength('')─┬─JSONArrayLength('[1,2,3]')─┐
│                ᴺᵁᴸᴸ │                          3 │
└─────────────────────┴────────────────────────────┘
```


## JSONDynamicPaths

自 v24.8 引入

返回存储为 JSON 列中独立子列的动态路径列表。

**语法**

```sql
JSONDynamicPaths(json)
```

**参数**

* `json` — JSON 列。[`JSON`](/sql-reference/data-types/newjson)

**返回值**

返回 JSON 列中动态路径的数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPaths(json)─┐
│ {"a":"42"}                           │ ['a']                  │
│ {"b":"Hello"}                        │ []                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a']                  │
└──────────────────────────────────────┴────────────────────────┘
```


## JSONDynamicPathsWithTypes

引入于：v24.8

返回 JSON 列中每一行里，作为单独子列存储的动态路径及其类型的列表。

**语法**

```sql
JSONDynamicPathsWithTypes(json)
```

**参数**

* `json` — JSON 列。[`JSON`](/sql-reference/data-types/newjson)

**返回值**

返回 JSON 列中动态路径与其数据类型之间的映射关系。[`Map(String, String)`](/sql-reference/data-types/map)

**示例**

**使用示例**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {'a':'Int64'}                   │
│ {"b":"Hello"}                        │ {}                              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))'}  │
└──────────────────────────────────────┴─────────────────────────────────┘
```


## JSONExtract

自 v19.14 版本引入

解析 JSON，并按照指定的 ClickHouse 数据类型提取对应的值。

**语法**

```sql
JSONExtract(json[, indices_or_keys, ...], return_type)
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数组成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `return_type` — 要返回的 ClickHouse 数据类型。[`String`](/sql-reference/data-types/string)

**返回值**

如果可能，返回指定的 ClickHouse 数据类型的值，否则返回该类型的默认值。

**示例**

**用法示例**

```sql title=Query
SELECT JSONExtract('{"a": "hello", "b": [-100, 200.0, 300]}', 'Tuple(String, Array(Float64))') AS res;
```

```response title=Response
┌─res──────────────────────────────┐
│ ('hello',[-100,200,300])         │
└──────────────────────────────────┘
```


## JSONExtractArrayRaw

自 v20.1 起引入

返回一个数组，其中包含 JSON 数组中的各个元素，每个元素以原始（未解析）字符串形式表示。

**语法**

```sql
JSONExtractArrayRaw(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数构成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回由 JSON 数组元素组成的字符串数组。如果相应部分不是数组或不存在，则返回空数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT JSONExtractArrayRaw('{"a": "hello", "b": [-100, 200.0, "hello"]}', 'b') AS res;
```

```response title=Response
┌─res──────────────────────────┐
│ ['-100','200.0','"hello"']   │
└──────────────────────────────┘
```


## JSONExtractArrayRawCaseInsensitive

自 v25.8 起引入

返回一个数组，其中包含 JSON 数组的各个元素，每个元素都以未解析的字符串形式表示，并在匹配键名时不区分大小写。此函数类似于 [`JSONExtractArrayRaw`](#JSONExtractArrayRaw)。

**语法**

```sql
JSONExtractArrayRawCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于定位到数组的索引或键。键进行不区分大小写的匹配 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回原始 JSON 字符串的数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**基础用法**

```sql title=Query
SELECT JSONExtractArrayRawCaseInsensitive('{"Items": [1, 2, 3]}', 'ITEMS')
```

```response title=Response
['1','2','3']
```


## JSONExtractBool

自 v20.1 版本引入

解析 JSON 并提取布尔（Bool）类型的值。

**语法**

```sql
JSONExtractBool(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数构成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

如果存在则返回一个 Bool 类型的值，否则返回 `0`。[`Bool`](/sql-reference/data-types/boolean)

**示例**

**使用示例**

```sql title=Query
SELECT JSONExtractBool('{"passed": true}', 'passed') AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```


## JSONExtractBoolCaseInsensitive

自 v25.8 引入

解析 JSON，并使用不区分大小写的键名匹配来提取布尔值。此函数类似于 [`JSONExtractBool`](#JSONExtractBool)。

**语法**

```sql
JSONExtractBoolCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于导航到目标字段的索引或键。键名大小写不敏感 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回提取到的布尔值（true 为 1，false 为 0），未找到时返回 0。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**基本用法**

```sql title=Query
SELECT JSONExtractBoolCaseInsensitive('{"IsActive": true}', 'isactive')
```

```response title=Response
1
```


## JSONExtractCaseInsensitive

自 v25.8 版本引入。

解析 JSON，并使用不区分大小写的键匹配来提取指定 ClickHouse 数据类型的值。此函数类似于 [`JSONExtract`](#JSONExtract)。

**语法**

```sql
JSONExtractCaseInsensitive(json [, indices_or_keys...], return_type)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于导航到字段的索引或键。键进行不区分大小写匹配 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `return_type` — 提取后要转换成的 ClickHouse 数据类型 [`String`](/sql-reference/data-types/string)

**返回值**

以指定的数据类型返回提取出的值。[`Any`](/sql-reference/data-types)

**示例**

**int&#95;type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"Number": 123}', 'number', 'Int32')
```

```response title=Response
123
```

**array&#95;type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"List": [1, 2, 3]}', 'list', 'Array(Int32)')
```

```response title=Response
[1,2,3]
```


## JSONExtractFloat

引入版本：v20.1

解析 JSON 并提取 Float 类型的值。

**语法**

```sql
JSONExtractFloat(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数组成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

如果存在则返回一个 Float 类型的值，否则返回 `0`。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT JSONExtractFloat('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 2) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```


## JSONExtractFloatCaseInsensitive

于 v25.8 引入

解析 JSON，并使用不区分大小写的键名匹配提取 Float 类型的值。此函数类似于 [`JSONExtractFloat`](#JSONExtractFloat)。

**语法**

```sql
JSONExtractFloatCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于导航到目标字段的索引或键。键采用不区分大小写的匹配 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回提取到的浮点值，若未找到或无法转换，则返回 0。[`Float64`](/sql-reference/data-types/float)

**示例**

**基础用法**

```sql title=Query
SELECT JSONExtractFloatCaseInsensitive('{"Price": 12.34}', 'PRICE')
```

```response title=Response
12.34
```


## JSONExtractInt

自 v20.1 引入

解析 JSON 并提取 Int 类型的值。

**语法**

```sql
JSONExtractInt(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数组成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

如果存在则返回一个 Int 类型的值，否则返回 `0`。[`Int64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT JSONExtractInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 1) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```


## JSONExtractIntCaseInsensitive

自 v25.8 版本引入

解析 JSON，并通过对键进行不区分大小写的匹配来提取 Int 类型的值。此函数与 [`JSONExtractInt`](#JSONExtractInt) 类似。

**语法**

```sql
JSONExtractIntCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于导航到目标字段的索引或键。键进行不区分大小写的匹配，可为 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回提取出的 Int 值；如果未找到或无法转换，则返回 0。[`Int64`](/sql-reference/data-types/int-uint)

**示例**

**基础**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"Value": 123}', 'value')
```

```response title=Response
123
```

**嵌套**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"DATA": {"COUNT": 42}}', 'data', 'Count')
```

```response title=Response
42
```


## JSONExtractKeys

自 v21.11 引入

解析 JSON 字符串并提取其中的键。

**语法**

```sql
JSONExtractKeys(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数构成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个包含 JSON 对象键的数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT JSONExtractKeys('{"a": "hello", "b": [-100, 200.0, 300]}') AS res;
```

```response title=Response
┌─res─────────┐
│ ['a','b']   │
└─────────────┘
```


## JSONExtractKeysAndValues

自 v20.1 起引入

从 JSON 中解析键值对，其中值为给定的 ClickHouse 数据类型。

**语法**

```sql
JSONExtractKeysAndValues(json[, indices_or_keys, ...], value_type)
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数组成的列表，其中每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `value_type` — 值在 ClickHouse 中的数据类型。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个元组数组，其中包含解析后的键值对。[`Array(Tuple(String, value_type))`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT JSONExtractKeysAndValues('{"x": {"a": 5, "b": 7, "c": 11}}', 'Int8', 'x') AS res;
```

```response title=Response
┌─res────────────────────┐
│ [('a',5),('b',7),('c',11)] │
└────────────────────────┘
```


## JSONExtractKeysAndValuesCaseInsensitive

引入版本：v25.8

使用不区分大小写的键匹配方式，从 JSON 中解析键值对。此函数类似于 [`JSONExtractKeysAndValues`](#JSONExtractKeysAndValues)。

**语法**

```sql
JSONExtractKeysAndValuesCaseInsensitive(json [, indices_or_keys...], value_type)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于定位到对象的索引或键。键在匹配时不区分大小写 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `value_type` — 值在 ClickHouse 中的数据类型 [`String`](/sql-reference/data-types/string)

**返回值**

返回一个由元组组成的数组，每个元组包含一个键值对。[`Array(Tuple(String, T))`](/sql-reference/data-types/array)

**示例**

**基础示例**

```sql title=Query
SELECT JSONExtractKeysAndValuesCaseInsensitive('{"Name": "Alice", "AGE": 30}', 'String')
```

```response title=Response
[('Name','Alice'),('AGE','30')]
```


## JSONExtractKeysAndValuesRaw

自 v20.4 引入

返回一个元组数组，每个元组包含 JSON 对象中的键和值。所有值都以未解析的字符串形式表示。

**语法**

```sql
JSONExtractKeysAndValuesRaw(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数组成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个包含解析得到的键值对的元组数组，其中值为未解析的字符串。[`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT JSONExtractKeysAndValuesRaw('{"a": [-100, 200.0], "b": "hello"}') AS res;
```

```response title=Response
┌─res──────────────────────────────────┐
│ [('a','[-100,200.0]'),('b','"hello"')] │
└──────────────────────────────────────┘
```


## JSONExtractKeysAndValuesRawCaseInsensitive

引入版本：v25.8

从 JSON 中提取原始键值对，并使用对键名不区分大小写的匹配方式。此函数类似于 [`JSONExtractKeysAndValuesRaw`](#JSONExtractKeysAndValuesRaw)。

**语法**

```sql
JSONExtractKeysAndValuesRawCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于导航到目标对象的索引或键。键名匹配不区分大小写 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个元组数组，其中包含以原始字符串形式表示的键值对。[`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**示例**

**基础示例**

```sql title=Query
SELECT JSONExtractKeysAndValuesRawCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
[('Name','"Alice"'),('AGE','30')]
```


## JSONExtractKeysCaseInsensitive

引入版本：v25.8

解析 JSON 字符串，并通过不区分大小写的键匹配来定位嵌套对象并提取键。此函数类似于 [`JSONExtractKeys`](#JSONExtractKeys)。

**语法**

```sql
JSONExtractKeysCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于导航到目标对象的索引或键。键匹配时不区分大小写 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回 JSON 对象中的键数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**基本示例**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
['Name','AGE']
```

**嵌套**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"User": {"name": "John", "AGE": 25}}', 'user')
```

```response title=Response
['name','AGE']
```


## JSONExtractRaw

引入版本：v20.1

以未解析的字符串形式返回 JSON 片段。

**语法**

```sql
JSONExtractRaw(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数组成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回 JSON 中对应部分的原始（未解析）字符串。如果该部分不存在或类型不正确，则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT JSONExtractRaw('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') AS res;
```

```response title=Response
┌─res──────────────┐
│ [-100,200.0,300] │
└──────────────────┘
```


## JSONExtractRawCaseInsensitive

自 v25.8 起引入。

使用大小写不敏感的键匹配，以未解析字符串的形式返回 JSON 的部分内容。此函数类似于 [`JSONExtractRaw`](#JSONExtractRaw)。

**语法**

```sql
JSONExtractRawCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于导航到目标字段的索引或键。键使用不区分大小写的匹配方式 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回提取元素的原始 JSON 字符串。[`String`](/sql-reference/data-types/string)

**示例**

**object**

```sql title=Query
SELECT JSONExtractRawCaseInsensitive('{"Object": {"key": "value"}}', 'OBJECT')
```

```response title=Response
{"key":"value"}
```


## JSONExtractString

首次引入于：v20.1

解析 JSON 并提取 `String` 类型的值。

**语法**

```sql
JSONExtractString(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数组成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

如果存在对应值，则返回一个 String 类型的值，否则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT JSONExtractString('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') AS res;
```

```response title=Response
┌─res───┐
│ hello │
└───────┘
```


## JSONExtractStringCaseInsensitive

引入版本：v25.8

解析 JSON，并通过不区分大小写的键名匹配来提取字符串。此函数类似于 [`JSONExtractString`](#JSONExtractString)。

**语法**

```sql
JSONExtractStringCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于定位到目标字段的索引或键。键使用不区分大小写的匹配 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回提取出的字符串值，若未找到则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**基本用法**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"ABC": "def"}', 'abc')
```

```response title=Response
def
```

**嵌套**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"User": {"Name": "John"}}', 'user', 'name')
```

```response title=Response
John
```


## JSONExtractUInt

自 v20.1 版本引入

解析 JSON 并提取一个 UInt 类型的值。

**语法**

```sql
JSONExtractUInt(json [, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 由零个或多个参数组成的列表，每个参数可以是字符串或整数。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

如果存在则返回 UInt 值，否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT JSONExtractUInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', -1) AS res;
```

```response title=Response
┌─res─┐
│ 300 │
└─────┘
```


## JSONExtractUIntCaseInsensitive

引入于：v25.8

解析 JSON，并通过不区分大小写的键名匹配提取 `UInt` 类型的值。此函数类似于 [`JSONExtractUInt`](#JSONExtractUInt)。

**语法**

```sql
JSONExtractUIntCaseInsensitive(json [, indices_or_keys]...)
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 可选。用于定位到目标字段的索引或键。键进行不区分大小写的匹配 [`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回提取的 UInt 值，如果未找到或无法转换则返回 0。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**基础示例**

```sql title=Query
SELECT JSONExtractUIntCaseInsensitive('{"COUNT": 789}', 'count')
```

```response title=Response
789
```


## JSONHas

引入于：v20.1

检查 JSON 文档中是否存在给定的值。

**语法**

```sql
JSONHas(json[ ,indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `[ ,indices_or_keys, ...]` — 零个或多个参数的列表。[`String`](/sql-reference/data-types/string) 或 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

如果该值存在于 `json` 中则返回 `1`，否则返回 `0` [`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 1;
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 4) = 0;
```

```response title=Response
1
0
```


## JSONLength

自 v20.1 起引入

返回 JSON 数组或 JSON 对象的长度。
如果值不存在或类型不正确，则返回 `0`。

**语法**

```sql
JSONLength(json [, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 格式字符串 [`String`](/sql-reference/data-types/string)
* `[, indices_or_keys, ...]` — 可选。由零个或多个参数组成的列表，每个参数的类型为 [`String`](/sql-reference/data-types/string) 或 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

返回 JSON 数组或 JSON 对象的长度；如果值不存在或类型不正确，则返回 `0`。返回类型：[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 3;
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}') = 2;
```

```response title=Response
1
1
```


## JSONMergePatch

引入版本：v23.10

返回将多个 JSON 对象合并后得到的 JSON 对象字符串。

**语法**

```sql
jsonMergePatch(json1[, json2, ...])
```

**别名**: `jsonMergePatch`

**参数**

* `json1[, json2, ...]` — 一个或多个有效的 JSON 字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果 JSON 对象字符串有效，则返回合并后的 JSON 对象字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT jsonMergePatch('{"a":1}', '{"name": "joey"}', '{"name": "tom"}', '{"name": "zoey"}') AS res;
```

```response title=Response
┌─res───────────────────┐
│ {"a":1,"name":"zoey"} │
└───────────────────────┘
```


## JSONSharedDataPaths

自 v24.8 版本引入。

返回 JSON 列中共享数据结构所存储的路径列表。

**语法**

```sql
JSONSharedDataPaths(json)
```

**参数**

* `json` — JSON 列。[`JSON`](/sql-reference/data-types/newjson)

**返回值**

返回一个数组，包含存储在该 JSON 列的共享数据结构中的各个路径。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPaths(json)─┐
│ {"a":"42"}                           │ []                        │
│ {"b":"Hello"}                        │ ['b']                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['c']                     │
└──────────────────────────────────────┴───────────────────────────┘
```


## JSONSharedDataPathsWithTypes

自 v24.8 版本引入

返回存储在共享数据结构中的路径列表，以及这些路径在 JSON 列每一行中的数据类型。

**语法**

```sql
JSONSharedDataPathsWithTypes(json)
```

**参数**

* `json` — JSON 列。[`JSON`](/sql-reference/data-types/newjson)

**返回值**

返回一个映射，包含存储在共享的数据结构中的路径及其在 JSON 列中的数据类型。[`Map(String, String)`](/sql-reference/data-types/map)

**示例**

**用法示例**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {}                                  │
│ {"b":"Hello"}                        │ {'b':'String'}                      │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'c':'Date'}                        │
└──────────────────────────────────────┴─────────────────────────────────────┘
```


## JSONType

自 v20.1 版本引入

返回 JSON 值的类型。如果该值不存在，则返回 `Null=0`。

**语法**

```sql
JSONType(json[, indices_or_keys, ...])
```

**参数**

* `json` — 要解析的 JSON 字符串 [`String`](/sql-reference/data-types/string)
* `json[, indices_or_keys, ...]` — 零个或多个参数组成的列表，每个参数可以是字符串或整数类型。[`String`](/sql-reference/data-types/string) 或 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**返回值**

以字符串形式返回 JSON 值的类型；如果该值不存在，则返回 `Null=0` [`Enum`](/sql-reference/data-types/enum)

**示例**

**用法示例**

```sql title=Query
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}') = 'Object';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') = 'String';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 'Array';
```

```response title=Response
1
1
1
```


## JSON&#95;EXISTS

自 v21.8 版本引入

如果该值在 JSON 文档中存在，则返回 `1`。\
如果该值不存在，则返回 `0`。

**语法**

```sql
JSON_EXISTS(json, path)
```

**参数**

* `json` — 包含有效 JSON 的字符串。[`String`](/sql-reference/data-types/string)
* `path` — 表示路径的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果 JSON 文档中存在该值，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT JSON_EXISTS('{"hello":1}', '$.hello');
SELECT JSON_EXISTS('{"hello":{"world":1}}', '$.hello.world');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[*]');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[0]');
```

```response title=Response
┌─JSON_EXISTS(⋯ '$.hello')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯llo.world')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[*]')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[0]')─┐
│                        1 │
└──────────────────────────┘
```


## JSON&#95;QUERY

自 v21.8 起引入

解析 JSON，并将其中的某个值提取为 JSON 数组或 JSON 对象。
如果该值不存在，则返回空字符串。

**语法**

```sql
JSON_QUERY(json, path)
```

**参数**

* `json` — 包含有效 JSON 的字符串。[`String`](/sql-reference/data-types/string)
* `path` — 表示路径的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回提取出的 JSON 数组或 JSON 对象的字符串。如果该值不存在，则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT JSON_QUERY('{"hello":"world"}', '$.hello');
SELECT JSON_QUERY('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_QUERY('{"hello":2}', '$.hello');
SELECT toTypeName(JSON_QUERY('{"hello":2}', '$.hello'));
```

```response title=Response
["world"]
[0, 1, 4, 0, -1, -4]
[2]
String
```


## JSON&#95;VALUE

引入版本：v21.11

解析 JSON 并将某个值提取为 JSON 标量。如果该值不存在，则默认返回空字符串。

此函数受以下设置控制：

* 通过 SET `function_json_value_return_type_allow_nullable` = `true`，将返回 `NULL`。如果该值为复杂类型（例如：struct、array、map），则默认返回空字符串。
* 通过 SET `function_json_value_return_type_allow_complex` = `true`，将返回复杂类型的值。

**语法**

```sql
JSON_VALUE(json, path)
```

**参数**

* `json` — 包含有效 JSON 的字符串。[`String`](/sql-reference/data-types/string)
* `path` — 表示路径的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回提取到的 JSON 标量值（作为字符串）。如果该值不存在，则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT JSON_VALUE('{"hello":"world"}', '$.hello');
SELECT JSON_VALUE('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_VALUE('{"hello":2}', '$.hello');
SELECT JSON_VALUE('{"hello":"world"}', '$.b') settings function_json_value_return_type_allow_nullable=true;
```

```response title=Response
world
0
2
ᴺᵁᴸᴸ
```


## dynamicElement

引入版本：v24.1

从 `Dynamic` 列中提取指定类型的列。

此函数允许你从 `Dynamic` 列中提取特定类型的值。如果某行包含所请求类型的值，则返回该值。如果该行包含不同类型或为 NULL，则对标量类型返回 NULL，对数组类型返回空数组。

**语法**

```sql
dynamicElement(dynamic, type_name)
```

**参数**

* `dynamic` — 要从中提取值的 Dynamic 列。[`Dynamic`](/sql-reference/data-types/dynamic)
* `type_name` — 要提取的变体类型名称（例如：&#39;String&#39;、&#39;Int64&#39;、&#39;Array(Int64)&#39;）。

**返回值**

从 Dynamic 列中返回指定类型的值。类型不匹配时返回 NULL（对于数组类型返回空数组）。[`Any`](/sql-reference/data-types)

**示例**

**从 Dynamic 列中提取不同类型的数据**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d), dynamicElement(d, 'String'), dynamicElement(d, 'Int64'), dynamicElement(d, 'Array(Int64)'), dynamicElement(d, 'Date'), dynamicElement(d, 'Array(String)') FROM test
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┬─dynamicElement(d, 'String')─┬─dynamicElement(d, 'Int64')─┬─dynamicElement(d, 'Array(Int64)')─┬─dynamicElement(d, 'Date')─┬─dynamicElement(d, 'Array(String)')─┐
│ ᴺᵁᴸᴸ          │ None           │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ 42            │ Int64          │ ᴺᵁᴸᴸ                        │                         42 │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ Hello, World! │ String         │ Hello, World!               │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ [1,2,3]       │ Array(Int64)   │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ [1,2,3]                           │                      ᴺᵁᴸᴸ │ []                                 │
└───────────────┴────────────────┴─────────────────────────────┴────────────────────────────┴───────────────────────────────────┴───────────────────────────┴────────────────────────────────────┘
```


## dynamicType

引入版本：v24.1

对 `Dynamic` 列的每一行返回其变体类型名称。

对于值为 NULL 的行，函数返回 &#39;None&#39;。对于所有其他行，返回该行在 Dynamic 列中实际存储的数据类型（例如，&#39;Int64&#39;、&#39;String&#39;、&#39;Array(Int64)&#39;）。

**语法**

```sql
dynamicType(dynamic)
```

**参数**

* `dynamic` — 要检查的 Dynamic 类型列。[`Dynamic`](/sql-reference/data-types/dynamic)

**返回值**

返回每一行中所存储值的类型名称，对于 NULL 值返回 `'None'`。[`String`](/sql-reference/data-types/string)

**示例**

**检查 Dynamic 列中的类型**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d) FROM test;
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┐
│ ᴺᵁᴸᴸ          │ None           │
│ 42            │ Int64          │
│ Hello, World! │ String         │
│ [1,2,3]       │ Array(Int64)   │
└───────────────┴────────────────┘
```


## isDynamicElementInSharedData

引入版本：v24.1

对于 Dynamic 列中以共享变体格式（shared variant format）而非单独子列形式存储的行，返回 true。

当一个 Dynamic 列设置了 `max_types` 限制时，超出该限制的值会以共享二进制格式存储，
而不是被拆分为独立的类型化子列。此函数用于确定哪些行是以这种共享格式存储的。

**语法**

```sql
isDynamicElementInSharedData(dynamic)
```

**参数**

* `dynamic` — 要检查的 Dynamic 列。[`Dynamic`](/sql-reference/data-types/dynamic)

**返回值**

如果值以 shared variant 格式存储则返回 true，如果作为单独子列存储或为 NULL 则返回 false。[`Bool`](/sql-reference/data-types/boolean)

**示例**

**在设置了 max&#95;types 上限的 Dynamic 列中检查存储格式**

```sql title=Query
CREATE TABLE test (d Dynamic(max_types=2)) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, isDynamicElementInSharedData(d) FROM test;
```

```response title=Response
┌─d─────────────┬─isDynamicElementInSharedData(d)─┐
│ ᴺᵁᴸᴸ          │ false                           │
│ 42            │ false                           │
│ Hello, World! │ true                            │
│ [1,2,3]       │ true                            │
└───────────────┴─────────────────────────────────┘
```


## isValidJSON

首次引入于：v20.1

检查传入的字符串是否为有效的 JSON。

**语法**

```sql
isValidJSON(json)
```

**参数**

* `json` — 要验证的 JSON 字符串 [`String`](/sql-reference/data-types/string)

**返回值**

如果字符串是有效的 JSON，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT isValidJSON('{"a": "hello", "b": [-100, 200.0, 300]}') = 1;
SELECT isValidJSON('not JSON') = 0;
```

```response title=Response
1
0
```

**使用整数访问 JSON 数组和对象**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 0);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 3);
```

```response title=Response
0
1
1
1
1
1
0
```


## simpleJSONExtractBool

自 v21.4 版本引入

从名为 `field_name` 的字段值中解析一个 true/false 布尔值。
结果类型为 `UInt8`。

**语法**

```sql
simpleJSONExtractBool(json, field_name)
```

**别名**: `visitParamExtractBool`

**参数**

* `json` — 要搜索字段所在的 JSON。[`String`](/sql-reference/data-types/string)
* `field_name` — 要搜索的字段名称。[`const String`](/sql-reference/data-types/string)

**返回值**

如果字段的值为 `true`，则返回 `1`，否则返回 `0`。也就是说，在以下情况中（且不限于这些情况），该函数都会返回 `0`：

* 字段不存在。
* 字段的值是字符串形式的 `true`，例如：`{"field":"true"}`。
* 字段的值是数值 `1`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":false,"bar":true}');
INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONExtractBool(json, 'bar') FROM jsons ORDER BY json;
SELECT simpleJSONExtractBool(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
1
0
0
```


## simpleJSONExtractFloat

引入版本：v21.4

从名为 `field_name` 的字段值中解析 `Float64` 类型的数值。
如果 `field_name` 是字符串字段，则会尝试从字符串开头解析一个数字。
如果字段不存在，或者存在但不包含数字，则返回 `0`。

**语法**

```sql
simpleJSONExtractFloat(json, field_name)
```

**别名**: `visitParamExtractFloat`

**参数**

* `json` — 要在其中搜索字段的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `field_name` — 要搜索的字段名称。[`const String`](/sql-reference/data-types/string)

**返回值**

如果字段存在且包含数值，则返回从该字段解析出的数值，否则返回 `0`。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

````sql title=Query
```sql title=查询
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractFloat(json, 'foo') FROM jsons ORDER BY json;
```
````

```response title=Response
0
-4000
0
-3.4
5
```


## simpleJSONExtractInt

自 v21.4 起引入

从名为 `field_name` 的字段的值中解析 `Int64`。
如果 `field_name` 是字符串字段，则会尝试从字符串开头解析一个数字。
如果字段不存在，或者存在但不包含数字，则返回 `0`。

**语法**

```sql
simpleJSONExtractInt(json, field_name)
```

**别名**：`visitParamExtractInt`

**参数**

* `json` — 要在其中搜索字段的 JSON。[`String`](/sql-reference/data-types/string)
* `field_name` — 要搜索的字段名。[`const String`](/sql-reference/data-types/string)

**返回值**

如果字段存在且包含数字，则返回从该字段中解析出的数值 [`Int64`](/sql-reference/data-types/int-uint)，否则返回 `0`。

**示例**

**用法示例**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4
0
-3
5
```


## simpleJSONExtractRaw

自 v21.4 版本引入

返回名为 `field_name` 的字段值，类型为 `String`，并包含分隔符。

**语法**

```sql
simpleJSONExtractRaw(json, field_name)
```

**别名**: `visitParamExtractRaw`

**参数**

* `json` — 要在其中查找字段的 JSON。[`String`](/sql-reference/data-types/string)
* `field_name` — 要查找的字段名。[`const String`](/sql-reference/data-types/string)

**返回值**

如果字段存在，则返回包含分隔符的字段值字符串；否则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":{"def":[1,2,3]}}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractRaw(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
"-4e3"
-3.4
5
{"def":[1,2,3]}
```


## simpleJSONExtractString

引入版本：v21.4

从名为 `field_name` 的字段值中解析出用双引号括起来的 `String`。

**实现细节**

目前不支持格式为 `\uXXXX\uYYYY` 且不属于基本多文种平面的 Unicode 码点（这些码点会被转换为 CESU-8，而不是 UTF-8）。

**语法**

```sql
simpleJSONExtractString(json, field_name)
```

**别名**: `visitParamExtractString`

**参数**

* `json` — 包含要搜索字段的 JSON。[`String`](/sql-reference/data-types/string)
* `field_name` — 要搜索的字段名称。[`const String`](/sql-reference/data-types/string)

**返回值**

以字符串形式返回字段的去转义值（包括分隔符）。如果字段不包含带双引号的字符串、去转义失败或字段不存在，则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"\\n\\u0000"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263a"}');
INSERT INTO jsons VALUES ('{"foo":"hello}');

SELECT simpleJSONExtractString(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
\n\0

☺
```


## simpleJSONExtractUInt

自 v21.4 起引入

从名为 `field_name` 的字段值中解析 `UInt64`。
如果 `field_name` 是字符串字段，则尝试从字符串开头解析一个数字。
如果该字段不存在，或者存在但不包含数字，则返回 `0`。

**语法**

```sql
simpleJSONExtractUInt(json, field_name)
```

**别名**: `visitParamExtractUInt`

**参数**

* `json` — 要在其中搜索字段的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `field_name` — 要搜索的字段名称。[`const String`](/sql-reference/data-types/string)

**返回值**

如果字段存在且包含数字，则返回从该字段解析出的数字，否则返回 `0`。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"4e3"}');
INSERT INTO jsons VALUES ('{"foo":3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractUInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
4
0
3
5
```


## simpleJSONHas

自 v21.4 引入

检查是否存在名为 `field_name` 的字段。

**语法**

```sql
simpleJSONHas(json, field_name)
```

**别名**: `visitParamHas`

**参数**

* `json` — 要在其中搜索字段的 JSON 字符串。[`String`](/sql-reference/data-types/string)
* `field_name` — 要搜索的字段名。[`const String`](/sql-reference/data-types/string)

**返回值**

如果字段存在则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONHas(json, 'foo') FROM jsons;
SELECT simpleJSONHas(json, 'bar') FROM jsons;
```

```response title=Response
1
0
```


## toJSONString \

引入版本：v21.7

将一个值序列化为其 JSON 表示形式。支持多种数据类型和嵌套结构。
默认情况下，64 位[整数](../data-types/int-uint.md)或更大的整数（如 `UInt64` 或 `Int128`）会被用引号括起来。[output&#95;format&#95;json&#95;quote&#95;64bit&#95;integers](/operations/settings/formats#output_format_json_quote_64bit_integers) 用于控制这一行为。
特殊值 `NaN` 和 `inf` 会被替换为 `null`。启用 [output&#95;format&#95;json&#95;quote&#95;denormals](/operations/settings/formats#output_format_json_quote_denormals) 设置可以显示它们。
在序列化 [Enum](../data-types/enum.md) 值时，该函数会输出其名称。

另请参阅：

* [output&#95;format&#95;json&#95;quote&#95;64bit&#95;integers](/operations/settings/formats#output_format_json_quote_64bit_integers)
* [output&#95;format&#95;json&#95;quote&#95;denormals](/operations/settings/formats#output_format_json_quote_denormals)

**语法**

```sql
toJSONString(value)
```

**参数**

* `value` — 要序列化的值，可以是任意数据类型。[`Any`](/sql-reference/data-types)

**返回值**

返回该值的 JSON 表示形式。[`String`](/sql-reference/data-types/string)

**示例**

**Map 序列化**

```sql title=Query
SELECT toJSONString(map('key1', 1, 'key2', 2));
```

```response title=Response
┌─toJSONString(map('key1', 1, 'key2', 2))─┐
│ {"key1":1,"key2":2}                     │
└─────────────────────────────────────────┘
```

**特殊值**

```sql title=Query
SELECT toJSONString(tuple(1.25, NULL, NaN, +inf, -inf, [])) SETTINGS output_format_json_quote_denormals = 1;
```

```response title=Response
┌─toJSONString(tuple(1.25, NULL, NaN, plus(inf), minus(inf), []))─┐
│ [1.25,null,"nan","inf","-inf",[]]                               │
└─────────────────────────────────────────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

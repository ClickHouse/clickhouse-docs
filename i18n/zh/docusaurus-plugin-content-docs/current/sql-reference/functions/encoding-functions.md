---
description: '编码函数相关文档'
sidebar_label: '编码'
slug: /sql-reference/functions/encoding-functions
title: '编码函数'
keywords: ['编码', '常规函数', 'encode', 'decode']
doc_type: 'reference'
---

# 编码函数 {#encoding-functions}

{/* 
  以下标签中的内容会在文档框架构建时替换为
  根据 system.functions 生成的文档。请不要修改或删除这些标签。
  参见: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## bech32Decode {#bech32Decode}

引入版本：v25.6

对由 bech32 或 bech32m 算法生成的 Bech32 地址字符串进行解码。

:::note
与编码函数不同，`Bech32Decode` 会自动处理带填充的 FixedString。
:::

**语法**

```sql
bech32Decode(address)
```

**参数**

* `address` — 要解码的 Bech32 字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)

**返回值**

返回一个元组 `(hrp, data)`，其中包含用于编码该字符串的值。`data` 为二进制格式。[`Tuple(String, String)`](/sql-reference/data-types/tuple)

**示例**

**解码地址**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z') AS tup)
```

```response title=Response
bc   751E76E8199196D454941C45D1B3A323F1433BD6
```

**Testnet address**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('tb1w508d6qejxtdg4y5r3zarvary0c5xw7kzp034v') AS tup)
```

```response title=Response
tb   751E76E8199196D454941C45D1B3A323F1433BD6
```



## bech32Encode {#bech32Encode}

Introduced in: v25.6


Encodes a binary data string, along with a human-readable part (HRP), using the [Bech32 or Bech32m](https://en.bitcoin.it/wiki/Bech32) algorithms.

:::note
When using the [`FixedString`](../data-types/fixedstring.md) data type, if a value does not fully fill the row it is padded with null characters.
While the `bech32Encode` function will handle this automatically for the hrp argument, for the data argument the values must not be padded.
For this reason it is not recommended to use the [`FixedString`](../data-types/fixedstring.md) data type for your data values unless you are
certain that they are all the same length and ensure that your `FixedString` column is set to that length as well.
:::
    

**Syntax**

```sql
bech32Encode(hrp, data[, witver])
```

**Arguments**

- `hrp` — A String of `1 - 83` lowercase characters specifying the "human-readable part" of the code. Usually 'bc' or 'tb'. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `data` — A String of binary data to encode. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `witver` — Optional. The witness version (default = 1). An `UInt*` specifying the version of the algorithm to run. `0` for Bech32 and `1` or greater for Bech32m. [`UInt*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a Bech32 address string, consisting of the human-readable part, a separator character which is always '1', and a data part. The length of the string will never exceed 90 characters. If the algorithm cannot generate a valid address from the input, it will return an empty string. [`String`](/sql-reference/data-types/string)

**Examples**

**Default Bech32m**

```sql title=Query
-- 当未提供见证版本时，默认为 1，即更新后的 Bech32m 算法。
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'))
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7k8zcwmq
```

**Bech32 algorithm**

```sql title=Query
-- 见证版本为 0 将生成不同的地址字符串。
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 0)
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z
```

**Custom HRP**

```sql title=Query
-- 虽然在 SegWit 地址格式中，只有 'bc'（主网）和 'tb'（测试网）是允许的 hrp 值，
-- 但 Bech32 允许使用任何满足上述要求的 hrp。
SELECT bech32Encode('abcdefg', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 10)
```

```response title=Response
abcdefg1w508d6qejxtdg4y5r3zarvary0c5xw7k9rp8r4
```



## bin {#bin}

Introduced in: v21.8


Returns a string containing the argument's binary representation according
to the following logic for different types:

| Type                       | Description                                                                                                                                                                                                                                                           |
|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `(U)Int*`                  | Prints bin digits from the most significant to least significant (big-endian or "human-readable" order). It starts with the most significant non-zero byte (leading zero bytes are omitted) but always prints eight digits of every byte if the leading digit is zero.|
| `Date` and `DateTime`      | Formatted as corresponding integers (the number of days since epoch for Date and the value of unix timestamp for DateTime).                                                                                                                                           |
| `String` and `FixedString` | All bytes are simply encoded as eight binary numbers. Zero bytes are not omitted.                                                                                                                                                                                     |
| `Float*` and `Decimal`     | Encoded as their representation in memory. As we support little-endian architecture, they are encoded in little-endian. Zero leading/trailing bytes are not omitted.                                                                                                  |
| `UUID`                     | Encoded as big-endian order string.                                                                                                                                                                                                                                   |
    

**Syntax**

```sql
bin(arg)
```

**Arguments**

- `arg` — A value to convert to binary. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring) or [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal) or [`Date`](/sql-reference/data-types/date) or [`DateTime`](/sql-reference/data-types/datetime)


**Returned value**

Returns a string with the binary representation of the argument. [`String`](/sql-reference/data-types/string)

**Examples**

**Simple integer**

```sql title=Query
SELECT bin(14)
```

```response title=Response
┌─bin(14)──┐
│ 00001110 │
└──────────┘
```

**Float32 numbers**

```sql title=Query
SELECT bin(toFloat32(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────┐
│ 00000000000000000111000001000001 │
│ 00000000000000001000000001000001 │
└──────────────────────────────────┘
```

**Float64 numbers**

```sql title=Query
SELECT bin(toFloat64(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────────────────────────────────────┐
│ 0000000000000000000000000000000000000000000000000010111001000000 │
│ 0000000000000000000000000000000000000000000000000011000001000000 │
└──────────────────────────────────────────────────────────────────┘
```

**UUID conversion**

```sql title=Query
SELECT bin(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')) AS bin_uuid
```

```response title=Response
┌─bin_uuid─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ 01100001111100001100010000000100010111001011001100010001111001111001000001111011101001100000000001101010110100111101101110100000 │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```



## bitPositionsToArray {#bitPositionsToArray}

Introduced in: v21.7


This function returns the positions (in ascending order) of the 1 bits in the binary representation of an unsigned integer.
Signed input integers are first casted to an unsigned integer.
    

**Syntax**

```sql
bitPositionsToArray(arg)
```

**Arguments**

- `arg` — An integer value. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array with the ascendingly ordered positions of 1 bits in the binary representation of the input. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Single bit set**

```sql title=Query
SELECT bitPositionsToArray(toInt8(1)) AS bit_positions
```

```response title=Response
┌─bit_positions─┐
│ [0]           │
└───────────────┘
```

**All bits set**

```sql title=Query
SELECT bitPositionsToArray(toInt8(-1)) AS bit_positions
```

```response title=Response
┌─bit_positions─────────────┐
│ [0, 1, 2, 3, 4, 5, 6, 7]  │
└───────────────────────────┘
```



## bitmaskToArray {#bitmaskToArray}

Introduced in: v1.1


This function decomposes an integer into a sum of powers of two.
The powers of two are returned as an ascendingly ordered array.
    

**Syntax**

```sql
bitmaskToArray(数字)
```

**Arguments**

- `num` — An integer value. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array with the ascendingly ordered powers of two which sum up to the input number. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Basic example**

```sql title=Query
SELECT bitmaskToArray(50) AS powers_of_two
```

```response title=Response
┌─powers_of_two───┐
│ [2, 16, 32]     │
└─────────────────┘
```

**Single power of two**

```sql title=Query
SELECT bitmaskToArray(8) AS powers_of_two
```

```response title=Response
┌─powers_of_two─┐
│ [8]           │
└───────────────┘
```



## bitmaskToList {#bitmaskToList}

Introduced in: v1.1


Like bitmaskToArray but returns the powers of two as a comma-separated string.
    

**Syntax**

```sql
bitmaskToList(数字)
```

**Arguments**

- `num` — An integer value. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a string containing comma-separated powers of two. [`String`](/sql-reference/data-types/string)

**Examples**

**Basic example**

```sql title=Query
SELECT bitmaskToList(50) AS powers_list
```

```response title=Response
┌─powers_list───┐
│ 2, 16, 32     │
└───────────────┘
```



## char {#char}

Introduced in: v20.1


Returns a string with length equal to the number of arguments passed where each byte
has the value of the corresponding argument. Accepts multiple arguments of numeric types.

If the value of the argument is out of range of the `UInt8` data type, then it is converted
to `UInt8` with potential rounding and overflow.
        

**Syntax**

```sql
char(num1[, num2[, ...]])
```

**Arguments**

- `num1[, num2[, num3 ...]]` — Numerical arguments interpreted as integers. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)


**Returned value**

Returns a string of the given bytes. [`String`](/sql-reference/data-types/string)

**Examples**

**Basic example**

```sql title=Query
SELECT char(104.1, 101, 108.9, 108.9, 111) AS hello;
```

```response title=Response
┌─hello─┐
│ hello │
└───────┘
```

**Constructing arbitrary encodings**

```sql title=Query
-- 您可以通过传递相应的字节来构造任意编码的字符串。
-- 例如 UTF-8
SELECT char(0xD0, 0xBF, 0xD1, 0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1, 0x82) AS hello;
```

```response title=Response
┌─hello──┐
│ привет │
└────────┘
```



## hex {#hex}

Introduced in: v1.1


Returns a string containing the argument's hexadecimal representation according
to the following logic for different types:

| Type                       | Description                                                                                                                                                                                                                                                                            |
|----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `(U)Int*`                  | Prints hex digits ("nibbles") from the most significant to least significant (big-endian or "human-readable" order). It starts with the most significant non-zero byte (leading zero bytes are omitted) but always prints both digits of every byte even if the leading digit is zero. |
| `Date` and `DateTime`      | Formatted as corresponding integers (the number of days since epoch for Date and the value of unix timestamp for DateTime).                                                                                                                                                            |
| `String` and `FixedString` | All bytes are simply encoded as two hexadecimal numbers. Zero bytes are not omitted.                                                                                                                                                                                                   |
| `Float*` and `Decimal`     | Encoded as their representation in memory. ClickHouse represents the values internally always as little endian, therefore they are encoded as such. Zero leading/trailing bytes are not omitted.                                                                                                                   |
| `UUID`                     | Encoded as big-endian order string.                                                                                                                                                                                                                                                    |

The function uses uppercase letters `A-F` and not using any prefixes (like `0x`) or suffixes (like `h`).
    

**Syntax**

```sql
hex(arg)
```

**Arguments**

- `arg` — A value to convert to hexadecimal. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal) or [`Date`](/sql-reference/data-types/date) or [`DateTime`](/sql-reference/data-types/datetime)


**Returned value**

Returns a string with the hexadecimal representation of the argument. [`String`](/sql-reference/data-types/string)

**Examples**

**Simple integer**

```sql title=Query
SELECT hex(1)
```

```response title=Response
01
```

**Float32 numbers**

```sql title=Query
SELECT hex(toFloat32(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 00007041         │
│ 00008041         │
└──────────────────┘
```

**Float64 numbers**

```sql title=Query
SELECT hex(toFloat64(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 0000000000002E40 │
│ 0000000000003040 │
└──────────────────┘
```

**UUID conversion**

```sql title=Query
SELECT lower(hex(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'))) AS uuid_hex
```

```response title=Response
┌─uuid_hex─────────────────────────┐
│ 61f0c4045cb311e7907ba6006ad3dba0 │
└──────────────────────────────────┘
```



## hilbertDecode {#hilbertDecode}

Introduced in: v24.6


Decodes a Hilbert curve index back into a tuple of unsigned integers, representing coordinates in multi-dimensional space.

As with the `hilbertEncode` function, this function has two modes of operation:
- **Simple**
- **Expanded**

**Simple mode**

Accepts up to 2 unsigned integers as arguments and produces a `UInt64` code.

**Expanded mode**

Accepts a range mask (tuple) as a first argument and up to 2 unsigned integers as
other arguments. Each number in the mask configures the number of bits by which
the corresponding argument will be shifted left, effectively scaling the argument
within its range.

Range expansion can be beneficial when you need a similar distribution for
arguments with wildly different ranges (or cardinality) For example: 'IP Address' `(0...FFFFFFFF)`
and 'Country code' `(0...FF)`. As with the encode function, this is limited to 8
numbers at most.
    

**Syntax**

```sql
hilbertDecode(tuple_size, code)
```

**Arguments**

- `tuple_size` — Integer value of no more than `2`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint) or [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — `UInt64` code. [`UInt64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a tuple of the specified size. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**Examples**

**Simple mode**

```sql title=Query
SELECT hilbertDecode(2, 31)
```

```response title=Response
["3", "4"]
```

**Single argument**

```sql title=Query
-- 当只有一个参数时，其 Hilbert 编码始终就是该参数本身（作为元组）。
SELECT hilbertDecode(1, 1)
```

```response title=Response
["1"]
```

**Expanded mode**

```sql title=Query
-- 当以单个参数传入一个指定位移位数的元组时，将按该元组指定的位数进行右移。
SELECT hilbertDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**Column usage**

```sql title=Query
-- 首先创建表并插入数据
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';
insert into hilbert_numbers (*) values(1,2);

-- 使用列名而非常量作为函数参数
SELECT untuple(hilbertDecode(2, hilbertEncode(n1, n2))) FROM hilbert_numbers;
```

```response title=Response
1    2
```



## hilbertEncode {#hilbertEncode}

Introduced in: v24.6


Calculates code for Hilbert Curve for a list of unsigned integers.

The function has two modes of operation:
- **Simple**
- **Expanded**

**Simple mode**

Accepts up to 2 unsigned integers as arguments and produces a UInt64 code.

**Expanded mode**

Accepts a range mask ([Tuple](../../sql-reference/data-types/tuple.md)) as the
first argument and up to 2 [unsigned integers](../../sql-reference/data-types/int-uint.md)
as other arguments.

Each number in the mask configures the number of bits by which the corresponding
argument will be shifted left, effectively scaling the argument within its range.
    

**Syntax**

```sql
-- 简化模式
hilbertEncode(args)

-- 扩展模式
hilbertEncode(range_mask, args)
```

**Arguments**

- `args` — Up to two `UInt` values or columns of type `UInt`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — For the expanded mode, up to two `UInt` values or columns of type `UInt`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a `UInt64` code. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Simple mode**

```sql title=Query
SELECT hilbertEncode(3, 4)
```

```response title=Response
31
```

**Expanded mode**

```sql title=Query
-- 当需要为范围（或基数）差异极大的参数实现相似的分布时，范围扩展会很有用。
-- 例如：'IP 地址'（0...FFFFFFFF）和'国家代码'（0...FF）。
-- 注意：元组大小必须等于其他参数的数量。
SELECT hilbertEncode((10, 6), 1024, 16)
```

```response title=Response
4031541586602
```

**Single argument**

```sql title=Query
-- 当仅传入一个非元组的单个参数时，函数会将该参数本身作为 Hilbert 索引返回，
-- 因为不需要进行维度映射。
SELECT hilbertEncode(1)
```

```response title=Response
1
```

**Expanded single argument**

```sql title=Query
-- 如果只提供一个参数，并使用元组指定位移位数，函数会
-- 按指定的位数将该参数左移。
SELECT hilbertEncode(tuple(2), 128)
```

```response title=Response
512
```

**Column usage**

```sql title=Query
-- 首先创建表并插入一些数据
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1;
insert into hilbert_numbers (*) values(1, 2);

-- 使用列名而非常量作为函数参数
SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;
```

```response title=Response
13
```



## mortonDecode {#mortonDecode}

Introduced in: v24.6


Decodes a Morton encoding (ZCurve) into the corresponding unsigned integer tuple.

As with the `mortonEncode` function, this function has two modes of operation:
- **Simple**
- **Expanded**

**Simple mode**

Accepts a resulting tuple size as the first argument and the code as the second argument.

**Expanded mode**

Accepts a range mask (tuple) as the first argument and the code as the second argument.
Each number in the mask configures the amount of range shrink:

* `1` - no shrink
* `2` - 2x shrink
* `3` - 3x shrink
⋮
* Up to 8x shrink.

Range expansion can be beneficial when you need a similar distribution for
arguments with wildly different ranges (or cardinality). For example: 'IP Address' `(0...FFFFFFFF)`
and 'Country code' `(0...FF)`. As with the encode function, this is limited to
8 numbers at most.
    

**Syntax**

```sql
-- 简单模式
mortonDecode(tuple_size, code)

-- 扩展模式
mortonDecode(range_mask, code)
```

**Arguments**

- `tuple_size` — Integer value no more than 8. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — For the expanded mode, the mask for each argument. The mask is a tuple of unsigned integers. Each number in the mask configures the amount of range shrink. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — UInt64 code. [`UInt64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a tuple of the specified size. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**Examples**

**Simple mode**

```sql title=Query
SELECT mortonDecode(3, 53)
```

```response title=Response
["1", "2", "3"]
```

**Single argument**

```sql title=Query
SELECT mortonDecode(1, 1)
```

```response title=Response
["1"]
```

**Expanded mode, shrinking one argument**

```sql title=Query
SELECT mortonDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**Column usage**

```sql title=Query
-- 首先创建表并写入一些数据
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- 将列名用作函数参数，而不是使用常量
SELECT untuple(mortonDecode(8, mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8))) FROM morton_numbers;
```

```response title=Response
1 2 3 4 5 6 7 8
```



## mortonEncode {#mortonEncode}

Introduced in: v24.6


Calculates the Morton encoding (ZCurve) for a list of unsigned integers.

The function has two modes of operation:
- **Simple**
- *Expanded**

**Simple mode**

Accepts up to 8 unsigned integers as arguments and produces a `UInt64` code.

**Expanded mode**

Accepts a range mask ([Tuple](../data-types/tuple.md)) as the first argument and
up to 8 [unsigned integers](../data-types/int-uint.md) as other arguments.

Each number in the mask configures the amount of range expansion:
* 1 - no expansion
* 2 - 2x expansion
* 3 - 3x expansion
⋮
* Up to 8x expansion.
    

**Syntax**

```sql
-- 简化模式
mortonEncode(args)

-- 扩展模式
mortonEncode(range_mask, args)
```

**Arguments**

- `args` — Up to 8 unsigned integers or columns of the aforementioned type. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — For the expanded mode, the mask for each argument. The mask is a tuple of unsigned integers from `1` - `8`. Each number in the mask configures the amount of range shrink. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)


**Returned value**

Returns a `UInt64` code. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Simple mode**

```sql title=Query
SELECT mortonEncode(1, 2, 3)
```

```response title=Response
53
```

**Expanded mode**

```sql title=Query
-- 当你需要让取值范围（或基数）差异巨大的参数获得相似分布时，范围扩展会很有帮助
-- 例如：'IP Address' (0...FFFFFFFF) 和 'Country code' (0...FF)。
-- 注意：元组（Tuple）的大小必须等于其他参数的数量。
SELECT mortonEncode((1,2), 1024, 16)
```

```response title=Response
1572864
```

**Single argument**

```sql title=Query
-- 单个参数的 Morton 编码始终是参数本身
SELECT mortonEncode(1)
```

```response title=Response
1
```

**Expanded single argument**

```sql title=Query
SELECT mortonEncode(tuple(2), 128)
```

```response title=Response
32768
```

**Column usage**

```sql title=Query
-- 首先创建表并插入一些数据
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- 使用列名而不是常量作为函数参数
SELECT mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8) FROM morton_numbers;
```

```response title=Response
2155374165
```



## sqidDecode {#sqidDecode}

Introduced in: v24.1


Transforms a [sqid](https://sqids.org/) back into an array of numbers.
    

**Syntax**

```sql
sqidDecode(sqid)
```

**Arguments**

- `sqid` — The sqid to decode. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns an array of numbers from `sqid`. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT sqidDecode('gXHfJ1C6dN');
```

```response title=Response
┌─sqidDecode('gXHfJ1C6dN')─────┐
│ [1, 2, 3, 4, 5]              │
└──────────────────────────────┘
```



## sqidEncode {#sqidEncode}

Introduced in: v24.1


Transforms numbers into a [sqid](https://sqids.org/), a Youtube-like ID string.
    

**Syntax**

```sql
sqidEncode(n1[, n2, ...])
```

**Aliases**: `sqid`

**Arguments**

- `n1[, n2, ...]` — Arbitrarily many numbers. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a hash ID [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
SELECT sqidEncode(1, 2, 3, 4, 5);
```

```response title=Response
┌─sqidEncode(1, 2, 3, 4, 5)─┐
│ gXHfJ1C6dN                │
└───────────────────────────┘
```



## unbin {#unbin}

Introduced in: v21.8


Interprets each pair of binary digits (in the argument) as a number and converts it to the byte represented by the number. The functions performs the opposite operation to bin.

For a numeric argument `unbin()` does not return the inverse of `bin()`. If you want to convert the result to a number, you can use the reverse and `reinterpretAs<Type>` functions.

:::note
If `unbin` is invoked from within the `clickhouse-client`, binary strings are displayed using UTF-8.
:::

Supports binary digits `0` and `1`. The number of binary digits does not have to be multiples of eight. If the argument string contains anything other than binary digits,
the result is undefined (no exception is thrown).
    

**Syntax**

```sql
unbin(arg)
```

**Arguments**

- `arg` — A string containing any number of binary digits. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns a binary string (BLOB). [`String`](/sql-reference/data-types/string)

**Examples**

**Basic usage**

```sql title=Query
SELECT UNBIN('001100000011000100110010'), UNBIN('0100110101111001010100110101000101001100')
```

```response title=Response
┌─unbin('001100000011000100110010')─┬─unbin('0100110101111001010100110101000101001100')─┐
│ 012                               │ MySQL                                             │
└───────────────────────────────────┴───────────────────────────────────────────────────┘
```

**Convert to number**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unbin('1110'))) AS num
```

```response title=Response
┌─num─┐
│  14 │
└─────┘
```



## unhex {#unhex}

Introduced in: v1.1


Performs the opposite operation of [`hex`](#hex). It interprets each pair of hexadecimal digits (in the argument) as a number and converts
it to the byte represented by the number. The returned value is a binary string (BLOB).

If you want to convert the result to a number, you can use the `reverse` and `reinterpretAs<Type>` functions.

:::note
`clickhouse-client` interprets strings as UTF-8.
This may cause that values returned by `hex` to be displayed surprisingly.
:::

Supports both uppercase and lowercase letters `A-F`.
The number of hexadecimal digits does not have to be even.
If it is odd, the last digit is interpreted as the least significant half of the `00-0F` byte.
If the argument string contains anything other than hexadecimal digits, some implementation-defined result is returned (an exception isn't thrown).
For a numeric argument the inverse of hex(N) is not performed by unhex().


**Syntax**

```sql
unhex(arg)
```

**Arguments**

- `arg` — A string containing any number of hexadecimal digits. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)


**Returned value**

Returns a binary string (BLOB). [`String`](/sql-reference/data-types/string)

**Examples**

**Basic usage**

```sql title=Query
SELECT unhex('303132'), UNHEX('4D7953514C')
```

```response title=Response
┌─unhex('303132')─┬─unhex('4D7953514C')─┐
│ 012             │ MySQL               │
└─────────────────┴─────────────────────┘
```

**Convert to number**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unhex('FFF'))) AS num
```

```response title=Response
┌──num─┐
│ 4095 │
└──────┘
```

{/*AUTOGENERATED_END*/ }

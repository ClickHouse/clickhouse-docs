---
description: '字符串函数参考文档'
sidebar_label: '字符串'
slug: /sql-reference/functions/string-functions
title: '字符串处理函数'
doc_type: 'reference'
---

import VersionBadge from '@theme/badges/VersionBadge';

# 用于处理字符串的函数 {#functions-for-working-with-strings}

用于在字符串中[搜索](string-search-functions.md)和[替换](string-replace-functions.md)的函数在单独的文档中说明。

:::note
下文文档是从 `system.functions` 系统表生成的。
:::

{/* 
    以下标签中的内容会在构建文档框架时被
    从 system.functions 生成的文档替换。请勿修改或删除这些标签。
    参见：https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## CRC32 {#CRC32}

自 v20.1 引入

使用 CRC-32-IEEE 802.3 多项式和初始值 `0xffffffff`（zlib 实现）来计算字符串的 CRC32 校验和。

**语法**

```sql
CRC32(s)
```

**参数**

* `s` — 要计算 CRC32 的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回该字符串的 CRC32 校验和。[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT CRC32('ClickHouse')
```

```response title=Response
┌─CRC32('ClickHouse')─┐
│          1538217360 │
└─────────────────────┘
```

## CRC32IEEE {#CRC32IEEE}

首次引入于：v20.1

使用 CRC-32-IEEE 802.3 多项式计算字符串的 CRC32 校验值。

**语法**

```sql
CRC32IEEE(s)
```

**参数**

* `s` — 用于计算 CRC32 的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回该字符串的 CRC32 校验和。[`UInt32`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT CRC32IEEE('ClickHouse');
```

```response title=Response
┌─CRC32IEEE('ClickHouse')─┐
│              3089448422 │
└─────────────────────────┘
```

## CRC64 {#CRC64}

自 v20.1 引入

使用 CRC-64-ECMA 多项式计算字符串的 CRC64 校验和。

**语法**

```sql
CRC64(s)
```

**参数**

* `s` — 要计算 CRC64 的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回字符串的 CRC64 校验和。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT CRC64('ClickHouse');
```

```response title=Response
┌──CRC64('ClickHouse')─┐
│ 12126588151325169346 │
└──────────────────────┘
```

## appendTrailingCharIfAbsent {#appendTrailingCharIfAbsent}

自 v1.1 起引入

如果字符串 `s` 非空且不以字符 `c` 结尾，则将字符 `c` 追加到字符串 `s` 的末尾。

**语法**

```sql
appendTrailingCharIfAbsent(s, c)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)
* `c` — 若不存在则追加的字符。[`String`](/sql-reference/data-types/string)

**返回值**

返回字符串 `s`，如果 `s` 不以字符 `c` 结尾，则在末尾追加字符 `c`。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT appendTrailingCharIfAbsent('https://example.com', '/');
```

```response title=Response
┌─appendTraili⋯.com', '/')─┐
│ https://example.com/     │
└──────────────────────────┘
```

## ascii {#ascii}

自 v22.11 起引入

返回字符串 `s` 第一个字符的 ASCII 码点，类型为 `Int32`。

**语法**

```sql
ascii(s)
```

**参数**

* `s` — 字符串输入。[`String`](/sql-reference/data-types/string)

**返回值**

返回第一个字符的 ASCII 码点。若 `s` 为空，结果为 `0`。如果第一个字符不是 ASCII 字符，或不属于 UTF-16 的 Latin-1 补充块，则结果未定义。[`Int32`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT ascii('234')
```

```response title=Response
┌─ascii('234')─┐
│           50 │
└──────────────┘
```

## base32Decode {#base32Decode}

引入版本：v25.6

对 [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6)（RFC 4648）字符串进行解码。
如果字符串不是有效的 Base32 编码格式，将抛出异常。

**语法**

```sql
base32Decode(encoded)
```

**参数**

* `encoded` — 字符串类型的列或常量。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个字符串，包含参数的解码结果。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT base32Decode('IVXGG33EMVSA====');
```

```response title=Response
┌─base32Decode('IVXGG33EMVSA====')─┐
│ Encoded                          │
└──────────────────────────────────┘
```

## base32Encode {#base32Encode}

自 v25.6 引入

使用 [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) 对字符串进行编码。

**语法**

```sql
base32Encode(plaintext)
```

**参数**

* `plaintext` — 待编码的明文。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含该参数编码值的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)

**示例**

**用法示例**

```sql title=Query
SELECT base32Encode('Encoded')
```

```response title=Response
┌─base32Encode('Encoded')─┐
│ IVXGG33EMVSA====        │
└─────────────────────────┘
```

## base58Decode {#base58Decode}

自 v22.7 起引入

对 [Base58](https://datatracker.ietf.org/doc/html/draft-msporny-base58-03#section-3) 字符串进行解码。
如果字符串不是有效的 Base58 编码，则会抛出异常。

**语法**

```sql
base58Decode(encoded)
```

**参数**

* `encoded` — 要解码的字符串类型列或常量。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含参数解码后值的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT base58Decode('JxF12TrwUP45BMd');
```

```response title=Response
┌─base58Decode⋯rwUP45BMd')─┐
│ Hello World              │
└──────────────────────────┘
```

## base58Encode {#base58Encode}

引入版本：v22.7

使用 [Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) 编码字符串。

**语法**

```sql
base58Encode(plaintext)
```

**参数**

* `plaintext` — 要进行编码的明文。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含该参数编码后值的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT base58Encode('ClickHouse');
```

```response title=Response
┌─base58Encode('ClickHouse')─┐
│ 4nhk8K7GHXf6zx             │
└────────────────────────────┘
```

## base64Decode {#base64Decode}

引入版本：v18.16

根据 RFC 4648，从 [Base64](https://en.wikipedia.org/wiki/Base64) 表示形式解码字符串。
在出错时抛出异常。

**语法**

```sql
base64Decode(encoded)
```

**别名**: `FROM_BASE64`

**参数**

* `encoded` — 要解码的字符串列或常量。如果字符串不是有效的 Base64 编码字符串，则会抛出异常。[`String`](/sql-reference/data-types/string)

**返回值**

返回解码后的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT base64Decode('Y2xpY2tob3VzZQ==')
```

```response title=Response
┌─base64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                       │
└──────────────────────────────────┘
```

## base64Encode {#base64Encode}

自 v18.16 引入。

使用 [Base64](https://en.wikipedia.org/wiki/Base64) 表示法对字符串进行编码，遵循 RFC 4648。

**语法**

```sql
base64Encode(plaintext)
```

**别名**: `TO_BASE64`

**参数**

* `plaintext` — 要解码的明文列或常量。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含参数编码值的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT base64Encode('clickhouse')
```

```response title=Response
┌─base64Encode('clickhouse')─┐
│ Y2xpY2tob3VzZQ==           │
└────────────────────────────┘
```

## base64URLDecode {#base64URLDecode}

引入版本：v24.6

使用符合 RFC 4648 规定的 URL 安全字母表，从 [Base64](https://en.wikipedia.org/wiki/Base64) 表示中解码字符串。
在发生错误时抛出异常。

**语法**

```sql
base64URLDecode(encoded)
```

**参数**

* `encoded` — 要编码的字符串列或常量。如果该字符串不是有效的 Base64 编码字符串，则会抛出异常。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含参数解码结果的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                            │
└───────────────────────────────────────────────────┘
```

## base64URLEncode {#base64URLEncode}

自 v18.16 引入

使用适用于 URL 的安全字母表，将字符串编码为 [Base64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)（RFC 4648）表示形式。

**语法**

```sql
base64URLEncode(plaintext)
```

**参数**

* `plaintext` — 要编码的明文列或常量。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含参数编码后值的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT base64URLEncode('https://clickhouse.com')
```

```response title=Response
┌─base64URLEncode('https://clickhouse.com')─┐
│ aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ            │
└───────────────────────────────────────────┘
```

## basename {#basename}

自 v20.1 起引入

提取字符串中最后一个正斜杠或反斜杠之后的部分。
该函数通常用于从路径中提取文件名。

**语法**

```sql
basename(expr)
```

**参数**

* `expr` — 字符串表达式。反斜杠必须进行转义。[`String`](/sql-reference/data-types/string)

**返回值**

返回输入字符串中最后一个正斜杠或反斜杠之后的部分。如果输入字符串以正斜杠或反斜杠结尾，则函数返回空字符串。如果没有正斜杠或反斜杠，则返回原始字符串。[`String`](/sql-reference/data-types/string)

**示例**

**从 Unix 路径中提取文件名**

```sql title=Query
SELECT 'some/long/path/to/file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some/long/path/to/file')─┐
│ some/long/path/to/file │ file                               │
└────────────────────────┴────────────────────────────────────┘
```

**从 Windows 路径提取文件名**

```sql title=Query
SELECT 'some\\long\\path\\to\\file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some\\long\\path\\to\\file')─┐
│ some\long\path\to\file │ file                                   │
└────────────────────────┴────────────────────────────────────────┘
```

**不包含路径分隔符的字符串**

```sql title=Query
SELECT 'some-file-name' AS a, basename(a)
```

```response title=Response
┌─a──────────────┬─basename('some-file-name')─┐
│ some-file-name │ some-file-name             │
└────────────────┴────────────────────────────┘
```

## byteHammingDistance {#byteHammingDistance}

自 v23.9 起引入。

计算两个字节字符串之间的[汉明距离](https://en.wikipedia.org/wiki/Hamming_distance)。

**语法**

```sql
byteHammingDistance(s1, s2)
```

**别名**: `mismatches`

**参数**

* `s1` — 第一个输入字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 第二个输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回两个字符串之间的汉明距离 (Hamming distance)。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT byteHammingDistance('karolin', 'kathrin')
```

```response title=Response
┌─byteHammingDistance('karolin', 'kathrin')─┐
│                                         3 │
└───────────────────────────────────────────┘
```

## compareSubstrings {#compareSubstrings}

在 v25.2 中引入

按字典顺序比较两个字符串。

**语法**

```sql
compareSubstrings(s1, s2, s1_offset, s2_offset, num_bytes)
```

**参数**

* `s1` — 要比较的第一个字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 要比较的第二个字符串。[`String`](/sql-reference/data-types/string)
* `s1_offset` — 在 `s1` 中开始比较的偏移位置（从 0 开始）。[`UInt*`](/sql-reference/data-types/int-uint)
* `s2_offset` — 在 `s2` 中开始比较的偏移位置（从 0 开始的索引）。[`UInt*`](/sql-reference/data-types/int-uint)
* `num_bytes` — 在两个字符串中要比较的最大字节数。如果 `s1_offset`（或 `s2_offset`）+ `num_bytes` 超过输入字符串的末尾，则会自动相应减少 `num_bytes`。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回：

* 当 `s1`[`s1_offset` : `s1_offset` + `num_bytes`] &lt; `s2`[`s2_offset` : `s2_offset` + `num_bytes`] 时为 `-1`。
* 当 `s1`[`s1_offset` : `s1_offset` + `num_bytes`] = `s2`[`s2_offset` : `s2_offset` + `num_bytes`] 时为 `0`。
* 当 `s1`[`s1_offset` : `s1_offset` + `num_bytes`] &gt; `s2`[`s2_offset` : `s2_offset` + `num_bytes`] 时为 `1`。
  [`Int8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT compareSubstrings('Saxony', 'Anglo-Saxon', 0, 6, 5) AS result
```

```response title=Response
┌─result─┐
│      0 │
└────────┘
```

## concat {#concat}

引入版本：v1.1

将给定的参数连接为一个字符串。

不是 [`String`](../data-types/string.md) 或 [`FixedString`](../data-types/fixedstring.md) 类型的参数，会通过其默认序列化方式转换为字符串。
由于这会降低性能，不建议使用非 String/FixedString 类型的参数。

**语法**

```sql
concat([s1, s2, ...])
```

**参数**

* `s1, s2, ...` — 任意数量、任意类型的值。[`Any`](/sql-reference/data-types)

**返回值**

返回通过将各个参数连接起来创建的 String。如果任意参数为 `NULL`，则函数返回 `NULL`。如果没有参数，则返回空字符串。[`Nullable(String)`](/sql-reference/data-types/nullable)

**示例**

**字符串拼接**

```sql title=Query
SELECT concat('Hello, ', 'World!')
```

```response title=Response
┌─concat('Hello, ', 'World!')─┐
│ Hello, World!               │
└─────────────────────────────┘
```

**数字拼接**

```sql title=Query
SELECT concat(42, 144)
```

```response title=Response
┌─concat(42, 144)─┐
│ 42144           │
└─────────────────┘
```

## concatAssumeInjective {#concatAssumeInjective}

引入版本：v1.1

与 [`concat`](#concat) 类似，但假设 `concat(s1, s2, ...) → sn` 是单射，
即对不同的参数返回不同的结果。

可用于对 `GROUP BY` 的优化。

**语法**

```sql
concatAssumeInjective([s1, s2, ...])
```

**参数**

* `s1, s2, ...` — 任意数量、任意类型的值。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)

**返回值**

返回通过连接参数创建的字符串。如果任一参数值为 `NULL`，则函数返回 `NULL`。如果不传入任何参数，则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**GROUP BY 优化**

```sql title=Query
SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY concatAssumeInjective(key1, key2)
```

```response title=Response
┌─concat(key1, key2)─┬─sum(value)─┐
│ Hello, World!      │          3 │
│ Hello, World!      │          2 │
│ Hello, World       │          3 │
└────────────────────┴────────────┘
```

## concatWithSeparator {#concatWithSeparator}

引入版本：v22.12

将提供的字符串用指定的分隔符连接起来。

**语法**

```sql
concatWithSeparator(sep[, exp1, exp2, ...])
```

**别名**: `concat_ws`

**参数**

* `sep` — 要使用的分隔符。[`const String`](/sql-reference/data-types/string) 或 [`const FixedString`](/sql-reference/data-types/fixedstring)
* `exp1, exp2, ...` — 要连接的表达式。不是 `String` 或 `FixedString` 类型的参数将使用其默认序列化方式转换为字符串。由于这会降低性能，不建议传入非 `String`/`FixedString` 类型的参数。[`Any`](/sql-reference/data-types)

**返回值**

返回由各参数拼接而成的字符串。如果任一参数值为 `NULL`，则函数返回 `NULL`。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT concatWithSeparator('a', '1', '2', '3', '4')
```

```response title=Response
┌─concatWithSeparator('a', '1', '2', '3', '4')─┐
│ 1a2a3a4                                      │
└──────────────────────────────────────────────┘
```

## concatWithSeparatorAssumeInjective {#concatWithSeparatorAssumeInjective}

引入版本：v22.12

类似于 [`concatWithSeparator`](#concatWithSeparator)，但假定 `concatWithSeparator(sep[,exp1, exp2, ... ]) → result` 是单射。
如果对不同的参数返回不同的结果，则称该函数为单射（injective）。

可用于优化 `GROUP BY`。

**语法**

```sql
concatWithSeparatorAssumeInjective(sep[, exp1, exp2, ... ])
```

**参数**

* `sep` — 要使用的分隔符。[`const String`](/sql-reference/data-types/string) 或 [`const FixedString`](/sql-reference/data-types/fixedstring)
* `exp1, exp2, ...` — 要连接的表达式。不是 `String` 或 `FixedString` 类型的参数会使用其默认序列化方式转换为字符串。由于这会降低性能，不推荐使用非 String/FixedString 类型的参数。参数类型：[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)

**返回值**

返回通过连接各个参数创建的字符串。如果任一参数值为 `NULL`，则函数返回 `NULL`。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
CREATE TABLE user_data (
user_id UInt32,
first_name String,
last_name String,
score UInt32
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO user_data VALUES
(1, 'John', 'Doe', 100),
(2, 'Jane', 'Smith', 150),
(3, 'John', 'Wilson', 120),
(4, 'Jane', 'Smith', 90);

SELECT
    concatWithSeparatorAssumeInjective('-', first_name, last_name) as full_name,
    sum(score) as total_score
FROM user_data
GROUP BY concatWithSeparatorAssumeInjective('-', first_name, last_name);
```

```response title=Response
┌─full_name───┬─total_score─┐
│ Jane-Smith  │         240 │
│ John-Doe    │         100 │
│ John-Wilson │         120 │
└─────────────┴─────────────┘
```

## conv {#conv}

引入版本：v1.1

在不同进制之间转换数值。

该函数将一个数值从一种进制转换为另一种进制。它支持从 2 到 36 的进制。
对于大于 10 的进制，使用字母 A-Z（不区分大小写）来表示数值 10-35。

此函数与 MySQL 的 CONV() 函数兼容。

**语法**

```sql
conv(number, from_base, to_base)
```

**参数**

* `number` — 要转换的数值。可以是字符串或数值类型。 - `from_base` — 源进制（2–36）。必须是整数。 - `to_base` — 目标进制（2–36）。必须是整数。

**返回值**

该数值在目标进制下的字符串表示形式。

**示例**

**将十进制数转换为二进制**

```sql title=Query
SELECT conv('10', 10, 2)
```

```response title=Response
1010
```

**将十六进制转换为十进制**

```sql title=Query
SELECT conv('FF', 16, 10)
```

```response title=Response
255
```

**使用负数进行转换**

```sql title=Query
SELECT conv('-1', 10, 16)
```

```response title=Response
FFFFFFFFFFFFFFFF
```

**将二进制数转换为八进制数**

```sql title=Query
SELECT conv('1010', 2, 8)
```

```response title=Response
12
```

## convertCharset {#convertCharset}

自 v1.1 版本引入

返回将字符串 `s` 从编码 `from` 转换为编码 `to` 后的字符串。

**语法**

```sql
convertCharset(s, from, to)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)
* `from` — 源字符编码。[`String`](/sql-reference/data-types/string)
* `to` — 目标字符编码。[`String`](/sql-reference/data-types/string)

**返回值**

返回字符串 `s` 从编码 `from` 转换为编码 `to` 后的结果。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT convertCharset('Café', 'UTF-8', 'ISO-8859-1');
```

```response title=Response
┌─convertChars⋯SO-8859-1')─┐
│ Caf�                     │
└──────────────────────────┘
```

## damerauLevenshteinDistance {#damerauLevenshteinDistance}

自 v24.1 起提供

计算两个字节字符串之间的 [Damerau-Levenshtein 距离](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance)。

**语法**

```sql
damerauLevenshteinDistance(s1, s2)
```

**参数**

* `s1` — 第一个输入字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 第二个输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回两个字符串之间的 Damerau-Levenshtein 距离。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT damerauLevenshteinDistance('clickhouse', 'mouse')
```

```response title=Response
┌─damerauLevenshteinDistance('clickhouse', 'mouse')─┐
│                                                 6 │
└───────────────────────────────────────────────────┘
```

## decodeHTMLComponent {#decodeHTMLComponent}

引入版本：v23.9

将字符串中的 HTML 实体解码为相应字符。

**语法**

```sql
decodeHTMLComponent(s)
```

**参数**

* `s` — 包含要解码的 HTML 实体的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回解码 HTML 实体后的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')
```

```response title=Response
┌─decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')─┐
│ <div>Hello & "World"</div>                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

## decodeXMLComponent {#decodeXMLComponent}

自 v21.2 起引入

将字符串中的 XML 实体解码为对应的字符。

**语法**

```sql
decodeXMLComponent(s)
```

**参数**

* `s` — 包含需解码 XML 实体的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回解码了 XML 实体的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT decodeXMLComponent('&lt;tag&gt;Hello &amp; World&lt;/tag&gt;')
```

```response title=Response
┌─decodeXMLCom⋯;/tag&gt;')─┐
│ <tag>Hello & World</tag> │
└──────────────────────────┘
```

## editDistance {#editDistance}

引入于：v23.9

计算两个字节串之间的[编辑距离](https://en.wikipedia.org/wiki/Edit_distance)。

**语法**

```sql
editDistance(s1, s2)
```

**别名**: `levenshteinDistance`

**参数**

* `s1` — 第一个输入字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 第二个输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回两个字符串的编辑距离。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT editDistance('clickhouse', 'mouse')
```

```response title=Response
┌─editDistance('clickhouse', 'mouse')─┐
│                                   6 │
└─────────────────────────────────────┘
```

## editDistanceUTF8 {#editDistanceUTF8}

自 v24.6 起引入

计算两个 UTF-8 字符串之间的[编辑距离](https://en.wikipedia.org/wiki/Edit_distance)。

**语法**

```sql
editDistanceUTF8(s1, s2)
```

**别名**: `levenshteinDistanceUTF8`

**参数**

* `s1` — 第一个输入字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 第二个输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回两个 UTF-8 字符串之间的编辑距离。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT editDistanceUTF8('我是谁', '我是我')
```

```response title=Response
┌─editDistanceUTF8('我是谁', '我是我')──┐
│                                   1 │
└─────────────────────────────────────┘
```

## encodeXMLComponent {#encodeXMLComponent}

自 v21.1 起引入

用于对字符串中的字符进行转义，以便将字符串放入 XML 文本节点或属性中。

**语法**

```sql
encodeXMLComponent(s)
```

**参数**

* `s` — 要转义的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回转义后的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT
    '<tag>Hello & "World"</tag>' AS original,
    encodeXMLComponent('<tag>Hello & "World"</tag>') AS xml_encoded;
```

```response title=Response
┌─original───────────────────┬─xml_encoded──────────────────────────────────────────┐
│ <tag>Hello & "World"</tag> │ &lt;tag&gt;Hello &amp; &quot;World&quot;&lt;/tag&gt; │
└────────────────────────────┴──────────────────────────────────────────────────────┘
```

## endsWith {#endsWith}

自 v1.1 版本引入

检查字符串是否以指定后缀结束。

**语法**

```sql
endsWith(s, suffix)
```

**参数**

* `s` — 要检查的字符串。[`String`](/sql-reference/data-types/string)
* `suffix` — 要检查是否为结尾的后缀。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `s` 以 `suffix` 结尾，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT endsWith('ClickHouse', 'House');
```

```response title=Response
┌─endsWith('Cl⋯', 'House')─┐
│                        1 │
└──────────────────────────┘
```

## endsWithCaseInsensitive {#endsWithCaseInsensitive}

引入于：v25.9

检查字符串是否以给定的、不区分大小写的后缀结尾。

**语法**

```sql
endsWithCaseInsensitive(s, suffix)
```

**参数**

* `s` — 要检查的字符串。[`String`](/sql-reference/data-types/string)
* `suffix` — 要检查的、不区分大小写的后缀。[`String`](/sql-reference/data-types/string)

**返回值**

当 `s` 以 `suffix`（不区分大小写）结尾时返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT endsWithCaseInsensitive('ClickHouse', 'HOUSE');
```

```response title=Response
┌─endsWithCaseInsensitive('Cl⋯', 'HOUSE')─┐
│                                       1 │
└─────────────────────────────────────────┘
```

## endsWithCaseInsensitiveUTF8 {#endsWithCaseInsensitiveUTF8}

引入版本：v25.9

返回字符串 `s` 是否以不区分大小写的后缀 `suffix` 结尾。
假定字符串包含有效的 UTF-8 编码文本。
如果该假设不成立，不会抛出异常，结果未定义。

**语法**

```sql
endsWithCaseInsensitiveUTF8(s, suffix)
```

**参数**

* `s` — 要检查的字符串。[`String`](/sql-reference/data-types/string)
* `suffix` — 要检查的后缀（不区分大小写）。[`String`](/sql-reference/data-types/string)

**返回值**

如果在不区分大小写的情况下，`s` 以 `suffix` 结尾，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT endsWithCaseInsensitiveUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithCaseInsensitiveUTF8('данных', 'ых')─┐
│                                           1 │
└─────────────────────────────────────────────┘
```

## endsWithUTF8 {#endsWithUTF8}

引入版本：v23.8

返回字符串 `s` 是否以 `suffix` 结尾。
假设该字符串包含有效的 UTF-8 编码文本。
如果该假设不成立，则不会抛出异常，且结果未定义。

**语法**

```sql
endsWithUTF8(s, suffix)
```

**参数**

* `s` — 要检查的字符串。[`String`](/sql-reference/data-types/string)
* `suffix` — 要检查的后缀字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `s` 以 `suffix` 结尾，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT endsWithUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithUTF8('данных', 'ых')─┐
│                            1 │
└──────────────────────────────┘
```

## extractTextFromHTML {#extractTextFromHTML}

自 v21.3 引入

从 HTML 或 XHTML 中提取文本内容。

此函数会移除 HTML 标签、注释以及 script/style 元素，只保留文本内容。它会执行以下操作：

* 移除所有 HTML/XML 标签
* 移除注释（`<!-- -->`）
* 移除 script 和 style 元素及其内容
* 处理 CDATA 段（按原样复制）
* 正确处理并规范化空白字符

注意：HTML 实体不会被解码，如有需要，应使用单独的函数进行处理。

**Syntax**

```sql
extractTextFromHTML(html)
```

**参数**

* `html` — 包含要从中提取文本的 HTML 内容字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回提取出的文本内容，并对空白字符进行了规范化处理。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT extractTextFromHTML('
<html>
    <head><title>Page Title</title></head>
    <body>
        <p>Hello <b>World</b>!</p>
        <script>alert("test");</script>
        <!-- comment -->
    </body>
</html>
');
```

```response title=Response
┌─extractTextFromHTML('<html><head>...')─┐
│ Page Title Hello World!                │
└────────────────────────────────────────┘
```

## firstLine {#firstLine}

首次引入：v23.7

返回多行字符串的第一行。

**语法**

```sql
firstLine(s)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回输入字符串的第一行；如果没有换行符，则返回整个字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT firstLine('foo\\nbar\\nbaz')
```

```response title=Response
┌─firstLine('foo\nbar\nbaz')─┐
│ foo                        │
└────────────────────────────┘
```

## idnaDecode {#idnaDecode}

引入版本：v24.1

根据 [Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications)（IDNA）机制，使用 ToUnicode 算法返回域名的 Unicode（UTF-8）表示。
如果出现错误（例如输入无效），则返回输入字符串本身。
请注意，由于大小写规范化，反复调用 [`idnaEncode()`](#idnaEncode) 和 [`idnaDecode()`](#idnaDecode) 不一定会返回原始字符串。

**语法**

```sql
idnaDecode(s)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

按照输入值的 IDNA 机制转换后，返回该字符串的 Unicode（UTF-8）表示形式。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')
```

```response title=Response
┌─idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')─┐
│ straße.münchen.de                             │
└───────────────────────────────────────────────┘
```

## idnaEncode {#idnaEncode}

引入版本：v24.1

根据[应用中的国际化域名](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications)（IDNA）机制，返回域名的 ASCII 表示形式（使用 ToASCII 算法）。
输入字符串必须是 UTF 编码，并且可以转换为 ASCII 字符串，否则会抛出异常。

:::note
不会执行百分号解码，也不会去除制表符、空格或控制字符。
:::

**语法**

```sql
idnaEncode(s)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

根据输入值的 IDNA 规范，返回输入字符串的 ASCII 表示形式。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT idnaEncode('straße.münchen.de')
```

```response title=Response
┌─idnaEncode('straße.münchen.de')─────┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```

## initcap {#initcap}

引入自：v23.7

将每个单词的首字母转换为大写，其余字母转换为小写。
单词是指由非字母数字字符分隔的字母数字字符序列。

:::note
由于 `initcap` 只将每个单词的首字母转换为大写，对于包含撇号或本身带有大写字母的单词，可能会出现非预期行为。
这是已知行为，目前没有修复计划。
:::

**语法**

```sql
initcap(s)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回将 `s` 中每个单词的首字母转换为大写后的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT initcap('building for fast')
```

```response title=Response
┌─initcap('building for fast')─┐
│ Building For Fast            │
└──────────────────────────────┘
```

**关于包含撇号或大写字母的单词的已知行为示例**

```sql title=Query
SELECT initcap('John''s cat won''t eat.');
```

```response title=Response
┌─initcap('Joh⋯n\'t eat.')─┐
│ John'S Cat Won'T Eat.    │
└──────────────────────────┘
```

## initcapUTF8 {#initcapUTF8}

引入版本：v23.7

与 [`initcap`](#initcap) 类似，`initcapUTF8` 会将每个单词的首字母转换为大写，其余字母转换为小写。
假定字符串包含有效的 UTF-8 编码文本。
如果该假设不成立，不会抛出异常，结果未定义。

:::note
该函数不会检测语言，例如对于土耳其语，结果可能不完全正确（i/İ 与 i/I）。
如果某个码点的大写和小写形式的 UTF-8 字节序列长度不同，该码点的结果可能不正确。
:::

**语法**

```sql
initcapUTF8(s)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回将 `s` 中每个单词的首字母转换为大写后的结果。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT initcapUTF8('не тормозит')
```

```response title=Response
┌─initcapUTF8('не тормозит')─┐
│ Не Тормозит                │
└────────────────────────────┘
```

## isValidASCII {#isValidASCII}

引入版本：v25.9

如果输入的 String 或 FixedString 仅包含 ASCII 字节（0x00–0x7F），则返回 1，否则返回 0。

**语法**

```sql
```

**别名**：`isASCII`

**参数**

* 无。

**返回值**

**示例**

**isValidASCII**

```sql title=Query
SELECT isValidASCII('hello') AS is_ascii, isValidASCII('你好') AS is_not_ascii
```

```response title=Response
```

## isValidUTF8 {#isValidUTF8}

引入版本：v20.1

检查这组字节是否构成有效的 UTF-8 编码文本。

**语法**

```sql
isValidUTF8(s)
```

**参数**

* `s` — 待检查 UTF-8 编码有效性的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

如果该字节序列构成有效的 UTF-8 编码文本，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT isValidUTF8('\\xc3\\xb1') AS valid, isValidUTF8('\\xc3\\x28') AS invalid
```

```response title=Response
┌─valid─┬─invalid─┐
│     1 │       0 │
└───────┴─────────┘
```

## jaroSimilarity {#jaroSimilarity}

自 v24.1 引入

计算两个字节字符串之间的 [Jaro 相似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance#Jaro_similarity)。

**语法**

```sql
jaroSimilarity(s1, s2)
```

**参数**

* `s1` — 第一个输入字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 第二个输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回两个字符串之间的 Jaro 相似度。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT jaroSimilarity('clickhouse', 'click')
```

```response title=Response
┌─jaroSimilarity('clickhouse', 'click')─┐
│                    0.8333333333333333 │
└───────────────────────────────────────┘
```

## jaroWinklerSimilarity {#jaroWinklerSimilarity}

自 v24.1 起引入

计算两个字节字符串之间的 [Jaro-Winkler 相似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance)。

**语法**

```sql
jaroWinklerSimilarity(s1, s2)
```

**参数**

* `s1` — 第一个输入字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 第二个输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回两个字符串之间的 Jaro-Winkler 相似度。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT jaroWinklerSimilarity('clickhouse', 'click')
```

```response title=Response
┌─jaroWinklerSimilarity('clickhouse', 'click')─┐
│                           0.8999999999999999 │
└──────────────────────────────────────────────┘
```

## left {#left}

自 v22.1 引入

返回从左侧起、偏移量为 `offset` 的字符串 `s` 的子串。

**语法**

```sql
left(s, offset)
```

**参数**

* `s` — 要从中获取子字符串的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — 偏移的字节数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回：

* 当 `offset` 为正数时，从字符串左侧开始，返回长度为 `offset` 字节的 `s` 的子字符串。
* 当 `offset` 为负数时，从字符串左侧开始，返回长度为 `length(s) - |offset|` 字节的 `s` 的子字符串。
* 如果 `length` 为 `0`，返回空字符串。
  [`String`](/sql-reference/data-types/string)

**示例**

**正偏移量**

```sql title=Query
SELECT left('Hello World', 5)
```

```response title=Response
Hello
```

**负偏移**

```sql title=Query
SELECT left('Hello World', -6)
```

```response title=Response
Hello
```

## leftPad {#leftPad}

引入于：v21.8

在左侧使用空格或指定字符串（必要时重复多次）对字符串进行填充，直到结果字符串达到指定的 `length`。

**语法**

```sql
leftPad(string, length[, pad_string])
```

**别名**: `lpad`

**参数**

* `string` — 需要进行填充的输入字符串。[`String`](/sql-reference/data-types/string)
* `length` — 结果字符串的长度。如果该值小于输入字符串的长度，则输入字符串会被截断为 `length` 个字符。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 可选。用于对输入字符串进行填充的字符串。如果未指定，则使用空格对输入字符串进行填充。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个按给定长度左侧填充后的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT leftPad('abc', 7, '*'), leftPad('def', 7)
```

```response title=Response
┌─leftPad('abc', 7, '*')─┬─leftPad('def', 7)─┐
│ ****abc                │     def           │
└────────────────────────┴───────────────────┘
```

## leftPadUTF8 {#leftPadUTF8}

引入于：v21.8

从左侧使用空格或指定字符串（必要时可重复多次）填充 UTF-8 字符串，直到结果字符串达到给定长度。
与按字节计算字符串长度的 [`leftPad`](#leftPad) 不同，这里的字符串长度是按 Unicode 码点数量来计算的。

**语法**

```sql
leftPadUTF8(string, length[, pad_string])
```

**参数**

* `string` — 需要进行填充的输入字符串。[`String`](/sql-reference/data-types/string)
* `length` — 结果字符串的长度。如果该值小于输入字符串的长度，则输入字符串会被截断为 `length` 个字符。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 可选。用于填充输入字符串的字符串。如果未指定，则使用空格对输入字符串进行填充。[`String`](/sql-reference/data-types/string)

**返回值**

返回按指定长度左侧填充后的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT leftPadUTF8('абвг', 7, '*'), leftPadUTF8('дежз', 7)
```

```response title=Response
┌─leftPadUTF8('абвг', 7, '*')─┬─leftPadUTF8('дежз', 7)─┐
│ ***абвг                     │    дежз                │
└─────────────────────────────┴────────────────────────┘
```

## leftUTF8 {#leftUTF8}

引入版本：v22.1

返回 UTF-8 编码字符串 `s` 中，从左侧偏移 `offset` 后开始的子字符串。

**语法**

```sql
leftUTF8(s, offset)
```

**参数**

* `s` — 用于截取子字符串的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — 偏移量的字节数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回：

* 当 `offset` 为正时，返回从字符串左侧开始、长度为 `offset` 字节的 `s` 的子字符串。
* 当 `offset` 为负时，返回从字符串左侧开始、长度为 `length(s) - |offset|` 字节的 `s` 的子字符串。
* 当 `length` 为 0 时，返回空字符串。
  [`String`](/sql-reference/data-types/string)

**示例**

**正偏移量**

```sql title=Query
SELECT leftUTF8('Привет', 4)
```

```response title=Response
Прив
```

**负偏移量**

```sql title=Query
SELECT leftUTF8('Привет', -4)
```

```response title=Response
Пр
```

## lengthUTF8 {#lengthUTF8}

自 v1.1 起引入

返回字符串按 Unicode 码点计算的长度，而不是按字节或字符计算。
该函数假定字符串包含有效的 UTF-8 编码文本。
如果该假设不成立，则不会抛出异常，且结果未定义。

**语法**

```sql
lengthUTF8(s)
```

**别名**: `CHAR_LENGTH`, `CHARACTER_LENGTH`

**参数**

* `s` — 包含有效 UTF-8 编码文本的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

字符串 `s` 的长度，以 Unicode 码点个数计。[`UInt64`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT lengthUTF8('Здравствуй, мир!')
```

```response title=Response
┌─lengthUTF8('Здравствуй, мир!')─┐
│                             16 │
└────────────────────────────────┘
```

## lower {#lower}

在 v1.1 中引入

将 ASCII 字符串转换为小写。

**语法**

```sql
lower(s)
```

**别名**: `lcase`

**参数**

* `s` — 要转换为小写的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回将 `s` 转换为小写后的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT lower('CLICKHOUSE')
```

```response title=Response
┌─lower('CLICKHOUSE')─┐
│ clickhouse          │
└─────────────────────┘
```

## lowerUTF8 {#lowerUTF8}

自 v1.1 引入

将字符串转换为小写形式，前提是假定该字符串包含有效的 UTF-8 编码文本。如果该假设不成立，则不会抛出异常，结果未定义。

**语法**

```sql
lowerUTF8(input)
```

**参数**

* `input` — 要转换为小写的输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个小写字符串。[`String`](/sql-reference/data-types/string)

**示例**

**示例一**

```sql title=Query
SELECT lowerUTF8('München') as Lowerutf8;
```

```response title=Response
münchen
```

## normalizeUTF8NFC {#normalizeUTF8NFC}

引入于：v21.11

根据 [NFC 规范化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)对 UTF-8 字符串进行规范化处理。

**语法**

```sql
normalizeUTF8NFC(str)
```

**参数**

* `str` — 采用 UTF-8 编码的输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回 UTF-8 字符串的 NFC 归一化形式。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT
'é' AS original, -- e + combining acute accent (U+0065 + U+0301)
length(original),
normalizeUTF8NFC('é') AS nfc_normalized, -- é (U+00E9)
length(nfc_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfc_normalized─┬─length(nfc_normalized)─┐
│ é        │                2 │ é              │                      2 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```

## normalizeUTF8NFD {#normalizeUTF8NFD}

引入版本：v21.11

根据 [NFD 规范化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)将 UTF-8 字符串进行规范化。

**语法**

```sql
normalizeUTF8NFD(str)
```

**参数**

* `str` — 使用 UTF-8 编码的输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回该 UTF-8 字符串的 NFD 归一化形式。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT
    'é' AS original, -- é (U+00E9)
    length(original),
    normalizeUTF8NFD('é') AS nfd_normalized, -- e + combining acute (U+0065 + U+0301)
    length(nfd_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfd_normalized─┬─length(nfd_normalized)─┐
│ é        │                2 │ é              │                      3 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```

## normalizeUTF8NFKC {#normalizeUTF8NFKC}

引入版本：v21.11

按照 [NFKC 规范化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)对 UTF-8 字符串进行归一化处理。

**语法**

```sql
normalizeUTF8NFKC(str)
```

**参数**

* `str` — 以 UTF-8 编码的输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回该 UTF-8 字符串的 NFKC 规范化形式。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT
    '① ② ③' AS original,                            -- Circled number characters
    normalizeUTF8NFKC('① ② ③') AS nfkc_normalized;  -- Converts to 1 2 3
```

```response title=Response
┌─original─┬─nfkc_normalized─┐
│ ① ② ③  │ 1 2 3           │
└──────────┴─────────────────┘
```

## normalizeUTF8NFKD {#normalizeUTF8NFKD}

引入自：v21.11

根据 [NFKD 规范分解形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)对 UTF-8 字符串进行规范化。

**语法**

```sql
normalizeUTF8NFKD(str)
```

**参数**

* `str` — UTF-8 编码的输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回该 UTF-8 字符串的 NFKD 规范化形式。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT
    'H₂O²' AS original,                            -- H + subscript 2 + O + superscript 2
    normalizeUTF8NFKD('H₂O²') AS nfkd_normalized;  -- Converts to H 2 O 2
```

```response title=Response
┌─original─┬─nfkd_normalized─┐
│ H₂O²     │ H2O2            │
└──────────┴─────────────────┘
```

## punycodeDecode {#punycodeDecode}

自 v24.1 起引入

返回 [Punycode](https://en.wikipedia.org/wiki/Punycode) 编码字符串对应的 UTF-8 编码明文。
如果未提供有效的 Punycode 编码字符串，则会抛出异常。

**语法**

```sql
punycodeDecode(s)
```

**参数**

* `s` — 经 Punycode 编码的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回输入值对应的明文字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT punycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─punycodeDecode('Mnchen-3ya')─┐
│ München                      │
└──────────────────────────────┘
```

## punycodeEncode {#punycodeEncode}

引入版本：v24.1

返回字符串的 [Punycode](https://en.wikipedia.org/wiki/Punycode) 表示形式。
字符串必须为 UTF-8 编码，否则其行为未定义。

**语法**

```sql
punycodeEncode(s)
```

**参数**

* `s` — 输入值。[`String`](/sql-reference/data-types/string)

**返回值**

返回输入值的 Punycode 表示形式。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT punycodeEncode('München')
```

```response title=Response
┌─punycodeEncode('München')─┐
│ Mnchen-3ya                │
└───────────────────────────┘
```

## regexpExtract {#regexpExtract}

自 v23.2 起引入。

从 `haystack` 中提取与正则表达式匹配、并对应指定正则捕获组索引的第一个字符串。

**语法**

```sql
regexpExtract(haystack, pattern[, index])
```

**别名**: `REGEXP_EXTRACT`

**参数**

* `haystack` — 要在其中匹配正则表达式模式的字符串。[`String`](/sql-reference/data-types/string)
* `pattern` — 正则表达式字符串。`pattern` 可以包含多个正则捕获组，`index` 表示要提取的捕获组。索引为 0 表示匹配整个正则表达式。[`const String`](/sql-reference/data-types/string)
* `index` — 可选。大于或等于 0 的整数，默认值为 1。表示要提取的正则捕获组编号。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回匹配的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT
    regexpExtract('100-200', '(\\d+)-(\\d+)', 1),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 2),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 0),
    regexpExtract('100-200', '(\\d+)-(\\d+)');
```

```response title=Response
┌─regexpExtract('100-200', '(\\d+)-(\\d+)', 1)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 2)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 0)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)')─┐
│ 100                                          │ 200                                          │ 100-200                                      │ 100                                       │
└──────────────────────────────────────────────┴──────────────────────────────────────────────┴──────────────────────────────────────────────┴───────────────────────────────────────────┘
```

## repeat {#repeat}

引入于：v20.1

按指定次数将字符串与其自身连接。

**语法**

```sql
repeat(s, n)
```

**参数**

* `s` — 要重复的字符串。[`String`](/sql-reference/data-types/string)
* `n` — 字符串重复的次数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

一个由字符串 `s` 重复 `n` 次组成的字符串。如果 `n` 为负数，则函数返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT repeat('abc', 10)
```

```response title=Response
┌─repeat('abc', 10)──────────────┐
│ abcabcabcabcabcabcabcabcabcabc │
└────────────────────────────────┘
```

## reverseUTF8 {#reverseUTF8}

引入版本：v1.1

对字符串中的 Unicode 码点序列进行反转。
假设字符串包含有效的 UTF-8 编码文本。
如果该假设不成立，不会抛出异常，结果未定义。

**语法**

```sql
reverseUTF8(s)
```

**参数**

* `s` — 包含有效 UTF-8 编码文本的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个字符串，其 Unicode 码点序列被反转。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT reverseUTF8('ClickHouse')
```

```response title=Response
esuoHkcilC
```

## right {#right}

引入版本：v22.1

返回字符串 `s` 从右侧（末尾）开始、长度为 `offset` 的子串。

**语法**

```sql
right(s, offset)
```

**参数**

* `s` — 要从中截取子字符串的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — 偏移量的字节数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回：

* 对于正值的 `offset`，返回从字符串右侧开始、长度为 `offset` 字节的 `s` 的子字符串。
* 对于负值的 `offset`，返回从字符串右侧开始、长度为 `length(s) - |offset|` 字节的 `s` 的子字符串。
* 如果 `length` 为 `0`，则返回空字符串。
  [`String`](/sql-reference/data-types/string)

**示例**

**正偏移量**

```sql title=Query
SELECT right('Hello', 3)
```

```response title=Response
llo
```

**负偏移量**

```sql title=Query
SELECT right('Hello', -3)
```

```response title=Response
lo
```

## rightPad {#rightPad}

引入版本：v21.8

从右侧开始使用空格或指定字符串（必要时可重复多次）对字符串进行填充，直到结果字符串达到指定的 `length`。

**语法**

```sql
rightPad(string, length[, pad_string])
```

**别名**: `rpad`

**参数**

* `string` — 待填充的输入字符串。[`String`](/sql-reference/data-types/string)
* `length` — 结果字符串的长度。如果该值小于输入字符串的长度，则输入字符串会被截断为 `length` 个字符。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 可选。用于填充输入字符串的字符串。如果未指定，则使用空格填充输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回在右侧填充到指定长度的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT rightPad('abc', 7, '*'), rightPad('abc', 7)
```

```response title=Response
┌─rightPad('abc', 7, '*')─┬─rightPad('abc', 7)─┐
│ abc****                 │ abc                │
└─────────────────────────┴────────────────────┘
```

## rightPadUTF8 {#rightPadUTF8}

自 v21.8 引入

从右侧开始使用空格或指定字符串（必要时可重复多次）对字符串进行填充，直到结果字符串达到给定长度。
与按字节计算字符串长度的 [`rightPad`](#rightPad) 不同，此处的字符串长度按代码点（Unicode 码点）计算。

**语法**

```sql
rightPadUTF8(string, length[, pad_string])
```

**参数**

* `string` — 要填充的输入字符串。[`String`](/sql-reference/data-types/string)
* `length` — 结果字符串的长度。如果该值小于输入字符串的长度，则输入字符串会被截断为 `length` 个字符。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 可选。用于填充输入字符串的字符串。如果未指定，则使用空格对输入字符串进行填充。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个在右侧填充到指定长度的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT rightPadUTF8('абвг', 7, '*'), rightPadUTF8('абвг', 7)
```

```response title=Response
┌─rightPadUTF8('абвг', 7, '*')─┬─rightPadUTF8('абвг', 7)─┐
│ абвг***                      │ абвг                    │
└──────────────────────────────┴─────────────────────────┘
```

## rightUTF8 {#rightUTF8}

引入于：v22.1

返回对 UTF-8 编码字符串 `s` 从右侧按指定 `offset` 偏移后得到的子字符串。

**语法**

```sql
rightUTF8(s, offset)
```

**参数**

* `s` — 用于截取子字符串的 UTF-8 编码字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — 偏移量的字节数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回：

* 对于正的 `offset`，返回从字符串右侧开始，长度为 `offset` 字节的 `s` 的子字符串。
* 对于负的 `offset`，返回从字符串右侧开始，长度为 `length(s) - |offset|` 字节的 `s` 的子字符串。
* 当 `length` 为 `0` 时，返回空字符串。
  [`String`](/sql-reference/data-types/string)

**示例**

**正偏移量**

```sql title=Query
SELECT rightUTF8('Привет', 4)
```

```response title=Response
ивет
```

**负偏移量**

```sql title=Query
SELECT rightUTF8('Привет', -4)
```

```response title=Response
ет
```

## soundex {#soundex}

自 v23.4 起引入

返回字符串的 [Soundex 代码](https://en.wikipedia.org/wiki/Soundex)。

**语法**

```sql
soundex(s)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回输入字符串的 Soundex 编码。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT soundex('aksel')
```

```response title=Response
┌─soundex('aksel')─┐
│ A240             │
└──────────────────┘
```

## space {#space}

引入版本：v23.5

将空格字符（` `）按指定次数重复拼接。

**语法**

```sql
space(n)
```

**参数**

* `n` — 要重复空格的次数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个包含空格重复 `n` 次的字符串。如果 `n <= 0`，函数返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT space(3) AS res, length(res);
```

```response title=Response
┌─res─┬─length(res)─┐
│     │           3 │
└─────┴─────────────┘
```

## sparseGrams {#sparseGrams}

自 v25.5 引入

查找给定字符串中所有长度至少为 `n` 的子串，
这些子串需要满足：其边界上的 (n-1)-gram 的哈希值
都严格大于子串内部任意 (n-1)-gram 的哈希值。
使用 `CRC32` 作为哈希函数。

**语法**

```sql
sparseGrams(s[, min_ngram_length, max_ngram_length])
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 可选。提取的 n-gram 的最小长度。默认值也是允许的最小值，为 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 可选。提取的 n-gram 的最大长度。默认值为 100。该值不得小于 `min_ngram_length`。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回所选子串的数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT sparseGrams('alice', 3)
```

```response title=Response
┌─sparseGrams('alice', 3)────────────┐
│ ['ali','lic','lice','ice']         │
└────────────────────────────────────┘
```

## sparseGramsHashes {#sparseGramsHashes}

引入版本：v25.5

查找给定字符串中所有长度至少为 `n` 的子串的哈希值，
其中要求该子串边界处的 (n-1)-gram 的哈希值
严格大于子串内部任意 (n-1)-gram 的哈希值。
使用 `CRC32` 作为哈希函数。

**语法**

```sql
sparseGramsHashes(s[, min_ngram_length, max_ngram_length])
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 可选。提取的 ngram 的最小长度。默认值和最小值为 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 可选。提取的 ngram 的最大长度。默认值为 100。应不小于 `min_ngram_length`。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回所选子串的 CRC32 哈希数组。[`Array(UInt32)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT sparseGramsHashes('alice', 3)
```

```response title=Response
┌─sparseGramsHashes('alice', 3)──────────────────────┐
│ [1481062250,2450405249,4012725991,1918774096]      │
└────────────────────────────────────────────────────┘
```

## sparseGramsHashesUTF8 {#sparseGramsHashesUTF8}

引入版本：v25.5

查找给定 UTF-8 字符串中所有长度至少为 `n` 的子串的哈希值，这些子串需要满足：其边界处的 (n-1)-gram 的哈希值都严格大于该子串内部任意 (n-1)-gram 的哈希值。
该函数要求输入为 UTF-8 编码的字符串，如果遇到无效的 UTF-8 序列则抛出异常。
使用 `CRC32` 作为哈希函数。

**语法**

```sql
sparseGramsHashesUTF8(s[, min_ngram_length, max_ngram_length])
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 可选。提取的 ngram 的最小长度。默认值和最小允许值为 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 可选。提取的 ngram 的最大长度。默认值为 100。必须不小于 `min_ngram_length`。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回一个数组，其中包含所选 UTF-8 子串的 CRC32 哈希值。[`Array(UInt32)`](/sql-reference/data-types/array)

**示例**

**使用示例**

```sql title=Query
SELECT sparseGramsHashesUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsHashesUTF8('алиса', 3)─┐
│ [4178533925,3855635300,561830861] │
└───────────────────────────────────┘
```

## sparseGramsUTF8 {#sparseGramsUTF8}

引入于：v25.5

查找给定 UTF-8 字符串中所有长度至少为 `n` 的子字符串，这些子字符串在边界处的 (n-1)-gram 的哈希值严格大于子字符串内部任意 (n-1)-gram 的哈希值。
要求输入为 UTF-8 字符串，如遇到无效的 UTF-8 序列则抛出异常。
使用 `CRC32` 作为哈希函数。

**语法**

```sql
sparseGramsUTF8(s[, min_ngram_length, max_ngram_length])
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 可选。提取的 ngram 的最小长度。默认值和最小值为 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 可选。提取的 ngram 的最大长度。默认值为 100。不得小于 `min_ngram_length`。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

返回选取的 UTF-8 子串数组。[`Array(String)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT sparseGramsUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsUTF8('алиса', 3)─┐
│ ['али','лис','иса']         │
└─────────────────────────────┘
```

## startsWith {#startsWith}

自 v1.1 引入

判断字符串是否以给定的字符串开头。

**语法**

```sql
startsWith(s, prefix)
```

**参数**

* `s` — 要检查的字符串。[`String`](/sql-reference/data-types/string)
* `prefix` — 要检查的前缀。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `s` 以 `prefix` 开头，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT startsWith('ClickHouse', 'Click');
```

```response title=Response
┌─startsWith('⋯', 'Click')─┐
│                        1 │
└──────────────────────────┘
```

## startsWithCaseInsensitive {#startsWithCaseInsensitive}

引入于：v25.9

检查某个字符串是否以给定字符串（不区分大小写）开头。

**语法**

```sql
startsWithCaseInsensitive(s, prefix)
```

**参数**

* `s` — 要检查的字符串。[`String`](/sql-reference/data-types/string)
* `prefix` — 要检查的、不区分大小写的前缀。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `s` 以 `prefix`（不区分大小写）开头，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT startsWithCaseInsensitive('ClickHouse', 'CLICK');
```

```response title=Response
┌─startsWithCaseInsensitive('⋯', 'CLICK')─┐
│                                       1 │
└─────────────────────────────────────────┘
```

## startsWithCaseInsensitiveUTF8 {#startsWithCaseInsensitiveUTF8}

引入于：v25.9

检查字符串是否以给定的、大小写不敏感的前缀开始。
假定字符串包含有效的 UTF-8 编码文本。
如果该假设不成立，不会抛出异常，结果未定义。

**语法**

```sql
startsWithCaseInsensitiveUTF8(s, prefix)
```

**参数**

* `s` — 要检查的字符串。[`String`](/sql-reference/data-types/string)
* `prefix` — 要检查的前缀（不区分大小写）。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `s` 以不区分大小写的 `prefix` 开头，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT startsWithCaseInsensitiveUTF8('приставка', 'при')
```

```response title=Response
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```

## startsWithUTF8 {#startsWithUTF8}

引入于：v23.8

检查字符串是否以指定前缀开头。
假定字符串包含有效的 UTF-8 编码文本。
如果该假设不成立，不会抛出异常，且结果未定义。

**语法**

```sql
startsWithUTF8(s, prefix)
```

**参数**

* `s` — 要检查的字符串。[`String`](/sql-reference/data-types/string)
* `prefix` — 要检查的前缀。[`String`](/sql-reference/data-types/string)

**返回值**

如果 `s` 以 `prefix` 开头，则返回 `1`，否则返回 `0`。[`UInt8`](/sql-reference/data-types/int-uint)

**示例**

**使用示例**

```sql title=Query
SELECT startsWithUTF8('приставка', 'при')
```

```response title=Response
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```

## stringBytesEntropy {#stringBytesEntropy}

引入版本：v25.6

计算字符串中字节分布的香农熵。

**语法**

```sql
stringBytesEntropy(s)
```

**参数**

* `s` — 要分析的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回字符串中字节分布的香农熵。[`Float64`](/sql-reference/data-types/float)

**示例**

**使用示例**

```sql title=Query
SELECT stringBytesEntropy('Hello, world!')
```

```response title=Response
┌─stringBytesEntropy('Hello, world!')─┐
│                         3.07049960  │
└─────────────────────────────────────┘
```

## stringBytesUniq {#stringBytesUniq}

引入版本：v25.6

统计字符串中不同字节的个数。

**语法**

```sql
stringBytesUniq(s)
```

**参数**

* `s` — 要分析的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回字符串中不同字节的数量。[`UInt16`](/sql-reference/data-types/int-uint)

**示例**

**用法示例**

```sql title=Query
SELECT stringBytesUniq('Hello')
```

```response title=Response
┌─stringBytesUniq('Hello')─┐
│                        4 │
└──────────────────────────┘
```

## stringJaccardIndex {#stringJaccardIndex}

引入版本：v23.11

计算两个字节字符串之间的 [Jaccard 相似系数](https://en.wikipedia.org/wiki/Jaccard_index)。

**语法**

```sql
stringJaccardIndex(s1, s2)
```

**参数**

* `s1` — 第一个输入字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 第二个输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回两个字符串之间的 Jaccard 相似系数。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT stringJaccardIndex('clickhouse', 'mouse')
```

```response title=Response
┌─stringJaccardIndex('clickhouse', 'mouse')─┐
│                                       0.4 │
└───────────────────────────────────────────┘
```

## stringJaccardIndexUTF8 {#stringJaccardIndexUTF8}

引入于：v23.11

与 [`stringJaccardIndex`](#stringJaccardIndex) 类似，但适用于 UTF-8 编码的字符串。

**语法**

```sql
stringJaccardIndexUTF8(s1, s2)
```

**参数**

* `s1` — 第一个 UTF8 输入字符串。[`String`](/sql-reference/data-types/string)
* `s2` — 第二个 UTF8 输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回两个 UTF8 字符串之间的杰卡德相似系数。[`Float64`](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT stringJaccardIndexUTF8('我爱你', '我也爱你')
```

```response title=Response
┌─stringJaccardIndexUTF8('我爱你', '我也爱你')─┐
│                                       0.75 │
└─────────────────────────────────────────────┘
```

## substring {#substring}

引入版本：v1.1

返回字符串 `s` 从指定字节索引 `offset` 开始的子串。
字节计数从 1 开始，遵循以下规则：

* 如果 `offset` 为 `0`，则返回空字符串。
* 如果 `offset` 为负数，则子串从字符串末尾起第 `pos` 个字符处开始，而不是从开头开始。

可选参数 `length` 指定返回子串的最大字节数上限。

**语法**

```sql
substring(s, offset[, length])
```

**别名**: `byteSlice`, `mid`, `substr`

**参数**

* `s` — 要从中截取子字符串的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring) 或 [`Enum`](/sql-reference/data-types/enum)
* `offset` — 子字符串在 `s` 中的起始位置。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 可选。子字符串的最大长度。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

返回从索引 `offset` 开始、长度为 `length` 字节的 `s` 的子字符串。[`String`](/sql-reference/data-types/string)

**示例**

**基本用法**

```sql title=Query
SELECT 'database' AS db, substr(db, 5), substr(db, 5, 1)
```

```response title=Response
┌─db───────┬─substring('database', 5)─┬─substring('database', 5, 1)─┐
│ database │ base                     │ b                           │
└──────────┴──────────────────────────┴─────────────────────────────┘
```

## substringIndex {#substringIndex}

首次引入于：v23.7

返回字符串 `s` 中在分隔符 `delim` 第 `count` 次出现之前的子字符串，其行为与 Spark 或 MySQL 中的同名函数相同。

**语法**

```sql
substringIndex(s, delim, count)
```

**别名**: `SUBSTRING_INDEX`

**参数**

* `s` — 要从中提取子字符串的字符串。[`String`](/sql-reference/data-types/string)
* `delim` — 用于分割的分隔符字符。[`String`](/sql-reference/data-types/string)
* `count` — 在提取子字符串之前需要统计的分隔符出现次数。如果 `count` 为正，则返回从左向右计数时最后一个（即第 `count` 个）分隔符左侧的所有内容。如果 `count` 为负，则返回从右向左计数时最后一个（即第 `|count|` 个）分隔符右侧的所有内容。[`UInt`](/sql-reference/data-types/int-uint) 或 [`Int`](/sql-reference/data-types/int-uint)

**返回值**

返回 `s` 中在第 `count` 次出现的 `delim` 之前的子字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT substringIndex('www.clickhouse.com', '.', 2)
```

```response title=Response
┌─substringIndex('www.clickhouse.com', '.', 2)─┐
│ www.clickhouse                               │
└──────────────────────────────────────────────┘
```

## substringIndexUTF8 {#substringIndexUTF8}

引入版本：v23.7

返回字符串 `s` 中，在分隔符 `delim` 第 `count` 次出现之前的子字符串，按 Unicode 码点进行处理。
假定字符串包含有效的 UTF-8 编码文本。
如果该假设不成立，则不会抛出异常，结果未定义。

**语法**

```sql
substringIndexUTF8(s, delim, count)
```

**参数**

* `s` — 要从中提取子字符串的字符串。[`String`](/sql-reference/data-types/string)
* `delim` — 用于分割的分隔字符。[`String`](/sql-reference/data-types/string)
* `count` — 在提取子字符串之前要统计的分隔符出现次数。如果 `count` 为正数，则返回从左侧计数时最后一个分隔符左侧的所有内容。如果 `count` 为负数，则返回从右侧计数时最后一个分隔符右侧的所有内容。[`UInt`](/sql-reference/data-types/int-uint) 或 [`Int`](/sql-reference/data-types/int-uint)

**返回值**

返回 `s` 中在出现 `count` 次 `delim` 之前的子字符串。[`String`](/sql-reference/data-types/string)

**示例**

**UTF8 示例**

```sql title=Query
SELECT substringIndexUTF8('www.straßen-in-europa.de', '.', 2)
```

```response title=Response
www.straßen-in-europa
```

## substringUTF8 {#substringUTF8}

引入版本：v1.1

返回字符串 `s` 的子字符串，其起始位置为按 Unicode 码点计算的字节索引 `offset`。
字节计数从 `1` 开始，并遵循以下逻辑：

* 如果 `offset` 为 `0`，则返回空字符串。
* 如果 `offset` 为负数，则子字符串从字符串末尾向前数第 `pos` 个字符处开始，而不是从开头开始。

可选参数 `length` 指定返回的子字符串最多可以包含的字节数。

:::note
此函数假定字符串包含有效的 UTF-8 编码文本。
如果不满足该假设，则不会抛出异常，且结果未定义。
:::

**语法**

```sql
substringUTF8(s, offset[, length])
```

**参数**

* `s` — 要从中截取子字符串的字符串。[`String`](/sql-reference/data-types/string) 或 [`FixedString`](/sql-reference/data-types/fixedstring) 或 [`Enum`](/sql-reference/data-types/enum)
* `offset` — 子字符串在 `s` 中的起始位置。[`Int`](/sql-reference/data-types/int-uint) 或 [`UInt`](/sql-reference/data-types/int-uint)
* `length` — 子字符串的最大长度，可选。[`Int`](/sql-reference/data-types/int-uint) 或 [`UInt`](/sql-reference/data-types/int-uint)

**返回值**

返回从索引 `offset` 开始、长度为 `length` 字节的 `s` 的子字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT 'Täglich grüßt das Murmeltier.' AS str, substringUTF8(str, 9), substringUTF8(str, 9, 5)
```

```response title=Response
Täglich grüßt das Murmeltier.    grüßt das Murmeltier.    grüßt
```

## toValidUTF8 {#toValidUTF8}

自 v20.1 起引入

通过将所有无效的 UTF-8 字符替换为替换字符 `�`（U+FFFD），将字符串转换为有效的 UTF-8 编码。
当发现多个连续的无效字符时，它们会被合并为单个替换字符。

**语法**

```sql
toValidUTF8(s)
```

**参数**

* `s` — 以 String 数据类型对象表示的任意字节序列。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个有效的 UTF-8 字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT toValidUTF8('\\x61\\xF0\\x80\\x80\\x80b')
```

```response title=Response
c
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```

## trimBoth {#trimBoth}

引入版本：v20.1

从字符串的开头和结尾移除指定字符。
默认会移除常见的空白 ASCII 字符。

**语法**

```sql
trimBoth(s[, trim_characters])
```

**别名**: `trim`

**参数**

* `s` — 要处理的字符串。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 可选。要去除的字符。如果未指定，则会移除常见的空白字符。[`String`](/sql-reference/data-types/string)

**返回值**

返回在两端去除了指定字符的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT trimBoth('$$ClickHouse$$', '$')
```

```response title=Response
┌─trimBoth('$$⋯se$$', '$')─┐
│ ClickHouse               │
└──────────────────────────┘
```

## trimLeft {#trimLeft}

自 v20.1 引入

从字符串的开头移除指定字符。
默认情况下，会移除常见的空白（ASCII）字符。

**语法**

```sql
trimLeft(input[, trim_characters])
```

**别名**: `ltrim`

**参数**

* `input` — 要去除字符的字符串。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 可选。要去除的字符。如果未指定，则会移除常见的空白字符。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个从左侧去除了指定字符的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT trimLeft('ClickHouse', 'Click');
```

```response title=Response
┌─trimLeft('Cl⋯', 'Click')─┐
│ House                    │
└──────────────────────────┘
```

## trimRight {#trimRight}

自 v20.1 起引入

从字符串末尾移除指定字符。
默认情况下，移除常见的空白（ASCII）字符。

**语法**

```sql
trimRight(s[, trim_characters])
```

**别名**: `rtrim`

**参数**

* `s` — 要进行修剪的字符串。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 可选，要从字符串中删除的字符。如果未指定，则会移除常见的空白字符。[`String`](/sql-reference/data-types/string)

**返回值**

返回从右侧删除了指定字符后的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT trimRight('ClickHouse','House');
```

```response title=Response
┌─trimRight('C⋯', 'House')─┐
│ Click                    │
└──────────────────────────┘
```

## tryBase32Decode {#tryBase32Decode}

引入版本：v25.6

接受一个字符串，并按照 [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) 编码方案对其进行解码。

**语法**

```sql
tryBase32Decode(encoded)
```

**参数**

* `encoded` — 要解码的字符串列或常量。如果字符串不是有效的 Base32 编码，出错时将返回空字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含参数解码后值的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT tryBase32Decode('IVXGG33EMVSA====');
```

```response title=Response
┌─tryBase32Decode('IVXGG33EMVSA====')─┐
│ Encoded                             │
└─────────────────────────────────────┘
```

## tryBase58Decode {#tryBase58Decode}

引入于：v22.10

与 [`base58Decode`](#base58Decode) 类似，但在发生错误时返回空字符串。

**语法**

```sql
tryBase58Decode(encoded)
```

**参数**

* `encoded` — 字符串列或常量。如果字符串不是有效的 Base58 编码，出错时返回空字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含参数解码结果的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT tryBase58Decode('3dc8KtHrwM') AS res, tryBase58Decode('invalid') AS res_invalid;
```

```response title=Response
┌─res─────┬─res_invalid─┐
│ Encoded │             │
└─────────┴─────────────┘
```

## tryBase64Decode {#tryBase64Decode}

引入版本：v18.16

与 [`base64Decode`](#base64Decode) 类似，但在出错时返回空字符串。

**语法**

```sql
tryBase64Decode(encoded)
```

**参数**

* `encoded` — 要解码的字符串列或常量。如果该字符串不是有效的 Base64 编码，发生错误时会返回空字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个包含该参数解码后值的字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT tryBase64Decode('Y2xpY2tob3VzZQ==')
```

```response title=Response
┌─tryBase64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                          │
└─────────────────────────────────────┘
```

## tryBase64URLDecode {#tryBase64URLDecode}

自 v18.16 版本引入

类似于 [`base64URLDecode`](#base64URLDecode)，但在出错时返回空字符串。

**语法**

```sql
tryBase64URLDecode(encoded)
```

**参数**

* `encoded` — 要解码的字符串列或常量。如果字符串不是有效的 Base64 编码格式，出错时返回空字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个字符串，内容为参数解码后的值。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                               │
└──────────────────────────────────────────────────────┘
```

## tryIdnaEncode {#tryIdnaEncode}

自 v24.1 引入

按照 [Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications)（IDNA）机制，返回域名的 Unicode（UTF-8）表示（使用 ToUnicode 算法）。
在出错时不会抛出异常，而是返回空字符串。

**语法**

```sql
tryIdnaEncode(s)
```

**参数**

* `s` — 输入字符串。[`String`](/sql-reference/data-types/string)

**返回值**

根据 IDNA 机制返回输入字符串的 ASCII 表示形式；如果输入无效，则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT tryIdnaEncode('straße.münchen.de')
```

```response title=Response
┌─tryIdnaEncode('straße.münchen.de')──┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```

## tryPunycodeDecode {#tryPunycodeDecode}

自 v24.1 起引入。

与 `punycodeDecode` 类似，但在未给出有效的 Punycode 编码字符串时返回空字符串。

**语法**

```sql
tryPunycodeDecode(s)
```

**参数**

* `s` — 经过 Punycode 编码的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回输入值对应的原始文本；如果输入无效，则返回空字符串。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT tryPunycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─tryPunycodeDecode('Mnchen-3ya')─┐
│ München                         │
└─────────────────────────────────┘
```

## upper {#upper}

引入于：v1.1

将字符串中的 ASCII 拉丁字符转换为大写形式。

**语法**

```sql
upper(s)
```

**别名**: `ucase`

**参数**

* `s` — 要转换为大写的字符串。[`String`](/sql-reference/data-types/string)

**返回值**

返回 `s` 的大写形式。[`String`](/sql-reference/data-types/string)

**示例**

**使用示例**

```sql title=Query
SELECT upper('clickhouse')
```

```response title=Response
┌─upper('clickhouse')─┐
│ CLICKHOUSE          │
└─────────────────────┘
```

## upperUTF8 {#upperUTF8}

引入版本：v1.1

在假定字符串包含有效 UTF-8 编码文本的前提下，将字符串转换为大写。
如果这一假设不成立，不会抛出异常，结果是未定义的。

:::note
此函数不会自动检测语言，例如对于土耳其语，结果可能不完全正确（i/İ 与 i/I）。
如果某个码点的大写和小写形式的 UTF-8 字节序列长度不同（例如 `ẞ` 和 `ß`），则该码点的结果可能不正确。
:::

**语法**

```sql
upperUTF8(s)
```

**参数**

* `s` — 字符串类型。[`String`](/sql-reference/data-types/string)

**返回值**

返回一个 `String` 类型的值。[`String`](/sql-reference/data-types/string)

**示例**

**用法示例**

```sql title=Query
SELECT upperUTF8('München') AS Upperutf8
```

```response title=Response
┌─Upperutf8─┐
│ MÜNCHEN   │
└───────────┘
```

{/*AUTOGENERATED_END*/ }

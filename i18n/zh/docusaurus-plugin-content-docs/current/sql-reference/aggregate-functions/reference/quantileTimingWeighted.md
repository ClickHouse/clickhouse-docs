---
description: '以给定精度，根据每个序列成员的权重计算数值序列的分位数。'
slug: /sql-reference/aggregate-functions/reference/quantiletimingweighted
title: 'quantileTimingWeighted'
doc_type: 'reference'
---

{/*AUTOGENERATED_START*/ }

## quantileTimingWeighted \{#quantileTimingWeighted\}

引入于：v1.1

在给定精度下，根据序列中每个元素的权重计算数值数据序列的[分位数](https://en.wikipedia.org/wiki/Quantile)。

结果是确定性的（不依赖于查询的执行顺序）。该函数针对描述分布的序列（例如网页加载时间或后端响应时间）进行了优化。

在同一个查询中使用多个具有不同 level 的 `quantile*` 函数时，其内部状态不会被合并（也就是说，该查询的效率低于理论上可以达到的效率）。在这种情况下，请使用 [`quantiles`](/sql-reference/aggregate-functions/reference/quantiles#quantiles) 函数。

**精度**

在以下情况下，计算结果是精确的：

* 值的总数不超过 5670。
* 值的总数超过 5670，但页面加载时间小于 1024 ms。

否则，计算结果会四舍五入到最接近的 16 ms 的倍数。

:::note
对于页面加载时间分位数的计算，此函数比 [`quantile`](/sql-reference/aggregate-functions/reference/quantile) 更高效且更精确。
:::

:::note
如果没有向函数传入任何值（在使用 `quantileTimingIf` 时），则返回 [NaN](/sql-reference/data-types/float#nan-and-inf)。这样做的目的是将这些情况与结果为零的情况区分开来。关于 `NaN` 值排序的说明，参见 [ORDER BY 子句](/sql-reference/statements/select/order-by)。
:::

**语法**

```sql
quantileTimingWeighted(level)(expr, weight)
```

**别名**: `medianTimingWeighted`

**参数**

* `level` — 可选。分位数水平。0 到 1 之间的常量浮点数。建议使用 `[0.01, 0.99]` 范围内的 `level` 值。默认值：0.5。在 `level=0.5` 时，函数计算中位数。[`Float*`](/sql-reference/data-types/float)

**参数说明**

* `expr` — 对列值进行计算的表达式，返回 Float* 类型的数字。如果向函数传入负值，其行为未定义。如果值大于 30,000（页面加载时间超过 30 秒），则将其视为 30,000。[`Float*`](/sql-reference/data-types/float)
* `weight` — 包含序列元素权重的列。权重表示该值出现的次数。[`UInt*`](/sql-reference/data-types/int-uint)

**返回值**

指定水平的分位数。[`Float32`](/sql-reference/data-types/float)

**示例**

**计算加权时间分位数**

```sql title=Query
CREATE TABLE t (response_time UInt32, weight UInt32) ENGINE = Memory;
INSERT INTO t VALUES (68, 1), (104, 2), (112, 3), (126, 2), (138, 1), (162, 1);

SELECT quantileTimingWeighted(response_time, weight) FROM t;
```

```response title=Response
┌─quantileTimingWeighted(response_time, weight)─┐
│                                           112 │
└───────────────────────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

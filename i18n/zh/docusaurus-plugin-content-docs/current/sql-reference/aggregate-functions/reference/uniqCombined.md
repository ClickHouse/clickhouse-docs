---
description: '计算不同参数取值的近似数量。'
slug: /sql-reference/aggregate-functions/reference/uniqcombined
title: 'uniqCombined'
doc_type: 'reference'
---

# uniqCombined \{#uniqcombined\}

近似计算不同参数值的数量。

```sql
uniqCombined(HLL_precision)(x[, ...])
```

`uniqCombined` 函数是在计算不同值数量时的一个较好选择。

**参数**

* `HLL_precision`： [HyperLogLog](https://en.wikipedia.org/wiki/HyperLogLog) 中单元格数量的以 2 为底的对数。可选参数，也可以以 `uniqCombined(x[, ...])` 的形式使用该函数。`HLL_precision` 的默认值为 17，这在实际中大约占用 96 KiB 空间（2^17 个单元格，每个 6 位）。
* `X`：可变数量的参数。参数可以是 `Tuple`、`Array`、`Date`、`DateTime`、`String` 或数值类型。

**返回值**

* 一个 [UInt64](../../../sql-reference/data-types/int-uint.md) 类型的数字。

**实现细节**

`uniqCombined` 函数：

* 对聚合中的所有参数计算哈希（`String` 使用 64 位哈希，其它类型使用 32 位哈希），然后在计算中使用该哈希值。
* 组合使用三种算法：数组、哈希表，以及带误差修正表的 HyperLogLog。
  * 对于较少数量的不同元素，使用数组。
  * 当集合规模更大时，使用哈希表。
  * 对于更多元素时，使用 HyperLogLog，它将占用固定大小的内存。
* 以确定性的方式提供结果（结果不依赖于查询处理顺序）。

:::note
由于对非 `String` 类型使用 32 位哈希，当基数（cardinality）明显大于 `UINT_MAX` 时，结果误差会非常大（在数百亿级别以上不同值时误差会迅速增大），因此在这种情况下你应当使用 [uniqCombined64](/sql-reference/aggregate-functions/reference/uniqcombined64)。
:::

与 [uniq](/sql-reference/aggregate-functions/reference/uniq) 函数相比，`uniqCombined` 函数：

* 内存消耗减少数倍。
* 计算精度提高数倍。
* 通常性能略低。在某些场景中，`uniqCombined` 的表现可能优于 `uniq`，例如在通过网络传输大量聚合状态的分布式查询中。

**示例**

查询：

```sql
SELECT uniqCombined(number) FROM numbers(1e6);
```

结果：

```response
┌─uniqCombined(number)─┐
│              1001148 │ -- 1.00 million
└──────────────────────┘
```

请参阅 [uniqCombined64](/sql-reference/aggregate-functions/reference/uniqcombined64) 的示例部分，以了解在输入规模大得多时 `uniqCombined` 和 `uniqCombined64` 之间的差异。

**另请参阅**

* [uniq](/sql-reference/aggregate-functions/reference/uniq)
* [uniqCombined64](/sql-reference/aggregate-functions/reference/uniqcombined64)
* [uniqHLL12](/sql-reference/aggregate-functions/reference/uniqhll12)
* [uniqExact](/sql-reference/aggregate-functions/reference/uniqexact)
* [uniqTheta](/sql-reference/aggregate-functions/reference/uniqthetasketch)

{/*AUTOGENERATED_START*/ }

{/*AUTOGENERATED_END*/ }

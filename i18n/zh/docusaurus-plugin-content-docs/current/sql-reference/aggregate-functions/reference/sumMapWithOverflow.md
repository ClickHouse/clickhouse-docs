---
description: '根据 `key` 数组中指定的键，对 `value` 数组进行求和。返回一个包含两个数组的元组：按排序顺序排列的键，以及对应键的求和值。与 sumMap 函数的不同之处在于，它执行的是允许溢出的求和。'
slug: /sql-reference/aggregate-functions/reference/summapwithoverflow
title: 'sumMapWithOverflow'
doc_type: 'reference'
---

{/*AUTOGENERATED_START*/ }

## sumMapWithOverflow \{#sumMapWithOverflow\}

引入版本：v20.1

根据 `key` 数组中指定的键，对 `value` 数组进行汇总求和。返回一个由两个数组组成的 tuple：按排序顺序排列的键数组，以及对应键的求和值数组。
它与 [`sumMap`](/sql-reference/aggregate-functions/reference/summap) 函数的不同之处在于，它执行的是带溢出的求和——即求和结果的数据类型与参数的数据类型相同。

:::note

* 传入一个由 key 和 value 数组构成的 tuple，与分别传入一个 key 数组和一个 value 数组是等价的。
* 对于每一行，`key` 和 `value` 中的元素数量必须相同。
  :::

**语法**

```sql
sumMapWithOverflow(key, value)
sumMapWithOverflow(Tuple(key, value))
```

**参数**

* `key` — 键的数组。[`Array`](/sql-reference/data-types/array)
* `value` — 值的数组。[`Array`](/sql-reference/data-types/array)

**返回值**

返回包含两个数组的元组：按排序后顺序排列的键，以及对应键的值之和。[`Tuple(Array, Array)`](/sql-reference/data-types/tuple)

**示例**

**演示溢出行为的数组语法**

```sql title=Query
CREATE TABLE sum_map(
    date Date,
    timeslot DateTime,
    statusMap Nested(
        status UInt8,
        requests UInt8
    ),
    statusMapTuple Tuple(Array(Int8), Array(Int8))
) ENGINE = Memory;

INSERT INTO sum_map VALUES
    ('2000-01-01', '2000-01-01 00:00:00', [1, 2, 3], [10, 10, 10], ([1, 2, 3], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:00:00', [3, 4, 5], [10, 10, 10], ([3, 4, 5], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', [4, 5, 6], [10, 10, 10], ([4, 5, 6], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', [6, 7, 8], [10, 10, 10], ([6, 7, 8], [10, 10, 10]));

SELECT
    timeslot,
    toTypeName(sumMap(statusMap.status, statusMap.requests)),
    toTypeName(sumMapWithOverflow(statusMap.status, statusMap.requests))
FROM sum_map
GROUP BY timeslot;
```

```response title=Response
┌────────────timeslot─┬─toTypeName(sumMap⋯usMap.requests))─┬─toTypeName(sumMa⋯usMap.requests))─┐
│ 2000-01-01 00:01:00 │ Tuple(Array(UInt8), Array(UInt64)) │ Tuple(Array(UInt8), Array(UInt8)) │
│ 2000-01-01 00:00:00 │ Tuple(Array(UInt8), Array(UInt64)) │ Tuple(Array(UInt8), Array(UInt8)) │
└─────────────────────┴────────────────────────────────────┴───────────────────────────────────┘
```

**等价的元组语法**

```sql title=Query
SELECT
    timeslot,
    toTypeName(sumMap(statusMapTuple)),
    toTypeName(sumMapWithOverflow(statusMapTuple))
FROM sum_map
GROUP BY timeslot;
```

```response title=Response
┌────────────timeslot─┬─toTypeName(sumMap(statusMapTuple))─┬─toTypeName(sumM⋯tatusMapTuple))─┐
│ 2000-01-01 00:01:00 │ Tuple(Array(Int8), Array(Int64))   │ Tuple(Array(Int8), Array(Int8)) │
│ 2000-01-01 00:00:00 │ Tuple(Array(Int8), Array(Int64))   │ Tuple(Array(Int8), Array(Int8)) │
└─────────────────────┴────────────────────────────────────┴─────────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

**另请参阅**

* [sumMap](../reference/sumMappedArrays.md)

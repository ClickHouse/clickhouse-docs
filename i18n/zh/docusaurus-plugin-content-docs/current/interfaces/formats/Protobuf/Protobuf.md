---
'alias': []
'description': 'Protobuf 格式的文档'
'input_format': true
'keywords':
- 'Protobuf'
'output_format': true
'slug': '/interfaces/formats/Protobuf'
'title': 'Protobuf'
---

import CloudNotSupportedBadge from '@theme/badges/CloudNotSupportedBadge';

<CloudNotSupportedBadge/>

| 输入  | 输出  | 别名 |
|-------|--------|-------|
| ✔     | ✔      |       |

## 描述 {#description}

`Protobuf` 格式是 [Protocol Buffers](https://protobuf.dev/) 格式。

该格式需要一个外部格式架构，且在查询之间进行缓存。

ClickHouse 支持：
- `proto2` 和 `proto3` 语法。
- `Repeated` / `optional` / `required` 字段。

## 示例用法 {#example-usage}

### 基本示例 {#basic-examples}

用法示例：

```sql
SELECT * FROM test.table FORMAT Protobuf SETTINGS format_schema = 'schemafile:MessageType'
```

```bash
cat protobuf_messages.bin | clickhouse-client --query "INSERT INTO test.table SETTINGS format_schema='schemafile:MessageType' FORMAT Protobuf"
```

其中文件 `schemafile.proto` 看起来如下：

```capnp
syntax = "proto3";

message MessageType {
  string name = 1;
  string surname = 2;
  uint32 birthDate = 3;
  repeated string phoneNumbers = 4;
};
```

要查找表列与 Protocol Buffers 消息类型字段之间的对应关系，ClickHouse 会比较它们的名称。
此比较是不区分大小写的，并且字符 `_`（下划线）和 `.`（点）被视为相等。
如果列的类型与 Protocol Buffers 消息的字段类型不同，则将应用必要的转换。

支持嵌套消息。例如，对于以下消息类型中的字段 `z`：

```capnp
message MessageType {
  message XType {
    message YType {
      int32 z;
    };
    repeated YType y;
  };
  XType x;
};
```

ClickHouse 会尝试查找名为 `x.y.z`（或 `x_y_z` 或 `X.y_Z` 等）的列。

嵌套消息适用于 [嵌套数据结构](/sql-reference/data-types/nested-data-structures/index.md) 的输入或输出。

在如以下所示的 protobuf 架构中定义的默认值不会被应用，而是使用 [表的默认值](/sql-reference/statements/create/table#default_values) 代替：

```capnp
syntax = "proto2";

message MessageType {
  optional int32 result_per_page = 3 [default = 10];
}
```

ClickHouse 以 `length-delimited` 格式输入和输出 protobuf 消息。
这意味着在每个消息之前需要先写入其长度，格式为 [可变宽度整数 (varint)](https://developers.google.com/protocol-buffers/docs/encoding#varints)。

另请参见：[如何在流行语言中读写长度限制的 protobuf 消息](https://cwiki.apache.org/confluence/display/GEODE/Delimiting+Protobuf+Messages)。

### 使用自动生成的架构 {#using-autogenerated-protobuf-schema}

如果您没有数据的外部 Protobuf 架构，您仍然可以使用自动生成的架构在 Protobuf 格式中输入/输出数据。

例如：

```sql
SELECT * FROM test.hits format Protobuf SETTINGS format_protobuf_use_autogenerated_schema=1
```

在这种情况下，ClickHouse 将根据表结构使用函数 [`structureToProtobufSchema`](/sql-reference/functions/other-functions.md#structure_to_protobuf_schema) 自动生成 Protobuf 架构。
它将使用该架构序列化 Protobuf 格式的数据。

您还可以读取具有自动生成架构的 Protobuf 文件。在这种情况下，文件必须使用相同的架构创建：

```bash
$ cat hits.bin | clickhouse-client --query "INSERT INTO test.hits SETTINGS format_protobuf_use_autogenerated_schema=1 FORMAT Protobuf"
```

设置 [`format_protobuf_use_autogenerated_schema`](/operations/settings/settings-formats.md#format_protobuf_use_autogenerated_schema) 默认为启用，并在未设置 [`format_schema`](/operations/settings/formats#format_schema) 时适用。

您还可以在输入/输出过程中使用设置 [`output_format_schema`](/operations/settings/formats#output_format_schema) 将自动生成的架构保存到文件中。例如：

```sql
SELECT * FROM test.hits format Protobuf SETTINGS format_protobuf_use_autogenerated_schema=1, output_format_schema='path/to/schema/schema.proto'
```
在这种情况下，自动生成的 Protobuf 架构将保存到文件 `path/to/schema/schema.capnp` 中。

### 删除 Protobuf 缓存 {#drop-protobuf-cache}

要重新加载从 [`format_schema_path`](/operations/server-configuration-parameters/settings.md/#format_schema_path) 加载的 Protobuf 架构，请使用 [`SYSTEM DROP ... FORMAT CACHE`](/sql-reference/statements/system.md/#system-drop-schema-format) 语句。

```sql
SYSTEM DROP FORMAT SCHEMA CACHE FOR Protobuf
```

## 格式设置 {#format-settings}

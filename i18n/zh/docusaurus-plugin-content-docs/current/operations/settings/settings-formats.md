---
'title': '格式设置'
'sidebar_label': '格式设置'
'slug': '/operations/settings/formats'
'toc_max_heading_level': 2
'description': '控制输入和输出格式的设置。'
'doc_type': 'reference'
---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import BetaBadge from '@theme/badges/BetaBadge';
import SettingsInfoBlock from '@theme/SettingsInfoBlock/SettingsInfoBlock';
import VersionHistory from '@theme/VersionHistory/VersionHistory';

<!-- Autogenerated -->
这些设置是从 [source](https://github.com/ClickHouse/ClickHouse/blob/master/src/Core/FormatFactorySettings.h) 自动生成的。
## allow_special_bool_values_inside_variant {#allow_special_bool_values_inside_variant}   

<SettingsInfoBlock type="Bool" default_value="0" />

允许从特殊文本布尔值（如“on”、“off”、“enable”、“disable”等）中解析Variant类型内的布尔值。
## bool_false_representation {#bool_false_representation}   

<SettingsInfoBlock type="String" default_value="false" />

在TSV/CSV/垂直/漂亮格式中表示假布尔值的文本。
## bool_true_representation {#bool_true_representation}   

<SettingsInfoBlock type="String" default_value="true" />

在TSV/CSV/垂直/漂亮格式中表示真布尔值的文本。
## column_names_for_schema_inference {#column_names_for_schema_inference}   

用于在没有列名的格式中进行模式推断的列名列表。格式：'column1,column2,column3,...'
## cross_to_inner_join_rewrite {#cross_to_inner_join_rewrite}   

<SettingsInfoBlock type="UInt64" default_value="1" />

如果在WHERE部分存在连接表达式，则使用内连接而不是逗号/交叉连接。值：0 - 不重写，1 - 如果可能则应用于逗号/交叉，2 - 强制重写所有逗号连接，cross - 如果可能
## date_time_64_output_format_cut_trailing_zeros_align_to_groups_of_thousands {#date_time_64_output_format_cut_trailing_zeros_align_to_groups_of_thousands}   

<SettingsInfoBlock type="Bool" default_value="0" />

动态修剪datetime64值的尾随零，以将输出规模调整为 [0, 3, 6]，
对应"秒"、"毫秒"和"微秒"
## date_time_input_format {#date_time_input_format}   

<SettingsInfoBlock type="DateTimeInputFormat" default_value="basic" />

允许选择日期和时间文本表示的解析器。

该设置不适用于 [日期和时间函数](../../sql-reference/functions/date-time-functions.md)。

可能的值：

- `'best_effort'` — 启用扩展解析。

    ClickHouse可以解析基本的 `YYYY-MM-DD HH:MM:SS` 格式和所有 [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) 日期和时间格式。例如，`'2018-06-08T01:02:03.000Z'`。

- `'best_effort_us'` — 类似于 `best_effort` (关于 [parseDateTimeBestEffortUS](../../sql-reference/functions/type-conversion-functions#parsedatetimebesteffortus) 的区别)

- `'basic'` — 使用基本解析器。

    ClickHouse只能够解析基本的 `YYYY-MM-DD HH:MM:SS` 或 `YYYY-MM-DD` 格式。例如，`2019-08-20 10:18:56` 或 `2019-08-20`。

云的默认值：`'best_effort'`。

另见：

- [日期时间数据类型。](../../sql-reference/data-types/datetime.md)
- [处理日期和时间的函数。](../../sql-reference/functions/date-time-functions.md)
## date_time_output_format {#date_time_output_format}   

<SettingsInfoBlock type="DateTimeOutputFormat" default_value="simple" />

允许选择日期和时间文本表示的不同输出格式。

可能的值：

- `simple` - 简单输出格式。

    ClickHouse输出日期和时间为 `YYYY-MM-DD hh:mm:ss` 格式。例如，`2019-08-20 10:18:56`。计算是根据数据类型的时区（如果存在）或服务器时区进行的。

- `iso` - ISO输出格式。

    ClickHouse以 [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) `YYYY-MM-DDThh:mm:ssZ` 格式输出日期和时间。例如，`2019-08-20T10:18:56Z`。请注意，输出为UTC（`Z`表示UTC）。

- `unix_timestamp` - Unix时间戳输出格式。

    ClickHouse以 [Unix时间戳](https://en.wikipedia.org/wiki/Unix_time) 格式输出日期和时间。例如 `1566285536`。

另见：

- [日期时间数据类型。](../../sql-reference/data-types/datetime.md)
- [处理日期和时间的函数。](../../sql-reference/functions/date-time-functions.md)
## date_time_overflow_behavior {#date_time_overflow_behavior}   

<SettingsInfoBlock type="DateTimeOverflowBehavior" default_value="ignore" />

定义当 [Date](../../sql-reference/data-types/date.md)、[Date32](../../sql-reference/data-types/date32.md)、[DateTime](../../sql-reference/data-types/datetime.md)、[DateTime64](../../sql-reference/data-types/datetime64.md) 或整数转换为Date、Date32、DateTime或DateTime64但该值无法在结果类型中表示时的行为。

可能的值：

- `ignore` — 安静地忽略溢出。结果未定义。
- `throw` — 如果溢出则抛出异常。
- `saturate` — 饱和结果。如果值小于目标类型所能表示的最小值，则结果选择为可表示的最小值。如果值大于目标类型所能表示的最大值，则结果选择为可表示的最大值。

默认值：`ignore`。
## dictionary_use_async_executor {#dictionary_use_async_executor}   

<SettingsInfoBlock type="Bool" default_value="0" />

在多个线程中执行读取字典源的管道。仅支持具有本地CLICKHOUSE源的字典。
## errors_output_format {#errors_output_format}   

<SettingsInfoBlock type="String" default_value="CSV" />

写入错误到文本输出的方法。
## exact_rows_before_limit {#exact_rows_before_limit}   

<SettingsInfoBlock type="Bool" default_value="0" />

启用时，ClickHouse将在rows_before_limit_at_least统计数据中提供确切值，但代价是必须完全读取限制前的数据。
## format_avro_schema_registry_url {#format_avro_schema_registry_url}   

对于AvroConfluent格式：Confluent Schema Registry URL。
## format_binary_max_array_size {#format_binary_max_array_size}   

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

RowBinary格式中Array的最大允许大小。防止在数据损坏的情况下分配大量内存。0表示没有限制。
## format_binary_max_string_size {#format_binary_max_string_size}   

<SettingsInfoBlock type="UInt64" default_value="1073741824" />

RowBinary格式中String的最大允许大小。防止在数据损坏的情况下分配大量内存。0表示没有限制。
## format_capn_proto_enum_comparising_mode {#format_capn_proto_enum_comparising_mode}   

<SettingsInfoBlock type="CapnProtoEnumComparingMode" default_value="by_values" />

如何映射ClickHouse ENUM和CapnProto ENUM。
## format_capn_proto_use_autogenerated_schema {#format_capn_proto_use_autogenerated_schema}   

<SettingsInfoBlock type="Bool" default_value="1" />

在未设置format_schema时使用自动生成的CapnProto模式。
## format_csv_allow_double_quotes {#format_csv_allow_double_quotes}   

如果设置为true，允许使用双引号的字符串。
## format_csv_allow_single_quotes {#format_csv_allow_single_quotes}   

如果设置为true，允许使用单引号的字符串。
## format_csv_delimiter {#format_csv_delimiter}   

被视为CSV数据中分隔符的字符。如果设置为字符串，则字符串的长度必须为1。
## format_csv_null_representation {#format_csv_null_representation}   

CSV格式中自定义NULL表示。
## format_custom_escaping_rule {#format_custom_escaping_rule}   

字段转义规则（用于CustomSeparated格式）。
## format_custom_field_delimiter {#format_custom_field_delimiter}   

字段之间的分隔符（用于CustomSeparated格式）。
## format_custom_result_after_delimiter {#format_custom_result_after_delimiter}   

结果集之后的后缀（用于CustomSeparated格式）。
## format_custom_result_before_delimiter {#format_custom_result_before_delimiter}   

结果集之前的前缀（用于CustomSeparated格式）。
## format_custom_row_after_delimiter {#format_custom_row_after_delimiter}   

<SettingsInfoBlock type="String" default_value="
" />

最后一列字段后的分隔符（用于CustomSeparated格式）。
## format_custom_row_before_delimiter {#format_custom_row_before_delimiter}   

<SettingsInfoBlock type="String" default_value="
" />

第一列字段前的分隔符（用于CustomSeparated格式）。
## format_custom_row_between_delimiter {#format_custom_row_between_delimiter}   

<SettingsInfoBlock type="String" default_value="
" />

行之间的分隔符（用于CustomSeparated格式）。
## format_display_secrets_in_show_and_select {#format_display_secrets_in_show_and_select}   

<SettingsInfoBlock type="Bool" default_value="0" />

启用或禁用在表、数据库、表函数和字典的 `SHOW` 和 `SELECT` 查询中显示机密。

希望查看机密的用户还必须具有
[`display_secrets_in_show_and_select` 服务器设置](../server-configuration-parameters/settings#display_secrets_in_show_and_select)
已打开，并且具有
[`displaySecretsInShowAndSelect`](/sql-reference/statements/grant#displaysecretsinshowandselect) 权限。

可能的值：

- 0 — 禁用。
- 1 — 启用。
## format_json_object_each_row_column_for_object_name {#format_json_object_each_row_column_for_object_name}   

将用于存储/写入 [JSONObjectEachRow](/interfaces/formats/JSONObjectEachRow) 格式中对象名称的列名。
列类型应该是String。如果值为空，将使用默认名称 `row_{i}` 作为对象名称。
## format_protobuf_use_autogenerated_schema {#format_protobuf_use_autogenerated_schema}   

<SettingsInfoBlock type="Bool" default_value="1" />

在未设置format_schema时使用自动生成的Protobuf。
## format_regexp {#format_regexp}   

<SettingsInfoBlock type="EscapingRule" default_value="Raw" />

正则表达式（用于Regexp格式）。
## format_regexp_escaping_rule {#format_regexp_escaping_rule}   

<SettingsInfoBlock type="EscapingRule" default_value="Raw" />

字段转义规则（用于Regexp格式）。
## format_regexp_skip_unmatched {#format_regexp_skip_unmatched}   

<SettingsInfoBlock type="Bool" default_value="0" />

跳过正则表达式未匹配的行（用于Regexp格式）。
## format_schema {#format_schema}   

此参数在使用需要模式定义的格式时非常有用，例如 [Cap'n Proto](https://capnproto.org/) 或 [Protobuf](https://developers.google.com/protocol-buffers/)。值依赖于格式。
## format_schema_message_name {#format_schema_message_name}   

定义在 `format_schema` 中所需消息的名称。
为了与遗留 `format_schema` 格式（`file_name:message_name`）保持兼容：
- 如果未指定 `format_schema_message_name`，则消息名称从遗留 `format_schema` 值的 `message_name` 部分推断。
- 如果在使用遗留格式时指定了 `format_schema_message_name`，则会引发错误。
## format_schema_source {#format_schema_source}   

<SettingsInfoBlock type="String" default_value="file" />

定义 `format_schema` 的来源。
可能的值：
- 'file' (默认)：`format_schema` 是位于 `format_schemas` 目录中的模式文件的名称。
- 'string'：`format_schema` 是模式的文字内容。
- 'query'：`format_schema` 是用于检索模式的查询。
当将 `format_schema_source` 设置为 'query' 时，适用以下条件：
- 查询必须返回确切一个值：一行带有单个字符串列。
- 查询的结果被视为模式内容。
- 此结果在 `format_schemas` 目录中本地缓存。
- 可以使用命令清除本地缓存：`SYSTEM DROP FORMAT SCHEMA CACHE FOR Files`。
- 一旦缓存，相同的查询不会再次执行以获取模式，直到明确清除缓存。
- 除本地缓存文件外，Protobuf消息也在内存中缓存。即使清除本地缓存文件，也必须使用 `SYSTEM DROP FORMAT SCHEMA CACHE [FOR Protobuf]` 来完全刷新模式。
- 运行查询 `SYSTEM DROP FORMAT SCHEMA CACHE` 可以一次性清除缓存文件和Protobuf消息模式的缓存。
## format_template_resultset {#format_template_resultset}   

用于包含结果集格式字符串的文件的路径（用于模板格式）。
## format_template_resultset_format {#format_template_resultset_format}   

结果集的格式字符串（用于模板格式）。
## format_template_row {#format_template_row}   

用于包含行格式字符串的文件的路径（用于模板格式）。
## format_template_row_format {#format_template_row_format}   

行的格式字符串（用于模板格式）。
## format_template_rows_between_delimiter {#format_template_rows_between_delimiter}   

<SettingsInfoBlock type="String" default_value="
" />

行之间的分隔符（用于模板格式）。
## format_tsv_null_representation {#format_tsv_null_representation}   

TSV格式中的自定义NULL表示。
## input_format_allow_errors_num {#input_format_allow_errors_num}   

<SettingsInfoBlock type="UInt64" default_value="0" />

设置从文本格式（CSV、TSV等）读取时允许的最大错误数量。

默认值为0。

始终与 `input_format_allow_errors_ratio` 一起使用。

如果在读取行时发生错误，但错误计数器仍小于 `input_format_allow_errors_num`，ClickHouse将忽略该行并继续下一个。

如果同时超过 `input_format_allow_errors_num` 和 `input_format_allow_errors_ratio`，ClickHouse将抛出异常。
## input_format_allow_errors_ratio {#input_format_allow_errors_ratio}   

<SettingsInfoBlock type="Float" default_value="0" />

设置在从文本格式（CSV、TSV等）读取时允许的最大错误百分比。
错误的百分比被设置为0到1之间的浮点数。

默认值为0。

始终与 `input_format_allow_errors_num` 一起使用。

如果在读取行时发生错误，但错误计数器仍小于 `input_format_allow_errors_ratio`，ClickHouse将忽略该行并继续下一个。

如果同时超过 `input_format_allow_errors_num` 和 `input_format_allow_errors_ratio`，ClickHouse将抛出异常。
## input_format_allow_seeks {#input_format_allow_seeks}   

<SettingsInfoBlock type="Bool" default_value="1" />

允许在读取ORC/Parquet/Arrow输入格式时进行查找。

默认情况下启用。
## input_format_arrow_allow_missing_columns {#input_format_arrow_allow_missing_columns}   

<SettingsInfoBlock type="Bool" default_value="1" />

在读取Arrow输入格式时允许缺少列。
## input_format_arrow_case_insensitive_column_matching {#input_format_arrow_case_insensitive_column_matching}   

<SettingsInfoBlock type="Bool" default_value="0" />

忽略大小写，匹配箭头列与CH列。
## input_format_arrow_skip_columns_with_unsupported_types_in_schema_inference {#input_format_arrow_skip_columns_with_unsupported_types_in_schema_inference}   

<SettingsInfoBlock type="Bool" default_value="0" />

在Arrow格式的模式推断中跳过具有不支持类型的列。
## input_format_avro_allow_missing_fields {#input_format_avro_allow_missing_fields}   

<SettingsInfoBlock type="Bool" default_value="0" />

对于Avro/AvroConfluent格式：当在模式中找不到字段时，使用默认值而不是错误。
## input_format_avro_null_as_default {#input_format_avro_null_as_default}   

<SettingsInfoBlock type="Bool" default_value="0" />

对于Avro/AvroConfluent格式：在null和非Nullable列的情况下插入默认值。
## input_format_binary_decode_types_in_binary_format {#input_format_binary_decode_types_in_binary_format}   

<SettingsInfoBlock type="Bool" default_value="0" />

在RowBinaryWithNamesAndTypes输入格式中读取数据类型，而不是读取类型名称。
## input_format_binary_read_json_as_string {#input_format_binary_read_json_as_string}   

<SettingsInfoBlock type="Bool" default_value="0" />

在RowBinary输入格式中，将 [JSON](../../sql-reference/data-types/newjson.md) 数据类型的值作为JSON [String](../../sql-reference/data-types/string.md) 值读取。
## input_format_bson_skip_fields_with_unsupported_types_in_schema_inference {#input_format_bson_skip_fields_with_unsupported_types_in_schema_inference}   

<SettingsInfoBlock type="Bool" default_value="0" />

在BSON格式的模式推断中跳过具有不支持类型的字段。
## input_format_capn_proto_skip_fields_with_unsupported_types_in_schema_inference {#input_format_capn_proto_skip_fields_with_unsupported_types_in_schema_inference}   

<SettingsInfoBlock type="Bool" default_value="0" />

在CapnProto格式的模式推断中跳过具有不支持类型的列。
## input_format_csv_allow_cr_end_of_line {#input_format_csv_allow_cr_end_of_line}   

<SettingsInfoBlock type="Bool" default_value="0" />

如果设置为true，则 \\r 将被允许出现在行末，且后面不跟随
## input_format_csv_allow_variable_number_of_columns {#input_format_csv_allow_variable_number_of_columns}   

在CSV输入中忽略额外列（如果文件中列数多于预期），并将缺失字段视为默认值。
## input_format_csv_allow_whitespace_or_tab_as_delimiter {#input_format_csv_allow_whitespace_or_tab_as_delimiter}   

允许在CSV字符串中使用空格和制表符（\\t）作为字段分隔符。
## input_format_csv_arrays_as_nested_csv {#input_format_csv_arrays_as_nested_csv}   

读取Array时，期望其元素在嵌套CSV中被序列化，然后放入字符串中。例如：“[\"Hello\", \"world\", \"42\"]”。数组周围的括号可以省略。
## input_format_csv_deserialize_separate_columns_into_tuple {#input_format_csv_deserialize_separate_columns_into_tuple}   

如果设置为true，则CSV格式的分隔列可以反序列化为Tuple列。
## input_format_csv_detect_header {#input_format_csv_detect_header}   

自动检测CSV格式中的带名称和类型的标题。
## input_format_csv_empty_as_default {#input_format_csv_empty_as_default}   

将CSV输入中的空字段视为默认值。
## input_format_csv_enum_as_number {#input_format_csv_enum_as_number}   

在CSV格式中将插入的枚举值视为枚举索引。
## input_format_csv_skip_first_lines {#input_format_csv_skip_first_lines}   

跳过CSV格式数据开头指定的行数。
## input_format_csv_skip_trailing_empty_lines {#input_format_csv_skip_trailing_empty_lines}   

跳过CSV格式中的尾随空行。
## input_format_csv_trim_whitespaces {#input_format_csv_trim_whitespaces}   

修剪CSV字符串开头和结尾的空格和制表符（\\t）字符。
## input_format_csv_try_infer_numbers_from_strings {#input_format_csv_try_infer_numbers_from_strings}   

<SettingsInfoBlock type="Bool" default_value="0" />

如果启用，在模式推断期间ClickHouse将尝试从字符串字段推断数字。
如果CSV数据包含带引号的UInt64数字，这可能很有用。

默认情况下禁用。
## input_format_csv_try_infer_strings_from_quoted_tuples {#input_format_csv_try_infer_strings_from_quoted_tuples}   

<SettingsInfoBlock type="Bool" default_value="1" />

在输入数据中将引号元组解释为String类型的值。
## input_format_csv_use_best_effort_in_schema_inference {#input_format_csv_use_best_effort_in_schema_inference}   

在CSV格式中使用一些调整和启发式方法来推断模式。
## input_format_csv_use_default_on_bad_values {#input_format_csv_use_default_on_bad_values}   

在CSV字段反序列化失败的情况下允许将默认值设置为列。
## input_format_custom_allow_variable_number_of_columns {#input_format_custom_allow_variable_number_of_columns}   

<SettingsInfoBlock type="Bool" default_value="0" />

在CustomSeparated输入中忽略额外列（如果文件中列数多于预期），并将缺失字段视为默认值。
## input_format_custom_detect_header {#input_format_custom_detect_header}   

自动检测CustomSeparated格式中的带名称和类型的标题。
## input_format_custom_skip_trailing_empty_lines {#input_format_custom_skip_trailing_empty_lines}   

在CustomSeparated格式跳过尾随空行。
## input_format_defaults_for_omitted_fields {#input_format_defaults_for_omitted_fields}   

在执行 `INSERT` 查询时，将省略输入列值替换为相应列的默认值。此选项适用于 [JSONEachRow](/interfaces/formats/JSONEachRow)（和其他JSON格式）、[CSV](/interfaces/formats/CSV)、[TabSeparated](/interfaces/formats/TabSeparated)、[TSKV](/interfaces/formats/TSKV)、[Parquet](/interfaces/formats/Parquet)、[Arrow](/interfaces/formats/Arrow)、[Avro](/interfaces/formats/Avro)、[ORC](/interfaces/formats/ORC)、[Native](/interfaces/formats/Native) 格式和带有 `WithNames`/`WithNamesAndTypes` 后缀的格式。

:::note
启用此选项时，扩展表元数据将从服务器发送到客户端。这会消耗额外的服务器计算资源，并可能降低性能。
:::

可能的值：

- 0 — 禁用。
- 1 — 启用。
## input_format_force_null_for_omitted_fields {#input_format_force_null_for_omitted_fields}   

强制使用null值初始化省略的字段。
## input_format_hive_text_allow_variable_number_of_columns {#input_format_hive_text_allow_variable_number_of_columns}   

<SettingsInfoBlock type="Bool" default_value="1" />

在Hive文本输入中忽略额外列（如果文件中列数多于预期），并将缺失字段视为默认值。
## input_format_hive_text_collection_items_delimiter {#input_format_hive_text_collection_items_delimiter}   

Hive文本文件中集合（数组或映射）项之间的分隔符。
## input_format_hive_text_fields_delimiter {#input_format_hive_text_fields_delimiter}   

Hive文本文件中字段之间的分隔符。
## input_format_hive_text_map_keys_delimiter {#input_format_hive_text_map_keys_delimiter}   

Hive文本文件中键/值对之间的分隔符。
## input_format_import_nested_json {#input_format_import_nested_json}   

启用或禁用插入带有嵌套对象的JSON数据。

支持的格式：

- [JSONEachRow](/interfaces/formats/JSONEachRow)

可能的值：

- 0 — 禁用。
- 1 — 启用。

另见：

- [使用嵌套结构](/integrations/data-formats/json/other-formats#accessing-nested-json-objects) 使用`JSONEachRow`格式。
## input_format_ipv4_default_on_conversion_error {#input_format_ipv4_default_on_conversion_error}   

IPv4的反序列化将在转换错误时使用默认值，而不是抛出异常。

默认情况下禁用。
## input_format_ipv6_default_on_conversion_error {#input_format_ipv6_default_on_conversion_error}   

IPV6的反序列化将在转换错误时使用默认值，而不是抛出异常。

默认情况下禁用。
## input_format_json_compact_allow_variable_number_of_columns {#input_format_json_compact_allow_variable_number_of_columns}   

允许在JSONCompact/JSONCompactEachRow输入格式的行中使用可变数量的列。
在列数多于预期的行中忽略额外列，并将缺失列视为默认值。

默认情况下禁用。
## input_format_json_defaults_for_missing_elements_in_named_tuple {#input_format_json_defaults_for_missing_elements_in_named_tuple}   

在解析命名元组时，为JSON对象中缺失的元素插入默认值。
此设置仅在启用 `input_format_json_named_tuples_as_objects` 时有效。

默认情况下启用。
## input_format_json_empty_as_default {#input_format_json_empty_as_default}   

启用时，将JSON中空输入字段替换为默认值。对于复杂的默认表达式，`input_format_defaults_for_omitted_fields` 也必须启用。

可能的值：

+ 0 — 禁用。
+ 1 — 启用。
## input_format_json_ignore_unknown_keys_in_named_tuple {#input_format_json_ignore_unknown_keys_in_named_tuple}   

忽略命名元组的JSON对象中未知键。

默认情况下启用。
## input_format_json_ignore_unnecessary_fields {#input_format_json_ignore_unnecessary_fields}   

忽略不必要的字段而不进行解析。启用此设置可能不会对格式无效或有重复字段的json字符串引发异常。
## input_format_json_infer_array_of_dynamic_from_array_of_different_types {#input_format_json_infer_array_of_dynamic_from_array_of_different_types}   

如果启用，在模式推断期间ClickHouse将使用Array(Dynamic)类型处理值具有不同数据类型的JSON数组。

示例：

```sql
SET input_format_json_infer_array_of_dynamic_from_array_of_different_types=1;
DESC format(JSONEachRow, '{"a" : [42, "hello", [1, 2, 3]]}');
```

```response
┌─name─┬─type───────────┐
│ a    │ Array(Dynamic) │
└──────┴────────────────┘
```

```sql
SET input_format_json_infer_array_of_dynamic_from_array_of_different_types=0;
DESC format(JSONEachRow, '{"a" : [42, "hello", [1, 2, 3]]}');
```

```response
┌─name─┬─type─────────────────────────────────────────────────────────────┐
│ a    │ Tuple(Nullable(Int64), Nullable(String), Array(Nullable(Int64))) │
└──────┴──────────────────────────────────────────────────────────────────┘
```

默认情况下启用。
## input_format_json_infer_incomplete_types_as_strings {#input_format_json_infer_incomplete_types_as_strings}   

允许在模式推断期间对于JSON数据样本中仅包含 `Null`/`{}`/`[]` 的键使用String类型。
在JSON格式中，任何值都可以作为String读取，我们可以避免在模式推断期间出现类似“无法通过前25000行数据确定字段'column_name'的类型，很可能该字段仅包含Null或空数组/映射”的错误。

示例：

```sql
SET input_format_json_infer_incomplete_types_as_strings = 1, input_format_json_try_infer_named_tuples_from_objects = 1;
DESCRIBE format(JSONEachRow, '{"obj" : {"a" : [1,2,3], "b" : "hello", "c" : null, "d" : {}, "e" : []}}');
SELECT * FROM format(JSONEachRow, '{"obj" : {"a" : [1,2,3], "b" : "hello", "c" : null, "d" : {}, "e" : []}}');
```

结果：
```
┌─name─┬─type───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬─default_type─┬─default_expression─┬─comment─┬─codec_expression─┬─ttl_expression─┐
│ obj  │ Tuple(a Array(Nullable(Int64)), b Nullable(String), c Nullable(String), d Nullable(String), e Array(Nullable(String))) │              │                    │         │                  │                │
└──────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────┴────────────────────┴─────────┴──────────────────┴────────────────┘

┌─obj────────────────────────────┐
│ ([1,2,3],'hello',NULL,'{}',[]) │
└────────────────────────────────┘
```

默认情况下启用。
## input_format_json_map_as_array_of_tuples {#input_format_json_map_as_array_of_tuples}   

将map列反序列化为JSON元组的数组。

默认情况下禁用。
## input_format_json_max_depth {#input_format_json_max_depth}   

JSON中字段的最大深度。这不是严格限制，并不一定要精确应用。
## input_format_json_named_tuples_as_objects {#input_format_json_named_tuples_as_objects}   

将命名元组列解析为JSON对象。

默认情况下启用。
## input_format_json_read_arrays_as_strings {#input_format_json_read_arrays_as_strings}   

允许在JSON输入格式中将JSON数组解析为字符串。

示例：

```sql
SET input_format_json_read_arrays_as_strings = 1;
SELECT arr, toTypeName(arr), JSONExtractArrayRaw(arr)[3] from format(JSONEachRow, 'arr String', '{"arr" : [1, "Hello", [1,2,3]]}');
```

结果：
```
┌─arr───────────────────┬─toTypeName(arr)─┬─arrayElement(JSONExtractArrayRaw(arr), 3)─┐
│ [1, "Hello", [1,2,3]] │ String          │ [1,2,3]                                   │
└───────────────────────┴─────────────────┴───────────────────────────────────────────┘
```

默认情况下启用。
## input_format_json_read_bools_as_numbers {#input_format_json_read_bools_as_numbers}   

允许在JSON输入格式中将布尔值解析为数字。

默认情况下启用。
## input_format_json_read_bools_as_strings {#input_format_json_read_bools_as_strings}   

允许在JSON输入格式中将布尔值解析为字符串。

默认情况下启用。
## input_format_json_read_numbers_as_strings {#input_format_json_read_numbers_as_strings}   

允许在JSON输入格式中将数字解析为字符串。

默认情况下启用。
## input_format_json_read_objects_as_strings {#input_format_json_read_objects_as_strings}   

允许在JSON输入格式中将JSON对象解析为字符串。

示例：

```sql
SET input_format_json_read_objects_as_strings = 1;
CREATE TABLE test (id UInt64, obj String, date Date) ENGINE=Memory();
INSERT INTO test FORMAT JSONEachRow {"id" : 1, "obj" : {"a" : 1, "b" : "Hello"}, "date" : "2020-01-01"};
SELECT * FROM test;
```

结果：

```
┌─id─┬─obj──────────────────────┬───────date─┐
│  1 │ {"a" : 1, "b" : "Hello"} │ 2020-01-01 │
└────┴──────────────────────────┴────────────┘
```

默认情况下启用。
## input_format_json_throw_on_bad_escape_sequence {#input_format_json_throw_on_bad_escape_sequence}   

如果JSON字符串包含不良转义序列，则抛出异常。如果禁用，不良转义序列将原样保留在数据中。

默认情况下启用。
## input_format_json_try_infer_named_tuples_from_objects {#input_format_json_try_infer_named_tuples_from_objects}   

如果启用，在模式推断期间ClickHouse将尝试从JSON对象推断命名元组。
生成的命名元组将包含来自样本数据中所有对应JSON对象的所有元素。

示例：

```sql
SET input_format_json_try_infer_named_tuples_from_objects = 1;
DESC format(JSONEachRow, '{"obj" : {"a" : 42, "b" : "Hello"}}, {"obj" : {"a" : 43, "c" : [1, 2, 3]}}, {"obj" : {"d" : {"e" : 42}}}')
```

结果：

```
┌─name─┬─type───────────────────────────────────────────────────────────────────────────────────────────────┬─default_type─┬─default_expression─┬─comment─┬─codec_expression─┬─ttl_expression─┐
│ obj  │ Tuple(a Nullable(Int64), b Nullable(String), c Array(Nullable(Int64)), d Tuple(e Nullable(Int64))) │              │                    │         │                  │                │
└──────┴────────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────┴────────────────────┴─────────┴──────────────────┴────────────────┘
```

默认情况下启用。
## input_format_json_try_infer_numbers_from_strings {#input_format_json_try_infer_numbers_from_strings}   

如果启用，在模式推断期间ClickHouse将尝试从字符串字段推断数字。
如果JSON数据包含带引号的UInt64数字，这可能很有用。

默认情况下禁用。
## input_format_json_use_string_type_for_ambiguous_paths_in_named_tuples_inference_from_objects {#input_format_json_use_string_type_for_ambiguous_paths_in_named_tuples_inference_from_objects}   

在命名元组推断中的JSON对象的模糊路径情况下，使用String类型而不是抛出异常。
## input_format_json_validate_types_from_metadata {#input_format_json_validate_types_from_metadata}   

对于JSON/JSONCompact/JSONColumnsWithMetadata输入格式，如果该设置设置为1，
将比较输入数据的元数据中的类型与表中对应列的类型。

默认情况下启用。
## input_format_max_block_size_bytes {#input_format_max_block_size_bytes}   

限制在输入格式中解析数据时形成的块的大小（以字节为单位）。在基于行的输入格式中使用，当在ClickHouse端形成块时。
0表示字节上没有限制。
## input_format_max_bytes_to_read_for_schema_inference {#input_format_max_bytes_to_read_for_schema_inference}   

进行自动模式推断时可读取的最大字节数据量。
## input_format_max_rows_to_read_for_schema_inference {#input_format_max_rows_to_read_for_schema_inference}   

进行自动模式推断时可读取的最大数据行数。
## input_format_msgpack_number_of_columns {#input_format_msgpack_number_of_columns}   

插入的MsgPack数据中的列数。用于从数据中进行自动模式推断。
## input_format_mysql_dump_map_column_names {#input_format_mysql_dump_map_column_names}   

根据名称匹配MySQL转储中的表列和ClickHouse表中的列。
## input_format_mysql_dump_table_name {#input_format_mysql_dump_table_name}   

MySQL转储中要读取数据的表名称。
## input_format_native_allow_types_conversion {#input_format_native_allow_types_conversion}   

允许在Native输入格式中进行数据类型转换。
## input_format_native_decode_types_in_binary_format {#input_format_native_decode_types_in_binary_format}   

在Native输入格式中读取数据类型，而不是读取类型名称。
## input_format_null_as_default {#input_format_null_as_default}   

<SettingsInfoBlock type="Bool" default_value="1" />

启用或禁用使用 [NULL](/sql-reference/syntax#literals) 字段的 [默认值](/sql-reference/statements/create/table#default_values) 进行初始化，如果这些字段的数据类型不是 [nullable](/sql-reference/data-types/nullable)。
如果列类型不是nullable，并且该设置禁用，则插入 `NULL` 会导致异常。如果列类型是nullable，则 `NULL` 值将按原样插入，而与此设置无关。

此设置适用于大多数输入格式。

对于复杂的默认表达式，`input_format_defaults_for_omitted_fields` 也必须启用。

可能的值：

- 0 — 将 `NULL` 插入非nullable列导致异常。
- 1 — `NULL` 字段用默认列值初始化。
## input_format_orc_allow_missing_columns {#input_format_orc_allow_missing_columns}   

<SettingsInfoBlock type="Bool" default_value="1" />

在读取ORC输入格式时允许缺少列。
## input_format_orc_case_insensitive_column_matching {#input_format_orc_case_insensitive_column_matching}   

<SettingsInfoBlock type="Bool" default_value="0" />

在匹配 ORC 列与 CH 列时忽略大小写。
## input_format_orc_dictionary_as_low_cardinality {#input_format_orc_dictionary_as_low_cardinality}   

<SettingsInfoBlock type="Bool" default_value="1" />

在读取 ORC 文件时，将 ORC 字典编码列视为 LowCardinality 列。
## input_format_orc_filter_push_down {#input_format_orc_filter_push_down}   

<SettingsInfoBlock type="Bool" default_value="1" />

在读取 ORC 文件时，根据 WHERE/PREWHERE 表达式、最小/最大统计信息或 ORC 元数据中的布隆过滤器跳过整个条带或行组。
## input_format_orc_reader_time_zone_name {#input_format_orc_reader_time_zone_name}   

<SettingsInfoBlock type="String" default_value="GMT" />

ORC 行读取器的时区名称，默认 ORC 行读取器的时区为 GMT。
## input_format_orc_row_batch_size {#input_format_orc_row_batch_size}   

<SettingsInfoBlock type="Int64" default_value="100000" />

读取 ORC 条带时的批处理大小。
## input_format_orc_skip_columns_with_unsupported_types_in_schema_inference {#input_format_orc_skip_columns_with_unsupported_types_in_schema_inference}   

<SettingsInfoBlock type="Bool" default_value="0" />

在 ORC 格式的模式推断过程中跳过具有不支持类型的列。
## input_format_orc_use_fast_decoder {#input_format_orc_use_fast_decoder}   

<SettingsInfoBlock type="Bool" default_value="1" />

使用更快的 ORC 解码器实现。
## input_format_parquet_allow_geoparquet_parser {#input_format_parquet_allow_geoparquet_parser}   

<SettingsInfoBlock type="Bool" default_value="1" />

使用地理列解析器将 Array(UInt8) 转换为 Point/Linestring/Polygon/MultiLineString/MultiPolygon 类型。
## input_format_parquet_allow_missing_columns {#input_format_parquet_allow_missing_columns}   

<SettingsInfoBlock type="Bool" default_value="1" />

在读取 Parquet 输入格式时允许缺少列。
## input_format_parquet_bloom_filter_push_down {#input_format_parquet_bloom_filter_push_down}   

<SettingsInfoBlock type="Bool" default_value="1" />

在读取 Parquet 文件时，根据 WHERE 表达式和 Parquet 元数据中的布隆过滤器跳过整个行组。
## input_format_parquet_case_insensitive_column_matching {#input_format_parquet_case_insensitive_column_matching}   

<SettingsInfoBlock type="Bool" default_value="0" />

在匹配 Parquet 列与 CH 列时忽略大小写。
## input_format_parquet_enable_json_parsing {#input_format_parquet_enable_json_parsing}   

<SettingsInfoBlock type="Bool" default_value="1" />

在读取 Parquet 文件时，将 JSON 列解析为 ClickHouse JSON 列。
## input_format_parquet_enable_row_group_prefetch {#input_format_parquet_enable_row_group_prefetch}   

<SettingsInfoBlock type="Bool" default_value="1" />

在 Parquet 解析过程中启用行组预取。目前，只有单线程解析可以进行预取。
## input_format_parquet_filter_push_down {#input_format_parquet_filter_push_down}   

<SettingsInfoBlock type="Bool" default_value="1" />

在读取 Parquet 文件时，根据 WHERE/PREWHERE 表达式和 Parquet 元数据中的最小/最大统计信息跳过整个行组。
## input_format_parquet_local_file_min_bytes_for_seek {#input_format_parquet_local_file_min_bytes_for_seek}   

<SettingsInfoBlock type="UInt64" default_value="8192" />

进行本地读取（文件）以执行查找所需的最小字节数，而不是在 Parquet 输入格式中忽略读取。
## input_format_parquet_max_block_size {#input_format_parquet_max_block_size}   

<SettingsInfoBlock type="NonZeroUInt64" default_value="65409" />

Parquet 阅读器的最大块大小。
## input_format_parquet_memory_high_watermark {#input_format_parquet_memory_high_watermark}   

<SettingsInfoBlock type="UInt64" default_value="4294967296" />

Parquet 阅读器 v3 的近似内存限制。限制可以并行读取的行组或列的数量。当在一个查询中读取多个文件时，限制是这些文件的总内存使用量。
## input_format_parquet_memory_low_watermark {#input_format_parquet_memory_low_watermark}   

<SettingsInfoBlock type="UInt64" default_value="2097152" />

如果内存使用量低于阈值，则更积极地调度预取。这在通过网络读取许多小布隆过滤器时可能会很有用。
## input_format_parquet_page_filter_push_down {#input_format_parquet_page_filter_push_down}   

<SettingsInfoBlock type="Bool" default_value="1" />

使用列索引中的最小/最大值跳过页面。
## input_format_parquet_prefer_block_bytes {#input_format_parquet_prefer_block_bytes}   

<SettingsInfoBlock type="UInt64" default_value="16744704" />

Parquet 阅读器输出的平均块字节数。
## input_format_parquet_preserve_order {#input_format_parquet_preserve_order}   

<SettingsInfoBlock type="Bool" default_value="0" />

在从 Parquet 文件读取时避免重新排序行。不推荐，因为行的排序通常不保证，查询管道的其他部分可能会破坏它。请改用 `ORDER BY _row_number`。
## input_format_parquet_skip_columns_with_unsupported_types_in_schema_inference {#input_format_parquet_skip_columns_with_unsupported_types_in_schema_inference}   

<SettingsInfoBlock type="Bool" default_value="0" />

在 Parquet 格式的模式推断过程中跳过具有不支持类型的列。
## input_format_parquet_use_native_reader {#input_format_parquet_use_native_reader}   

<SettingsInfoBlock type="Bool" default_value="0" />

使用原生 Parquet 阅读器 v1。这是相对快速但未完成的实现。已弃用。
## input_format_parquet_use_native_reader_v3 {#input_format_parquet_use_native_reader_v3} <ExperimentalBadge/>  

<SettingsInfoBlock type="Bool" default_value="0" />

使用 Parquet 阅读器 v3。实验性。
## input_format_parquet_use_offset_index {#input_format_parquet_use_offset_index}   

<SettingsInfoBlock type="Bool" default_value="1" />

在不使用页面过滤的情况下，稍微调整从 Parquet 文件读取页面的方式。
## input_format_protobuf_flatten_google_wrappers {#input_format_protobuf_flatten_google_wrappers}   

<SettingsInfoBlock type="Bool" default_value="0" />

启用 Google wrappers 用于常规非嵌套列，例如 google.protobuf.StringValue 'str' 用于字符串列 'str'。对于 Nullable 列，空的 wrappers 被识别为默认值，缺失则作为 null。
## input_format_protobuf_oneof_presence {#input_format_protobuf_oneof_presence}   

<SettingsInfoBlock type="Bool" default_value="0" />

通过在特殊列中设置枚举值指示 protobuf oneof 的哪些字段被找到。
## input_format_protobuf_skip_fields_with_unsupported_types_in_schema_inference {#input_format_protobuf_skip_fields_with_unsupported_types_in_schema_inference}   

<SettingsInfoBlock type="Bool" default_value="0" />

在 Protobuf 格式的模式推断过程中跳过具有不支持类型的字段。
## input_format_record_errors_file_path {#input_format_record_errors_file_path}   

用于记录读取文本格式（CSV, TSV）时错误的文件路径。
## input_format_skip_unknown_fields {#input_format_skip_unknown_fields}   

<SettingsInfoBlock type="Bool" default_value="1" />

启用或禁用跳过多余数据的插入。

在插入数据时，如果输入数据包含在目标表中不存在的列，ClickHouse 会抛出异常。如果启用跳过，ClickHouse 不会插入多余数据，也不会抛出异常。

支持的格式：

- [JSONEachRow](/interfaces/formats/JSONEachRow)（和其他 JSON 格式）
- [BSONEachRow](/interfaces/formats/BSONEachRow)（和其他 JSON 格式）
- [TSKV](/interfaces/formats/TSKV）
- 所有带有 WithNames/WithNamesAndTypes 后缀的格式
- [MySQLDump](/interfaces/formats/MySQLDump）
- [Native](/interfaces/formats/Native）

可能的值：

- 0 — 禁用。
- 1 — 启用。
## input_format_try_infer_dates {#input_format_try_infer_dates}   

<SettingsInfoBlock type="Bool" default_value="1" />

如果启用，ClickHouse 将尝试从模式推断文本格式中的字符串字段推断类型 `Date`。如果输入数据中列的所有字段都成功解析为日期，则结果类型将为 `Date`；如果至少有一个字段未解析为日期，则结果类型将为 `String`。

默认启用。
## input_format_try_infer_datetimes {#input_format_try_infer_datetimes}   

<SettingsInfoBlock type="Bool" default_value="1" />

如果启用，ClickHouse 将尝试从模式推断文本格式中的字符串字段推断类型 `DateTime64`。如果输入数据中列的所有字段都成功解析为日期时间，则结果类型将为 `DateTime64`；如果至少有一个字段未解析为日期时间，则结果类型将为 `String`。

默认启用。
## input_format_try_infer_datetimes_only_datetime64 {#input_format_try_infer_datetimes_only_datetime64}   

<SettingsInfoBlock type="Bool" default_value="0" />

当 input_format_try_infer_datetimes 启用时，仅推断 DateTime64 而不推断 DateTime 类型。
## input_format_try_infer_exponent_floats {#input_format_try_infer_exponent_floats}   

<SettingsInfoBlock type="Bool" default_value="0" />

尝试在文本格式的模式推断过程中推断以指数表示的浮点数（除 JSON 外，因为在 JSON 中，指数数字总是被推断）。
## input_format_try_infer_integers {#input_format_try_infer_integers}   

<SettingsInfoBlock type="Bool" default_value="1" />

如果启用，ClickHouse 将尝试在文本格式的模式推断中推断整型而不是浮点型。如果输入数据中列的所有数字都是整数，则结果类型将为 `Int64`；如果至少有一个数字是浮点数，则结果类型将为 `Float64`。

默认启用。
## input_format_try_infer_variants {#input_format_try_infer_variants}   

<SettingsInfoBlock type="Bool" default_value="0" />

如果启用，ClickHouse 将尝试在文本格式的模式推断中推断类型 [`Variant`](../../sql-reference/data-types/variant.md)，当列/数组元素有多种可能类型时。

可能的值：

- 0 — 禁用。
- 1 — 启用。
## input_format_tsv_allow_variable_number_of_columns {#input_format_tsv_allow_variable_number_of_columns}   

<SettingsInfoBlock type="Bool" default_value="0" />

忽略 TSV 输入中的额外列（如果文件中的列超过预期），并将 TSV 输入中的缺失字段视为默认值。
## input_format_tsv_crlf_end_of_line {#input_format_tsv_crlf_end_of_line}   

<SettingsInfoBlock type="Bool" default_value="0" />

如果设置为 true，则文件功能将读取带有 \\r\\n 的 TSV 格式，而不是 \\n。
## input_format_tsv_detect_header {#input_format_tsv_detect_header}   

<SettingsInfoBlock type="Bool" default_value="1" />

自动检测 TSV 格式中的列名和类型的头。
## input_format_tsv_empty_as_default {#input_format_tsv_empty_as_default}   

<SettingsInfoBlock type="Bool" default_value="0" />

将 TSV 输入中的空字段视为默认值。
## input_format_tsv_enum_as_number {#input_format_tsv_enum_as_number}   

<SettingsInfoBlock type="Bool" default_value="0" />

将 TSV 格式中的插入的枚举值视为枚举索引。
## input_format_tsv_skip_first_lines {#input_format_tsv_skip_first_lines}   

<SettingsInfoBlock type="UInt64" default_value="0" />

跳过 TSV 格式数据开头指定数量的行。
## input_format_tsv_skip_trailing_empty_lines {#input_format_tsv_skip_trailing_empty_lines}   

<SettingsInfoBlock type="Bool" default_value="0" />

跳过 TSV 格式中的尾部空行。
## input_format_tsv_use_best_effort_in_schema_inference {#input_format_tsv_use_best_effort_in_schema_inference}   

<SettingsInfoBlock type="Bool" default_value="1" />

使用一些技巧和启发式方法在 TSV 格式中推断模式。
## input_format_values_accurate_types_of_literals {#input_format_values_accurate_types_of_literals}   

<SettingsInfoBlock type="Bool" default_value="1" />

对于 Values 格式：在解析和解释使用模板的表达式时，检查文字的实际类型以避免可能的溢出和精度问题。
## input_format_values_deduce_templates_of_expressions {#input_format_values_deduce_templates_of_expressions}   

<SettingsInfoBlock type="Bool" default_value="1" />

对于 Values 格式：如果字段无法通过流式解析器解析，则运行 SQL 解析器，推导 SQL 表达式的模板，尝试使用模板解析所有行，然后解释所有行的表达式。
## input_format_values_interpret_expressions {#input_format_values_interpret_expressions}   

<SettingsInfoBlock type="Bool" default_value="1" />

对于 Values 格式：如果字段无法通过流式解析器解析，则运行 SQL 解析器并尝试将其解释为 SQL 表达式。
## input_format_with_names_use_header {#input_format_with_names_use_header}   

<SettingsInfoBlock type="Bool" default_value="1" />

启用或禁用在插入数据时检查列的顺序。

为了提高插入性能，我们建议在确定输入数据的列顺序与目标表相同的情况下禁用此检查。

支持的格式：

- [CSVWithNames](/interfaces/formats/CSVWithNames)
- [CSVWithNamesAndTypes](/interfaces/formats/CSVWithNamesAndTypes)
- [TabSeparatedWithNames](/interfaces/formats/TabSeparatedWithNames)
- [TabSeparatedWithNamesAndTypes](/interfaces/formats/TabSeparatedWithNamesAndTypes)
- [JSONCompactEachRowWithNames](/interfaces/formats/JSONCompactEachRowWithNames)
- [JSONCompactEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactEachRowWithNamesAndTypes)
- [JSONCompactStringsEachRowWithNames](/interfaces/formats/JSONCompactStringsEachRowWithNamesAndTypes)
- [RowBinaryWithNames](/interfaces/formats/RowBinaryWithNames)
- [RowBinaryWithNamesAndTypes](/interfaces/formats/RowBinaryWithNamesAndTypes)
- [CustomSeparatedWithNames](/interfaces/formats/CustomSeparatedWithNames)
- [CustomSeparatedWithNamesAndTypes](/interfaces/formats/CustomSeparatedWithNamesAndTypes)

可能的值：

- 0 — 禁用。
- 1 — 启用。
## input_format_with_types_use_header {#input_format_with_types_use_header}   

<SettingsInfoBlock type="Bool" default_value="1" />

控制格式解析器是否应检查输入数据的类型与目标表中的数据类型是否匹配。

支持的格式：

- [CSVWithNamesAndTypes](/interfaces/formats/CSVWithNamesAndTypes)
- [TabSeparatedWithNamesAndTypes](/interfaces/formats/TabSeparatedWithNamesAndTypes)
- [JSONCompactEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactEachRowWithNamesAndTypes)
- [JSONCompactStringsEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactStringsEachRowWithNamesAndTypes)
- [RowBinaryWithNamesAndTypes](/interfaces/formats/RowBinaryWithNamesAndTypes)
- [CustomSeparatedWithNamesAndTypes](/interfaces/formats/CustomSeparatedWithNamesAndTypes)

可能的值：

- 0 — 禁用。
- 1 — 启用。
## insert_distributed_one_random_shard {#insert_distributed_one_random_shard}   

<SettingsInfoBlock type="Bool" default_value="0" />

启用或禁用在没有分布式键时随机分片插入 [Distributed](/engines/table-engines/special/distributed) 表。

默认情况下，当向具有多个分片的 `Distributed` 表插入数据时，如果没有分布式键，ClickHouse 服务器将拒绝任何插入请求。当 `insert_distributed_one_random_shard = 1` 时，允许插入，并将数据随机转发到所有分片。

可能的值：

- 0 — 如果有多个分片且未给出分布式键，则拒绝插入。
- 1 — 在未给出分布式键时，在所有可用分片之间随机进行插入。
## interval_output_format {#interval_output_format}   

<SettingsInfoBlock type="IntervalOutputFormat" default_value="numeric" />

允许选择间隔类型文本表示的不同输出格式。

可能的值：

-   `kusto` - KQL 样式输出格式。

    ClickHouse 以 [KQL 格式](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-timespan-format-strings#the-constant-c-format-specifier) 输出间隔。例如，`toIntervalDay(2)` 将格式化为 `2.00:00:00`。请注意，对于长度不等的间隔类型（例如 `IntervalMonth` 和 `IntervalYear`），会考虑每个间隔的平均秒数。

-   `numeric` - 数字输出格式。

    ClickHouse 以其底层的数字表示输出间隔。例如，`toIntervalDay(2)` 将格式化为 `2`。

另请参见：

-   [Interval](../../sql-reference/data-types/special-data-types/interval.md)
## json_type_escape_dots_in_keys {#json_type_escape_dots_in_keys}   

<SettingsInfoBlock type="Bool" default_value="0" />

启用后，在解析期间将转义 JSON 键中的点。
## output_format_arrow_compression_method {#output_format_arrow_compression_method}   

<SettingsInfoBlock type="ArrowCompression" default_value="lz4_frame" />

Arrow 输出格式的压缩方法。支持的编解码器：lz4_frame, zstd, none（未压缩）
## output_format_arrow_fixed_string_as_fixed_byte_array {#output_format_arrow_fixed_string_as_fixed_byte_array}   

<SettingsInfoBlock type="Bool" default_value="1" />

对于 FixedString 列，使用 Arrow FIXED_SIZE_BINARY 类型，而不是 Binary。
## output_format_arrow_low_cardinality_as_dictionary {#output_format_arrow_low_cardinality_as_dictionary}   

<SettingsInfoBlock type="Bool" default_value="0" />

将输出 LowCardinality 类型作为字典 Arrow 类型。
## output_format_arrow_string_as_string {#output_format_arrow_string_as_string}   

<SettingsInfoBlock type="Bool" default_value="1" />

对于字符串列，使用 Arrow 字符串类型，而不是 Binary。
## output_format_arrow_use_64_bit_indexes_for_dictionary {#output_format_arrow_use_64_bit_indexes_for_dictionary}   

<SettingsInfoBlock type="Bool" default_value="0" />

始终使用 64 位整数作为 Arrow 格式中的字典索引。
## output_format_arrow_use_signed_indexes_for_dictionary {#output_format_arrow_use_signed_indexes_for_dictionary}   

<SettingsInfoBlock type="Bool" default_value="1" />

在 Arrow 格式中为字典索引使用有符号整数。
## output_format_avro_codec {#output_format_avro_codec}   

<SettingsInfoBlock type="UInt64" default_value="1" />

用于输出的压缩编解码器。可能的值：'null', 'deflate', 'snappy', 'zstd'。
## output_format_avro_rows_in_file {#output_format_avro_rows_in_file}   

<SettingsInfoBlock type="UInt64" default_value="16384" />

文件中的最大行数（如果存储允许）。
## output_format_avro_string_column_pattern {#output_format_avro_string_column_pattern}   

   
用于 Avro 格式：选择为 AVRO 字符串的字符串列的正则表达式。
## output_format_avro_sync_interval {#output_format_avro_sync_interval}   

<SettingsInfoBlock type="Bool" default_value="0" />

同步间隔（以字节为单位）。
## output_format_binary_encode_types_in_binary_format {#output_format_binary_encode_types_in_binary_format}   

<SettingsInfoBlock type="Bool" default_value="0" />

在 RowBinaryWithNamesAndTypes 输出格式中以二进制格式写入数据类型，而不是类型名称。
## output_format_binary_write_json_as_string {#output_format_binary_write_json_as_string}   

<SettingsInfoBlock type="Bool" default_value="0" />

在 RowBinary 输出格式中，将 [JSON](../../sql-reference/data-types/newjson.md) 数据类型的值写为 JSON [String](../../sql-reference/data-types/string.md) 值。
## output_format_bson_string_as_string {#output_format_bson_string_as_string}   

<SettingsInfoBlock type="Bool" default_value="0" />

对于字符串列，使用 BSON 字符串类型，而不是 Binary。
## output_format_csv_crlf_end_of_line {#output_format_csv_crlf_end_of_line}   

<SettingsInfoBlock type="Bool" default_value="1" />

如果设置为 true，CSV 格式的行结束将为 \\r\\n，而不是 \\n。
## output_format_csv_serialize_tuple_into_separate_columns {#output_format_csv_serialize_tuple_into_separate_columns}   

<SettingsInfoBlock type="Bool" default_value="0" />

如果设置为 true，则 CSV 格式中的元组被序列化为单独的列（即它们在元组中的嵌套关系丢失）。
## output_format_decimal_trailing_zeros {#output_format_decimal_trailing_zeros}   

<SettingsInfoBlock type="Bool" default_value="0" />

打印十进制值时输出尾随零。例如，1.230000 而不是 1.23。

默认禁用。
## output_format_json_array_of_rows {#output_format_json_array_of_rows}   

<SettingsInfoBlock type="Bool" default_value="1" />

启用将所有行作为 JSON 数组输出的能力，格式为 [JSONEachRow](/interfaces/formats/JSONEachRow)。

可能的值：

- 1 — ClickHouse 将所有行输出为数组，每行为 `JSONEachRow` 格式。
- 0 — ClickHouse 将每行单独输出为 `JSONEachRow` 格式。

**启用设置的查询示例**

查询：

```sql
SET output_format_json_array_of_rows = 1;
SELECT number FROM numbers(3) FORMAT JSONEachRow;
```

结果：

```text
[
{"number":"0"},
{"number":"1"},
{"number":"2"}
]
```

**禁用设置的查询示例**

查询：

```sql
SET output_format_json_array_of_rows = 0;
SELECT number FROM numbers(3) FORMAT JSONEachRow;
```

结果：

```text
{"number":"0"}
{"number":"1"}
{"number":"2"}
```
## output_format_json_escape_forward_slashes {#output_format_json_escape_forward_slashes}   

<SettingsInfoBlock type="Bool" default_value="0" />

控制 JSON 输出格式中字符串输出的正斜杠转义。这是为了与 JavaScript 兼容。与总是被转义的反斜杠混淆。
 
默认启用。
## output_format_json_map_as_array_of_tuples {#output_format_json_map_as_array_of_tuples}   

<SettingsInfoBlock type="Bool" default_value="1" />

将映射列序列化为 JSON 元组数组。

默认禁用。
## output_format_json_named_tuples_as_objects {#output_format_json_named_tuples_as_objects}   

<SettingsInfoBlock type="Bool" default_value="1" />

将命名元组列序列化为 JSON 对象。

默认启用。
## output_format_json_pretty_print {#output_format_json_pretty_print}   

<SettingsInfoBlock type="Bool" default_value="0" />

此设置确定在使用 JSON 输出格式时，嵌套结构（例如元组、映射和数组）在 `data` 数组中如何显示。

例如，输出将不再是：

```json
"data":
[
  {
    "tuple": {"a":1,"b":2,"c":3},
    "array": [1,2,3],
    "map": {"a":1,"b":2,"c":3}
  }
],
```

而是格式化为：

```json
"data":
[
    {
        "tuple": {
            "a": 1,
            "b": 2,
            "c": 3
        },
        "array": [
            1,
            2,
            3
        ],
        "map": {
            "a": 1,
            "b": 2,
            "c": 3
        }
    }
],
```

默认启用。
## output_format_json_quote_64bit_floats {#output_format_json_quote_64bit_floats}   

<SettingsInfoBlock type="Bool" default_value="0" />

控制在 JSON* 格式中输出 64 位 [浮点数](../../sql-reference/data-types/float.md) 时的引号。

默认禁用。
## output_format_json_quote_64bit_integers {#output_format_json_quote_64bit_integers}   

<SettingsInfoBlock type="Bool" default_value="0" />

控制在 [JSON](/interfaces/formats/JSON) 格式中输出 64 位或更大 [整数](../../sql-reference/data-types/int-uint.md)（如 `UInt64` 或 `Int128`）时的引号。
该整数默认用引号括起来。这种行为与大多数 JavaScript 实现兼容。

可能的值：

- 0 — 整数不带引号输出。
- 1 — 整数用引号括起来。
## output_format_json_quote_decimals {#output_format_json_quote_decimals}   

<SettingsInfoBlock type="Bool" default_value="0" />

控制在 JSON 输出格式中小数的引号。

默认禁用。
## output_format_json_quote_denormals {#output_format_json_quote_denormals}   

<SettingsInfoBlock type="Bool" default_value="0" />

启用在 [JSON](/interfaces/formats/JSON) 输出格式中输出 `+nan`、`-nan`、`+inf`、`-inf`。

可能的值：

- 0 — 禁用。
- 1 — 启用。

**示例**

考虑以下表 `account_orders`：

```text
┌─id─┬─name───┬─duration─┬─period─┬─area─┐
│  1 │ Andrew │       20 │      0 │  400 │
│  2 │ John   │       40 │      0 │    0 │
│  3 │ Bob    │       15 │      0 │ -100 │
└────┴────────┴──────────┴────────┴──────┘
```

当 `output_format_json_quote_denormals = 0` 时，查询返回的输出中的值为 `null`：

```sql
SELECT area/period FROM account_orders FORMAT JSON;
```

```json
{
        "meta":
        [
                {
                        "name": "divide(area, period)",
                        "type": "Float64"
                }
        ],

        "data":
        [
                {
                        "divide(area, period)": null
                },
                {
                        "divide(area, period)": null
                },
                {
                        "divide(area, period)": null
                }
        ],

        "rows": 3,

        "statistics":
        {
                "elapsed": 0.003648093,
                "rows_read": 3,
                "bytes_read": 24
        }
}
```

当 `output_format_json_quote_denormals = 1` 时，查询返回：

```json
{
        "meta":
        [
                {
                        "name": "divide(area, period)",
                        "type": "Float64"
                }
        ],

        "data":
        [
                {
                        "divide(area, period)": "inf"
                },
                {
                        "divide(area, period)": "-nan"
                },
                {
                        "divide(area, period)": "-inf"
                }
        ],

        "rows": 3,

        "statistics":
        {
                "elapsed": 0.000070241,
                "rows_read": 3,
                "bytes_read": 24
        }
}
```
## output_format_json_skip_null_value_in_named_tuples {#output_format_json_skip_null_value_in_named_tuples}   

<SettingsInfoBlock type="Bool" default_value="0" />

在将命名元组列序列化为 JSON 对象时，跳过具有 null 值的键值对。仅在 output_format_json_named_tuples_as_objects 为 true 时有效。
## output_format_json_validate_utf8 {#output_format_json_validate_utf8}   

<SettingsInfoBlock type="Bool" default_value="0" />

控制在 JSON 输出格式中对 UTF-8 序列的验证，不影响格式 JSON/JSONCompact/JSONColumnsWithMetadata，它们始终验证 UTF-8。

默认禁用。
## output_format_markdown_escape_special_characters {#output_format_markdown_escape_special_characters}   

<SettingsInfoBlock type="MsgPackUUIDRepresentation" default_value="ext" />

启用后，在 Markdown 中转义特殊字符。

[Common Mark](https://spec.commonmark.org/0.30/#example-12) 定义以下特殊字符可以被转义：

```
! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
```

可能的值：

+ 0 — 禁用。
+ 1 — 启用。
## output_format_msgpack_uuid_representation {#output_format_msgpack_uuid_representation}   

<SettingsInfoBlock type="Bool" default_value="0" />

在 MsgPack 格式中输出 UUID 的方式。
## output_format_native_encode_types_in_binary_format {#output_format_native_encode_types_in_binary_format}   

<SettingsInfoBlock type="Bool" default_value="0" />

在原生输出格式中以二进制格式写入数据类型，而不是类型名称。
## output_format_native_use_flattened_dynamic_and_json_serialization {#output_format_native_use_flattened_dynamic_and_json_serialization}   

<SettingsInfoBlock type="Bool" default_value="0" />

以扁平格式（将所有类型/路径作为单独的子列）写入 [JSON](../../sql-reference/data-types/newjson.md) 和 [Dynamic](../../sql-reference/data-types/dynamic.md) 列的数据。
## output_format_native_write_json_as_string {#output_format_native_write_json_as_string}   

<SettingsInfoBlock type="UInt64" default_value="262144" />

以 [String](../../sql-reference/data-types/string.md) 列的形式写入 [JSON](../../sql-reference/data-types/newjson.md) 列的数据，其中包含 JSON 字符串，而不是默认的原生 JSON 序列化。
## output_format_orc_compression_block_size {#output_format_orc_compression_block_size}   

<SettingsInfoBlock type="ORCCompression" default_value="zstd" />

ORC 输出格式中压缩块的字节大小。
## output_format_orc_compression_method {#output_format_orc_compression_method}   

<SettingsInfoBlock type="Double" default_value="0" />

ORC 输出格式的压缩方法。支持的编解码器：lz4, snappy, zlib, zstd, none（未压缩）。
## output_format_orc_dictionary_key_size_threshold {#output_format_orc_dictionary_key_size_threshold}   

<SettingsInfoBlock type="UInt64" default_value="10000" />

对于 ORC 输出格式中的字符串列，如果不同值的数量超过非空行总数的这一比例，则关闭字典编码。否则启用字典编码。
## output_format_orc_row_index_stride {#output_format_orc_row_index_stride}   

ORC 输出格式中目标行索引步幅。
## output_format_orc_string_as_string {#output_format_orc_string_as_string}   

<SettingsInfoBlock type="Bool" default_value="1" />

对于字符串列，使用 ORC 字符串类型，而不是 Binary。
## output_format_orc_writer_time_zone_name {#output_format_orc_writer_time_zone_name}   

<SettingsInfoBlock type="String" default_value="GMT" />

ORC 写入器的时区名称，默认 ORC 写入器的时区为 GMT。
## output_format_parquet_batch_size {#output_format_parquet_batch_size}   

<SettingsInfoBlock type="NonZeroUInt64" default_value="1024" />

检查每这多少行的页面大小。如果您的列的平均值大小超过几个 KB，请考虑减少该值。
## output_format_parquet_bloom_filter_bits_per_value {#output_format_parquet_bloom_filter_bits_per_value}   

<SettingsInfoBlock type="Double" default_value="10.5" />

在 Parquet 布隆过滤器中为每个不同值使用的近似位数。估计的假阳性率：
  *  6 位 - 10%
  * 10.5 位 -  1%
  * 16.9 位 -  0.1%
  * 26.4 位 -  0.01%
  * 41 位 -  0.001%
## output_format_parquet_bloom_filter_flush_threshold_bytes {#output_format_parquet_bloom_filter_flush_threshold_bytes}   

<SettingsInfoBlock type="UInt64" default_value="134217728" />

在 Parquet 文件中放置布隆过滤器的位置。布隆过滤器将以大约此大小的组写入。特别是：
  * 如果为 0，每个行组的布隆过滤器会立即写在行组之后。
  * 如果大于所有布隆过滤器的总大小，所有行组的布隆过滤器将存储在内存中，然后一起在文件的末尾附近写入。
  * 否则，布隆过滤器将在内存中累积，并在其总大小超过此值时写出。
## output_format_parquet_compliant_nested_types {#output_format_parquet_compliant_nested_types}   

<SettingsInfoBlock type="Bool" default_value="1" />

在 Parquet 文件模式中，为列表元素使用名称 'element' 而不是 'item'。这是 Arrow 库实现的历史遗留物。通常可以增加兼容性，除非与某些旧版本的 Arrow。
## output_format_parquet_compression_method {#output_format_parquet_compression_method}   

<SettingsInfoBlock type="ParquetCompression" default_value="zstd" />

Parquet 输出格式的压缩方法。支持的编解码器：snappy, lz4, brotli, zstd, gzip, none（未压缩）。
## output_format_parquet_data_page_size {#output_format_parquet_data_page_size}   

<SettingsInfoBlock type="UInt64" default_value="1048576" />

以字节为单位的目标页面大小，在压缩之前。
## output_format_parquet_date_as_uint16 {#output_format_parquet_date_as_uint16}   

<SettingsInfoBlock type="Bool" default_value="0" />

将日期值写为普通的 16 位数字（以 UInt16 读取），而不是转换为 32 位 parquet DATE 类型（以 Date32 读取）。
## output_format_parquet_datetime_as_uint32 {#output_format_parquet_datetime_as_uint32}   

<SettingsInfoBlock type="Bool" default_value="0" />

将 DateTime 值写为原始 unix 时间戳（以 UInt32 读取），而不是转换为毫秒（以 DateTime64(3) 读取）。
## output_format_parquet_enum_as_byte_array {#output_format_parquet_enum_as_byte_array}   

<SettingsInfoBlock type="Bool" default_value="1" />

使用 parquet 物理类型：BYTE_ARRAY 和逻辑类型：ENUM 编写枚举。
## output_format_parquet_fixed_string_as_fixed_byte_array {#output_format_parquet_fixed_string_as_fixed_byte_array}   

<SettingsInfoBlock type="Bool" default_value="1" />

对于 FixedString 列，使用 Parquet FIXED_LENGTH_BYTE_ARRAY 类型，而不是 Binary。
## output_format_parquet_geometadata {#output_format_parquet_geometadata}   

<SettingsInfoBlock type="Bool" default_value="1" />

允许在 parquet 元数据中写入有关地理列的信息，并以 WKB 格式编码列。
## output_format_parquet_max_dictionary_size {#output_format_parquet_max_dictionary_size}   

<SettingsInfoBlock type="UInt64" default_value="1048576" />

如果字典大小超过这一字节数，则切换到不使用字典的编码。设置为 0 以禁用字典编码。
## output_format_parquet_parallel_encoding {#output_format_parquet_parallel_encoding}   

<SettingsInfoBlock type="Bool" default_value="1" />

在多个线程中进行 Parquet 编码。需要 output_format_parquet_use_custom_encoder。
## output_format_parquet_row_group_size {#output_format_parquet_row_group_size}   

<SettingsInfoBlock type="UInt64" default_value="1000000" />

目标行组大小（以行数为单位）。
## output_format_parquet_row_group_size_bytes {#output_format_parquet_row_group_size_bytes}   

<SettingsInfoBlock type="UInt64" default_value="536870912" />

目标行组大小（以字节为单位），在压缩之前。
## output_format_parquet_string_as_string {#output_format_parquet_string_as_string}   

<SettingsInfoBlock type="Bool" default_value="1" />

对于字符串列，使用 Parquet 字符串类型，而不是 Binary。
## output_format_parquet_use_custom_encoder {#output_format_parquet_use_custom_encoder}   

<SettingsInfoBlock type="Bool" default_value="1" />

使用更快的 Parquet 编码器实现。
## output_format_parquet_version {#output_format_parquet_version}   

<SettingsInfoBlock type="ParquetVersion" default_value="2.latest" />

输出格式的 Parquet 格式版本。支持的版本：1.0、2.4、2.6 和 2.latest（默认）。
## output_format_parquet_write_bloom_filter {#output_format_parquet_write_bloom_filter}   

<SettingsInfoBlock type="Bool" default_value="1" />

在 Parquet 文件中写入布隆过滤器。需要 output_format_parquet_use_custom_encoder = true。
## output_format_parquet_write_page_index {#output_format_parquet_write_page_index}   

<SettingsInfoBlock type="Bool" default_value="1" />

在 Parquet 文件中写入列索引和偏移索引（即有关每个数据页面的统计信息，可用于读取时的过滤器下推）。
## output_format_pretty_color {#output_format_pretty_color}   

<SettingsInfoBlock type="UInt64Auto" default_value="auto" />

在 Pretty 格式中使用 ANSI 转义序列。0 - 禁用，1 - 启用，'auto' - 在终端中启用。
## output_format_pretty_display_footer_column_names {#output_format_pretty_display_footer_column_names}   

<SettingsInfoBlock type="UInt64" default_value="1" />

当表行数很多时，在页脚中显示列名。

可能的值：

- 0 — 页脚中不显示列名。
- 1 — 如果行数大于或等于由 [output_format_pretty_display_footer_column_names_min_rows](#output_format_pretty_display_footer_column_names_min_rows) 设置的阈值（默认 50），则在页脚中显示列名。

**示例**

查询：

```sql
SELECT *, toTypeName(*) FROM (SELECT * FROM system.numbers LIMIT 1000);
```

结果：

```response
      ┌─number─┬─toTypeName(number)─┐
   1. │      0 │ UInt64             │
   2. │      1 │ UInt64             │
   3. │      2 │ UInt64             │
   ...
 999. │    998 │ UInt64             │
1000. │    999 │ UInt64             │
      └─number─┴─toTypeName(number)─┘
```
## output_format_pretty_display_footer_column_names_min_rows {#output_format_pretty_display_footer_column_names_min_rows}   

<SettingsInfoBlock type="UInt64" default_value="50" />

设置在启用 [output_format_pretty_display_footer_column_names](#output_format_pretty_display_footer_column_names) 的情况下，显示包含列名的页脚的最小行数。
## output_format_pretty_fallback_to_vertical {#output_format_pretty_fallback_to_vertical}   

<SettingsInfoBlock type="Bool" default_value="1" />

如果启用且表宽但短，Pretty 格式将像纵向格式那样输出。
有关此行为的详细调优，请参见 `output_format_pretty_fallback_to_vertical_max_rows_per_chunk` 和 `output_format_pretty_fallback_to_vertical_min_table_width`。
## output_format_pretty_fallback_to_vertical_max_rows_per_chunk {#output_format_pretty_fallback_to_vertical_max_rows_per_chunk}   

<SettingsInfoBlock type="UInt64" default_value="10" />

仅在块中的记录数不超过指定值时，才会激活纵向格式的回退（请参见 `output_format_pretty_fallback_to_vertical`）。
## output_format_pretty_fallback_to_vertical_min_columns {#output_format_pretty_fallback_to_vertical_min_columns}   

<SettingsInfoBlock type="UInt64" default_value="5" />

仅在列数大于指定值时，才会激活纵向格式的回退（请参见 `output_format_pretty_fallback_to_vertical`）。
## output_format_pretty_fallback_to_vertical_min_table_width {#output_format_pretty_fallback_to_vertical_min_table_width}   

<SettingsInfoBlock type="UInt64" default_value="250" />

仅在表中列的长度总和至少为指定值，或至少有一个值包含换行符时，才会激活纵向格式的回退（请参见 `output_format_pretty_fallback_to_vertical`）。
## output_format_pretty_glue_chunks {#output_format_pretty_glue_chunks}   

<SettingsInfoBlock type="UInt64Auto" default_value="auto" />

如果以 Pretty 格式渲染的数据分为多个块，即使在延迟后，但是下一个块与之前的列宽相同，使用 ANSI 转义序列回到上一行并覆盖前一个块的页脚，以继续新块的数据。这使得结果在视觉上更加美观。

0 - 禁用，1 - 启用，'auto' - 如果是终端则启用。
## output_format_pretty_grid_charset {#output_format_pretty_grid_charset}   

<SettingsInfoBlock type="String" default_value="UTF-8" />

打印网格边框的字符集。可用的字符集：ASCII、UTF-8（默认字符集）。
## output_format_pretty_highlight_digit_groups {#output_format_pretty_highlight_digit_groups}   

<SettingsInfoBlock type="Bool" default_value="1" />

如果启用且输出为终端，则将每个与千位、百万等对应的数字加下划线高亮显示。
## output_format_pretty_highlight_trailing_spaces {#output_format_pretty_highlight_trailing_spaces}   

<SettingsInfoBlock type="Bool" default_value="1" />

如果启用且输出为终端，则使用灰色和下划线高亮显示尾随空格。
## output_format_pretty_max_column_name_width_cut_to {#output_format_pretty_max_column_name_width_cut_to}   

<SettingsInfoBlock type="UInt64" default_value="24" />

如果列名过长，则将其裁剪至该长度。
如果列名长度超过 `output_format_pretty_max_column_name_width_cut_to` 加 `output_format_pretty_max_column_name_width_min_chars_to_cut`，则会裁剪该列名。
## output_format_pretty_max_column_name_width_min_chars_to_cut {#output_format_pretty_max_column_name_width_min_chars_to_cut}   

<SettingsInfoBlock type="UInt64" default_value="4" />

如果列名过长，则裁剪的最小字符数。
如果列名长度超过 `output_format_pretty_max_column_name_width_cut_to` 加 `output_format_pretty_max_column_name_width_min_chars_to_cut`，则会裁剪该列名。
## output_format_pretty_max_column_pad_width {#output_format_pretty_max_column_pad_width}   

<SettingsInfoBlock type="UInt64" default_value="250" />

在 Pretty 格式中填充列中所有值的最大宽度。
## output_format_pretty_max_rows {#output_format_pretty_max_rows}   

<SettingsInfoBlock type="UInt64" default_value="1000" />

Pretty 格式的行数限制。
## output_format_pretty_max_value_width {#output_format_pretty_max_value_width}   

<SettingsInfoBlock type="UInt64" default_value="10000" />

在 Pretty 格式中显示的值的最大宽度。如果超出限制，则会裁剪。
值为 0 表示 - 永不裁剪。
## output_format_pretty_max_value_width_apply_for_single_value {#output_format_pretty_max_value_width_apply_for_single_value}   

<SettingsInfoBlock type="UInt64" default_value="0" />

仅在块中不是单个值时裁剪值（请参见 `output_format_pretty_max_value_width` 设置）。否则完全输出，这对 `SHOW CREATE TABLE` 查询非常有用。
## output_format_pretty_multiline_fields {#output_format_pretty_multiline_fields}   

<SettingsInfoBlock type="Bool" default_value="1" />

如果启用，Pretty 格式将在表单元格内呈现多行字段，以保留表的轮廓。
如果未启用，它们将按原样呈现，可能导致表的形状不美观（关闭它的一个好处是更容易复制粘贴多行值）。
## output_format_pretty_row_numbers {#output_format_pretty_row_numbers}   

<SettingsInfoBlock type="Bool" default_value="1" />

为 Pretty 输出格式的每一行添加行号。
## output_format_pretty_single_large_number_tip_threshold {#output_format_pretty_single_large_number_tip_threshold}   

<SettingsInfoBlock type="UInt64" default_value="1000000" />

如果块由一个超过该值的单个数字组成（不包括 0），则在表的右侧打印可读的数字提示。
## output_format_pretty_squash_consecutive_ms {#output_format_pretty_squash_consecutive_ms}   

<SettingsInfoBlock type="UInt64" default_value="50" />

等待下一个块的时间最多为指定的毫秒数，并在写入之前将其压缩到之前的块中。
这可以避免频繁输出太小的块，但仍允许以流式方式显示数据。
## output_format_pretty_squash_max_wait_ms {#output_format_pretty_squash_max_wait_ms}   

<SettingsInfoBlock type="UInt64" default_value="1000" />

如果自上一次输出以来已超过指定的毫秒数，则以 Pretty 格式输出待处理块。
## output_format_protobuf_nullables_with_google_wrappers {#output_format_protobuf_nullables_with_google_wrappers}   

<SettingsInfoBlock type="Bool" default_value="0" />

在使用 Google 包装器序列化 Nullable 列时，将默认值序列化为空包装器。如果关闭，则不序列化默认值和空值。
## output_format_schema {#output_format_schema}   

生成的架构将保存到 [Cap'n Proto](/interfaces/formats/CapnProto) 或 [Protobuf](/interfaces/formats/Protobuf) 格式的文件路径。
## output_format_sql_insert_include_column_names {#output_format_sql_insert_include_column_names}   

在 INSERT 查询中包含列名。
## output_format_sql_insert_max_batch_size {#output_format_sql_insert_max_batch_size}   

单个 INSERT 语句中的最大行数。
## output_format_sql_insert_quote_names {#output_format_sql_insert_quote_names}   

用 '`' 字符引用列名。
## output_format_sql_insert_table_name {#output_format_sql_insert_table_name}   

输出 INSERT 查询中的表名。
## output_format_sql_insert_use_replace {#output_format_sql_insert_use_replace}   

使用 REPLACE 语句而不是 INSERT。
## output_format_tsv_crlf_end_of_line {#output_format_tsv_crlf_end_of_line}   

如果设置为 true，则 TSV 格式的行结束符为 \\r\\n，而不是 \\n。
## output_format_values_escape_quote_with_quote {#output_format_values_escape_quote_with_quote}   

如果为 true，则用 '' 转义 '，否则用 \\' 引号。
## output_format_write_statistics {#output_format_write_statistics}   

以适当的输出格式写入有关读取行、字节、经过时间的统计信息。

默认启用。
## precise_float_parsing {#precise_float_parsing}   

优先使用更精确（但更慢）的浮点解析算法。
## regexp_dict_allow_hyperscan {#regexp_dict_allow_hyperscan}   

允许 regexp_tree 字典使用 Hyperscan 库。
## regexp_dict_flag_case_insensitive {#regexp_dict_flag_case_insensitive}   

对 regexp_tree 字典使用不区分大小写的匹配。可以在单独的表达式中用 (?i) 和 (?-i) 重写。
## regexp_dict_flag_dotall {#regexp_dict_flag_dotall}   

允许 '.' 匹配换行符，适用于 regexp_tree 字典。
## rows_before_aggregation {#rows_before_aggregation}   

启用时，ClickHouse 将提供确切的 rows_before_aggregation 统计信息，表示聚合之前读取的行数。
## schema_inference_hints {#schema_inference_hints}   

在没有架构的格式中用于提示架构推断的列名和类型列表。

示例：

查询：
```sql
desc format(JSONEachRow, '{"x" : 1, "y" : "String", "z" : "0.0.0.0" }') settings schema_inference_hints='x UInt8, z IPv4';
```

结果：
```sql
x   UInt8
y   Nullable(String)
z   IPv4
```

:::note
如果 `schema_inference_hints` 格式不正确，或者有错字或错误的数据类型等，整个 schema_inference_hints 将被忽略。
:::
## schema_inference_make_columns_nullable {#schema_inference_make_columns_nullable}   

<SettingsInfoBlock type="UInt64Auto" default_value="3" />

控制在架构推断中将推断类型设置为 `Nullable`。
可能的值：
 * 0 - 推断的类型将永远不会是 `Nullable`（使用 input_format_null_as_default 控制在这种情况下如何处理空值），
 * 1 - 所有推断的类型将是 `Nullable`，
 * 2 或 `auto` - 仅当列在解析时的样本中包含 `NULL`，或文件元数据包含有关列空值的信息时，推断的类型才会是 `Nullable`，
 * 3 - 如果格式具有文件元数据，则推断的类型的空值将匹配文件元数据（例如 Parquet）；否则始终为 Nullable（例如 CSV）。
## schema_inference_make_json_columns_nullable {#schema_inference_make_json_columns_nullable}   

<SettingsInfoBlock type="Bool" default_value="0" />

控制在架构推断中将推断的 JSON 类型设置为 `Nullable`。
如果此设置与 schema_inference_make_columns_nullable 一起启用，推断的 JSON 类型将为 `Nullable`。
## schema_inference_mode {#schema_inference_mode}   

<SettingsInfoBlock type="SchemaInferenceMode" default_value="default" />

架构推断的模式。'default' - 假设所有文件具有相同的架构，架构可以从任何文件推断；'union' - 文件可以具有不同的架构，结果架构应是所有文件架构的并集。
## show_create_query_identifier_quoting_rule {#show_create_query_identifier_quoting_rule}   

<SettingsInfoBlock type="IdentifierQuotingRule" default_value="when_necessary" />

设置 SHOW CREATE 查询中标识符的引号规则。
## show_create_query_identifier_quoting_style {#show_create_query_identifier_quoting_style}   

<SettingsInfoBlock type="IdentifierQuotingStyle" default_value="Backticks" />

设置 SHOW CREATE 查询中标识符的引号样式。
## type_json_skip_duplicated_paths {#type_json_skip_duplicated_paths}   

<SettingsInfoBlock type="Bool" default_value="0" />

启用后，在将 JSON 对象解析为 JSON 类型时，将忽略重复路径，仅插入第一个而不是引发异常。
## validate_experimental_and_suspicious_types_inside_nested_types {#validate_experimental_and_suspicious_types_inside_nested_types}   

<SettingsInfoBlock type="Bool" default_value="1" />

验证在嵌套类型（如 Array/Map/Tuple）内部使用实验性和可疑类型的情况。

---
date: 2023-05-02
title: TTL 规则何时被应用，我们是否能控制其执行时机？
description: ClickHouse 中的 TTL 规则最终都会被执行，并且你可以使用 `merge_with_ttl_timeout` 设置来控制它们的执行时间。了解如何强制应用 TTL 并管理用于执行 TTL 的后台线程。
tags: ['核心数据概念']
keywords: ['TTL']
---

{frontMatter.description}

{/* 截断 */}

## TTL 规则与控制 \{#ttl-rules-and-control\}

TTL 规则&#x662F;***最终***&#x624D;会生效的。这是什么意思？`MergeTree` 表设置 [`merge_with_ttl_timeout`](https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree#merge_with_ttl_timeout) 用于设置在包含 delete TTL 的合并操作再次执行前的最小延迟时间（以秒为单位）。默认值为 14400 秒（4 小时）。但这只是最小延迟，在实际触发 delete TTL 合并之前，可能需要更长时间。

可以通过以下查询查看当前所有 TTL 设置（例如 `merge_with_ttl_timeout`）：

```sql
SELECT *
FROM system.merge_tree_settings
WHERE name like '%ttl%'
```

响应如下：

```response
┌─name───────────────────────────────────────────────────────────┬─value───┬─changed─┬─description────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬─min──┬─max──┬─readonly─┬─type───┐
│ max_replicated_merges_with_ttl_in_queue                        │ 1       │       0 │ ReplicatedMergeTree 队列中允许同时执行的带 TTL 数据分片合并任务数量。                                                                                          │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ max_number_of_merges_with_ttl_in_pool                          │ 2       │       0 │ 当池中带 TTL 条目的合并任务数量超过指定值时,不再分配新的带 TTL 的合并任务。此设置用于为常规合并保留空闲线程,避免出现"分片过多"问题 │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ merge_tree_clear_old_broken_detached_parts_ttl_timeout_seconds │ 2592000 │       1 │ 如果旧的损坏分离分片在此设置指定的时间段内未被触碰,则在后台将其删除。                                                              │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ merge_with_ttl_timeout                                         │ 14400   │       0 │ 带删除 TTL 的合并可重复执行的最小时间间隔(秒)。                                                                                                                       │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Int64  │
│ merge_with_recompression_ttl_timeout                           │ 14400   │       0 │ 带重新压缩 TTL 的合并可重复执行的最小时间间隔(秒)。                                                                                                                │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Int64  │
│ ttl_only_drop_parts                                            │ 0       │       0 │ 仅完全删除过期的数据分片,不进行部分清理。                                                                                                                       │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Bool   │
│ materialize_ttl_recalculate_only                               │ 0       │       0 │ 仅在执行 MATERIALIZE TTL 时重新计算 TTL 信息                                                                                                                                             │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Bool   │
└────────────────────────────────────────────────────────────────┴─────────┴─────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────┴──────┴──────────┴────────┘
```

可以使用 `SHOW CREATE TABLE` 命令检查表是否包含 TTL 规则，以及是否有任何表级 `SETTINGS` 修改了上述设置的值：

```sql
SHOW CREATE TABLE <TableName>
```

## 强制应用 TTL 规则 \{#force-a-ttl-rule-to-be-applied\}

这并不是最优雅的解决方案，但你可以显式执行 `MATERIALIZE TTL`，它会强制将表的所有 TTL 规则物化生效：

```sql
ALTER TABLE my_table
    MATERIALIZE TTL
```

## 影响 TTL 的后台线程 \{#background-threads-affecting-ttl\}

TTL 规则可能没有生效，是因为后台线程池中没有足够的工作线程。例如，如果写入数据非常频繁，整个后台线程池可能都会被常规合并操作占满。不过，可以通过调整参数来增大后台线程池的大小。

可以通过以下查询检查当前的后台线程池大小：

```sql
SELECT *
FROM system.settings
WHERE name = 'background_pool_size';
```

响应类似如下：

```response
┌─name─────────────────┬─value─┬─changed─┬─description─────────────────────┬─min──┬─max──┬─readonly─┬─type───┬─default─┬─alias_for─┐
│ background_pool_size │ 16    │       0 │ 已废弃的设置,无任何作用。 │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │ 16      │           │
└──────────────────────┴───────┴─────────┴─────────────────────────────────┴──────┴──────┴──────────┴────────┴─────────┴───────────┘
```

请查看文档，了解如何修改 [`background_pool_size` 设置](https://clickhouse.com/docs/operations/server-configuration-parameters/settings#background_pool_size)，其配置如下：

```xml
<background_pool_size>16</background_pool_size>
```

可以通过以下查询查看当前后台池的活动情况：

```sql
SELECT *
FROM system.metrics
WHERE metric like 'Background%'
```

---
date: 2025-07-20
title: "OPTIMIZE FINAL 与 FINAL 有何不同？"
tags: ['核心数据概念']
keywords: ['OPTIMIZE FINAL', 'FINAL']
description: "讨论 OPTIMIZE FINAL 与 FINAL 之间的区别，以及在何时应当使用或避免它们。"
---

{frontMatter.description}

{/* 截断 */}


# `OPTIMIZE FINAL` 和 `FINAL` 之间有什么区别？

`OPTIMIZE FINAL` 是一个 DDL 命令，会在磁盘上对数据进行物理且永久的重组和优化。它会对 `MergeTree` 表中的数据片段进行物理合并，并在此过程中通过从存储中移除重复行来执行数据去重。

`FINAL` 是一个**查询阶段（query-time）**修饰符，它在不改变已存储数据结构的情况下，返回去重后的结果。它的工作方式是在读取时执行合并逻辑。其效果是临时的，仅影响当前查询结果。

通常会建议用户避免使用 `OPTIMIZE FINAL`，因为它会带来显著的性能开销，但同时不应将两者混淆。为了获得无重复的查询结果，经常有必要使用 `FINAL`，尤其是在使用诸如 `ReplacingMergeTree` 之类的表引擎时，这类表中可能包含尚未在最终后台合并过程中被替换掉的重复行。

下表总结了关键差异：

|Aspect	           |`OPTIMIZE FINAL`                            | `FINAL`                                            |
|------------------|--------------------------------------------|----------------------------------------------------|
|Type              | DDL 命令                                   | 查询修饰符                                         |
|Effect            | 持久的存储优化	                            | 临时的查询阶段去重                                 |
|Performance       | 性能影响：一次性成本高，之后查询更快       | 单次成本较低，但每次查询都会重复执行               |
|Data Modification | 是 - 物理更改存储                          | 否 - 只读操作                                      |
|Use Case          | 周期性维护/优化                            | 实时去重查询                                       |

## 何时使用各自选项 \{#when-to-use-each\}

在以下场景下使用 `OPTIMIZE FINAL`：

- 你希望持久地提升查询性能
- 你可以承担一次性的优化开销
- 你在执行周期性的表维护
- 你希望在物理层面清理重复数据

在以下场景下使用 `FINAL`：

- 你需要立即获得去重后的结果
- 你无法等待或不希望进行永久性优化
- 你只是偶尔需要去重后的数据
- 你在处理频繁变更的数据

两者都是有价值的工具，但在 ClickHouse 的去重策略中承担着不同的作用。
---
title: "使用 LLVM 的 XRay 对 ClickHouse 进行性能剖析"
date: 2024-11-13
description: "了解如何使用 LLVM 的 XRay 插桩分析器对 ClickHouse 进行性能剖析、可视化跟踪并进行性能诊断。"
tags: ['性能与优化', '工具与实用工具']
---

import Image from "@theme/IdealImage";
import clickhouse from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/profile.png'
import time_order from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/time-order.png'
import left_heavy from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/left-heavy.png'
import sandwich from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/sandwich.png'

{frontMatter.description}

{/* 截断 */}

## 分析器的类型 \{#types-of-profilers\}

LLVM 已经包含了一个通过对代码插桩来进行[插桩分析](https://en.wikipedia.org/wiki/Profiling_\(computer_programming\)#Instrumentation)的工具。与[采样或统计分析](https://en.wikipedia.org/wiki/Profiling_\(computer_programming\)#Statistical_profilers)相比，它在不丢失任何调用的情况下非常精确，但代价是需要对代码进行插桩，且资源开销更大。

简而言之，插桩分析器会插入新的代码来跟踪对所有函数的调用。统计分析器则允许我们在无需修改代码的情况下直接运行程序，定期获取快照以查看应用程序的状态。因此，只有在获取快照时正在运行的函数才会被统计。[perf](https://en.wikipedia.org/wiki/Perf_%28Linux%29) 是一个非常知名的统计分析器。

## 使用 XRay 集成对 ClickHouse 进行性能分析 \{#profiling-clickhouse-using-xray-integration\}

在 ClickHouse 25.12 中，XRay 已经集成进来，可用于无缝地为函数添加新的插桩点。
因此，任何正式发行版都已经带有此特性，可以按需触发，在未启用时不会
影响整体性能。原则是只启用尽可能少的插桩点即可获取有价值的信息。

我们可以使用 [SYSTEM INSTRUMENT ADD
PROFILE](https://clickhouse.com/docs/sql-reference/statements/system#instrument-add-profile)
语句添加一个新的性能分析插桩点。需要插桩的函数可以从
[system.symbols](https://clickhouse.com/docs/operations/system-tables/symbols) 系统表中获取。假设我们
想要分析 `sleepForNanoseconds` 函数的性能，这个函数对于检查运行耗时非常方便。

```sql
SYSTEM INSTRUMENT ADD `sleepForNanoseconds` PROFILE
```

然后，让它按我们需要的时间段运行以进行分析，结束后再将其停止。

```sql
SYSTEM INSTRUMENT REMOVE ALL
```

我们将 `system.trace_log` 中收集的数据[转换为 Chrome 事件跟踪格式](https://clickhouse.com/docs/operations/system-tables/trace_log#chrome-event-trace-format)，以便在 [Perfetto](https://ui.perfetto.dev) 中进行可视化。请注意查看每条记录中的 `query_id`、`cpu_id` 和 `stacktrace`。

<Image img={clickhouse} size="md" alt="time-order" />

## 使用 XRay 对原生应用程序进行性能分析 \{#profiling-a-native-application-using-xray\}

以下内容作为参考，帮助你了解 XRay 的底层工作机制，以及如何直接开箱即用地对原生应用程序进行性能分析。

### 对代码进行埋点 \{#instrument-the-code\}

假设有如下源代码：

```cpp
#include <chrono>
#include <cstdio>
#include <thread>

void one()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
}

void two()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(5));
}

int main()
{
    printf("Start\n");

    for (int i = 0; i < 10; ++i)
    {
        one();
        two();
    }

    printf("Finish\n");
}
```

要接入 XRay 进行埋点，我们需要按如下方式添加一些标志参数：

```bash
clang++ -o test test.cpp -fxray-instrument -fxray-instruction-threshold=1
```

* `-fxray-instrument` 用于对代码进行插桩。
* `-fxray-instruction-threshold=1` 用于确保对所有函数进行插桩，即使它们像示例中那样非常小。默认情况下，它只会对[至少包含 200 条指令](https://llvm.org/docs/XRay.html#instrumenting-your-c-c-objective-c-application)的函数进行插桩。

我们可以通过检查二进制文件中是否出现了一个新的节（section），来确认代码是否已正确插桩：

```bash
objdump -h -j xray_instr_map test

test:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
 17 xray_instr_map 000005c0  000000000002f91c  000000000002f91c  0002f91c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
```

### 使用正确的环境变量值运行进程以收集 trace \{#run-the-process-with-proper-env-var-values-to-collect-the-trace\}

默认情况下，除非显式启用，否则不会进行任何 profiler 数据收集。换句话说，如果不进行 profiling，其开销可以忽略不计。我们可以通过为 `XRAY_OPTIONS` 设置不同的值，来配置 profiler 何时开始收集以及具体的收集方式。

```bash
XRAY_OPTIONS="patch_premain=true xray_mode=xray-basic verbosity=1" ./test
==74394==XRay: Log file in 'xray-log.test.14imlN'
开始
完成
==74394==Cleaned up log for TID: 74394
```

### 转换 trace \{#convert-the-trace\}

XRay 的 trace 可以转换为多种格式。`trace_event` 格式非常实用，因为它易于解析，且已经有许多工具支持，因此我们将在这里使用这种格式：

```bash
llvm-xray convert --symbolize --instr_map=./test --output-format=trace_event xray-log.test.14imlN | gzip > test-trace.txt.gz
```

### 可视化 trace \{#visualize-the-trace\}

我们可以使用基于 Web 的 UI，例如 [speedscope.app](https://www.speedscope.app/) 或
[Perfetto](https://ui.perfetto.dev)。

Perfetto 在可视化多线程和查询数据方面更有优势，而 speedscope 更适合为你的数据生成 flamegraph 和 sandwich 视图。

#### 时间顺序 \{#time-order\}

<Image img={time_order} size="md" alt="时间顺序" />

#### 左侧为主 \{#left-heavy\}

<Image img={left_heavy} size="md" alt="左侧为主" />

#### 三明治 \{#sandwitch\}

<Image img={sandwich} size="md" alt="三明治" />

## 查看文档 \{#check-out-the-docs\}

* [SYSTEM INSTRUMENT](https://clickhouse.com/docs/sql-reference/statements/system#instrument) — 添加
  或删除插桩点。
* [system.instrumentation](https://clickhouse.com/docs/operations/system-tables/instrumentation)
  — 查看已插桩的位置。
* [system.symbols](https://clickhouse.com/docs/operations/system-tables/symbols) — 查看
  用于添加插桩点的符号。
* [system.trace&#95;log](https://clickhouse.com/docs/operations/system-tables/trace_log) — 查看通过插桩点
  收集的数据。
* [XRay Instrumentation](https://llvm.org/docs/XRay.html)
* [Debugging with XRay](https://llvm.org/docs/XRayExample.html) 文档，了解更多详细信息。
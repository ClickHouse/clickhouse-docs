---
title: 我可以把 ClickHouse 用作键值存储吗？
description: "简短的回答是：**「不行」**。键值型工作负载是**不应**使用 ClickHouse 的典型场景之一。"
date: 2021-09-01
tags: ['概念', '使用场景']
keywords: ['键值存储']
---

{frontMatter.description}

{/* 截断 */}

## 简短的回答是「不」 \{#the-short-answer-is-no\}

简短的回答是 **「不」**。键值型负载在「<span class="text-danger">**不要**</span> 使用 ClickHouse」的场景列表中名列前茅。毕竟它是一个 [OLAP](https://clickhouse.com/docs/faq/general/olap) 系统，而市面上已经有很多优秀的键值存储系统。

不过，在某些情况下，在键值风格的查询中使用 ClickHouse 仍然是有意义的。通常，这是一些预算有限的产品，其主要负载是分析型的，非常适合 ClickHouse，但同时还存在某个次要流程需要键值模式，而且请求吞吐量不高，也没有严格的延迟要求。如果预算无限，你会为这类次要负载部署一个独立的键值数据库，但在现实中，引入一个新的存储系统会带来额外的运维成本（监控、备份等），这是人们往往希望避免的。

如果你决定违背上述建议，在 ClickHouse 上跑一些类似键值的查询，下面是一些提示：

* 在 ClickHouse 中，点查询昂贵的关键原因是主要的 [MergeTree table engine family](https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree) 使用稀疏主键索引。该索引无法精确定位到每一行数据，而是只指向每隔 N 行中的一行，系统必须从相邻的第 N 行开始扫描直到目标行，在此过程中会多读大量数据。在键值场景中，可以考虑通过 `index_granularity` 设置来减小 N 的值。
* ClickHouse 将每一列存放在一组单独的文件中，因此要组装出一整行数据，就需要遍历所有这些列文件。列文件的数量会随着列数线性增加，所以在键值场景下，可能值得避免使用大量列，而是将所有负载数据放进单个 `String` 列中，并用某种序列化格式（例如 JSON、Protobuf 或其他合适的格式）进行编码。
* 还有一种替代方案是使用 [Join](https://clickhouse.com/docs/engines/table-engines/special/join) 表引擎代替普通的 `MergeTree` 表，并通过 [joinGet](https://clickhouse.com/docs/sql-reference/functions/other-functions/#joinget) 函数来读取数据。这种方式可以带来更好的查询性能，但在易用性和可靠性方面可能存在一些问题。这里有一个[使用示例](https://github.com/ClickHouse/ClickHouse/blob/master/tests/queries/0_stateless/00800_versatile_storage_join.sql#L49-L51)。
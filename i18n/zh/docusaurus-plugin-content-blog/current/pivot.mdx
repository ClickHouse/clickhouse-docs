---
title: 在 ClickHouse 中可以使用 PIVOT 吗？
description: "ClickHouse 没有 PIVOT 子句，但我们可以通过聚合函数组合器来实现类似的功能。下面来看一下如何使用英国房价数据集来实现这一点。"
date: 2024-12-11
tags: ['数据建模', '核心数据概念']
keywords: ['PIVOT', '聚合函数组合器']
---

{frontMatter.description}

{/* 截断 */}

## 简介 \{#introduction\}

ClickHouse 没有透视（pivot）运算符，但我们可以通过使用[聚合函数组合器](/sql-reference/aggregate-functions/combinators)，尤其是带有 [`-Map` 后缀](/sql-reference/aggregate-functions/combinators#-map)的组合器，实现类似的效果。

本文将介绍如何实现这一点。
下面还有一个视频，对相同内容进行了讲解：

<iframe width="560" height="315" src="https://www.youtube.com/embed/nlRMOmwYtF4?si=0TZSNg-uo7zjiO52" title="YouTube 视频播放器" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen />

## 理解聚合函数组合器 \{#understanding-aggregate-function-combinators\}

先从一个简单的示例开始。我们将使用 [clickhouse-local](/operations/utilities/clickhouse-local)，可以通过运行以下命令来启动：

```bash
clickhouse -m --output_format_pretty_row_numbers=0
```

下面的查询调用了 `sumMap` 函数，该函数接受一个 map，并对每个键对应的值求和：

```sql
SELECT sumMap(map('ClickHouse', 1, 'ClickBench', 2));
```

```text
┌─sumMap(map('ClickHouse', 1, 'ClickBench', 2))─┐
│ {'ClickBench':2,'ClickHouse':1}               │
└───────────────────────────────────────────────┘
```

这个例子本身并不算特别有趣，因为它只是返回了我们传入的同一个 map。
现在让我们在多行 map 数据上调用 `sumMap`。

```sql
WITH values AS (
  SELECT map('ClickHouse', 3) AS value
  UNION ALL
  SELECT map('ClickBench', 2, 'ClickHouse', 4) AS value
)
SELECT sumMap(value)
FROM values;
```

```text
┌─sumMap(value)───────────────────┐
│ {'ClickBench':2,'ClickHouse':7} │
└─────────────────────────────────┘
```

键 `ClickHouse` 在两行中都出现了，因此其对应的值被相加。键 `ClickBench` 只出现在一行中，所以只对单个值求和，结果就是该值本身！

我们也可以使用 `maxMap` 来按键查找最大值：

```sql
WITH values AS (
  SELECT map('ClickHouse', 3) AS value
  UNION ALL
  SELECT map('ClickBench', 2, 'ClickHouse', 4) AS value
)
SELECT maxMap(value)
FROM values;
```

```text
┌─maxMap(value)───────────────────┐
│ {'ClickBench':2,'ClickHouse':4} │
└─────────────────────────────────┘
```

或者我们可以使用 `avgMap` 来计算每个键对应的平均值：

```sql
WITH values AS (
  SELECT map('ClickHouse', 3) AS value
  UNION ALL
  SELECT map('ClickBench', 2, 'ClickHouse', 4) AS value
)
SELECT avgMap(value)
FROM values;
```

```text
┌─avgMap(value)─────────────────────┐
│ {'ClickBench':2,'ClickHouse':3.5} │
└───────────────────────────────────┘
```

希望通过上面的内容，你已经大致了解这些函数组合子的工作方式。

## 实战应用：英国房价数据集 \{#real-world-application-uk-housing-prices-dataset\}

现在我们将在 [ClickHouse SQL Playground](https://clickhouse.com/blog/announcing-the-new-sql-playground) 中，将它们应用到一个更大的数据集上。

我们可以使用 clickhouse-client 连接到 Playground：

```bash
clickhouse client -m \
  -h sql-clickhouse.clickhouse.com \
  -u demo \
  --secure
```

接下来我们要查询 `uk_price_paid` 表，先来看一下该表中的数据：

```sql
SELECT * FROM uk.uk_price_paid LIMIT 1 FORMAT Vertical;
```

```text
第 1 行：
──────
价格：     145000
日期：      2008-11-19
邮编1：
邮编2：
类型：      半独立式
是否新建：    0
产权期限：  租赁
地址1：
地址2：
街道：    CURLEW DRIVE
地区：  SCARBOROUGH
城镇：      SCARBOROUGH
区域：  SCARBOROUGH
郡：    NORTH YORKSHIRE
类别：  0
```

从上面可以看出，上表包含了与英国房产销售相关的各类字段。

### 按十年分组并聚合 \{#grouping-and-aggregating-by-decade\}

让我们计算一下数据集中每个郡在各个十年期的价格中位数：

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    medianMap(map(year, price)) AS medianPrices
FROM uk.uk_price_paid
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10;
```

```text
    ┌─county─────────────┬─medianPrices───────────────────────────────────────┐
 1. │ GREATER LONDON     │ {1990:89972.5,2000:215000,2010:381500,2020:485000} │
 2. │ TYNE AND WEAR      │ {1990:46500,2000:93000,2010:130000,2020:139000}    │
 3. │ WEST MIDLANDS      │ {1990:50000,2000:110000,2010:149950,2020:185000}   │
 4. │ GREATER MANCHESTER │ {1990:47000,2000:97000,2010:141171,2020:178000}    │
 5. │ MERSEYSIDE         │ {1990:46750,2000:94972.5,2010:128000,2020:149000}  │
 6. │ HERTFORDSHIRE      │ {1990:86500,2000:193000,2010:315000,2020:415000}   │
 7. │ WEST YORKSHIRE     │ {1990:48995,2000:99950,2010:139000,2020:164950}    │
 8. │ BRIGHTON AND HOVE  │ {1990:70000,2000:173000,2010:288000,2020:387000}   │
 9. │ DORSET             │ {1990:76500,2000:182000,2010:250000,2020:315000}   │
10. │ HAMPSHIRE          │ {1990:79950,2000:177500,2010:260000,2020:335000}   │
    └────────────────────┴────────────────────────────────────────────────────┘
```

### 过滤结果 \{#filtering-results\}

我们可以过滤结果，只包含自 2010 年起的数据：

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    medianMap(map(year, price)) AS medianPrices
FROM uk.uk_price_paid
WHERE year >= 2010
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10;
```

```text
    ┌─county─────────────┬─medianPrices────────────────┐
 1. │ GREATER LONDON     │ {2010:384975,2020:485919.5} │
 2. │ TYNE AND WEAR      │ {2010:130000,2020:140000}   │
 3. │ WEST MIDLANDS      │ {2010:146500,2020:185000}   │
 4. │ GREATER MANCHESTER │ {2010:140000,2020:177500}   │
 5. │ MERSEYSIDE         │ {2010:130000,2020:150000}   │
 6. │ HERTFORDSHIRE      │ {2010:315000,2020:415000}   │
 7. │ WEST YORKSHIRE     │ {2010:140000,2020:162500}   │
 8. │ BRIGHTON AND HOVE  │ {2010:287500,2020:387000}   │
 9. │ DORSET             │ {2010:255750,2020:315000}   │
10. │ HAMPSHIRE          │ {2010:265000,2020:330000}   │
    └────────────────────┴─────────────────────────────┘
```

## 组合多个聚合操作 \{#combining-multiple-aggregations\}

如果我们想要按十年为单位求出最高价格，可以使用之前看到的 `maxMap` 函数来实现：

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    medianMap(map(year, price)) AS medianPrices,
    maxMap(map(year, price)) AS maxPrices
FROM uk.uk_price_paid
WHERE year >= 2010
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10;
```

```text
    ┌─county─────────────┬─medianPrices──────────────┬─maxPrices───────────────────────┐
 1. │ GREATER LONDON     │ {2010:385000,2020:485250} │ {2010:594300000,2020:630000000} │
 2. │ TYNE AND WEAR      │ {2010:130000,2020:141000} │ {2010:448300979,2020:93395000}  │
 3. │ WEST MIDLANDS      │ {2010:149000,2020:184250} │ {2010:415000000,2020:104500000} │
 4. │ GREATER MANCHESTER │ {2010:140000,2020:175000} │ {2010:107086856,2020:319186000} │
 5. │ MERSEYSIDE         │ {2010:129950,2020:150000} │ {2010:300000000,2020:93395000}  │
 6. │ HERTFORDSHIRE      │ {2010:315000,2020:415000} │ {2010:254325163,2020:93395000}  │
 7. │ WEST YORKSHIRE     │ {2010:138500,2020:165000} │ {2010:246300000,2020:109686257} │
 8. │ BRIGHTON AND HOVE  │ {2010:285000,2020:387000} │ {2010:200000000,2020:71540000}  │
 9. │ DORSET             │ {2010:250000,2020:315000} │ {2010:150000000,2020:20230000}  │
10. │ HAMPSHIRE          │ {2010:264000,2020:330000} │ {2010:150000000,2020:48482500}  │
    └────────────────────┴───────────────────────────┴─────────────────────────────────┘
```

## 将函数应用于映射值 \{#applying-functions-to-map-values\}

或者，我们可以使用 `avgMap` 来计算平均价格。
这些值有很多小数位，我们可以使用 [`mapApply`](/sql-reference/functions/tuple-map-functions#mapapply) 函数，对映射中的每个值调用 [`floor`](/sql-reference/functions/rounding-functions#floor) 函数来进行处理：

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    medianMap(map(year, price)) AS medianPrices,
    mapApply((k, v) -> (k, floor(v)), avgMap(map(year, price))) AS avgPrices
FROM uk.uk_price_paid
WHERE year >= 2010
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10;
```

```text
    ┌─县─────────────────┬─中位数价格────────────────┬─平均价格──────────────────┐
 1. │ 大伦敦             │ {2010:382000,2020:490000} │ {2010:626091,2020:807240} │
 2. │ 泰恩-威尔          │ {2010:127000,2020:140000} │ {2010:176955,2020:225770} │
 3. │ 西米德兰兹         │ {2010:148500,2020:183000} │ {2010:204128,2020:257226} │
 4. │ 大曼彻斯特         │ {2010:140000,2020:177500} │ {2010:195592,2020:251165} │
 5. │ 默西塞德           │ {2010:127995,2020:150000} │ {2010:182194,2020:206062} │
 6. │ 赫特福德郡         │ {2010:317500,2020:415000} │ {2010:414134,2020:529409} │
 7. │ 西约克郡           │ {2010:140000,2020:164500} │ {2010:185121,2020:234870} │
 8. │ 布莱顿-霍夫        │ {2010:285000,2020:387000} │ {2010:372285,2020:527184} │
 9. │ 多塞特             │ {2010:250000,2020:315000} │ {2010:305581,2020:370739} │
10. │ 汉普郡             │ {2010:265000,2020:330000} │ {2010:335945,2020:425196} │
    └────────────────────┴───────────────────────────┴───────────────────────────┘
```

## 灵活分组：郡、地区和邮政编码 \{#flexible-grouping-counties-districts-and-postcodes\}

让我们尝试按一些不同的字段进行分组。
这次我们将按郡和地区分组，计算每十年的价格中位数：

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    district,
    medianMap(map(year, price)) AS medianPrices
FROM uk.uk_price_paid
WHERE year >= 2010
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10
```

```text
    ┌─county─────────────┬─district───────────────┬─medianPrices────────────────┐
 1. │ GREATER LONDON     │ CROYDON                │ {2010:298475,2020:400000}   │
 2. │ GREATER LONDON     │ CITY OF WESTMINSTER    │ {2010:800000,2020:935000}   │
 3. │ GREATER LONDON     │ SOUTHWARK              │ {2010:437000,2020:540000}   │
 4. │ TYNE AND WEAR      │ NEWCASTLE UPON TYNE    │ {2010:144000,2020:162500}   │
 5. │ WEST MIDLANDS      │ WALSALL                │ {2010:137450,2020:162000}   │
 6. │ GREATER LONDON     │ CITY OF LONDON         │ {2010:725875,2020:840000}   │
 7. │ GREATER LONDON     │ HILLINGDON             │ {2010:329125,2020:439000}   │
 8. │ GREATER MANCHESTER │ MANCHESTER             │ {2010:144972.5,2020:190000} │
 9. │ GREATER LONDON     │ HAMMERSMITH AND FULHAM │ {2010:622250,2020:750000}   │
10. │ GREATER LONDON     │ ISLINGTON              │ {2010:500000,2020:640000}   │
    └────────────────────┴────────────────────────┴─────────────────────────────┘
```

我们也可以选择按年份分组，然后在 map 中将 `postcode1` 和 `postcode2` 拼接起来：

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    year,
    medianMap(map(postcode1 || ' ' || postcode2, price)) AS medianPrices
FROM uk.uk_price_paid
WHERE postcode1 LIKE 'NP1'
GROUP BY ALL;
```

```text
   ┌─year─┬─medianPrices────────────────────────────────────────────────────────┐
1. │ 1990 │ {'NP1 4PB':9000}                                                    │
2. │ 2000 │ {'NP1 4SR':28475,'NP1 7HZ':200000}                                  │
3. │ 2010 │ {'NP1 4PB':5000,'NP1 4QJ':1075000,'NP1 4SR':58000,'NP1 8BR':200000} │
4. │ 2020 │ {'NP1 5DW':140000}                                                  │
   └──────┴─────────────────────────────────────────────────────────────────────┘
```

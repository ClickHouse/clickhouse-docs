---
title: ClickHouse における基本データ型の最適化に関するヒントとテクニック
description: "ClickHouse における基本データ型の最適化に関するヒントとテクニック"
date: 2024-07-02
tags: ['パフォーマンスと最適化']
keywords: ['基本データ型の最適化']
---

{frontMatter.description}

{/* 省略 */}


## 質問 \{#question\}

クエリの速度とストレージ使用量を最適化するために、ClickHouse ではどのデータ型を使用すればよいですか？

## Answer

他のシステムからの自動変換を使う場合やデータ型を選択しようとする場合、多くのユーザーはしばしば「とにかく大きいほうが良い」「楽なほうを選ぶ」「一番汎用的なものを選ぶ」といったアプローチを取ります。これは、数百万行から、多くても数十億行程度までの比較的小さなデータセットであれば、たいてい問題なく動作します。そのような規模で、ユーザーのクエリ応答時間の差がユースケース上わずかであれば、ほとんど気にならず、許容されるでしょう。

しかし、データ量が増加し、その差が目立つようになってくると、こうした選択は許容できなくなります。

たとえば、クエリに 50ms かかる場合と 500ms かかる場合の差は、多くのユースケース、たとえば Web UI では許容されるかもしれませんが、片方がもう一方より 10 倍遅いという事実は変わりません。フロントエンドのユーザーから見るとあまり目立たないとしてもです。

初期テーブルの例:

```
timestamp Datetime64(9),
group_id Int64,
vendor_id String,
product_id String,
category1 Int64,
code_name String,
paid_status String,
country_code String,
description String,
price Float64,
attributes Map(String, String)
```

サンプル データ:

```
3456, 0123456789, bd6087b7-6026-4974-9122-bc99faae5d84, "2024-03-01 01:00:01.000", 98, "bear", paid", "us", "corvette model car", 123.45, {"color" : "blue", "size" : "S"}
156, 0000012345, bd6087b7-6026-4974-9122-bc99faae5d84, "2024-03-01 01:00:02:123", 45, "tiger", "not paid", "uk", "electric car", 53432.10, {"color" : "red", "model" : "X"} 
...
```

以下は、このデータを最適化できるポイントに関するいくつかの推奨事項です:

`timestamp : DateTime64(9)`\
科学計測レベルの精度が不要であれば、9 桁精度（ナノ秒）はまず不要です。表示や並び替えの用途であればありえますが、検索用クエリや主キーなどでは通常そこまでの精度は使いません。

* **推奨:**\
  PK 用:  DateTime で ORDER BY\
  表示や並び替え用: 追加のカラムを用意 - 例: `timestamp_microseconds : DateTime64(6)`

`group_id : Int64`\
これは整数に見えるため、そのカラムで扱う最大値を格納できる、最小の整数型を選択します。このサンプルデータセットとカラム名からすると、10 の 18 乗（quintillion）までの値は不要と思われ、おそらく最大でも 16k 程度なので Int16 で十分と考えられます。

* **推奨**: Int16

`vendor_id : String`\
このカラムは数値のように見えますが先頭にゼロが付いており、フォーマットを保持することが重要な値だと考えられます。また、文字数も一定の長さに収まっていそうです。

* **推奨**: FixedString(10)

`product_id : String`\
これは英数字で、一見すると文字列として扱うのが直感的ですが、UUID でもあります。

* **推奨**: UUID

`category1 : Int64`\
値は小さく、カテゴリの種類はそれほど多くなく、今後も大きく増える予定はないか、上限が決まっていそうです。255 未満です。

* **推奨**: UInt8

`code_name : String`\
このフィールドは、使用される文字列の種類が限られていそうです。\
文字列値の種類が数百〜数千程度に収まりそうな場合、LowCardinality 型のフィールドにすると有利です。

* **推奨**: LowCardinality(String)

`paid_status : String`\
文字列の値は &quot;paid&quot; または &quot;not&#95;paid&quot; の 2 種類のみです。このように値が 2 種類しかない場合は、boolean を使用します。

* **推奨**: Bool

`country_code : String`\
一つのカラムが複数の最適化条件を満たす場合があります。この例では、国コードの種類は限られており、すべて 2 文字の識別子です。

* **推奨**: LowCardinality(FixedString(2))

`price : Float64`\
固定された精度が分かっている場合、とくに金融データや計算では Float 型は推奨されません。必要な精度に応じて Decimal 型を使用するのが最適です。このユースケースでは、商品の価格は 999,999.00 を超えない想定です。

* **推奨**: Decimal(10,2)


`attributes : map`  
動的な属性を `Map` 型で保持しているテーブルがあることはよくあります。キーや値での検索は通常、遅くなりがちです。`Map` を高速化する方法はいくつかあります。ほとんどのレコードに存在するキーがある場合、それらは別の列に切り出して低カーディナリティとして定義し、まれにしか現れないものは別の列で高カーディナリティとして定義するのが最適です。こうすることで、クエリは複雑になる可能性がありますが、スキップインデックスをより効率的に作成できます。

- **推奨構成:** lc_attributes: Map(String, String), hc_attributes: Map(String, String)。  

クエリ内容に応じて、スキップインデックスの作成や属性の抽出に使用できるオプションとして、以下があります。  
Array Join を使用して、マテリアライズドビュー経由で列に展開する方法:  
https://clickhouse.com/docs/knowledgebase/using-array-join-to-extract-and-query-attributes  
キーに対してスキップインデックスを使用する方法:  
https://clickhouse.com/docs/knowledgebase/improve-map-performance
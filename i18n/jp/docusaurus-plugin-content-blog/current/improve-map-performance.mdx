---
title: ClickHouse における Map 参照パフォーマンスの向上
description: ClickHouse のクエリ性能を高めるために、特定のキーを個別の列としてマテリアライズし、Map 列の参照を最適化する方法を学びます。
date: 2022-10-30
tags: ['パフォーマンスと最適化']
keywords: ['Map パフォーマンス']
---

{frontMatter.description}

{/* 省略 */}

## 問題 \{#problem\}

`a['key']` のような Map のルックアップは計算量が線形時間オーダーであり（[こちら](https://clickhouse.com/docs/sql-reference/data-types/map)で説明されています）、非効率になる場合があります。これは、テーブルから特定のキーに対応する値を取得するには、Map 列内の全行 (N) にわたって各行のすべてのキー (~M) を走査する必要があり、その結果として ~M×N 回のルックアップが発生するためです。

Map を使ったルックアップは、String 型の列に対するルックアップと比べて最大 10 倍遅くなる可能性があります。以下の実験では、コールドクエリでも約 10 倍の低速化が確認され、処理されたデータ量にも桁違いの差（7.21 MB と 5.65 GB）があります。

```sql
-- SpanNameをString型、ResourceAttributesをMap型としてテーブルを作成
DROP TABLE IF EXISTS tbl;
CREATE TABLE tbl (
    `Timestamp` DateTime64(9) CODEC (Delta(8), ZSTD(1)),
    `TraceId` String CODEC (ZSTD(1)),
    `ServiceName` LowCardinality(String) CODEC (ZSTD(1)),
    `Duration` UInt8 CODEC (ZSTD(1)), -- Int64
    `SpanName` LowCardinality(String) CODEC (ZSTD(1)),
    `ResourceAttributes` Map(LowCardinality(String), String) CODEC (ZSTD(1))
)
ENGINE = MergeTree
PARTITION BY toDate(Timestamp)
ORDER BY (ServiceName, SpanName, toUnixTimestamp(Timestamp), TraceId);

-- ResourceAttributes用のランダムなMapデータを生成するUDFを作成
DROP FUNCTION IF EXISTS genmap;
CREATE FUNCTION genmap AS (n) -> arrayMap (x-> (x::String, (x*rand32())::String), range(1, n));

-- genmapが意図通りに動作することを確認
SELECT genmap(10)::Map(String, String);

-- 100万行を挿入
INSERT INTO tbl
SELECT
    now() - randUniform(1, 1000000.) as Timestamp,
    randomPrintableASCII(2) as TraceId,
    randomPrintableASCII(2) as ServiceName,
    rand32() as Duration,
    randomPrintableASCII(2) as SpanName,
    genmap(rand64()%500)::Map(String, String) as ResourceAttributes
FROM numbers(1_000_000);

-- SpanNameに対するクエリの方が高速
-- [cold] 0 rows in set. Elapsed: 0.642 sec. Processed 1.00 million rows, 7.21 MB (1.56 million rows/s., 11.22 MB/s.)
-- [warm] 0 rows in set. Elapsed: 0.164 sec. Processed 1.00 million rows, 7.21 MB (6.10 million rows/s., 43.99 MB/s.)
SELECT
    COUNT(*),
    avg(Duration/1E6) as average,
    quantile(0.95)(Duration/1E6) as p95,
    quantile(0.99)(Duration/1E6) as p99,
    SpanName
FROM tbl
GROUP BY SpanName ORDER BY 1 DESC LIMIT 50 FORMAT Null;

-- ResourceAttributesに対するクエリの方が低速
-- [cold] 0 rows in set. Elapsed: 6.432 sec. Processed 1.00 million rows, 5.65 GB (155.46 thousand rows/s., 879.07 MB/s.)
-- [warm] 0 rows in set. Elapsed: 5.935 sec. Processed 1.00 million rows, 5.65 GB (168.50 thousand rows/s., 952.81 MB/s.)
SELECT
    COUNT(*),
    avg(Duration/1E6) as average,
    quantile(0.95)(Duration/1E6) as p95,
    quantile(0.99)(Duration/1E6) as p99,
    ResourceAttributes['1'] as hostname
FROM tbl
GROUP BY hostname ORDER BY 1 DESC LIMIT 50 FORMAT Null;
```

**解決策**
クエリを改善するために、`Map` 列内の特定のキーの値をデフォルト値とする新しい列を追加し、その後、既存行の値を埋めるためにそれを `MATERIALIZE` します。こうすることで、挿入時に必要な値を抽出して保存できるため、クエリ時のルックアップが高速になります。

```sql
-- 解決策は、Map内の特定のキーをデフォルト値とする列を追加すること
ALTER TABLE tbl ADD COLUMN hostname LowCardinality(String) DEFAULT ResourceAttributes['1'];
ALTER TABLE tbl MATERIALIZE COLUMN hostname;

-- hostname（新しい列）に対するクエリが高速化される
-- [コールド] 0行を返却。経過時間: 2.215秒。処理: 100万行、21.67 MB（45.152万行/秒、9.78 MB/秒）
-- [ウォーム] 0行を返却。経過時間: 0.541秒。処理: 100万行、21.67 MB（185万行/秒、40.04 MB/秒）
SELECT
    COUNT(*),
    avg(Duration/1E6) as average,
    quantile(0.95)(Duration/1E6) as p95,
    quantile(0.99)(Duration/1E6) as p99,
    hostname
FROM tbl
GROUP BY hostname ORDER BY 1 DESC LIMIT 50 FORMAT Null;

-- キャッシュを削除してクエリをコールド実行する
SYSTEM DROP FILESYSTEM CACHE;
```

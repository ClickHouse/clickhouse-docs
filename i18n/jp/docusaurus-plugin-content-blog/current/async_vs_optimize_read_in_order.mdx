---
title: 同期データ読み取り
description: "新しい設定 `allow_asynchronous_read_from_io_pool_for_merge_tree` により、読み取りスレッド（ストリーム）の数を、クエリ実行パイプラインの他の部分で使用されるスレッド数より多くすることができます。"
date: 2023-03-01
tags: ['設定', 'パフォーマンスと最適化']
keywords: ['同期', '非同期', 'データ読み取り']
---

import Image from "@theme/IdealImage";
import sync_read from "@site/static/images/knowledgebase/sync_read.png";
import async_read from "@site/static/images/knowledgebase/async_read.png";
import optimize_read from "@site/static/images/knowledgebase/optimize_read.png";

{frontMatter.description}

{/* 省略 */}


## 同期データ読み取り \{#synchronous-data-reading\}

新しい設定 `allow_asynchronous_read_from_io_pool_for_merge_tree` によって、読み取りスレッド（ストリーム）の数を、クエリ実行パイプラインの残りの処理で使用されるスレッド数よりも多く設定できます。

通常、[max_threads](https://clickhouse.com/docs/operations/settings/settings/#settings-max_threads) 設定は、並列読み取りスレッド数と並列クエリ処理スレッド数を[制御](https://clickhouse.com/company/events/query-performance-introspection)します。

<Image img={sync_read} size="md" alt="同期データ読み取りの図" />

データはディスクから、列単位で順番に読み出されます。

### 非同期データ読み取り \{#asynchronous-data-reading\}

新しい設定 [allow_asynchronous_read_from_io_pool_for_merge_tree](https://github.com/ClickHouse/ClickHouse/pull/43260) により、**CPU リソースが限られた ClickHouse Cloud サービスでのコールドクエリを高速化**し、**I/O ボトルネックとなるクエリのパフォーマンスを向上**させるために、読み取りスレッド（ストリーム）の数を、クエリ実行パイプラインの残りの部分で使用されるスレッド数より多く設定できるようになりました。
この設定が有効な場合、読み取りスレッドの数は [max_streams_for_merge_tree_reading](https://github.com/ClickHouse/ClickHouse/pull/43260) 設定によって制御されます。

<Image img={async_read} size="md" alt="非同期データ読み取りの図" />

データは、異なるカラムから非同期かつ並列に読み取られます。

また、読み取りスレッド（ストリーム）の数と、クエリ実行パイプラインの残りの部分で使用されるスレッド数との比率を設定するための [max_streams_to_max_threads_ratio](https://github.com/ClickHouse/ClickHouse/pull/43260) 設定も存在します。ただし、ベンチマークでは `max_streams_for_merge_tree_reading` 設定ほどの効果はありませんでした。

### optimize_read_in_order の場合はどうなりますか？ \{#what-about-optimize_read_in_order\}

[optimize_read_in_order 最適化](https://clickhouse.com/docs/sql-reference/statements/select/order-by/#optimization-of-data-reading)を有効にすると、クエリのソート順がディスク上のデータの物理的な並び順を反映している場合、ClickHouse はメモリ内でのデータの再ソート処理を[省略](https://clickhouse.com/blog/clickhouse-faster-queries-with-projections-and-primary-indexes)できます。**ただし、そのためにはデータを順序どおりに読み出す必要があります（非同期読み取りとは対照的です）。**

<Image img={optimize_read} size="md" alt="順序どおりの読み取り最適化を示す図" />

### optimize_read_in_order は非同期読み取りよりも優先される \{#optimize_read_in_order-has-precedence-over-asynchronous-reading\}

ClickHouse が `optimize_read_in_order optimization` を適用できると判断した場合、`allow_asynchronous_read_from_io_pool_for_merge_tree` 設定は無視されるか、無効化されます。

### 上記の内容をすべて踏まえた例

* [UK Property Price Paid テーブル](https://clickhouse.com/docs/getting-started/example-datasets/uk-price-paid) を作成してデータをロードする

* max&#95;threads の設定値を確認する（デフォルトでは、クエリを実行するノード上で ClickHouse が認識している CPU コア数と同じ）

```
SELECT getSetting('max_threads');


┌─getSetting('max_threads')─┐
│                        10 │
└───────────────────────────┘
```

* 読み取りおよびデータ処理の両方で、デフォルトのスレッド数を用いてクエリパイプラインを確認する

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid;

┌─explain──────────────────────┐
│ (Expression)                 │
│ ExpressionTransform × 10     │
│   (ReadFromMergeTree)        │
│   MergeTreeThread × 10 0 → 1 │
└──────────────────────────────┘
```

* 読み取りには 60 個の非同期スレッドを使用し、それ以外のクエリ実行パイプライン部分にはデフォルトのスレッド数を用いたクエリパイプラインを確認する

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
SETTINGS
    allow_asynchronous_read_from_io_pool_for_merge_tree = 1,
    max_streams_for_merge_tree_reading = 60;


┌─explain────────────────────────┐
│ (Expression)                   │
│ ExpressionTransform × 10       │
│   (ReadFromMergeTree)          │
│   Resize 60 → 10               │
│     MergeTreeThread × 60 0 → 1 │
└────────────────────────────────┘
```

* データの読み取りと処理の両方で、20 スレッドのクエリパイプラインになっていることを確認する

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
SETTINGS
    max_threads = 20;


┌─explain──────────────────────┐
│ (Expression)                 │
│ ExpressionTransform × 20     │
│   (ReadFromMergeTree)        │
│   MergeTreeThread × 20 0 → 1 │
└──────────────────────────────┘
```

* 非同期読み取り用 60 スレッドと、残りのクエリ実行パイプライン用 20 スレッドで構成されるクエリパイプラインを確認する

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
SETTINGS
    max_threads = 20,
    allow_asynchronous_read_from_io_pool_for_merge_tree = 1,
    max_streams_for_merge_tree_reading = 60;


┌─explain────────────────────────┐
│ (Expression)                   │
│ ExpressionTransform × 20       │
│   (ReadFromMergeTree)          │
│   Resize 60 → 20               │
│     MergeTreeThread × 60 0 → 1 │
└────────────────────────────────┘
```

* `optimize_read_in_order optimization` を適用できる場合、
  非同期読み取り用に 60 個、残りのクエリ実行パイプライン用に 20 個のスレッドを使用するクエリパイプラインを確認する


```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
ORDER BY postcode1, postcode2
SETTINGS
    max_threads = 20,
    allow_asynchronous_read_from_io_pool_for_merge_tree= 1,
    max_streams_for_merge_tree_reading= 60;


┌─explain───────────────────────────┐
│ (Expression)                      │
│ ExpressionTransform               │
│   (Sorting)                       │
│   MergingSortedTransform 20 → 1   │
│     (Expression)                  │
│     ExpressionTransform × 20      │
│       (ReadFromMergeTree)         │
│       MergeTreeInOrder × 20 0 → 1 │
└───────────────────────────────────┘


-- これは allow_asynchronous_read_from_io_pool_for_merge_tree を無効化することと同等です

EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
ORDER BY postcode1, postcode2
SETTINGS
    max_threads = 20,
    allow_asynchronous_read_from_io_pool_for_merge_tree = 0,
    max_streams_for_merge_tree_reading = 0;


┌─explain───────────────────────────┐
│ (Expression)                      │
│ ExpressionTransform               │
│   (Sorting)                       │
│   MergingSortedTransform 20 → 1   │
│     (Expression)                  │
│     ExpressionTransform × 20      │
│       (ReadFromMergeTree)         │
│       MergeTreeInOrder × 20 0 → 1 │
└───────────────────────────────────┘

-- optimize_read_in_order を無効化することで allow_asynchronous_read_from_io_pool_for_merge_tree を強制できます

EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
ORDER BY
    postcode1 ASC,
    postcode2 ASC
SETTINGS
    max_threads = 20,
    allow_asynchronous_read_from_io_pool_for_merge_tree = 1,
    max_streams_for_merge_tree_reading = 60,
    optimize_read_in_order = 0;


┌─explain──────────────────────────────┐
│ (Expression)                         │
│ ExpressionTransform                  │
│   (Sorting)                          │
│   MergingSortedTransform 20 → 1      │
│     MergeSortingTransform × 20       │
│       (Expression)                   │
│       ExpressionTransform × 20       │
│         (ReadFromMergeTree)          │
│         Resize 60 → 20               │
│           MergeTreeThread × 60 0 → 1 │
└──────────────────────────────────────┘


```

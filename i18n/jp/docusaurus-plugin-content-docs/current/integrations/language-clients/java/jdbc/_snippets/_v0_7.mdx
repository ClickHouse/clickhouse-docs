import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

`clickhouse-jdbc` は標準 JDBC インターフェイスを実装しています。[clickhouse-client](/integrations/sql-clients/sql-console) の上に構築されており、カスタム型マッピング、トランザクションサポート、標準的な同期 `UPDATE` および `DELETE` ステートメントなどの追加機能を提供するため、レガシーアプリケーションやツールでも容易に利用できます。

:::note
最新の JDBC (0.7.2) バージョンは Client-V1 を使用します
:::

`clickhouse-jdbc` API は同期型であり、一般的により多くのオーバーヘッド（例：SQL の構文解析や型のマッピング／変換など）が発生します。パフォーマンスが重要な場合や、より直接的な方法で ClickHouse にアクセスしたい場合は、[clickhouse-client](/integrations/sql-clients/sql-console) の利用を検討してください。

## 環境要件 \{#environment-requirements\}

* [OpenJDK](https://openjdk.java.net) バージョン 8 以上

### セットアップ \{#setup\}

<Tabs groupId="client-v1-compression-deps">
  <TabItem value="maven" label="Maven">
    ```xml
    <!-- https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc -->
    <dependency>
        <groupId>com.clickhouse</groupId>
        <artifactId>clickhouse-jdbc</artifactId>
        <version>0.7.2</version>
        <!-- すべての依存関係を含む Uber JAR を使用します。より小さな JAR が必要な場合は classifier を http に変更してください -->
        <classifier>shaded-all</classifier>
    </dependency>
    ```
  </TabItem>

  <TabItem value="gradle-kt" label="Gradle（Kotlin）">
    ```kotlin
    // https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc
    // すべての依存関係を含む Uber JAR を使用します。より小さな JAR が必要な場合は classifier を http に変更してください
    implementation("com.clickhouse:clickhouse-jdbc:0.7.2:shaded-all")
    ```
  </TabItem>

  <TabItem value="gradle" label="Gradle">
    ```groovy
    // https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc
    // すべての依存関係を含む Uber JAR を使用します。より小さな JAR が必要な場合は classifier を http に変更してください
    implementation 'com.clickhouse:clickhouse-jdbc:0.7.2:shaded-all'
    ```
  </TabItem>
</Tabs>

バージョン `0.5.0` 以降では、クライアントライブラリにバンドルされている Apache HTTP Client を使用しています。共通で利用できるパッケージのバージョンが用意されていないため、ロギング用ライブラリを依存関係として追加する必要があります。

<Tabs groupId="client-v1-compression-deps">
  <TabItem value="maven" label="Maven">
    ```xml
    <!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.16</version>
    </dependency>
    ```
  </TabItem>

  <TabItem value="gradle-kt" label="Gradle（Kotlin）">
    ```kotlin
    // https://mvnrepository.com/artifact/org.slf4j/slf4j-api
    implementation("org.slf4j:slf4j-api:2.0.16")
    ```
  </TabItem>

  <TabItem value="gradle" label="Gradle">
    ```groovy
    // https://mvnrepository.com/artifact/org.slf4j/slf4j-api
    implementation 'org.slf4j:slf4j-api:2.0.16'
    ```
  </TabItem>
</Tabs>

## 設定 \{#configuration\}

**ドライバークラス**: `com.clickhouse.jdbc.ClickHouseDriver`

**URL 構文**: `jdbc:(ch|clickhouse)[:<protocol>]://endpoint1[,endpoint2,...][/<database>][?param1=value1&param2=value2][#tag1,tag2,...]`。例えば次のとおりです:

* `jdbc:ch://localhost` は `jdbc:clickhouse:http://localhost:8123` と同じです
* `jdbc:ch:https://localhost` は `jdbc:clickhouse:http://localhost:8443?ssl=true&sslmode=STRICT` と同じです
* `jdbc:ch:grpc://localhost` は `jdbc:clickhouse:grpc://localhost:9100` と同じです

**接続プロパティ**:

| Property                 | Default | Description                                                                                                                                                                                                                                                                                                                                                                                                                |
| ------------------------ | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `continueBatchOnError`     | `false` | エラー発生時にバッチ処理を継続するかどうか                                                                                                                                                                                                                                                                                                                                                                                  |
| `createDatabaseIfNotExist` | `false` | データベースが存在しない場合に作成するかどうか                                                                                                                                                                                                                                                                                                                                                                             |
| `custom_http_headers`      |         | カンマ区切りのカスタム HTTP ヘッダー。例: `User-Agent=client1,X-Gateway-Id=123`                                                                                                                                                                                                                                                                                                                                            |
| `custom_http_params`       |         | カンマ区切りのカスタム HTTP クエリパラメータ。例: `extremes=0,max_result_rows=100`                                                                                                                                                                                                                                                                                                                                         |
| `nullAsDefault`            | `0`     | `0` - null 値はそのまま扱い、NULL 不可のカラムに null を挿入した場合は例外をスローする；`1` - null 値はそのまま扱い、挿入時の null チェックを無効にする；`2` - クエリおよび挿入の両方について、null を対応するデータ型のデフォルト値に置き換える                                                                                                                                                                                   |
| `jdbcCompliance`           | `true`  | 標準的な同期 UPDATE/DELETE と疑似トランザクションをサポートするかどうか                                                                                                                                                                                                                                                                                                                                                    |
| `typeMappings`             |         | ClickHouse のデータ型と Java クラス間のマッピングをカスタマイズします。これは [`getColumnType()`](https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSetMetaData.html#getColumnType-int-) および [`getObject(Class<>?>`)](https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html#getObject-java.lang.String-java.lang.Class-) の結果に影響します。例: `UInt128=java.lang.String,UInt256=java.lang.String` |
| `wrapperObject`            | `false` | Array / Tuple に対して [`getObject()`](https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html#getObject-int-) が java.sql.Array / java.sql.Struct を返すかどうか                                                                                                                                                                                                                                               |

注意: 詳細については [JDBC 固有の設定](https://github.com/ClickHouse/clickhouse-java/blob/main/clickhouse-jdbc/src/main/java/com/clickhouse/jdbc/JdbcConfig.java) を参照してください。

## サポートされているデータ型 \{#supported-data-types\}

JDBC ドライバーはクライアントライブラリと同じデータ形式をサポートします。

:::note

* AggregatedFunction - :warning: `SELECT * FROM table ...` をサポートしていません
* Decimal - 一貫性を保つため、21.9 以降では `SET output_format_decimal_trailing_zeros=1` を設定してください
* Enum - 文字列および整数の両方として扱うことができます
* UInt64 - client-v1 では `long` にマッピングされます
  :::

## 接続の作成 \{#creating-connection\}

```java
String url = "jdbc:ch://my-server/system"; // デフォルトでHTTPプロトコルとポート8123を使用

Properties properties = new Properties();

ClickHouseDataSource dataSource = new ClickHouseDataSource(url, properties);
try (Connection conn = dataSource.getConnection("default", "password");
    Statement stmt = conn.createStatement()) {
}
```

## 単純なステートメント \{#simple-statement\}

```java showLineNumbers

try (Connection conn = dataSource.getConnection(...);
    Statement stmt = conn.createStatement()) {
    ResultSet rs = stmt.executeQuery("select * from numbers(50000)");
    while(rs.next()) {
        // ...
    }
}
```

## Insert \{#insert\}

:::note

* `Statement` の代わりに `PreparedStatement` を使用してください
  :::

以下の input 関数と比較すると使いやすい反面、パフォーマンスは劣ります:

```java showLineNumbers
try (PreparedStatement ps = conn.prepareStatement("insert into mytable(* except (description))")) {
    ps.setString(1, "test"); // id
    ps.setObject(2, LocalDateTime.now()); // timestamp
    ps.addBatch(); // パラメータは即座にバイナリ形式でバッファストリームに書き込まれます
    ...
    ps.executeBatch(); // バッファ内のすべてのデータをClickHouseにストリーミングします
}
```

### input table 関数を使用する場合 \{#with-input-table-function\}

パフォーマンス面で非常に優れたオプションです。

```java showLineNumbers
try (PreparedStatement ps = conn.prepareStatement(
    "insert into mytable select col1, col2 from input('col1 String, col2 DateTime64(3), col3 Int32')")) {
    // カラム定義が解析され、ドライバは3つのパラメータ（col1、col2、col3）を認識します
    ps.setString(1, "test"); // col1
    ps.setObject(2, LocalDateTime.now()); // col2、setTimestampは低速のため非推奨です
    ps.setInt(3, 123); // col3
    ps.addBatch(); // パラメータは即座にバイナリ形式でバッファストリームに書き込まれます
    ...
    ps.executeBatch(); // バッファ内の全データをClickHouseにストリーミングします
}
```

* 可能な限り [input 関数のドキュメント](/sql-reference/table-functions/input/) を利用する

### プレースホルダーを使った挿入 \{#insert-with-placeholders\}

このオプションは、小規模なインサートにのみ使用することを推奨します。クライアント側でパースされる長大な SQL 式が必要になり、その処理で CPU とメモリを消費するためです。

```java showLineNumbers
try (PreparedStatement ps = conn.prepareStatement("insert into mytable values(trim(?),?,?)")) {
    ps.setString(1, "test"); // id
    ps.setObject(2, LocalDateTime.now()); // タイムスタンプ
    ps.setString(3, null); // 説明
    ps.addBatch(); // パラメータをクエリに追加
    ...
    ps.executeBatch(); // 構成されたクエリを実行: insert into mytable values(...)(...)...(...)
}
```

## DateTime とタイムゾーンの扱い \{#handling-datetime-and-time-zones\}

`java.sql.Timestamp` の代わりに `java.time.LocalDateTime` または `java.time.OffsetDateTime` を使用し、`java.sql.Date` の代わりには `java.time.LocalDate` を使用してください。

```java showLineNumbers
try (PreparedStatement ps = conn.prepareStatement("select date_time from mytable where date_time > ?")) {
    ps.setObject(2, LocalDateTime.now());
    ResultSet rs = ps.executeQuery();
    while(rs.next()) {
        LocalDateTime dateTime = (LocalDateTime) rs.getObject(1);
    }
    ...
}
```

## `AggregateFunction` の扱い \{#handling-aggregatefunction\}

:::note
現時点では、`groupBitmap` のみがサポートされています。
:::

```java showLineNumbers
// input関数を使用したバッチ挿入
try (ClickHouseConnection conn = newConnection(props);
        Statement s = conn.createStatement();
        PreparedStatement stmt = conn.prepareStatement(
                "insert into test_batch_input select id, name, value from input('id Int32, name Nullable(String), desc Nullable(String), value AggregateFunction(groupBitmap, UInt32)')")) {
    s.execute("drop table if exists test_batch_input;"
            + "create table test_batch_input(id Int32, name Nullable(String), value AggregateFunction(groupBitmap, UInt32))engine=Memory");
    Object[][] objs = new Object[][] {
            new Object[] { 1, "a", "aaaaa", ClickHouseBitmap.wrap(1, 2, 3, 4, 5) },
            new Object[] { 2, "b", null, ClickHouseBitmap.wrap(6, 7, 8, 9, 10) },
            new Object[] { 3, null, "33333", ClickHouseBitmap.wrap(11, 12, 13) }
    };
    for (Object[] v : objs) {
        stmt.setInt(1, (int) v[0]);
        stmt.setString(2, (String) v[1]);
        stmt.setString(3, (String) v[2]);
        stmt.setObject(4, v[3]);
        stmt.addBatch();
    }
    int[] results = stmt.executeBatch();
    ...
}

// クエリパラメータとしてbitmapを使用
try (PreparedStatement stmt = conn.prepareStatement(
    "SELECT bitmapContains(my_bitmap, toUInt32(1)) as v1, bitmapContains(my_bitmap, toUInt32(2)) as v2 from {tt 'ext_table'}")) {
    stmt.setObject(1, ClickHouseExternalTable.builder().name("ext_table")
            .columns("my_bitmap AggregateFunction(groupBitmap,UInt32)").format(ClickHouseFormat.RowBinary)
            .content(new ByteArrayInputStream(ClickHouseBitmap.wrap(1, 3, 5).toBytes()))
            .asTempTable()
            .build());
    ResultSet rs = stmt.executeQuery();
    Assert.assertTrue(rs.next());
    Assert.assertEquals(rs.getInt(1), 1);
    Assert.assertEquals(rs.getInt(2), 0);
    Assert.assertFalse(rs.next());
}
```

<br />

## HTTP ライブラリの設定 \{#configuring-http-library\}

ClickHouse JDBC コネクタは、次の 3 種類の HTTP ライブラリをサポートしています。[`HttpClient`](https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html)、[`HttpURLConnection`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/HttpURLConnection.html)、および [Apache `HttpClient`](https://hc.apache.org/httpcomponents-client-5.2.x/) です。

:::note
`HttpClient` は JDK 11 以降でのみ利用できます。
:::

JDBC ドライバはデフォルトで `HttpClient` を使用します。ClickHouse JDBC コネクタが使用する HTTP ライブラリは、次のプロパティを設定することで変更できます。

```java
properties.setProperty("http_connection_provider", "APACHE_HTTP_CLIENT");
```

対応する値の一覧は次のとおりです。

| プロパティ値                      | HTTP ライブラリ          |
| --------------------------- | ------------------- |
| HTTP&#95;CLIENT             | `HttpClient`        |
| HTTP&#95;URL&#95;CONNECTION | `HttpURLConnection` |
| APACHE&#95;HTTP&#95;CLIENT  | Apache `HttpClient` |

<br />

## SSL を使用して ClickHouse に接続する \{#connect-to-clickhouse-with-ssl\}

SSL を使用して ClickHouse へのセキュアな JDBC 接続を確立するには、JDBC プロパティに SSL パラメータを含めるように設定する必要があります。通常は、JDBC URL または Properties オブジェクトにおいて `sslmode` や `sslrootcert` などの SSL プロパティを指定します。

## SSL プロパティ \{#ssl-properties\}

| Name                 | Default Value | Optional Values | Description                                          |
| -------------------- | ------------- | --------------- | ---------------------------------------------------- |
| `ssl`                | false         | true, false     | 接続に SSL/TLS を有効にするかどうか                               |
| `sslmode`            | strict        | strict, none    | SSL/TLS 証明書を検証するかどうか                                 |
| `sslrootcert`        |               |                 | SSL/TLS ルート証明書へのパス                                   |
| `sslcert`            |               |                 | SSL/TLS 証明書へのパス                                      |
| `sslkey`             |               |                 | PKCS#8 形式の RSA 秘密鍵                                   |
| `key_store_type`     |               | JKS, PKCS12     | `KeyStore`/`TrustStore` ファイルの種類または形式を指定              |
| `trust_store`        |               |                 | `TrustStore` ファイルへのパス                                |
| `key_store_password` |               |                 | `KeyStore` 設定で指定した `KeyStore` ファイルへアクセスするために必要なパスワード |

これらのプロパティにより、Java アプリケーションは ClickHouse サーバーと暗号化された接続で通信し、データ送信時のセキュリティを強化できます。

```java showLineNumbers
  String url = "jdbc:ch://your-server:8443/system";

  Properties properties = new Properties();
  properties.setProperty("ssl", "true");
  properties.setProperty("sslmode", "strict"); // NONE to trust all servers; STRICT for trusted only
  properties.setProperty("sslrootcert", "/mine.crt");
  try (Connection con = DriverManager
          .getConnection(url, properties)) {

      try (PreparedStatement stmt = con.prepareStatement(

          // ここにコードを配置してください

      }
  }
```

## 大規模な INSERT 時の JDBC タイムアウトの解消 \{#resolving-jdbc-timeout-on-large-inserts\}

ClickHouse で長時間実行される大規模な INSERT を行う際、次のような JDBC タイムアウトエラーが発生する場合があります：

```plaintext
原因: java.sql.SQLException: 読み取りタイムアウト、サーバー myHostname [uri=https://hostname.aws.clickhouse.cloud:8443]
```

これらのエラーはデータ挿入プロセスを阻害し、システムの安定性に影響を及ぼす可能性があります。この問題に対処するには、クライアント OS 側のいくつかのタイムアウト設定を調整する必要があります。

### Mac OS \{#mac-os\}

Mac OS では、以下の設定を調整することで問題を解消できます。

* `net.inet.tcp.keepidle`: 60000
* `net.inet.tcp.keepintvl`: 45000
* `net.inet.tcp.keepinit`: 45000
* `net.inet.tcp.keepcnt`: 8
* `net.inet.tcp.always_keepalive`: 1

### Linux \{#linux\}

Linux では、同等の設定だけでは問題が解決しない場合があります。Linux におけるソケットのキープアライブ設定の扱いが異なるため、追加の手順が必要です。次の手順に従ってください。

1. `/etc/sysctl.conf` または関連する設定ファイル内で、以下の Linux カーネルパラメータを調整します。

* `net.inet.tcp.keepidle`: 60000
* `net.inet.tcp.keepintvl`: 45000
* `net.inet.tcp.keepinit`: 45000
* `net.inet.tcp.keepcnt`: 8
* `net.inet.tcp.always_keepalive`: 1
* `net.ipv4.tcp_keepalive_intvl`: 75
* `net.ipv4.tcp_keepalive_probes`: 9
* `net.ipv4.tcp_keepalive_time`: 60（デフォルトの 300 秒からこの値を下げることを検討してください）

2. カーネルパラメータを変更したら、次のコマンドを実行して変更を反映させます。

```shell
sudo sysctl -p
```

これらの設定を行った後、クライアントのソケットで keep-alive オプションが有効になっていることを確認する必要があります。

```java
properties.setProperty("socket_keepalive", "true");
```

:::note
現在、ソケットの keep-alive を設定する場合は Apache HTTP Client ライブラリを使用する必要があります。これは、`clickhouse-java` がサポートする他の 2 つの HTTP クライアントライブラリではソケットオプションを設定できないためです。詳細な手順については、[HTTP ライブラリの設定](/integrations/language-clients/java/jdbc-v1#configuring-http-library)を参照してください。
:::

別の方法として、同等のパラメータを JDBC URL に追加することもできます。

JDBC ドライバのデフォルトのソケットおよび接続タイムアウトは 30 秒です。大規模なデータ挿入処理をサポートするために、このタイムアウト値を長く設定できます。`ClickHouseClient` の `options` メソッドを、`ClickHouseClientOption` で定義されている `SOCKET_TIMEOUT` および `CONNECTION_TIMEOUT` オプションと組み合わせて使用します。

```java showLineNumbers
final int MS_12H = 12 * 60 * 60 * 1000; // 12時間(ミリ秒)
final String sql = "insert into table_a (c1, c2, c3) select c1, c2, c3 from table_b;";

try (ClickHouseClient client = ClickHouseClient.newInstance(ClickHouseProtocol.HTTP)) {
    client.read(servers).write()
        .option(ClickHouseClientOption.SOCKET_TIMEOUT, MS_12H)
        .option(ClickHouseClientOption.CONNECTION_TIMEOUT, MS_12H)
        .query(sql)
        .executeAndWait();
}
```

---
slug: /best-practices/minimize-optimize-joins
sidebar_position: 10
sidebar_label: 'JOIN を最小化と最適化する'
title: 'JOIN を最小化と最適化する'
description: 'JOIN のベストプラクティスを説明するページ'
keywords: ['JOIN', 'Parallel Hash JOIN']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import joins from '@site/static/images/bestpractices/joins-speed-memory.png';

ClickHouse は多様な JOIN の種類とアルゴリズムをサポートしており、最近のリリースで JOIN のパフォーマンスは大きく向上しています。しかし、JOIN は本質的に、単一の非正規化テーブルに対するクエリよりもコストが高くなります。非正規化は計算処理をクエリ実行時から挿入時または事前処理時へと移し替えることで、多くの場合、クエリ実行時のレイテンシを大幅に低減します。リアルタイムまたはレイテンシに敏感な分析クエリに対しては、**非正規化を強く推奨します**。

一般に、次のような場合は非正規化を行います:

* テーブルの更新頻度が低い場合、またはバッチ更新で問題ない場合。
* 関係が多対多ではない、またはカーディナリティが過度に高くない場合。
* クエリで使用されるカラムが限定されており、つまり一部のカラムは非正規化の対象から除外できる場合。
* ClickHouse の外部、たとえば Flink のようなアップストリームシステムに処理をオフロードし、リアルタイムなエンリッチメントやフラット化処理をそこで管理できる場合。

すべてのデータを非正規化する必要はありません。頻繁にクエリされる属性に注力してください。また、サブテーブル全体を重複させる代わりに、集計を増分的に計算するために [materialized views](/best-practices/use-materialized-views) の利用も検討してください。スキーマの更新がまれでレイテンシが重要な場合、非正規化はパフォーマンス面で最適なトレードオフとなります。

ClickHouse におけるデータの非正規化に関する詳細なガイドは[こちら](/data-modeling/denormalization)を参照してください。


## JOINが必要な場合 {#when-joins-are-required}

JOINが必要な場合は、**少なくともバージョン24.12以降、できれば最新バージョンを使用してください**。JOINのパフォーマンスは新しいリリースごとに改善され続けています。ClickHouse 24.12以降、クエリプランナーは最適なパフォーマンスを実現するため、小さいテーブルを自動的にJOINの右側に配置するようになりました。これは以前は手動で行う必要があった作業です。さらに多くの機能強化が近日中に予定されており、より積極的なフィルタプッシュダウンや複数のJOINの自動並べ替えなどが含まれます。

JOINのパフォーマンスを向上させるために、以下のベストプラクティスに従ってください:

- **デカルト積を避ける**: 左側の値が右側の複数の値と一致する場合、JOINは複数の行を返します。これはいわゆるデカルト積です。ユースケースで右側のすべての一致が必要なく、任意の単一の一致だけで十分な場合は、`ANY` JOIN(例: `LEFT ANY JOIN`)を使用できます。これらは通常のJOINよりも高速で、メモリ使用量も少なくなります。
- **JOINするテーブルのサイズを削減する**: JOINの実行時間とメモリ消費量は、左右のテーブルのサイズに比例して増加します。JOINで処理されるデータ量を削減するには、クエリの`WHERE`句または`JOIN ON`句に追加のフィルタ条件を追加してください。ClickHouseはフィルタ条件をクエリプランの可能な限り深い位置、通常はJOINの前にプッシュダウンします。フィルタが自動的にプッシュダウンされない場合(何らかの理由で)、JOINの片側をサブクエリとして書き直すことで、プッシュダウンを強制できます。
- **適切な場合はディクショナリを介した直接JOINを使用する**: ClickHouseの標準的なJOINは2つのフェーズで実行されます。右側を反復処理してハッシュテーブルを構築するビルドフェーズと、左側を反復処理してハッシュテーブルルックアップを介して一致するJOINパートナーを見つけるプローブフェーズです。右側が[ディクショナリ](/dictionary)またはキーバリュー特性を持つ他のテーブルエンジン(例: [EmbeddedRocksDB](/engines/table-engines/integrations/embedded-rocksdb)や[Joinテーブルエンジン](/engines/table-engines/special/join))である場合、ClickHouseは「直接」JOINアルゴリズムを使用でき、ハッシュテーブルの構築が不要になり、クエリ処理が高速化されます。これは`INNER`および`LEFT OUTER` JOINで機能し、リアルタイム分析ワークロードに適しています。
- **JOINにテーブルのソートを活用する**: ClickHouseの各テーブルは、テーブルのプライマリキー列でソートされています。`full_sorting_merge`や`partial_merge`などのソートマージJOINアルゴリズムを使用することで、テーブルのソートを活用できます。ハッシュテーブルに基づく標準的なJOINアルゴリズム(以下の`parallel_hash`、`hash`、`grace_hash`を参照)とは異なり、ソートマージJOINアルゴリズムは最初に両方のテーブルをソートしてからマージします。クエリが両方のテーブルをそれぞれのプライマリキー列でJOINする場合、ソートマージにはソートステップを省略する最適化があり、処理時間とオーバーヘッドを節約できます。
- **ディスクスピルJOINを避ける**: JOINの中間状態(例: ハッシュテーブル)は非常に大きくなり、メインメモリに収まらなくなることがあります。この状況では、ClickHouseはデフォルトでメモリ不足エラーを返します。一部のJOINアルゴリズム(以下を参照)、例えば[`grace_hash`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2)、[`partial_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3)、[`full_sorting_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3)は、中間状態をディスクにスピルしてクエリ実行を継続できます。ただし、これらのJOINアルゴリズムは、ディスクアクセスがJOIN処理を大幅に遅くする可能性があるため、注意して使用する必要があります。代わりに、中間状態のサイズを削減するために、他の方法でJOINクエリを最適化することをお勧めします。
- **外部JOINで不一致マーカーとしてデフォルト値を使用する**: 左/右/完全外部JOINは、左/右/両方のテーブルのすべての値を含みます。ある値に対して他のテーブルでJOINパートナーが見つからない場合、ClickHouseはJOINパートナーを特別なマーカーで置き換えます。SQL標準では、データベースがこのようなマーカーとしてNULLを使用することを義務付けています。ClickHouseでは、これには結果列をNullableでラップする必要があり、追加のメモリとパフォーマンスのオーバーヘッドが発生します。代替として、設定`join_use_nulls = 0`を構成し、結果列のデータ型のデフォルト値をマーカーとして使用できます。


:::note 辞書の利用には注意が必要です
ClickHouse で JOIN に辞書を使用する場合、辞書は設計上、重複キーを許可しないことを理解しておくことが重要です。データロード時には、重複したキーはすべて暗黙的に重複排除され、そのキーに対して最後にロードされた値だけが保持されます。この挙動により、辞書は、最新または正とみなす値だけが必要とされる 1 対 1 や多対 1 のリレーションシップに最適です。しかし、辞書を 1 対多または多対多のリレーションシップ（例えば、1 人の俳優が複数の役を持ち得るような、役と俳優の結合）に使用すると、マッチした行のうち 1 行を除くすべてが破棄されるため、データが暗黙的に失われます。その結果、辞書は複数のマッチに対して完全なリレーショナルな完全性が求められるシナリオには適していません。
:::



## 適切なJOINアルゴリズムの選択 {#choosing-the-right-join-algorithm}

ClickHouseは、速度とメモリのトレードオフを考慮した複数のJOINアルゴリズムをサポートしています:

- **Parallel Hash JOIN（デフォルト）:** メモリに収まる小規模から中規模の右側テーブルに対して高速に動作します。
- **Direct JOIN:** ディクショナリ（またはキーバリュー特性を持つ他のテーブルエンジン）を`INNER`または`LEFT ANY JOIN`で使用する場合に最適です。ハッシュテーブルの構築が不要なため、ポイントルックアップにおいて最速の方法となります。
- **Full Sorting Merge JOIN:** 両方のテーブルが結合キーでソート済みの場合に効率的です。
- **Partial Merge JOIN:** メモリ使用量を最小化しますが、処理速度は遅くなります。メモリが限られた環境で大規模テーブルを結合する場合に最適です。
- **Grace Hash JOIN:** 柔軟でメモリ調整が可能であり、パフォーマンス特性を調整できる大規模データセットに適しています。

<Image img={joins} size='md' alt='JOIN — 速度とメモリの関係' />

:::note
各アルゴリズムは、JOINタイプに対するサポートが異なります。各アルゴリズムでサポートされている結合タイプの完全なリストは[こちら](/guides/joining-tables#choosing-a-join-algorithm)で確認できます。
:::

`join_algorithm = 'auto'`（デフォルト）を設定することでClickHouseに最適なアルゴリズムを選択させるか、ワークロードに基づいて明示的に制御することができます。パフォーマンスやメモリオーバーヘッドを最適化するために結合アルゴリズムを選択する必要がある場合は、[このガイド](/guides/joining-tables#choosing-a-join-algorithm)を参照することをお勧めします。

最適なパフォーマンスを実現するために:

- 高パフォーマンスワークロードでは、JOINを最小限に抑えてください。
- クエリあたり3〜4個を超える結合は避けてください。
- 実際のデータで異なるアルゴリズムをベンチマークしてください。パフォーマンスは結合キーの分布とデータサイズによって変動します。

JOIN最適化戦略、JOINアルゴリズム、およびそのチューニング方法の詳細については、[ClickHouseドキュメント](/guides/joining-tables)および[このブログシリーズ](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1)を参照してください。

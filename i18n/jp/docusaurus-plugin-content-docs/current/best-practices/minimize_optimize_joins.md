---
slug: /best-practices/minimize-optimize-joins
sidebar_position: 10
sidebar_label: 'JOINの最小化と最適化'
title: 'JOINの最小化と最適化'
description: 'JOINに関するベストプラクティスを説明するページ'
keywords: ['JOIN', 'Parallel Hash JOIN']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import joins from '@site/static/images/bestpractices/joins-speed-memory.png';

ClickHouseは多様なJOINタイプとアルゴリズムをサポートしており、最近のリリースではJOINのパフォーマンスが大幅に向上しています。しかし、JOINは本質的に、単一の非正規化テーブルに対するクエリよりもコストが高くなります。非正規化により、計算処理をクエリ実行時から挿入時または前処理時にシフトさせることで、実行時のレイテンシを大幅に削減できます。リアルタイムまたはレイテンシが重要な分析クエリでは、**非正規化を強く推奨します**。

一般的に、以下の場合に非正規化を検討してください。

* テーブルの変更頻度が低い場合、またはバッチ更新で問題ない場合
* リレーションシップが多対多ではない場合、またはカーディナリティが過度に高くない場合
* クエリ対象のカラムが限定的である場合、つまり特定のカラムを非正規化から除外できる場合
* Flinkなどの上流システムに処理をオフロードできる場合。リアルタイムでのエンリッチメントやフラット化を上流で管理できます

すべてのデータを非正規化する必要はありません。頻繁にクエリされる属性に焦点を当ててください。また、サブテーブル全体を複製する代わりに、[マテリアライズドビュー](/best-practices/use-materialized-views)を使用して集計を段階的に計算することも検討してください。スキーマ更新が稀でレイテンシが重要な場合、非正規化は最適なパフォーマンストレードオフとなります。

ClickHouseでのデータ非正規化の詳細なガイドについては、[こちら](/data-modeling/denormalization)を参照してください。


## JOINが必要な場合 {#when-joins-are-required}

JOINが必要な場合は、**少なくともバージョン24.12以降、できれば最新バージョンを使用してください**。JOINのパフォーマンスは新しいリリースごとに改善され続けています。ClickHouse 24.12以降、クエリプランナーは最適なパフォーマンスのために、小さいテーブルを自動的にJOINの右側に配置するようになりました。これは以前は手動で行う必要があった作業です。さらに多くの機能強化が近日中に予定されており、より積極的なフィルタプッシュダウンや複数のJOINの自動並べ替えなどが含まれます。

JOINのパフォーマンスを向上させるために、以下のベストプラクティスに従ってください:

- **デカルト積を避ける**: 左側の値が右側の複数の値と一致する場合、JOINは複数の行を返します。これはいわゆるデカルト積です。ユースケースで右側のすべての一致が必要なく、任意の単一の一致だけで十分な場合は、`ANY` JOIN(例: `LEFT ANY JOIN`)を使用できます。これらは通常のJOINよりも高速でメモリ使用量も少なくなります。
- **JOINするテーブルのサイズを削減する**: JOINの実行時間とメモリ消費量は、左右のテーブルのサイズに比例して増加します。JOINで処理されるデータ量を削減するには、クエリの`WHERE`句または`JOIN ON`句に追加のフィルタ条件を追加します。ClickHouseはフィルタ条件をクエリプランの可能な限り深い位置、通常はJOINの前にプッシュダウンします。フィルタが自動的にプッシュダウンされない場合(何らかの理由で)、JOINの片側をサブクエリとして書き直すことで、プッシュダウンを強制できます。
- **適切な場合はディクショナリを介した直接JOINを使用する**: ClickHouseの標準的なJOINは2つのフェーズで実行されます。右側を反復処理してハッシュテーブルを構築するビルドフェーズと、左側を反復処理してハッシュテーブルルックアップを介して一致するJOINパートナーを見つけるプローブフェーズです。右側が[ディクショナリ](/dictionary)またはキーバリュー特性を持つ他のテーブルエンジン(例: [EmbeddedRocksDB](/engines/table-engines/integrations/embedded-rocksdb)や[Joinテーブルエンジン](/engines/table-engines/special/join))である場合、ClickHouseは「直接」JOINアルゴリズムを使用でき、ハッシュテーブルの構築が不要になり、クエリ処理が高速化されます。これは`INNER`および`LEFT OUTER` JOINで機能し、リアルタイム分析ワークロードに適しています。
- **JOINにテーブルのソートを活用する**: ClickHouseの各テーブルは、テーブルのプライマリキー列でソートされています。`full_sorting_merge`や`partial_merge`などのソートマージJOINアルゴリズムを使用することで、テーブルのソートを活用できます。ハッシュテーブルに基づく標準的なJOINアルゴリズム(以下の`parallel_hash`、`hash`、`grace_hash`を参照)とは異なり、ソートマージJOINアルゴリズムは最初に両方のテーブルをソートしてからマージします。クエリが両方のテーブルをそれぞれのプライマリキー列でJOINする場合、ソートマージにはソートステップを省略する最適化があり、処理時間とオーバーヘッドを節約できます。
- **ディスクスピルJOINを避ける**: JOINの中間状態(例: ハッシュテーブル)は非常に大きくなり、メインメモリに収まらなくなることがあります。この状況では、ClickHouseはデフォルトでメモリ不足エラーを返します。一部のJOINアルゴリズム(以下を参照)、例えば[`grace_hash`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2)、[`partial_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3)、[`full_sorting_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3)は、中間状態をディスクにスピルしてクエリ実行を継続できます。ただし、これらのJOINアルゴリズムは、ディスクアクセスがJOIN処理を大幅に遅くする可能性があるため、注意して使用する必要があります。代わりに、中間状態のサイズを削減するために、他の方法でJOINクエリを最適化することをお勧めします。
- **外部JOINで一致なしマーカーとしてデフォルト値を使用する**: 左/右/完全外部JOINは、左/右/両方のテーブルのすべての値を含みます。ある値に対して他のテーブルでJOINパートナーが見つからない場合、ClickHouseはJOINパートナーを特別なマーカーで置き換えます。SQL標準では、データベースがこのようなマーカーとしてNULLを使用することを義務付けています。ClickHouseでは、これには結果列をNullableでラップする必要があり、追加のメモリとパフォーマンスのオーバーヘッドが発生します。代替として、設定`join_use_nulls = 0`を構成し、結果列のデータ型のデフォルト値をマーカーとして使用できます。


:::note ディクショナリの使用には注意が必要です
ClickHouseでJOINにディクショナリを使用する場合、ディクショナリは設計上、重複キーを許可しないことを理解しておく必要があります。データ読み込み時に重複キーがあると、それらは暗黙的に重複排除され、特定のキーに対して最後に読み込まれた値のみが保持されます。この動作により、ディクショナリは1対1または多対1の関係で、最新または正規の値のみが必要な場合に適しています。しかし、1対多または多対多の関係(例:俳優と役割を結合する場合で、1人の俳優が複数の役割を持つケース)でディクショナリを使用すると、一致する行のうち1つを除いてすべてが破棄されるため、データが暗黙的に失われます。そのため、複数の一致に対して完全なリレーショナルの整合性が求められるシナリオには、ディクショナリは適していません。
:::



## 適切なJOINアルゴリズムの選択 {#choosing-the-right-join-algorithm}

ClickHouseは、速度とメモリのトレードオフを考慮した複数のJOINアルゴリズムをサポートしています：

- **Parallel Hash JOIN（デフォルト）：** メモリに収まる小〜中規模の右側テーブルに対して高速です。
- **Direct JOIN：** ディクショナリ（またはキーバリュー特性を持つ他のテーブルエンジン）を`INNER`または`LEFT ANY JOIN`で使用する場合に最適です。ハッシュテーブルの構築が不要なため、ポイントルックアップで最速の方法となります。
- **Full Sorting Merge JOIN：** 両方のテーブルが結合キーでソート済みの場合に効率的です。
- **Partial Merge JOIN：** メモリ使用量を最小化しますが、処理速度は遅くなります。メモリが限られた環境で大規模テーブルを結合する場合に最適です。
- **Grace Hash JOIN：** 柔軟でメモリ調整が可能であり、パフォーマンス特性を調整できる大規模データセットに適しています。

<Image img={joins} size='md' alt='Joins — speed vs memory' />

:::note
各アルゴリズムは、JOINタイプに対するサポートが異なります。各アルゴリズムでサポートされている結合タイプの完全なリストは[こちら](/guides/joining-tables#choosing-a-join-algorithm)で確認できます。
:::

`join_algorithm = 'auto'`（デフォルト）を設定することでClickHouseに最適なアルゴリズムを選択させるか、ワークロードに基づいて明示的に制御することができます。パフォーマンスやメモリオーバーヘッドを最適化するために結合アルゴリズムを選択する必要がある場合は、[このガイド](/guides/joining-tables#choosing-a-join-algorithm)を参照することをお勧めします。

最適なパフォーマンスを実現するために：

- 高パフォーマンスワークロードでは、JOINを最小限に抑えてください。
- クエリあたり3〜4個を超える結合は避けてください。
- 実際のデータで異なるアルゴリズムをベンチマークしてください。パフォーマンスは結合キーの分布とデータサイズによって変動します。

JOIN最適化戦略、JOINアルゴリズム、およびそのチューニング方法の詳細については、[ClickHouseドキュメント](/guides/joining-tables)および[このブログシリーズ](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1)を参照してください。

---
slug: /best-practices/minimize-optimize-joins
sidebar_position: 10
sidebar_label: 'JOIN を最小化・最適化する'
title: 'JOIN を最小化・最適化する'
description: 'JOIN のベストプラクティスを解説するページ'
keywords: ['JOIN', 'Parallel Hash JOIN']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import joins from '@site/static/images/bestpractices/joins-speed-memory.png';

ClickHouse は多様な JOIN の種類とアルゴリズムをサポートしており、最近のリリースで JOIN のパフォーマンスは大きく向上しています。しかし、JOIN は本質的に、単一の非正規化テーブルに対するクエリよりもコストが高くなります。非正規化は、計算処理をクエリ実行時から挿入時や事前処理時に移すことで、実行時のレイテンシを大幅に低減できる場合が多くあります。リアルタイム性や低レイテンシが求められる分析クエリに対しては、**非正規化を強く推奨します**。

一般的には、次のような場合に非正規化を行います:

* テーブルの更新頻度が低い、またはバッチによるリフレッシュで問題ない場合。
* リレーションが多対多ではない、またはカーディナリティが極端に高くない場合。
* クエリ対象となるカラムが限定されており、つまり一部のカラムは非正規化の対象から外せる場合。
* Flink のような上流システムに処理をオフロードでき、リアルタイムなエンリッチメントやフラット化をそこで管理できる場合。

すべてのデータを非正規化する必要はありません。よくクエリされる属性に重点を置いてください。また、サブテーブル全体を複製するのではなく、集計を段階的に計算する手段として [materialized views](/best-practices/use-materialized-views) の利用も検討してください。スキーマ更新がまれでレイテンシが重要な場合、非正規化はパフォーマンス面で最も優れたトレードオフを提供します。

ClickHouse におけるデータの非正規化に関する詳細なガイドは[こちら](/data-modeling/denormalization)を参照してください。


## JOINが必要な場合 {#when-joins-are-required}

JOINが必要な場合は、**少なくともバージョン24.12以降、できれば最新バージョンを使用してください**。JOINのパフォーマンスは新しいリリースごとに改善され続けています。ClickHouse 24.12以降、クエリプランナーは最適なパフォーマンスのために、小さいテーブルを自動的にJOINの右側に配置するようになりました。これは以前は手動で行う必要があった作業です。さらに多くの機能強化が近日中に予定されており、より積極的なフィルタプッシュダウンや複数のJOINの自動並べ替えなどが含まれます。

JOINのパフォーマンスを向上させるために、以下のベストプラクティスに従ってください：

- **デカルト積を避ける**：左側の値が右側の複数の値と一致する場合、JOINは複数の行を返します。これはいわゆるデカルト積です。ユースケースで右側のすべての一致が必要なく、任意の単一の一致だけで十分な場合は、`ANY` JOIN（例：`LEFT ANY JOIN`）を使用できます。これらは通常のJOINよりも高速で、メモリ使用量も少なくなります。
- **JOINするテーブルのサイズを削減する**：JOINの実行時間とメモリ消費量は、左右のテーブルのサイズに比例して増加します。JOINで処理されるデータ量を削減するには、クエリの`WHERE`句または`JOIN ON`句に追加のフィルタ条件を追加します。ClickHouseはフィルタ条件をクエリプランの可能な限り深い位置、通常はJOINの前にプッシュダウンします。フィルタが自動的にプッシュダウンされない場合（何らかの理由で）、JOINの片側をサブクエリとして書き直すことで、プッシュダウンを強制できます。
- **適切な場合はディクショナリを介した直接JOINを使用する**：ClickHouseの標準的なJOINは2つのフェーズで実行されます。右側を反復処理してハッシュテーブルを構築するビルドフェーズと、左側を反復処理してハッシュテーブルルックアップを介して一致するJOINパートナーを見つけるプローブフェーズです。右側が[ディクショナリ](/dictionary)またはキーバリュー特性を持つ他のテーブルエンジン（例：[EmbeddedRocksDB](/engines/table-engines/integrations/embedded-rocksdb)や[Joinテーブルエンジン](/engines/table-engines/special/join)）の場合、ClickHouseは「直接」JOINアルゴリズムを使用でき、ハッシュテーブルの構築が不要になり、クエリ処理が高速化されます。これは`INNER`および`LEFT OUTER` JOINで機能し、リアルタイム分析ワークロードに適しています。
- **JOINにテーブルのソートを活用する**：ClickHouseの各テーブルは、テーブルのプライマリキー列でソートされています。`full_sorting_merge`や`partial_merge`などのソートマージJOINアルゴリズムを使用することで、テーブルのソートを活用できます。ハッシュテーブルベースの標準的なJOINアルゴリズム（後述の`parallel_hash`、`hash`、`grace_hash`）とは異なり、ソートマージJOINアルゴリズムは最初に両方のテーブルをソートしてからマージします。クエリが両方のテーブルをそれぞれのプライマリキー列でJOINする場合、ソートマージにはソートステップを省略する最適化があり、処理時間とオーバーヘッドを節約できます。
- **ディスクスピルJOINを避ける**：JOINの中間状態（例：ハッシュテーブル）は非常に大きくなり、メインメモリに収まらなくなることがあります。この状況では、ClickHouseはデフォルトでメモリ不足エラーを返します。一部のJOINアルゴリズム（後述）、例えば[`grace_hash`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2)、[`partial_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3)、[`full_sorting_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3)は、中間状態をディスクにスピルしてクエリ実行を継続できます。ただし、これらのJOINアルゴリズムは、ディスクアクセスがJOIN処理を大幅に遅くする可能性があるため、慎重に使用する必要があります。代わりに、中間状態のサイズを削減するために、他の方法でJOINクエリを最適化することをお勧めします。
- **外部JOINで不一致マーカーとしてデフォルト値を使用する**：左外部JOIN、右外部JOIN、完全外部JOINは、左側、右側、または両方のテーブルのすべての値を含みます。ある値に対して他のテーブルでJOINパートナーが見つからない場合、ClickHouseはJOINパートナーを特別なマーカーで置き換えます。SQL標準では、データベースがこのようなマーカーとしてNULLを使用することを義務付けています。ClickHouseでは、これには結果列をNullableでラップする必要があり、追加のメモリとパフォーマンスのオーバーヘッドが発生します。代替として、設定`join_use_nulls = 0`を構成し、結果列のデータ型のデフォルト値をマーカーとして使用できます。


:::note 辞書の使用には注意する
ClickHouse で JOIN に辞書を使用する場合、辞書は設計上、重複キーを許容しないことを理解しておくことが重要です。データ読み込み時には、重複キーはすべて暗黙的に重複排除され、そのキーに対して最後に読み込まれた値だけが保持されます。この挙動により、辞書は、最新もしくは正とみなすべき値だけが必要な 1 対 1 または多 対 1 の関係に最適です。しかし、1 対 多または多 対 多の関係（例えば、1 人の俳優が複数の役を持つことがあるような、俳優と役を結合するケース）に辞書を使用すると、一致する行のうち 1 行を除いてすべてが破棄されるため、データが暗黙的に失われます。その結果、辞書は複数のマッチ間で完全なリレーショナルな整合性が求められるシナリオには適していません。
:::



## 適切なJOINアルゴリズムの選択 {#choosing-the-right-join-algorithm}

ClickHouseは、速度とメモリのトレードオフを考慮した複数のJOINアルゴリズムをサポートしています:

- **Parallel Hash JOIN(デフォルト):** メモリに収まる小〜中規模の右側テーブルに対して高速です。
- **Direct JOIN:** ディクショナリ(またはキーバリュー特性を持つ他のテーブルエンジン)を`INNER`または`LEFT ANY JOIN`で使用する場合に最適です。ハッシュテーブルの構築が不要なため、ポイントルックアップで最速の方法となります。
- **Full Sorting Merge JOIN:** 両方のテーブルが結合キーでソート済みの場合に効率的です。
- **Partial Merge JOIN:** メモリ使用量を最小化しますが、処理速度は遅くなります。メモリが限られた環境で大規模テーブルを結合する場合に最適です。
- **Grace Hash JOIN:** 柔軟でメモリ調整が可能であり、パフォーマンス特性を調整できる大規模データセットに適しています。

<Image img={joins} size='md' alt='Joins — speed vs memory' />

:::note
各アルゴリズムは、JOINタイプに対するサポートが異なります。各アルゴリズムでサポートされている結合タイプの完全なリストは[こちら](/guides/joining-tables#choosing-a-join-algorithm)で確認できます。
:::

`join_algorithm = 'auto'`(デフォルト)を設定することでClickHouseに最適なアルゴリズムを選択させるか、ワークロードに基づいて明示的に制御することができます。パフォーマンスやメモリオーバーヘッドを最適化するために結合アルゴリズムを選択する必要がある場合は、[このガイド](/guides/joining-tables#choosing-a-join-algorithm)を参照することをお勧めします。

最適なパフォーマンスを実現するために:

- 高パフォーマンスワークロードでは、JOINを最小限に抑えてください。
- クエリあたり3〜4個を超える結合は避けてください。
- 実際のデータで異なるアルゴリズムをベンチマークしてください。パフォーマンスは結合キーの分布とデータサイズによって変動します。

JOIN最適化戦略、JOINアルゴリズム、およびそのチューニング方法の詳細については、[ClickHouseドキュメント](/guides/joining-tables)および[このブログシリーズ](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1)を参照してください。

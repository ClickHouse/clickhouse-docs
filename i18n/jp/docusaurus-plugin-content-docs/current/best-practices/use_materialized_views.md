---
slug: /best-practices/use-materialized-views
sidebar_position: 10
sidebar_label: 'マテリアライズドビューを活用する'
title: 'マテリアライズドビューを活用する'
description: 'マテリアライズドビューについて解説するページ'
keywords: ['materialized views', 'medallion architecture']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import incremental_materialized_view from '@site/static/images/bestpractices/incremental_materialized_view.gif';
import refreshable_materialized_view from '@site/static/images/bestpractices/refreshable_materialized_view.gif';

ClickHouse は 2 種類のマテリアライズドビューをサポートしています。すなわち、[**インクリメンタル**](/materialized-view/incremental-materialized-view) と [**リフレッシャブル**](/materialized-view/refreshable-materialized-view) です。どちらもクエリ結果を事前に計算して保存することでクエリを高速化するように設計されていますが、基になるクエリが「いつ・どのように」実行されるか、どのようなワークロードに適しているか、データの鮮度をどのように扱うかといった点で大きく異なります。

**ユーザーは、特定のクエリパターンの高速化が必要であり、かつ事前に [型に関するベストプラクティス](/best-practices/select-data-types) と [主キー最適化](/best-practices/choosing-a-primary-key) を適用している場合に、マテリアライズドビューの利用を検討すべきです。**

**インクリメンタルマテリアライズドビュー** はリアルタイムで更新されます。新しいデータがソーステーブルに挿入されると、ClickHouse は自動的にマテリアライズドビューのクエリをその新しいデータブロックに適用し、結果を別のターゲットテーブルに書き込みます。時間の経過とともに、ClickHouse はこれらの部分的な結果をマージして、完全かつ最新のビューを生成します。このアプローチは、計算コストを挿入時に移し、かつ新しいデータのみを処理するため、非常に効率的です。その結果、ターゲットテーブルに対する `SELECT` クエリは高速かつ軽量になります。インクリメンタルビューはあらゆる集約関数をサポートし、各クエリが挿入中のデータセットの小さな直近サブセットのみを処理するため、ペタバイト級のデータまで良好にスケールします。

<Image img={incremental_materialized_view} size="lg" alt="マテリアライズドビュー" />

**リフレッシャブルマテリアライズドビュー** は、これとは対照的に、スケジュールに従って更新されます。これらのビューは、定期的にクエリ全体を再実行し、その結果でターゲットテーブルの内容を上書きします。これは、Postgres のような従来の OLTP データベースにおけるマテリアライズドビューと似ています。

<Image img={refreshable_materialized_view} size="lg" alt="リフレッシャブルマテリアライズドビューの図" />

インクリメンタルマテリアライズドビューとリフレッシャブルマテリアライズドビューのどちらを選択するかは、主にクエリの性質、データの変更頻度、およびビューの更新が挿入される各行を逐一反映する必要があるのか、それとも定期的なリフレッシュで十分なのかによって決まります。これらのトレードオフを理解することは、ClickHouse で高性能かつスケーラブルなマテリアライズドビューを設計するうえで非常に重要です。


## インクリメンタルマテリアライズドビューを使用するタイミング {#when-to-use-incremental-materialized-views}

インクリメンタルマテリアライズドビューは一般的に推奨されます。ソーステーブルが新しいデータを受信するたびに、リアルタイムで自動的に更新されるためです。すべての集約関数をサポートし、単一テーブルに対する集約に特に効果的です。挿入時に結果を段階的に計算することで、クエリは大幅に小さなデータサブセットに対して実行されるため、これらのビューはペタバイト規模のデータでも容易にスケールできます。ほとんどの場合、クラスタ全体のパフォーマンスに顕著な影響を与えることはありません。

インクリメンタルマテリアライズドビューを使用するタイミング:

- 挿入のたびに更新されるリアルタイムのクエリ結果が必要な場合
- 大量のデータを頻繁に集約またはフィルタリングする場合
- クエリが単一テーブルに対する単純な変換または集約を含む場合

インクリメンタルマテリアライズドビューの例については、[こちら](/materialized-view/incremental-materialized-view)を参照してください。


## リフレッシュ可能なマテリアライズドビューを使用するタイミング {#when-to-use-refreshable-materialized-views}

リフレッシュ可能なマテリアライズドビューは、増分的ではなく定期的にクエリを実行し、クエリ結果セットを保存することで高速な取得を実現します。

クエリのパフォーマンスが重要である場合(例:ミリ秒未満のレイテンシ)で、わずかに古い結果が許容される場合に最も有用です。クエリは完全に再実行されるため、リフレッシュ可能なビューは、計算が比較的高速なクエリ、または低頻度の間隔(例:1時間ごと)で計算できるクエリに最適です。例えば、「上位N件」の結果やルックアップテーブルのキャッシュなどが該当します。

実行頻度は、システムへの過度な負荷を避けるために慎重に調整する必要があります。大量のリソースを消費する非常に複雑なクエリは、慎重にスケジュールする必要があります。これらはキャッシュに影響を与え、CPUとメモリを消費することで、クラスタ全体のパフォーマンスを低下させる可能性があります。クラスタへの過負荷を避けるため、クエリはリフレッシュ間隔に比べて比較的短時間で実行される必要があります。例えば、クエリ自体の計算に少なくとも10秒かかる場合、ビューを10秒ごとに更新するようにスケジュールしないでください。


## まとめ {#summary}

まとめると、リフレッシュ可能なマテリアライズドビューは以下の場合に使用します：

- クエリ結果を即座に利用できるようキャッシュする必要があり、データの鮮度にわずかな遅延が許容される場合。
- クエリ結果セットの上位N件が必要な場合。
- 結果セットのサイズが時間とともに無制限に増加しない場合。無制限に増加すると、ターゲットビューのパフォーマンスが低下します。
- 複数のテーブルを含む複雑な結合や非正規化を実行しており、ソーステーブルのいずれかが変更されるたびに更新が必要な場合。
- バッチワークフロー、非正規化タスク、またはDBT DAGに類似したビュー依存関係を構築している場合。

リフレッシュ可能なマテリアライズドビューの例については、[こちら](/materialized-view/refreshable-materialized-view)を参照してください。

### APPENDモード vs REPLACEモード {#append-vs-replace-mode}

リフレッシュ可能なマテリアライズドビューは、ターゲットテーブルへのデータ書き込みに2つのモードをサポートしています：`APPEND`と`REPLACE`です。これらのモードは、ビューがリフレッシュされる際にビューのクエリ結果がどのように書き込まれるかを定義します。

`REPLACE`はデフォルトの動作です。ビューがリフレッシュされるたびに、ターゲットテーブルの以前の内容は最新のクエリ結果で完全に上書きされます。これは、結果セットのキャッシュなど、ビューが常に最新の状態を反映すべきユースケースに適しています。

対照的に、`APPEND`は内容を置き換える代わりに、ターゲットテーブルの末尾に新しい行を追加します。これにより、定期的なスナップショットの取得など、追加のユースケースが可能になります。`APPEND`は、各リフレッシュが特定の時点を表す場合や、結果の履歴的な蓄積が必要な場合に特に有用です。

以下の場合は`APPEND`モードを選択してください：

- 過去のリフレッシュの履歴を保持したい場合。
- 定期的なスナップショットやレポートを構築している場合。
- 時間の経過とともにリフレッシュされた結果を段階的に収集する必要がある場合。

以下の場合は`REPLACE`モードを選択してください：

- 最新の結果のみが必要な場合。
- 古いデータを完全に破棄すべき場合。
- ビューが現在の状態またはルックアップを表す場合。

`APPEND`機能の応用例は、[Medallionアーキテクチャ](https://clickhouse.com/blog/building-a-medallion-architecture-for-bluesky-json-data-with-clickhouse)を構築する際に見つけることができます。

---
slug: /best-practices/use-materialized-views
sidebar_position: 10
sidebar_label: 'マテリアライズドビューの活用'
title: 'マテリアライズドビューの活用'
description: 'マテリアライズドビューについて説明するページ'
keywords: ['materialized views', 'medallion architecture']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import incremental_materialized_view from '@site/static/images/bestpractices/incremental_materialized_view.gif';
import refreshable_materialized_view from '@site/static/images/bestpractices/refreshable_materialized_view.gif';

ClickHouse は 2 種類のマテリアライズドビューをサポートします。すなわち、[**インクリメンタル**](/materialized-view/incremental-materialized-view) と [**リフレッシャブル**](/materialized-view/refreshable-materialized-view) です。どちらも結果を事前計算して保存することでクエリを高速化するよう設計されていますが、基盤となるクエリがどのように・いつ実行されるか、どのようなワークロードに適しているか、データの鮮度をどのように扱うかといった点で大きく異なります。

**ユーザーは、[データ型の選択](/best-practices/select-data-types) および [プライマリキー最適化](/best-practices/choosing-a-primary-key) に関する既存のベストプラクティスを適用済みであることを前提に、高速化が必要な特定のクエリパターンに対してマテリアライズドビューの利用を検討すべきです。**

**インクリメンタルマテリアライズドビュー**はリアルタイムで更新されます。ソーステーブルに新しいデータが挿入されると、ClickHouse は自動的にマテリアライズドビューのクエリを新しいデータブロックに適用し、その結果を別のターゲットテーブルに書き込みます。時間の経過とともに、ClickHouse はこれらの部分的な結果をマージして、完全かつ最新のビューを生成します。このアプローチは、計算コストを挿入時にシフトし、新しいデータだけを処理するため、非常に効率的です。その結果、ターゲットテーブルに対する `SELECT` クエリは高速かつ軽量になります。インクリメンタルビューはすべての集約関数をサポートし、各クエリが挿入されるデータセットの新しい小さなサブセットのみを処理するため、ペタバイト規模まで良好にスケールします。

<Image img={incremental_materialized_view} size="lg" alt="マテリアライズドビュー" />

**リフレッシャブルマテリアライズドビュー**は、対照的に、スケジュールに基づいて更新されます。これらのビューは、定期的にクエリ全体を再実行し、その結果でターゲットテーブルを上書きします。これは Postgres のような従来の OLTP データベースにおけるマテリアライズドビューと類似しています。

<Image img={refreshable_materialized_view} size="lg" alt="リフレッシャブルマテリアライズドビューの図" />

インクリメンタルマテリアライズドビューとリフレッシャブルマテリアライズドビューのどちらを選択するかは、主にクエリの性質、データがどの程度頻繁に変化するか、ビューの更新が挿入される各行を逐一反映する必要があるか、それとも定期的なリフレッシュで許容できるかに大きく依存します。これらのトレードオフを理解することは、ClickHouse で高性能かつスケーラブルなマテリアライズドビューを設計するうえで重要です。


## インクリメンタルマテリアライズドビューを使用するタイミング {#when-to-use-incremental-materialized-views}

インクリメンタルマテリアライズドビューは一般的に推奨されます。ソーステーブルが新しいデータを受信するたびに、リアルタイムで自動的に更新されるためです。すべての集約関数をサポートし、単一テーブルに対する集約に特に効果的です。挿入時に結果を段階的に計算することで、クエリは大幅に小さなデータサブセットに対して実行されるため、これらのビューはペタバイト規模のデータでも容易にスケールできます。ほとんどの場合、クラスタ全体のパフォーマンスに顕著な影響を与えることはありません。

インクリメンタルマテリアライズドビューを使用するタイミング:

- 挿入のたびに更新されるリアルタイムのクエリ結果が必要な場合
- 大量のデータを頻繁に集約またはフィルタリングする場合
- クエリが単一テーブルに対する単純な変換または集約を含む場合

インクリメンタルマテリアライズドビューの例については、[こちら](/materialized-view/incremental-materialized-view)を参照してください。


## リフレッシュ可能なマテリアライズドビューを使用するタイミング {#when-to-use-refreshable-materialized-views}

リフレッシュ可能なマテリアライズドビューは、増分的ではなく定期的にクエリを実行し、クエリ結果セットを保存することで高速な取得を実現します。

クエリのパフォーマンスが重要である場合（例：ミリ秒未満のレイテンシ）で、わずかに古い結果が許容される場合に最も有用です。クエリは完全に再実行されるため、リフレッシュ可能なビューは、比較的高速に計算できるクエリ、または低頻度の間隔（例：1時間ごと）で計算できるクエリに最適です。例えば、「上位N件」の結果やルックアップテーブルのキャッシュなどが該当します。

実行頻度は、システムへの過度な負荷を避けるために慎重に調整する必要があります。大量のリソースを消費する非常に複雑なクエリは、慎重にスケジュールする必要があります。これらはキャッシュに影響を与え、CPUとメモリを消費することで、クラスタ全体のパフォーマンスを低下させる可能性があります。クラスタへの過負荷を避けるため、クエリはリフレッシュ間隔に比べて比較的短時間で実行される必要があります。例えば、クエリ自体の計算に少なくとも10秒かかる場合、ビューを10秒ごとに更新するようにスケジュールしないでください。


## まとめ {#summary}

まとめると、リフレッシュ可能なマテリアライズドビューは以下の場合に使用します:

- クエリ結果を即座に利用できるようキャッシュする必要があり、データの鮮度にわずかな遅延が許容される場合。
- クエリ結果セットの上位N件が必要な場合。
- 結果セットのサイズが時間とともに無制限に増大しない場合。無制限に増大すると、ターゲットビューのパフォーマンスが低下します。
- 複数のテーブルを含む複雑な結合や非正規化を実行しており、ソーステーブルのいずれかが変更されるたびに更新が必要な場合。
- バッチワークフロー、非正規化タスク、またはDBT DAGに類似したビュー依存関係を構築している場合。

リフレッシュ可能なマテリアライズドビューの例については、[こちら](/materialized-view/refreshable-materialized-view)を参照してください。

### APPENDモード vs REPLACEモード {#append-vs-replace-mode}

リフレッシュ可能なマテリアライズドビューは、ターゲットテーブルへのデータ書き込みに2つのモードをサポートしています:`APPEND`と`REPLACE`です。これらのモードは、ビューがリフレッシュされる際にビューのクエリ結果がどのように書き込まれるかを定義します。

`REPLACE`はデフォルトの動作です。ビューがリフレッシュされるたびに、ターゲットテーブルの以前の内容は最新のクエリ結果で完全に上書きされます。これは、結果セットのキャッシュなど、ビューが常に最新の状態を反映すべきユースケースに適しています。

対照的に、`APPEND`は内容を置き換える代わりに、ターゲットテーブルの末尾に新しい行を追加することを可能にします。これにより、定期的なスナップショットの取得など、追加のユースケースが可能になります。`APPEND`は、各リフレッシュが特定の時点を表す場合や、結果の履歴的な蓄積が望まれる場合に特に有用です。

`APPEND`モードを選択する場合:

- 過去のリフレッシュの履歴を保持したい場合。
- 定期的なスナップショットやレポートを構築している場合。
- 時間の経過とともにリフレッシュされた結果を段階的に収集する必要がある場合。

`REPLACE`モードを選択する場合:

- 最新の結果のみが必要な場合。
- 古いデータを完全に破棄すべき場合。
- ビューが現在の状態またはルックアップを表す場合。

ユーザーは、[Medallionアーキテクチャ](https://clickhouse.com/blog/building-a-medallion-architecture-for-bluesky-json-data-with-clickhouse)を構築する際に、`APPEND`機能の応用例を見つけることができます。

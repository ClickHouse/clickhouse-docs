---
slug: /best-practices/use-materialized-views
sidebar_position: 10
sidebar_label: 'マテリアライズドビューを使用する'
title: 'マテリアライズドビューを使用する'
description: 'マテリアライズドビューを説明するページ'
keywords: ['materialized views', 'medallion architecture']
show_related_blogs: true
doc_type: 'guide'
---

import Image from '@theme/IdealImage';
import incremental_materialized_view from '@site/static/images/bestpractices/incremental_materialized_view.gif';
import refreshable_materialized_view from '@site/static/images/bestpractices/refreshable_materialized_view.gif';

ClickHouse は 2 種類のマテリアライズドビューをサポートしています：[**インクリメンタル**](/materialized-view/incremental-materialized-view) と [**リフレッシャブル**](/materialized-view/refreshable-materialized-view) です。どちらも結果を事前計算して保存することでクエリを高速化するように設計されていますが、基盤となるクエリがどのように・いつ実行されるか、どのようなワークロードに適しているか、そしてデータの鮮度をどのように扱うかが大きく異なります。

**ユーザーは、[型に関するベストプラクティス](/best-practices/select-data-types) および [主キーの最適化](/best-practices/choosing-a-primary-key) を実施済みであることを前提に、高速化が必要な特定のクエリパターンに対してマテリアライズドビューの利用を検討すべきです。**

**インクリメンタルマテリアライズドビュー** はリアルタイムで更新されます。新しいデータがソーステーブルに挿入されると、ClickHouse は自動的にその新しいデータブロックに対してマテリアライズドビューのクエリを適用し、結果を別のターゲットテーブルに書き込みます。時間の経過とともに、ClickHouse はこれらの部分的な結果をマージし、完全で最新のビューを生成します。このアプローチは、計算コストを挿入時に移し、新しいデータのみを処理するため、非常に効率的です。その結果、ターゲットテーブルに対する `SELECT` クエリは高速かつ軽量になります。インクリメンタルビューはすべての集約関数をサポートしており、各クエリが挿入されるデータセットの小さく直近のサブセットのみに対して動作するため、ペタバイト級のデータに対しても優れたスケーラビリティを発揮します。

<Image img={incremental_materialized_view} size="lg" alt="マテリアライズドビュー" />

**リフレッシャブルマテリアライズドビュー** は、これとは対照的に、スケジュールに基づいて更新されます。これらのビューは定期的にクエリ全体を再実行し、その結果でターゲットテーブルの内容を上書きします。これは、Postgres のような従来の OLTP データベースにおけるマテリアライズドビューと類似しています。

<Image img={refreshable_materialized_view} size="lg" alt="リフレッシャブルマテリアライズドビューの図" />

インクリメンタルマテリアライズドビューとリフレッシャブルマテリアライズドビューのどちらを選択するかは、主にクエリの性質、データの変更頻度、ビューの更新が挿入されたすべての行を即時に反映する必要があるか、それとも一定間隔でのリフレッシュで十分かによって決まります。これらのトレードオフを理解することが、ClickHouse において高性能かつスケーラブルなマテリアライズドビューを設計するうえで重要です。


## インクリメンタルマテリアライズドビューを使用するタイミング {#when-to-use-incremental-materialized-views}

インクリメンタルマテリアライズドビューは、ソーステーブルに新しいデータが挿入されるたびにリアルタイムで自動更新されるため、一般的に推奨されます。すべての集約関数をサポートしており、単一テーブルに対する集約に特に効果的です。挿入時に結果を段階的に計算することで、クエリは大幅に小さなデータサブセットに対して実行されるため、ペタバイト規模のデータでも容易にスケールできます。ほとんどの場合、クラスタ全体のパフォーマンスに目立った影響を与えることはありません。

インクリメンタルマテリアライズドビューを使用するタイミング:

- 挿入のたびに更新されるリアルタイムのクエリ結果が必要な場合
- 大量のデータを頻繁に集約またはフィルタリングする場合
- 単一テーブルに対する単純な変換または集約を含むクエリの場合

インクリメンタルマテリアライズドビューの例については、[こちら](/materialized-view/incremental-materialized-view)を参照してください。


## リフレッシュ可能なマテリアライズドビューを使用するタイミング {#when-to-use-refreshable-materialized-views}

リフレッシュ可能なマテリアライズドビューは、増分的ではなく定期的にクエリを実行し、クエリ結果セットを保存することで高速な取得を実現します。

クエリのパフォーマンスが重要である場合(例:ミリ秒未満のレイテンシ)で、わずかに古い結果が許容される場合に最も有用です。クエリは完全に再実行されるため、リフレッシュ可能なビューは、比較的高速に計算できるクエリ、または低頻度の間隔(例:1時間ごと)で計算できるクエリに最適です。例えば、「上位N件」の結果やルックアップテーブルのキャッシュなどが該当します。

実行頻度は、システムへの過度な負荷を避けるために慎重に調整する必要があります。大量のリソースを消費する極めて複雑なクエリは、慎重にスケジュールする必要があります。これらはキャッシュに影響を与え、CPUとメモリを消費することで、クラスタ全体のパフォーマンスを低下させる可能性があります。クラスタへの過負荷を避けるため、クエリはリフレッシュ間隔に比べて比較的短時間で実行される必要があります。例えば、クエリ自体の計算に少なくとも10秒かかる場合、ビューを10秒ごとに更新するようにスケジュールしないでください。


## まとめ {#summary}

まとめると、更新可能なマテリアライズドビューは以下の場合に使用します:

- クエリ結果を即座に利用できるようキャッシュする必要があり、データの鮮度にわずかな遅延が許容される場合。
- クエリ結果セットの上位N件が必要な場合。
- 結果セットのサイズが時間とともに無制限に増大しない場合。無制限に増大すると、対象ビューのパフォーマンスが低下します。
- 複数のテーブルを含む複雑な結合や非正規化を実行しており、ソーステーブルのいずれかが変更されるたびに更新が必要な場合。
- バッチワークフロー、非正規化タスク、またはDBT DAGに類似したビュー依存関係を構築している場合。

更新可能なマテリアライズドビューの例については、[こちら](/materialized-view/refreshable-materialized-view)を参照してください。

### APPENDモードとREPLACEモード {#append-vs-replace-mode}

更新可能なマテリアライズドビューは、対象テーブルへのデータ書き込みに2つのモード(`APPEND`と`REPLACE`)をサポートしています。これらのモードは、ビューが更新される際にビューのクエリ結果がどのように書き込まれるかを定義します。

`REPLACE`はデフォルトの動作です。ビューが更新されるたびに、対象テーブルの以前の内容は最新のクエリ結果で完全に上書きされます。これは、結果セットのキャッシュなど、ビューが常に最新の状態を反映すべきユースケースに適しています。

対照的に、`APPEND`は内容を置き換える代わりに、対象テーブルの末尾に新しい行を追加することを可能にします。これにより、定期的なスナップショットの取得など、追加のユースケースが実現できます。`APPEND`は、各更新が特定の時点を表す場合や、結果の履歴的な蓄積が必要な場合に特に有用です。

以下の場合は`APPEND`モードを選択してください:

- 過去の更新履歴を保持したい場合。
- 定期的なスナップショットやレポートを構築している場合。
- 時間の経過とともに更新された結果を段階的に収集する必要がある場合。

以下の場合は`REPLACE`モードを選択してください:

- 最新の結果のみが必要な場合。
- 古いデータを完全に破棄すべき場合。
- ビューが現在の状態または参照を表す場合。

`APPEND`機能の応用例は、[Medallionアーキテクチャ](https://clickhouse.com/blog/building-a-medallion-architecture-for-bluesky-json-data-with-clickhouse)を構築する際に見つけることができます。

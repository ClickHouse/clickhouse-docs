---
slug: /optimize/skipping-indexes
sidebar_label: 'データスキッピングインデックス'
sidebar_position: 2
description: 'スキップインデックスにより、ClickHouse は一致する値が存在しないことが保証されている大きなデータチャンクの読み取りをスキップできます。'
title: 'ClickHouse のデータスキッピングインデックスを理解する'
doc_type: 'guide'
keywords: ['skipping indexes', 'data skipping', 'performance', 'indexing', 'best practices']
---

import simple_skip from '@site/static/images/guides/best-practices/simple_skip.png';
import bad_skip from '@site/static/images/guides/best-practices/bad_skip.png';
import Image from '@theme/IdealImage';


# ClickHouse のデータスキップインデックスを理解する



## はじめに {#introduction}

ClickHouseのクエリパフォーマンスには多くの要因が影響します。ほとんどのシナリオにおいて重要な要素は、クエリのWHERE句の条件を評価する際にClickHouseがプライマリキーを使用できるかどうかです。したがって、最も一般的なクエリパターンに適したプライマリキーを選択することが、効果的なテーブル設計には不可欠です。

それにもかかわらず、プライマリキーをどれほど慎重に調整しても、それを効率的に使用できないクエリのユースケースは必然的に発生します。ユーザーは時系列型データにClickHouseを利用することが一般的ですが、顧客ID、WebサイトURL、製品番号などの他のビジネスディメンションに従って同じデータを分析したいと考えることがよくあります。その場合、WHERE句の条件を適用するために各カラム値の全スキャンが必要になる可能性があるため、クエリパフォーマンスが著しく低下することがあります。このような状況でもClickHouseは比較的高速ですが、数百万または数十億の個別の値を評価する必要があるため、「インデックスなし」のクエリはプライマリキーに基づくクエリよりもはるかに遅く実行されます。

従来のリレーショナルデータベースでは、この問題に対する1つのアプローチとして、テーブルに1つ以上の「セカンダリ」インデックスを付加する方法があります。これはB-tree構造であり、データベースがディスク上の一致するすべての行をO(n)時間(テーブルスキャン)ではなくO(log(n))時間で見つけることを可能にします。ここでnは行数です。しかし、この種のセカンダリインデックスは、ClickHouse(または他のカラム指向データベース)では機能しません。なぜなら、インデックスに追加するための個別の行がディスク上に存在しないためです。

代わりに、ClickHouseは異なるタイプのインデックスを提供しており、特定の状況下ではクエリ速度を大幅に向上させることができます。これらの構造は「Skip」インデックスと呼ばれています。一致する値が存在しないことが保証されている大量のデータチャンクの読み取りをClickHouseがスキップできるようにするためです。


## 基本的な動作 {#basic-operation}

データスキップインデックスはMergeTreeファミリーのテーブルでのみ使用できます。各データスキップインデックスには4つの主要な引数があります:

- インデックス名。インデックス名は各パーティションでインデックスファイルを作成する際に使用されます。また、インデックスの削除やマテリアライズ時のパラメータとしても必要です。
- インデックス式。インデックス式はインデックスに格納される値のセットを計算するために使用されます。カラムの組み合わせ、単純な演算子、および/またはインデックスタイプによって決定される関数のサブセットを含めることができます。
- TYPE。インデックスのタイプは、各インデックスブロックの読み取りと評価をスキップできるかどうかを判断する計算を制御します。
- GRANULARITY。各インデックスブロックはGRANULARITY個のグラニュールで構成されます。例えば、プライマリテーブルインデックスのグラニュラリティが8192行で、インデックスのグラニュラリティが4の場合、各インデックス「ブロック」は32768行になります。

ユーザーがデータスキップインデックスを作成すると、テーブルの各データパートディレクトリに2つの追加ファイルが作成されます。

- `skp_idx_{index_name}.idx` - 順序付けられた式の値を含む
- `skp_idx_{index_name}.mrk2` - 関連するデータカラムファイルへの対応するオフセットを含む

クエリを実行して関連するカラムファイルを読み取る際に、WHERE句のフィルタリング条件の一部がスキップインデックス式と一致する場合、ClickHouseはインデックスファイルのデータを使用して、各関連データブロックを処理する必要があるか、またはバイパスできるかを判断します(ブロックがプライマリキーの適用によってすでに除外されていないことを前提とします)。非常に単純化された例として、予測可能なデータがロードされた次のテーブルを考えてみましょう。

```sql
CREATE TABLE skip_table
(
  my_key UInt64,
  my_value UInt64
)
ENGINE MergeTree primary key my_key
SETTINGS index_granularity=8192;

INSERT INTO skip_table SELECT number, intDiv(number,4096) FROM numbers(100000000);
```

プライマリキーを使用しない単純なクエリを実行すると、`my_value`カラムの1億件のエントリすべてがスキャンされます:

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.079 sec. Processed 100.00 million rows, 800.10 MB (1.26 billion rows/s., 10.10 GB/s.
```

次に、非常に基本的なスキップインデックスを追加します:

```sql
ALTER TABLE skip_table ADD INDEX vix my_value TYPE set(100) GRANULARITY 2;
```

通常、スキップインデックスは新しく挿入されたデータにのみ適用されるため、インデックスを追加するだけでは上記のクエリには影響しません。

既存のデータにインデックスを付けるには、次のステートメントを使用します:

```sql
ALTER TABLE skip_table MATERIALIZE INDEX vix;
```

新しく作成されたインデックスを使用してクエリを再実行します:

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.051 sec. Processed 32.77 thousand rows, 360.45 KB (643.75 thousand rows/s., 7.08 MB/s.)
```

800メガバイトの1億行を処理する代わりに、ClickHouseは360キロバイトの32768行のみを読み取って分析しました
-- それぞれ8192行の4つのグラニュールです。

より視覚的な形式で示すと、`my_value`が125である4096行がどのように読み取られて選択され、その後の行がディスクから読み取られることなくスキップされたかは次のとおりです:

<Image img={simple_skip} size='md' alt='Simple Skip' />

ユーザーは、クエリ実行時にトレースを有効にすることで、スキップインデックスの使用に関する詳細情報にアクセスできます。clickhouse-clientから、`send_logs_level`を設定します:

```sql
SET send_logs_level='trace';
```

これにより、クエリSQLとテーブルインデックスをチューニングする際に有用なデバッグ情報が提供されます。上記の例では、デバッグログはスキップインデックスが2つのグラニュールを除くすべてを除外したことを示しています:


```sql
<Debug> default.skip_table (933d4b2c-8cea-4bf9-8c93-c56e900eefd1) (SelectExecutor): Index `vix` has dropped 6102/6104 granules.
```

## スキップインデックスの種類 {#skip-index-types}

<!-- vale off -->

### minmax {#minmax}

<!-- vale on -->

この軽量なインデックスタイプはパラメータを必要としません。各ブロックに対してインデックス式の最小値と最大値を格納します（式がタプルの場合、タプルの各要素のメンバーごとに値を個別に格納します）。このタイプは、値によって緩やかにソートされる傾向のあるカラムに最適です。このインデックスタイプは、通常、クエリ処理時に適用するコストが最も低くなります。

このタイプのインデックスは、スカラーまたはタプル式でのみ正しく機能します。配列またはマップデータ型を返す式には、インデックスは適用されません。

<!-- vale off -->

### set {#set}

<!-- vale on -->

この軽量なインデックスタイプは、ブロックごとの値セットの max_size という単一のパラメータを受け取ります（0 は無制限の個別値を許可します）。このセットにはブロック内のすべての値が含まれます（値の数が max_size を超える場合は空になります）。このインデックスタイプは、各グラニュールセット内でのカーディナリティが低い（本質的に「まとまっている」）が、全体的にはカーディナリティが高いカラムに適しています。

このインデックスのコスト、パフォーマンス、および効果は、ブロック内のカーディナリティに依存します。各ブロックに多数の一意の値が含まれている場合、大きなインデックスセットに対してクエリ条件を評価するコストが非常に高くなるか、max_size を超えたためにインデックスが空になり、インデックスが適用されません。

### Bloomフィルタータイプ {#bloom-filter-types}

_Bloomフィルター_ は、わずかな偽陽性の可能性を代償として、空間効率的な集合メンバーシップのテストを可能にするデータ構造です。スキップインデックスの場合、偽陽性は重大な懸念事項ではありません。なぜなら、唯一の欠点は不要なブロックをいくつか読み取ることだけだからです。ただし、偽陽性の可能性があるということは、インデックス式が真であることが期待されるべきであることを意味します。そうでなければ、有効なデータがスキップされる可能性があります。

Bloomフィルターは多数の個別値のテストをより効率的に処理できるため、テストする値をより多く生成する条件式に適しています。特に、Bloomフィルターインデックスは、配列のすべての値がテストされる配列や、mapKeys または mapValues 関数を使用してキーまたは値を配列に変換することでマップに適用できます。

Bloomフィルターに基づくデータスキップインデックスには3つのタイプがあります：

- 基本的な **bloom_filter** は、0 から 1 の間の許容される「偽陽性」率の単一のオプションパラメータを取ります（指定されていない場合、.025 が使用されます）。

- 特化型の **tokenbf_v1**。使用される Bloom フィルターのチューニングに関連する3つのパラメータを取ります：(1) フィルターのサイズ（バイト単位）（大きなフィルターは偽陽性が少なくなりますが、ストレージコストがかかります）、(2) 適用されるハッシュ関数の数（同様に、より多くのハッシュ関数は偽陽性を減らします）、(3) Bloom フィルターハッシュ関数のシード値。これらのパラメータが Bloom フィルターの機能にどのように影響するかの詳細については、[こちら](https://hur.st/bloomfilter/)の計算機を参照してください。
  このインデックスは、String、FixedString、および Map データ型でのみ機能します。入力式は、英数字以外の文字で区切られた文字列シーケンスに分割されます。たとえば、`This is a candidate for a "full text" search` というカラム値には、`This` `is` `a` `candidate` `for` `full` `text` `search` というトークンが含まれます。これは、LIKE、EQUALS、IN、hasToken() および長い文字列内の単語やその他の値を検索する類似の検索での使用を目的としています。たとえば、自由形式のアプリケーションログ行のカラム内で少数のクラス名や行番号を検索する場合などに使用できます。

- 特化型の **ngrambf_v1**。このインデックスはトークンインデックスと同じように機能します。Bloom フィルター設定の前に、インデックス化する ngram のサイズという追加パラメータを1つ取ります。ngram は任意の文字からなる長さ `n` の文字列であり、ngram サイズが 4 の場合、文字列 `A short string` は次のようにインデックス化されます：
  ```text
  'A sh', ' sho', 'shor', 'hort', 'ort ', 'rt s', 't st', ' str', 'stri', 'trin', 'ring'
  ```
  このインデックスは、特に中国語のような単語区切りのない言語において、テキスト検索にも有用です。


## スキップインデックス関数 {#skip-index-functions}

データスキップインデックスの主な目的は、よく使用されるクエリで解析されるデータ量を制限することです。ClickHouseデータの分析的な性質を考えると、これらのクエリのパターンには多くの場合、関数式が含まれます。したがって、スキップインデックスが効率的に機能するには、一般的な関数と正しく連携する必要があります。これは次のいずれかの場合に発生します:

- データが挿入され、インデックスが関数式として定義されている場合(式の結果がインデックスファイルに保存される)
- クエリが処理され、保存されたインデックス値に式が適用されて、ブロックを除外するかどうかが判断される場合

各タイプのスキップインデックスは、[こちら](/engines/table-engines/mergetree-family/mergetree/#functions-support)に記載されているインデックス実装に適した、利用可能なClickHouse関数のサブセットで動作します。一般的に、セットインデックスとBloomフィルタベースのインデックス(セットインデックスの別のタイプ)はどちらも順序付けされていないため、範囲指定では機能しません。対照的に、minmaxインデックスは範囲指定との相性が特に良く、範囲が交差するかどうかの判定が非常に高速だからです。部分一致関数であるLIKE、startsWith、endsWith、hasTokenの有効性は、使用されるインデックスタイプ、インデックス式、およびデータの具体的な形状に依存します。


## スキップインデックスの設定 {#skip-index-settings}

スキップインデックスに適用される設定は2つあります。

- **use_skip_indexes** (0または1、デフォルトは1)。すべてのクエリがスキップインデックスを効率的に使用できるわけではありません。特定のフィルタリング条件でほとんどのグラニュールが対象となる場合、データスキップインデックスの適用は不要なコストを招き、場合によっては大きなコストとなります。スキップインデックスの効果が期待できないクエリに対しては、値を0に設定してください。
- **force_data_skipping_indices** (インデックス名のカンマ区切りリスト)。この設定は、特定の種類の非効率なクエリを防ぐために使用できます。スキップインデックスを使用しない限りテーブルへのクエリが高コストになる状況では、この設定に1つ以上のインデックス名を指定することで、指定されたインデックスを使用しないクエリに対して例外を返します。これにより、不適切に記述されたクエリがサーバーリソースを消費することを防ぎます。


## スキップインデックスのベストプラクティス {#skip-best-practices}

スキップインデックスは直感的ではありません。特にRDBMSの行ベースのセカンダリインデックスやドキュメントストアの転置インデックスに慣れているユーザーにとってはそうです。ClickHouseのデータスキップインデックスから効果を得るには、インデックスの計算コストを相殺できるだけのグラニュール読み取りを回避する必要があります。重要な点として、インデックス化されたブロック内に値が一度でも出現すると、ブロック全体をメモリに読み込んで評価する必要があり、インデックスのコストが無駄に発生してしまいます。

次のデータ分布を考えてみましょう:

<Image img={bad_skip} size='md' alt='不適切なスキップ' />

プライマリキー/ORDER BYキーが`timestamp`であり、`visitor_id`にインデックスがあると仮定します。次のクエリを考えてみましょう:

```sql
SELECT timestamp, url FROM table WHERE visitor_id = 1001`
```

この種のデータ分布では、従来のセカンダリインデックスが非常に有利です。要求されたvisitor_idを持つ5行を見つけるために32768行すべてを読み取る代わりに、セカンダリインデックスには5つの行の位置のみが含まれ、それらの5行だけがディスクから読み取られます。ClickHouseのデータスキップインデックスでは、まったく逆のことが当てはまります。スキップインデックスの種類に関係なく、`visitor_id`列の32768個すべての値がテストされます。

したがって、主要な列にインデックスを追加するだけでClickHouseクエリを高速化しようとする自然な発想は、多くの場合誤りです。この高度な機能は、プライマリキーの変更([プライマリキーの選び方](../best-practices/sparse-primary-indexes.md)を参照)、プロジェクションの使用、マテリアライズドビューの使用など、他の代替手段を検討した後にのみ使用すべきです。データスキップインデックスが適切な場合でも、インデックスとテーブルの両方を慎重にチューニングする必要があることが多くあります。

ほとんどの場合、有用なスキップインデックスには、プライマリキーと対象となる非プライマリ列/式との間に強い相関関係が必要です。
相関関係がない場合(上図のように)、数千の値のブロック内の少なくとも1つの行でフィルタリング条件が満たされる可能性が高く、スキップされるブロックはわずかです。対照的に、プライマリキーの値の範囲(時刻など)が潜在的なインデックス列の値(テレビ視聴者の年齢など)と強く関連している場合、minmaxタイプのインデックスが有益である可能性が高くなります。データを挿入する際に、ソート/ORDER BYキーに追加の列を含めるか、プライマリキーに関連する値が挿入時にグループ化されるようにバッチで挿入することで、この相関関係を高めることができる場合があることに注意してください。たとえば、プライマリキーが多数のサイトからのイベントを含むタイムスタンプであっても、特定のsite_idのすべてのイベントをインジェストプロセスによってグループ化して一緒に挿入できます。これにより、少数のsite_idのみを含む多くのグラニュールが生成されるため、特定のsite_id値で検索する際に多くのブロックをスキップできます。

スキップインデックスのもう1つの適切な候補は、データ内で任意の1つの値が比較的まばらである高カーディナリティの式です。1つの例として、APIリクエストのエラーコードを追跡する可観測性プラットフォームが挙げられます。特定のエラーコードは、データ内ではまれですが、検索において特に重要である可能性があります。error_code列にセットスキップインデックスを設定すると、エラーを含まない大部分のブロックをバイパスできるため、エラーに焦点を当てたクエリを大幅に改善できます。

最後に、重要なベストプラクティスはテスト、テスト、テストです。繰り返しになりますが、B-treeセカンダリインデックスやドキュメント検索用の転置インデックスとは異なり、データスキップインデックスの動作は簡単には予測できません。テーブルに追加すると、データインジェストと、さまざまな理由でインデックスの恩恵を受けないクエリの両方に意味のあるコストが発生します。常に実際のデータで検証する必要があり、テストには種類、グラニュラリティサイズ、その他のパラメータのバリエーションを含める必要があります。テストは、思考実験だけでは明らかでないパターンや落とし穴を明らかにすることが多くあります。


## 関連ドキュメント {#related-docs}

- [ベストプラクティスガイド](/best-practices/use-data-skipping-indices-where-appropriate)
- [データスキップインデックスの例](/optimize/skipping-indexes/examples)
- [データスキップインデックスの操作](/sql-reference/statements/alter/skipping-index)
- [システムテーブル情報](/operations/system-tables/data_skipping_indices)

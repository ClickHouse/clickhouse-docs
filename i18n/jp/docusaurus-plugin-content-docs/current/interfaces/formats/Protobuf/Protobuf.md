---
alias: []
description: 'Protobuf 形式のドキュメント'
input_format: true
keywords: ['Protobuf']
output_format: true
slug: /interfaces/formats/Protobuf
title: 'Protobuf'
doc_type: 'guide'
---

| 入力 | 出力 | エイリアス |
|-------|--------|-------|
| ✔     | ✔      |       |



## 説明 {#description}

`Protobuf`フォーマットは[Protocol Buffers](https://protobuf.dev/)フォーマットです。

このフォーマットは外部フォーマットスキーマを必要とし、クエリ間でキャッシュされます。

ClickHouseは以下をサポートしています:

- `proto2`と`proto3`の両方の構文
- `Repeated`/`optional`/`required`フィールド

テーブルカラムとProtocol Buffersのメッセージタイプのフィールド間の対応関係を見つけるため、ClickHouseはそれらの名前を比較します。
この比較は大文字小文字を区別せず、`_`(アンダースコア)と`.`(ドット)の文字は同等とみなされます。
カラムの型とProtocol Buffersメッセージのフィールドの型が異なる場合、必要な変換が適用されます。

ネストされたメッセージがサポートされています。例えば、以下のメッセージタイプのフィールド`z`の場合:

```capnp
message MessageType {
  message XType {
    message YType {
      int32 z;
    };
    repeated YType y;
  };
  XType x;
};
```

ClickHouseは`x.y.z`(または`x_y_z`や`X.y_Z`など)という名前のカラムを見つけようとします。

ネストされたメッセージは[ネストされたデータ構造](/sql-reference/data-types/nested-data-structures/index.md)の入力または出力に適しています。

以下のようなprotobufスキーマで定義されたデフォルト値は適用されず、代わりに[テーブルのデフォルト値](/sql-reference/statements/create/table#default_values)が使用されます:

```capnp
syntax = "proto2";

message MessageType {
  optional int32 result_per_page = 3 [default = 10];
}
```

メッセージに[oneof](https://protobuf.dev/programming-guides/proto3/#oneof)が含まれ、`input_format_protobuf_oneof_presence`が設定されている場合、ClickHouseはoneofのどのフィールドが見つかったかを示すカラムを埋めます。

```capnp
syntax = "proto3";

message StringOrString {
  oneof string_oneof {
    string string1 = 1;
    string string2 = 42;
  }
}
```

```sql
CREATE TABLE string_or_string ( string1 String, string2 String, string_oneof Enum('no'=0, 'hello' = 1, 'world' = 42))  Engine=MergeTree ORDER BY tuple();
INSERT INTO string_or_string from INFILE '$CURDIR/data_protobuf/String1' SETTINGS format_schema='$SCHEMADIR/string_or_string.proto:StringOrString' FORMAT ProtobufSingle;
SELECT * FROM string_or_string
```

```text
   ┌─────────┬─────────┬──────────────┐
   │ string1 │ string2 │ string_oneof │
   ├─────────┼─────────┼──────────────┤
1. │         │ string2 │ world        │
   ├─────────┼─────────┼──────────────┤
2. │ string1 │         │ hello        │
   └─────────┴─────────┴──────────────┘
```

存在を示すカラムの名前はoneofの名前と同じでなければなりません。ネストされたメッセージもサポートされています([basic-examples](#basic-examples)を参照)。
許可される型はInt8、UInt8、Int16、UInt16、Int32、UInt32、Int64、UInt64、Enum、Enum8、またはEnum16です。
Enum(およびEnum8またはEnum16)は、oneofの可能なすべてのタグに加えて、不在を示す0を含む必要があります。文字列表現は問いません。

設定[`input_format_protobuf_oneof_presence`](/operations/settings/settings-formats.md#input_format_protobuf_oneof_presence)はデフォルトで無効になっています。

ClickHouseは`length-delimited`フォーマットでprotobufメッセージを入出力します。
これは、各メッセージの前にその長さを[可変幅整数(varint)](https://developers.google.com/protocol-buffers/docs/encoding#varints)として書き込む必要があることを意味します。


## 使用例 {#example-usage}

### データの読み書き {#basic-examples}

:::note サンプルファイル
この例で使用するファイルは[examplesリポジトリ](https://github.com/ClickHouse/formats/ProtoBuf)から入手できます
:::

この例では、`protobuf_message.bin`ファイルからClickHouseテーブルにデータを読み込みます。その後、`Protobuf`形式を使用して`protobuf_message_from_clickhouse.bin`というファイルに書き戻します。

`schemafile.proto`ファイルが以下のように定義されているとします:

```capnp
syntax = "proto3";

message MessageType {
  string name = 1;
  string surname = 2;
  uint32 birthDate = 3;
  repeated string phoneNumbers = 4;
};
```

<details>
<summary>バイナリファイルの生成</summary>
  
`Protobuf`形式でのデータのシリアライズおよびデシリアライズ方法をすでにご存知の場合は、この手順をスキップできます。

Pythonを使用してデータを`protobuf_message.bin`にシリアライズし、ClickHouseに読み込みます。
他の言語を使用する場合は、["How to read/write length-delimited Protobuf messages in popular languages"](https://cwiki.apache.org/confluence/display/GEODE/Delimiting+Protobuf+Messages)も参照してください。

以下のコマンドを実行して、`schemafile.proto`と同じディレクトリに`schemafile_pb2.py`という名前のPythonファイルを生成します。このファイルには、`UserData` Protobufメッセージを表すPythonクラスが含まれています:

```bash
protoc --python_out=. schemafile.proto
```

次に、`schemafile_pb2.py`と同じディレクトリに`generate_protobuf_data.py`という名前の新しいPythonファイルを作成します。以下のコードを貼り付けます:

```python
import schemafile_pb2  # Module generated by 'protoc'
from google.protobuf import text_format
from google.protobuf.internal.encoder import _VarintBytes # Import the internal varint encoder

def create_user_data_message(name, surname, birthDate, phoneNumbers):
    """
    UserData Protobufメッセージを作成して値を設定します。
    """
    message = schemafile_pb2.MessageType()
    message.name = name
    message.surname = surname
    message.birthDate = birthDate
    message.phoneNumbers.extend(phoneNumbers)
    return message

```


# サンプルユーザーのデータ

data_to_serialize = [
{"name": "Aisha", "surname": "Khan", "birthDate": 19920815, "phoneNumbers": ["(555) 247-8903", "(555) 612-3457"]},
{"name": "Javier", "surname": "Rodriguez", "birthDate": 20001015, "phoneNumbers": ["(555) 891-2046", "(555) 738-5129"]},
{"name": "Mei", "surname": "Ling", "birthDate": 19980616, "phoneNumbers": ["(555) 956-1834", "(555) 403-7682"]},
]

output_filename = "protobuf_messages.bin"


# バイナリファイルをバイナリ書き込みモード（'wb'）で開く
with open(output_filename, "wb") as f:
    for item in data_to_serialize:
        # 現在のユーザー用の Protobuf メッセージインスタンスを作成
        message = create_user_data_message(
            item["name"],
            item["surname"],
            item["birthDate"],
            item["phoneNumbers"]
        )

        # メッセージをシリアル化
        serialized_data = message.SerializeToString()

        # シリアル化されたデータの長さを取得
        message_length = len(serialized_data)

        # Protobuf ライブラリの内部関数 _VarintBytes を使用して長さをエンコード
        length_prefix = _VarintBytes(message_length)

        # 長さプレフィックスを書き込む
        f.write(length_prefix)
        # シリアル化されたメッセージデータを書き込む
        f.write(serialized_data)

print(f"Protobuf メッセージ（長さ区切り）を {output_filename} に書き込みました")



# --- オプション: 検証（読み戻しと出力）---

# 読み戻しには、varint用の内部Protobufデコーダーも使用します。

from google.protobuf.internal.decoder import \_DecodeVarint32

print("\n--- 読み戻しによる検証 ---")
with open(output_filename, "rb") as f:
buf = f.read() # varintデコードを容易にするため、ファイル全体をバッファに読み込む
n = 0
while n < len(buf): # varint長プレフィックスをデコード
msg_len, new_pos = \_DecodeVarint32(buf, n)
n = new_pos

        # メッセージデータを抽出
        message_data = buf[n:n+msg_len]
        n += msg_len

        # メッセージを解析
        decoded_message = schemafile_pb2.MessageType()
        decoded_message.ParseFromString(message_data)
        print(text_format.MessageToString(decoded_message, as_utf8=True))

````

次に、コマンドラインからスクリプトを実行します。Python仮想環境から実行することを推奨します。例えば`uv`を使用する場合:

```bash
uv venv proto-venv
source proto-venv/bin/activate
````

以下のPythonライブラリをインストールする必要があります:

```bash
uv pip install --upgrade protobuf
```

スクリプトを実行してバイナリファイルを生成します:

```bash
python generate_protobuf_data.py
```

</details>

スキーマに一致するClickHouseテーブルを作成します:

```sql
CREATE DATABASE IF NOT EXISTS test;
CREATE TABLE IF NOT EXISTS test.protobuf_messages (
  name String,
  surname String,
  birthDate UInt32,
  phoneNumbers Array(String)
)
ENGINE = MergeTree()
ORDER BY tuple()
```

コマンドラインからテーブルにデータを挿入します:

```bash
cat protobuf_messages.bin | clickhouse-client --query "INSERT INTO test.protobuf_messages SETTINGS format_schema='schemafile:MessageType' FORMAT Protobuf"
```

`Protobuf`形式を使用してデータをバイナリファイルに書き戻すこともできます:

```sql
SELECT * FROM test.protobuf_messages INTO OUTFILE 'protobuf_message_from_clickhouse.bin' FORMAT Protobuf SETTINGS format_schema = 'schemafile:MessageType'
```

Protobufスキーマを使用して、ClickHouseからファイル`protobuf_message_from_clickhouse.bin`に書き出されたデータをデシリアライズできます。

### ClickHouse Cloudを使用したデータの読み書き {#basic-examples-cloud}

ClickHouse Cloudでは、Protobufスキーマファイルをアップロードすることはできません。ただし、`format_protobuf_schema`設定を使用してクエリ内でスキーマを指定できます。この例では、ローカルマシンからシリアライズされたデータを読み取り、ClickHouse Cloudのテーブルに挿入する方法を示します。

前の例と同様に、ClickHouse CloudでProtobufスキーマに従ってテーブルを作成します:

```sql
CREATE DATABASE IF NOT EXISTS test;
CREATE TABLE IF NOT EXISTS test.protobuf_messages (
  name String,
  surname String,
  birthDate UInt32,
  phoneNumbers Array(String)
)
ENGINE = MergeTree()
ORDER BY tuple()
```

`format_schema_source`設定は、`format_schema`設定のソースを定義します

使用可能な値:

- 'file'（デフォルト）: Cloudではサポートされていません
- 'string': `format_schema`はスキーマのリテラルコンテンツです。
- 'query': `format_schema`はスキーマを取得するためのクエリです。

### `format_schema_source='string'` {#format-schema-source-string}

スキーマを文字列として指定してClickHouse Cloudにデータを挿入するには、次を実行します:

```bash
cat protobuf_messages.bin | clickhouse client --host <hostname> --secure --password <password> --query "INSERT INTO testing.protobuf_messages SETTINGS format_schema_source='syntax = "proto3";message MessageType {  string name = 1;  string surname = 2;  uint32 birthDate = 3;  repeated string phoneNumbers = 4;};', format_schema='schemafile:MessageType' FORMAT Protobuf"
```

テーブルに挿入されたデータを選択します:

```sql
clickhouse client --host <hostname> --secure --password <password> --query "SELECT * FROM testing.protobuf_messages"
```

```response
Aisha Khan 19920815 ['(555) 247-8903','(555) 612-3457']
Javier Rodriguez 20001015 ['(555) 891-2046','(555) 738-5129']
Mei Ling 19980616 ['(555) 956-1834','(555) 403-7682']
```

### `format_schema_source='query'` {#format-schema-source-query}

Protobufスキーマをテーブルに保存することもできます。

データを挿入するためのテーブルをClickHouse Cloudに作成します:


```sql
CREATE TABLE testing.protobuf_schema (
  schema String
)
ENGINE = MergeTree()
ORDER BY tuple();
```

```sql
INSERT INTO testing.protobuf_schema VALUES ('syntax = "proto3";message MessageType {  string name = 1;  string surname = 2;  uint32 birthDate = 3;  repeated string phoneNumbers = 4;};');
```

スキーマを実行するクエリとして指定し、ClickHouse Cloudにデータを挿入します:

```bash
cat protobuf_messages.bin | clickhouse client --host <hostname> --secure --password <password> --query "INSERT INTO testing.protobuf_messages SETTINGS format_schema_source='SELECT schema FROM testing.protobuf_schema', format_schema='schemafile:MessageType' FORMAT Protobuf"
```

テーブルに挿入されたデータを取得します:

```sql
clickhouse client --host <hostname> --secure --password <password> --query "SELECT * FROM testing.protobuf_messages"
```

```response
Aisha Khan 19920815 ['(555) 247-8903','(555) 612-3457']
Javier Rodriguez 20001015 ['(555) 891-2046','(555) 738-5129']
Mei Ling 19980616 ['(555) 956-1834','(555) 403-7682']
```

### 自動生成スキーマの使用 {#using-autogenerated-protobuf-schema}

データに対する外部Protobufスキーマがない場合でも、自動生成されたスキーマを使用してProtobuf形式でデータを出力/入力できます。これには`format_protobuf_use_autogenerated_schema`設定を使用します。

例:

```sql
SELECT * FROM test.hits format Protobuf SETTINGS format_protobuf_use_autogenerated_schema=1
```

この場合、ClickHouseは[`structureToProtobufSchema`](/sql-reference/functions/other-functions#structureToProtobufSchema)関数を使用してテーブル構造に基づいてProtobufスキーマを自動生成します。その後、このスキーマを使用してデータをProtobuf形式でシリアライズします。

自動生成されたスキーマを使用してProtobufファイルを読み取ることもできます。この場合、ファイルは同じスキーマを使用して作成されている必要があります:

```bash
$ cat hits.bin | clickhouse-client --query "INSERT INTO test.hits SETTINGS format_protobuf_use_autogenerated_schema=1 FORMAT Protobuf"
```

[`format_protobuf_use_autogenerated_schema`](/operations/settings/settings-formats.md#format_protobuf_use_autogenerated_schema)設定はデフォルトで有効になっており、[`format_schema`](/operations/settings/formats#format_schema)が設定されていない場合に適用されます。

[`output_format_schema`](/operations/settings/formats#output_format_schema)設定を使用して、入出力時に自動生成されたスキーマをファイルに保存することもできます。例:

```sql
SELECT * FROM test.hits format Protobuf SETTINGS format_protobuf_use_autogenerated_schema=1, output_format_schema='path/to/schema/schema.proto'
```

この場合、自動生成されたProtobufスキーマは`path/to/schema/schema.capnp`ファイルに保存されます。

### Protobufキャッシュの削除 {#drop-protobuf-cache}

[`format_schema_path`](/operations/server-configuration-parameters/settings.md/#format_schema_path)から読み込まれたProtobufスキーマを再読み込みするには、[`SYSTEM DROP ... FORMAT CACHE`](/sql-reference/statements/system.md/#system-drop-schema-format)ステートメントを使用します。

```sql
SYSTEM DROP FORMAT SCHEMA CACHE FOR Protobuf
```

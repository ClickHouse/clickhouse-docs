---
slug: /merges
title: 'パーツマージ'
description: 'ClickHouse におけるパーツマージとは何か'
keywords: ['merges']
doc_type: 'guide'
---

import merges_01 from '@site/static/images/managing-data/core-concepts/merges_01.png';
import merges_02 from '@site/static/images/managing-data/core-concepts/merges_02.png';
import merges_03 from '@site/static/images/managing-data/core-concepts/merges_03.png';
import merges_04 from '@site/static/images/managing-data/core-concepts/merges_04.png';
import merges_05 from '@site/static/images/managing-data/core-concepts/merges_05.png';
import merges_06 from '@site/static/images/managing-data/core-concepts/merges_06.png';
import merges_07 from '@site/static/images/managing-data/core-concepts/merges_07.png';
import merges_dashboard from '@site/static/images/managing-data/core-concepts/merges-dashboard.gif';
import Image from '@theme/IdealImage';


## ClickHouse におけるパートマージとは？ \{#what-are-part-merges-in-clickhouse\}

<br/>

ClickHouse は、クエリだけでなくインサートも[高速](/concepts/why-clickhouse-is-so-fast)です。その理由は、[ストレージレイヤ](https://www.vldb.org/pvldb/vol17/p3731-schulze.pdf) にあり、これは [LSM tree](https://en.wikipedia.org/wiki/Log-structured_merge-tree) と同様の動作をします。

① （[MergeTree engine](/engines/table-engines/mergetree-family) ファミリーの）テーブルへのインサートは、ソート済みで不変の [data parts](/parts) を生成します。

② すべてのデータ処理は **バックグラウンドパートマージ** にオフロードされます。

これにより、データ書き込みは軽量で、[非常に効率的](/concepts/why-clickhouse-is-so-fast#storage-layer-concurrent-inserts-are-isolated-from-each-other)になります。

テーブルごとの ^^parts^^ の数を制御し、上記 ② を実現するために、ClickHouse はバックグラウンドで継続的に（[パーティション単位](/partitions#per-partition-merges)で）小さな ^^parts^^ を大きなものへとマージし、圧縮後のサイズがおよそ [~150 GB](/operations/settings/merge-tree-settings#max_bytes_to_merge_at_max_space_in_pool) に達するまで続けます。

次の図は、このバックグラウンドマージ処理の概要を示しています。

<Image img={merges_01} size="lg" alt="PART MERGES"/>

<br/>

`merge level` は、追加のマージが行われるたびに 1 ずつ増加します。`0` のレベルは、そのパートが新しく、まだマージされていないことを意味します。より大きな ^^parts^^ にマージされた元の ^^parts^^ は [inactive](/operations/system-tables/parts) とマークされ、最終的には [設定可能](/operations/settings/merge-tree-settings#old_parts_lifetime) な時間（デフォルトでは 8 分）後に削除されます。時間の経過とともに、これによりマージされた ^^parts^^ の **木構造** が形成されます。これが [merge tree](/engines/table-engines/mergetree-family) テーブルという名称の由来です。

## マージの監視

[テーブルパーツとは何か](/parts)の例では、ClickHouse がすべてのテーブル^^パーツ^^を [parts](/operations/system-tables/parts) システムテーブルで追跡していることを[示しました](/parts#monitoring-table-parts)。例に用いたテーブルについて、アクティブな各パーツごとのマージレベルと保存されている行数を取得するために、次のクエリを使用しました。

```sql
SELECT
    name,
    level,
    rows
FROM system.parts
WHERE (database = 'uk') AND (`table` = 'uk_price_paid_simple') AND active
ORDER BY name ASC;
```

[前に説明した](/parts#monitoring-table-parts)クエリ結果から、サンプルテーブルにはアクティブな ^^parts^^ が4つあり、それぞれは最初に挿入された ^^parts^^ を1回マージして作成されたものであることが分かります。

```response
   ┌─name────────┬─level─┬────rows─┐
1. │ all_0_5_1   │     1 │ 6368414 │
2. │ all_12_17_1 │     1 │ 6442494 │
3. │ all_18_23_1 │     1 │ 5977762 │
4. │ all_6_11_1  │     1 │ 6459763 │
   └─────────────┴───────┴─────────┘
```

[クエリを実行すると](https://sql.clickhouse.com/?query=U0VMRUNUCiAgICBuYW1lLAogICAgbGV2ZWwsCiAgICByb3dzCkZST00gc3lzdGVtLnBhcnRzCldIRVJFIChkYXRhYmFzZSA9ICd1aycpIEFORCAoYHRhYmxlYCA9ICd1a19wcmljZV9wYWlkX3NpbXBsZScpIEFORCBhY3RpdmUKT1JERVIgQlkgbmFtZSBBU0M7\&run_query=true\&tab=results) 、4 つの ^^parts^^ が、その後 1 つの最終 part にマージされたことがわかります（テーブルにこれ以上 insert が行われていない場合）:

```response
   ┌─name───────┬─level─┬─────rows─┐
1. │ all_0_23_2 │     2 │ 25248433 │
   └────────────┴───────┴──────────┘
```

ClickHouse 24.10 では、組み込みの [monitoring dashboards](https://clickhouse.com/blog/common-issues-you-can-solve-using-advanced-monitoring-dashboards) に新しい [merges dashboard](https://presentations.clickhouse.com/2024-release-24.10/index.html#17) が追加されました。OSS と Cloud の両方で `/merges` HTTP ハンドラー経由で利用でき、このダッシュボードを使ってサンプルテーブルに対するすべてのパートマージを可視化できます。

<Image img={merges_dashboard} size="lg" alt="パートマージ" />

<br />

上のダッシュボードは、最初のデータ挿入から最終的に 1 つのパートへマージされるまでの全プロセスを捉えています。

① アクティブな ^^parts^^ の数。

② パートマージ。ボックスで視覚的に表現されており（サイズはパートの大きさを反映しています）。

③ [Write amplification](https://en.wikipedia.org/wiki/Write_amplification)。


## 同時マージ \{#concurrent-merges\}

1 つの ClickHouse サーバーでは、複数のバックグラウンド[マージスレッド](/operations/server-configuration-parameters/settings#background_pool_size)を使用して、パーツのマージを並行して実行します。

<Image img={merges_02} size="lg" alt='パーツのマージ'/>

<br/>

各マージスレッドは次のループを実行します。

① 次にどの ^^パーツ^^ をマージするかを決定し、それらの ^^パーツ^^ をメモリに読み込みます。

② メモリ上で ^^パーツ^^ をマージして、より大きな 1 つのパーツにします。

③ マージされたパーツをディスクに書き込みます。

① に戻る

CPU コア数と RAM 容量を増やすことで、バックグラウンドマージのスループットを高めることができます。

## メモリ最適化されたマージ \{#memory-optimized-merges\}

ClickHouse は、[前の例](/merges#concurrent-merges)で示したように、マージ対象となるすべての ^^parts^^ を必ずしも一度にメモリへ読み込むわけではありません。いくつかの[要因](https://github.com/ClickHouse/ClickHouse/blob/bf37120c925ed846ae5cd72cd51e6340bebd2918/src/Storages/MergeTree/MergeTreeSettings.cpp#L210)に応じて、メモリ消費量を削減する（マージ速度を犠牲にする）ために、いわゆる[垂直マージ](https://github.com/ClickHouse/ClickHouse/blob/bf37120c925ed846ae5cd72cd51e6340bebd2918/src/Storages/MergeTree/MergeTreeSettings.cpp#L209)を用い、^^parts^^ を一度にではなく、ブロックのチャンクごとに読み込んでマージします。

## マージの仕組み \{#merge-mechanics\}

下の図は、ClickHouse における単一のバックグラウンド[マージスレッド](/merges#concurrent-merges)が、（デフォルトでは[バーティカルマージ](/merges#memory-optimized-merges)なしで）^^パーツ^^をどのようにマージするかを示しています:

<Image img={merges_03} size="lg" alt='パーツのマージ'/>

<br/>

パーツのマージは、次のステップで行われます:

**① 解凍と読み込み**: マージ対象の ^^パーツ^^ から取得した[圧縮済みバイナリカラムファイル](/parts#what-are-table-parts-in-clickhouse)を解凍し、メモリに読み込みます。

**② マージ**: データをより大きなカラムファイルにマージします。

**③ インデックス作成**: マージ後のカラムファイルに対して、新しい[疎なプライマリインデックス](/guides/best-practices/sparse-primary-indexes)を生成します。

**④ 圧縮と保存**: 新しいカラムファイルとインデックスを[圧縮](/sql-reference/statements/create/table#column_compression_codec)し、マージ後のデータパーツを表す新しい[ディレクトリ](/parts#what-are-table-parts-in-clickhouse)に保存します。

セカンダリのデータスキップインデックス、カラム統計情報、チェックサム、min-max インデックスなどの[データパーツ内の追加メタデータ](/parts)も、マージ後のカラムファイルに基づいて再生成されます。ここでは説明を簡潔にするため、これらの詳細は省略しています。

ステップ ② の動作は、使用している特定の [MergeTree エンジン](/engines/table-engines/mergetree-family)に依存します。エンジンごとにマージ処理の方法が異なり、たとえば行が集約されたり、古い行が置き換えられたりすることがあります。前述のとおり、このアプローチにより**すべてのデータ処理がバックグラウンドのマージにオフロードされ**、書き込み処理を軽量かつ効率的に保つことで、**極めて高速な挿入**を実現します。

次に、^^MergeTree^^ ファミリー内の特定のエンジンにおけるマージの仕組みについて、簡単に概観します。

### 標準的なマージ \{#standard-merges\}

以下の図は、標準的な [MergeTree](/engines/table-engines/mergetree-family/mergetree) テーブルにおいて ^^パーツ^^ がどのようにマージされるかを示しています。

<Image img={merges_04} size="lg" alt='PART MERGES'/>

<br/>

上の図にある DDL 文は、`MergeTree` テーブルを作成し、^^ソートキー^^ `(town, street)` を指定しています。これは、[ディスク上のデータがこれらのカラムでソートされ](/parts#what-are-table-parts-in-clickhouse)、それに応じて疎なプライマリインデックスが生成されることを意味します。

① 解凍され事前にソート済みのテーブル列が、テーブルの ^^ソートキー^^ によって定義されるテーブル全体のソート順序を維持したまま ② マージされ、③ 新しい疎なプライマリインデックスが生成され、④ マージされた列ファイルとインデックスが圧縮されて、新しいデータパーツとしてディスクに保存されます。

### 置換マージ \{#replacing-merges\}

[ReplacingMergeTree](/engines/table-engines/mergetree-family/replacingmergetree) テーブルにおけるパーツのマージ処理は [標準のマージ](/merges#standard-merges) と同様に動作しますが、各行について最新バージョンのみが保持され、古いバージョンは破棄されます。

<Image img={merges_05} size="lg" alt='PART MERGES'/>

<br/>

上図の DDL ステートメントは、^^ソートキー^^ `(town, street, id)` を持つ `ReplacingMergeTree` テーブルを作成します。これは、ディスク上のデータがこれらのカラムでソートされ、そのソートに基づいてスパースなプライマリインデックスが生成されることを意味します。

② のマージは標準的な `MergeTree` テーブルと同様に動作し、グローバルなソート順を維持しながら、解凍済みで事前ソートされたカラムを結合します。

ただし、`ReplacingMergeTree` は同じ ^^ソートキー^^ を持つ重複行を削除し、それぞれを含むパーツの作成タイムスタンプに基づいて、最新の行のみを保持します。

<br/>

### 集計マージ \{#summing-merges\}

数値データは、[SummingMergeTree](/engines/table-engines/mergetree-family/summingmergetree) テーブルの ^^パーツ^^ がマージされる際に、自動的に集計されます。

<Image img={merges_06} size="lg" alt='パーツのマージ'/>

<br/>

上の図の DDL ステートメントは、`town` を ^^ソートキー^^ とする `SummingMergeTree` テーブルを定義しています。これは、ディスク上のデータがこの列でソートされ、その列に基づいて疎な primary index が作成されることを意味します。

② のマージ処理ステップでは、ClickHouse は同じ ^^ソートキー^^ を持つすべての行を 1 行に集約し、数値列の値を合計します。

### 集約マージ \{#aggregating-merges\}

上の `SummingMergeTree` テーブルの例は、[AggregatingMergeTree](/engines/table-engines/mergetree-family/aggregatingmergetree) テーブルの特殊なバリアントであり、パーツのマージ時に [90 以上](/sql-reference/aggregate-functions/reference) の任意の集約関数を適用することで、[自動インクリメンタルなデータ変換](https://www.youtube.com/watch?v=QDAJTKZT8y4) を可能にします。

<Image img={merges_07} size="lg" alt='PART MERGES'/>

<br/>

上の図の DDL ステートメントは、`town` を ^^ソートキー^^ とする `AggregatingMergeTree` テーブルを作成します。これにより、ディスク上でこの列に基づいてデータがソートされ、対応する疎なプライマリインデックスが生成されます。

② のマージ中、ClickHouse は同じ ^^ソートキー^^ を持つすべての行を、[部分集約状態](https://clickhouse.com/blog/clickhouse_vs_elasticsearch_mechanics_of_count_aggregations#-multi-core-parallelization)（例: `avg()` 向けの `sum` と `count`）を格納する 1 つの行に置き換えます。これらの状態によって、バックグラウンドでのインクリメンタルなマージを通じて正確な結果が保証されます。
---
slug: /deletes/overview
title: '削除の概要'
description: 'ClickHouse でデータを削除する方法'
keywords: ['delete', 'truncate', 'drop', 'lightweight delete']
doc_type: 'guide'
---

ClickHouse でデータを削除する方法はいくつかあり、それぞれ長所とパフォーマンス特性が異なります。データモデルと削除するデータ量に応じて、適切な方法を選択してください。

| Method | Syntax | When to use |
| --- | --- | --- |
| [Lightweight delete](/guides/developer/lightweight-delete) | `DELETE FROM [table]` | 少量のデータを削除する場合に使用します。行は以降のすべての SELECT クエリから即座に除外されますが、当初は内部的に削除済みとしてマークされるだけであり、ディスク上からは削除されません。 |
| [Delete mutation](/sql-reference/statements/alter/delete) | `ALTER TABLE [table] DELETE` | データをすぐにディスクから削除する必要がある場合（コンプライアンス要件など）に使用します。SELECT のパフォーマンスに悪影響を与えます。 |
| [Truncate table](/sql-reference/statements/truncate) | `TRUNCATE TABLE [db.table]` | テーブルからすべてのデータを効率的に削除します。 |
| [Drop partition](/sql-reference/statements/alter/partition#drop-partitionpart) | `DROP PARTITION` | パーティション内のすべてのデータを効率的に削除します。 |

以下は、ClickHouse でデータを削除するさまざまな方法の概要です。

## 軽量削除

軽量削除では、行は即座に削除済みとしてマークされ、その後のすべての `SELECT` クエリから自動的にフィルタリングされます。これらの削除済み行の物理的な削除は、その後の通常のマージサイクル中に実行されるため、I/O 負荷が小さくなります。その結果、しばらくの間はデータがストレージから実際には削除されず、削除済みとしてマークされているだけの場合があります。データが確実に削除されていることを保証する必要がある場合は、上記のミューテーションコマンドの使用を検討してください。

```sql
-- 軽量削除で2018年のすべてのデータを削除します。非推奨です。
DELETE FROM posts WHERE toYear(CreationDate) = 2018
```

軽量な `DELETE` ステートメントで大量のデータを削除すると、`SELECT` クエリのパフォーマンスに悪影響を与える可能性があります。また、このコマンドはプロジェクションを持つテーブルとは互換性がありません。

削除された行を[マークする操作](/sql-reference/statements/delete#how-lightweight-deletes-work-internally-in-clickhouse)（`_row_exists` 列の追加）にはミューテーションが使用されるため、一定の I/O が発生する点に注意してください。

一般に、削除済みデータがディスク上に存在し続けることを許容できる場合（たとえばコンプライアンス順守が必須ではないケースなど）は、ミューテーションよりも軽量削除を優先して使用すべきです。一方で、すべてのデータを削除する必要がある場合には、この方法は避けるべきです。

[軽量削除](/guides/developer/lightweight-delete)の詳細については、こちらを参照してください。


## 削除ミューテーション

削除ミューテーションは、例えば `ALTER TABLE ... DELETE` コマンドで実行できます。

```sql
-- ミューテーションを使用して2018年のすべてのデータを削除します。非推奨です。
ALTER TABLE posts DELETE WHERE toYear(CreationDate) = 2018
```

これらは同期的（非レプリケートテーブルの場合はデフォルト）または非同期的（[mutations&#95;sync](/operations/settings/settings#mutations_sync) 設定によって決定）に実行できます。これらの処理は非常に I/O 負荷が高く、`WHERE` 句に一致するすべてのパーツを書き換えます。この処理にはアトミック性はありません。パーツはミューテーション後のパーツが準備でき次第順次置き換えられ、ミューテーションの実行中に開始された `SELECT` クエリは、すでにミューテーション済みのパーツと、まだミューテーションされていないパーツの両方からのデータを参照することになります。ユーザーは [systems.mutations](/operations/system-tables/mutations#monitoring-mutations) テーブルを通じて進捗状況を追跡できます。これらは I/O 負荷の高い操作であり、クラスタの `SELECT` パフォーマンスに影響を与える可能性があるため、利用は必要最小限に留める必要があります。

[delete mutations](/sql-reference/statements/alter/delete) の詳細を参照してください。


## テーブルを空にする

テーブル内のすべてのデータを削除する必要がある場合は、以下の `TRUNCATE TABLE` コマンドを使用します。これは軽量な処理です。

```sql
TRUNCATE TABLE posts
```

[TRUNCATE TABLE](/sql-reference/statements/truncate) の詳細については、こちらを参照してください。


## パーティションの削除

データに独自のパーティションキーを指定している場合、パーティションを効率的に削除できます。高カーディナリティなパーティション分割は避けてください。

```sql
ALTER TABLE posts (DROP PARTITION '2008')
```

[DROP PARTITION](/sql-reference/statements/alter/partition) の詳細については、こちらを参照してください。


## 参考情報 \{#more-resources\}

- [ClickHouse での更新と削除の扱い](https://clickhouse.com/blog/handling-updates-and-deletes-in-clickhouse)
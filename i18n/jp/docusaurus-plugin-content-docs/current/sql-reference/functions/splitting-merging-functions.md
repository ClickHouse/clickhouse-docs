---
description: '文字列を分割する関数に関するドキュメント'
sidebar_label: '文字列の分割'
slug: /sql-reference/functions/splitting-merging-functions
title: '文字列を分割する関数'
doc_type: 'reference'
---

import DeprecatedBadge from '@theme/badges/DeprecatedBadge';

# 文字列の分割関数 \{#functions-for-splitting-strings\}

:::note
本ドキュメントは、`system.functions` システムテーブルから自動生成されています。
:::

{/* 
  以下のタグ内の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントに置き換えられます。タグを変更または削除しないでください。
  詳細は https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{/*AUTOGENERATED_START*/ }

## alphaTokens \{#alphaTokens\}

導入バージョン: v1.1

`a-z` および `A-Z` の範囲に含まれる連続するバイト列からなる部分文字列を抽出し、その部分文字列の配列を返します。

**構文**

```sql
alphaTokens(s[, max_substrings])
```

**別名**: `splitByAlpha`

**引数**

* `s` — 分割する文字列。[`String`](/sql-reference/data-types/string)
* `max_substrings` — 任意。`max_substrings > 0` の場合、返される部分文字列の数は最大で `max_substrings` となり、0 以下の場合は可能な限り多くの部分文字列が返されます。[`Int64`](/sql-reference/data-types/int-uint)

**返される値**

`s` から抽出された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT alphaTokens('abca1abc');
```

```response title=Response
┌─alphaTokens('abca1abc')─┐
│ ['abca','abc']          │
└─────────────────────────┘
```

## arrayStringConcat \{#arrayStringConcat\}

導入バージョン: v1.1

配列内に列挙された値の文字列表現を、指定された区切り文字で連結します。区切り文字は省略可能なパラメータで、省略した場合はデフォルトで空文字列が使用されます。

**構文**

```sql
arrayStringConcat(arr[, separator])
```

**引数**

* `arr` — 連結する配列。[`Array(T)`](/sql-reference/data-types/array)
* `separator` — 任意。区切り文字列。デフォルトは空文字列。[`const String`](/sql-reference/data-types/string)

**戻り値**

連結された文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT arrayStringConcat(['12/05/2021', '12:50:00'], ' ') AS DateString;
```

```response title=Response
┌─DateString──────────┐
│ 12/05/2021 12:50:00 │
└─────────────────────┘
```

## extractAllGroupsVertical \{#extractAllGroupsVertical\}

導入バージョン: v20.5

正規表現を使用して文字列内のすべてのキャプチャグループにマッチさせ、その結果を配列の配列として返します。各配列には、入力文字列中の出現順にグループ化された、各キャプチャグループのマッチ部分が含まれます。

**構文**

```sql
extractAllGroupsVertical(s, regexp)
```

**別名**: `extractAllGroups`

**引数**

* `s` — 抽出対象の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — マッチに使用する正規表現。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

配列の配列を返し、各内側の配列には 1 回のマッチでキャプチャされたグループが含まれます。各マッチは、その正規表現内のキャプチャグループ（グループ 1、グループ 2 など）に対応する要素を持つ配列を生成します。マッチが 1 つも見つからない場合は、空の配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsVertical(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## ngrams \{#ngrams\}

導入バージョン: v21.11

UTF-8 でエンコードされた文字列を、長さ `N` の n-gram に分割します。

**構文**

```sql
ngrams(s, N)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `N` — N-gram の長さ。[`const UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

N-gram の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT ngrams('ClickHouse', 3);
```

```response title=Response
['Cli','lic','ick','ckH','kHo','Hou','ous','use']
```

## reverseBySeparator \{#reverseBySeparator\}

導入バージョン: v26.2

指定したセパレーターで区切られた文字列内の部分文字列の順序を逆にします。
この関数は、文字列をセパレーターで分割し、生成された各部分の順序を反転させ、
同じセパレーターを使って再度結合します。ドメイン名やファイルパスなど、
構成要素の順序を反転させる必要がある階層データの解析に役立ちます。

例:

* reverseBySeparator(&#39;www.google.com&#39;) は &#39;com.google.www&#39; を返します
* reverseBySeparator(&#39;a/b/c&#39;, &#39;/&#39;) は &#39;c/b/a&#39; を返します
* reverseBySeparator(&#39;x::y::z&#39;, &#39;::&#39;) は &#39;z::y::x&#39; を返します

**構文**

```sql
reverseBySeparator(string[, separator])
```

**引数**

* `string` — パーツの順序を逆転させる対象となる入力文字列。[`String`](/sql-reference/data-types/string)
* `separator` — パーツを識別するために使用する区切り文字列。指定しない場合は &#39;.&#39; (ドット) を使用します。デフォルト: &#39;.&#39; [`String`](/sql-reference/data-types/string)

**戻り値**

元の文字列中の部分文字列を右から左の順に並べ替え、同じ区切り文字で連結した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**ドメイン名の基本的な反転**

```sql title=Query
SELECT reverseBySeparator('www.google.com')
```

```response title=Response
'com.google.www'
```

**パスの逆順**

```sql title=Query
SELECT reverseBySeparator('a/b/c', '/')
```

```response title=Response
'c/b/a'
```

**任意の区切り文字**

```sql title=Query
SELECT reverseBySeparator('x::y::z', '::')
```

```response title=Response
'z::y::x'
```

**ドットを含むエッジケース**

```sql title=Query
SELECT reverseBySeparator('.a.b.', '.')
```

```response title=Response
'.b.a.'
```

**単一要素**

```sql title=Query
SELECT reverseBySeparator('single')
```

```response title=Response
'single'
```

**空の区切り**

```sql title=Query
SELECT reverseBySeparator('abcde', '')
```

```response title=Response
'edcba'
```

## splitByChar \{#splitByChar\}

導入バージョン: v1.1

長さ 1 文字の定数文字列 `separator` を区切り文字として用いて、文字列を部分文字列の配列に分割します。
区切り文字が文字列の先頭または末尾にある場合、あるいは複数の区切り文字が連続している場合には、空の部分文字列が生成されることがあります。

:::note
[`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string)（デフォルト: `0`）は、引数 `max_substrings > 0` のときに残りの文字列を結果配列の最後の要素に含めるかどうかを制御します。
:::

次の場合、空の部分文字列が生成されることがあります:

* 区切り文字が文字列の先頭または末尾にある場合
* 複数の区切り文字が連続している場合
* 元の文字列 `s` が空である場合

**構文**

```sql
splitByChar(separator, s[, max_substrings])
```

**引数**

* `separator` — 区切り文字は 1 バイト文字である必要があります。 [`String`](/sql-reference/data-types/string)
* `s` — 分割対象の文字列。 [`String`](/sql-reference/data-types/string)
* `max_substrings` — 省略可能。`max_substrings > 0` の場合、返される配列には最大で `max_substrings` 個の部分文字列が含まれます。それ以外の場合は、可能な限り多くの部分文字列を返します。デフォルト値は `0` です。  [`Int64`](/sql-reference/data-types/int-uint)

**返される値**

抽出された部分文字列の配列を返します。 [`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT splitByChar(',', '1,2,3,abcde');
```

```response title=Response
┌─splitByChar(⋯2,3,abcde')─┐
│ ['1','2','3','abcde']    │
└──────────────────────────┘
```

## splitByNonAlpha \{#splitByNonAlpha\}

導入バージョン: v21.9

空白文字および句読点文字で区切られた文字列を、部分文字列の配列に分割します。

:::note
設定 [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string)（デフォルト: `0`）は、引数 `max_substrings` が `0` より大きい場合に、残りの文字列を結果配列の最後の要素に含めるかどうかを制御します。
:::

**構文**

```sql
splitByNonAlpha(s[, max_substrings])
```

**引数**

* `s` — 分割対象の文字列。[`String`](/sql-reference/data-types/string)
* `max_substrings` — 省略可能。`max_substrings > 0` の場合、返される部分文字列の数は `max_substrings` を超えず、それ以外の場合は可能な限り多くの部分文字列を返します。デフォルト値: `0`。[`Int64`](/sql-reference/data-types/int-uint)

**戻り値**

`s` から取得した部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT splitByNonAlpha('user@domain.com');
```

```response title=Response
['user','domain','com']
```

## splitByRegexp \{#splitByRegexp\}

導入バージョン: v21.6

指定された正規表現で区切られた文字列を、部分文字列の配列に分割します。
指定された正規表現が空文字列の場合、文字列は 1 文字ごとの配列に分割されます。
正規表現にマッチしない場合、文字列は分割されません。

次のような場合に空の部分文字列が生成されることがあります:

* 空ではない正規表現のマッチが文字列の先頭または末尾にある場合
* 複数の空ではない正規表現のマッチが連続している場合
* 元の文字列が空で、正規表現が空ではない場合

:::note
[`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string)（デフォルト: `0`）は、引数 `max_substrings > 0` のときに、残りの文字列を結果配列の最後の要素に含めるかどうかを制御します。
:::

**構文**

```sql
splitByRegexp(regexp, s[, max_substrings])
```

**引数**

* `regexp` — 正規表現。定数。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `s` — 分割対象の文字列。[`String`](/sql-reference/data-types/string)
* `max_substrings` — オプション。`max_substrings > 0` の場合、返される部分文字列の数は最大で `max_substrings` 個となり、それ以外の場合は可能な限り多くの部分文字列を返します。デフォルト値: `0`。[`Int64`](/sql-reference/data-types/int-uint)

**戻り値**

`s` から抽出された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT splitByRegexp('\\d+', 'a12bc23de345f');
```

```response title=Response
┌─splitByRegex⋯c23de345f')─┐
│ ['a12bc23de345f']        │
└──────────────────────────┘
```

**空の正規表現**

```sql title=Query
SELECT splitByRegexp('', 'abcde');
```

```response title=Response
┌─splitByRegexp('', 'abcde')─┐
│ ['a','b','c','d','e']      │
└────────────────────────────┘
```

## splitByString \{#splitByString\}

導入: v1.1

複数文字から成る定数 `separator` をセパレータとして文字列を分割し、部分文字列の配列を返します。
文字列 `separator` が空の場合、文字列 `s` を 1 文字ずつの配列に分割します。

次の場合、空の部分文字列が生成されることがあります:

* 空でないセパレータが文字列の先頭または末尾に現れる場合
* 複数の空でないセパレータが連続している場合
* セパレータは空でない一方で、元の文字列 `s` が空の場合

:::note
[`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string) (デフォルト: `0`) は、引数 `max_substrings > 0` のときに、残りの文字列を結果配列の最後の要素に含めるかどうかを制御します。
:::

**構文**

```sql
splitByString(separator, s[, max_substrings])
```

**引数**

* `separator` — 区切り文字。[`String`](/sql-reference/data-types/string)
* `s` — 分割する文字列。[`String`](/sql-reference/data-types/string)
* `max_substrings` — 省略可能。`max_substrings > 0` の場合、返される部分文字列の数は最大で `max_substrings` となり、それ以外の場合は可能な限り多くの部分文字列を返します。デフォルト値: `0`。[`Int64`](/sql-reference/data-types/int-uint)

**返される値**

`s` から抽出された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT splitByString(', ', '1, 2 3, 4,5, abcde');
```

```response title=Response
┌─splitByStrin⋯4,5, abcde')─┐
│ ['1','2 3','4,5','abcde'] │
└───────────────────────────┘
```

**空の区切り文字**

```sql title=Query
SELECT splitByString('', 'abcde');
```

```response title=Response
┌─splitByString('', 'abcde')─┐
│ ['a','b','c','d','e']      │
└────────────────────────────┘
```

## splitByWhitespace \{#splitByWhitespace\}

導入バージョン: v21.9

空白文字で区切られた文字列を、部分文字列の配列に分割します。

:::note
引数 `max_substrings > 0` の場合に、結果配列の最後の要素に残りの文字列を含めるかどうかは、設定 [`splitby_max_substrings_includes_remaining_string`](../../operations/settings/settings.md#splitby_max_substrings_includes_remaining_string)（デフォルト: `0`）で制御されます。
:::

**構文**

```sql
splitByWhitespace(s[, max_substrings])
```

**引数**

* `s` — 分割する文字列。[`String`](/sql-reference/data-types/string)
* `max_substrings` — 省略可能。`max_substrings > 0` の場合、返される部分文字列の数は最大でも `max_substrings` 個となり、それ以外の場合は可能な限り多くの部分文字列を返します。デフォルト値: `0`。[`Int64`](/sql-reference/data-types/int-uint)

**返される値**

`s` から取得された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT splitByWhitespace('  1!  a,  b.  ');
```

```response title=Response
['1!','a,','b.']
```

## tokens \{#tokens\}

導入されたバージョン: v21.11

指定したトークナイザーを使用して文字列をトークンに分割します。

利用可能なトークナイザー:

* `splitByNonAlpha` は、英数字以外の ASCII 文字で文字列を分割します（関数 [splitByNonAlpha](/sql-reference/functions/splitting-merging-functions.md/#splitByNonAlpha) も参照してください）。
* `splitByString(S)` は、ユーザー定義の区切り文字列 `S` に沿って文字列を分割します（関数 [splitByString](/sql-reference/functions/splitting-merging-functions.md/#splitByString) も参照してください）。区切り文字はオプションのパラメータで指定でき、例えば `tokenizer = splitByString([', ', '; ', '\n', '\\'])` のように指定します。各文字列は複数文字（この例では `', '`）から構成されていてもかまいません。区切り文字リストを明示的に指定しない場合（例えば `tokenizer = splitByString`）、デフォルトの区切り文字リストは単一の空白 `[' ']` です。
* `ngrams(N)` は、文字列を同じ長さの `N`-gram に分割します（関数 [ngrams](/sql-reference/functions/splitting-merging-functions.md/#ngrams) も参照してください）。ngram の長さは 1 から 8 の整数のオプションパラメータで指定でき、例えば `tokenizer = ngrams(3)` のように指定します。ngram のデフォルトサイズは、明示的に指定しない場合（例えば `tokenizer = ngrams`）、3 です。
* `sparseGrams(min_length, max_length, min_cutoff_length)` は、少なくとも `min_length` 文字、最大で（両端を含めて）`max_length` 文字の可変長 n-gram に文字列を分割します（関数 [sparseGrams](/sql-reference/functions/string-functions#sparseGrams) も参照してください）。明示的に指定しない場合、`min_length` と `max_length` のデフォルト値はそれぞれ 3 と 100 です。パラメータ `min_cutoff_length` を指定した場合、その長さ以上の n-gram のみが返されます。`ngrams(N)` と比較すると、`sparseGrams` トークナイザーは可変長の N-gram を生成するため、元のテキストをより柔軟に表現できます。例えば、`tokenizer = sparseGrams(3, 5, 4)` は内部的には入力文字列から 3, 4, 5-gram を生成しますが、返されるのは 4-gram と 5-gram のみです。
* `array` はトークナイズを行わず、各行の値全体を 1 つのトークンとして扱います（関数 [array](/sql-reference/functions/array-functions.md/#array) も参照してください）。

`splitByString` トークナイザーの場合、トークンが [prefix code](https://en.wikipedia.org/wiki/Prefix_code) を形成しないときには、より長い区切り文字を優先してマッチさせたい場合が多いでしょう。
そのためには、区切り文字を長い順（長さの降順）に並べて渡してください。
例えば、separators = `['%21', '%']` の場合、文字列 `%21abc` は `['abc']` にトークナイズされますが、separators = `['%', '%21']` の場合は `['21ac']` にトークナイズされます（これはおそらく意図した結果ではないでしょう）。

**構文**

```sql
tokens(value) -- 'splitByNonAlpha' tokenizer
tokens(value, 'splitByNonAlpha')
tokens(value, 'splitByString'[, separators])
tokens(value, 'ngrams'[, n])
tokens(value, 'sparseGrams'[, min_length, max_length[, min_cutoff_length]])
tokens(value, 'array')
```

**引数**

* `value` — 入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `tokenizer` — 使用するトークナイザー。有効な引数は `splitByNonAlpha`、`ngrams`、`splitByString`、`array`、`sparseGrams` です。省略可能で、明示的に指定しない場合は `splitByNonAlpha` がデフォルトになります。[`const String`](/sql-reference/data-types/string)
* `n` — 引数 `tokenizer` が `ngrams` の場合にのみ有効: n-gram の長さを指定する省略可能なパラメータです。明示的に指定しない場合は `3` がデフォルトです。[`const UInt8`](/sql-reference/data-types/int-uint)
* `separators` — 引数 `tokenizer` が `split` の場合にのみ有効: 区切り文字列を指定する省略可能なパラメータです。明示的に指定しない場合は `[' ']` がデフォルトです。[`const Array(String)`](/sql-reference/data-types/array)
* `min_length` — 引数 `tokenizer` が `sparseGrams` の場合にのみ有効: gram の最小長を指定する省略可能なパラメータで、デフォルトは 3 です。[`const UInt8`](/sql-reference/data-types/int-uint)
* `max_length` — 引数 `tokenizer` が `sparseGrams` の場合にのみ有効: gram の最大長を指定する省略可能なパラメータで、デフォルトは 100 です。[`const UInt8`](/sql-reference/data-types/int-uint)
* `min_cutoff_length` — 引数 `tokenizer` が `sparseGrams` の場合にのみ有効: 最小カットオフ長を指定する省略可能なパラメータです。[`const UInt8`](/sql-reference/data-types/int-uint)

**戻り値**

入力文字列から生成されたトークンの配列を返します。[`Array`](/sql-reference/data-types/array)

**例**

**デフォルトのトークナイザー**

```sql title=Query
SELECT tokens('test1,;\\\\ test2,;\\\\ test3,;\\\\   test4') AS tokens;
```

```response title=Response
['test1','test2','test3','test4']
```

**Nグラムトークナイザー**

```sql title=Query
SELECT tokens('abc def', 'ngrams', 3) AS tokens;
```

```response title=Response
['abc','bc ','c d',' de','def']
```

{/*AUTOGENERATED_END*/ }

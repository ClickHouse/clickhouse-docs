---
'description': 'Bitmap Functions のドキュメンテーション'
'sidebar_label': 'Bitmap'
'slug': '/sql-reference/functions/bitmap-functions'
'title': 'ビットマップ関数'
'doc_type': 'reference'
---


# ビットマップ関数

ビットマップは二つの方法で構築できます。最初の方法は、`-State` を使用した集約関数 groupBitmap によって構築され、二つ目の方法は Array オブジェクトからビットマップを構築することです。

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## bitmapAnd {#bitmapAnd}

Introduced in: v20.1

二つのビットマップの論理積 (AND) を計算します。

**構文**

```sql
bitmapAnd(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

両方の入力ビットマップに存在するビットを含むビットマップを返します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapAnd(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─┐
│ [3] │
└─────┘
```



## bitmapAndCardinality {#bitmapAndCardinality}

Introduced in: v20.1

二つのビットマップの論理積 (AND) の基数を返します。

**構文**

```sql
bitmapAndCardinality(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

二つのビットマップの交差部分におけるセットビットの数を返します [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapAndCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```



## bitmapAndnot {#bitmapAndnot}

Introduced in: v20.1

二つのビットマップの論理積を計算し、結果を否定します (AND-NOT)。

**構文**

```sql
bitmapAndnot(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

最初のビットマップには存在するが、二番目のビットマップには存在しないセットビットを含むビットマップを返します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapAndnot(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res────┐
│ [1, 2] │
└────────┘
```



## bitmapAndnotCardinality {#bitmapAndnotCardinality}

Introduced in: v20.1

二つのビットマップの AND-NOT 操作の基数を返します。

**構文**

```sql
bitmapAndnotCardinality(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

`bitmap1 AND-NOT bitmap2` の結果のセットビットの数を返します [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapAndnotCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```



## bitmapBuild {#bitmapBuild}

Introduced in: v20.1

符号なし整数配列からビットマップを構築します。これは、`bitmapToArray` 関数の逆です。 [`bitmapToArray`](/sql-reference/functions/bitmap-functions#bitmapToArray)

**構文**

```sql
bitmapBuild(array)
```

**引数**

- `array` — 符号なし整数配列。 [`Array(UInt*)`](/sql-reference/data-types/array)


**返される値**

提供された配列からビットマップを返します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapBuild([1, 2, 3, 4, 5]) AS res, toTypeName(res);
```

```response title=Response
┌─res─┬─toTypeName(bitmapBuild([1, 2, 3, 4, 5]))─────┐
│     │ AggregateFunction(groupBitmap, UInt8)        │
└─────┴──────────────────────────────────────────────┘
```



## bitmapCardinality {#bitmapCardinality}

Introduced in: v20.1

ビットマップ内のセットビットの数 (基数) を返します。

**構文**

```sql
bitmapCardinality(bitmap)
```

**引数**

- `bitmap` — ビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

ビットマップ内のセットビットの数を返します [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapCardinality(bitmapBuild([1, 3, 3, 5, 7, 7])) AS res
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```



## bitmapContains {#bitmapContains}

Introduced in: v20.1

ビットマップが特定の要素を含んでいるかをチェックします。

**構文**

```sql
bitmapContains(bitmap, value)
```

**引数**

- `bitmap` — ビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `value` — チェックする要素。 [(U)Int8/16/32/64](/sql-reference/data-types/int-uint/) 

**返される値**

ビットマップが指定された値を含む場合は `1` を、それ以外の場合は `0` を返します [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapContains(bitmapBuild([1, 2, 3]), 2) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapHasAll {#bitmapHasAll}

Introduced in: v20.1

最初のビットマップが二番目のビットマップのすべてのセットビットを含んでいるかをチェックします。

**構文**

```sql
bitmapHasAll(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

二番目のビットマップのすべてのセットビットが最初のビットマップに存在する場合は `1` を、それ以外の場合は `0` を返します [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapHasAll(bitmapBuild([1, 2, 3]), bitmapBuild([2, 3])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapHasAny {#bitmapHasAny}

Introduced in: v20.1

最初のビットマップが二番目のビットマップのいずれかのセットビットを含んでいるかをチェックします。

**構文**

```sql
bitmapHasAny(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

二番目のビットマップのいずれかのビットが最初のビットマップに存在する場合は `1` を、それ以外の場合は `0` を返します [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapHasAny(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapMax {#bitmapMax}

Introduced in: v20.1

ビットマップ内で最も大きいビットがセットされている位置を返します。ビットマップが空である場合は `0` を返します。

**構文**

```sql
bitmapMax(bitmap)
```

**引数**

- `bitmap` — ビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

ビットマップ内で最も大きいビットがセットされている位置を返します。それ以外の場合は `0` を返します [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapMax(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```



## bitmapMin {#bitmapMin}

Introduced in: v20.1

ビットマップ内で最も小さいビットがセットされている位置を返します。すべてのビットが unset の場合は `UINT32_MAX` （ビットマップが `2^64` ビットを超える場合は `UINT64_MAX`）を返します。

**構文**

```sql
bitmapMin(bitmap)
```

**引数**

- `bitmap` — ビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

ビットマップ内で最も小さいビットがセットされている位置を返します。それ以外の場合は `UINT32_MAX`/`UINT64_MAX` を返します [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapMin(bitmapBuild([3, 5, 2, 6])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```



## bitmapOr {#bitmapOr}

Introduced in: v20.1

二つのビットマップの論理和 (OR) を計算します。

**構文**

```sql
bitmapOr(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

いずれかの入力ビットマップに存在するセットビットを含むビットマップを返します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapOr(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```



## bitmapOrCardinality {#bitmapOrCardinality}

Introduced in: v20.1

二つのビットマップの論理和 (OR) の基数を返します。

**構文**

```sql
bitmapOrCardinality(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

二つのビットマップの和におけるセットビットの数を返します [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapOrCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```



## bitmapSubsetInRange {#bitmapSubsetInRange}

Introduced in: v20.1

指定された範囲 [start, end) に存在するセットビットのみを含むビットマップのサブセットを返します。1ベースのインデックスを使用します。

**構文**

```sql
bitmapSubsetInRange(bitmap, start, end)
```

**引数**

- `bitmap` — サブセットを抽出するビットマップ。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `start` — 範囲の開始 (含む)。 [`UInt*`](/sql-reference/data-types/int-uint) - `end` — 範囲の終了 (含まない)。 [`UInt*`](/sql-reference/data-types/int-uint) 

**返される値**

指定された範囲のセットビットのみを含むビットマップを返します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild([1, 2, 3, 4, 5]), 2, 5)) AS res;
```

```response title=Response
┌─res───────┐
│ [2, 3, 4] │
└───────────┘
```



## bitmapSubsetLimit {#bitmapSubsetLimit}

Introduced in: v20.1

`range_start` からのビットマップのサブセットを返し、最大で `cardinality_limit` のセットビットを含みます。1ベースのインデックスを使用します。

**構文**

```sql
bitmapSubsetLimit(bitmap, range_start, cardinality_limit)
```

**引数**

- `bitmap` — ビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `range_start` — 範囲の開始 (含む)。 [`UInt32`](/sql-reference/data-types/int-uint) - `cardinality_limit` — サブセットの最大基数。 [`UInt32`](/sql-reference/data-types/int-uint) 

**返される値**

最大 `cardinality_limit` のセットビットを含むビットマップを返します。`range_start` から開始します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild([1, 5, 3, 2, 8]), 3, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [5, 3] │
└────────┘
```



## bitmapToArray {#bitmapToArray}

Introduced in: v20.1

ビットマップを符号なし整数の配列に変換します。これは、`bitmapBuild` 関数の逆です。 [`bitmapBuild`](/sql-reference/functions/bitmap-functions#bitmapBuild)

**構文**

```sql
bitmapToArray(bitmap)
```

**引数**

- `bitmap` — 変換するビットマップ。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

ビットマップに含まれる符号なし整数の配列を返します [`Array(UInt*)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```



## bitmapTransform {#bitmapTransform}

Introduced in: v20.1


ビットマップ内の最大 N ビットを、`from_array` 中の特定のビット値を `to_array` の対応するものと交換することによって変更します。 
    

**構文**

```sql
bitmapTransform(bitmap, from_array, to_array)
```

**引数**

- `bitmap` — ビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `from_array` — 置き換えられる元のセットビットの配列。 [`Array(T)`](/sql-reference/data-types/array)。 - `to_array` — 置き換えに使用する新しいセットビットの配列。 [`Array(T)`](/sql-reference/data-types/array)。 

**返される値**

指定されたマッピングに従って変換された要素を持つビットマップを返します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapTransform(bitmapBuild([1, 2, 3, 4, 5]), [2, 4], [20, 40])) AS res;
```

```response title=Response
┌─res───────────────┐
│ [1, 3, 5, 20, 40] │
└───────────────────┘
```



## bitmapXor {#bitmapXor}

Introduced in: v20.1

二つのビットマップの対称差 (XOR) を計算します。

**構文**

```sql
bitmapXor(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

双方の入力ビットマップに存在するが、両方には存在しないセットビットを含むビットマップを返します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapXor(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res──────────┐
│ [1, 2, 4, 5] │
└──────────────┘
```



## bitmapXorCardinality {#bitmapXorCardinality}

Introduced in: v20.1

二つのビットマップの XOR (対称差) の基数を返します。

**構文**

```sql
bitmapXorCardinality(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `bitmap2` — 二番目のビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 

**返される値**

二つのビットマップの対称差におけるセットビットの数を返します [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapXorCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```



## subBitmap {#subBitmap}

Introduced in: v21.9

ビットマップのサブセットを返し、位置 `offset` から開始します。返されるビットマップの最大基数は `cardinality_limit` です。

**構文**

```sql
subBitmap(bitmap, offset, cardinality_limit)
```

**引数**

- `bitmap` — ビットマップオブジェクト。 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。 - `offset` — 最初からスキップするセットビットの数 (ゼロベース)。 [`UInt32`](/sql-reference/data-types/int-uint) - `cardinality_limit` — サブセットに含めるセットビットの最大数。 [`UInt32`](/sql-reference/data-types/int-uint) 

**返される値**

昇順で `offset` セットビットをスキップした後、最大 `limit` セットビットを含むビットマップを返します [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(subBitmap(bitmapBuild([1, 2, 3, 4, 5]), 2, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [3, 4] │
└────────┘
```



<!--AUTOGENERATED_END-->

---
description: 'ビットマップ関数に関するドキュメント'
sidebar_label: 'ビットマップ'
slug: /sql-reference/functions/bitmap-functions
title: 'ビットマップ関数'
doc_type: 'reference'
---



# ビットマップ関数

ビットマップは2つの方法で構築できます。1つ目は、集約関数groupBitmapを`-State`と組み合わせて構築する方法、もう1つはArrayオブジェクトからビットマップを構築する方法です。

<!--
以下のタグ内のコンテンツは、ドキュメントフレームワークのビルド時に
system.functionsから生成されたドキュメントで置き換えられます。タグを変更または削除しないでください。
参照: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## bitmapAnd {#bitmapAnd}

導入バージョン: v20.1

2つのビットマップの論理積（AND）を計算します。

**構文**

```sql
bitmapAnd(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。
- `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**返り値**

両方の入力ビットマップに存在するビットを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapToArray(bitmapAnd(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=レスポンス
┌─res─┐
│ [3] │
└─────┘
```


## bitmapAndCardinality {#bitmapAndCardinality}

導入バージョン: v20.1

2つのビットマップの論理積（AND）のカーディナリティを返します。

**構文**

```sql
bitmapAndCardinality(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。
- `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**返り値**

2つのビットマップの積集合におけるセットビット数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapAndCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```


## bitmapAndnot {#bitmapAndnot}

導入バージョン: v20.1

2つのビットマップの集合差分 A AND-NOT B を計算します。

**構文**

```sql
bitmapAndnot(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
- `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**戻り値**

1つ目のビットマップには存在するが2つ目のビットマップには存在しないセットビットを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapToArray(bitmapAndnot(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=レスポンス
┌─res────┐
│ [1, 2] │
└────────┘
```


## bitmapAndnotCardinality {#bitmapAndnotCardinality}

導入バージョン: v20.1

2つのビットマップのAND-NOT演算のカーディナリティを返します。

**構文**

```sql
bitmapAndnotCardinality(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。
- `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**戻り値**

`bitmap1 AND-NOT bitmap2`の結果でセットされているビット数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapAndnotCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=レスポンス
┌─res─┐
│   2 │
└─────┘
```


## bitmapBuild {#bitmapBuild}

導入バージョン: v20.1

符号なし整数配列からビットマップを構築します。[`bitmapToArray`](/sql-reference/functions/bitmap-functions#bitmapToArray)関数の逆の操作を行います。

**構文**

```sql
bitmapBuild(array)
```

**引数**

- `array` — 符号なし整数配列。[`Array(UInt*)`](/sql-reference/data-types/array)

**戻り値**

指定された配列からビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapBuild([1, 2, 3, 4, 5]) AS res, toTypeName(res);
```

```response title=レスポンス
┌─res─┬─toTypeName(bitmapBuild([1, 2, 3, 4, 5]))─────┐
│     │ AggregateFunction(groupBitmap, UInt8)        │
└─────┴──────────────────────────────────────────────┘
```


## bitmapCardinality {#bitmapCardinality}

導入バージョン: v20.1

ビットマップ内で設定されているビット数（カーディナリティ）を返します。

**構文**

```sql
bitmapCardinality(bitmap)
```

**引数**

- `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**戻り値**

ビットマップ内で設定されているビット数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapCardinality(bitmapBuild([1, 3, 3, 5, 7, 7])) AS res
```

```response title=レスポンス
┌─res─┐
│   4 │
└─────┘
```


## bitmapContains {#bitmapContains}

導入バージョン: v20.1

ビットマップに特定の要素が含まれているかどうかを確認します。

**構文**

```sql
bitmapContains(bitmap, value)
```

**引数**

- `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
- `value` — 確認する要素。[(U)Int8/16/32/64](/sql-reference/data-types/int-uint/)

**戻り値**

ビットマップに指定された値が含まれている場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapContains(bitmapBuild([1, 2, 3]), 2) AS res;
```

```response title=レスポンス
┌─res─┐
│  1  │
└─────┘
```


## bitmapHasAll {#bitmapHasAll}

導入バージョン: v20.1

最初のビットマップが2番目のビットマップのすべての設定ビットを含んでいるかどうかを確認します。

**構文**

```sql
bitmapHasAll(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。
- `bitmap2` — 2番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**戻り値**

2番目のビットマップのすべての設定ビットが最初のビットマップに存在する場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapHasAll(bitmapBuild([1, 2, 3]), bitmapBuild([2, 3])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```


## bitmapHasAny {#bitmapHasAny}

導入バージョン: v20.1

最初のビットマップが2番目のビットマップのセットビットのいずれかを含むかどうかを確認します。

**構文**

```sql
bitmapHasAny(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 最初のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
- `bitmap2` — 2番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**返り値**

2番目のビットマップのいずれかのビットが最初のビットマップに存在する場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapHasAny(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5])) AS res;
```

```response title=レスポンス
┌─res─┐
│  1  │
└─────┘
```


## bitmapMax {#bitmapMax}

導入バージョン: v20.1

ビットマップ内で設定されている最大のビット位置を返します。ビットマップが空の場合は `0` を返します。

**構文**

```sql
bitmapMax(bitmap)
```

**引数**

- `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**戻り値**

ビットマップ内で設定されている最大のビット位置を返します。それ以外の場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapMax(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```


## bitmapMin {#bitmapMin}

導入バージョン: v20.1

ビットマップ内で設定されている最小のビット位置を返します。すべてのビットが未設定の場合は `UINT32_MAX`（ビットマップが `2^32` ビットを超える場合は `UINT64_MAX`）を返します。

**構文**

```sql
bitmapMin(bitmap)
```

**引数**

- `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**戻り値**

ビットマップ内で設定されている最小のビット位置、またはすべてのビットが未設定の場合は `UINT32_MAX`/`UINT64_MAX` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapMin(bitmapBuild([3, 5, 2, 6])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```


## bitmapOr {#bitmapOr}

導入バージョン: v20.1

2つのビットマップの論理和(OR)を計算します。

**構文**

```sql
bitmapOr(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
- `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**返り値**

いずれかの入力ビットマップに存在するセットビットを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapOr(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```


## bitmapOrCardinality {#bitmapOrCardinality}

導入バージョン: v20.1

2つのビットマップの論理和(OR)のカーディナリティを返します。

**構文**

```sql
bitmapOrCardinality(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。
- `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**返り値**

2つのビットマップの和集合における設定ビット数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapOrCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```


## bitmapSubsetInRange {#bitmapSubsetInRange}

導入バージョン: v20.1

指定された範囲 [start, end) 内に設定されているビットのみを含むビットマップのサブセットを返します。1ベースのインデックスを使用します。

**構文**

```sql
bitmapSubsetInRange(bitmap, start, end)
```

**引数**

- `bitmap` — サブセットを抽出するビットマップ。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
- `start` — 範囲の開始位置(含む)。[`UInt*`](/sql-reference/data-types/int-uint)
- `end` — 範囲の終了位置(含まない)。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

指定された範囲内に設定されているビットのみを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild([1, 2, 3, 4, 5]), 2, 5)) AS res;
```

```response title=レスポンス
┌─res───────┐
│ [2, 3, 4] │
└───────────┘
```


## bitmapSubsetLimit {#bitmapSubsetLimit}

導入バージョン: v20.1

位置 `range_start` から始まる最大 `cardinality_limit` 個のセットビットを持つビットマップのサブセットを返します。1ベースのインデックスを使用します。

**構文**

```sql
bitmapSubsetLimit(bitmap, range_start, cardinality_limit)
```

**引数**

- `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
- `range_start` — 範囲の開始位置(含む)。[`UInt32`](/sql-reference/data-types/int-uint)
- `cardinality_limit` — サブセットの最大カーディナリティ。[`UInt32`](/sql-reference/data-types/int-uint)

**返される値**

`range_start` から始まる最大 `cardinality_limit` 個のセットビットを含むビットマップ。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild([1, 5, 3, 2, 8]), 3, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [5, 3] │
└────────┘
```


## bitmapToArray {#bitmapToArray}

導入バージョン: v20.1

ビットマップを符号なし整数の配列に変換します。[`bitmapBuild`](/sql-reference/functions/bitmap-functions#bitmapBuild)関数の逆の操作です。

**構文**

```sql
bitmapToArray(bitmap)
```

**引数**

- `bitmap` — 変換するビットマップ。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**戻り値**

ビットマップに含まれる符号なし整数の配列を返します。[`Array(UInt*)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```


## bitmapTransform {#bitmapTransform}

導入バージョン: v20.1

`from_array`内の特定のビット値を`to_array`内の対応する値と入れ替えることで、ビットマップ内の最大N個のビットを変更します。

**構文**

```sql
bitmapTransform(bitmap, from_array, to_array)
```

**引数**

- `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。
- `from_array` — 置換元のセットビットの配列。[`Array(T)`](/sql-reference/data-types/array)。
- `to_array` — 置換先の新しいセットビットの配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

指定されたマッピングに従って要素が変換されたビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapTransform(bitmapBuild([1, 2, 3, 4, 5]), [2, 4], [20, 40])) AS res;
```

```response title=Response
┌─res───────────────┐
│ [1, 3, 5, 20, 40] │
└───────────────────┘
```


## bitmapXor {#bitmapXor}

導入バージョン: v20.1

2つのビットマップの排他的論理和（XOR）を計算します。

**構文**

```sql
bitmapXor(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
- `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**返り値**

いずれか一方の入力ビットマップにのみ存在し、両方には存在しないセットビットを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapXor(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res──────────┐
│ [1, 2, 4, 5] │
└──────────────┘
```


## bitmapXorCardinality {#bitmapXorCardinality}

導入バージョン: v20.1

2つのビットマップのXOR（対称差）のカーディナリティを返します。

**構文**

```sql
bitmapXorCardinality(bitmap1, bitmap2)
```

**引数**

- `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。
- `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**戻り値**

2つのビットマップの対称差における設定ビット数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapXorCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=レスポンス
┌─res─┐
│   4 │
└─────┘
```


## subBitmap {#subBitmap}

導入バージョン: v21.9

位置 `offset` から開始するビットマップのサブセットを返します。返されるビットマップの最大カーディナリティは `cardinality_limit` です。

**構文**

```sql
subBitmap(bitmap, offset, cardinality_limit)
```

**引数**

- `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。
- `offset` — 先頭からスキップするセットビットの数(ゼロベース)。[`UInt32`](/sql-reference/data-types/int-uint)
- `cardinality_limit` — サブセットに含めるセットビットの最大数。[`UInt32`](/sql-reference/data-types/int-uint)

**戻り値**

昇順で `offset` 個のセットビットをスキップした後から開始し、最大 `cardinality_limit` 個のセットビットを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=クエリ
SELECT bitmapToArray(subBitmap(bitmapBuild([1, 2, 3, 4, 5]), 2, 2)) AS res;
```

```response title=レスポンス
┌─res────┐
│ [3, 4] │
└────────┘
```

<!--AUTOGENERATED_END-->

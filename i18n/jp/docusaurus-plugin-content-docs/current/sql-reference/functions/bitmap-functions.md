---
description: 'ビットマップ関数に関するドキュメント'
sidebar_label: 'ビットマップ'
slug: /sql-reference/functions/bitmap-functions
title: 'ビットマップ関数'
doc_type: 'reference'
---

# ビットマップ関数 \\{#bitmap-functions\\}

ビットマップは 2 通りの方法で作成できます。1 つ目の方法は、集約関数 groupBitmap の `-State` 付きバージョンによって作成する方法です。もう 1 つの方法は、Array オブジェクトからビットマップを作成する方法です。

{/* 
  以下のタグ内の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントに置き換えられます。タグを変更または削除しないでください。
  詳しくは https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{/*AUTOGENERATED_START*/ }

## bitmapAnd \\{#bitmapAnd\\}

導入バージョン: v20.1

2 つのビットマップの論理積 (AND) を計算します。

**構文**

```sql
bitmapAnd(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1 番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
* `bitmap2` — 2 番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**返される値**

両方の入力ビットマップに共通するビットを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapAnd(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─┐
│ [3] │
└─────┘
```

## bitmapAndCardinality \\{#bitmapAndCardinality\\}

導入バージョン: v20.1

2つのビットマップの論理積 (AND) のカーディナリティ（要素数）を返します。

**構文**

```sql
bitmapAndCardinality(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**戻り値**

2つのビットマップの積集合において、ビットがセットされている数を返します。型は [`UInt64`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT bitmapAndCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```

## bitmapAndnot \\{#bitmapAndnot\\}

導入バージョン: v20.1

2つのビットマップについて、集合差 A AND-NOT B を計算します。

**構文**

```sql
bitmapAndnot(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**返り値**

1つ目のビットマップには含まれているが、2つ目のビットマップには含まれていないビットが立っているビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapAndnot(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res────┐
│ [1, 2] │
└────────┘
```

## bitmapAndnotCardinality \\{#bitmapAndnotCardinality\\}

導入バージョン: v20.1

2 つのビットマップに対する AND-NOT 演算のカーディナリティ（基数）を返します。

**構文**

```sql
bitmapAndnotCardinality(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 2番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**返される値**

`bitmap1 AND-NOT bitmap2` の結果における、セットされているビット数（[`UInt64`](/sql-reference/data-types/int-uint)）を返します。

**例**

**使用例**

```sql title=Query
SELECT bitmapAndnotCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```

## bitmapBuild \\{#bitmapBuild\\}

導入: v20.1

符号なし整数の配列からビットマップを構築します。関数 [`bitmapToArray`](/sql-reference/functions/bitmap-functions#bitmapToArray) とは逆の関係にあります。

**構文**

```sql
bitmapBuild(array)
```

**引数**

* `array` — 符号なし整数の配列。[`Array(UInt*)`](/sql-reference/data-types/array)

**戻り値**

指定された配列からビットマップを生成して返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapBuild([1, 2, 3, 4, 5]) AS res, toTypeName(res);
```

```response title=Response
┌─res─┬─toTypeName(bitmapBuild([1, 2, 3, 4, 5]))─────┐
│     │ AggregateFunction(groupBitmap, UInt8)        │
└─────┴──────────────────────────────────────────────┘
```

## bitmapCardinality \\{#bitmapCardinality\\}

導入バージョン: v20.1

ビットマップ内で 1 に設定されているビット数（カーディナリティ）を返します。

**構文**

```sql
bitmapCardinality(bitmap)
```

**引数**

* `bitmap` — Bitmap オブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**戻り値**

ビットマップ内で 1 に設定されているビットの数を返します。型は [`UInt64`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT bitmapCardinality(bitmapBuild([1, 3, 3, 5, 7, 7])) AS res
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```

## bitmapContains \\{#bitmapContains\\}

導入バージョン: v20.1

特定の要素がビットマップに含まれているかを確認します。

**構文**

```sql
bitmapContains(bitmap, value)
```

**引数**

* `bitmap` — Bitmap オブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。- `value` — 含まれているかをチェックする要素。[(U)Int8/16/32/64](/sql-reference/data-types/int-uint/)

**戻り値**

ビットマップ内に指定した値が含まれている場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapContains(bitmapBuild([1, 2, 3]), 2) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```

## bitmapHasAll \\{#bitmapHasAll\\}

導入バージョン: v20.1

最初のビットマップが、2番目のビットマップのすべてのセットビットを含んでいるかどうかを判定します。

**構文**

```sql
bitmapHasAll(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1 番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)
* `bitmap2` — 2 番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**戻り値**

2 番目のビットマップでセットされているすべてのビットが 1 番目のビットマップにも存在する場合は `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapHasAll(bitmapBuild([1, 2, 3]), bitmapBuild([2, 3])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```

## bitmapHasAny \\{#bitmapHasAny\\}

導入バージョン: v20.1

最初のビットマップが、2 番目のビットマップでセットされているビットを 1 つ以上含んでいるかどうかを判定します。

**構文**

```sql
bitmapHasAny(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1 番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction) 型。 - `bitmap2` — 2 番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction) 型。

**戻り値**

2 番目のビットマップのビットのうちいずれかが 1 番目のビットマップに存在する場合は `1` を返し、そうでない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitmapHasAny(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```

## bitmapMax \\{#bitmapMax\\}

導入バージョン: v20.1

ビットマップ内で最も大きいビットが立っている位置を返します。ビットマップが空の場合は `0` を返します。

**構文**

```sql
bitmapMax(bitmap)
```

**引数**

* `bitmap` — Bitmap オブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**返される値**

ビットマップ内で 1 にセットされているビットのうち、最も大きい位置を返し、該当するビットがない場合は `0` を返します。型は [`UInt64`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT bitmapMax(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```

## bitmapMin \\{#bitmapMin\\}

導入バージョン: v20.1

ビットマップ内で 1 に設定されているビットのうち、最小のビット（最下位ビット）の位置を返します。すべてのビットが未設定の場合は `UINT32_MAX` を、ビットマップが `2^64` ビットを超える場合は `UINT64_MAX` を返します。

**構文**

```sql
bitmapMin(bitmap)
```

**引数**

* `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**返される値**

ビットマップ内で 1 に設定されている最小のビット位置、または `UINT32_MAX`/`UINT64_MAX` [`UInt64`](/sql-reference/data-types/int-uint) を返します。

**例**

**使用例**

```sql title=Query
SELECT bitmapMin(bitmapBuild([3, 5, 2, 6])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```

## bitmapOr \\{#bitmapOr\\}

導入バージョン: v20.1

2つのビットマップの論理和 (OR) を計算します。

**構文**

```sql
bitmapOr(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**戻り値**

いずれかの入力ビットマップ [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction) に存在するセットビットを含むビットマップを返します。

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapOr(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```

## bitmapOrCardinality \\{#bitmapOrCardinality\\}

導入バージョン: v20.1

2 つのビットマップに対する論理和 (OR) のカーディナリティ（要素数）を返します。

**構文**

```sql
bitmapOrCardinality(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1 つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 2 つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**戻り値**

2 つのビットマップの和集合において、セットされているビット数を返します。型は [`UInt64`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT bitmapOrCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```

## bitmapSubsetInRange \\{#bitmapSubsetInRange\\}

導入バージョン: v20.1

指定された範囲 [start, end) にあるセットビットのみを含むビットマップの部分集合を返します。インデックスは 1 始まりです。

**構文**

```sql
bitmapSubsetInRange(bitmap, start, end)
```

**引数**

* `bitmap` — サブセットを抽出するビットマップ。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `start` — 範囲の開始位置（含む）。[`UInt*`](/sql-reference/data-types/int-uint) - `end` — 範囲の終了位置（含まない）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

指定した範囲内でセットされているビットのみを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild([1, 2, 3, 4, 5]), 2, 5)) AS res;
```

```response title=Response
┌─res───────┐
│ [2, 3, 4] │
└───────────┘
```

## bitmapSubsetLimit \\{#bitmapSubsetLimit\\}

導入バージョン: v20.1

ビットマップの `range_start` 位置から、最大で `cardinality_limit` 個のビットが 1 に設定された要素を含む部分集合を返します。インデックスは 1 始まりです。

**構文**

```sql
bitmapSubsetLimit(bitmap, range_start, cardinality_limit)
```

**引数**

* `bitmap` — Bitmap オブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `range_start` — 範囲の開始位置（含む）。[`UInt32`](/sql-reference/data-types/int-uint) - `cardinality_limit` — 部分集合の最大カーディナリティ。[`UInt32`](/sql-reference/data-types/int-uint)

**戻り値**

`range_start` から開始して、最大で `cardinality_limit` 個までビットがセットされた Bitmap を返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild([1, 5, 3, 2, 8]), 3, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [5, 3] │
└────────┘
```

## bitmapToArray \\{#bitmapToArray\\}

導入バージョン: v20.1

ビットマップを符号なし整数の配列に変換します。これは、関数 [`bitmapBuild`](/sql-reference/functions/bitmap-functions#bitmapBuild) の逆の処理を行います。

**構文**

```sql
bitmapToArray(bitmap)
```

**引数**

* `bitmap` — 変換するビットマップ。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)。

**返り値**

ビットマップに含まれる符号なし整数から成る配列を返します。[`Array(UInt*)`](/sql-reference/data-types/array)。

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```

## bitmapTransform \\{#bitmapTransform\\}

導入バージョン: v20.1

`from_array` 内の特定のビット値を `to_array` 内の対応するビット値に置き換えることで、ビットマップ中の最大 N 個のビットを変更します。

**構文**

```sql
bitmapTransform(bitmap, from_array, to_array)
```

**引数**

* `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `from_array` — 置き換え対象となる元のセットビットの配列。[`Array(T)`](/sql-reference/data-types/array). - `to_array` — 置き換え後の新しいセットビットの配列。[`Array(T)`](/sql-reference/data-types/array).

**戻り値**

指定されたマッピングに従って要素が変換されたビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapTransform(bitmapBuild([1, 2, 3, 4, 5]), [2, 4], [20, 40])) AS res;
```

```response title=Response
┌─res───────────────┐
│ [1, 3, 5, 20, 40] │
└───────────────────┘
```

## bitmapXor \\{#bitmapXor\\}

導入バージョン: v20.1

2つのビットマップの対称差（XOR）を計算します。

**構文**

```sql
bitmapXor(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction) - `bitmap2` — 2番目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**返される値**

いずれか一方の入力ビットマップには存在するが、両方には存在しないセットビットを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(bitmapXor(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res──────────┐
│ [1, 2, 4, 5] │
└──────────────┘
```

## bitmapXorCardinality \\{#bitmapXorCardinality\\}

導入バージョン: v20.1

2 つのビットマップの XOR（対称差）のカーディナリティ（要素数）を返します。

**構文**

```sql
bitmapXorCardinality(bitmap1, bitmap2)
```

**引数**

* `bitmap1` — 1つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 2つ目のビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**返される値**

2つのビットマップの対称差におけるセットビット数を返します。型は [`UInt64`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT bitmapXorCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```

## subBitmap \\{#subBitmap\\}

導入バージョン: v21.9

ビットマップの `offset` から始まる部分集合を返します。返されるビットマップの最大要素数（カーディナリティ）は `cardinality_limit` です。

**構文**

```sql
subBitmap(bitmap, offset, cardinality_limit)
```

**引数**

* `bitmap` — ビットマップオブジェクト。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `offset` — 先頭からスキップするセットビットの数（0 始まり）。[`UInt32`](/sql-reference/data-types/int-uint) - `cardinality_limit` — サブセットに含めるセットビットの最大数。[`UInt32`](/sql-reference/data-types/int-uint)

**戻り値**

セットビットを昇順に見て先頭から `offset` 個スキップした後、最大 `limit` 個のセットビットを含むビットマップを返します。[`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**例**

**使用例**

```sql title=Query
SELECT bitmapToArray(subBitmap(bitmapBuild([1, 2, 3, 4, 5]), 2, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [3, 4] │
└────────┘
```

{/*AUTOGENERATED_END*/ }

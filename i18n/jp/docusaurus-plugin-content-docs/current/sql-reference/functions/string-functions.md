---
description: '文字列関数のドキュメント'
sidebar_label: '文字列'
slug: /sql-reference/functions/string-functions
title: '文字列を扱う関数'
doc_type: 'reference'
---

import VersionBadge from '@theme/badges/VersionBadge';

# 文字列操作用関数 {#functions-for-working-with-strings}

文字列内の[検索](string-search-functions.md)および[置換](string-replace-functions.md)に関する関数は、別途説明されています。

:::note
以下のドキュメントは `system.functions` システムテーブルから生成されています。
:::

{/* 
  以下のタグの内部の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントに置き換えられます。これらのタグは変更または削除しないでください。
  詳細は https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{{/*AUTOGENERATED_START*/ } }

## CRC32 {#CRC32}

導入バージョン: v20.1

CRC-32-IEEE 802.3 多項式と初期値 `0xffffffff`（zlib 実装）を使用して、文字列の CRC32 チェックサムを計算します。

**構文**

```sql
CRC32(s)
```

**引数**

* `s` — CRC32 チェックサムを計算する対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC32 チェックサムを返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC32('ClickHouse')
```

```response title=Response
┌─CRC32('ClickHouse')─┐
│          1538217360 │
└─────────────────────┘
```

## CRC32IEEE {#CRC32IEEE}

導入バージョン: v20.1

CRC-32-IEEE 802.3 の多項式を使用して、文字列のCRC32チェックサムを計算します。

**構文**

```sql
CRC32IEEE(s)
```

**引数**

* `s` — CRC32 を計算する対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC32 チェックサムを返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC32IEEE('ClickHouse');
```

```response title=Response
┌─CRC32IEEE('ClickHouse')─┐
│              3089448422 │
└─────────────────────────┘
```

## CRC64 {#CRC64}

導入バージョン: v20.1

CRC-64-ECMA 多項式を使用して、文字列の CRC64 チェックサムを計算します。

**構文**

```sql
CRC64(s)
```

**引数**

* `s` — CRC64 を計算する対象となる文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC64 チェックサムを返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC64('ClickHouse');
```

```response title=Response
┌──CRC64('ClickHouse')─┐
│ 12126588151325169346 │
└──────────────────────┘
```

## appendTrailingCharIfAbsent {#appendTrailingCharIfAbsent}

導入バージョン: v1.1

文字列 `s` が空でなく、末尾が文字 `c` で終わっていない場合に、文字 `c` を文字列 `s` の末尾に追加します。

**構文**

```sql
appendTrailingCharIfAbsent(s, c)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `c` — `s` が末尾に持っていない場合に追加する文字。[`String`](/sql-reference/data-types/string)

**返り値**

文字列 `s` が文字 `c` で終わっていない場合、末尾に `c` を追加した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT appendTrailingCharIfAbsent('https://example.com', '/');
```

```response title=Response
┌─appendTraili⋯.com', '/')─┐
│ https://example.com/     │
└──────────────────────────┘
```

## ascii {#ascii}

導入バージョン: v22.11

文字列 `s` の先頭文字の ASCII コードポイントを `Int32` として返します。

**構文**

```sql
ascii(s)
```

**引数**

* `s` — 文字列入力。[`String`](/sql-reference/data-types/string)

**戻り値**

先頭文字の ASCII コードポイントを返します。`s` が空の場合、結果は `0` です。先頭文字が ASCII 文字ではないか、UTF-16 の Latin-1 補助範囲に含まれていない場合、結果は未定義です。[`Int32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT ascii('234')
```

```response title=Response
┌─ascii('234')─┐
│           50 │
└──────────────┘
```

## base32Decode {#base32Decode}

導入バージョン: v25.6

[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6)（RFC 4648）でエンコードされた文字列をデコードします。
文字列が有効な Base32 エンコードではない場合、例外が発生します。

**構文**

```sql
base32Decode(encoded)
```

**引数**

* `encoded` — 文字列型のカラムまたは定数。[`String`](/sql-reference/data-types/string)

**戻り値**

デコードされた引数の値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base32Decode('IVXGG33EMVSA====');
```

```response title=Response
┌─base32Decode('IVXGG33EMVSA====')─┐
│ Encoded                          │
└──────────────────────────────────┘
```

## base32Encode {#base32Encode}

導入バージョン: v25.6

文字列を [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) でエンコードします。

**構文**

```sql
base32Encode(plaintext)
```

**引数**

* `plaintext` — エンコードするプレーンテキスト。[`String`](/sql-reference/data-types/string)

**返り値**

引数の値をエンコードした文字列を返します。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**例**

**使用例**

```sql title=Query
SELECT base32Encode('Encoded')
```

```response title=Response
┌─base32Encode('Encoded')─┐
│ IVXGG33EMVSA====        │
└─────────────────────────┘
```

## base58Decode {#base58Decode}

導入バージョン: v22.7

[Base58](https://datatracker.ietf.org/doc/html/draft-msporny-base58-03#section-3) でエンコードされた文字列をデコードします。
文字列が有効な Base58 エンコード文字列でない場合は、例外がスローされます。

**構文**

```sql
base58Decode(encoded)
```

**引数**

* `encoded` — デコードする文字列型のカラムまたは定数。[`String`](/sql-reference/data-types/string)

**返り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base58Decode('JxF12TrwUP45BMd');
```

```response title=Response
┌─base58Decode⋯rwUP45BMd')─┐
│ Hello World              │
└──────────────────────────┘
```

## base58Encode {#base58Encode}

導入バージョン: v22.7

文字列を [Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) 方式でエンコードします。

**構文**

```sql
base58Encode(plaintext)
```

**引数**

* `plaintext` — エンコードするプレーンテキスト。[`String`](/sql-reference/data-types/string)

**返り値**

引数の値をエンコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base58Encode('ClickHouse');
```

```response title=Response
┌─base58Encode('ClickHouse')─┐
│ 4nhk8K7GHXf6zx             │
└────────────────────────────┘
```

## base64Decode {#base64Decode}

導入バージョン: v18.16

[RFC 4648](https://en.wikipedia.org/wiki/Base64) に従って、[Base64](https://en.wikipedia.org/wiki/Base64) 形式から文字列をデコードします。
エラー時には例外をスローします。

**構文**

```sql
base64Decode(encoded)
```

**別名**: `FROM_BASE64`

**引数**

* `encoded` — デコードする文字列カラムまたは定数。文字列が有効な Base64 形式でエンコードされていない場合は、例外がスローされます。[`String`](/sql-reference/data-types/string)

**戻り値**

デコードされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64Decode('Y2xpY2tob3VzZQ==')
```

```response title=Response
┌─base64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                       │
└──────────────────────────────────┘
```

## base64Encode {#base64Encode}

導入バージョン: v18.16

RFC 4648 に準拠した [Base64](https://en.wikipedia.org/wiki/Base64) 表現で文字列をエンコードします。

**構文**

```sql
base64Encode(plaintext)
```

**別名**: `TO_BASE64`

**引数**

* `plaintext` — デコード対象のプレーンテキストのカラムまたは定数。[`String`](/sql-reference/data-types/string)

**返される値**

引数のエンコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64Encode('clickhouse')
```

```response title=Response
┌─base64Encode('clickhouse')─┐
│ Y2xpY2tob3VzZQ==           │
└────────────────────────────┘
```

## base64URLDecode {#base64URLDecode}

導入: v24.6

RFC 4648 に従い、URL セーフなアルファベットを使用して [Base64](https://en.wikipedia.org/wiki/Base64) 表現から文字列をデコードします。
エラーが発生した場合は例外を送出します。

**構文**

```sql
base64URLDecode(encoded)
```

**引数**

* `encoded` — エンコード対象の文字列カラムまたは定数。文字列が有効な Base64 形式でない場合は、例外がスローされます。 [`String`](/sql-reference/data-types/string)

**返り値**

引数をデコードした値を含む文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                            │
└───────────────────────────────────────────────────┘
```

## base64URLEncode {#base64URLEncode}

導入バージョン: v18.16

URL セーフなアルファベットを用いた [Base64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)（RFC 4648）表現で文字列をエンコードします。

**構文**

```sql
base64URLEncode(plaintext)
```

**引数**

* `plaintext` — エンコードするプレーンテキストのカラムまたは定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のエンコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64URLEncode('https://clickhouse.com')
```

```response title=Response
┌─base64URLEncode('https://clickhouse.com')─┐
│ aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ            │
└───────────────────────────────────────────┘
```

## basename {#basename}

導入バージョン：v20.1

文字列内の最後のスラッシュまたはバックスラッシュ以降の部分を抽出します。
この関数は、パスからファイル名を抽出するためによく使用されます。

**構文**

```sql
basename(expr)
```

**引数**

* `expr` — 文字列式。バックスラッシュはエスケープする必要があります。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列中で最後に現れるスラッシュまたはバックスラッシュ以降の部分文字列を返します。入力文字列がスラッシュまたはバックスラッシュで終わる場合は、空文字列を返します。スラッシュやバックスラッシュが存在しない場合は元の文字列を返します。[`String`](/sql-reference/data-types/string)

**使用例**

**Unix パスからファイル名を抽出する**

```sql title=Query
SELECT 'some/long/path/to/file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some/long/path/to/file')─┐
│ some/long/path/to/file │ file                               │
└────────────────────────┴────────────────────────────────────┘
```

**Windows のパスからファイル名を取得**

```sql title=Query
SELECT 'some\\long\\path\\to\\file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some\\long\\path\\to\\file')─┐
│ some\long\path\to\file │ file                                   │
└────────────────────────┴────────────────────────────────────────┘
```

**パス区切り文字を含まない文字列**

```sql title=Query
SELECT 'some-file-name' AS a, basename(a)
```

```response title=Response
┌─a──────────────┬─basename('some-file-name')─┐
│ some-file-name │ some-file-name             │
└────────────────┴────────────────────────────┘
```

## byteHammingDistance {#byteHammingDistance}

導入バージョン: v23.9

2つのバイト列同士の[ハミング距離](https://en.wikipedia.org/wiki/Hamming_distance)を計算します。

**構文**

```sql
byteHammingDistance(s1, s2)
```

**別名**: `mismatches`

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列間のハミング距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT byteHammingDistance('karolin', 'kathrin')
```

```response title=Response
┌─byteHammingDistance('karolin', 'kathrin')─┐
│                                         3 │
└───────────────────────────────────────────┘
```

## compareSubstrings {#compareSubstrings}

導入されたバージョン: v25.2

2つの文字列を辞書順で比較します。

**構文**

```sql
compareSubstrings(s1, s2, s1_offset, s2_offset, num_bytes)
```

**引数**

* `s1` — 比較する1つ目の文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 比較する2つ目の文字列。[`String`](/sql-reference/data-types/string)
* `s1_offset` — 比較を開始する `s1` 内の位置（0始まりのインデックス）。[`UInt*`](/sql-reference/data-types/int-uint)
* `s2_offset` — 比較を開始する `s2` 内の位置（0始まりのインデックス）。[`UInt*`](/sql-reference/data-types/int-uint)
* `num_bytes` — 両方の文字列で比較する最大バイト数。`s1_offset`（または `s2_offset`） + `num_bytes` が入力文字列の末尾を超える場合は、`num_bytes` がそれに応じて小さくなります。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

次のいずれかを返します:

* `-1` — `s1`[`s1_offset` : `s1_offset` + `num_bytes`] &lt; `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合。
* `0` — `s1`[`s1_offset` : `s1_offset` + `num_bytes`] = `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合。
* `1` — `s1`[`s1_offset` : `s1_offset` + `num_bytes`] &gt; `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合。
  [`Int8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT compareSubstrings('Saxony', 'Anglo-Saxon', 0, 6, 5) AS result
```

```response title=Response
┌─result─┐
│      0 │
└────────┘
```

## concat {#concat}

導入バージョン: v1.1

指定された引数を連結します。

[`String`](../data-types/string.md) または [`FixedString`](../data-types/fixedstring.md) 型ではない引数は、デフォルトのシリアライゼーションを用いて文字列に変換されます。
これはパフォーマンスが低下するため、String / FixedString 以外の引数の使用は推奨されません。

**構文**

```sql
concat([s1, s2, ...])
```

**引数**

* `s1, s2, ...` — 任意の型の値をいくつでも指定できます。[`Any`](/sql-reference/data-types)

**返り値**

引数を連結して作成された String を返します。いずれかの引数が `NULL` の場合、関数は `NULL` を返します。引数が1つも指定されていない場合は、空文字列を返します。[`Nullable(String)`](/sql-reference/data-types/nullable)

**使用例**

**文字列の連結**

```sql title=Query
SELECT concat('Hello, ', 'World!')
```

```response title=Response
┌─concat('Hello, ', 'World!')─┐
│ Hello, World!               │
└─────────────────────────────┘
```

**数値の結合**

```sql title=Query
SELECT concat(42, 144)
```

```response title=Response
┌─concat(42, 144)─┐
│ 42144           │
└─────────────────┘
```

## concatAssumeInjective {#concatAssumeInjective}

導入: v1.1

[`concat`](#concat) と同様ですが、`concat(s1, s2, ...) → sn` が単射である、
すなわち異なる引数に対して異なる結果を返すと仮定します。

`GROUP BY` の最適化に利用できます。

**構文**

```sql
concatAssumeInjective([s1, s2, ...])
```

**引数**

* `s1, s2, ...` — 任意の型の値を任意の数だけ指定可能。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

引数を連結して生成された文字列を返します。いずれかの引数の値が `NULL` の場合は `NULL` を返します。引数が 1 つも渡されない場合は、空文字列を返します。型は [`String`](/sql-reference/data-types/string) です。

**例**

**GROUP BY の最適化**

```sql title=Query
SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY concatAssumeInjective(key1, key2)
```

```response title=Response
┌─concat(key1, key2)─┬─sum(value)─┐
│ Hello, World!      │          3 │
│ Hello, World!      │          2 │
│ Hello, World       │          3 │
└────────────────────┴────────────┘
```

## concatWithSeparator {#concatWithSeparator}

導入バージョン: v22.12

指定されたセパレータで区切って、与えられた文字列を連結します。

**構文**

```sql
concatWithSeparator(sep[, exp1, exp2, ...])
```

**別名**: `concat_ws`

**引数**

* `sep` — 使用する区切り文字。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)
* `exp1, exp2, ...` — 連結する式。`String` または `FixedString` 型ではない引数は、既定のシリアライゼーションで文字列に変換されます。これはパフォーマンスが低下するため、String/FixedString 以外の引数の使用は推奨されません。[`Any`](/sql-reference/data-types)

**返される値**

引数を連結して作成された `String` を返します。いずれかの引数の値が `NULL` の場合、関数は `NULL` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT concatWithSeparator('a', '1', '2', '3', '4')
```

```response title=Response
┌─concatWithSeparator('a', '1', '2', '3', '4')─┐
│ 1a2a3a4                                      │
└──────────────────────────────────────────────┘
```

## concatWithSeparatorAssumeInjective {#concatWithSeparatorAssumeInjective}

導入バージョン: v22.12

[`concatWithSeparator`](#concatWithSeparator) と同様ですが、`concatWithSeparator(sep[,exp1, exp2, ... ]) → result` が単射であると仮定します。
異なる引数に対して異なる結果を返す関数を単射と呼びます。

`GROUP BY` の最適化に使用できます。

**構文**

```sql
concatWithSeparatorAssumeInjective(sep[, exp1, exp2, ... ])
```

**引数**

* `sep` — 使用するセパレータ。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)
* `exp1, exp2, ...` — 連結する式。`String` または `FixedString` 型ではない引数は、デフォルトのシリアライゼーションで文字列に変換されます。これはパフォーマンス低下を招くため、String/FixedString 以外の引数の使用は推奨されません。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**返される値**

引数を連結して作成された String 型の値を返します。いずれかの引数が `NULL` の場合、関数は `NULL` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
CREATE TABLE user_data (
user_id UInt32,
first_name String,
last_name String,
score UInt32
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO user_data VALUES
(1, 'John', 'Doe', 100),
(2, 'Jane', 'Smith', 150),
(3, 'John', 'Wilson', 120),
(4, 'Jane', 'Smith', 90);

SELECT
    concatWithSeparatorAssumeInjective('-', first_name, last_name) as full_name,
    sum(score) as total_score
FROM user_data
GROUP BY concatWithSeparatorAssumeInjective('-', first_name, last_name);
```

```response title=Response
┌─full_name───┬─total_score─┐
│ Jane-Smith  │         240 │
│ John-Doe    │         100 │
│ John-Wilson │         120 │
└─────────────┴─────────────┘
```

## conv {#conv}

導入バージョン: v1.1

異なる基数の間で数値を変換します。

この関数は、ある基数で表された数値を別の基数に変換します。サポートされる基数は 2 から 36 です。
基数が 10 を超える場合、10～35 の数字を表すために文字 A-Z（大文字・小文字は区別しません）が使用されます。

この関数は MySQL の CONV() 関数と互換性があります。

**構文**

```sql
conv(number, from_base, to_base)
```

**引数**

* `number` — 変換する数値。文字列型または数値型を指定できます。 - `from_base` — 元の基数 (2-36)。整数である必要があります。 - `to_base` — 変換先の基数 (2-36)。整数である必要があります。

**戻り値**

変換先の基数で表した数値の文字列表現。

**例**

**10 進数を 2 進数に変換**

```sql title=Query
SELECT conv('10', 10, 2)
```

```response title=Response
1010
```

**16進数を10進数に変換する**

```sql title=Query
SELECT conv('FF', 16, 10)
```

```response title=Response
255
```

**負の数による変換**

```sql title=Query
SELECT conv('-1', 10, 16)
```

```response title=Response
FFFFFFFFFFFFFFFF
```

**2進数を8進数に変換**

```sql title=Query
SELECT conv('1010', 2, 8)
```

```response title=Response
12
```

## convertCharset {#convertCharset}

導入バージョン: v1.1

文字列 `s` をエンコーディング `from` から `to` へ変換した結果を返します。

**構文**

```sql
convertCharset(s, from, to)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `from` — 変換元の文字エンコーディング。[`String`](/sql-reference/data-types/string)
* `to` — 変換先の文字エンコーディング。[`String`](/sql-reference/data-types/string)

**戻り値**

エンコーディング `from` の文字列 `s` を `to` エンコーディングに変換して返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT convertCharset('Café', 'UTF-8', 'ISO-8859-1');
```

```response title=Response
┌─convertChars⋯SO-8859-1')─┐
│ Caf�                     │
└──────────────────────────┘
```

## damerauLevenshteinDistance {#damerauLevenshteinDistance}

導入バージョン: v24.1

2 つのバイト列間の [Damerau-Levenshtein 距離](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance) を計算します。

**構文**

```sql
damerauLevenshteinDistance(s1, s2)
```

**引数**

* `s1` — 1番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の Damerau-Levenshtein 距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT damerauLevenshteinDistance('clickhouse', 'mouse')
```

```response title=Response
┌─damerauLevenshteinDistance('clickhouse', 'mouse')─┐
│                                                 6 │
└───────────────────────────────────────────────────┘
```

## decodeHTMLComponent {#decodeHTMLComponent}

導入バージョン: v23.9

文字列中の HTML エンティティを対応する文字にデコードします。

**構文**

```sql
decodeHTMLComponent(s)
```

**引数**

* `s` — HTML エンティティをデコードする対象の文字列。[`String`](/sql-reference/data-types/string)

**返り値**

HTML エンティティをデコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')
```

```response title=Response
┌─decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')─┐
│ <div>Hello & "World"</div>                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

## decodeXMLComponent {#decodeXMLComponent}

導入バージョン: v21.2

文字列中の XML エンティティを対応する文字にデコードします。

**構文**

```sql
decodeXMLComponent(s)
```

**引数**

* `s` — デコード対象の XML エンティティを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された文字列内の XML エンティティをデコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT decodeXMLComponent('&lt;tag&gt;Hello &amp; World&lt;/tag&gt;')
```

```response title=Response
┌─decodeXMLCom⋯;/tag&gt;')─┐
│ <tag>Hello & World</tag> │
└──────────────────────────┘
```

## editDistance {#editDistance}

導入バージョン: v23.9

2 つのバイト列間の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)を計算します。

**構文**

```sql
editDistance(s1, s2)
```

**別名**: `levenshteinDistance`

**引数**

* `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の編集距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT editDistance('clickhouse', 'mouse')
```

```response title=Response
┌─editDistance('clickhouse', 'mouse')─┐
│                                   6 │
└─────────────────────────────────────┘
```

## editDistanceUTF8 {#editDistanceUTF8}

導入バージョン: v24.6

2つの UTF8 文字列間の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)を計算します。

**構文**

```sql
editDistanceUTF8(s1, s2)
```

**別名**: `levenshteinDistanceUTF8`

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの UTF-8 文字列間の編集距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT editDistanceUTF8('我是谁', '我是我')
```

```response title=Response
┌─editDistanceUTF8('我是谁', '我是我')──┐
│                                   1 │
└─────────────────────────────────────┘
```

## encodeXMLComponent {#encodeXMLComponent}

導入バージョン: v21.1

文字列を XML のテキストノードまたは属性値として配置できるように、特殊文字をエスケープします。

**構文**

```sql
encodeXMLComponent(s)
```

**引数**

* `s` — エスケープする文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

エスケープされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    '<tag>Hello & "World"</tag>' AS original,
    encodeXMLComponent('<tag>Hello & "World"</tag>') AS xml_encoded;
```

```response title=Response
┌─original───────────────────┬─xml_encoded──────────────────────────────────────────┐
│ <tag>Hello & "World"</tag> │ &lt;tag&gt;Hello &amp; &quot;World&quot;&lt;/tag&gt; │
└────────────────────────────┴──────────────────────────────────────────────────────┘
```

## endsWith {#endsWith}

導入バージョン: v1.1

文字列が指定された接尾辞で終わっているかどうかを判定します。

**構文**

```sql
endsWith(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — `s` の末尾にあるかどうかを確認する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `suffix` で終わる場合は `1`、それ以外は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWith('ClickHouse', 'House');
```

```response title=Response
┌─endsWith('Cl⋯', 'House')─┐
│                        1 │
└──────────────────────────┘
```

## endsWithCaseInsensitive {#endsWithCaseInsensitive}

導入バージョン: v25.9

文字列が、指定された接尾辞で大文字小文字を区別せずに終わっているかどうかを判定します。

**構文**

```sql
endsWithCaseInsensitive(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 大文字・小文字を区別せずに末尾としてチェックする接尾辞。[`String`](/sql-reference/data-types/string)

**返される値**

文字列 `s` が大文字・小文字を区別せずに `suffix` で終わる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithCaseInsensitive('ClickHouse', 'HOUSE');
```

```response title=Response
┌─endsWithCaseInsensitive('Cl⋯', 'HOUSE')─┐
│                                       1 │
└─────────────────────────────────────────┘
```

## endsWithCaseInsensitiveUTF8 {#endsWithCaseInsensitiveUTF8}

導入バージョン: v25.9

文字列 `s` が、大文字・小文字を区別せずに `suffix` で終わるかどうかを返します。
文字列が有効な UTF-8 エンコードされたテキストであることを前提とします。
この前提が満たされない場合、例外はスローされず、結果は未定義です。

**構文**

```sql
endsWithCaseInsensitiveUTF8(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 大文字小文字を区別せずに、末尾としてチェックする文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が大文字小文字を区別せずに `suffix` で終わる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithCaseInsensitiveUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithCaseInsensitiveUTF8('данных', 'ых')─┐
│                                           1 │
└─────────────────────────────────────────────┘
```

## endsWithUTF8 {#endsWithUTF8}

導入バージョン: v23.8

文字列 `s` が `suffix` で終わるかどうかを返します。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされなくても、例外はスローされず、結果は未定義です。

**構文**

```sql
endsWithUTF8(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 末尾に存在するかを確認するサフィックス（接尾辞）。[`String`](/sql-reference/data-types/string)

**返り値**

`s` が `suffix` で終わる場合は `1`、そうでない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithUTF8('данных', 'ых')─┐
│                            1 │
└──────────────────────────────┘
```

## extractTextFromHTML {#extractTextFromHTML}

導入バージョン: v21.3

HTML または XHTML からテキスト内容を抽出します。

この関数は HTML タグ、コメント、script/style 要素を削除し、テキスト内容のみを残します。次の処理を行います:

* すべての HTML/XML タグの削除
* コメント（`<!-- -->`）の削除
* script および style 要素とその内容の削除
* CDATA セクションの処理（内容をそのままコピー）
* 適切な空白処理と正規化

注意: HTML エンティティはデコードされないため、必要に応じて別の関数で処理してください。

**構文**

```sql
extractTextFromHTML(html)
```

**引数**

* `html` — テキストを抽出する対象の HTML コンテンツを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

抽出されたテキストコンテンツを、空白を正規化したうえで返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT extractTextFromHTML('
<html>
    <head><title>Page Title</title></head>
    <body>
        <p>Hello <b>World</b>!</p>
        <script>alert("test");</script>
        <!-- comment -->
    </body>
</html>
');
```

```response title=Response
┌─extractTextFromHTML('<html><head>...')─┐
│ Page Title Hello World!                │
└────────────────────────────────────────┘
```

## firstLine {#firstLine}

導入バージョン: v23.7

複数行の文字列の最初の行を返します。

**構文**

```sql
firstLine(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列の最初の行を返します。行区切り文字が存在しない場合は、文字列全体を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT firstLine('foo\\nbar\\nbaz')
```

```response title=Response
┌─firstLine('foo\nbar\nbaz')─┐
│ foo                        │
└────────────────────────────┘
```

## idnaDecode {#idnaDecode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications)（IDNA）メカニズムに従い、ドメイン名の Unicode（UTF-8）表現（ToUnicode アルゴリズム）を返します。
エラーが発生した場合（たとえば入力が不正な場合）には、入力文字列をそのまま返します。
大文字小文字の正規化が行われるため、[`idnaEncode()`](#idnaEncode) と [`idnaDecode()`](#idnaDecode) を繰り返し適用しても、必ずしも元の文字列が返されるとは限らない点に注意してください。

**構文**

```sql
idnaDecode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値に対する IDNA メカニズムに従って、入力文字列の Unicode（UTF-8）表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')
```

```response title=Response
┌─idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')─┐
│ straße.münchen.de                             │
└───────────────────────────────────────────────┘
```

## idnaEncode {#idnaEncode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications) (IDNA) の仕組みに従い、ドメイン名の ASCII 表現（ToASCII アルゴリズム）を返します。
入力文字列は UTF-8 でエンコードされており、ASCII 文字列に変換可能である必要があります。そうでない場合は例外が発生します。

:::note
パーセントデコードや、タブ・空白・制御文字のトリミングは行われません。
:::

**構文**

```sql
idnaEncode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**返り値**

IDNA メカニズムに従って、入力文字列の ASCII 表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT idnaEncode('straße.münchen.de')
```

```response title=Response
┌─idnaEncode('straße.münchen.de')─────┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```

## initcap {#initcap}

導入バージョン: v23.7

各単語の最初の文字を大文字にし、それ以外を小文字に変換します。
単語は、英数字が連続した並びで構成され、非英数字によって区切られます。

:::note
`initcap` は各単語の最初の文字だけを大文字に変換するため、アポストロフィや大文字を含む単語では予期しない動作となる場合があります。
これは既知の動作であり、現時点で修正の予定はありません。
:::

**構文**

```sql
initcap(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

各単語の先頭文字を大文字に変換した `s` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT initcap('building for fast')
```

```response title=Response
┌─initcap('building for fast')─┐
│ Building For Fast            │
└──────────────────────────────┘
```

**アポストロフィや大文字を含む単語に関する既知の動作例**

```sql title=Query
SELECT initcap('John''s cat won''t eat.');
```

```response title=Response
┌─initcap('Joh⋯n\'t eat.')─┐
│ John'S Cat Won'T Eat.    │
└──────────────────────────┘
```

## initcapUTF8 {#initcapUTF8}

導入バージョン: v23.7

[`initcap`](#initcap) と同様に、`initcapUTF8` は各単語の先頭の文字を大文字にし、残りを小文字に変換します。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

:::note
この関数は言語を判別しません。例えばトルコ語では結果が必ずしも正しくならない可能性があります（i/İ と i/I の違いなど）。
あるコードポイントについて、大文字と小文字で UTF-8 バイト列の長さが異なる場合、そのコードポイントに対する結果は正しくない可能性があります。
:::

**構文**

```sql
initcapUTF8(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**返される値**

各単語の先頭文字を大文字にした `s` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT initcapUTF8('не тормозит')
```

```response title=Response
┌─initcapUTF8('не тормозит')─┐
│ Не Тормозит                │
└────────────────────────────┘
```

## isValidASCII {#isValidASCII}

導入バージョン: v25.9

入力された String または FixedString が ASCII バイト (0x00–0x7F) のみで構成されている場合は 1 を返し、それ以外の場合は 0 を返します。

**構文**

```sql
```

**別名**: `isASCII`

**引数**

* なし。

**戻り値**

**例**

**isValidASCII**

```sql title=Query
SELECT isValidASCII('hello') AS is_ascii, isValidASCII('你好') AS is_not_ascii
```

```response title=Response
```

## isValidUTF8 {#isValidUTF8}

導入バージョン: v20.1

バイト列が有効な UTF-8 エンコードされたテキストかどうかを判定します。

**構文**

```sql
isValidUTF8(s)
```

**引数**

* `s` — UTF-8 エンコードの妥当性を検証する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

バイト列が有効な UTF-8 エンコードのテキストであれば `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT isValidUTF8('\\xc3\\xb1') AS valid, isValidUTF8('\\xc3\\x28') AS invalid
```

```response title=Response
┌─valid─┬─invalid─┐
│     1 │       0 │
└───────┴─────────┘
```

## jaroSimilarity {#jaroSimilarity}

導入バージョン: v24.1

2つのバイト列同士の [Jaro 類似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance#Jaro_similarity) を計算します。

**構文**

```sql
jaroSimilarity(s1, s2)
```

**引数**

* `s1` — 1番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の Jaro 類似度を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT jaroSimilarity('clickhouse', 'click')
```

```response title=Response
┌─jaroSimilarity('clickhouse', 'click')─┐
│                    0.8333333333333333 │
└───────────────────────────────────────┘
```

## jaroWinklerSimilarity {#jaroWinklerSimilarity}

導入バージョン: v24.1

2 つのバイト列間の [Jaro-Winkler 類似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance) を計算します。

**構文**

```sql
jaroWinklerSimilarity(s1, s2)
```

**引数**

* `s1` — 1番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の Jaro-Winkler 類似度を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT jaroWinklerSimilarity('clickhouse', 'click')
```

```response title=Response
┌─jaroWinklerSimilarity('clickhouse', 'click')─┐
│                           0.8999999999999999 │
└──────────────────────────────────────────────┘
```

## left {#left}

導入バージョン: v22.1

文字列 `s` の左端から `offset` 文字分の部分文字列を返します。

**構文**

```sql
left(s, offset)
```

**引数**

* `s` — 部分文字列を取得する対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセット値のバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返り値**

返り値:

* 正の `offset` の場合、文字列の左端から `offset` バイト分を含む `s` の部分文字列。
* 負の `offset` の場合、文字列の左端から `length(s) - |offset|` バイト分を含む `s` の部分文字列。
* `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT left('Hello World', 5)
```

```response title=Response
Hello
```

**負のオフセット**

```sql title=Query
SELECT left('Hello World', -6)
```

```response title=Response
Hello
```

## leftPad {#leftPad}

導入バージョン: v21.8

文字列の左側をスペース、または指定した文字列（必要に応じて繰り返し）で埋め、結果の文字列が指定された `length` に達するまでパディングします。

**構文**

```sql
leftPad(string, length[, pad_string])
```

**別名**: `lpad`

**引数**

* `string` — パディング対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果の文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 省略可能。入力文字列をパディングする際に使用する文字列。指定されていない場合、入力文字列は空白文字でパディングされます。[`String`](/sql-reference/data-types/string)

**返される値**

指定された長さになるよう左側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT leftPad('abc', 7, '*'), leftPad('def', 7)
```

```response title=Response
┌─leftPad('abc', 7, '*')─┬─leftPad('def', 7)─┐
│ ****abc                │     def           │
└────────────────────────┴───────────────────┘
```

## leftPadUTF8 {#leftPadUTF8}

導入バージョン: v21.8

UTF8 文字列の左側を、結果の文字列が指定された長さに達するまで、スペースまたは指定した文字列（必要に応じて複数回）で埋めます。
文字列長をバイト数で測定する [`leftPad`](#leftPad) とは異なり、この関数では文字列長はコードポイント数で測定されます。

**構文**

```sql
leftPadUTF8(string, length[, pad_string])
```

**引数**

* `string` — パディング対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果となる文字列の長さ。値が入力文字列の長さより小さい場合は、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 任意。入力文字列を埋めるために使用する文字列。指定されていない場合、入力文字列はスペースで埋められます。[`String`](/sql-reference/data-types/string)

**返り値**

指定された長さになるよう左側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT leftPadUTF8('абвг', 7, '*'), leftPadUTF8('дежз', 7)
```

```response title=Response
┌─leftPadUTF8('абвг', 7, '*')─┬─leftPadUTF8('дежз', 7)─┐
│ ***абвг                     │    дежз                │
└─────────────────────────────┴────────────────────────┘
```

## leftUTF8 {#leftUTF8}

導入バージョン: v22.1

UTF-8 エンコードされた文字列 `s` の左端から、指定した `offset` 文字分の部分文字列を返します。

**構文**

```sql
leftUTF8(s, offset)
```

**引数**

* `s` — 部分文字列を計算する対象となる UTF-8 エンコード文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットとなるバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

返される値は次のとおりです。

* `offset` が正の場合、文字列の左端から数えて `offset` バイトの長さを持つ、`s` の部分文字列。
* `offset` が負の場合、文字列の左端から数えて `length(s) - |offset|` バイトの長さを持つ、`s` の部分文字列。
* `length` が 0 の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT leftUTF8('Привет', 4)
```

```response title=Response
Прив
```

**負のオフセット**

```sql title=Query
SELECT leftUTF8('Привет', -4)
```

```response title=Response
Пр
```

## lengthUTF8 {#lengthUTF8}

導入バージョン: v1.1

文字列の長さを、バイト数や文字数ではなく、Unicode コードポイント数として返します。
文字列には有効な UTF-8 でエンコードされたテキストが含まれていると仮定します。
この前提が満たされない場合でも、例外はスローされず、結果は未定義となります。

**構文**

```sql
lengthUTF8(s)
```

**エイリアス**: `CHAR_LENGTH`, `CHARACTER_LENGTH`

**引数**

* `s` — 有効な UTF-8 でエンコードされたテキストを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

Unicode のコードポイント数で表した文字列 `s` の長さ。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT lengthUTF8('Здравствуй, мир!')
```

```response title=Response
┌─lengthUTF8('Здравствуй, мир!')─┐
│                             16 │
└────────────────────────────────┘
```

## lower {#lower}

導入バージョン: v1.1

ASCII 文字列を小文字に変換します。

**構文**

```sql
lower(s)
```

**別名**: `lcase`

**引数**

* `s` — 小文字に変換する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` を小文字に変換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT lower('CLICKHOUSE')
```

```response title=Response
┌─lower('CLICKHOUSE')─┐
│ clickhouse          │
└─────────────────────┘
```

## lowerUTF8 {#lowerUTF8}

導入: v1.1

文字列が有効な UTF-8 でエンコードされたテキストであると仮定して、その文字列を小文字に変換します。この前提が満たされない場合でも、例外は送出されず、結果は未定義です。

**構文**

```sql
lowerUTF8(input)
```

**引数**

* `input` — 小文字に変換する入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

小文字に変換された文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**first**

```sql title=Query
SELECT lowerUTF8('München') as Lowerutf8;
```

```response title=Response
münchen
```

## normalizeUTF8NFC {#normalizeUTF8NFC}

導入バージョン: v21.11

[正規化形式 NFC](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って UTF-8 文字列を正規化します。

**構文**

```sql
normalizeUTF8NFC(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8 文字列を NFC で正規化した形式を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
'é' AS original, -- e + combining acute accent (U+0065 + U+0301)
length(original),
normalizeUTF8NFC('é') AS nfc_normalized, -- é (U+00E9)
length(nfc_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfc_normalized─┬─length(nfc_normalized)─┐
│ é        │                2 │ é              │                      2 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```

## normalizeUTF8NFD {#normalizeUTF8NFD}

導入バージョン: v21.11

UTF-8 文字列を [NFD 正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って正規化します。

**構文**

```sql
normalizeUTF8NFD(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8 文字列を NFD 形式に正規化したものを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    'é' AS original, -- é (U+00E9)
    length(original),
    normalizeUTF8NFD('é') AS nfd_normalized, -- e + combining acute (U+0065 + U+0301)
    length(nfd_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfd_normalized─┬─length(nfd_normalized)─┐
│ é        │                2 │ é              │                      3 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```

## normalizeUTF8NFKC {#normalizeUTF8NFKC}

導入バージョン: v21.11

[NFKC 正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)に従って UTF-8 文字列を正規化します。

**構文**

```sql
normalizeUTF8NFKC(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**返される値**

UTF-8 文字列の NFKC 正規化形式を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    '① ② ③' AS original,                            -- Circled number characters
    normalizeUTF8NFKC('① ② ③') AS nfkc_normalized;  -- Converts to 1 2 3
```

```response title=Response
┌─original─┬─nfkc_normalized─┐
│ ① ② ③  │ 1 2 3           │
└──────────┴─────────────────┘
```

## normalizeUTF8NFKD {#normalizeUTF8NFKD}

導入バージョン: v21.11

[正規化形式 NFKD](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って UTF-8 文字列を正規化します。

**構文**

```sql
normalizeUTF8NFKD(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8 文字列を NFKD 形式に正規化したものを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    'H₂O²' AS original,                            -- H + subscript 2 + O + superscript 2
    normalizeUTF8NFKD('H₂O²') AS nfkd_normalized;  -- Converts to H 2 O 2
```

```response title=Response
┌─original─┬─nfkd_normalized─┐
│ H₂O²     │ H2O2            │
└──────────┴─────────────────┘
```

## punycodeDecode {#punycodeDecode}

導入バージョン: v24.1

[Punycode](https://en.wikipedia.org/wiki/Punycode) でエンコードされた文字列の、UTF-8 エンコードされた平文を返します。
有効な Punycode でエンコードされた文字列が指定されていない場合は、例外をスローします。

**構文**

```sql
punycodeDecode(s)
```

**引数**

* `s` — Punycode でエンコードされた文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値のプレーンテキストを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT punycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─punycodeDecode('Mnchen-3ya')─┐
│ München                      │
└──────────────────────────────┘
```

## punycodeEncode {#punycodeEncode}

導入バージョン: v24.1

文字列の [Punycode](https://en.wikipedia.org/wiki/Punycode) 表現を返します。
文字列は UTF-8 でエンコードされている必要があり、それ以外の場合の動作は未定義です。

**構文**

```sql
punycodeEncode(s)
```

**引数**

* `s` — 入力値。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値の Punycode 表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT punycodeEncode('München')
```

```response title=Response
┌─punycodeEncode('München')─┐
│ Mnchen-3ya                │
└───────────────────────────┘
```

## regexpExtract {#regexpExtract}

導入バージョン: v23.2

`haystack` 内で正規表現パターンにマッチし、指定された正規表現グループのインデックスに対応する最初の文字列を抽出します。

**構文**

```sql
regexpExtract(haystack, pattern[, index])
```

**別名**: `REGEXP_EXTRACT`

**引数**

* `haystack` — 正規表現パターンと照合する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現を表す文字列。`pattern` には複数の正規表現グループ（キャプチャグループ）を含めることができ、`index` はどのグループを抽出するかを示します。インデックス 0 は正規表現全体にマッチすることを意味します。[`const String`](/sql-reference/data-types/string)
* `index` — 省略可能。0 以上の整数値で、デフォルトは 1 です。抽出する正規表現グループを指定します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

一致した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    regexpExtract('100-200', '(\\d+)-(\\d+)', 1),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 2),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 0),
    regexpExtract('100-200', '(\\d+)-(\\d+)');
```

```response title=Response
┌─regexpExtract('100-200', '(\\d+)-(\\d+)', 1)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 2)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 0)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)')─┐
│ 100                                          │ 200                                          │ 100-200                                      │ 100                                       │
└──────────────────────────────────────────────┴──────────────────────────────────────────────┴──────────────────────────────────────────────┴───────────────────────────────────────────┘
```

## repeat {#repeat}

導入バージョン: v20.1

指定された回数分だけ文字列を繰り返して連結します。

**構文**

```sql
repeat(s, n)
```

**引数**

* `s` — 繰り返す文字列。[`String`](/sql-reference/data-types/string)
* `n` — 文字列を繰り返す回数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

文字列 `s` を `n` 回繰り返した文字列。`n` が負の値の場合、関数は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT repeat('abc', 10)
```

```response title=Response
┌─repeat('abc', 10)──────────────┐
│ abcabcabcabcabcabcabcabcabcabc │
└────────────────────────────────┘
```

## reverseUTF8 {#reverseUTF8}

導入: v1.1

文字列内の Unicode コードポイントの並びを逆順にします。
文字列に有効な UTF-8 でエンコードされたテキストが含まれていることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義のままです。

**構文**

```sql
reverseUTF8(s)
```

**引数**

* `s` — 有効な UTF-8 でエンコードされたテキストを含む文字列。[`String`](/sql-reference/data-types/string)

**返される値**

Unicode コードポイント列を逆順にした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT reverseUTF8('ClickHouse')
```

```response title=Response
esuoHkcilC
```

## right {#right}

導入バージョン: v22.1

文字列 `s` の末尾（右端）から `offset` 文字分の位置を開始点とする部分文字列を返します。

**構文**

```sql
right(s, offset)
```

**引数**

* `s` — 部分文字列を取得する元の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

次を返します:

* 正の `offset` の場合、文字列の右端から数えて `offset` バイト分の `s` の部分文字列。
* 負の `offset` の場合、文字列の右端から数えて `length(s) - |offset|` バイト分の `s` の部分文字列。
* `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT right('Hello', 3)
```

```response title=Response
llo
```

**負のオフセット**

```sql title=Query
SELECT right('Hello', -3)
```

```response title=Response
lo
```

## rightPad {#rightPad}

導入バージョン: v21.8

文字列の右側に、スペースまたは指定した文字列を（必要に応じて複数回）追加して、結果の文字列が指定された `length` に達するまでパディングします。

**構文**

```sql
rightPad(string, length[, pad_string])
```

**別名**: `rpad`

**引数**

* `string` — パディング対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果の文字列の長さ。値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 省略可能。入力文字列のパディングに使用する文字列。指定しない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された長さの、右側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT rightPad('abc', 7, '*'), rightPad('abc', 7)
```

```response title=Response
┌─rightPad('abc', 7, '*')─┬─rightPad('abc', 7)─┐
│ abc****                 │ abc                │
└─────────────────────────┴────────────────────┘
```

## rightPadUTF8 {#rightPadUTF8}

導入バージョン: v21.8

文字列の右端を、スペースまたは指定した文字列で（必要に応じて複数回）埋めて、結果の文字列が指定された長さに達するまでパディングします。
文字列の長さをバイト数で計測する [`rightPad`](#rightPad) とは異なり、文字列の長さはコードポイント数で計測されます。

**構文**

```sql
rightPadUTF8(string, length[, pad_string])
```

**引数**

* `string` — パディング対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 生成される文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 省略可能。入力文字列をパディングする際に使用する文字列。指定しない場合、入力文字列は空白文字でパディングされます。[`String`](/sql-reference/data-types/string)

**返される値**

指定された長さになるように右側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT rightPadUTF8('абвг', 7, '*'), rightPadUTF8('абвг', 7)
```

```response title=Response
┌─rightPadUTF8('абвг', 7, '*')─┬─rightPadUTF8('абвг', 7)─┐
│ абвг***                      │ абвг                    │
└──────────────────────────────┴─────────────────────────┘
```

## rightUTF8 {#rightUTF8}

導入バージョン: v22.1

UTF-8 エンコードされた文字列 `s` について、末尾からの `offset` を開始位置として部分文字列を返します。

**構文**

```sql
rightUTF8(s, offset)
```

**引数**

* `s` — 部分文字列を計算する対象の UTF-8 でエンコードされた文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返り値**

返り値:

* `offset` が正の場合、文字列の右端から数えて `offset` バイト分の `s` の部分文字列。
* `offset` が負の場合、文字列の右端から数えて `length(s) - |offset|` バイト分の `s` の部分文字列。
* `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT rightUTF8('Привет', 4)
```

```response title=Response
ивет
```

**負のオフセット**

```sql title=Query
SELECT rightUTF8('Привет', -4)
```

```response title=Response
ет
```

## soundex {#soundex}

導入バージョン: v23.4

文字列の [Soundex コード](https://en.wikipedia.org/wiki/Soundex) を返します。

**構文**

```sql
soundex(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列の Soundex コードを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT soundex('aksel')
```

```response title=Response
┌─soundex('aksel')─┐
│ A240             │
└──────────────────┘
```

## space {#space}

導入バージョン: v23.5

指定された回数分のスペース（` `）を連結した文字列を返します。

**構文**

```sql
space(n)
```

**引数**

* `n` — スペースを繰り返す回数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

スペースを `n` 回繰り返した文字列を返します。`n <= 0` の場合、空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT space(3) AS res, length(res);
```

```response title=Response
┌─res─┬─length(res)─┐
│     │           3 │
└─────┴─────────────┘
```

## sparseGrams {#sparseGrams}

導入バージョン: v25.5

指定された文字列から、長さが少なくとも `n` であり、かつその部分文字列の両端にある (n-1)-グラムのハッシュ値が、その部分文字列内部に含まれる任意の (n-1)-グラムのハッシュ値よりも厳密に大きくなるような、すべての部分文字列を見つけます。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGrams(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — オプション。抽出される n-gram の最小長。デフォルトかつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — オプション。抽出される n-gram の最大長。デフォルト値は 100。`min_ngram_length` 以上である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

抽出された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGrams('alice', 3)
```

```response title=Response
┌─sparseGrams('alice', 3)────────────┐
│ ['ali','lic','lice','ice']         │
└────────────────────────────────────┘
```

## sparseGramsHashes {#sparseGramsHashes}

導入バージョン: v25.5

与えられた文字列に対して、長さが少なくとも `n` であるすべての部分文字列のハッシュを求めます。
このとき、その部分文字列の境界にある (n-1)-グラムのハッシュが、
その部分文字列内部に含まれるいかなる (n-1)-グラムのハッシュよりも厳密に大きい、という条件を満たす必要があります。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsHashes(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される n-gram の最小長さ。デフォルトかつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される n-gram の最大長さ。デフォルト値は 100。`min_ngram_length` 以上である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

選択された部分文字列の CRC32 ハッシュの配列を返します。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsHashes('alice', 3)
```

```response title=Response
┌─sparseGramsHashes('alice', 3)──────────────────────┐
│ [1481062250,2450405249,4012725991,1918774096]      │
└────────────────────────────────────────────────────┘
```

## sparseGramsHashesUTF8 {#sparseGramsHashesUTF8}

導入バージョン: v25.5

UTF-8 文字列を入力として受け取り、そのすべての部分文字列のうち、長さが少なくとも `n` であり、かつその部分文字列の両端にある (n-1)-グラムのハッシュ値が、その部分文字列内部に含まれる任意の (n-1)-グラムのハッシュ値よりも厳密に大きいものについて、そのハッシュ値を求めます。
UTF-8 文字列を前提としており、不正な UTF-8 シーケンスがあった場合には例外をスローします。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsHashesUTF8(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — オプション。抽出される n-gram の長さの最小値。デフォルトかつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — オプション。抽出される n-gram の長さの最大値。デフォルト値は 100。`min_ngram_length` 以上でなければなりません。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択された UTF-8 部分文字列の CRC32 ハッシュ値の配列を返します。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsHashesUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsHashesUTF8('алиса', 3)─┐
│ [4178533925,3855635300,561830861] │
└───────────────────────────────────┘
```

## sparseGramsUTF8 {#sparseGramsUTF8}

導入バージョン: v25.5

指定された UTF-8 文字列について、長さが少なくとも `n` のすべての部分文字列を求めます。このとき、その部分文字列の両端にある (n-1)-gram のハッシュ値が、その部分文字列内部に存在するいかなる (n-1)-gram のハッシュ値よりも厳密に大きいものだけを対象とします。
UTF-8 文字列を受け取り、無効な UTF-8 シーケンスが含まれている場合は例外を送出します。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsUTF8(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される ngram の長さの最小値。デフォルトかつ取り得る最小の値は 3 です。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される ngram の長さの最大値。デフォルト値は 100 です。`min_ngram_length` 以上である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**返される値**

抽出された UTF-8 部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsUTF8('алиса', 3)─┐
│ ['али','лис','иса']         │
└─────────────────────────────┘
```

## startsWith {#startsWith}

導入バージョン: v1.1

文字列が指定した文字列で始まるかどうかを判定します。

**構文**

```sql
startsWith(s, prefix)
```

**引数**

* `s` — 判定対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — `s` がこのプレフィックスで始まるかどうかを確認するための文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `prefix` で始まる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWith('ClickHouse', 'Click');
```

```response title=Response
┌─startsWith('⋯', 'Click')─┐
│                        1 │
└──────────────────────────┘
```

## startsWithCaseInsensitive {#startsWithCaseInsensitive}

導入バージョン: v25.9

文字列が、大文字小文字を区別しない比較において、指定した文字列で始まるかどうかを判定します。

**構文**

```sql
startsWithCaseInsensitive(s, prefix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — 大文字小文字を区別せずに判定するプレフィックス文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`1` を返します。`s` が大文字小文字を区別せずに比較したときに `prefix` で始まる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithCaseInsensitive('ClickHouse', 'CLICK');
```

```response title=Response
┌─startsWithCaseInsensitive('⋯', 'CLICK')─┐
│                                       1 │
└─────────────────────────────────────────┘
```

## startsWithCaseInsensitiveUTF8 {#startsWithCaseInsensitiveUTF8}

導入バージョン: v25.9

文字列が、指定されたプレフィックスで始まっているかを大文字小文字を区別せずに確認します。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。

**構文**

```sql
startsWithCaseInsensitiveUTF8(s, prefix)
```

**引数**

* `s` — 判定対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — 大文字小文字を区別せずに先頭一致を判定するプレフィックス文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

` s` が大文字小文字を区別せずに `prefix` で始まる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithCaseInsensitiveUTF8('приставка', 'при')
```

```response title=Response
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```

## startsWithUTF8 {#startsWithUTF8}

導入バージョン: v23.8

文字列が指定されたプレフィックスで始まるかをチェックします。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
startsWithUTF8(s, prefix)
```

**引数**

* `s` — チェックする文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — 先頭にあるかどうかを判定するプレフィックス。[`String`](/sql-reference/data-types/string)

**返される値**

`s` が `prefix` で始まる場合は `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithUTF8('приставка', 'при')
```

```response title=Response
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```

## stringBytesEntropy {#stringBytesEntropy}

導入バージョン: v25.6

文字列内のバイト分布のシャノンのエントロピーを計算します。

**構文**

```sql
stringBytesEntropy(s)
```

**引数**

* `s` — 解析対象の文字列。[`String`](/sql-reference/data-types/string)

**返り値**

文字列内のバイト分布に対するシャノンのエントロピーを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringBytesEntropy('Hello, world!')
```

```response title=Response
┌─stringBytesEntropy('Hello, world!')─┐
│                         3.07049960  │
└─────────────────────────────────────┘
```

## stringBytesUniq {#stringBytesUniq}

導入: v25.6

文字列内に含まれる異なるバイト数をカウントします。

**構文**

```sql
stringBytesUniq(s)
```

**引数**

* `s` — 解析する文字列。[`String`](/sql-reference/data-types/string)

**返される値**

文字列中に含まれる異なるバイトの数を返します。[`UInt16`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT stringBytesUniq('Hello')
```

```response title=Response
┌─stringBytesUniq('Hello')─┐
│                        4 │
└──────────────────────────┘
```

## stringJaccardIndex {#stringJaccardIndex}

導入バージョン: v23.11

2つのバイト列間の [Jaccard similarity index](https://en.wikipedia.org/wiki/Jaccard_index) を計算します。

**構文**

```sql
stringJaccardIndex(s1, s2)
```

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列の Jaccard 類似度指数を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringJaccardIndex('clickhouse', 'mouse')
```

```response title=Response
┌─stringJaccardIndex('clickhouse', 'mouse')─┐
│                                       0.4 │
└───────────────────────────────────────────┘
```

## stringJaccardIndexUTF8 {#stringJaccardIndexUTF8}

導入バージョン: v23.11

[`stringJaccardIndex`](#stringJaccardIndex) と同様ですが、UTF-8 エンコードされた文字列を対象とします。

**構文**

```sql
stringJaccardIndexUTF8(s1, s2)
```

**引数**

* `s1` — 1 番目の UTF8 入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の UTF8 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの UTF8 文字列の Jaccard 類似度インデックスを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringJaccardIndexUTF8('我爱你', '我也爱你')
```

```response title=Response
┌─stringJaccardIndexUTF8('我爱你', '我也爱你')─┐
│                                       0.75 │
└─────────────────────────────────────────────┘
```

## substring {#substring}

導入バージョン: v1.1

文字列 `s` の、指定されたバイトインデックス `offset` の位置から始まる部分文字列を返します。
バイトのカウントは次のロジックで 1 から始まります:

* `offset` が `0` の場合、空文字列を返します。
* `offset` が負の場合、部分文字列は先頭からではなく、文字列の末尾から `pos` 文字分だけさかのぼった位置から始まります。

省略可能な引数 `length` では、返される部分文字列が持つことのできる最大バイト数を指定します。

**構文**

```sql
substring(s, offset[, length])
```

**別名**: `byteSlice`, `mid`, `substr`

**引数**

* `s` — 部分文字列を取り出す対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Enum`](/sql-reference/data-types/enum)
* `offset` — `s` における部分文字列の開始位置。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 省略可能。部分文字列の最大長。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

`offset` で指定された位置から `length` バイト分の `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な使い方**

```sql title=Query
SELECT 'database' AS db, substr(db, 5), substr(db, 5, 1)
```

```response title=Response
┌─db───────┬─substring('database', 5)─┬─substring('database', 5, 1)─┐
│ database │ base                     │ b                           │
└──────────┴──────────────────────────┴─────────────────────────────┘
```

## substringIndex {#substringIndex}

導入バージョン: v23.7

Spark や MySQL と同様に、`s` から、デリミタ `delim` が `count` 回出現するより前の部分文字列を返します。

**構文**

```sql
substringIndex(s, delim, count)
```

**別名**: `SUBSTRING_INDEX`

**引数**

* `s` — 部分文字列を抽出する元の文字列。[`String`](/sql-reference/data-types/string)
* `delim` — 分割に用いる区切り文字（列）。[`String`](/sql-reference/data-types/string)
* `count` — 部分文字列を抽出する前にカウントする区切り文字の出現回数。`count` が正の場合は（左から数えて）最後に現れる区切り文字より左側のすべてが返されます。`count` が負の場合は（右から数えて）最後に現れる区切り文字より右側のすべてが返されます。[`UInt`](/sql-reference/data-types/int-uint) または [`Int`](/sql-reference/data-types/int-uint)

**返される値**

`delim` が `count` 回出現する位置より前の `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT substringIndex('www.clickhouse.com', '.', 2)
```

```response title=Response
┌─substringIndex('www.clickhouse.com', '.', 2)─┐
│ www.clickhouse                               │
└──────────────────────────────────────────────┘
```

## substringIndexUTF8 {#substringIndexUTF8}

導入バージョン: v23.7

区切り文字 `delim` が `count` 回出現するより前にある `s` の部分文字列を、Unicode コードポイント単位で返します。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提としています。
この前提が満たされない場合でも例外はスローされず、結果は未定義です。

**構文**

```sql
substringIndexUTF8(s, delim, count)
```

**引数**

* `s` — 部分文字列を抽出する元の文字列。[`String`](/sql-reference/data-types/string)
* `delim` — 分割に使用する区切り文字。[`String`](/sql-reference/data-types/string)
* `count` — 部分文字列を抽出する前に数える区切り文字の出現回数。`count` が正の場合は、（左から数えた）最後の区切り文字より左側のすべてが返されます。`count` が負の場合は、（右から数えた）最後の区切り文字より右側のすべてが返されます。[`UInt`](/sql-reference/data-types/int-uint) または [`Int`](/sql-reference/data-types/int-uint)

**返される値**

`delim` が `count` 回出現する手前までの、`s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**UTF-8 の例**

```sql title=Query
SELECT substringIndexUTF8('www.straßen-in-europa.de', '.', 2)
```

```response title=Response
www.straßen-in-europa
```

## substringUTF8 {#substringUTF8}

導入バージョン: v1.1

Unicode コードポイントに対して、文字列 `s` の指定されたバイトインデックス `offset` から始まる部分文字列を返します。
バイト数のカウントは、次のロジックで `1` から始まります。

* `offset` が `0` の場合、空文字列が返されます。
* `offset` が負の値の場合、部分文字列は先頭からではなく、文字列の末尾から数えて `pos` 文字目から始まります。

オプション引数 `length` は、返される部分文字列が持つことができる最大バイト数を指定します。

:::note
この関数は、文字列が有効な UTF-8 エンコードのテキストであることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。
:::

**構文**

```sql
substringUTF8(s, offset[, length])
```

**引数**

* `s` — 部分文字列を取得する対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Enum`](/sql-reference/data-types/enum)
* `offset` — `s` における部分文字列の開始位置。[`Int`](/sql-reference/data-types/int-uint) または [`UInt`](/sql-reference/data-types/int-uint)
* `length` — 部分文字列の最大長。省略可能。[`Int`](/sql-reference/data-types/int-uint) または [`UInt`](/sql-reference/data-types/int-uint)

**返り値**

`offset` を開始位置として、長さ `length` バイトの `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT 'Täglich grüßt das Murmeltier.' AS str, substringUTF8(str, 9), substringUTF8(str, 9, 5)
```

```response title=Response
Täglich grüßt das Murmeltier.    grüßt das Murmeltier.    grüßt
```

## toValidUTF8 {#toValidUTF8}

導入バージョン: v20.1

文字列を、有効な UTF-8 エンコーディングに変換します。この際、文字列中の無効な UTF-8 文字は、置換文字 `�` (U+FFFD) に置き換えられます。
複数の無効な文字が連続している場合は、1 つの置換文字にまとめられます。

**構文**

```sql
toValidUTF8(s)
```

**引数**

* `s` — String データ型オブジェクトとして表される任意のバイト列。[`String`](/sql-reference/data-types/string)

**戻り値**

有効な UTF-8 文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT toValidUTF8('\\x61\\xF0\\x80\\x80\\x80b')
```

```response title=Response
c
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```

## trimBoth {#trimBoth}

導入バージョン: v20.1

文字列の先頭と末尾から指定した文字を削除します。
デフォルトでは、一般的な ASCII の空白文字を削除します。

**構文**

```sql
trimBoth(s[, trim_characters])
```

**別名**: `trim`

**引数**

* `s` — トリム対象の文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 省略可能。トリムする対象の文字。指定しない場合、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**返される値**

両端から指定された文字が取り除かれた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimBoth('$$ClickHouse$$', '$')
```

```response title=Response
┌─trimBoth('$$⋯se$$', '$')─┐
│ ClickHouse               │
└──────────────────────────┘
```

## trimLeft {#trimLeft}

導入バージョン: v20.1

文字列の先頭から指定された文字を取り除きます。
デフォルトでは、一般的な空白（ASCII）文字を取り除きます。

**構文**

```sql
trimLeft(input[, trim_characters])
```

**別名**: `ltrim`

**引数**

* `input` — 左側をトリムする対象の文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 省略可能。トリムする文字の集合。指定しない場合は、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

左側から指定された文字をトリムした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimLeft('ClickHouse', 'Click');
```

```response title=Response
┌─trimLeft('Cl⋯', 'Click')─┐
│ House                    │
└──────────────────────────┘
```

## trimRight {#trimRight}

導入バージョン: v20.1

文字列の末尾から指定された文字を削除します。
デフォルトでは、一般的な ASCII の空白文字を削除します。

**構文**

```sql
trimRight(s[, trim_characters])
```

**別名**: `rtrim`

**引数**

* `s` — 末尾の文字をトリムする対象の文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 任意で指定するトリム対象の文字。指定しない場合は、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定した文字を末尾（右側）から取り除いた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimRight('ClickHouse','House');
```

```response title=Response
┌─trimRight('C⋯', 'House')─┐
│ Click                    │
└──────────────────────────┘
```

## tryBase32Decode {#tryBase32Decode}

導入バージョン: v25.6

文字列を引数に取り、[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) エンコーディング方式でデコードします。

**構文**

```sql
tryBase32Decode(encoded)
```

**引数**

* `encoded` — デコード対象の文字列カラムまたは定数。文字列が有効な Base32 形式でエンコードされていない場合、エラーが発生したときは空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase32Decode('IVXGG33EMVSA====');
```

```response title=Response
┌─tryBase32Decode('IVXGG33EMVSA====')─┐
│ Encoded                             │
└─────────────────────────────────────┘
```

## tryBase58Decode {#tryBase58Decode}

導入バージョン: v22.10

[`base58Decode`](#base58Decode) と同様ですが、エラーが発生した場合は空文字列を返します。

**構文**

```sql
tryBase58Decode(encoded)
```

**引数**

* `encoded` — 文字列カラムまたは定数。文字列が有効な Base58 エンコードではない場合、エラー時には空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコード済みの値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase58Decode('3dc8KtHrwM') AS res, tryBase58Decode('invalid') AS res_invalid;
```

```response title=Response
┌─res─────┬─res_invalid─┐
│ Encoded │             │
└─────────┴─────────────┘
```

## tryBase64Decode {#tryBase64Decode}

導入バージョン: v18.16

[`base64Decode`](#base64Decode) と同様ですが、エラーが発生した場合は空文字列を返します。

**構文**

```sql
tryBase64Decode(encoded)
```

**引数**

* `encoded` — デコードする文字列カラムまたは定数。有効な Base64 形式でエンコードされていない文字列の場合、エラー時には空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase64Decode('Y2xpY2tob3VzZQ==')
```

```response title=Response
┌─tryBase64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                          │
└─────────────────────────────────────┘
```

## tryBase64URLDecode {#tryBase64URLDecode}

導入バージョン: v18.16

[`base64URLDecode`](#base64URLDecode) と同様ですが、エラーが発生した場合は空文字列を返します。

**構文**

```sql
tryBase64URLDecode(encoded)
```

**引数**

* `encoded` — デコード対象の文字列カラムまたは定数。文字列が有効な Base64 でエンコードされたものでない場合、エラー時には空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                               │
└──────────────────────────────────────────────────────┘
```

## tryIdnaEncode {#tryIdnaEncode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications) (IDNA) 方式に従って、ドメイン名の Unicode (UTF-8) 表現（ToUnicode アルゴリズム）を返します。
エラーが発生した場合は、例外をスローする代わりに空文字列を返します。

**構文**

```sql
tryIdnaEncode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値の IDNA メカニズムに基づいて変換した、入力文字列の ASCII 表現を返します。入力が不正な場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryIdnaEncode('straße.münchen.de')
```

```response title=Response
┌─tryIdnaEncode('straße.münchen.de')──┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```

## tryPunycodeDecode {#tryPunycodeDecode}

導入バージョン: v24.1

`punycodeDecode` と同様ですが、有効な Punycode 文字列が指定されなかった場合は空文字列を返します。

**構文**

```sql
tryPunycodeDecode(s)
```

**引数**

* `s` — Punycode でエンコードされた文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値に対応するプレーンテキストを返します。入力が無効な場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryPunycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─tryPunycodeDecode('Mnchen-3ya')─┐
│ München                         │
└─────────────────────────────────┘
```

## upper {#upper}

導入: v1.1

文字列中の ASCII ラテン文字を大文字に変換します。

**構文**

```sql
upper(s)
```

**別名**: `ucase`

**引数**

* `s` — 大文字に変換する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` を大文字に変換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT upper('clickhouse')
```

```response title=Response
┌─upper('clickhouse')─┐
│ CLICKHOUSE          │
└─────────────────────┘
```

## upperUTF8 {#upperUTF8}

導入バージョン: v1.1

文字列が有効な UTF-8 でエンコードされたテキストであると仮定して、その文字列を大文字に変換します。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

:::note
この関数は言語を判別しません。例えばトルコ語では結果が完全には正しくない場合があります（i/İ と i/I など）。
あるコードポイントについて、大文字と小文字で UTF-8 バイト列の長さが異なる場合（`ẞ` と `ß` など）、そのコードポイントに対する結果は正しくない可能性があります。
:::

**構文**

```sql
upperUTF8(s)
```

**引数**

* `s` — 文字列型。[`String`](/sql-reference/data-types/string)

**戻り値**

String 型の値。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT upperUTF8('München') AS Upperutf8
```

```response title=Response
┌─Upperutf8─┐
│ MÜNCHEN   │
└───────────┘
```

{/*AUTOGENERATED_END*/ }

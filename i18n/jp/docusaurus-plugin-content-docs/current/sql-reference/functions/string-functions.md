---
description: '文字列関数のドキュメント'
sidebar_label: '文字列'
slug: /sql-reference/functions/string-functions
title: '文字列を扱う関数'
doc_type: 'reference'
---

import VersionBadge from '@theme/badges/VersionBadge';

# 文字列を扱うための関数 {#functions-for-working-with-strings}

文字列の[検索](string-search-functions.md)および[置換](string-replace-functions.md)に関する関数については、別途説明しています。

:::note
以下のドキュメントは、`system.functions` システムテーブルから生成されています。
:::

{/* 
  以下のタグ内の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントで置き換えられます。タグを変更または削除しないでください。
  詳細は https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{/*AUTOGENERATED_START*/ }

## CRC32 {#CRC32}

導入バージョン: v20.1

CRC-32-IEEE 802.3 の多項式および初期値 `0xffffffff`（zlib 実装）を使用して、文字列の CRC32 チェックサムを計算します。

**構文**

```sql
CRC32(s)
```

**引数**

* `s` — CRC32 を計算する対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC32 チェックサム値を返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC32('ClickHouse')
```

```response title=Response
┌─CRC32('ClickHouse')─┐
│          1538217360 │
└─────────────────────┘
```

## CRC32IEEE {#CRC32IEEE}

導入バージョン: v20.1

CRC-32-IEEE 802.3 多項式を用いて、文字列の CRC32 チェックサムを計算します。

**構文**

```sql
CRC32IEEE(s)
```

**引数**

* `s` — CRC32 を計算する対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC32 チェックサムを返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC32IEEE('ClickHouse');
```

```response title=Response
┌─CRC32IEEE('ClickHouse')─┐
│              3089448422 │
└─────────────────────────┘
```

## CRC64 {#CRC64}

導入バージョン: v20.1

CRC-64-ECMA多項式を使用して、文字列のCRC64チェックサムを計算します。

**構文**

```sql
CRC64(s)
```

**引数**

* `s` — CRC64 を計算する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC64 チェックサムを返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC64('ClickHouse');
```

```response title=Response
┌──CRC64('ClickHouse')─┐
│ 12126588151325169346 │
└──────────────────────┘
```

## appendTrailingCharIfAbsent {#appendTrailingCharIfAbsent}

導入バージョン: v1.1

文字列 `s` が空でなく、かつ末尾の文字が `c` でない場合に、文字 `c` を `s` の末尾に追加します。

**構文**

```sql
appendTrailingCharIfAbsent(s, c)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `c` — 末尾に存在しない場合に追加する文字。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列 `s` が `c` で終わっていない場合、その末尾に文字 `c` を付加したものを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT appendTrailingCharIfAbsent('https://example.com', '/');
```

```response title=Response
┌─appendTraili⋯.com', '/')─┐
│ https://example.com/     │
└──────────────────────────┘
```

## ascii {#ascii}

導入バージョン: v22.11

文字列 `s` の先頭文字の ASCII コードポイント値を `Int32` として返します。

**構文**

```sql
ascii(s)
```

**引数**

* `s` — 文字列入力。[`String`](/sql-reference/data-types/string)

**戻り値**

先頭文字の ASCII コードポイントを返します。`s` が空文字列の場合、結果は `0` です。先頭文字が ASCII 文字ではない、または UTF-16 における Latin-1 補助範囲に含まれない場合、結果は未定義です。[`Int32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT ascii('234')
```

```response title=Response
┌─ascii('234')─┐
│           50 │
└──────────────┘
```

## base32Decode {#base32Decode}

導入バージョン: v25.6

[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6)（RFC 4648）文字列をデコードします。
文字列が有効な Base32 エンコードではない場合、例外をスローします。

**構文**

```sql
base32Decode(encoded)
```

**引数**

* `encoded` — 文字列カラムまたは定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base32Decode('IVXGG33EMVSA====');
```

```response title=Response
┌─base32Decode('IVXGG33EMVSA====')─┐
│ エンコード済み                        │
└──────────────────────────────────┘
```

## base32Encode {#base32Encode}

導入バージョン: v25.6

文字列を [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) でエンコードします。

**構文**

```sql
base32Encode(plaintext)
```

**引数**

* `plaintext` — エンコードするプレーンテキスト。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をエンコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**例**

**使用例**

```sql title=Query
SELECT base32Encode('Encoded')
```

```response title=Response
┌─base32Encode('Encoded')─┐
│ IVXGG33EMVSA====        │
└─────────────────────────┘
```

## base58Decode {#base58Decode}

導入バージョン: v22.7

[Base58](https://datatracker.ietf.org/doc/html/draft-msporny-base58-03#section-3) でエンコードされた文字列をデコードします。
文字列が有効な Base58 エンコードでない場合は、例外がスローされます。

**構文**

```sql
base58Decode(encoded)
```

**引数**

* `encoded` — デコード対象の文字列カラムまたは定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数として指定された値をデコードした結果の文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base58Decode('JxF12TrwUP45BMd');
```

```response title=Response
┌─base58Decode⋯rwUP45BMd')─┐
│ Hello World              │
└──────────────────────────┘
```

## base58Encode {#base58Encode}

導入: v22.7

[Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) エンコード方式を使って文字列をエンコードします。

**構文**

```sql
base58Encode(plaintext)
```

**引数**

* `plaintext` — エンコードするプレーンテキスト。[`String`](/sql-reference/data-types/string)

**戻り値**

引数の値をエンコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base58Encode('ClickHouse');
```

```response title=Response
┌─base58Encode('ClickHouse')─┐
│ 4nhk8K7GHXf6zx             │
└────────────────────────────┘
```

## base64Decode {#base64Decode}

導入バージョン: v18.16

[RFC 4648](https://en.wikipedia.org/wiki/Base64) に従い、[Base64](https://en.wikipedia.org/wiki/Base64) 形式から文字列をデコードします。
エラーが発生した場合は例外をスローします。

**構文**

```sql
base64Decode(encoded)
```

**別名**: `FROM_BASE64`

**引数**

* `encoded` — デコードする文字列型のカラムまたは定数。文字列が有効な Base64 形式でない場合は、例外がスローされる。[`String`](/sql-reference/data-types/string)

**返される値**

デコードされた文字列を返す。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64Decode('Y2xpY2tob3VzZQ==')
```

```response title=Response
┌─base64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                       │
└──────────────────────────────────┘
```

## base64Encode {#base64Encode}

導入バージョン: v18.16

[RFC 4648](https://en.wikipedia.org/wiki/Base64) に従って、文字列を Base64 形式でエンコードします。

**構文**

```sql
base64Encode(plaintext)
```

**別名**: `TO_BASE64`

**引数**

* `plaintext` — 復号する対象のプレーンテキストを含むカラムまたは定数。[`String`](/sql-reference/data-types/string)

**返される値**

引数の値をエンコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64Encode('clickhouse')
```

```response title=Response
┌─base64Encode('clickhouse')─┐
│ Y2xpY2tob3VzZQ==           │
└────────────────────────────┘
```

## base64URLDecode {#base64URLDecode}

導入バージョン: v24.6

URL セーフアルファベットを使用し、RFC 4648 に従って [Base64](https://en.wikipedia.org/wiki/Base64) 表現から文字列をデコードします。
エラーが発生した場合は例外をスローします。

**構文**

```sql
base64URLDecode(encoded)
```

**引数**

* `encoded` — エンコード対象の文字列カラムまたは定数。文字列が有効な Base64 形式でエンコードされていない場合は、例外がスローされます。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコード後の値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                            │
└───────────────────────────────────────────────────┘
```

## base64URLEncode {#base64URLEncode}

導入バージョン: v18.16

URL セーフなアルファベットを用いる [Base64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)（RFC 4648）表現で文字列をエンコードします。

**構文**

```sql
base64URLEncode(plaintext)
```

**引数**

* `plaintext` — エンコードするプレーンテキストのカラムまたは定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数の値をエンコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64URLEncode('https://clickhouse.com')
```

```response title=Response
┌─base64URLEncode('https://clickhouse.com')─┐
│ aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ            │
└───────────────────────────────────────────┘
```

## basename {#basename}

導入バージョン: v20.1

文字列内の最後のスラッシュまたはバックスラッシュ以降の部分を抽出します。
この関数は、パスからファイル名を抽出する際によく使用されます。

**構文**

```sql
basename(expr)
```

**引数**

* `expr` — 文字列表現。バックスラッシュはエスケープする必要があります。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列の最後のスラッシュまたはバックスラッシュ以降の部分を返します。入力文字列がスラッシュまたはバックスラッシュで終わる場合、関数は空文字列を返します。スラッシュやバックスラッシュが存在しない場合は元の文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**Unix パスからファイル名を抽出**

```sql title=Query
SELECT 'some/long/path/to/file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some/long/path/to/file')─┐
│ some/long/path/to/file │ file                               │
└────────────────────────┴────────────────────────────────────┘
```

**Windows のパスからファイル名を抽出する**

```sql title=Query
SELECT 'some\\long\\path\\to\\file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some\\long\\path\\to\\file')─┐
│ some\long\path\to\file │ file                                   │
└────────────────────────┴────────────────────────────────────────┘
```

**パス区切り文字を含まない文字列**

```sql title=Query
SELECT 'some-file-name' AS a, basename(a)
```

```response title=Response
┌─a──────────────┬─basename('some-file-name')─┐
│ some-file-name │ some-file-name             │
└────────────────┴────────────────────────────┘
```

## byteHammingDistance {#byteHammingDistance}

導入バージョン: v23.9

2つのバイト文字列間の[ハミング距離](https://en.wikipedia.org/wiki/Hamming_distance)を計算します。

**構文**

```sql
byteHammingDistance(s1, s2)
```

**エイリアス**: `mismatches`

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列のハミング距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT byteHammingDistance('karolin', 'kathrin')
```

```response title=Response
┌─byteHammingDistance('karolin', 'kathrin')─┐
│                                         3 │
└───────────────────────────────────────────┘
```

## compareSubstrings {#compareSubstrings}

導入バージョン: v25.2

2つの文字列を辞書順で比較します。

**構文**

```sql
compareSubstrings(s1, s2, s1_offset, s2_offset, num_bytes)
```

**引数**

* `s1` — 比較する最初の文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 比較する2番目の文字列。[`String`](/sql-reference/data-types/string)
* `s1_offset` — 比較を開始する `s1` 内の位置（0始まり）。[`UInt*`](/sql-reference/data-types/int-uint)
* `s2_offset` — 比較を開始する `s2` 内の位置（0始まりのインデックス）。[`UInt*`](/sql-reference/data-types/int-uint)
* `num_bytes` — 両方の文字列で比較する最大バイト数。`s1_offset`（または `s2_offset`） + `num_bytes` が入力文字列の末尾を超える場合、`num_bytes` はそれに応じて調整されます。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

次の値を返します:

* `-1` — `s1`[`s1_offset` : `s1_offset` + `num_bytes`] &lt; `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合。
* `0` — `s1`[`s1_offset` : `s1_offset` + `num_bytes`] = `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合。
* `1` — `s1`[`s1_offset` : `s1_offset` + `num_bytes`] &gt; `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合。
  [`Int8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT compareSubstrings('Saxony', 'Anglo-Saxon', 0, 6, 5) AS result
```

```response title=Response
┌─result─┐
│      0 │
└────────┘
```

## concat {#concat}

導入バージョン: v1.1

指定された引数を連結します。

[`String`](../data-types/string.md) または [`FixedString`](../data-types/fixedstring.md) 型ではない引数は、デフォルトのシリアライゼーションを用いて文字列に変換されます。
これはパフォーマンスを低下させるため、String/FixedString 以外の引数の使用は推奨されません。

**構文**

```sql
concat([s1, s2, ...])
```

**引数**

* `s1, s2, ...` — 任意の型の値を任意の数だけ指定できます。[`Any`](/sql-reference/data-types)

**戻り値**

引数を連結して作成された String を返します。いずれかの引数が `NULL` の場合、関数は `NULL` を返します。引数が 1 つも指定されていない場合は、空文字列を返します。[`Nullable(String)`](/sql-reference/data-types/nullable)

**例**

**文字列の連結**

```sql title=Query
SELECT concat('Hello, ', 'World!')
```

```response title=Response
┌─concat('Hello, ', 'World!')─┐
│ Hello, World!               │
└─────────────────────────────┘
```

**数値の結合**

```sql title=Query
SELECT concat(42, 144)
```

```response title=Response
┌─concat(42, 144)─┐
│ 42144           │
└─────────────────┘
```

## concatAssumeInjective {#concatAssumeInjective}

導入バージョン: v1.1

[`concat`](#concat) と同様ですが、`concat(s1, s2, ...) → sn` が単射である、
つまり異なる引数に対して常に異なる結果を返すと仮定します。

`GROUP BY` の最適化に使用できます。

**構文**

```sql
concatAssumeInjective([s1, s2, ...])
```

**引数**

* `s1, s2, ...` — 任意の型の値を任意の数だけ指定できます。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**返り値**

引数を連結して生成された文字列を返します。いずれかの引数の値が `NULL` の場合、関数は `NULL` を返します。引数が 1 つも指定されない場合は、空文字列を返します。型は [`String`](/sql-reference/data-types/string) です。

**使用例**

**GROUP BY の最適化**

```sql title=Query
SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY concatAssumeInjective(key1, key2)
```

```response title=Response
┌─concat(key1, key2)─┬─sum(value)─┐
│ Hello, World!      │          3 │
│ Hello, World!      │          2 │
│ Hello, World       │          3 │
└────────────────────┴────────────┘
```

## concatWithSeparator {#concatWithSeparator}

導入バージョン: v22.12

指定した区切り文字で区切って、指定された文字列を連結します。

**構文**

```sql
concatWithSeparator(sep[, exp1, exp2, ...])
```

**別名**: `concat_ws`

**引数**

* `sep` — 使用する区切り文字。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)
* `exp1, exp2, ...` — 連結する式。型が `String` または `FixedString` でない引数は、デフォルトのシリアル化により文字列に変換されます。これはパフォーマンスを低下させるので、非 String/FixedString 型の引数を使用することは推奨されません。[`Any`](/sql-reference/data-types)

**戻り値**

引数を連結して生成された String を返します。いずれかの引数の値が `NULL` の場合、関数は `NULL` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT concatWithSeparator('a', '1', '2', '3', '4')
```

```response title=Response
┌─concatWithSeparator('a', '1', '2', '3', '4')─┐
│ 1a2a3a4                                      │
└──────────────────────────────────────────────┘
```

## concatWithSeparatorAssumeInjective {#concatWithSeparatorAssumeInjective}

導入バージョン: v22.12

[`concatWithSeparator`](#concatWithSeparator) と同様ですが、`concatWithSeparator(sep[,exp1, exp2, ... ]) → result` が単射であると仮定します。
関数は、異なる引数に対して必ず異なる結果を返す場合に単射と呼ばれます。

`GROUP BY` の最適化に使用できます。

**構文**

```sql
concatWithSeparatorAssumeInjective(sep[, exp1, exp2, ... ])
```

**引数**

* `sep` — 使用するセパレーター。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)
* `exp1, exp2, ...` — 連結する式。`String` または `FixedString` 型ではない引数は、デフォルトのシリアライゼーションを使用して文字列に変換されます。これはパフォーマンスの低下を招くため、非 String/FixedString 引数の使用は推奨されません。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**返される値**

引数を連結して生成された String 型の値を返します。いずれかの引数の値が `NULL` の場合、関数は `NULL` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
CREATE TABLE user_data (
user_id UInt32,
first_name String,
last_name String,
score UInt32
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO user_data VALUES
(1, 'John', 'Doe', 100),
(2, 'Jane', 'Smith', 150),
(3, 'John', 'Wilson', 120),
(4, 'Jane', 'Smith', 90);

SELECT
    concatWithSeparatorAssumeInjective('-', first_name, last_name) as full_name,
    sum(score) as total_score
FROM user_data
GROUP BY concatWithSeparatorAssumeInjective('-', first_name, last_name);
```

```response title=Response
┌─full_name───┬─total_score─┐
│ Jane-Smith  │         240 │
│ John-Doe    │         100 │
│ John-Wilson │         120 │
└─────────────┴─────────────┘
```

## conv {#conv}

導入バージョン: v1.1

異なる基数の間で数値を変換します。

この関数は、ある基数から別の基数へ数値を変換します。2 から 36 までの基数をサポートします。
10 を超える基数では、10〜35 の数字を表すために文字 A〜Z（大文字・小文字は区別されません）が使用されます。

この関数は MySQL の CONV() 関数と互換性があります。

**構文**

```sql
conv(number, from_base, to_base)
```

**引数**

* `number` — 変換する数値。文字列または数値型を指定できます。 - `from_base` — 変換元の基数 (2-36)。整数である必要があります。 - `to_base` — 変換先の基数 (2-36)。整数である必要があります。

**戻り値**

変換先の基数で表現された数値の文字列表現。

**例**

**10 進数を 2 進数に変換**

```sql title=Query
SELECT conv('10', 10, 2)
```

```response title=Response
1010
```

**16進数を10進数に変換**

```sql title=Query
SELECT conv('FF', 16, 10)
```

```response title=Response
255
```

**負の数で変換**

```sql title=Query
SELECT conv('-1', 10, 16)
```

```response title=Response
FFFFFFFFFFFFFFFF
```

**2進数を8進数に変換**

```sql title=Query
SELECT conv('1010', 2, 8)
```

```response title=Response
12
```

## convertCharset {#convertCharset}

導入バージョン: v1.1

エンコーディング `from` から `to` へ変換した文字列 `s` を返します。

**構文**

```sql
convertCharset(s, from, to)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `from` — 変換元の文字エンコーディング。[`String`](/sql-reference/data-types/string)
* `to` — 変換先の文字エンコーディング。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列 `s` を、エンコーディング `from` から `to` に変換して返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT convertCharset('Café', 'UTF-8', 'ISO-8859-1');
```

```response title=Response
┌─convertChars⋯SO-8859-1')─┐
│ Caf�                     │
└──────────────────────────┘
```

## damerauLevenshteinDistance {#damerauLevenshteinDistance}

導入バージョン: v24.1

2つのバイト列間の [Damerau-Levenshtein 距離](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance) を計算します。

**構文**

```sql
damerauLevenshteinDistance(s1, s2)
```

**引数**

* `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の Damerau-Levenshtein 距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT damerauLevenshteinDistance('clickhouse', 'mouse')
```

```response title=Response
┌─damerauLevenshteinDistance('clickhouse', 'mouse')─┐
│                                                 6 │
└───────────────────────────────────────────────────┘
```

## decodeHTMLComponent {#decodeHTMLComponent}

導入バージョン: v23.9

文字列内の HTML エンティティ参照を対応する文字にデコードします。

**構文**

```sql
decodeHTMLComponent(s)
```

**引数**

* `s` — デコードする HTML エンティティを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

HTML エンティティをデコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')
```

```response title=Response
┌─decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')─┐
│ <div>Hello & "World"</div>                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

## decodeXMLComponent {#decodeXMLComponent}

導入バージョン: v21.2

文字列内の XML エンティティを対応する文字にデコードします。

**構文**

```sql
decodeXMLComponent(s)
```

**引数**

* `s` — デコードする XML エンティティを含む文字列。[`String`](/sql-reference/data-types/string)

**返り値**

指定された文字列内の XML エンティティをデコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT decodeXMLComponent('&lt;tag&gt;Hello &amp; World&lt;/tag&gt;')
```

```response title=Response
┌─decodeXMLCom⋯;/tag&gt;')─┐
│ <tag>Hello & World</tag> │
└──────────────────────────┘
```

## editDistance {#editDistance}

導入バージョン: v23.9

2つのバイト列間の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)を計算します。

**構文**

```sql
editDistance(s1, s2)
```

**別名**: `levenshteinDistance`

**引数**

* `s1` — 1 つ目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列間の編集距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT editDistance('clickhouse', 'mouse')
```

```response title=Response
┌─editDistance('clickhouse', 'mouse')─┐
│                                   6 │
└─────────────────────────────────────┘
```

## editDistanceUTF8 {#editDistanceUTF8}

導入バージョン: v24.6

2 つの UTF8 文字列間の [編集距離](https://en.wikipedia.org/wiki/Edit_distance) を計算します。

**構文**

```sql
editDistanceUTF8(s1, s2)
```

**エイリアス**: `levenshteinDistanceUTF8`

**引数**

* `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**返される値**

2つの UTF8 文字列間の編集距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT editDistanceUTF8('我是谁', '我是我')
```

```response title=Response
┌─editDistanceUTF8('我是谁', '我是我')──┐
│                                   1 │
└─────────────────────────────────────┘
```

## encodeXMLComponent {#encodeXMLComponent}

導入バージョン: v21.1

文字列を XML テキストノードまたは属性内に配置できるように、文字をエスケープします。

**構文**

```sql
encodeXMLComponent(s)
```

**引数**

* `s` — エスケープする文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

エスケープされた文字列。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    '<tag>Hello & "World"</tag>' AS original,
    encodeXMLComponent('<tag>Hello & "World"</tag>') AS xml_encoded;
```

```response title=Response
┌─original───────────────────┬─xml_encoded──────────────────────────────────────────┐
│ <tag>こんにちは & "世界"</tag> │ &lt;tag&gt;こんにちは &amp; &quot;世界&quot;&lt;/tag&gt; │
└────────────────────────────┴──────────────────────────────────────────────────────┘
```

## endsWith {#endsWith}

導入バージョン: v1.1

文字列が指定されたサフィックスで終わるかどうかを判定します。

**構文**

```sql
endsWith(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 末尾に付いているかを確認する接尾辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `suffix` で終わる場合は `1` を、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWith('ClickHouse', 'House');
```

```response title=Response
┌─endsWith('Cl⋯', 'House')─┐
│                        1 │
└──────────────────────────┘
```

## endsWithCaseInsensitive {#endsWithCaseInsensitive}

導入バージョン: v25.9

文字列が、大文字小文字を区別せずに指定したサフィックスで終わっているかどうかをチェックします。

**構文**

```sql
endsWithCaseInsensitive(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 末尾として一致するかを判定する、大文字・小文字を区別しないサフィックス。[`String`](/sql-reference/data-types/string)

**返り値**

`s` の末尾が、大文字・小文字を区別せずに `suffix` と一致する場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithCaseInsensitive('ClickHouse', 'HOUSE');
```

```response title=Response
┌─endsWithCaseInsensitive('Cl⋯', 'HOUSE')─┐
│                                       1 │
└─────────────────────────────────────────┘
```

## endsWithCaseInsensitiveUTF8 {#endsWithCaseInsensitiveUTF8}

導入バージョン: v25.9

文字列 `s` が、大文字と小文字を区別せずに `suffix` で終わるかどうかを返します。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合、例外はスローされず、結果は未定義です。

**構文**

```sql
endsWithCaseInsensitiveUTF8(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 大文字小文字を区別せずに判定されるサフィックス文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が大文字小文字を区別せずに `suffix` で終わる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithCaseInsensitiveUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithCaseInsensitiveUTF8('данных', 'ых')─┐
│                                           1 │
└─────────────────────────────────────────────┘
```

## endsWithUTF8 {#endsWithUTF8}

導入バージョン: v23.8

文字列 `s` が `suffix` で終わるかどうかを返します。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が成り立たない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
endsWithUTF8(s, suffix)
```

**引数**

* `s` — 判定対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 末尾にあるかを確認するサフィックス文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `suffix` で終わる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithUTF8('данных', 'ых')─┐
│                            1 │
└──────────────────────────────┘
```

## extractTextFromHTML {#extractTextFromHTML}

導入バージョン: v21.3

HTML または XHTML からテキストコンテンツを抽出します。

この関数は、HTML タグ、コメント、script/style 要素を削除し、テキストコンテンツのみを残します。次の処理を行います:

* すべての HTML/XML タグの削除
* コメント（`<!-- -->`）の削除
* script および style 要素とその内容の削除
* CDATA セクションの処理（内容をそのままコピー）
* 空白文字の適切な処理と正規化

注意: HTML エンティティはデコードされないため、必要に応じて別の関数で処理する必要があります。

**構文**

```sql
extractTextFromHTML(html)
```

**引数**

* `html` — テキストを抽出する対象の HTML コンテンツを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

空白を正規化した抽出済みのテキストコンテンツを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT extractTextFromHTML('
<html>
    <head><title>ページタイトル</title></head>
    <body>
        <p>こんにちは <b>世界</b>！</p>
        <script>alert("test");</script>
        <!-- comment -->
    </body>
</html>
');
```

```response title=Response
┌─extractTextFromHTML('<html><head>...')─┐
│ Page Title Hello World!                │
└────────────────────────────────────────┘
```

## firstLine {#firstLine}

導入されたバージョン: v23.7

複数行文字列の最初の行を返します。

**構文**

```sql
firstLine(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列に含まれる最初の行を返します。改行文字が存在しない場合は、文字列全体を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT firstLine('foo\\nbar\\nbaz')
```

```response title=Response
┌─firstLine('foo\nbar\nbaz')─┐
│ foo                        │
└────────────────────────────┘
```

## idnaDecode {#idnaDecode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications) (IDNA) メカニズムに従って、ドメイン名の Unicode（UTF-8）表現（ToUnicode アルゴリズム）を返します。
エラーが発生した場合（例: 入力が無効な場合）、入力文字列をそのまま返します。
大文字小文字の正規化により、[`idnaEncode()`](#idnaEncode) と [`idnaDecode()`](#idnaDecode) を繰り返し適用しても、必ずしも元の文字列には戻らないことに注意してください。

**構文**

```sql
idnaDecode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**返される値**

入力値に対して IDNA メカニズムを適用し、入力文字列を Unicode (UTF-8) で表現した値を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')
```

```response title=Response
┌─idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')─┐
│ straße.münchen.de                             │
└───────────────────────────────────────────────┘
```

## idnaEncode {#idnaEncode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications) (IDNA) の仕組みに従って、ドメイン名の ASCII 表現（ToASCII アルゴリズム）を返します。
入力文字列は UTF でエンコードされており、ASCII 文字列に変換可能である必要があります。条件を満たさない場合は例外がスローされます。

:::note
パーセントデコードや、タブ・スペース・制御文字のトリミングは行われません。
:::

**構文**

```sql
idnaEncode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**返される値**

入力値に対する IDNA メカニズムに従い、入力文字列の ASCII 表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT idnaEncode('straße.münchen.de')
```

```response title=Response
┌─idnaEncode('straße.münchen.de')─────┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```

## initcap {#initcap}

導入バージョン: v23.7

各単語の最初の文字を大文字にし、それ以外を小文字に変換します。
ここでの単語とは、英数字から成る連続した文字列であり、英数字以外の文字によって区切られたものを指します。

:::note
`initcap` は各単語の最初の文字のみを大文字に変換するため、アポストロフィや大文字を含む単語では予期しない動作が発生する場合があります。
これは既知の挙動であり、現時点で修正の予定はありません。
:::

**構文**

```sql
initcap(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

各単語の先頭文字を大文字に変換した `s` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT initcap('building for fast')
```

```response title=Response
┌─initcap('building for fast')─┐
│ Building For Fast            │
└──────────────────────────────┘
```

**アポストロフィや大文字を含む単語に関する既知の動作の例**

```sql title=Query
SELECT initcap('John''s cat won''t eat.');
```

```response title=Response
┌─initcap('Joh⋯n\'t eat.')─┐
│ John'S Cat Won'T Eat.    │
└──────────────────────────┘
```

## initcapUTF8 {#initcapUTF8}

導入バージョン: v23.7

[`initcap`](#initcap) と同様に、`initcapUTF8` は各単語の最初の文字を大文字にし、残りを小文字に変換します。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合でも例外はスローされず、結果は未定義です。

:::note
この関数は言語を判別しません。例えばトルコ語では結果が正確にならない場合があります (i/İ と i/I など)。
あるコードポイントにおいて、大文字と小文字で UTF-8 のバイト列の長さが異なる場合、そのコードポイントに対する結果は正しくない可能性があります。
:::

**構文**

```sql
initcapUTF8(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

各単語の先頭文字を大文字に変換した `s` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT initcapUTF8('не тормозит')
```

```response title=Response
┌─initcapUTF8('не тормозит')─┐
│ Не Тормозит                │
└────────────────────────────┘
```

## isValidASCII {#isValidASCII}

導入バージョン: v25.9

入力の String または FixedString が ASCII バイト (0x00–0x7F) のみを含む場合は 1、それ以外の場合は 0 を返します。正のケース（入力が有効な ASCII である場合）に最適化されています。

**構文**

```sql
```

**エイリアス**: `isASCII`

**引数**

* なし。

**戻り値**

**例**

**isValidASCII**

```sql title=Query
SELECT isValidASCII('hello') AS is_ascii, isValidASCII('你好') AS is_not_ascii
```

```response title=Response
```


## isValidUTF8 {#isValidUTF8}

導入バージョン: v20.1

バイト列が有効な UTF-8 でエンコードされたテキストかどうかを確認します。

**構文**

```sql
isValidUTF8(s)
```

**引数**

* `s` — UTF-8 エンコードの有効性を検査する対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

バイト列が有効な UTF-8 でエンコードされたテキストを構成していれば `1`、そうでなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT isValidUTF8('\\xc3\\xb1') AS valid, isValidUTF8('\\xc3\\x28') AS invalid
```

```response title=Response
┌─valid─┬─invalid─┐
│     1 │       0 │
└───────┴─────────┘
```

## jaroSimilarity {#jaroSimilarity}

導入: v24.1

2 つのバイト文字列間の [Jaro 類似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance#Jaro_similarity) を計算します。

**構文**

```sql
jaroSimilarity(s1, s2)
```

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列間の Jaro 類似度を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT jaroSimilarity('clickhouse', 'click')
```

```response title=Response
┌─jaroSimilarity('clickhouse', 'click')─┐
│                    0.8333333333333333 │
└───────────────────────────────────────┘
```

## jaroWinklerSimilarity {#jaroWinklerSimilarity}

導入バージョン: v24.1

2 つのバイト列間の [Jaro-Winkler 類似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance) を計算します。

**構文**

```sql
jaroWinklerSimilarity(s1, s2)
```

**引数**

* `s1` — 1 つ目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列間の Jaro-Winkler 類似度を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT jaroWinklerSimilarity('clickhouse', 'click')
```

```response title=Response
┌─jaroWinklerSimilarity('clickhouse', 'click')─┐
│                           0.8999999999999999 │
└──────────────────────────────────────────────┘
```

## left {#left}

導入バージョン: v22.1

文字列 `s` の左端から、指定された `offset` の長さの部分文字列を返します。

**構文**

```sql
left(s, offset)
```

**引数**

* `s` — 部分文字列を取得する対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットを表すバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

戻り値:

* 正の `offset` の場合、文字列の左側から開始し、`offset` バイト分の `s` の部分文字列。
* 負の `offset` の場合、文字列の左側から開始し、`length(s) - |offset|` バイト分の `s` の部分文字列。
* `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正のオフセット**

```sql title=Query
SELECT left('Hello World', 5)
```

```response title=Response
Hello
```

**負のオフセット**

```sql title=Query
SELECT left('Hello World', -6)
```

```response title=Response
Hello
```

## leftPad {#leftPad}

導入: v21.8

結果の文字列が指定された `length` に達するまで、左側からスペースまたは指定した文字列（必要に応じて複数回）で文字列を埋めます。

**構文**

```sql
leftPad(string, length[, pad_string])
```

**別名**: `lpad`

**引数**

* `string` — パディング対象となる入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果の文字列の長さ。値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 省略可。入力文字列をパディングする際に使用する文字列。指定されていない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**返される値**

指定した長さになるよう左側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT leftPad('abc', 7, '*'), leftPad('def', 7)
```

```response title=Response
┌─leftPad('abc', 7, '*')─┬─leftPad('def', 7)─┐
│ ****abc                │     def           │
└────────────────────────┴───────────────────┘
```

## leftPadUTF8 {#leftPadUTF8}

導入バージョン: v21.8

UTF-8 文字列の左側を、スペースまたは指定した文字列で（必要に応じて複数回）パディングし、結果の文字列が指定された長さに達するまで埋めます。
文字列の長さをバイト数で測定する [`leftPad`](#leftPad) と異なり、文字列の長さはコードポイント数で測定されます。

**構文**

```sql
leftPadUTF8(string, length[, pad_string])
```

**引数**

* `string` — パディング対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果の文字列の長さ。値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 省略可能。入力文字列をパディングするための文字列。指定されていない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**返される値**

指定された長さになるよう左側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT leftPadUTF8('абвг', 7, '*'), leftPadUTF8('дежз', 7)
```

```response title=Response
┌─leftPadUTF8('абвг', 7, '*')─┬─leftPadUTF8('дежз', 7)─┐
│ ***абвг                     │    дежз                │
└─────────────────────────────┴────────────────────────┘
```

## leftUTF8 {#leftUTF8}

導入バージョン: v22.1

UTF-8 エンコードされた文字列 `s` に対して、左端からの `offset` で指定された位置を開始位置とする部分文字列を返します。

**構文**

```sql
leftUTF8(s, offset)
```

**引数**

* `s` — 部分文字列を計算する対象の UTF-8 エンコード済み文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

次を返します:

* 正の `offset` の場合、文字列の左端から開始する、`offset` バイト分の `s` の部分文字列。
* 負の `offset` の場合、文字列の左端から開始する、`length(s) - |offset|` バイト分の `s` の部分文字列。
* `length` が 0 の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT leftUTF8('Привет', 4)
```

```response title=Response
Прив
```

**負のオフセット**

```sql title=Query
SELECT leftUTF8('Привет', -4)
```

```response title=Response
Пр
```

## lengthUTF8 {#lengthUTF8}

導入: v1.1

文字列の長さを、バイト数や文字数ではなく Unicode コードポイント数で返します。
文字列は有効な UTF-8 でエンコードされたテキストであると仮定します。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
lengthUTF8(s)
```

**別名**: `CHAR_LENGTH`, `CHARACTER_LENGTH`

**引数**

* `s` — 有効な UTF-8 でエンコードされたテキストを含む文字列。[`String`](/sql-reference/data-types/string)

**返される値**

文字列 `s` の長さ（Unicode コードポイント数）。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT lengthUTF8('Здравствуй, мир!')
```

```response title=Response
┌─lengthUTF8('Здравствуй, мир!')─┐
│                             16 │
└────────────────────────────────┘
```

## lower {#lower}

導入: v1.1

ASCII 文字列を小文字に変換します。

**構文**

```sql
lower(s)
```

**別名**: `lcase`

**引数**

* `s` — 小文字に変換する対象の文字列。 [`String`](/sql-reference/data-types/string)

**返り値**

`s` を小文字に変換した文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT lower('CLICKHOUSE')
```

```response title=Response
┌─lower('CLICKHOUSE')─┐
│ clickhouse          │
└─────────────────────┘
```

## lowerUTF8 {#lowerUTF8}

導入バージョン: v1.1

文字列が有効な UTF-8 でエンコードされたテキストであると仮定して、小文字に変換します。この前提が満たされない場合でも、例外はスローされず、結果は未定義になります。

**構文**

```sql
lowerUTF8(input)
```

**引数**

* `input` — 小文字に変換する入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

小文字に変換された文字列を返します。[`String`](/sql-reference/data-types/string)

**使用例**

**first**

```sql title=Query
SELECT lowerUTF8('München') as Lowerutf8;
```

```response title=Response
münchen
```

## normalizeUTF8NFC {#normalizeUTF8NFC}

導入: v21.11

UTF-8文字列を [NFC 正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って正規化します。

**構文**

```sql
normalizeUTF8NFC(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**返り値**

UTF-8 文字列の NFC 正規化形式を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
'é' AS original, -- e + 結合アキュートアクセント (U+0065 + U+0301)
length(original),
normalizeUTF8NFC('é') AS nfc_normalized, -- é (U+00E9)
length(nfc_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfc_normalized─┬─length(nfc_normalized)─┐
│ é        │                2 │ é              │                      2 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```

## normalizeUTF8NFD {#normalizeUTF8NFD}

導入バージョン: v21.11

UTF-8 文字列を、[NFD 正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)に従って正規化します。

**構文**

```sql
normalizeUTF8NFD(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**返り値**

UTF-8 文字列を NFD 形式に正規化した値を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    'é' AS original, -- é (U+00E9) アキュート付きe
    length(original),
    normalizeUTF8NFD('é') AS nfd_normalized, -- e + 結合アキュート (U+0065 + U+0301)
    length(nfd_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfd_normalized─┬─length(nfd_normalized)─┐
│ é        │                2 │ é              │                      3 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```

## normalizeUTF8NFKC {#normalizeUTF8NFKC}

導入バージョン: v21.11

UTF-8 文字列を [NFKC 正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って正規化します。

**構文**

```sql
normalizeUTF8NFKC(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8 文字列を NFKC 形式に正規化した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    '① ② ③' AS original,                            -- 丸囲み数字
    normalizeUTF8NFKC('① ② ③') AS nfkc_normalized;  -- 1 2 3 に変換されます
```

```response title=Response
┌─original─┬─nfkc_normalized─┐
│ ① ② ③  │ 1 2 3           │
└──────────┴─────────────────┘
```

## normalizeUTF8NFKD {#normalizeUTF8NFKD}

導入されたバージョン: v21.11

UTF-8 文字列を [NFKD 正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って正規化します。

**構文**

```sql
normalizeUTF8NFKD(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**返される値**

UTF-8 文字列を NFKD 形式に正規化したものを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    'H₂O²' AS original,                            -- H + 下付き文字2 + O + 上付き文字2
    normalizeUTF8NFKD('H₂O²') AS nfkd_normalized;  -- H 2 O 2 に変換
```

```response title=Response
┌─original─┬─nfkd_normalized─┐
│ H₂O²     │ H2O2            │
└──────────┴─────────────────┘
```

## punycodeDecode {#punycodeDecode}

導入バージョン: v24.1

[Punycode](https://en.wikipedia.org/wiki/Punycode) でエンコードされた文字列の、UTF8 エンコードされたプレーンテキストを返します。
有効な Punycode でエンコードされた文字列が指定されていない場合は、例外がスローされます。

**構文**

```sql
punycodeDecode(s)
```

**引数**

* `s` — Punycode でエンコードされた文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値のプレーンテキストを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT punycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─punycodeDecode('Mnchen-3ya')─┐
│ München                      │
└──────────────────────────────┘
```

## punycodeEncode {#punycodeEncode}

導入バージョン: v24.1

文字列の [Punycode](https://en.wikipedia.org/wiki/Punycode) 表現を返します。
文字列は UTF-8 でエンコードされている必要があり、そうでない場合の動作は未定義です。

**構文**

```sql
punycodeEncode(s)
```

**引数**

* `s` — 入力値。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値を Punycode 形式で表した値を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT punycodeEncode('München')
```

```response title=Response
┌─punycodeEncode('München')─┐
│ Mnchen-3ya                │
└───────────────────────────┘
```

## regexpExtract {#regexpExtract}

導入バージョン: v23.2

`haystack` 内で正規表現パターンにマッチし、指定した正規表現グループインデックスに対応する最初の文字列を抽出します。

**構文**

```sql
regexpExtract(haystack, pattern[, index])
```

**別名**: `REGEXP_EXTRACT`

**引数**

* `haystack` — 正規表現パターンをマッチさせる対象となる文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターンを表す文字列。`pattern` には複数の正規表現グループを含めることができ、`index` はどの正規表現グループを抽出するかを示します。`index` が 0 の場合は、正規表現全体にマッチした部分（全体一致）を意味します。[`const String`](/sql-reference/data-types/string)
* `index` — 省略可能。0 以上の整数値で、デフォルト値は 1 です。抽出する正規表現グループを表します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

マッチした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    regexpExtract('100-200', '(\\d+)-(\\d+)', 1),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 2),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 0),
    regexpExtract('100-200', '(\\d+)-(\\d+)');
```

```response title=Response
┌─regexpExtract('100-200', '(\\d+)-(\\d+)', 1)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 2)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 0)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)')─┐
│ 100                                          │ 200                                          │ 100-200                                      │ 100                                       │
└──────────────────────────────────────────────┴──────────────────────────────────────────────┴──────────────────────────────────────────────┴───────────────────────────────────────────┘
```

## repeat {#repeat}

導入されたバージョン: v20.1

指定された回数だけ、文字列を繰り返し連結します。

**構文**

```sql
repeat(s, n)
```

**引数**

* `s` — 繰り返す文字列。[`String`](/sql-reference/data-types/string)
* `n` — 文字列を繰り返す回数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

文字列 `s` を `n` 回繰り返した文字列。`n` が負の場合、関数は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT repeat('abc', 10)
```

```response title=Response
┌─repeat('abc', 10)──────────────┐
│ abcabcabcabcabcabcabcabcabcabc │
└────────────────────────────────┘
```

## reverseUTF8 {#reverseUTF8}

導入バージョン: v1.1

文字列内の Unicode コードポイントの並びを逆順にします。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義になります。

**構文**

```sql
reverseUTF8(s)
```

**引数**

* `s` — 有効な UTF-8 でエンコードされたテキストを含む文字列。[`String`](/sql-reference/data-types/string)

**返り値**

Unicode コードポイントの並びを逆順にした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT reverseUTF8('ClickHouse')
```

```response title=Response
esuoHkcilC
```

## right {#right}

導入バージョン: v22.1

文字列 `s` の末尾（右側）から数えて `offset` 文字分の部分文字列を返します。

**構文**

```sql
right(s, offset)
```

**引数**

* `s` — 部分文字列を計算する対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返り値**

次を返します：

* 正の `offset` の場合、文字列の右端から `offset` バイト分の `s` の部分文字列。
* 負の `offset` の場合、文字列の右端から `length(s) - |offset|` バイト分の `s` の部分文字列。
* `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT right('Hello', 3)
```

```response title=Response
llo
```

**負のオフセット**

```sql title=Query
SELECT right('Hello', -3)
```

```response title=Response
lo
```

## rightPad {#rightPad}

導入バージョン: v21.8

文字列の右端をスペースまたは指定した文字列（必要に応じて複数回）で埋めて、結果の文字列が指定された `length` に達するまでパディングします。

**構文**

```sql
rightPad(string, length[, pad_string])
```

**別名**: `rpad`

**引数**

* `string` — パディング対象となる入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 生成される文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — オプション。入力文字列をパディングするための文字列。指定されていない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**返される値**

指定された長さの、右側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT rightPad('abc', 7, '*'), rightPad('abc', 7)
```

```response title=Response
┌─rightPad('abc', 7, '*')─┬─rightPad('abc', 7)─┐
│ abc****                 │ abc                │
└─────────────────────────┴────────────────────┘
```

## rightPadUTF8 {#rightPadUTF8}

導入バージョン: v21.8

文字列の右側を空白、または指定した文字列（必要に応じて複数回）で埋め、結果の文字列が指定された長さに達するまでパディングします。
文字列長をバイト数で測定する [`rightPad`](#rightPad) と異なり、文字列長はコードポイント数で測定されます。

**構文**

```sql
rightPadUTF8(string, length[, pad_string])
```

**引数**

* `string` — パディング対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果となる文字列の長さ。値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 省略可能。入力文字列をパディングする際に使用する文字列。指定しない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定した長さの右側パディング済み文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT rightPadUTF8('абвг', 7, '*'), rightPadUTF8('абвг', 7)
```

```response title=Response
┌─rightPadUTF8('абвг', 7, '*')─┬─rightPadUTF8('абвг', 7)─┐
│ абвг***                      │ абвг                    │
└──────────────────────────────┴─────────────────────────┘
```

## rightUTF8 {#rightUTF8}

導入バージョン: v22.1

UTF-8 でエンコードされた文字列 `s` に対して、右端から数えた指定の `offset` 位置を開始位置とする部分文字列を返します。

**構文**

```sql
rightUTF8(s, offset)
```

**引数**

* `s` — 部分文字列を取得する対象の UTF-8 エンコード文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットを表すバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

戻り値:

* 正の `offset` の場合、文字列の右端から数えて `offset` バイト分の `s` の部分文字列。
* 負の `offset` の場合、文字列の右端から数えて `length(s) - |offset|` バイト分の `s` の部分文字列。
* `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT rightUTF8('Привет', 4)
```

```response title=Response
ивет
```

**負のオフセット**

```sql title=Query
SELECT rightUTF8('Привет', -4)
```

```response title=Response
ет
```

## soundex {#soundex}

導入バージョン: v23.4

文字列の [Soundex コード](https://en.wikipedia.org/wiki/Soundex) を返します。

**構文**

```sql
soundex(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列の Soundex コードを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT soundex('aksel')
```

```response title=Response
┌─soundex('aksel')─┐
│ A240             │
└──────────────────┘
```

## space {#space}

導入バージョン: v23.5

指定された回数分の空白文字（` `）を連結して返します。

**構文**

```sql
space(n)
```

**引数**

* `n` — スペースを繰り返す回数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

スペースを `n` 回繰り返した文字列を返します。`n <= 0` の場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT space(3) AS res, length(res);
```

```response title=Response
┌─res─┬─length(res)─┐
│     │           3 │
└─────┴─────────────┘
```

## sparseGrams {#sparseGrams}

導入バージョン: v25.5

指定された文字列から、長さが少なくとも `n` のすべての部分文字列を抽出します。
このとき、その部分文字列の両端にある (n-1)-gram のハッシュ値が、
その部分文字列内部に含まれるどの (n-1)-gram のハッシュ値よりも厳密に大きいものだけを対象とします。
ハッシュ関数としては `CRC32` を使用します。

**構文**

```sql
sparseGrams(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される n-gram の最小長。デフォルトかつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される n-gram の最大長。デフォルト値は 100。`min_ngram_length` 以上である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

選択された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGrams('alice', 3)
```

```response title=Response
┌─sparseGrams('alice', 3)────────────┐
│ ['ali','lic','lice','ice']         │
└────────────────────────────────────┘
```

## sparseGramsHashes {#sparseGramsHashes}

導入: v25.5

長さが少なくとも `n` ある、指定された文字列のすべての部分文字列のハッシュ値を求めます。
ここで、その部分文字列の境界にある (n-1)-gram のハッシュ値は、
その部分文字列内部にある任意の (n-1)-gram のハッシュ値よりも常に大きくなります。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsHashes(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可。抽出される n-gram の最小長さ。デフォルトかつ最小の値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可。抽出される n-gram の最大長さ。デフォルト値は 100。`min_ngram_length` 以上でなければならない。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択された部分文字列の CRC32 ハッシュ値の配列を返す。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsHashes('alice', 3)
```

```response title=Response
┌─sparseGramsHashes('alice', 3)──────────────────────┐
│ [1481062250,2450405249,4012725991,1918774096]      │
└────────────────────────────────────────────────────┘
```

## sparseGramsHashesUTF8 {#sparseGramsHashesUTF8}

導入: v25.5

指定された UTF-8 文字列について、長さが少なくとも `n` のすべての部分文字列のハッシュを求めます。このとき、その部分文字列の両端にある (n-1)-gram のハッシュが、その部分文字列内に含まれる任意の (n-1)-gram のハッシュよりも厳密に大きい場合のみを対象とします。
UTF-8 文字列を受け取り、UTF-8 の不正なシーケンスが含まれている場合は例外をスローします。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsHashesUTF8(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される n-gram の長さの最小値。デフォルトかつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される n-gram の長さの最大値。デフォルト値は 100。`min_ngram_length` 以上でなければなりません。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択された UTF-8 部分文字列の CRC32 ハッシュ値の配列を返します。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsHashesUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsHashesUTF8('алиса', 3)─┐
│ [4178533925,3855635300,561830861] │
└───────────────────────────────────┘
```

## sparseGramsUTF8 {#sparseGramsUTF8}

導入バージョン: v25.5

与えられた UTF-8 文字列について、長さが少なくとも `n` であり、かつその部分文字列の両端にある (n-1)-gram のハッシュ値が、その部分文字列内に含まれるいずれの (n-1)-gram のハッシュ値よりも厳密に大きくなるような、すべての部分文字列を検出します。
UTF-8 文字列を入力として受け取り、無効な UTF-8 シーケンスがあった場合は例外をスローします。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsUTF8(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される n-gram の最小長さ。既定かつ最小の値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される n-gram の最大長さ。既定値は 100。`min_ngram_length` 以上である必要がある。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択された UTF-8 の部分文字列の配列を返す。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsUTF8('алиса', 3)─┐
│ ['али','лис','иса']         │
└─────────────────────────────┘
```

## startsWith {#startsWith}

導入バージョン: v1.1

文字列が指定された文字列で始まるかどうかを判定します。

**構文**

```sql
startsWith(s, prefix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — `s` の先頭に存在するかをチェックするプレフィックス文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `prefix` で始まる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWith('ClickHouse', 'Click');
```

```response title=Response
┌─startsWith('⋯', 'Click')─┐
│                        1 │
└──────────────────────────┘
```

## startsWithCaseInsensitive {#startsWithCaseInsensitive}

導入バージョン: v25.9

文字列が指定された文字列で始まっているかを、大文字・小文字を区別せずに判定します。

**構文**

```sql
startsWithCaseInsensitive(s, prefix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — 大文字・小文字を区別せずにチェックするプレフィックス文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が大文字・小文字を区別せずに `prefix` で始まる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithCaseInsensitive('ClickHouse', 'CLICK');
```

```response title=Response
┌─startsWithCaseInsensitive('⋯', 'CLICK')─┐
│                                       1 │
└─────────────────────────────────────────┘
```

## startsWithCaseInsensitiveUTF8 {#startsWithCaseInsensitiveUTF8}

導入バージョン: v25.9

文字列が、指定した大文字小文字を区別しないプレフィックスで始まるかどうかをチェックします。
文字列には、有効な UTF-8 でエンコードされたテキストのみが含まれていることを前提とします。
この前提に反している場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
startsWithCaseInsensitiveUTF8(s, prefix)
```

**引数**

* `s` — 判定対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — 大文字小文字を区別せずに判定するプレフィックス文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が大文字小文字を区別せずに `prefix` で始まる場合は `1` を返し、そうでない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithCaseInsensitiveUTF8('приставка', 'при')
```

```response title=Response
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```

## startsWithUTF8 {#startsWithUTF8}

導入バージョン: v23.8

文字列が指定された接頭辞で始まるかどうかをチェックします。
文字列が有効な UTF-8 でエンコードされたテキストであると仮定します。
この前提が満たされない場合でも、例外はスローされず、結果は未定義となります。

**構文**

```sql
startsWithUTF8(s, prefix)
```

**引数**

* `s` — 判定対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — 先頭一致を確認するためのプレフィックス。[`String`](/sql-reference/data-types/string)

**返される値**

`s` が `prefix` で始まる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithUTF8('приставка', 'при')
```

```response title=Response
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```

## stringBytesEntropy {#stringBytesEntropy}

導入バージョン: v25.6

文字列内のバイト分布に対する Shannon エントロピーを計算します。

**構文**

```sql
stringBytesEntropy(s)
```

**引数**

* `s` — 解析対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列内のバイト分布のシャノンエントロピーを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringBytesEntropy('Hello, world!')
```

```response title=Response
┌─stringBytesEntropy('Hello, world!')─┐
│                         3.07049960  │
└─────────────────────────────────────┘
```

## stringBytesUniq {#stringBytesUniq}

導入バージョン: v25.6

文字列内の重複しないバイトの個数を数えます。

**構文**

```sql
stringBytesUniq(s)
```

**引数**

* `s` — 解析対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列内に含まれる異なるバイトの種類数を返します。[`UInt16`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT stringBytesUniq('Hello')
```

```response title=Response
┌─stringBytesUniq('Hello')─┐
│                        4 │
└──────────────────────────┘
```

## stringJaccardIndex {#stringJaccardIndex}

導入バージョン: v23.11

2 つのバイト列間の [Jaccard 類似度](https://en.wikipedia.org/wiki/Jaccard_index) を計算します。

**構文**

```sql
stringJaccardIndex(s1, s2)
```

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列間のジャカード類似度係数を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringJaccardIndex('clickhouse', 'mouse')
```

```response title=Response
┌─stringJaccardIndex('clickhouse', 'mouse')─┐
│                                       0.4 │
└───────────────────────────────────────────┘
```

## stringJaccardIndexUTF8 {#stringJaccardIndexUTF8}

導入バージョン: v23.11

[`stringJaccardIndex`](#stringJaccardIndex) と同様ですが、UTF-8 エンコードの文字列を対象とします。

**構文**

```sql
stringJaccardIndexUTF8(s1, s2)
```

**引数**

* `s1` — 1 番目の入力 UTF8 文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力 UTF8 文字列。[`String`](/sql-reference/data-types/string)

**返される値**

2つの UTF8 文字列間の Jaccard 類似度インデックスを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringJaccardIndexUTF8('我爱你', '我也爱你')
```

```response title=Response
┌─stringJaccardIndexUTF8('我爱你', '我也爱你')─┐
│                                       0.75 │
└─────────────────────────────────────────────┘
```

## substring {#substring}

導入バージョン: v1.1

文字列 `s` のうち、指定されたバイトインデックス `offset` から始まる部分文字列を返します。
バイトのカウントは 1 から始まり、次のルールに従います:

* `offset` が `0` の場合、空文字列を返します。
* `offset` が負の値の場合、部分文字列は先頭からではなく、文字列の末尾から `pos` 文字目を起点として始まります。

省略可能な引数 `length` で、返される部分文字列が持つことのできる最大バイト数を指定します。

**構文**

```sql
substring(s, offset[, length])
```

**別名**: `byteSlice`, `mid`, `substr`

**引数**

* `s` — 部分文字列を取得する元となる文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Enum`](/sql-reference/data-types/enum)
* `offset` — `s` における部分文字列の開始位置。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 省略可能。部分文字列の最大バイト長。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

`offset` バイト目から開始し、`length` バイト分の `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な使用例**

```sql title=Query
SELECT 'database' AS db, substr(db, 5), substr(db, 5, 1)
```

```response title=Response
┌─db───────┬─substring('database', 5)─┬─substring('database', 5, 1)─┐
│ database │ base                     │ b                           │
└──────────┴──────────────────────────┴─────────────────────────────┘
```

## substringIndex {#substringIndex}

導入バージョン: v23.7

Spark や MySQL と同様に、文字列 `s` から、区切り文字 `delim` が `count` 回目に現れる位置より前の部分文字列を返します。

**構文**

```sql
substringIndex(s, delim, count)
```

**別名**: `SUBSTRING_INDEX`

**引数**

* `s` — 部分文字列を抽出する元の文字列。[`String`](/sql-reference/data-types/string)
* `delim` — 文字列を分割するための区切り文字。[`String`](/sql-reference/data-types/string)
* `count` — 部分文字列を抽出する前に数える区切り文字の出現回数。`count` が正の値の場合、（左側から数えて）最後の区切り文字より左側のすべてが返されます。`count` が負の値の場合、（右側から数えて）最後の区切り文字より右側のすべてが返されます。[`UInt`](/sql-reference/data-types/int-uint) または [`Int`](/sql-reference/data-types/int-uint)

**戻り値**

`delim` が `count` 回出現する位置より前の、`s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT substringIndex('www.clickhouse.com', '.', 2)
```

```response title=Response
┌─substringIndex('www.clickhouse.com', '.', 2)─┐
│ www.clickhouse                               │
└──────────────────────────────────────────────┘
```

## substringIndexUTF8 {#substringIndexUTF8}

導入バージョン: v23.7

Unicode コードポイント用に、区切り文字 `delim` が `count` 回出現するより前にある `s` の部分文字列を返します。
文字列には、有効な UTF-8 でエンコードされたテキストが含まれていると仮定します。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
substringIndexUTF8(s, delim, count)
```

**引数**

* `s` — 部分文字列を抽出する対象の文字列。[`String`](/sql-reference/data-types/string)
* `delim` — 分割に使用する区切り文字。[`String`](/sql-reference/data-types/string)
* `count` — 部分文字列を抽出する前にカウントする区切り文字の出現回数。`count` が正の場合、（左から数えて）最後の区切り文字より左側のすべてが返されます。`count` が負の場合、（右から数えて）最後の区切り文字より右側のすべてが返されます。[`UInt`](/sql-reference/data-types/int-uint) または [`Int`](/sql-reference/data-types/int-uint)

**戻り値**

`delim` が `count` 回出現するまでの `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**使用例**

**UTF-8 の例**

```sql title=Query
SELECT substringIndexUTF8('www.straßen-in-europa.de', '.', 2)
```

```response title=Response
www.straßen-in-europa
```

## substringUTF8 {#substringUTF8}

導入バージョン: v1.1

Unicode コードポイントに対して、指定されたバイトインデックス `offset` から始まる文字列 `s` の部分文字列を返します。
バイト数のカウントは、次のロジックで `1` から始まります。

* `offset` が `0` の場合、空文字列が返されます。
* `offset` が負の値の場合、部分文字列は文字列の先頭ではなく、末尾から `pos` 文字分さかのぼった位置から始まります。

省略可能な引数 `length` は、返される部分文字列が持つことのできる最大バイト数を指定します。

:::note
この関数は、文字列に有効な UTF-8 でエンコードされたテキストが含まれていることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。
:::

**構文**

```sql
substringUTF8(s, offset[, length])
```

**引数**

* `s` — 部分文字列を取得する対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Enum`](/sql-reference/data-types/enum)
* `offset` — `s` における部分文字列の開始位置。[`Int`](/sql-reference/data-types/int-uint) または [`UInt`](/sql-reference/data-types/int-uint)
* `length` — 部分文字列の最大長（バイト数）。省略可能。[`Int`](/sql-reference/data-types/int-uint) または [`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

インデックス `offset` から開始し、`length` で指定されたバイト数の `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT 'Täglich grüßt das Murmeltier.' AS str, substringUTF8(str, 9), substringUTF8(str, 9, 5)
```

```response title=Response
Täglich grüßt das Murmeltier.    grüßt das Murmeltier.    grüßt
```

## toValidUTF8 {#toValidUTF8}

導入バージョン: v20.1

文字列中の無効な UTF-8 文字を、置換文字 `�` (U+FFFD) に置き換えることで、有効な UTF-8 文字列に変換します。
連続する複数の無効な文字が検出された場合、それらは 1 つの置換文字にまとめられます。

**構文**

```sql
toValidUTF8(s)
```

**引数**

* `s` — String データ型オブジェクトとして表される任意のバイト列。[`String`](/sql-reference/data-types/string)

**戻り値**

有効な UTF-8 文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT toValidUTF8('\\x61\\xF0\\x80\\x80\\x80b')
```

```response title=Response
c
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```

## trimBoth {#trimBoth}

導入バージョン: v20.1

文字列の先頭と末尾から、指定した文字を削除します。
デフォルトでは、一般的な ASCII の空白文字を削除します。

**構文**

```sql
trimBoth(s[, trim_characters])
```

**別名**: `trim`

**引数**

* `s` — トリムする文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 省略可能。トリムする文字の集合。指定されていない場合は、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された文字が両端からトリムされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimBoth('$$ClickHouse$$', '$')
```

```response title=Response
┌─trimBoth('$$⋯se$$', '$')─┐
│ ClickHouse               │
└──────────────────────────┘
```

## trimLeft {#trimLeft}

導入バージョン: v20.1

文字列の先頭から、指定された文字を除去します。
デフォルトでは、一般的な ASCII の空白文字を除去します。

**構文**

```sql
trimLeft(input[, trim_characters])
```

**エイリアス**: `ltrim`

**引数**

* `input` — トリミングする文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 省略可能。トリミングする文字。指定されていない場合、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された文字を左側から取り除いた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimLeft('ClickHouse', 'Click');
```

```response title=Response
┌─trimLeft('Cl⋯', 'Click')─┐
│ House                    │
└──────────────────────────┘
```

## trimRight {#trimRight}

導入: v20.1

文字列の末尾から、指定した文字を削除します。
デフォルトでは、一般的な空白文字（ASCII）を削除します。

**構文**

```sql
trimRight(s[, trim_characters])
```

**別名**: `rtrim`

**引数**

* `s` — 末尾をトリミングする対象の文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 省略可能なトリミング対象の文字。指定しない場合は、一般的な空白文字が末尾から削除されます。[`String`](/sql-reference/data-types/string)

**返される値**

指定された文字を右側から取り除いた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimRight('ClickHouse','House');
```

```response title=Response
┌─trimRight('C⋯', 'House')─┐
│ Click                    │
└──────────────────────────┘
```

## tryBase32Decode {#tryBase32Decode}

導入バージョン: v25.6

文字列を受け取り、[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) エンコード方式に従ってデコードします。

**構文**

```sql
tryBase32Decode(encoded)
```

**引数**

* `encoded` — デコードする文字列カラムまたは定数。文字列が有効な Base32 でエンコードされたものでない場合、エラー時には空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase32Decode('IVXGG33EMVSA====');
```

```response title=Response
┌─tryBase32Decode('IVXGG33EMVSA====')─┐
│ エンコード済み                        │
└─────────────────────────────────────┘
```

## tryBase58Decode {#tryBase58Decode}

導入バージョン: v22.10

[`base58Decode`](#base58Decode) と同様ですが、エラーが発生した場合は空の文字列を返します。

**構文**

```sql
tryBase58Decode(encoded)
```

**引数**

* `encoded` — 文字列カラムまたは定数。文字列が有効な Base58 エンコード文字列でない場合、エラー時には空文字列を返します。[`String`](/sql-reference/data-types/string)

**返される値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase58Decode('3dc8KtHrwM') AS res, tryBase58Decode('invalid') AS res_invalid;
```

```response title=Response
┌─res─────┬─res_invalid─┐
│ エンコード済み │             │
└─────────┴─────────────┘
```

## tryBase64Decode {#tryBase64Decode}

導入バージョン: v18.16

[`base64Decode`](#base64Decode) と同様ですが、エラー時には空文字列を返します。

**構文**

```sql
tryBase64Decode(encoded)
```

**引数**

* `encoded` — デコードする文字列カラムまたは定数。文字列が有効な Base64 文字列でない場合、エラーの場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**返される値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase64Decode('Y2xpY2tob3VzZQ==')
```

```response title=Response
┌─tryBase64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                          │
└─────────────────────────────────────┘
```

## tryBase64URLDecode {#tryBase64URLDecode}

導入されたバージョン: v18.16

[`base64URLDecode`](#base64URLDecode) と同様ですが、エラーが発生した場合は空文字列を返します。

**構文**

```sql
tryBase64URLDecode(encoded)
```

**引数**

* `encoded` — デコードする文字列カラムまたは定数。文字列が有効な Base64 文字列でない場合、エラー時には空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                               │
└──────────────────────────────────────────────────────┘
```

## tryIdnaEncode {#tryIdnaEncode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications) (IDNA) メカニズムに従い、ドメイン名の Unicode (UTF-8) 表現（ToUnicode アルゴリズム）を返します。
エラーが発生した場合は、例外をスローせず空文字列を返します。

**構文**

```sql
tryIdnaEncode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値の IDNA 方式に基づいて、入力文字列の ASCII 表現を返します。入力値が無効な場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryIdnaEncode('straße.münchen.de')
```

```response title=Response
┌─tryIdnaEncode('straße.münchen.de')──┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```

## tryPunycodeDecode {#tryPunycodeDecode}

導入バージョン: v24.1

`punycodeDecode` と似ていますが、有効な Punycode でエンコードされた文字列が渡されなかった場合は空文字列を返します。

**構文**

```sql
tryPunycodeDecode(s)
```

**引数**

* `s` — Punycode でエンコードされた文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値のプレーンテキストを返します。入力が無効な場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryPunycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─tryPunycodeDecode('Mnchen-3ya')─┐
│ München                         │
└─────────────────────────────────┘
```

## upper {#upper}

導入バージョン: v1.1

文字列中の ASCII ラテン文字を大文字に変換します。

**構文**

```sql
upper(s)
```

**別名**: `ucase`

**引数**

* `s` — 大文字に変換する文字列。[`String`](/sql-reference/data-types/string)

**返り値**

`s` を大文字に変換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT upper('clickhouse')
```

```response title=Response
┌─upper('clickhouse')─┐
│ CLICKHOUSE          │
└─────────────────────┘
```

## upperUTF8 {#upperUTF8}

導入バージョン: v1.1

文字列が有効な UTF-8 でエンコードされたテキストであると仮定して、その文字列を大文字に変換します。
この仮定が満たされない場合でも、例外はスローされず、結果は未定義です。

:::note
この関数は言語を自動判別しません。たとえばトルコ語では結果が完全には正しくない場合があります（i/İ と i/I など）。
コードポイントの大文字と小文字で UTF-8 のバイト列の長さが異なる場合（`ẞ` と `ß` など）、そのコードポイントに対する結果が正しくない可能性があります。
:::

**構文**

```sql
upperUTF8(s)
```

**引数**

* `s` — 文字列型。[`String`](/sql-reference/data-types/string)

**戻り値**

`String` 型の値。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT upperUTF8('München') AS Upperutf8
```

```response title=Response
┌─Upperutf8─┐
│ MÜNCHEN   │
└───────────┘
```

{/*AUTOGENERATED_END*/ }

---
description: '文字列関数に関するドキュメント'
sidebar_label: '文字列'
slug: /sql-reference/functions/string-functions
title: '文字列操作関数'
doc_type: 'reference'
---

import VersionBadge from '@theme/badges/VersionBadge';


# 文字列操作関数

文字列の[検索](string-search-functions.md)および[置換](string-replace-functions.md)に関する関数については、別途説明しています。

:::note
以下のドキュメントは`system.functions`システムテーブルから自動生成されています。
:::

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## CRC32 {#CRC32}

導入バージョン: v20.1

CRC-32-IEEE 802.3多項式と初期値`0xffffffff`を使用して、文字列のCRC32チェックサムを計算します（zlib実装）。

**構文**

```sql
CRC32(s)
```

**引数**

- `s` — CRC32を計算する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列のCRC32チェックサムを返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT CRC32('ClickHouse')
```

```response title=レスポンス
┌─CRC32('ClickHouse')─┐
│          1538217360 │
└─────────────────────┘
```


## CRC32IEEE {#CRC32IEEE}

導入バージョン: v20.1

CRC-32-IEEE 802.3多項式を使用して、文字列のCRC32チェックサムを計算します。

**構文**

```sql
CRC32IEEE(s)
```

**引数**

- `s` — CRC32を計算する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列のCRC32チェックサムを返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT CRC32IEEE('ClickHouse');
```

```response title=レスポンス
┌─CRC32IEEE('ClickHouse')─┐
│              3089448422 │
└─────────────────────────┘
```


## CRC64 {#CRC64}

導入バージョン: v20.1

CRC-64-ECMA多項式を使用して文字列のCRC64チェックサムを計算します。

**構文**

```sql
CRC64(s)
```

**引数**

- `s` — CRC64を計算する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列のCRC64チェックサムを返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT CRC64('ClickHouse');
```

```response title=レスポンス
┌──CRC64('ClickHouse')─┐
│ 12126588151325169346 │
└──────────────────────┘
```


## appendTrailingCharIfAbsent {#appendTrailingCharIfAbsent}

導入バージョン: v1.1

文字列 `s` が空でなく、文字 `c` で終わっていない場合に、文字列 `s` の末尾に文字 `c` を追加します。

**構文**

```sql
appendTrailingCharIfAbsent(s, c)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
- `c` — 末尾に存在しない場合に追加する文字。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列 `s` が `c` で終わっていない場合、文字 `c` を末尾に追加した文字列 `s` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT appendTrailingCharIfAbsent('https://example.com', '/');
```

```response title=Response
┌─appendTraili⋯.com', '/')─┐
│ https://example.com/     │
└──────────────────────────┘
```


## ascii {#ascii}

導入バージョン: v22.11

文字列 `s` の最初の文字のASCIIコードポイントを `Int32` として返します。

**構文**

```sql
ascii(s)
```

**引数**

- `s` — 文字列入力。[`String`](/sql-reference/data-types/string)

**戻り値**

最初の文字のASCIIコードポイントを返します。`s` が空の場合、結果は `0` になります。最初の文字がASCII文字でない場合、またはUTF-16のLatin-1補助範囲に含まれない場合、結果は未定義です。[`Int32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT ascii('234')
```

```response title=レスポンス
┌─ascii('234')─┐
│           50 │
└──────────────┘
```


## base32Decode {#base32Decode}

導入バージョン: v25.6

[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) (RFC 4648) 文字列をデコードします。
文字列が有効なBase32エンコード形式でない場合、例外がスローされます。

**構文**

```sql
base32Decode(encoded)
```

**引数**

- `encoded` — 文字列カラムまたは定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT base32Decode('IVXGG33EMVSA====');
```

```response title=レスポンス
┌─base32Decode('IVXGG33EMVSA====')─┐
│ Encoded                          │
└──────────────────────────────────┘
```


## base32Encode {#base32Encode}

導入バージョン: v25.6

[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6)を使用して文字列をエンコードします。

**構文**

```sql
base32Encode(plaintext)
```

**引数**

- `plaintext` — エンコードする平文。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のエンコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)

**例**

**使用例**

```sql title=Query
SELECT base32Encode('Encoded')
```

```response title=Response
┌─base32Encode('Encoded')─┐
│ IVXGG33EMVSA====        │
└─────────────────────────┘
```


## base58Decode {#base58Decode}

導入バージョン: v22.7

[Base58](https://datatracker.ietf.org/doc/html/draft-msporny-base58-03#section-3)文字列をデコードします。
文字列が有効なBase58エンコードでない場合は、例外がスローされます。

**構文**

```sql
base58Decode(encoded)
```

**引数**

- `encoded` — デコードする文字列カラムまたは定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコード値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT base58Decode('JxF12TrwUP45BMd');
```

```response title=レスポンス
┌─base58Decode⋯rwUP45BMd')─┐
│ Hello World              │
└──────────────────────────┘
```


## base58Encode {#base58Encode}

導入バージョン: v22.7

[Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html)エンコーディングを使用して文字列をエンコードします。

**構文**

```sql
base58Encode(plaintext)
```

**引数**

- `plaintext` — エンコードする平文。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のエンコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT base58Encode('ClickHouse');
```

```response title=レスポンス
┌─base58Encode('ClickHouse')─┐
│ 4nhk8K7GHXf6zx             │
└────────────────────────────┘
```


## base64Decode {#base64Decode}

導入バージョン: v18.16

RFC 4648に従って、[Base64](https://en.wikipedia.org/wiki/Base64)表現から文字列をデコードします。
エラーが発生した場合は例外をスローします。

**構文**

```sql
base64Decode(encoded)
```

**エイリアス**: `FROM_BASE64`

**引数**

- `encoded` — デコードする文字列カラムまたは定数。文字列が有効なBase64エンコードでない場合、例外がスローされます。[`String`](/sql-reference/data-types/string)

**戻り値**

デコードされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT base64Decode('Y2xpY2tob3VzZQ==')
```

```response title=レスポンス
┌─base64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                       │
└──────────────────────────────────┘
```


## base64Encode {#base64Encode}

導入バージョン: v18.16

RFC 4648に従い、[Base64](https://en.wikipedia.org/wiki/Base64)形式で文字列をエンコードします。

**構文**

```sql
base64Encode(plaintext)
```

**エイリアス**: `TO_BASE64`

**引数**

- `plaintext` — エンコードする平文の列または定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をエンコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT base64Encode('clickhouse')
```

```response title=レスポンス
┌─base64Encode('clickhouse')─┐
│ Y2xpY2tob3VzZQ==           │
└────────────────────────────┘
```


## base64URLDecode {#base64URLDecode}

導入バージョン: v24.6

RFC 4648に従い、URLセーフなアルファベットを使用して[Base64](https://en.wikipedia.org/wiki/Base64)表現から文字列をデコードします。
エラーが発生した場合は例外をスローします。

**構文**

```sql
base64URLDecode(encoded)
```

**引数**

- `encoded` — デコードする文字列カラムまたは定数。文字列が有効なBase64エンコードでない場合、例外がスローされます。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                            │
└───────────────────────────────────────────────────┘
```


## base64URLEncode {#base64URLEncode}

導入バージョン: v18.16

URL セーフなアルファベットを使用して、[Base64](https://datatracker.ietf.org/doc/html/rfc4648#section-4) (RFC 4648) 形式で文字列をエンコードします。

**構文**

```sql
base64URLEncode(plaintext)
```

**引数**

- `plaintext` — エンコードする平文の列または定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のエンコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT base64URLEncode('https://clickhouse.com')
```

```response title=レスポンス
┌─base64URLEncode('https://clickhouse.com')─┐
│ aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ            │
└───────────────────────────────────────────┘
```


## basename {#basename}

導入バージョン: v20.1

文字列の最後のスラッシュまたはバックスラッシュ以降の末尾部分を抽出します。
この関数は、パスからファイル名を抽出する際によく使用されます。

**構文**

```sql
basename(expr)
```

**引数**

- `expr` — 文字列式。バックスラッシュはエスケープする必要があります。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列の最後のスラッシュまたはバックスラッシュ以降の末尾部分を返します。入力文字列がスラッシュまたはバックスラッシュで終わる場合、関数は空文字列を返します。スラッシュまたはバックスラッシュが存在しない場合は、元の文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**Unixパスからファイル名を抽出**

```sql title=Query
SELECT 'some/long/path/to/file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some/long/path/to/file')─┐
│ some/long/path/to/file │ file                               │
└────────────────────────┴────────────────────────────────────┘
```

**Windowsパスからファイル名を抽出**

```sql title=Query
SELECT 'some\\long\\path\\to\\file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some\\long\\path\\to\\file')─┐
│ some\long\path\to\file │ file                                   │
└────────────────────────┴────────────────────────────────────────┘
```

**パス区切り文字を含まない文字列**

```sql title=Query
SELECT 'some-file-name' AS a, basename(a)
```

```response title=Response
┌─a──────────────┬─basename('some-file-name')─┐
│ some-file-name │ some-file-name             │
└────────────────┴────────────────────────────┘
```


## byteHammingDistance {#byteHammingDistance}

導入バージョン: v23.9

2つのバイト文字列間の[ハミング距離](https://en.wikipedia.org/wiki/Hamming_distance)を計算します。

**構文**

```sql
byteHammingDistance(s1, s2)
```

**エイリアス**: `mismatches`

**引数**

- `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間のハミング距離。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT byteHammingDistance('karolin', 'kathrin')
```

```response title=レスポンス
┌─byteHammingDistance('karolin', 'kathrin')─┐
│                                         3 │
└───────────────────────────────────────────┘
```


## compareSubstrings {#compareSubstrings}

導入バージョン: v25.2

2つの文字列を辞書順で比較します。

**構文**

```sql
compareSubstrings(s1, s2, s1_offset, s2_offset, num_bytes)
```

**引数**

- `s1` — 比較する1つ目の文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 比較する2つ目の文字列。[`String`](/sql-reference/data-types/string)
- `s1_offset` — 比較を開始する`s1`内の位置(0始まり)。[`UInt*`](/sql-reference/data-types/int-uint)
- `s2_offset` — 比較を開始する`s2`内の位置(0始まりのインデックス)。[`UInt*`](/sql-reference/data-types/int-uint)
- `num_bytes` — 両方の文字列で比較する最大バイト数。`s1_offset`(または`s2_offset`) + `num_bytes`が入力文字列の末尾を超える場合、`num_bytes`は適切に削減されます。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

以下を返します:

- `s1`[`s1_offset` : `s1_offset` + `num_bytes`] < `s2`[`s2_offset` : `s2_offset` + `num_bytes`]の場合は`-1`
- `s1`[`s1_offset` : `s1_offset` + `num_bytes`] = `s2`[`s2_offset` : `s2_offset` + `num_bytes`]の場合は`0`
- `s1`[`s1_offset` : `s1_offset` + `num_bytes`] > `s2`[`s2_offset` : `s2_offset` + `num_bytes`]の場合は`1`

[`Int8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT compareSubstrings('Saxony', 'Anglo-Saxon', 0, 6, 5) AS result
```

```response title=レスポンス
┌─result─┐
│      0 │
└────────┘
```


## concat {#concat}

導入バージョン: v1.1

指定された引数を連結します。

[`String`](../data-types/string.md)型または[`FixedString`](../data-types/fixedstring.md)型でない引数は、デフォルトのシリアライゼーションを使用して文字列に変換されます。
これによりパフォーマンスが低下するため、String/FixedString以外の引数の使用は推奨されません。

**構文**

```sql
concat([s1, s2, ...])
```

**引数**

- `s1, s2, ...` — 任意の型の値を任意の数指定可能。[`Any`](/sql-reference/data-types)

**戻り値**

引数を連結して作成された文字列を返します。引数のいずれかが`NULL`の場合、関数は`NULL`を返します。引数がない場合は空の文字列を返します。[`Nullable(String)`](/sql-reference/data-types/nullable)

**例**

**文字列の連結**

```sql title=Query
SELECT concat('Hello, ', 'World!')
```

```response title=Response
┌─concat('Hello, ', 'World!')─┐
│ Hello, World!               │
└─────────────────────────────┘
```

**数値の連結**

```sql title=Query
SELECT concat(42, 144)
```

```response title=Response
┌─concat(42, 144)─┐
│ 42144           │
└─────────────────┘
```


## concatAssumeInjective {#concatAssumeInjective}

導入バージョン: v1.1

[`concat`](#concat)と同様ですが、`concat(s1, s2, ...) → sn`が単射であることを前提とします。
すなわち、異なる引数に対して異なる結果を返すことを仮定します。

`GROUP BY`の最適化に使用できます。

**構文**

```sql
concatAssumeInjective([s1, s2, ...])
```

**引数**

- `s1, s2, ...` — 任意の型の任意の数の値。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

引数を連結して作成された文字列を返します。引数のいずれかが`NULL`の場合、関数は`NULL`を返します。引数が渡されない場合は、空の文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**GROUP BYの最適化**

```sql title=Query
SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY concatAssumeInjective(key1, key2)
```

```response title=Response
┌─concat(key1, key2)─┬─sum(value)─┐
│ Hello, World!      │          3 │
│ Hello, World!      │          2 │
│ Hello, World       │          3 │
└────────────────────┴────────────┘
```


## concatWithSeparator {#concatWithSeparator}

導入バージョン: v22.12

指定された区切り文字で区切りながら、提供された文字列を連結します。

**構文**

```sql
concatWithSeparator(sep[, exp1, exp2, ...])
```

**エイリアス**: `concat_ws`

**引数**

- `sep` — 使用する区切り文字。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)
- `exp1, exp2, ...` — 連結する式。`String` 型または `FixedString` 型でない引数は、デフォルトのシリアライゼーションを使用して文字列に変換されます。これによりパフォーマンスが低下するため、String/FixedString 以外の引数を使用することは推奨されません。[`Any`](/sql-reference/data-types)

**返り値**

引数を連結して作成された文字列を返します。引数の値のいずれかが `NULL` の場合、関数は `NULL` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT concatWithSeparator('a', '1', '2', '3', '4')
```

```response title=Response
┌─concatWithSeparator('a', '1', '2', '3', '4')─┐
│ 1a2a3a4                                      │
└──────────────────────────────────────────────┘
```


## concatWithSeparatorAssumeInjective {#concatWithSeparatorAssumeInjective}

導入バージョン: v22.12

[`concatWithSeparator`](#concatWithSeparator)と同様ですが、`concatWithSeparator(sep[,exp1, exp2, ... ]) → result`が単射であると仮定します。
関数は、異なる引数に対して異なる結果を返す場合に単射と呼ばれます。

`GROUP BY`の最適化に使用できます。

**構文**

```sql
concatWithSeparatorAssumeInjective(sep[, exp1, exp2, ... ])
```

**引数**

- `sep` — 使用する区切り文字。[`const String`](/sql-reference/data-types/string)または[`const FixedString`](/sql-reference/data-types/fixedstring)
- `exp1, exp2, ...` — 連結する式。`String`型または`FixedString`型でない引数は、デフォルトのシリアライゼーションを使用して文字列に変換されます。これによりパフォーマンスが低下するため、String/FixedString以外の引数を使用することは推奨されません。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)

**返り値**

引数を連結して作成された文字列を返します。引数の値のいずれかが`NULL`の場合、関数は`NULL`を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
CREATE TABLE user_data (
user_id UInt32,
first_name String,
last_name String,
score UInt32
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO user_data VALUES
(1, 'John', 'Doe', 100),
(2, 'Jane', 'Smith', 150),
(3, 'John', 'Wilson', 120),
(4, 'Jane', 'Smith', 90);

SELECT
    concatWithSeparatorAssumeInjective('-', first_name, last_name) as full_name,
    sum(score) as total_score
FROM user_data
GROUP BY concatWithSeparatorAssumeInjective('-', first_name, last_name);
```

```response title=レスポンス
┌─full_name───┬─total_score─┐
│ Jane-Smith  │         240 │
│ John-Doe    │         100 │
│ John-Wilson │         120 │
└─────────────┴─────────────┘
```


## conv {#conv}

導入バージョン: v1.1

異なる基数間で数値を変換します。

この関数は、ある基数から別の基数へ数値を変換します。2から36までの基数をサポートしています。
10より大きい基数の場合、A-Zのアルファベット(大文字小文字を区別しない)が10から35の桁を表すために使用されます。

この関数はMySQLのCONV()関数と互換性があります。

**構文**

```sql
conv(number, from_base, to_base)
```

**引数**

- `number` — 変換する数値。文字列型または数値型を指定できます。
- `from_base` — 変換元の基数(2-36)。整数である必要があります。
- `to_base` — 変換先の基数(2-36)。整数である必要があります。

**返り値**

変換先の基数における数値の文字列表現。

**例**

**10進数を2進数に変換**

```sql title=Query
SELECT conv('10', 10, 2)
```

```response title=Response
1010
```

**16進数を10進数に変換**

```sql title=Query
SELECT conv('FF', 16, 10)
```

```response title=Response
255
```

**負の数値を変換**

```sql title=Query
SELECT conv('-1', 10, 16)
```

```response title=Response
FFFFFFFFFFFFFFFF
```

**2進数を8進数に変換**

```sql title=Query
SELECT conv('1010', 2, 8)
```

```response title=Response
12
```


## convertCharset {#convertCharset}

導入バージョン: v1.1

文字列`s`をエンコーディング`from`から`to`に変換して返します。

**構文**

```sql
convertCharset(s, from, to)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
- `from` — 変換元の文字エンコーディング。[`String`](/sql-reference/data-types/string)
- `to` — 変換先の文字エンコーディング。[`String`](/sql-reference/data-types/string)

**戻り値**

エンコーディング`from`から`to`に変換された文字列`s`。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT convertCharset('Café', 'UTF-8', 'ISO-8859-1');
```

```response title=レスポンス
┌─convertChars⋯SO-8859-1')─┐
│ Caf�                     │
└──────────────────────────┘
```


## damerauLevenshteinDistance {#damerauLevenshteinDistance}

導入バージョン: v24.1

2つのバイト文字列間の[Damerau-Levenshtein距離](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance)を計算します。

**構文**

```sql
damerauLevenshteinDistance(s1, s2)
```

**引数**

- `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間のDamerau-Levenshtein距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT damerauLevenshteinDistance('clickhouse', 'mouse')
```

```response title=レスポンス
┌─damerauLevenshteinDistance('clickhouse', 'mouse')─┐
│                                                 6 │
└───────────────────────────────────────────────────┘
```


## decodeHTMLComponent {#decodeHTMLComponent}

導入バージョン: v23.9

文字列内のHTMLエンティティを対応する文字にデコードします。

**構文**

```sql
decodeHTMLComponent(s)
```

**引数**

- `s` — デコードするHTMLエンティティを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

HTMLエンティティがデコードされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')
```

```response title=レスポンス
┌─decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')─┐
│ <div>Hello & "World"</div>                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```


## decodeXMLComponent {#decodeXMLComponent}

導入バージョン: v21.2

文字列内のXMLエンティティを対応する文字にデコードします。

**構文**

```sql
decodeXMLComponent(s)
```

**引数**

- `s` — デコードするXMLエンティティを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

XMLエンティティがデコードされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT decodeXMLComponent('&lt;tag&gt;Hello &amp; World&lt;/tag&gt;')
```

```response title=レスポンス
┌─decodeXMLCom⋯;/tag&gt;')─┐
│ <tag>Hello & World</tag> │
└──────────────────────────┘
```


## editDistance {#editDistance}

導入バージョン: v23.9

2つのバイト文字列間の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)を計算します。

**構文**

```sql
editDistance(s1, s2)
```

**エイリアス**: `levenshteinDistance`

**引数**

- `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の編集距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT editDistance('clickhouse', 'mouse')
```

```response title=レスポンス
┌─editDistance('clickhouse', 'mouse')─┐
│                                   6 │
└─────────────────────────────────────┘
```


## editDistanceUTF8 {#editDistanceUTF8}

導入バージョン: v24.6

2つのUTF8文字列間の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)を計算します。

**構文**

```sql
editDistanceUTF8(s1, s2)
```

**エイリアス**: `levenshteinDistanceUTF8`

**引数**

- `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つのUTF8文字列間の編集距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT editDistanceUTF8('我是谁', '我是我')
```

```response title=レスポンス
┌─editDistanceUTF8('我是谁', '我是我')──┐
│                                   1 │
└─────────────────────────────────────┘
```


## encodeXMLComponent {#encodeXMLComponent}

導入バージョン: v21.1

文字列をXMLテキストノードまたは属性に配置するために文字をエスケープします。

**構文**

```sql
encodeXMLComponent(s)
```

**引数**

- `s` — エスケープする文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

エスケープされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    '<tag>Hello & "World"</tag>' AS original,
    encodeXMLComponent('<tag>Hello & "World"</tag>') AS xml_encoded;
```

```response title=Response
┌─original───────────────────┬─xml_encoded──────────────────────────────────────────┐
│ <tag>Hello & "World"</tag> │ &lt;tag&gt;Hello &amp; &quot;World&quot;&lt;/tag&gt; │
└────────────────────────────┴──────────────────────────────────────────────────────┘
```


## endsWith {#endsWith}

導入バージョン: v1.1

文字列が指定された接尾辞で終わるかどうかを確認します。

**構文**

```sql
endsWith(s, suffix)
```

**引数**

- `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
- `suffix` — チェックする接尾辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s`が`suffix`で終わる場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT endsWith('ClickHouse', 'House');
```

```response title=レスポンス
┌─endsWith('Cl⋯', 'House')─┐
│                        1 │
└──────────────────────────┘
```


## endsWithCaseInsensitive {#endsWithCaseInsensitive}

導入バージョン: v25.9

文字列が指定された大文字小文字を区別しない接尾辞で終わるかどうかを確認します。

**構文**

```sql
endsWithCaseInsensitive(s, suffix)
```

**引数**

- `s` — 確認する文字列。[`String`](/sql-reference/data-types/string)
- `suffix` — 確認する大文字小文字を区別しない接尾辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s`が大文字小文字を区別しない`suffix`で終わる場合は`1`を返し、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT endsWithCaseInsensitive('ClickHouse', 'HOUSE');
```

```response title=レスポンス
┌─endsWithCaseInsensitive('Cl⋯', 'HOUSE')─┐
│                                       1 │
└─────────────────────────────────────────┘
```


## endsWithCaseInsensitiveUTF8 {#endsWithCaseInsensitiveUTF8}

導入バージョン: v25.9

文字列 `s` が大文字小文字を区別しない `suffix` で終わるかどうかを返します。
文字列が有効なUTF-8エンコードされたテキストを含むことを前提としています。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。

**構文**

```sql
endsWithCaseInsensitiveUTF8(s, suffix)
```

**引数**

- `s` — チェックする文字列。[`String`](/sql-reference/data-types/string)
- `suffix` — チェックする大文字小文字を区別しない接尾辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が大文字小文字を区別しない `suffix` で終わる場合は `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithCaseInsensitiveUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithCaseInsensitiveUTF8('данных', 'ых')─┐
│                                           1 │
└─────────────────────────────────────────────┘
```


## endsWithUTF8 {#endsWithUTF8}

導入バージョン: v23.8

文字列 `s` が `suffix` で終わるかどうかを返します。
文字列が有効なUTF-8エンコードされたテキストを含むことを前提としています。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。

**構文**

```sql
endsWithUTF8(s, suffix)
```

**引数**

- `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
- `suffix` — チェック対象の接尾辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `suffix` で終わる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT endsWithUTF8('данных', 'ых');
```

```response title=レスポンス
┌─endsWithUTF8('данных', 'ых')─┐
│                            1 │
└──────────────────────────────┘
```


## extractTextFromHTML {#extractTextFromHTML}

導入バージョン: v21.3

HTMLまたはXHTMLからテキストコンテンツを抽出します。

この関数はHTMLタグ、コメント、script/style要素を削除し、テキストコンテンツのみを残します。以下の処理を行います:

- すべてのHTML/XMLタグの削除
- コメント(`<!-- -->`)の削除
- scriptおよびstyle要素とそのコンテンツの削除
- CDATAセクションの処理(そのままコピー)
- 適切な空白文字の処理と正規化

注意: HTMLエンティティはデコードされないため、必要に応じて別の関数で処理してください。

**構文**

```sql
extractTextFromHTML(html)
```

**引数**

- `html` — テキストを抽出するHTMLコンテンツを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

正規化された空白文字を含む抽出されたテキストコンテンツを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT extractTextFromHTML('
<html>
    <head><title>Page Title</title></head>
    <body>
        <p>Hello <b>World</b>!</p>
        <script>alert("test");</script>
        <!-- comment -->
    </body>
</html>
');
```

```response title=Response
┌─extractTextFromHTML('<html><head>...')─┐
│ Page Title Hello World!                │
└────────────────────────────────────────┘
```


## firstLine {#firstLine}

導入バージョン: v23.7

複数行文字列の最初の行を返します。

**構文**

```sql
firstLine(s)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列の最初の行を返します。行区切り文字が存在しない場合は文字列全体を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT firstLine('foo\\nbar\\nbaz')
```

```response title=レスポンス
┌─firstLine('foo\nbar\nbaz')─┐
│ foo                        │
└────────────────────────────┘
```


## idnaDecode {#idnaDecode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications) (IDNA) メカニズムに従って、ドメイン名のUnicode (UTF-8) 表現 (ToUnicodeアルゴリズム) を返します。
エラーが発生した場合 (例: 入力が無効な場合)、入力文字列がそのまま返されます。
大文字小文字の正規化により、[`idnaEncode()`](#idnaEncode) と [`idnaDecode()`](#idnaDecode) を繰り返し適用しても、必ずしも元の文字列が返されるわけではないことに注意してください。

**構文**

```sql
idnaDecode(s)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

IDNAメカニズムに従って、入力文字列のUnicode (UTF-8) 表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')
```

```response title=Response
┌─idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')─┐
│ straße.münchen.de                             │
└───────────────────────────────────────────────┘
```


## idnaEncode {#idnaEncode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications) (IDNA) メカニズムに従って、ドメイン名のASCII表現（ToASCIIアルゴリズム）を返します。
入力文字列はUTFエンコードされており、ASCII文字列に変換可能である必要があります。そうでない場合は例外がスローされます。

:::note
パーセントデコードやタブ、スペース、制御文字のトリミングは実行されません。
:::

**構文**

```sql
idnaEncode(s)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

IDNAメカニズムに従って、入力文字列のASCII表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT idnaEncode('straße.münchen.de')
```

```response title=Response
┌─idnaEncode('straße.münchen.de')─────┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```


## initcap {#initcap}

導入バージョン: v23.7

各単語の最初の文字を大文字に変換し、残りを小文字に変換します。
単語は英数字以外の文字で区切られた英数字の連続として定義されます。

:::note
`initcap`は各単語の最初の文字のみを大文字に変換するため、アポストロフィや大文字を含む単語では予期しない動作が発生する可能性があります。
これは既知の動作であり、現時点で修正の予定はありません。
:::

**構文**

```sql
initcap(s)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

各単語の最初の文字が大文字に変換された`s`を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT initcap('building for fast')
```

```response title=Response
┌─initcap('building for fast')─┐
│ Building For Fast            │
└──────────────────────────────┘
```

**アポストロフィや大文字を含む単語の既知の動作例**

```sql title=Query
SELECT initcap('John''s cat won''t eat.');
```

```response title=Response
┌─initcap('Joh⋯n\'t eat.')─┐
│ John'S Cat Won'T Eat.    │
└──────────────────────────┘
```


## initcapUTF8 {#initcapUTF8}

導入バージョン: v23.7

[`initcap`](#initcap)と同様に、`initcapUTF8`は各単語の先頭文字を大文字に変換し、残りを小文字に変換します。
文字列が有効なUTF-8エンコードされたテキストを含むことを前提としています。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。

:::note
この関数は言語を検出しません。例えば、トルコ語の場合、結果が正確でない可能性があります（i/İ vs. i/I）。
コードポイントの大文字と小文字でUTF-8バイトシーケンスの長さが異なる場合、このコードポイントに対する結果が正しくない可能性があります。
:::

**構文**

```sql
initcapUTF8(s)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

各単語の先頭文字が大文字に変換された`s`を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT initcapUTF8('не тормозит')
```

```response title=Response
┌─initcapUTF8('не тормозит')─┐
│ Не Тормозит                │
└────────────────────────────┘
```


## isValidASCII {#isValidASCII}

導入バージョン: v25.9

入力文字列(StringまたはFixedString)がASCIIバイト(0x00–0x7F)のみで構成されている場合は1を返し、それ以外の場合は0を返します。

**構文**

```sql

```

**エイリアス**: `isASCII`

**引数**

- なし

**戻り値**

**例**

**isValidASCII**

```sql title=Query
SELECT isValidASCII('hello') AS is_ascii, isValidASCII('你好') AS is_not_ascii
```

```response title=Response

```


## isValidUTF8 {#isValidUTF8}

導入バージョン: v20.1

バイト列が有効なUTF-8エンコードテキストを構成しているかどうかを確認します。

**構文**

```sql
isValidUTF8(s)
```

**引数**

- `s` — UTF-8エンコードの妥当性を確認する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

バイト列が有効なUTF-8エンコードテキストを構成している場合は`1`を、そうでない場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT isValidUTF8('\\xc3\\xb1') AS valid, isValidUTF8('\\xc3\\x28') AS invalid
```

```response title=Response
┌─valid─┬─invalid─┐
│     1 │       0 │
└───────┴─────────┘
```


## jaroSimilarity {#jaroSimilarity}

導入バージョン: v24.1

2つのバイト文字列間の[Jaro類似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance#Jaro_similarity)を計算します。

**構文**

```sql
jaroSimilarity(s1, s2)
```

**引数**

- `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間のJaro類似度を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=クエリ
SELECT jaroSimilarity('clickhouse', 'click')
```

```response title=レスポンス
┌─jaroSimilarity('clickhouse', 'click')─┐
│                    0.8333333333333333 │
└───────────────────────────────────────┘
```


## jaroWinklerSimilarity {#jaroWinklerSimilarity}

導入バージョン: v24.1

2つのバイト文字列間の[Jaro-Winkler類似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance)を計算します。

**構文**

```sql
jaroWinklerSimilarity(s1, s2)
```

**引数**

- `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間のJaro-Winkler類似度を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=クエリ
SELECT jaroWinklerSimilarity('clickhouse', 'click')
```

```response title=レスポンス
┌─jaroWinklerSimilarity('clickhouse', 'click')─┐
│                           0.8999999999999999 │
└──────────────────────────────────────────────┘
```


## left {#left}

導入バージョン: v22.1

文字列 `s` の左側から指定された `offset` の位置で始まる部分文字列を返します。

**構文**

```sql
left(s, offset)
```

**引数**

- `s` — 部分文字列を取得する元の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
- `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

以下を返します:

- `offset` が正の場合、文字列の左側から `offset` バイト分の `s` の部分文字列。
- `offset` が負の場合、文字列の左側から `length(s) - |offset|` バイト分の `s` の部分文字列。
- `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正のオフセット**

```sql title=Query
SELECT left('Hello World', 5)
```

```response title=Response
Helllo
```

**負のオフセット**

```sql title=Query
SELECT left('Hello World', -6)
```

```response title=Response
Hello
```


## leftPad {#leftPad}

導入バージョン: v21.8

文字列の左側を空白または指定された文字列で（必要に応じて複数回）埋めて、結果の文字列が指定された`length`に達するようにします。

**構文**

```sql
leftPad(string, length[, pad_string])
```

**エイリアス**: `lpad`

**引数**

- `string` — 埋め込み対象の入力文字列。[`String`](/sql-reference/data-types/string)
- `length` — 結果の文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は`length`文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `pad_string` — オプション。入力文字列を埋めるための文字列。指定されない場合、入力文字列は空白で埋められます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された長さの左埋め文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT leftPad('abc', 7, '*'), leftPad('def', 7)
```

```response title=レスポンス
┌─leftPad('abc', 7, '*')─┬─leftPad('def', 7)─┐
│ ****abc                │     def           │
└────────────────────────┴───────────────────┘
```


## leftPadUTF8 {#leftPadUTF8}

導入バージョン: v21.8

UTF8文字列の左側を、結果の文字列が指定された長さに達するまで、スペースまたは指定された文字列で（必要に応じて複数回）パディングします。
文字列の長さをバイト単位で測定する[`leftPad`](#leftPad)とは異なり、文字列の長さはコードポイント単位で測定されます。

**構文**

```sql
leftPadUTF8(string, length[, pad_string])
```

**引数**

- `string` — パディングする入力文字列。[`String`](/sql-reference/data-types/string)
- `length` — 結果の文字列の長さ。値が入力文字列の長さより小さい場合、入力文字列は`length`文字に短縮されます。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `pad_string` — オプション。入力文字列をパディングする文字列。指定されない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された長さの左パディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT leftPadUTF8('абвг', 7, '*'), leftPadUTF8('дежз', 7)
```

```response title=Response
┌─leftPadUTF8('абвг', 7, '*')─┬─leftPadUTF8('дежз', 7)─┐
│ ***абвг                     │    дежз                │
└─────────────────────────────┴────────────────────────┘
```


## leftUTF8 {#leftUTF8}

導入バージョン: v22.1

UTF-8エンコードされた文字列`s`の左側から、指定された`offset`の位置までの部分文字列を返します。

**構文**

```sql
leftUTF8(s, offset)
```

**引数**

- `s` — 部分文字列を取得するUTF-8エンコードされた文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

以下を返します:

- `offset`が正の値の場合、文字列の左側から`offset`バイト分の`s`の部分文字列。
- `offset`が負の値の場合、文字列の左側から`length(s) - |offset|`バイト分の`s`の部分文字列。
- `length`が0の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正のオフセット**

```sql title=Query
SELECT leftUTF8('Привет', 4)
```

```response title=Response
Прив
```

**負のオフセット**

```sql title=Query
SELECT leftUTF8('Привет', -4)
```

```response title=Response
Пр
```


## lengthUTF8 {#lengthUTF8}

導入バージョン: v1.1

バイト数や文字数ではなく、Unicodeコードポイント数で文字列の長さを返します。
この関数は、文字列が有効なUTF-8でエンコードされたテキストであることを前提としています。
この前提が満たされない場合でも例外はスローされず、結果は未定義となります。

**構文**

```sql
lengthUTF8(s)
```

**エイリアス**: `CHAR_LENGTH`, `CHARACTER_LENGTH`

**引数**

- `s` — 有効なUTF-8でエンコードされたテキストを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

Unicodeコードポイント数で表した文字列`s`の長さ。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT lengthUTF8('Здравствуй, мир!')
```

```response title=Response
┌─lengthUTF8('Здравствуй, мир!')─┐
│                             16 │
└────────────────────────────────┘
```


## lower {#lower}

導入バージョン: v1.1

ASCII文字列を小文字に変換します。

**構文**

```sql
lower(s)
```

**エイリアス**: `lcase`

**引数**

- `s` — 小文字に変換する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s`を小文字に変換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT lower('CLICKHOUSE')
```

```response title=レスポンス
┌─lower('CLICKHOUSE')─┐
│ clickhouse          │
└─────────────────────┘
```


## lowerUTF8 {#lowerUTF8}

導入バージョン: v1.1

文字列を小文字に変換します。文字列が有効なUTF-8エンコードされたテキストを含むことを前提としています。この前提が満たされない場合、例外はスローされず、結果は未定義となります。

**構文**

```sql
lowerUTF8(input)
```

**引数**

- `input` — 小文字に変換する入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

小文字の文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**最初の例**

```sql title=クエリ
SELECT lowerUTF8('München') as Lowerutf8;
```

```response title=レスポンス
münchen
```


## normalizeUTF8NFC {#normalizeUTF8NFC}

導入バージョン: v21.11

[NFC正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)に従ってUTF-8文字列を正規化します。

**構文**

```sql
normalizeUTF8NFC(str)
```

**引数**

- `str` — UTF-8エンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8文字列のNFC正規化形式を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
'é' AS original, -- e + 結合鋭アクセント記号 (U+0065 + U+0301)
length(original),
normalizeUTF8NFC('é') AS nfc_normalized, -- é (U+00E9)
length(nfc_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfc_normalized─┬─length(nfc_normalized)─┐
│ é        │                2 │ é              │                      2 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```


## normalizeUTF8NFD {#normalizeUTF8NFD}

導入バージョン: v21.11

UTF-8文字列を[NFD正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)に従って正規化します。

**構文**

```sql
normalizeUTF8NFD(str)
```

**引数**

- `str` — UTF-8エンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8文字列のNFD正規化形式を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT
    'é' AS original, -- é (U+00E9)
    length(original),
    normalizeUTF8NFD('é') AS nfd_normalized, -- e + 結合用アキュート符号 (U+0065 + U+0301)
    length(nfd_normalized);
```

```response title=レスポンス
┌─original─┬─length(original)─┬─nfd_normalized─┬─length(nfd_normalized)─┐
│ é        │                2 │ é              │                      3 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```


## normalizeUTF8NFKC {#normalizeUTF8NFKC}

導入バージョン: v21.11

[NFKC正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)に従ってUTF-8文字列を正規化します。

**構文**

```sql
normalizeUTF8NFKC(str)
```

**引数**

- `str` — UTF-8エンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8文字列のNFKC正規化形式を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    '① ② ③' AS original,                            -- 丸囲み数字文字
    normalizeUTF8NFKC('① ② ③') AS nfkc_normalized;  -- 1 2 3に変換されます
```

```response title=Response
┌─original─┬─nfkc_normalized─┐
│ ① ② ③  │ 1 2 3           │
└──────────┴─────────────────┘
```


## normalizeUTF8NFKD {#normalizeUTF8NFKD}

導入バージョン: v21.11

[NFKD正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)に従ってUTF-8文字列を正規化します。

**構文**

```sql
normalizeUTF8NFKD(str)
```

**引数**

- `str` — UTF-8エンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8文字列のNFKD正規化形式を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    'H₂O²' AS original,                            -- H + 下付き文字2 + O + 上付き文字2
    normalizeUTF8NFKD('H₂O²') AS nfkd_normalized;  -- H 2 O 2に変換
```

```response title=Response
┌─original─┬─nfkd_normalized─┐
│ H₂O²     │ H2O2            │
└──────────┴─────────────────┘
```


## punycodeDecode {#punycodeDecode}

導入バージョン: v24.1

[Punycode](https://en.wikipedia.org/wiki/Punycode)でエンコードされた文字列をUTF-8エンコードされた平文として返します。
有効なPunycodeエンコード文字列が指定されていない場合は、例外がスローされます。

**構文**

```sql
punycodeDecode(s)
```

**引数**

- `s` — Punycodeでエンコードされた文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値の平文を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT punycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─punycodeDecode('Mnchen-3ya')─┐
│ München                      │
└──────────────────────────────┘
```


## punycodeEncode {#punycodeEncode}

導入バージョン: v24.1

文字列の[Punycode](https://en.wikipedia.org/wiki/Punycode)表現を返します。
文字列はUTF-8でエンコードされている必要があります。そうでない場合、動作は未定義です。

**構文**

```sql
punycodeEncode(s)
```

**引数**

- `s` — 入力値。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値のPunycode表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT punycodeEncode('München')
```

```response title=Response
┌─punycodeEncode('München')─┐
│ Mnchen-3ya                │
└───────────────────────────┘
```


## regexpExtract {#regexpExtract}

導入バージョン: v23.2

`haystack`内で正規表現パターンに一致し、指定された正規表現グループインデックスに対応する最初の文字列を抽出します。

**構文**

```sql
regexpExtract(haystack, pattern[, index])
```

**エイリアス**: `REGEXP_EXTRACT`

**引数**

- `haystack` — 正規表現パターンとの照合対象となる文字列。[`String`](/sql-reference/data-types/string)
- `pattern` — 正規表現パターンを表す文字列。`pattern`には複数の正規表現グループを含めることができ、`index`で抽出するグループを指定します。インデックス0は正規表現全体との一致を意味します。[`const String`](/sql-reference/data-types/string)
- `index` — オプション。0以上の整数で、デフォルト値は1。抽出する正規表現グループを指定します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

一致した文字列を返します [`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    regexpExtract('100-200', '(\\d+)-(\\d+)', 1),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 2),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 0),
    regexpExtract('100-200', '(\\d+)-(\\d+)');
```

```response title=Response
┌─regexpExtract('100-200', '(\\d+)-(\\d+)', 1)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 2)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 0)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)')─┐
│ 100                                          │ 200                                          │ 100-200                                      │ 100                                       │
└──────────────────────────────────────────────┴──────────────────────────────────────────────┴──────────────────────────────────────────────┴───────────────────────────────────────────┘
```


## repeat {#repeat}

導入バージョン: v20.1

指定された回数だけ文字列を繰り返し連結します。

**構文**

```sql
repeat(s, n)
```

**引数**

- `s` — 繰り返す文字列。[`String`](/sql-reference/data-types/string)
- `n` — 文字列を繰り返す回数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

文字列`s`を`n`回繰り返した文字列。`n`が負の値の場合、関数は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT repeat('abc', 10)
```

```response title=レスポンス
┌─repeat('abc', 10)──────────────┐
│ abcabcabcabcabcabcabcabcabcabc │
└────────────────────────────────┘
```


## reverseUTF8 {#reverseUTF8}

導入バージョン: v1.1

文字列内のUnicodeコードポイントの並びを反転します。
文字列が有効なUTF-8でエンコードされたテキストであることを前提としています。
この前提が満たされない場合でも例外はスローされず、結果は未定義となります。

**構文**

```sql
reverseUTF8(s)
```

**引数**

- `s` — 有効なUTF-8でエンコードされたテキストを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

Unicodeコードポイントの並びが反転された文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT reverseUTF8('ClickHouse')
```

```response title=Response
esuoHkcilC
```


## right {#right}

導入バージョン: v22.1

文字列 `s` の右側から指定された `offset` の位置で始まる部分文字列を返します。

**構文**

```sql
right(s, offset)
```

**引数**

- `s` — 部分文字列を取得する元の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
- `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

以下を返します:

- `offset` が正の場合、文字列の右側から `offset` バイト分の `s` の部分文字列。
- `offset` が負の場合、文字列の右側から `length(s) - |offset|` バイト分の `s` の部分文字列。
- `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正のオフセット**

```sql title=Query
SELECT right('Hello', 3)
```

```response title=Response
llo
```

**負のオフセット**

```sql title=Query
SELECT right('Hello', -3)
```

```response title=Response
lo
```


## rightPad {#rightPad}

導入バージョン: v21.8

文字列の右側を空白または指定された文字列で（必要に応じて複数回）埋めて、結果の文字列が指定された`length`に達するまでパディングします。

**構文**

```sql
rightPad(string, length[, pad_string])
```

**エイリアス**: `rpad`

**引数**

- `string` — パディングする入力文字列。[`String`](/sql-reference/data-types/string)
- `length` — 結果の文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は`length`文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `pad_string` — オプション。入力文字列のパディングに使用する文字列。指定しない場合、入力文字列は空白でパディングされます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された長さで右パディングされた文字列。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT rightPad('abc', 7, '*'), rightPad('abc', 7)
```

```response title=Response
┌─rightPad('abc', 7, '*')─┬─rightPad('abc', 7)─┐
│ abc****                 │ abc                │
└─────────────────────────┴────────────────────┘
```


## rightPadUTF8 {#rightPadUTF8}

導入バージョン: v21.8

文字列の右側を空白または指定された文字列で（必要に応じて複数回）パディングし、結果の文字列が指定された長さに達するまで埋めます。
文字列の長さをバイト単位で測定する[`rightPad`](#rightPad)とは異なり、文字列の長さはコードポイント単位で測定されます。

**構文**

```sql
rightPadUTF8(string, length[, pad_string])
```

**引数**

- `string` — パディングする入力文字列。[`String`](/sql-reference/data-types/string)
- `length` — 結果の文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は`length`文字に短縮されます。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `pad_string` — オプション。入力文字列のパディングに使用する文字列。指定されない場合、入力文字列は空白でパディングされます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された長さの右パディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT rightPadUTF8('абвг', 7, '*'), rightPadUTF8('абвг', 7)
```

```response title=Response
┌─rightPadUTF8('абвг', 7, '*')─┬─rightPadUTF8('абвг', 7)─┐
│ абвг***                      │ абвг                    │
└──────────────────────────────┴─────────────────────────┘
```


## rightUTF8 {#rightUTF8}

導入バージョン: v22.1

UTF-8エンコードされた文字列`s`の右側から指定された`offset`の位置から始まる部分文字列を返します。

**構文**

```sql
rightUTF8(s, offset)
```

**引数**

- `s` — 部分文字列を取得するUTF-8エンコードされた文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

以下を返します:

- `offset`が正の場合、文字列の右側から`offset`バイト分の`s`の部分文字列。
- `offset`が負の場合、文字列の右側から`length(s) - |offset|`バイト分の`s`の部分文字列。
- `length`が`0`の場合、空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正のオフセット**

```sql title=Query
SELECT rightUTF8('Привет', 4)
```

```response title=Response
ивет
```

**負のオフセット**

```sql title=Query
SELECT rightUTF8('Привет', -4)
```

```response title=Response
ет
```


## soundex {#soundex}

導入バージョン: v23.4

文字列の[Soundexコード](https://en.wikipedia.org/wiki/Soundex)を返します。

**構文**

```sql
soundex(s)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列のSoundexコードを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT soundex('aksel')
```

```response title=レスポンス
┌─soundex('aksel')─┐
│ A240             │
└──────────────────┘
```


## space {#space}

導入バージョン: v23.5

指定された回数だけ空白文字(` `)を繰り返した文字列を生成します。

**構文**

```sql
space(n)
```

**引数**

- `n` — 空白文字を繰り返す回数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

`n`回繰り返された空白文字を含む文字列を返します。`n <= 0`の場合、空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT space(3) AS res, length(res);
```

```response title=レスポンス
┌─res─┬─length(res)─┐
│     │           3 │
└─────┴─────────────┘
```


## sparseGrams {#sparseGrams}

導入バージョン: v25.5

与えられた文字列から、長さが少なくとも `n` であるすべての部分文字列を検出します。
この際、部分文字列の境界にある (n-1)-gram のハッシュ値が、
部分文字列内部のすべての (n-1)-gram のハッシュ値よりも厳密に大きいものを抽出します。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGrams(s[, min_ngram_length, max_ngram_length])
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
- `min_ngram_length` — オプション。抽出される n-gram の最小長。デフォルト値および最小値は 3 です。[`UInt*`](/sql-reference/data-types/int-uint)
- `max_ngram_length` — オプション。抽出される n-gram の最大長。デフォルト値は 100 です。`min_ngram_length` 以上である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT sparseGrams('alice', 3)
```

```response title=結果
┌─sparseGrams('alice', 3)────────────┐
│ ['ali','lic','lice','ice']         │
└────────────────────────────────────┘
```


## sparseGramsHashes {#sparseGramsHashes}

導入バージョン: v25.5

与えられた文字列から、長さが少なくとも `n` であるすべての部分文字列のハッシュを検索します。
ここで、部分文字列の境界にある (n-1)-gram のハッシュが、
部分文字列内部のすべての (n-1)-gram のハッシュよりも厳密に大きい場合に該当します。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsHashes(s[, min_ngram_length, max_ngram_length])
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
- `min_ngram_length` — オプション。抽出される n-gram の最小長。デフォルト値および最小値は 3 です。[`UInt*`](/sql-reference/data-types/int-uint)
- `max_ngram_length` — オプション。抽出される n-gram の最大長。デフォルト値は 100 です。`min_ngram_length` 以上である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択された部分文字列の CRC32 ハッシュの配列を返します。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsHashes('alice', 3)
```

```response title=Response
┌─sparseGramsHashes('alice', 3)──────────────────────┐
│ [1481062250,2450405249,4012725991,1918774096]      │
└────────────────────────────────────────────────────┘
```


## sparseGramsHashesUTF8 {#sparseGramsHashesUTF8}

導入バージョン: v25.5

与えられたUTF-8文字列から、長さが少なくとも`n`であるすべての部分文字列のハッシュを検索します。ここで、部分文字列の境界にある(n-1)-gramのハッシュは、部分文字列内部のすべての(n-1)-gramのハッシュよりも厳密に大きい値となります。
UTF-8文字列を想定しており、無効なUTF-8シーケンスの場合は例外をスローします。
ハッシュ関数として`CRC32`を使用します。

**構文**

```sql
sparseGramsHashesUTF8(s[, min_ngram_length, max_ngram_length])
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
- `min_ngram_length` — オプション。抽出するngramの最小長。デフォルト値および最小値は3です。[`UInt*`](/sql-reference/data-types/int-uint)
- `max_ngram_length` — オプション。抽出するngramの最大長。デフォルト値は100です。`min_ngram_length`以上である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択されたUTF-8部分文字列のCRC32ハッシュの配列を返します。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsHashesUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsHashesUTF8('алиса', 3)─┐
│ [4178533925,3855635300,561830861] │
└───────────────────────────────────┘
```


## sparseGramsUTF8 {#sparseGramsUTF8}

導入バージョン: v25.5

指定されたUTF-8文字列から、長さが少なくとも`n`であり、部分文字列の境界にある(n-1)-gramのハッシュ値が部分文字列内部のすべての(n-1)-gramのハッシュ値よりも厳密に大きいすべての部分文字列を検出します。
UTF-8文字列を想定しており、無効なUTF-8シーケンスの場合は例外をスローします。
ハッシュ関数として`CRC32`を使用します。

**構文**

```sql
sparseGramsUTF8(s[, min_ngram_length, max_ngram_length])
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
- `min_ngram_length` — オプション。抽出されるngramの最小長。デフォルト値および最小値は3です。[`UInt*`](/sql-reference/data-types/int-uint)
- `max_ngram_length` — オプション。抽出されるngramの最大長。デフォルト値は100です。`min_ngram_length`以上である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

選択されたUTF-8部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT sparseGramsUTF8('алиса', 3)
```

```response title=レスポンス
┌─sparseGramsUTF8('алиса', 3)─┐
│ ['али','лис','иса']         │
└─────────────────────────────┘
```


## startsWith {#startsWith}

導入バージョン: v1.1

文字列が指定された文字列で始まるかどうかをチェックします。

**構文**

```sql
startsWith(s, prefix)
```

**引数**

- `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
- `prefix` — チェックする接頭辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s`が`prefix`で始まる場合は`1`を返し、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT startsWith('ClickHouse', 'Click');
```

```response title=レスポンス
┌─startsWith('⋯', 'Click')─┐
│                        1 │
└──────────────────────────┘
```


## startsWithCaseInsensitive {#startsWithCaseInsensitive}

導入バージョン: v25.9

文字列が指定されたプレフィックスで始まるかどうかを大文字小文字を区別せずに確認します。

**構文**

```sql
startsWithCaseInsensitive(s, prefix)
```

**引数**

- `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
- `prefix` — チェックするプレフィックス(大文字小文字を区別しない)。[`String`](/sql-reference/data-types/string)

**戻り値**

`s`が`prefix`で始まる場合(大文字小文字を区別しない)は`1`を返し、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT startsWithCaseInsensitive('ClickHouse', 'CLICK');
```

```response title=レスポンス
┌─startsWithCaseInsensitive('⋯', 'CLICK')─┐
│                                       1 │
└─────────────────────────────────────────┘
```


## startsWithCaseInsensitiveUTF8 {#startsWithCaseInsensitiveUTF8}

導入バージョン: v25.9

文字列が指定された大文字小文字を区別しない接頭辞で始まるかどうかを確認します。
文字列が有効なUTF-8エンコードされたテキストを含むことを前提としています。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。

**構文**

```sql
startsWithCaseInsensitiveUTF8(s, prefix)
```

**引数**

- `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
- `prefix` — チェック対象の大文字小文字を区別しない接頭辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s`が大文字小文字を区別しない`prefix`で始まる場合は`1`を返し、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT startsWithCaseInsensitiveUTF8('приставка', 'при')
```

```response title=レスポンス
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```


## startsWithUTF8 {#startsWithUTF8}

導入バージョン: v23.8

文字列が指定された接頭辞で始まるかどうかをチェックします。
文字列が有効なUTF-8エンコードされたテキストを含むことを前提としています。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。

**構文**

```sql
startsWithUTF8(s, prefix)
```

**引数**

- `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
- `prefix` — チェック対象の接頭辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s`が`prefix`で始まる場合は`1`を返し、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT startsWithUTF8('приставка', 'при')
```

```response title=レスポンス
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```


## stringBytesEntropy {#stringBytesEntropy}

導入バージョン: v25.6

文字列内のバイト分布のシャノンエントロピーを計算します。

**構文**

```sql
stringBytesEntropy(s)
```

**引数**

- `s` — 分析する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列内のバイト分布のシャノンエントロピーを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=クエリ
SELECT stringBytesEntropy('Hello, world!')
```

```response title=レスポンス
┌─stringBytesEntropy('Hello, world!')─┐
│                         3.07049960  │
└─────────────────────────────────────┘
```


## stringBytesUniq {#stringBytesUniq}

導入バージョン: v25.6

文字列内の一意のバイト数をカウントします。

**構文**

```sql
stringBytesUniq(s)
```

**引数**

- `s` — 分析する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列内の一意のバイト数を返します。[`UInt16`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT stringBytesUniq('Hello')
```

```response title=レスポンス
┌─stringBytesUniq('Hello')─┐
│                        4 │
└──────────────────────────┘
```


## stringJaccardIndex {#stringJaccardIndex}

導入バージョン: v23.11

2つのバイト文字列間の[Jaccard類似度指数](https://en.wikipedia.org/wiki/Jaccard_index)を計算します。

**構文**

```sql
stringJaccardIndex(s1, s2)
```

**引数**

- `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間のJaccard類似度指数を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=クエリ
SELECT stringJaccardIndex('clickhouse', 'mouse')
```

```response title=レスポンス
┌─stringJaccardIndex('clickhouse', 'mouse')─┐
│                                       0.4 │
└───────────────────────────────────────────┘
```


## stringJaccardIndexUTF8 {#stringJaccardIndexUTF8}

導入バージョン: v23.11

[`stringJaccardIndex`](#stringJaccardIndex)と同様ですが、UTF-8エンコードされた文字列を対象とします。

**構文**

```sql
stringJaccardIndexUTF8(s1, s2)
```

**引数**

- `s1` — 1番目の入力UTF-8文字列。[`String`](/sql-reference/data-types/string)
- `s2` — 2番目の入力UTF-8文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つのUTF-8文字列間のJaccard類似度インデックスを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringJaccardIndexUTF8('我爱你', '我也爱你')
```

```response title=Response
┌─stringJaccardIndexUTF8('我爱你', '我也爱你')─┐
│                                       0.75 │
└─────────────────────────────────────────────┘
```


## substring {#substring}

導入バージョン: v1.1

指定されたバイトインデックス `offset` から始まる文字列 `s` の部分文字列を返します。
バイトカウントは1から始まり、以下のロジックに従います:

- `offset` が `0` の場合、空文字列が返されます。
- `offset` が負の場合、部分文字列は文字列の先頭からではなく、末尾から `pos` 文字の位置から始まります。

オプション引数 `length` は、返される部分文字列の最大バイト数を指定します。

**構文**

```sql
substring(s, offset[, length])
```

**エイリアス**: `byteSlice`, `mid`, `substr`

**引数**

- `s` — 部分文字列を抽出する文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Enum`](/sql-reference/data-types/enum)
- `offset` — `s` における部分文字列の開始位置。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `length` — オプション。部分文字列の最大長。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

インデックス `offset` から始まる、`length` バイトの `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な使用方法**

```sql title=Query
SELECT 'database' AS db, substr(db, 5), substr(db, 5, 1)
```

```response title=Response
┌─db───────┬─substring('database', 5)─┬─substring('database', 5, 1)─┐
│ database │ base                     │ b                           │
└──────────┴──────────────────────────┴─────────────────────────────┘
```


## substringIndex {#substringIndex}

導入バージョン: v23.7

SparkやMySQLと同様に、区切り文字`delim`の`count`回目の出現位置より前の`s`の部分文字列を返します。

**構文**

```sql
substringIndex(s, delim, count)
```

**エイリアス**: `SUBSTRING_INDEX`

**引数**

- `s` — 部分文字列を抽出する元の文字列。[`String`](/sql-reference/data-types/string)
- `delim` — 区切り文字。[`String`](/sql-reference/data-types/string)
- `count` — 部分文字列を抽出する前にカウントする区切り文字の出現回数。countが正の場合、左から数えて最後の区切り文字より左側のすべてが返されます。countが負の場合、右から数えて最後の区切り文字より右側のすべてが返されます。[`UInt`](/sql-reference/data-types/int-uint)または[`Int`](/sql-reference/data-types/int-uint)

**戻り値**

`delim`の`count`回目の出現位置より前の`s`の部分文字列。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT substringIndex('www.clickhouse.com', '.', 2)
```

```response title=Response
┌─substringIndex('www.clickhouse.com', '.', 2)─┐
│ www.clickhouse                               │
└──────────────────────────────────────────────┘
```


## substringIndexUTF8 {#substringIndexUTF8}

導入バージョン: v23.7

区切り文字 `delim` が `count` 回出現する前の `s` の部分文字列を返します。Unicodeコードポイントに特化しています。
文字列が有効なUTF-8エンコードされたテキストを含むことを前提としています。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。

**構文**

```sql
substringIndexUTF8(s, delim, count)
```

**引数**

- `s` — 部分文字列を抽出する文字列。[`String`](/sql-reference/data-types/string)
- `delim` — 区切り文字。[`String`](/sql-reference/data-types/string)
- `count` — 部分文字列を抽出する前にカウントする区切り文字の出現回数。countが正の場合、最後の区切り文字の左側(左から数えて)のすべてが返されます。countが負の場合、最後の区切り文字の右側(右から数えて)のすべてが返されます。[`UInt`](/sql-reference/data-types/int-uint) または [`Int`](/sql-reference/data-types/int-uint)

**戻り値**

`delim` が `count` 回出現する前の `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**UTF8の例**

```sql title=Query
SELECT substringIndexUTF8('www.straßen-in-europa.de', '.', 2)
```

```response title=Response
www.straßen-in-europa
```


## substringUTF8 {#substringUTF8}

導入バージョン: v1.1

Unicodeコードポイントに対して、指定されたバイトインデックス `offset` から始まる文字列 `s` の部分文字列を返します。
バイトカウントは `1` から始まり、以下のロジックに従います:

- `offset` が `0` の場合、空文字列が返されます。
- `offset` が負の場合、部分文字列は文字列の先頭からではなく、末尾から `pos` 文字の位置から始まります。

オプション引数 `length` は、返される部分文字列の最大バイト数を指定します。

:::note
この関数は、文字列が有効なUTF-8エンコードされたテキストを含むことを前提としています。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。
:::

**構文**

```sql
substringUTF8(s, offset[, length])
```

**引数**

- `s` — 部分文字列を抽出する元の文字列。[`String`](/sql-reference/data-types/string)、[`FixedString`](/sql-reference/data-types/fixedstring)、または[`Enum`](/sql-reference/data-types/enum)
- `offset` — `s` における部分文字列の開始位置。[`Int`](/sql-reference/data-types/int-uint)または[`UInt`](/sql-reference/data-types/int-uint)
- `length` — 部分文字列の最大長。オプション。[`Int`](/sql-reference/data-types/int-uint)または[`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

インデックス `offset` から始まる、最大 `length` バイトの `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT 'Täglich grüßt das Murmeltier.' AS str, substringUTF8(str, 9), substringUTF8(str, 9, 5)
```

```response title=Response
Täglich grüßt das Murmeltier.    grüßt das Murmeltier.    grüßt
```


## toValidUTF8 {#toValidUTF8}

導入バージョン: v20.1

文字列を有効なUTF-8エンコーディングに変換します。無効なUTF-8文字は置換文字`�`(U+FFFD)に置き換えられます。
連続する複数の無効な文字が見つかった場合、それらは単一の置換文字に集約されます。

**構文**

```sql
toValidUTF8(s)
```

**引数**

- `s` — String型オブジェクトとして表現される任意のバイト列。[`String`](/sql-reference/data-types/string)

**戻り値**

有効なUTF-8文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT toValidUTF8('\\x61\\xF0\\x80\\x80\\x80b')
```

```response title=レスポンス
c
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```


## trimBoth {#trimBoth}

導入バージョン: v20.1

文字列の先頭と末尾から指定された文字を削除します。
デフォルトでは、一般的な空白文字(ASCII)が削除されます。

**構文**

```sql
trimBoth(s[, trim_characters])
```

**エイリアス**: `trim`

**引数**

- `s` — トリムする文字列。[`String`](/sql-reference/data-types/string)
- `trim_characters` — オプション。トリムする文字。指定しない場合、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

両端から指定された文字がトリムされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT trimBoth('$$ClickHouse$$', '$')
```

```response title=レスポンス
┌─trimBoth('$$⋯se$$', '$')─┐
│ ClickHouse               │
└──────────────────────────┘
```


## trimLeft {#trimLeft}

導入バージョン: v20.1

文字列の先頭から指定された文字を削除します。
デフォルトでは、一般的な空白文字(ASCII)が削除されます。

**構文**

```sql
trimLeft(input[, trim_characters])
```

**エイリアス**: `ltrim`

**引数**

- `input` — トリム対象の文字列。[`String`](/sql-reference/data-types/string)
- `trim_characters` — オプション。トリムする文字。指定しない場合、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

左側から指定された文字がトリムされた文字列。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT trimLeft('ClickHouse', 'Click');
```

```response title=レスポンス
┌─trimLeft('Cl⋯', 'Click')─┐
│ House                    │
└──────────────────────────┘
```


## trimRight {#trimRight}

導入バージョン: v20.1

文字列の末尾から指定された文字を削除します。
デフォルトでは、一般的な空白文字(ASCII)を削除します。

**構文**

```sql
trimRight(s[, trim_characters])
```

**エイリアス**: `rtrim`

**引数**

- `s` — トリムする文字列。[`String`](/sql-reference/data-types/string)
- `trim_characters` — トリムする文字(オプション)。指定しない場合、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

右側から指定された文字がトリムされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT trimRight('ClickHouse','House');
```

```response title=レスポンス
┌─trimRight('C⋯', 'House')─┐
│ Click                    │
└──────────────────────────┘
```


## tryBase32Decode {#tryBase32Decode}

導入バージョン: v25.6

文字列を受け取り、[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6)エンコーディング方式を使用してデコードします。

**構文**

```sql
tryBase32Decode(encoded)
```

**引数**

- `encoded` — デコードする文字列カラムまたは定数。文字列が有効なBase32エンコードでない場合、エラー時に空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT tryBase32Decode('IVXGG33EMVSA====');
```

```response title=レスポンス
┌─tryBase32Decode('IVXGG33EMVSA====')─┐
│ Encoded                             │
└─────────────────────────────────────┘
```


## tryBase58Decode {#tryBase58Decode}

導入バージョン: v22.10

[`base58Decode`](#base58Decode)と同様ですが、エラーが発生した場合は空文字列を返します。

**構文**

```sql
tryBase58Decode(encoded)
```

**引数**

- `encoded` — 文字列カラムまたは定数。文字列が有効なBase58エンコードでない場合、エラー時に空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT tryBase58Decode('3dc8KtHrwM') AS res, tryBase58Decode('invalid') AS res_invalid;
```

```response title=レスポンス
┌─res─────┬─res_invalid─┐
│ Encoded │             │
└─────────┴─────────────┘
```


## tryBase64Decode {#tryBase64Decode}

導入バージョン: v18.16

[`base64Decode`](#base64Decode)と同様ですが、エラーが発生した場合は空文字列を返します。

**構文**

```sql
tryBase64Decode(encoded)
```

**引数**

- `encoded` — デコードする文字列カラムまたは定数。文字列が有効なBase64エンコードでない場合、エラー時に空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT tryBase64Decode('Y2xpY2tob3VzZQ==')
```

```response title=レスポンス
┌─tryBase64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                          │
└─────────────────────────────────────┘
```


## tryBase64URLDecode {#tryBase64URLDecode}

導入バージョン: v18.16

[`base64URLDecode`](#base64URLDecode)と同様ですが、エラーが発生した場合は空文字列を返します。

**構文**

```sql
tryBase64URLDecode(encoded)
```

**引数**

- `encoded` — デコードする文字列カラムまたは定数。文字列が有効なBase64エンコードでない場合、エラー時に空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                               │
└──────────────────────────────────────────────────────┘
```


## tryIdnaEncode {#tryIdnaEncode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications) (IDNA) 機構に従って、ドメイン名のUnicode (UTF-8) 表現 (ToUnicodeアルゴリズム) を返します。
エラーが発生した場合は、例外をスローせずに空文字列を返します。

**構文**

```sql
tryIdnaEncode(s)
```

**引数**

- `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

IDNA機構に従って入力文字列のASCII表現を返します。入力が無効な場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryIdnaEncode('straße.münchen.de')
```

```response title=Response
┌─tryIdnaEncode('straße.münchen.de')──┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```


## tryPunycodeDecode {#tryPunycodeDecode}

導入バージョン: v24.1

`punycodeDecode`と同様ですが、有効なPunycodeエンコード文字列が指定されていない場合は空文字列を返します。

**構文**

```sql
tryPunycodeDecode(s)
```

**引数**

- `s` — Punycodeエンコードされた文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値のプレーンテキストを返します。入力が無効な場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryPunycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─tryPunycodeDecode('Mnchen-3ya')─┐
│ München                         │
└─────────────────────────────────┘
```


## upper {#upper}

導入バージョン: v1.1

文字列内のASCIIラテン文字を大文字に変換します。

**構文**

```sql
upper(s)
```

**エイリアス**: `ucase`

**引数**

- `s` — 大文字に変換する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s`を大文字に変換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT upper('clickhouse')
```

```response title=レスポンス
┌─upper('clickhouse')─┐
│ CLICKHOUSE          │
└─────────────────────┘
```


## upperUTF8 {#upperUTF8}

導入バージョン: v1.1

文字列が有効なUTF-8エンコードテキストを含むことを前提として、文字列を大文字に変換します。
この前提が満たされない場合、例外はスローされず、結果は未定義となります。

:::note
この関数は言語を検出しません。例えば、トルコ語の場合、結果が正確でない可能性があります（i/İ と i/I）。
コードポイントの大文字と小文字でUTF-8バイトシーケンスの長さが異なる場合（`ẞ` と `ß` など）、そのコードポイントに対する結果が正しくない可能性があります。
:::

**構文**

```sql
upperUTF8(s)
```

**引数**

- `s` — 文字列型。[`String`](/sql-reference/data-types/string)

**戻り値**

String データ型の値。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=クエリ
SELECT upperUTF8('München') AS Upperutf8
```

```response title=レスポンス
┌─Upperutf8─┐
│ MÜNCHEN   │
└───────────┘
```

<!--AUTOGENERATED_END-->

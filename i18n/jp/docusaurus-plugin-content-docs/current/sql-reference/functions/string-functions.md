---
description: '文字列関数に関するドキュメント'
sidebar_label: '文字列'
slug: /sql-reference/functions/string-functions
title: '文字列を操作する関数'
doc_type: 'reference'
---

import VersionBadge from '@theme/badges/VersionBadge';

# 文字列を扱う関数 {#functions-for-working-with-strings}

文字列の[検索](string-search-functions.md)および[置換](string-replace-functions.md)に関する関数は、別セクションで説明しています。

:::note
以下の内容は、`system.functions` システムテーブルから自動生成されています。
:::

{/* 
  以下のタグ内の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントに置き換えられます。タグを変更したり削除したりしないでください。
  詳細は次を参照してください: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## CRC32 {#CRC32}

導入バージョン: v20.1

CRC-32-IEEE 802.3 の多項式と初期値 `0xffffffff`（zlib による実装）を使用して、文字列の CRC32 チェックサムを計算します。

**構文**

```sql
CRC32(s)
```

**引数**

* `s` — CRC32 を計算する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC32 チェックサムを返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC32('ClickHouse')
```

```response title=Response
┌─CRC32('ClickHouse')─┐
│          1538217360 │
└─────────────────────┘
```

## CRC32IEEE {#CRC32IEEE}

導入バージョン: v20.1

CRC-32-IEEE 802.3 多項式を使用して、文字列の CRC32 チェックサムを計算します。

**構文**

```sql
CRC32IEEE(s)
```

**引数**

* `s` — CRC32 を計算する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC32 チェックサムを返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC32IEEE('ClickHouse');
```

```response title=Response
┌─CRC32IEEE('ClickHouse')─┐
│              3089448422 │
└─────────────────────────┘
```

## CRC64 {#CRC64}

導入バージョン: v20.1

CRC-64-ECMA多項式を使用して文字列のCRC64チェックサムを計算します。

**構文**

```sql
CRC64(s)
```

**引数**

* `s` — CRC64 を計算する対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列の CRC64 チェックサムを返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT CRC64('ClickHouse');
```

```response title=Response
┌──CRC64('ClickHouse')─┐
│ 12126588151325169346 │
└──────────────────────┘
```

## appendTrailingCharIfAbsent {#appendTrailingCharIfAbsent}

導入: v1.1

文字列 `s` が空でなく、末尾が文字 `c` で終わっていない場合に、`s` の末尾に文字 `c` を付加します。

**構文**

```sql
appendTrailingCharIfAbsent(s, c)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `c` — 存在しない場合に末尾へ追加する文字。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `c` で終わっていない場合、末尾に文字 `c` を追加した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT appendTrailingCharIfAbsent('https://example.com', '/');
```

```response title=Response
┌─appendTraili⋯.com', '/')─┐
│ https://example.com/     │
└──────────────────────────┘
```

## ascii {#ascii}

導入バージョン: v22.11

文字列 `s` の先頭の1文字の ASCII コードポイント値を `Int32` として返します。

**構文**

```sql
ascii(s)
```

**引数**

* `s` — 文字列型の入力値。[`String`](/sql-reference/data-types/string)

**返される値**

先頭文字の ASCII コードポイントを返します。`s` が空の場合、結果は `0` です。先頭文字が ASCII 文字ではない、または UTF-16 の Latin-1 補助範囲に含まれない場合、結果は未定義です。[`Int32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT ascii('234')
```

```response title=Response
┌─ascii('234')─┐
│           50 │
└──────────────┘
```

## base32Decode {#base32Decode}

導入バージョン: v25.6

[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6)（RFC 4648）でエンコードされた文字列をデコードします。
文字列が有効な Base32 で正しくエンコードされていない場合は、例外がスローされます。

**構文**

```sql
base32Decode(encoded)
```

**引数**

* `encoded` — 文字列型の列または定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base32Decode('IVXGG33EMVSA====');
```

```response title=Response
┌─base32Decode('IVXGG33EMVSA====')─┐
│ エンコード済み                    │
└──────────────────────────────────┘
```

## base32Encode {#base32Encode}

導入バージョン: v25.6

文字列を [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) でエンコードします。

**構文**

```sql
base32Encode(plaintext)
```

**引数**

* `plaintext` — 符号化するプレーンテキスト。[`String`](/sql-reference/data-types/string)

**返り値**

引数を符号化した値を含む文字列を返します。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**例**

**使用例**

```sql title=Query
SELECT base32Encode('Encoded')
```

```response title=Response
┌─base32Encode('Encoded')─┐
│ IVXGG33EMVSA====        │
└─────────────────────────┘
```

## base58Decode {#base58Decode}

導入バージョン: v22.7

[Base58](https://datatracker.ietf.org/doc/html/draft-msporny-base58-03#section-3) でエンコードされた文字列をデコードします。
文字列が有効な Base58 エンコード文字列でない場合は、例外がスローされます。

**構文**

```sql
base58Decode(encoded)
```

**引数**

* `encoded` — デコードする文字列型の列または定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のデコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base58Decode('JxF12TrwUP45BMd');
```

```response title=Response
┌─base58Decode⋯rwUP45BMd')─┐
│ Hello World              │
└──────────────────────────┘
```

## base58Encode {#base58Encode}

導入バージョン: v22.7

文字列を [Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) エンコーディングでエンコードします。

**構文**

```sql
base58Encode(plaintext)
```

**引数**

* `plaintext` — エンコードするプレーンテキスト。[`String`](/sql-reference/data-types/string)

**戻り値**

引数のエンコードされた値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base58Encode('ClickHouse');
```

```response title=Response
┌─base58Encode('ClickHouse')─┐
│ 4nhk8K7GHXf6zx             │
└────────────────────────────┘
```

## base64Decode {#base64Decode}

導入バージョン: v18.16

[Base64](https://en.wikipedia.org/wiki/Base64) 表現の文字列を、RFC 4648 に従ってデコードします。
エラーが発生した場合は例外をスローします。

**構文**

```sql
base64Decode(encoded)
```

**エイリアス**: `FROM_BASE64`

**引数**

* `encoded` — デコード対象の文字列型カラムまたは定数。文字列が有効な Base64 文字列でない場合、例外がスローされます。 [`String`](/sql-reference/data-types/string)

**返される値**

デコードされた文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64Decode('Y2xpY2tob3VzZQ==')
```

```response title=Response
┌─base64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                       │
└──────────────────────────────────┘
```

## base64Encode {#base64Encode}

導入バージョン: v18.16

RFC 4648 に準拠した [Base64](https://en.wikipedia.org/wiki/Base64) 形式で文字列をエンコードします。

**構文**

```sql
base64Encode(plaintext)
```

**別名**: `TO_BASE64`

**引数**

* `plaintext` — デコードするプレーンテキストのカラムまたは定数。[`String`](/sql-reference/data-types/string)

**戻り値**

引数の値をエンコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64Encode('clickhouse')
```

```response title=Response
┌─base64Encode('clickhouse')─┐
│ Y2xpY2tob3VzZQ==           │
└────────────────────────────┘
```

## base64URLDecode {#base64URLDecode}

導入バージョン: v24.6

RFC 4648 に従い、URL セーフなアルファベットを使用する [Base64](https://en.wikipedia.org/wiki/Base64) 表現でエンコードされた文字列をデコードします。
エラーが発生した場合には例外をスローします。

**構文**

```sql
base64URLDecode(encoded)
```

**引数**

* `encoded` — エンコード対象の文字列カラムまたは定数。文字列が有効な Base64 でエンコードされたものでない場合は、例外がスローされます。 [`String`](/sql-reference/data-types/string)

**返される値**

引数をデコードした値を含む文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─base64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                            │
└───────────────────────────────────────────────────┘
```

## base64URLEncode {#base64URLEncode}

導入: v18.16

URL セーフなアルファベットを使用して、文字列を [Base64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)（RFC 4648）表現でエンコードします。

**構文**

```sql
base64URLEncode(plaintext)
```

**引数**

* `plaintext` — エンコードするプレーンテキスト列または定数。[`String`](/sql-reference/data-types/string)

**返される値**

引数をエンコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT base64URLEncode('https://clickhouse.com')
```

```response title=Response
┌─base64URLEncode('https://clickhouse.com')─┐
│ aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ            │
└───────────────────────────────────────────┘
```

## basename {#basename}

導入バージョン: v20.1

文字列内で最後に現れるスラッシュまたはバックスラッシュ以降の部分を抽出します。
この関数は、パスからファイル名を抽出する際によく使用されます。

**構文**

```sql
basename(expr)
```

**引数**

* `expr` — 文字列表現。バックスラッシュはエスケープする必要があります。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列内で最後に現れるスラッシュまたはバックスラッシュ以降の部分文字列を返します。入力文字列がスラッシュまたはバックスラッシュで終わる場合は、空文字列を返します。スラッシュやバックスラッシュが含まれていない場合は、元の文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**Unix パスからファイル名を抽出する**

```sql title=Query
SELECT 'some/long/path/to/file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some/long/path/to/file')─┐
│ some/long/path/to/file │ file                               │
└────────────────────────┴────────────────────────────────────┘
```

**Windows のパスからファイル名を抽出**

```sql title=Query
SELECT 'some\\long\\path\\to\\file' AS a, basename(a)
```

```response title=Response
┌─a──────────────────────┬─basename('some\\long\\path\\to\\file')─┐
│ some\long\path\to\file │ file                                   │
└────────────────────────┴────────────────────────────────────────┘
```

**パス区切りを含まない文字列**

```sql title=Query
SELECT 'some-file-name' AS a, basename(a)
```

```response title=Response
┌─a──────────────┬─basename('some-file-name')─┐
│ some-file-name │ some-file-name             │
└────────────────┴────────────────────────────┘
```

## byteHammingDistance {#byteHammingDistance}

導入バージョン: v23.9

2つのバイト文字列間の[ハミング距離](https://en.wikipedia.org/wiki/Hamming_distance)を計算します。

**構文**

```sql
byteHammingDistance(s1, s2)
```

**別名**: `mismatches`

**引数**

* `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間のハミング距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT byteHammingDistance('karolin', 'kathrin')
```

```response title=Response
┌─byteHammingDistance('karolin', 'kathrin')─┐
│                                         3 │
└───────────────────────────────────────────┘
```

## compareSubstrings {#compareSubstrings}

導入バージョン: v25.2

2つの文字列を辞書順で比較します。

**構文**

```sql
compareSubstrings(s1, s2, s1_offset, s2_offset, num_bytes)
```

**引数**

* `s1` — 比較する1番目の文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 比較する2番目の文字列。[`String`](/sql-reference/data-types/string)
* `s1_offset` — 比較を開始する `s1` 内の位置（0始まりのインデックス）。[`UInt*`](/sql-reference/data-types/int-uint)
* `s2_offset` — 比較を開始する `s2` 内の位置（0始まりのインデックス）。[`UInt*`](/sql-reference/data-types/int-uint)
* `num_bytes` — 両方の文字列で比較する最大バイト数。`s1_offset`（または `s2_offset`）+ `num_bytes` が入力文字列の末尾を超える場合、`num_bytes` はそれに応じて小さくなります。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

次の値を返します：

* `s1`[`s1_offset` : `s1_offset` + `num_bytes`] &lt; `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合は `-1`。
* `s1`[`s1_offset` : `s1_offset` + `num_bytes`] = `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合は `0`。
* `s1`[`s1_offset` : `s1_offset` + `num_bytes`] &gt; `s2`[`s2_offset` : `s2_offset` + `num_bytes`] の場合は `1`。
  [`Int8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT compareSubstrings('Saxony', 'Anglo-Saxon', 0, 6, 5) AS result
```

```response title=Response
┌─result─┐
│      0 │
└────────┘
```

## concat {#concat}

導入バージョン: v1.1

指定された引数を連結します。

[`String`](../data-types/string.md) または [`FixedString`](../data-types/fixedstring.md) 型以外の引数は、既定のシリアライズ方式を用いて文字列に変換されます。
これによりパフォーマンスが低下するため、`String` / `FixedString` 以外の引数を使用することは推奨されません。

**構文**

```sql
concat([s1, s2, ...])
```

**引数**

* `s1, s2, ...` — 任意の型の値を任意の数だけ指定できます。[`Any`](/sql-reference/data-types)

**戻り値**

引数を連結して生成された String を返します。いずれかの引数が `NULL` の場合、関数は `NULL` を返します。引数が 1 つもない場合は、空文字列を返します。[`Nullable(String)`](/sql-reference/data-types/nullable)

**例**

**文字列の連結**

```sql title=Query
SELECT concat('こんにちは、', '世界！')
```

```response title=Response
┌─concat('Hello, ', 'World!')─┐
│ Hello, World!               │
└─────────────────────────────┘
```

**数値の連結**

```sql title=Query
SELECT concat(42, 144)
```

```response title=Response
┌─concat(42, 144)─┐
│ 42144           │
└─────────────────┘
```

## concatAssumeInjective {#concatAssumeInjective}

導入: v1.1

[`concat`](#concat) と同様ですが、`concat(s1, s2, ...) → sn` が単射であると仮定します。
すなわち、異なる引数に対して常に異なる結果を返すとみなします。

`GROUP BY` の最適化に利用できます。

**構文**

```sql
concatAssumeInjective([s1, s2, ...])
```

**引数**

* `s1, s2, ...` — 任意の型の値を任意の数だけ指定できます。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

引数を連結して作成された文字列を返します。いずれかの引数の値が `NULL` の場合、関数は `NULL` を返します。引数が渡されない場合は空文字列を返します。戻り値の型は [`String`](/sql-reference/data-types/string) です。

**例**

**GROUP BY の最適化**

```sql title=Query
SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY concatAssumeInjective(key1, key2)
```

```response title=Response
┌─concat(key1, key2)─┬─sum(value)─┐
│ Hello, World!      │          3 │
│ Hello, World!      │          2 │
│ Hello, World       │          3 │
└────────────────────┴────────────┘
```

## concatWithSeparator {#concatWithSeparator}

導入バージョン: v22.12

指定されたセパレータで区切って文字列を連結します。

**構文**

```sql
concatWithSeparator(sep[, exp1, exp2, ...])
```

**別名**: `concat_ws`

**引数**

* `sep` — 使用する区切り文字列。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)
* `exp1, exp2, ...` — 連結する式。`String` または `FixedString` 型でない引数は、デフォルトのシリアライゼーションを用いて文字列に変換されます。これはパフォーマンスが低下するため、`String`/`FixedString` 以外の引数の使用は推奨されません。[`Any`](/sql-reference/data-types)

**戻り値**

引数を連結して作成された `String` を返します。引数のいずれかの値が `NULL` の場合、関数は `NULL` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT concatWithSeparator('a', '1', '2', '3', '4')
```

```response title=Response
┌─concatWithSeparator('a', '1', '2', '3', '4')─┐
│ 1a2a3a4                                      │
└──────────────────────────────────────────────┘
```

## concatWithSeparatorAssumeInjective {#concatWithSeparatorAssumeInjective}

導入バージョン: v22.12

[`concatWithSeparator`](#concatWithSeparator) と似ていますが、`concatWithSeparator(sep[,exp1, exp2, ... ]) → result` が単射であると仮定します。
関数は、異なる引数に対して常に異なる結果を返す場合に単射と呼ばれます。

`GROUP BY` の最適化に使用できます。

**構文**

```sql
concatWithSeparatorAssumeInjective(sep[, exp1, exp2, ... ])
```

**引数**

* `sep` — 使用する区切り文字。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)
* `exp1, exp2, ...` — 連結する式。型が `String` または `FixedString` でない引数は、デフォルトのシリアル化によって文字列に変換されます。これによりパフォーマンスが低下するため、String / FixedString 以外の引数の使用は推奨されません。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**返される値**

引数を連結して作成された String を返します。いずれかの引数の値が `NULL` の場合、関数は `NULL` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
CREATE TABLE user_data (
user_id UInt32,
first_name String,
last_name String,
score UInt32
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO user_data VALUES
(1, 'John', 'Doe', 100),
(2, 'Jane', 'Smith', 150),
(3, 'John', 'Wilson', 120),
(4, 'Jane', 'Smith', 90);

SELECT
    concatWithSeparatorAssumeInjective('-', first_name, last_name) as full_name,
    sum(score) as total_score
FROM user_data
GROUP BY concatWithSeparatorAssumeInjective('-', first_name, last_name);
```

```response title=Response
┌─full_name───┬─total_score─┐
│ Jane-Smith  │         240 │
│ John-Doe    │         100 │
│ John-Wilson │         120 │
└─────────────┴─────────────┘
```

## conv {#conv}

導入バージョン: v1.1

異なる基数間で数値を変換します。

数値をある基数から別の基数へ変換します。2 から 36 までの基数をサポートします。
10 より大きい基数では、桁 10～35 を表すために文字 A～Z（大文字・小文字は区別しない）が使用されます。

この関数は MySQL の `CONV()` 関数と互換性があります。

**構文**

```sql
conv(数値, 変換元基数, 変換先基数)
```

**引数**

* `number` — 変換する数値。文字列型または数値型を指定できます。
* `from_base` — 元の基数 (2〜36)。整数でなければなりません。
* `to_base` — 変換先の基数 (2〜36)。整数でなければなりません。

**戻り値**

変換先の基数で表現された数値の文字列表現。

**例**

**10進数を2進数に変換**

```sql title=Query
SELECT conv('10', 10, 2)
```

```response title=Response
1010
```

**16進数を10進数に変換**

```sql title=Query
SELECT conv('FF', 16, 10)
```

```response title=Response
255
```

**負数での変換**

```sql title=Query
SELECT conv('-1', 10, 16)
```

```response title=Response
FFFFFFFFFFFFFFFF
```

**2 進数を 8 進数に変換する**

```sql title=Query
SELECT conv('1010', 2, 8)
```

```response title=Response
12
```

## convertCharset {#convertCharset}

導入バージョン: v1.1

文字列 `s` をエンコーディング `from` から `to` へ変換した結果を返します。

**構文**

```sql
convertCharset(s, from, to)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `from` — 変換元の文字エンコーディング。[`String`](/sql-reference/data-types/string)
* `to` — 変換先の文字エンコーディング。[`String`](/sql-reference/data-types/string)

**戻り値**

文字エンコーディング `from` から `to` へ変換した文字列 `s` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT convertCharset('Café', 'UTF-8', 'ISO-8859-1');
```

```response title=Response
┌─convertChars⋯SO-8859-1')─┐
│ Caf�                     │
└──────────────────────────┘
```

## damerauLevenshteinDistance {#damerauLevenshteinDistance}

導入バージョン: v24.1

2 つのバイト列間の [Damerau-Levenshtein 距離](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance) を計算します。

**構文**

```sql
damerauLevenshteinDistance(s1, s2)
```

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列間の Damerau-Levenshtein 距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT damerauLevenshteinDistance('clickhouse', 'mouse')
```

```response title=Response
┌─damerauLevenshteinDistance('clickhouse', 'mouse')─┐
│                                                 6 │
└───────────────────────────────────────────────────┘
```

## decodeHTMLComponent {#decodeHTMLComponent}

導入バージョン: v23.9

文字列内の HTML エンティティを対応する文字にデコードします。

**構文**

```sql
decodeHTMLComponent(s)
```

**引数**

* `s` — デコード対象の HTML エンティティを含む文字列。[`String`](/sql-reference/data-types/string)

**返される値**

HTML エンティティをデコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')
```

```response title=Response
┌─decodeHTMLComponent('&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;')─┐
│ <div>Hello & "World"</div>                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

## decodeXMLComponent {#decodeXMLComponent}

導入バージョン: v21.2

文字列内の XML エンティティを対応する文字にデコードします。

**構文**

```sql
decodeXMLComponent(s)
```

**引数**

* `s` — デコードする XML エンティティを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された文字列内の XML エンティティをデコードした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT decodeXMLComponent('&lt;tag&gt;Hello &amp; World&lt;/tag&gt;')
```

```response title=Response
┌─decodeXMLCom⋯;/tag&gt;')─┐
│ <tag>Hello & World</tag> │
└──────────────────────────┘
```

## editDistance {#editDistance}

導入バージョン: v23.9

2つのバイト文字列間の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)を計算します。

**構文**

```sql
editDistance(s1, s2)
```

**エイリアス**: `levenshteinDistance`

**引数**

* `s1` — 1つ目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2つ目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の編集距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT editDistance('clickhouse', 'mouse')
```

```response title=Response
┌─editDistance('clickhouse', 'mouse')─┐
│                                   6 │
└─────────────────────────────────────┘
```

## editDistanceUTF8 {#editDistanceUTF8}

導入バージョン: v24.6

2つの UTF8 文字列間の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)を計算します。

**構文**

```sql
editDistanceUTF8(s1, s2)
```

**別名**: `levenshteinDistanceUTF8`

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**返り値**

2 つの UTF-8 文字列間の編集距離を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT editDistanceUTF8('我是谁', '我是我')
```

```response title=Response
┌─editDistanceUTF8('我是谁', '我是我')──┐
│                                   1 │
└─────────────────────────────────────┘
```

## encodeXMLComponent {#encodeXMLComponent}

導入バージョン: v21.1

文字列を XML のテキストノードや属性値として埋め込むために、特殊文字をエスケープします。

**構文**

```sql
encodeXMLComponent(s)
```

**引数**

* `s` — エスケープする文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

エスケープされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    '<tag>Hello & "World"</tag>' AS original,
    encodeXMLComponent('<tag>Hello & "World"</tag>') AS xml_encoded;
```

```response title=Response
┌─original───────────────────┬─xml_encoded──────────────────────────────────────────┐
│ <tag>こんにちは & "世界"</tag> │ &lt;tag&gt;こんにちは &amp; &quot;世界&quot;&lt;/tag&gt; │
└────────────────────────────┴──────────────────────────────────────────────────────┘
```

## endsWith {#endsWith}

導入: v1.1

文字列が指定された接尾辞で終わっているかどうかをチェックします。

**構文**

```sql
endsWith(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 末尾にあるかを確認する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `suffix` で終わる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWith('ClickHouse', 'House');
```

```response title=Response
┌─endsWith('Cl⋯', 'House')─┐
│                        1 │
└──────────────────────────┘
```

## endsWithCaseInsensitive {#endsWithCaseInsensitive}

導入バージョン: v25.9

文字列が、指定された大文字・小文字を区別しない接尾辞で終わっているかどうかを判定します。

**構文**

```sql
endsWithCaseInsensitive(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 大文字・小文字を区別せずに末尾にあるかをチェックする接尾辞。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が大文字・小文字を区別せずに見て `suffix` で終わっていれば `1` を返し、そうでなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithCaseInsensitive('ClickHouse', 'HOUSE');
```

```response title=Response
┌─endsWithCaseInsensitive('Cl⋯', 'HOUSE')─┐
│                                       1 │
└─────────────────────────────────────────┘
```

## endsWithCaseInsensitiveUTF8 {#endsWithCaseInsensitiveUTF8}

導入バージョン: v25.9

文字列 `s` が、大文字・小文字を区別せずに `suffix` で終わるかどうかを返します。
文字列は有効な UTF-8 でエンコードされたテキストであると仮定します。
この前提が満たされない場合でも、例外はスローされず、結果は未定義になります。

**構文**

```sql
endsWithCaseInsensitiveUTF8(s, suffix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 末尾に付くかどうかを大文字小文字を区別せずにチェックするサフィックス。[`String`](/sql-reference/data-types/string)

**返り値**

` s` が大文字小文字を区別せずに `suffix` で終わる場合は `1` を返し、そうでない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithCaseInsensitiveUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithCaseInsensitiveUTF8('данных', 'ых')─┐
│                                           1 │
└─────────────────────────────────────────────┘
```

## endsWithUTF8 {#endsWithUTF8}

導入されたバージョン: v23.8

文字列 `s` が `suffix` で終わるかどうかを返します。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
endsWithUTF8(s, suffix)
```

**引数**

* `s` — 確認する文字列。[`String`](/sql-reference/data-types/string)
* `suffix` — 末尾として確認する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `suffix` で終わる場合は `1` を、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT endsWithUTF8('данных', 'ых');
```

```response title=Response
┌─endsWithUTF8('данных', 'ых')─┐
│                            1 │
└──────────────────────────────┘
```

## extractTextFromHTML {#extractTextFromHTML}

導入バージョン: v21.3

HTML または XHTML からテキストコンテンツを抽出します。

この関数は HTML タグ、コメント、script/style 要素を削除し、テキストコンテンツのみを残します。次の処理を行います:

* すべての HTML/XML タグの削除
* コメント（`<!-- -->`）の削除
* script および style 要素とその内容の削除
* CDATA セクションの処理（内容をそのままコピー）
* 空白文字の適切な処理と正規化

注意: HTML エンティティはデコードされないため、必要に応じて別の関数で処理する必要があります。

**構文**

```sql
extractTextFromHTML(html)
```

**引数**

* `html` — テキストを抽出する対象の HTML コンテンツを含む文字列。[`String`](/sql-reference/data-types/string)

**返り値**

空白が正規化された抽出済みテキストコンテンツを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT extractTextFromHTML('
<html>
    <head><title>ページタイトル</title></head>
    <body>
        <p>こんにちは <b>世界</b>！</p>
        <script>alert("test");</script>
        <!-- comment -->
    </body>
</html>
');
```

```response title=Response
┌─extractTextFromHTML('<html><head>...')─┐
│ ページタイトル Hello World!                │
└────────────────────────────────────────┘
```

## firstLine {#firstLine}

導入バージョン: v23.7

複数行文字列の最初の行を返します。

**構文**

```sql
firstLine(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列の先頭行、または行区切りがない場合は文字列全体を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT firstLine('foo\\nbar\\nbaz')
```

```response title=Response
┌─firstLine('foo\nbar\nbaz')─┐
│ foo                        │
└────────────────────────────┘
```

## idnaDecode {#idnaDecode}

導入: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications)（IDNA）メカニズムに従い、ドメイン名の Unicode（UTF-8）表現（ToUnicode アルゴリズム）を返します。
エラーが発生した場合（例: 入力が不正な場合）は、入力文字列をそのまま返します。
大文字・小文字の正規化が行われるため、[`idnaEncode()`](#idnaEncode) と [`idnaDecode()`](#idnaDecode) を繰り返し適用しても、必ずしも元の文字列が得られるとは限らない点に注意してください。

**構文**

```sql
idnaDecode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

IDNA メカニズムに従い、入力文字列を Unicode (UTF-8) 表現に変換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')
```

```response title=Response
┌─idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de')─┐
│ straße.münchen.de                             │
└───────────────────────────────────────────────┘
```

## idnaEncode {#idnaEncode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications)（IDNA）メカニズムに従い、ドメイン名の ASCII 表現（ToASCII アルゴリズム）を返します。
入力文字列は UTF でエンコードされており、ASCII 文字列に変換可能である必要があります。変換できない場合は例外がスローされます。

:::note
パーセントデコードや、タブ・スペース・制御文字のトリミングは行われません。
:::

**構文**

```sql
idnaEncode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

IDNA メカニズムに従い、入力文字列の ASCII 表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT idnaEncode('straße.münchen.de')
```

```response title=Response
┌─idnaEncode('straße.münchen.de')─────┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```

## initcap {#initcap}

導入バージョン: v23.7

各単語の最初の文字を大文字にし、残りを小文字に変換します。
ここでいう単語とは、英数字が連続した部分列であり、非英数字によって区切られたシーケンスを指します。

:::note
`initcap` は各単語の最初の文字だけを大文字に変換するため、アポストロフィや大文字を含む単語では、予期しない動作が発生する場合があります。
これは既知の動作であり、現時点では修正の予定はありません。
:::

**構文**

```sql
initcap(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

各単語の先頭文字を大文字に変換した `s` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT initcap('building for fast')
```

```response title=Response
┌─initcap('building for fast')─┐
│ Building For Fast            │
└──────────────────────────────┘
```

**アポストロフィや大文字を含む単語に関する既知の挙動の例**

```sql title=Query
SELECT initcap('John''s cat won''t eat.');
```

```response title=Response
┌─initcap('Joh⋯n\'t eat.')─┐
│ John'S Cat Won'T Eat.    │
└──────────────────────────┘
```

## initcapUTF8 {#initcapUTF8}

導入バージョン: v23.7

[`initcap`](#initcap) と同様に、`initcapUTF8` は各単語の最初の文字を大文字にし、それ以外を小文字に変換します。
文字列には有効な UTF-8 エンコードのテキストが含まれていることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

:::note
この関数は言語を判別しません。たとえばトルコ語では、結果が厳密には正しくない場合があります（i/İ と i/I）。
あるコードポイントにおいて、大文字と小文字で UTF-8 のバイト列の長さが異なる場合、そのコードポイントに対する結果は正しくない可能性があります。
:::

**構文**

```sql
initcapUTF8(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

各単語の先頭の文字を大文字に変換した `s` を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT initcapUTF8('не тормозит')
```

```response title=Response
┌─initcapUTF8('не тормозит')─┐
│ Не Тормозит                │
└────────────────────────────┘
```

## isValidASCII {#isValidASCII}

導入バージョン: v25.9

入力の String または FixedString が ASCII バイト (0x00–0x7F) のみを含む場合は 1 を返し、それ以外の場合は 0 を返します。

**構文**

```sql
```

**別名**: `isASCII`

**引数**

* なし。

**戻り値**

**例**

**isValidASCII**

```sql title=Query
SELECT isValidASCII('hello') AS is_ascii, isValidASCII('你好') AS is_not_ascii
```

```response title=Response
```

## isValidUTF8 {#isValidUTF8}

導入: v20.1

バイト列が有効な UTF-8 でエンコードされたテキストかどうかを検証します。

**構文**

```sql
isValidUTF8(s)
```

**引数**

* `s` — UTF-8 エンコードが有効かどうかを検査する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

バイト列が有効な UTF-8 でエンコードされたテキストを構成していれば `1` を返し、そうでなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT isValidUTF8('\\xc3\\xb1') AS valid, isValidUTF8('\\xc3\\x28') AS invalid
```

```response title=Response
┌─valid─┬─invalid─┐
│     1 │       0 │
└───────┴─────────┘
```

## jaroSimilarity {#jaroSimilarity}

導入バージョン: v24.1

2 つのバイト文字列間の [Jaro 類似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance#Jaro_similarity) を計算します。

**構文**

```sql
jaroSimilarity(s1, s2)
```

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列の Jaro 類似度を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT jaroSimilarity('clickhouse', 'click')
```

```response title=Response
┌─jaroSimilarity('clickhouse', 'click')─┐
│                    0.8333333333333333 │
└───────────────────────────────────────┘
```

## jaroWinklerSimilarity {#jaroWinklerSimilarity}

導入バージョン: v24.1

2つのバイト列間の [Jaro-Winkler 類似度](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance) を計算します。

**構文**

```sql
jaroWinklerSimilarity(s1, s2)
```

**引数**

* `s1` — 1 番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの文字列間の Jaro-Winkler 類似度を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT jaroWinklerSimilarity('clickhouse', 'click')
```

```response title=Response
┌─jaroWinklerSimilarity('clickhouse', 'click')─┐
│                           0.8999999999999999 │
└──────────────────────────────────────────────┘
```

## left {#left}

導入バージョン: v22.1

文字列 `s` の左端から、指定した `offset` 文字を取り出した部分文字列を返します。

**構文**

```sql
left(s, offset)
```

**引数**

* `s` — 部分文字列を抽出する元の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

次を返します:

* 正の `offset` の場合、文字列の先頭から開始し、`offset` バイト分の `s` の部分文字列。
* 負の `offset` の場合、文字列の先頭から開始し、`length(s) - |offset|` バイト分の `s` の部分文字列。
* `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正のオフセット**

```sql title=Query
SELECT left('Hello World', 5)
```

```response title=Response
Helllo
```

**負のオフセット**

```sql title=Query
SELECT left('Hello World', -6)
```

```response title=Response
Hello
```

## leftPad {#leftPad}

導入バージョン: v21.8

指定された `length` に達するまで、文字列の左側をスペースまたは指定した文字列で（必要に応じて複数回）埋めます。

**構文**

```sql
leftPad(string, length[, pad_string])
```

**別名**: `lpad`

**引数**

* `string` — パディングを行う対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果となる文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 省略可。入力文字列を埋めるために使用する文字列。指定されていない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定した長さになるよう左側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT leftPad('abc', 7, '*'), leftPad('def', 7)
```

```response title=Response
┌─leftPad('abc', 7, '*')─┬─leftPad('def', 7)─┐
│ ****abc                │     def           │
└────────────────────────┴───────────────────┘
```

## leftPadUTF8 {#leftPadUTF8}

導入バージョン: v21.8

UTF8 文字列の左側を、スペースまたは指定した文字列（必要に応じて複数回）で埋めて、結果の文字列が指定された長さに達するまでパディングします。
文字列長をバイト数で測定する [`leftPad`](#leftPad) とは異なり、文字列長はコードポイント数で測定されます。

**構文**

```sql
leftPadUTF8(string, length[, pad_string])
```

**引数**

* `string` — パディングされる入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果の文字列の長さ。値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — 省略可能。入力文字列をパディングする際に使用する文字列。指定されていない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**返り値**

指定された長さの、左側がパディングされた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT leftPadUTF8('абвг', 7, '*'), leftPadUTF8('дежз', 7)
```

```response title=Response
┌─leftPadUTF8('абвг', 7, '*')─┬─leftPadUTF8('дежз', 7)─┐
│ ***абвг                     │    дежз                │
└─────────────────────────────┴────────────────────────┘
```

## leftUTF8 {#leftUTF8}

導入: v22.1

UTF-8 でエンコードされた文字列 `s` について、左側からの `offset` 文字目を開始位置とする部分文字列を返します。

**構文**

```sql
leftUTF8(s, offset)
```

**引数**

* `s` — 部分文字列を計算する対象の UTF-8 エンコードされた文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットのバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

返される値:

* 正の `offset` の場合、文字列の左端から開始し、`offset` バイト分を含む `s` の部分文字列。
* 負の `offset` の場合、文字列の左端から開始し、`length(s) - |offset|` バイト分を含む `s` の部分文字列。
* `length` が 0 の場合は空文字列。\
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT leftUTF8('Привет', 4)
```

```response title=Response
Прив
```

**負のオフセット**

```sql title=Query
SELECT leftUTF8('Привет', -4)
```

```response title=Response
Пр
```

## lengthUTF8 {#lengthUTF8}

導入バージョン: v1.1

文字列の長さを、バイト数や文字数ではなく Unicode のコードポイント数で返します。
文字列は有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合でも例外はスローされず、結果は未定義となります。

**構文**

```sql
lengthUTF8(s)
```

**別名**: `CHAR_LENGTH`, `CHARACTER_LENGTH`

**引数**

* `s` — 有効な UTF-8 でエンコードされたテキストを含む文字列。[`String`](/sql-reference/data-types/string)

**返される値**

文字列 `s` の Unicode コードポイント数。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT lengthUTF8('こんにちは、世界！')
```

```response title=Response
┌─lengthUTF8('Здравствуй, мир!')─┐
│                             16 │
└────────────────────────────────┘
```

## lower {#lower}

導入バージョン: v1.1

ASCII 文字列を小文字に変換します。

**構文**

```sql
lower(s)
```

**別名**: `lcase`

**引数**

* `s` — 小文字に変換する対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` を小文字に変換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT lower('CLICKHOUSE')
```

```response title=Response
┌─lower('CLICKHOUSE')─┐
│ clickhouse          │
└─────────────────────┘
```

## lowerUTF8 {#lowerUTF8}

導入バージョン: v1.1

文字列が有効な UTF-8 でエンコードされたテキストであると想定して、その文字列を小文字に変換します。この前提が満たされていない場合でも、例外はスローされず、結果は未定義になります。

**構文**

```sql
lowerUTF8(input)
```

**引数**

* `input` — 小文字に変換する入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

小文字に変換された文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**最初の例**

```sql title=Query
SELECT lowerUTF8('München') as Lowerutf8;
```

```response title=Response
münchen
```

## normalizeUTF8NFC {#normalizeUTF8NFC}

導入バージョン: v21.11

UTF-8 文字列を [正規化形式 NFC](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って正規化します。

**構文**

```sql
normalizeUTF8NFC(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**返される値**

UTF-8 文字列の NFC 正規化形式を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
'é' AS original, -- e + 結合鋭アクセント記号 (U+0065 + U+0301)
length(original),
normalizeUTF8NFC('é') AS nfc_normalized, -- é (U+00E9)
length(nfc_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfc_normalized─┬─length(nfc_normalized)─┐
│ é        │                2 │ é              │                      2 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```

## normalizeUTF8NFD {#normalizeUTF8NFD}

導入バージョン: v21.11

UTF-8 文字列を[NFD 正規化形式](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)に従って正規化します。

**構文**

```sql
normalizeUTF8NFD(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8 文字列を NFD 正規化形式にしたものを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    'é' AS original, -- é (U+00E9)
    length(original),
    normalizeUTF8NFD('é') AS nfd_normalized, -- e + 結合アキュート符号 (U+0065 + U+0301)
    length(nfd_normalized);
```

```response title=Response
┌─original─┬─length(original)─┬─nfd_normalized─┬─length(nfd_normalized)─┐
│ é        │                2 │ é              │                      3 │
└──────────┴──────────────────┴────────────────┴────────────────────────┘
```

## normalizeUTF8NFKC {#normalizeUTF8NFKC}

導入バージョン: v21.11

[正規化形式 NFKC](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って UTF-8 文字列を正規化します。

**構文**

```sql
normalizeUTF8NFKC(str)
```

**引数**

* `str` — UTF-8 でエンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8 文字列を NFKC 正規化形式にしたものを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    '① ② ③' AS original,                            -- 丸囲み数字
    normalizeUTF8NFKC('① ② ③') AS nfkc_normalized;  -- 1 2 3 に変換する
```

```response title=Response
┌─original─┬─nfkc_normalized─┐
│ ① ② ③  │ 1 2 3           │
└──────────┴─────────────────┘
```

## normalizeUTF8NFKD {#normalizeUTF8NFKD}

導入バージョン: v21.11

[正規化形式 NFKD](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms) に従って UTF-8 文字列を正規化します。

**構文**

```sql
normalizeUTF8NFKD(str)
```

**引数**

* `str` — UTF-8 エンコードされた入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

UTF-8 文字列を NFKD 形式に正規化したものを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    'H₂O²' AS original,                            -- H + 下付き文字 2 + O + 上付き文字 2
    normalizeUTF8NFKD('H₂O²') AS nfkd_normalized;  -- H 2 O 2 に変換される
```

```response title=Response
┌─original─┬─nfkd_normalized─┐
│ H₂O²     │ H2O2            │
└──────────┴─────────────────┘
```

## punycodeDecode {#punycodeDecode}

導入バージョン: v24.1

[Punycode](https://en.wikipedia.org/wiki/Punycode) でエンコードされた文字列を UTF-8 にデコードしたプレーンテキストを返します。
有効な Punycode エンコード文字列が指定されない場合は、例外をスローします。

**構文**

```sql
punycodeDecode(s)
```

**引数**

* `s` — Punycode でエンコードされた文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値のプレーンテキスト表現を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT punycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─punycodeDecode('Mnchen-3ya')─┐
│ München                      │
└──────────────────────────────┘
```

## punycodeEncode {#punycodeEncode}

導入バージョン: v24.1

文字列の [Punycode](https://en.wikipedia.org/wiki/Punycode) 表現を返します。
文字列は UTF-8 でエンコードされたものである必要があり、そうでない場合の動作は未定義です。

**構文**

```sql
punycodeEncode(s)
```

**引数**

* `s` — 入力値。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値を Punycode 表現で返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT punycodeEncode('München')
```

```response title=Response
┌─punycodeEncode('München')─┐
│ Mnchen-3ya                │
└───────────────────────────┘
```

## regexpExtract {#regexpExtract}

導入バージョン: v23.2

`haystack` 内で、正規表現パターンにマッチし、指定されたグループ番号に対応する、最初に一致した文字列を抽出します。

**構文**

```sql
regexpExtract(haystack, pattern[, index])
```

**別名**: `REGEXP_EXTRACT`

**引数**

* `haystack` — 正規表現パターンとマッチさせる文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現文字列。`pattern` は複数の正規表現グループを含むことができ、`index` はどの正規表現グループを抽出するかを示します。インデックス 0 は正規表現全体へのマッチを意味します。[`const String`](/sql-reference/data-types/string)
* `index` — 省略可能。デフォルト値 1 の 0 以上の整数。どの正規表現グループを抽出するかを表します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

マッチした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT
    regexpExtract('100-200', '(\\d+)-(\\d+)', 1),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 2),
    regexpExtract('100-200', '(\\d+)-(\\d+)', 0),
    regexpExtract('100-200', '(\\d+)-(\\d+)');
```

```response title=Response
┌─regexpExtract('100-200', '(\\d+)-(\\d+)', 1)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 2)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)', 0)─┬─regexpExtract('100-200', '(\\d+)-(\\d+)')─┐
│ 100                                          │ 200                                          │ 100-200                                      │ 100                                       │
└──────────────────────────────────────────────┴──────────────────────────────────────────────┴──────────────────────────────────────────────┴───────────────────────────────────────────┘
```

## repeat {#repeat}

導入: v20.1

指定された回数だけ文字列を繰り返して連結します。

**構文**

```sql
repeat(s, n)
```

**引数**

* `s` — 繰り返す対象の文字列。[`String`](/sql-reference/data-types/string)
* `n` — 文字列を繰り返す回数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

文字列 `s` を `n` 回繰り返した文字列。`n` が負の値の場合、この関数は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT repeat('abc', 10)
```

```response title=Response
┌─repeat('abc', 10)──────────────┐
│ abcabcabcabcabcabcabcabcabcabc │
└────────────────────────────────┘
```

## reverseUTF8 {#reverseUTF8}

導入バージョン: v1.1

文字列内の Unicode コードポイント列を逆順に並べ替えます。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が成り立たない場合でも例外はスローされず、結果は未定義です。

**構文**

```sql
reverseUTF8(s)
```

**引数**

* `s` — 有効な UTF-8 でエンコードされたテキストを含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

Unicode コードポイント列の順序を反転した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT reverseUTF8('ClickHouse')
```

```response title=Response
esuoHkcilC
```

## right {#right}

導入バージョン: v22.1

文字列 `s` の末尾から指定した `offset` 文字の部分文字列を返します。

**構文**

```sql
right(s, offset)
```

**引数**

* `s` — 部分文字列を取得する対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットとなるバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返り値**

返り値:

* 正の `offset` の場合、文字列の右端から `offset` バイト分を切り出した `s` の部分文字列。
* 負の `offset` の場合、文字列の右端から `length(s) - |offset|` バイト分を切り出した `s` の部分文字列。
* `length` が `0` の場合は空文字列。
  [`String`](/sql-reference/data-types/string)

**例**

**正の offset**

```sql title=Query
SELECT right('Hello', 3)
```

```response title=Response
llo
```

**負のオフセット**

```sql title=Query
SELECT right('Hello', -3)
```

```response title=Response
lo
```

## rightPad {#rightPad}

導入バージョン: v21.8

文字列の右側をスペースまたは指定した文字列（必要に応じて繰り返し）で埋め、結果の文字列が指定された `length` に達するまでパディングします。

**構文**

```sql
rightPad(string, length[, pad_string])
```

**エイリアス**: `rpad`

**引数**

* `string` — パディング対象の入力文字列。 [`String`](/sql-reference/data-types/string)
* `length` — 結果となる文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — オプション。入力文字列をパディングする際に使用する文字列。指定しない場合、入力文字列は空白文字で埋められます。 [`String`](/sql-reference/data-types/string)

**戻り値**

指定した長さになるように右側を埋めた文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT rightPad('abc', 7, '*'), rightPad('abc', 7)
```

```response title=Response
┌─rightPad('abc', 7, '*')─┬─rightPad('abc', 7)─┐
│ abc****                 │ abc                │
└─────────────────────────┴────────────────────┘
```

## rightPadUTF8 {#rightPadUTF8}

導入: v21.8

文字列の右側を、結果の文字列が指定された長さに達するまで、スペースまたは指定した文字列（必要に応じて複数回）で埋めます。
文字列の長さをバイト数で測定する [`rightPad`](#rightPad) とは異なり、この関数では文字列の長さはコードポイント数で測定されます。

**構文**

```sql
rightPadUTF8(string, length[, pad_string])
```

**引数**

* `string` — パディング対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `length` — 結果となる文字列の長さ。この値が入力文字列の長さより小さい場合、入力文字列は `length` 文字に切り詰められます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `pad_string` — オプション。入力文字列をパディングする際に用いる文字列。指定されていない場合、入力文字列はスペースでパディングされます。[`String`](/sql-reference/data-types/string)

**返される値**

指定された長さになるように右側をパディングした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT rightPadUTF8('абвг', 7, '*'), rightPadUTF8('абвг', 7)
```

```response title=Response
┌─rightPadUTF8('абвг', 7, '*')─┬─rightPadUTF8('абвг', 7)─┐
│ абвг***                      │ абвг                    │
└──────────────────────────────┴─────────────────────────┘
```

## rightUTF8 {#rightUTF8}

導入バージョン: v22.1

UTF-8 エンコードされた文字列 `s` に対して、右端から `offset` 文字の部分文字列を返します。

**構文**

```sql
rightUTF8(s, offset)
```

**引数**

* `s` — 部分文字列を計算する対象の UTF-8 エンコードされた文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` — オフセットを表すバイト数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

返される値:

* 正の `offset` の場合、文字列の右端から始まる、長さ `offset` バイトの `s` の部分文字列。
* 負の `offset` の場合、文字列の右端から始まる、長さ `length(s) - |offset|` バイトの `s` の部分文字列。
* `length` が `0` の場合は空文字列。\
  戻り値の型: [`String`](/sql-reference/data-types/string)

**例**

**正のオフセット**

```sql title=Query
SELECT rightUTF8('Привет', 4)
```

```response title=Response
ивет
```

**負のオフセット**

```sql title=Query
SELECT rightUTF8('Привет', -4)
```

```response title=Response
ет
```

## soundex {#soundex}

導入バージョン: v23.4

文字列の [Soundex コード](https://en.wikipedia.org/wiki/Soundex) を返します。

**構文**

```sql
soundex(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力文字列の Soundex コードを返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT soundex('aksel')
```

```response title=Response
┌─soundex('aksel')─┐
│ A240             │
└──────────────────┘
```

## space {#space}

導入バージョン: v23.5

指定された回数だけ空白文字（` `）を連結した文字列を返します。

**構文**

```sql
space(n)
```

**引数**

* `n` — スペースを繰り返す回数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

スペースを `n` 回繰り返した文字列を返します。`n <= 0` の場合、関数は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT space(3) AS res, length(res);
```

```response title=Response
┌─res─┬─length(res)─┐
│     │           3 │
└─────┴─────────────┘
```

## sparseGrams {#sparseGrams}

導入バージョン: v25.5

長さが少なくとも `n` であり、かつ次の条件を満たす、指定された文字列中のすべての部分文字列を検出します。
その部分文字列の両端に位置する (n-1)-グラムのハッシュ値が、
その部分文字列の内部に含まれるどの (n-1)-グラムのハッシュ値よりも大きい場合にのみ対象とします。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGrams(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される ngram の最小長。既定値かつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される ngram の最大長。既定値は 100。`min_ngram_length` 以上である必要がある。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGrams('alice', 3)
```

```response title=Response
┌─sparseGrams('alice', 3)────────────┐
│ ['ali','lic','lice','ice']         │
└────────────────────────────────────┘
```

## sparseGramsHashes {#sparseGramsHashes}

導入バージョン: v25.5

与えられた文字列について、長さが少なくとも `n` のすべての部分文字列のハッシュ値を求めます。
このとき、その部分文字列の両端にある (n-1)-gram のハッシュ値が、
その部分文字列内に含まれるいずれの (n-1)-gram のハッシュ値よりも厳密に大きいもののみを対象とします。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsHashes(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される n-gram の最小長。既定値かつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される n-gram の最大長。既定値は 100。`min_ngram_length` 以上である必要がある。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

選択された部分文字列の CRC32 ハッシュ値を要素とする配列を返す。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsHashes('alice', 3)
```

```response title=Response
┌─sparseGramsHashes('alice', 3)──────────────────────┐
│ [1481062250,2450405249,4012725991,1918774096]      │
└────────────────────────────────────────────────────┘
```

## sparseGramsHashesUTF8 {#sparseGramsHashesUTF8}

導入バージョン: v25.5

指定された UTF-8 文字列について、長さが少なくとも `n` のすべての部分文字列のハッシュを求めます。このとき、その部分文字列の両端にある (n-1)-gram のハッシュ値が、その部分文字列内部に含まれるどの (n-1)-gram のハッシュ値よりも厳密に大きいものだけを対象とします。
入力は UTF-8 文字列であることを前提としており、不正な UTF-8 シーケンスが含まれている場合は例外をスローします。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsHashesUTF8(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される ngram の最小長。デフォルト値かつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される ngram の最大長。デフォルト値は 100。`min_ngram_length` 以上でなければならない。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

抽出された UTF-8 部分文字列の CRC32 ハッシュの配列を返します。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsHashesUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsHashesUTF8('алиса', 3)─┐
│ [4178533925,3855635300,561830861] │
└───────────────────────────────────┘
```

## sparseGramsUTF8 {#sparseGramsUTF8}

導入バージョン: v25.5

与えられた UTF-8 文字列について、長さが少なくとも `n` であり、かつその部分文字列の両端にある (n-1)-gram のハッシュ値が、その部分文字列内のどの (n-1)-gram のハッシュ値よりも厳密に大きいような、すべての部分文字列を求めます。
UTF-8 文字列を引数に取り、無効な UTF-8 シーケンスが含まれている場合は例外をスローします。
ハッシュ関数として `CRC32` を使用します。

**構文**

```sql
sparseGramsUTF8(s[, min_ngram_length, max_ngram_length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `min_ngram_length` — 省略可能。抽出される n-gram の長さの最小値。デフォルトかつ最小値は 3。[`UInt*`](/sql-reference/data-types/int-uint)
* `max_ngram_length` — 省略可能。抽出される n-gram の長さの最大値。デフォルト値は 100。`min_ngram_length` 以上である必要がある。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

選択された UTF-8 部分文字列の配列を返す。[`Array(String)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sparseGramsUTF8('алиса', 3)
```

```response title=Response
┌─sparseGramsUTF8('алиса', 3)─┐
│ ['али','лис','иса']         │
└─────────────────────────────┘
```

## startsWith {#startsWith}

導入バージョン: v1.1

文字列が指定した文字列で始まるかどうかを判定します。

**構文**

```sql
startsWith(s, prefix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — `s` の先頭にあるかを確認するプレフィックス文字列。[`String`](/sql-reference/data-types/string)

**返される値**

`s` が `prefix` で始まる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWith('ClickHouse', 'Click');
```

```response title=Response
┌─startsWith('⋯', 'Click')─┐
│                        1 │
└──────────────────────────┘
```

## startsWithCaseInsensitive {#startsWithCaseInsensitive}

導入バージョン: v25.9

文字列が、指定された文字列で大文字小文字を区別せずに始まるかどうかを判定します。

**構文**

```sql
startsWithCaseInsensitive(s, prefix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — 大文字小文字を区別せずにチェックするプレフィックス文字列。[`String`](/sql-reference/data-types/string)

**返される値**

`s` が大文字小文字を区別せずに `prefix` で始まる場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithCaseInsensitive('ClickHouse', 'CLICK');
```

```response title=Response
┌─startsWithCaseInsensitive('⋯', 'CLICK')─┐
│                                       1 │
└─────────────────────────────────────────┘
```

## startsWithCaseInsensitiveUTF8 {#startsWithCaseInsensitiveUTF8}

導入バージョン: v25.9

文字列が、指定された大文字小文字を区別しない接頭辞で始まるかどうかを判定します。
文字列には、有効な UTF-8 でエンコードされたテキストが含まれていることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
startsWithCaseInsensitiveUTF8(s, prefix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — 大文字・小文字を区別せずに先頭一致を判定するプレフィックス文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が大文字・小文字を区別せずに `prefix` で始まる場合は `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithCaseInsensitiveUTF8('приставка', 'при')
```

```response title=Response
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```

## startsWithUTF8 {#startsWithUTF8}

導入バージョン: v23.8

文字列が指定されたプレフィックスで始まるかどうかをチェックします。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
startsWithUTF8(s, prefix)
```

**引数**

* `s` — チェック対象の文字列。[`String`](/sql-reference/data-types/string)
* `prefix` — `s` の先頭に存在するかを確認するプレフィックス。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` が `prefix` で始まる場合は `1`、それ以外は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT startsWithUTF8('приставка', 'при')
```

```response title=Response
┌─startsWithUT⋯ка', 'при')─┐
│                        1 │
└──────────────────────────┘
```

## stringBytesEntropy {#stringBytesEntropy}

導入バージョン: v25.6

文字列内のバイト分布に対するシャノンのエントロピーを計算します。

**構文**

```sql
stringBytesEntropy(s)
```

**引数**

* `s` — 解析する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列中のバイト分布に対するシャノンエントロピーを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringBytesEntropy('Hello, world!')
```

```response title=Response
┌─stringBytesEntropy('Hello, world!')─┐
│                         3.07049960  │
└─────────────────────────────────────┘
```

## stringBytesUniq {#stringBytesUniq}

導入されたバージョン: v25.6

文字列内の異なるバイト数をカウントします。

**構文**

```sql
stringBytesUniq(s)
```

**引数**

* `s` — 解析する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列内の相異なるバイト数を返します。[`UInt16`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT stringBytesUniq('Hello')
```

```response title=Response
┌─stringBytesUniq('Hello')─┐
│                        4 │
└──────────────────────────┘
```

## stringJaccardIndex {#stringJaccardIndex}

導入バージョン: v23.11

2 つのバイト列間の [Jaccard 係数](https://en.wikipedia.org/wiki/Jaccard_index) を計算します。

**構文**

```sql
stringJaccardIndex(s1, s2)
```

**引数**

* `s1` — 1番目の入力文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2番目の入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の Jaccard 類似度インデックスを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringJaccardIndex('clickhouse', 'mouse')
```

```response title=Response
┌─stringJaccardIndex('clickhouse', 'mouse')─┐
│                                       0.4 │
└───────────────────────────────────────────┘
```

## stringJaccardIndexUTF8 {#stringJaccardIndexUTF8}

導入バージョン: v23.11

[`stringJaccardIndex`](#stringJaccardIndex) と同様ですが、UTF-8 でエンコードされた文字列を対象とします。

**構文**

```sql
stringJaccardIndexUTF8(s1, s2)
```

**引数**

* `s1` — 1 つ目の入力 UTF8 文字列。[`String`](/sql-reference/data-types/string)
* `s2` — 2 つ目の入力 UTF8 文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2 つの UTF8 文字列間の Jaccard 類似度インデックスを返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT stringJaccardIndexUTF8('我爱你', '我也爱你')
```

```response title=Response
┌─stringJaccardIndexUTF8('我爱你', '我也爱你')─┐
│                                       0.75 │
└─────────────────────────────────────────────┘
```

## substring {#substring}

導入バージョン: v1.1

文字列 `s` のうち、指定されたバイトインデックス `offset` から始まる部分文字列を返します。
バイトのカウントは 1 から始まり、次の仕様に従います：

* `offset` が `0` の場合、空文字列が返されます。
* `offset` が負の場合、部分文字列は先頭からではなく、文字列の末尾から `pos` 文字分手前の位置から始まります。

オプション引数 `length` は、返される部分文字列が持つことのできる最大バイト数を指定します。

**構文**

```sql
substring(s, offset[, length])
```

**別名**: `byteSlice`, `mid`, `substr`

**引数**

* `s` — 部分文字列を取得する元の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Enum`](/sql-reference/data-types/enum)
* `offset` — `s` の中で部分文字列を開始する位置。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 省略可能。部分文字列の最大バイト長。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

`offset` で指定した位置から `length` バイト分の `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な使い方**

```sql title=Query
SELECT 'database' AS db, substr(db, 5), substr(db, 5, 1)
```

```response title=Response
┌─db───────┬─substring('database', 5)─┬─substring('database', 5, 1)─┐
│ database │ base                     │ b                           │
└──────────┴──────────────────────────┴─────────────────────────────┘
```

## substringIndex {#substringIndex}

導入バージョン: v23.7

Spark や MySQL と同様に、区切り文字 `delim` が `count` 回現れるより前の部分文字列を、文字列 `s` から返します。

**構文**

```sql
substringIndex(s, delim, count)
```

**別名**: `SUBSTRING_INDEX`

**引数**

* `s` — 部分文字列を抽出する対象の文字列。[`String`](/sql-reference/data-types/string)
* `delim` — 分割に使用する区切り文字。[`String`](/sql-reference/data-types/string)
* `count` — 部分文字列を抽出する前にカウントする区切り文字の出現回数。`count` が正の場合は、左から数えて `count` 個目の区切り文字より左側のすべてが返されます。`count` が負の場合は、右から数えて `|count|` 個目の区切り文字より右側のすべてが返されます。[`UInt`](/sql-reference/data-types/int-uint) または [`Int`](/sql-reference/data-types/int-uint)

**返される値**

`delim` が `count` 回出現する位置より前の `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT substringIndex('www.clickhouse.com', '.', 2)
```

```response title=Response
┌─substringIndex('www.clickhouse.com', '.', 2)─┐
│ www.clickhouse                               │
└──────────────────────────────────────────────┘
```

## substringIndexUTF8 {#substringIndexUTF8}

導入バージョン: v23.7

Unicode コードポイント単位で、区切り文字 `delim` が `count` 回出現するまでの `s` の部分文字列を返します。
文字列が有効な UTF-8 エンコードのテキストであることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
substringIndexUTF8(s, delim, count)
```

**引数**

* `s` — 部分文字列を抽出する元の文字列。[`String`](/sql-reference/data-types/string)
* `delim` — 分割に使用する区切り文字。[`String`](/sql-reference/data-types/string)
* `count` — 部分文字列を抽出する前にカウントする区切り文字の出現回数。`count` が正の値の場合は、（左から数えて）最後の区切り文字より左側のすべてが返されます。`count` が負の値の場合は、（右から数えて）最後の区切り文字より右側のすべてが返されます。[`UInt`](/sql-reference/data-types/int-uint) または [`Int`](/sql-reference/data-types/int-uint)

**戻り値**

`delim` が `count` 回出現する位置より前にある `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**使用例**

**UTF8 の例**

```sql title=Query
SELECT substringIndexUTF8('www.straßen-in-europa.de', '.', 2)
```

```response title=Response
www.straßen-in-europa
```

## substringUTF8 {#substringUTF8}

導入バージョン: v1.1

Unicode コードポイントを基準として、文字列 `s` のうち、指定したバイトインデックス `offset` から始まる部分文字列を返します。
バイトのカウントは次のルールで `1` から始まります。

* `offset` が `0` の場合は、空文字列を返します。
* `offset` が負の場合、部分文字列は先頭からではなく、文字列の末尾から `pos` 文字目を開始位置として始まります。

省略可能な引数 `length` は、返される部分文字列が持つことのできる最大バイト数を指定します。

:::note
この関数は、文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされていない場合でも、例外はスローされず、結果は未定義となります。
:::

**構文**

```sql
substringUTF8(s, offset[, length])
```

**引数**

* `s` — 部分文字列を取得する対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Enum`](/sql-reference/data-types/enum)
* `offset` — `s` 内での部分文字列の開始位置。[`Int`](/sql-reference/data-types/int-uint) または [`UInt`](/sql-reference/data-types/int-uint)
* `length` — 部分文字列の最大長。省略可能。[`Int`](/sql-reference/data-types/int-uint) または [`UInt`](/sql-reference/data-types/int-uint)

**返される値**

インデックス `offset` から開始し、最大 `length` バイトの `s` の部分文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT 'Täglich grüßt das Murmeltier.' AS str, substringUTF8(str, 9), substringUTF8(str, 9, 5)
```

```response title=Response
Täglich grüßt das Murmeltier.    grüßt das Murmeltier.    grüßt
```

## toValidUTF8 {#toValidUTF8}

導入バージョン: v20.1

文字列内の無効な UTF-8 文字を、置換文字 `�` (U+FFFD) に置き換えることで、有効な UTF-8 エンコーディングに変換します。
連続する複数の無効な文字が見つかった場合は、1 つの置換文字にまとめられます。

**構文**

```sql
toValidUTF8(s)
```

**引数**

* `s` — String データ型オブジェクトとして表される任意のバイト列。[`String`](/sql-reference/data-types/string)

**戻り値**

有効な UTF-8 文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT toValidUTF8('\\x61\\xF0\\x80\\x80\\x80b')
```

```response title=Response
c
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```

## trimBoth {#trimBoth}

v20.1 で導入

文字列の先頭および末尾から、指定した文字を削除します。
デフォルトでは、一般的な空白（ASCII）文字を削除します。

**構文**

```sql
trimBoth(s[, trim_characters])
```

**エイリアス**: `trim`

**引数**

* `s` — トリミングする文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 省略可。トリミング対象の文字集合。指定しない場合は、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

両端から指定された文字を取り除いた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimBoth('$$ClickHouse$$', '$')
```

```response title=Response
┌─trimBoth('$$⋯se$$', '$')─┐
│ ClickHouse               │
└──────────────────────────┘
```

## trimLeft {#trimLeft}

導入バージョン: v20.1

文字列の先頭から指定した文字を削除します。
既定では、一般的な空白（ASCII）文字を削除します。

**構文**

```sql
trimLeft(input[, trim_characters])
```

**別名**: `ltrim`

**引数**

* `input` — トリミング対象の文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 省略可能。トリミングする文字。指定されていない場合は、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

先頭（左側）から指定した文字をトリミングした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimLeft('ClickHouse', 'Click');
```

```response title=Response
┌─trimLeft('Cl⋯', 'Click')─┐
│ House                    │
└──────────────────────────┘
```

## trimRight {#trimRight}

導入バージョン: v20.1

文字列の末尾から指定した文字を削除します。
デフォルトでは、一般的な ASCII の空白文字を削除します。

**構文**

```sql
trimRight(s[, trim_characters])
```

**別名**: `rtrim`

**引数**

* `s` — トリム対象の文字列。[`String`](/sql-reference/data-types/string)
* `trim_characters` — 省略可能なトリム対象の文字列。指定しない場合、一般的な空白文字が削除されます。[`String`](/sql-reference/data-types/string)

**戻り値**

指定された文字を右端からトリムした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT trimRight('ClickHouse','House');
```

```response title=Response
┌─trimRight('C⋯', 'House')─┐
│ Click                    │
└──────────────────────────┘
```

## tryBase32Decode {#tryBase32Decode}

導入バージョン: v25.6

文字列を受け取り、[Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) エンコード方式でデコードします。

**構文**

```sql
tryBase32Decode(encoded)
```

**引数**

* `encoded` — デコードする文字列型の列または定数。有効な Base32 でエンコードされた文字列でない場合、エラー時には空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase32Decode('IVXGG33EMVSA====');
```

```response title=Response
┌─tryBase32Decode('IVXGG33EMVSA====')─┐
│ エンコード済み                        │
└─────────────────────────────────────┘
```

## tryBase58Decode {#tryBase58Decode}

導入バージョン: v22.10

[`base58Decode`](#base58Decode) と同様ですが、エラーが発生した場合は空文字列を返します。

**構文**

```sql
tryBase58Decode(encoded)
```

**引数**

* `encoded` — 文字列型カラムまたは定数。文字列が有効な Base58 エンコードでない場合、エラーが発生したときは空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数の値をデコードした結果を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase58Decode('3dc8KtHrwM') AS res, tryBase58Decode('invalid') AS res_invalid;
```

```response title=Response
┌─res─────┬─res_invalid─┐
│ エンコード済み │             │
└─────────┴─────────────┘
```

## tryBase64Decode {#tryBase64Decode}

導入バージョン: v18.16

[`base64Decode`](#base64Decode) と同様ですが、エラー時には空文字列を返します。

**構文**

```sql
tryBase64Decode(encoded)
```

**引数**

* `encoded` — デコード対象の文字列カラムまたは定数。文字列が有効な Base64 エンコードでない場合、エラー時は空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした値を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase64Decode('Y2xpY2tob3VzZQ==')
```

```response title=Response
┌─tryBase64Decode('Y2xpY2tob3VzZQ==')─┐
│ clickhouse                          │
└─────────────────────────────────────┘
```

## tryBase64URLDecode {#tryBase64URLDecode}

導入バージョン: v18.16

[`base64URLDecode`](#base64URLDecode) と同様ですが、エラーの場合は空文字列を返します。

**構文**

```sql
tryBase64URLDecode(encoded)
```

**引数**

* `encoded` — デコードする文字列カラムまたは定数。文字列が有効な Base64 エンコード文字列でない場合、エラー時には空文字列を返します。[`String`](/sql-reference/data-types/string)

**戻り値**

引数をデコードした結果を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')
```

```response title=Response
┌─tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')─┐
│ https://clickhouse.com                               │
└──────────────────────────────────────────────────────┘
```

## tryIdnaEncode {#tryIdnaEncode}

導入バージョン: v24.1

[Internationalized Domain Names in Applications](https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications)（IDNA）メカニズムに従い、ドメイン名の Unicode（UTF-8）表現（ToUnicode アルゴリズム）を返します。
エラー発生時は、例外をスローする代わりに空文字列を返します。

**構文**

```sql
tryIdnaEncode(s)
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値に対する IDNA メカニズムに従い、入力文字列の ASCII 表現を返します。入力が無効な場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryIdnaEncode('straße.münchen.de')
```

```response title=Response
┌─tryIdnaEncode('straße.münchen.de')──┐
│ xn--strae-oqa.xn--mnchen-3ya.de     │
└─────────────────────────────────────┘
```

## tryPunycodeDecode {#tryPunycodeDecode}

導入バージョン: v24.1

`punycodeDecode` と同様ですが、有効な Punycode でエンコードされた文字列が指定されなかった場合は空文字列を返します。

**構文**

```sql
tryPunycodeDecode(s)
```

**引数**

* `s` — Punycode でエンコードされた文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

入力値のプレーンテキストを返します。入力が無効な場合は空文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT tryPunycodeDecode('Mnchen-3ya')
```

```response title=Response
┌─tryPunycodeDecode('Mnchen-3ya')─┐
│ München                         │
└─────────────────────────────────┘
```

## upper {#upper}

導入バージョン: v1.1

文字列内の ASCII ラテン文字を大文字に変換します。

**構文**

```sql
upper(s)
```

**エイリアス**: `ucase`

**引数**

* `s` — 大文字に変換する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`s` を大文字に変換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT upper('clickhouse')
```

```response title=Response
┌─upper('clickhouse')─┐
│ CLICKHOUSE          │
└─────────────────────┘
```

## upperUTF8 {#upperUTF8}

導入されたバージョン: v1.1

文字列が有効な UTF-8 でエンコードされたテキストであると仮定して、その文字列を大文字に変換します。
この仮定に反する場合でも、例外はスローされず、結果は未定義です。

:::note
この関数は言語を判別しません。たとえばトルコ語では結果が厳密に正しくない場合があります（i/İ と i/I など）。
あるコードポイントについて、大文字と小文字で UTF-8 のバイト列の長さが異なる場合（`ẞ` と `ß` など）、そのコードポイントに対する結果は正しくない可能性があります。
:::

**構文**

```sql
upperUTF8(s)
```

**引数**

* `s` — 文字列型。[`String`](/sql-reference/data-types/string)

**戻り値**

`String` データ型の値。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT upperUTF8('München') AS Upperutf8
```

```response title=Response
┌─Upperutf8─┐
│ MÜNCHEN   │
└───────────┘
```

{/*AUTOGENERATED_END*/ }

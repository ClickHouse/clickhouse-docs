---
'description': 'Arithmetic Functions に関する Documentation'
'sidebar_label': 'Arithmetic'
'slug': '/sql-reference/functions/arithmetic-functions'
'title': '算術関数'
'doc_type': 'reference'
---


# 算術関数

## 概要 {#overview}

算術関数は、`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64`、`Float32`、または `Float64` の任意の2つのオペランドで動作します。

操作を実行する前に、両方のオペランドは結果型にキャストされます。結果型は以下のように決定されます（以下の関数ドキュメントで別途指定されていない限り）：
- 両方のオペランドが32ビット幅までの場合、結果型のサイズは、2つのオペランドのうちの大きい方の次に大きい型のサイズになります（整数サイズの昇格）。例えば `UInt8 + UInt16 = UInt32` または `Float32 * Float32 = Float64` です。
- オペランドの1つが64ビット以上の場合、結果型のサイズは2つのオペランドのうちの大きい方と同じサイズになります。例えば `UInt32 + UInt128 = UInt128` または `Float32 * Float64 = Float64` です。
- オペランドの1つが符号付きの場合、結果型も符号付きになります。そうでない場合は符号なしになります。例えば `UInt32 * Int32 = Int64` です。

これらのルールは、結果型がすべての可能な結果を表現できる最小の型になることを保証します。このことは、値の範囲境界周辺でのオーバーフローのリスクを導入しますが、計算が最大のネイティブ整数幅64ビットを使用して迅速に行われることを保証します。この動作はまた、64ビット整数（BIGINT）を最も大きな整数型として提供する他の多くのデータベースとの互換性を保証します。

例：

```sql
SELECT toTypeName(0), toTypeName(0 + 0), toTypeName(0 + 0 + 0), toTypeName(0 + 0 + 0 + 0)
```

```text
┌─toTypeName(0)─┬─toTypeName(plus(0, 0))─┬─toTypeName(plus(plus(0, 0), 0))─┬─toTypeName(plus(plus(plus(0, 0), 0), 0))─┐
│ UInt8         │ UInt16                 │ UInt32                          │ UInt64                                   │
└───────────────┴────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┘
```

オーバーフローはC++と同じ方法で発生します。

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## abs {#abs}

導入時期: v1.1

`x`の絶対値を計算します。`x`が符号なし型である場合、効果はありません。`x`が符号付き型である場合、符号なしの数を返します。

**構文**

```sql
abs(x)
```

**引数**

- `x` — 絶対値を取得する値 

**返される値**

`x`の絶対値

**例**

**使用例**

```sql title=Query
SELECT abs(-0.5)
```

```response title=Response
0.5
```




## byteSwap {#byteSwap}

導入時期: v23.10

整数のバイトを逆順にします。つまり、その [エンディアン](https://en.wikipedia.org/wiki/Endianness) を変更します。

以下の例は次のように計算できます：

1. 10進数の整数をビッグエンディアン形式の16進数に変換します。例： 3351772109 -> C7 C7 FB CD (4バイト)
2. バイトを逆にします。例： C7 C7 FB CD -> CD FB C7 C7
3. 結果をビッグエンディアンと仮定して整数に戻します。例： CD FB C7 C7 -> 3455829959
この関数の使用例は、IPv4を逆転させることです：

```result
┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
│ 199.199.251.205                                       │
└───────────────────────────────────────────────────────┘
```
    

**構文**

```sql
byteSwap(x)
```

**引数**

- `x` — 整数値。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**返される値**

バイトを逆にした `x` を返します。 [`(U)Int*`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**8ビット**

```sql title=Query
SELECT byteSwap(54)
```

```response title=Response
54
```

**16ビット**

```sql title=Query
SELECT byteSwap(4135)
```

```response title=Response
10000
```

**32ビット**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**64ビット**

```sql title=Query
SELECT byteSwap(123294967295)
```

```response title=Response
18439412204227788800
```



## divide {#divide}

導入時期: v1.1

`a`と`b`の2つの値の商を計算します。結果の型は常に [Float64](/sql-reference/data-types/float) です。整数の除算は `intDiv` 関数によって提供されます。

:::note
`0` で割ると `inf`、 `-inf`、または `nan` を返します。
:::
    

**構文**

```sql
divide(x, y)
```

**引数**

- `x` — 被除数 - `y` — 除数 

**返される値**

`x` と `y` の商

**例**

**2つの数値の割り算**

```sql title=Query
SELECT divide(25,5) AS quotient, toTypeName(quotient)
```

```response title=Response
5 Float64
```

**0で割り算**

```sql title=Query
SELECT divide(25,0)
```

```response title=Response
inf
```



## divideDecimal {#divideDecimal}

導入時期: v22.12


2つの小数を除算します。結果の値の型は [Decimal256](/sql-reference/data-types/decimal) になります。結果スケールは `result_scale` 引数で明示的に指定することができます（範囲 `[0, 76]` の定数整数）。指定しない場合、結果のスケールは与えられた引数の最大スケールになります。

:::note
これらの関数は通常の `divide` よりもかなり遅く動作します。
制御された精度が本当に必要ない場合や、迅速な計算が必要な場合は、 [divide](#divide) を使用することを検討してください。
:::
    

**構文**

```sql
divideDecimal(x, y[, result_scale])
```

**引数**

- `x` — 第一値: [Decimal](/sql-reference/data-types/decimal). - `y` — 第二値: [Decimal](/sql-reference/data-types/decimal). - `result_scale` — 結果のスケール。型 [Int/UInt](/sql-reference/data-types/int-uint). 

**返される値**

指定されたスケールでの除算の結果。 [`Decimal256`](/sql-reference/data-types/decimal)

**例**

**例1**

```sql title=Query
divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)
```

```response title=Response
┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐
│                                                -5.7142857142 │
└──────────────────────────────────────────────────────────────┘
```

**例2**

```sql title=Query
SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);
SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);
```

```response title=Response
┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐
│                                             -5.7 │
└──────────────────────────────────────────────────┘
┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐
│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
```



## divideOrNull {#divideOrNull}

導入時期: v25.5


`divide` と同じですが、0で割るとNULLを返します。
    

**構文**

```sql
divideOrNull(x, y)
```

**引数**

- `x` — 被除数 - `y` — 除数 

**返される値**

`x` と `y` の商、またはNULL。

**例**

**0で割り算**

```sql title=Query
SELECT divideOrNull(25, 0)
```

```response title=Response
\N
```



## gcd {#gcd}

導入時期: v1.1


2つの値 `a` と `b` の最大公約数を返します。

0で割るか、最小の負の数をマイナス1で割ると例外がスローされます。
    

**構文**

```sql
gcd(x, y)
```

**引数**

- `x` — 第1整数 - `y` — 第2整数 

**返される値**

`x` と `y` の最大公約数。

**例**

**使用例**

```sql title=Query
SELECT gcd(12, 18)
```

```response title=Response
6
```



## ifNotFinite {#ifNotFinite}

導入時期: v20.3


浮動小数点値が有限かどうかをチェックします。

[三項演算子](/sql-reference/functions/conditional-functions#if)を使用することで同様の結果を得ることができます： `isFinite(x) ? x : y`。
    

**構文**

```sql
ifNotFinite(x,y)
```

**引数**

- `x` — 無限かどうかを確認する値。 [`Float*`](/sql-reference/data-types/float)
- `y` — フォールバック値。 [`Float*`](/sql-reference/data-types/float)


**返される値**

- `x` が有限の場合は `x`。
- `x` が有限でない場合は `y`。

**例**

**使用例**

```sql title=Query
SELECT 1/0 AS infimum, ifNotFinite(infimum,42)
```

```response title=Response
inf  42
```



## intDiv {#intDiv}

導入時期: v1.1


2つの値 `x` を `y` で整数除算します。つまり、次に小さい整数に切り下げた商を計算します。

結果は被除数（最初のパラメータ）と同じ幅になります。

0で割ると例外がスローされ、商が被除数の範囲に収まらない場合、または最小の負の数をマイナス1で割ると例外がスローされます。
    

**構文**

```sql
intDiv(x, y)
```

**引数**

- `x` — 左側のオペランド。 - `y` — 右側のオペランド。 

**返される値**

`x` と `y` の整数除算結果

**例**

**2つの浮動小数点の整数除算**

```sql title=Query
SELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)
```

```response title=Response
┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐
│ 1000 │ Int64                                   │
└──────┴─────────────────────────────────────────┘
```

**商が被除数の範囲に収まらない**

```sql title=Query
SELECT
intDiv(1, 0.001) AS res,
toTypeName(res)
```

```response title=Response
Received exception from server (version 23.2.1):
Code: 153. DB::Exception: Received from localhost:9000. DB::Exception:
Cannot perform integer division, because it will produce infinite or too
large number: While processing intDiv(1, 0.001) AS res, toTypeName(res).
(ILLEGAL_DIVISION)
```



## intDivOrNull {#intDivOrNull}

導入時期: v25.5


`intDiv` と同じですが、0で割るか最小の負の数をマイナス1で割るとNULLを返します。
    

**構文**

```sql
intDivOrNull(x, y)
```

**引数**

- `x` — 左側のオペランド。 [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — 右側のオペランド。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**返される値**

`x` と `y` の整数除算結果、またはNULL。

**例**

**0による整数除算**

```sql title=Query
SELECT intDivOrNull(1, 0)
```

```response title=Response
\N
```

**最小の負の数をマイナス1で割った場合**

```sql title=Query
SELECT intDivOrNull(-9223372036854775808, -1)
```

```response title=Response
\N
```



## intDivOrZero {#intDivOrZero}

導入時期: v1.1


`intDiv` と同じですが、0で割るとゼロを返します。最小の負の数をマイナス1で割った場合もゼロを返します。
    

**構文**

```sql
intDivOrZero(a, b)
```

**引数**

- `a` — 左側のオペランド。 [`(U)Int*`](/sql-reference/data-types/int-uint)
- `b` — 右側のオペランド。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**返される値**

`a` と `b` の整数除算結果、またはゼロ。

**例**

**0による整数除算**

```sql title=Query
SELECT intDivOrZero(1, 0)
```

```response title=Response
0
```

**最小の負の数をマイナス1で割った場合**

```sql title=Query
SELECT intDivOrZero(0.05, -1)
```

```response title=Response
0
```



## isFinite {#isFinite}

導入時期: v1.1


Float32 または Float64 の引数が無限でなく、 `NaN` でない場合は `1` を返します。それ以外の場合、この関数は `0` を返します。
    

**構文**

```sql
isFinite(x)
```

**引数**

- `x` — 有限性を確認する数。 [`Float*`](/sql-reference/data-types/float)


**返される値**

`x` が無限でなく `NaN` でない場合は `1`、それ以外は `0`。

**例**

**数が有限であるかをテスト**

```sql title=Query
SELECT isFinite(inf)
```

```response title=Response
0
```



## isInfinite {#isInfinite}

導入時期: v1.1


Float32 または Float64 の引数が無限の場合は `1` を返します。それ以外の場合、この関数は `0` を返します。
`NaN` の場合は `0` が返されることに注意してください。
    

**構文**

```sql
isInfinite(x)
```

**引数**

- `x` — 無限かどうかを確認する数。 [`Float*`](/sql-reference/data-types/float)


**返される値**

`x` が無限の場合は `1`、それ以外は `0`（`NaN` を含む）。

**例**

**数が無限であるかをテスト**

```sql title=Query
SELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))
```

```response title=Response
1 0 0
```



## isNaN {#isNaN}

導入時期: v1.1

Float32 及び Float64 の引数が `NaN` の場合は `1` を返します。それ以外の場合は `0` を返します。

**構文**

```sql
isNaN(x)
```

**引数**

- `x` — `NaN` かどうか評価する引数。 [`Float*`](/sql-reference/data-types/float)


**返される値**

`NaN` の場合は `1`、それ以外は `0`。

**例**

**使用例**

```sql title=Query
SELECT isNaN(NaN)
```

```response title=Response
1
```



## lcm {#lcm}

導入時期: v1.1


2つの値 `x` と `y` の最小公倍数を返します。

0で割るか、最小の負の数をマイナス1で割ると例外がスローされます。
    

**構文**

```sql
lcm(x, y)
```

**引数**

- `x` — 第1整数。 [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — 第2整数。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**返される値**

`x` と `y` の最小公倍数を返します。 [`(U)Int*`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT lcm(6, 8)
```

```response title=Response
24
```



## max2 {#max2}

導入時期: v21.11


2つの数値 `x` と `y` のうち大きい方を返します。
    

**構文**

```sql
max2(x, y)
```

**引数**

- `x` — 第一の値 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 第二の値 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)


**返される値**

`x` と `y` の大きい方の値を返します。 [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT max2(-1, 2)
```

```response title=Response
2
```



## min2 {#min2}

導入時期: v21.11


2つの数値 `x` と `y` のうち小さい方を返します。
    

**構文**

```sql
min2(x, y)
```

**引数**

- `x` — 第一の値 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 第二の値 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)


**返される値**

`x` と `y` の小さい方の値を返します。 [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT min2(-1, 2)
```

```response title=Response
-1
```



## minus {#minus}

導入時期: v1.1


2つの値 `a` と `b` の差を計算します。結果は常に符号付きです。
プラスと同様に、整数を日付または時間付き日付から減算することが可能です。
さらに、時間付きの間の日付間の減算もサポートされており、それにより両者の間の時間差が得られます。
    

**構文**

```sql
minus(x, y)
```

**引数**

- `x` — 被減数。 - `y` — 減算数。 

**返される値**

`x` マイナス `y`

**例**

**2つの数を引き算**

```sql title=Query
SELECT minus(10, 5)
```

```response title=Response
5
```

**整数と日付を引き算**

```sql title=Query
SELECT minus(toDate('2025-01-01'),5)
```

```response title=Response
2024-12-27
```



## modulo {#modulo}

導入時期: v1.1


2つの値 `a` を `b` で割った余りを計算します。

入力が両方とも整数の場合、結果の型は整数になります。入力の1つが浮動小数点数の場合、結果の型は Float64 になります。

余りはC++と同様に計算されます。負の数には切り捨て除算が使用されます。

0で割る場合や最小の負の数をマイナス1で割る場合は例外がスローされます。
    

**構文**

```sql
modulo(a, b)
```

**引数**

- `a` — 被除数 - `b` — 除数（モジュラス） 

**返される値**

`a % b` の余り

**例**

**使用例**

```sql title=Query
SELECT modulo(5, 2)
```

```response title=Response
1
```



## moduloOrNull {#moduloOrNull}

導入時期: v25.5


`a` を `b` で割った余りを計算します。`modulo` 関数と似ていますが、`moduloOrNull` は右側の引数が 0 の場合は NULL を返します。
    

**構文**

```sql
moduloOrNull(x, y)
```

**引数**

- `x` — 被除数。 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
- `y` — 除数（モジュラス）。 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)


**返される値**

`x` を `y` で割った余りを返します。除数がゼロの場合は null を返します。

**例**

**0による moduloOrNull**

```sql title=Query
SELECT moduloOrNull(5, 0)
```

```response title=Response
\N
```



## moduloOrZero {#moduloOrZero}

導入時期: v20.3


modulo に似ますが、除数がゼロの場合はゼロを返し、modulo 関数では例外をスローします。
    

**構文**

```sql
moduloOrZero(a, b)
```

**引数**

- `a` — 被除数。 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
- `b` — 除数（モジュラス）。 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)


**返される値**

`a % b` の余りを返します。除数が `0` の場合は `0` を返します。

**例**

**使用例**

```sql title=Query
SELECT moduloOrZero(5, 0)
```

```response title=Response
0
```



## multiply {#multiply}

導入時期: v1.1

2つの値 `x` と `y` の積を計算します。

**構文**

```sql
multiply(x, y)
```

**引数**

- `x` — 因子。 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 因子。 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)


**返される値**

`x` と `y` の積を返します。

**例**

**2つの数を掛ける**

```sql title=Query
SELECT multiply(5,5)
```

```response title=Response
25
```



## multiplyDecimal {#multiplyDecimal}

導入時期: v22.12


2つの小数を掛けます。結果の値は [Decimal256](/sql-reference/data-types/decimal) の型になります。結果スケールは `result_scale` 引数で明示的に指定できます（範囲 `[0, 76]` の定数整数）。指定しない場合は、結果スケールは与えられた引数の最大スケールになります。

:::note
これらの関数は通常の `multiply` よりもかなり遅く処理されます。
制御された精度が本当に必要ない場合や、迅速な計算が必要な場合は、 [multiply](#multiply) の使用を検討してください。
:::
    

**構文**

```sql
multiplyDecimal(a, b[, result_scale])
```

**引数**

- `a` — 第一の値。 [`Decimal`](/sql-reference/data-types/decimal)
- `b` — 第二の値。 [`Decimal`](/sql-reference/data-types/decimal)
- `result_scale` — 結果のスケール。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**返される値**

指定されたスケールでの掛け算の結果。型: [`Decimal256`](/sql-reference/data-types/decimal)

**例**

**使用例**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
25.2
```

**通常の乗算との違い**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                               -26.8609633 │
└───────────────────────────────────────────────────────────┘
┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                                         -26.8609 │
└──────────────────────────────────────────────────────────────────┘
```

**小数のオーバーフロー**

```sql title=Query
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    multiplyDecimal(a, b);
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    a * b;
```

```response title=Response
┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐
│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │
└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘
Received exception from server (version 22.11.1):
Code: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow:
While processing toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)
```



## negate {#negate}

導入時期: v1.1

引数 `x` の符号を反転させます。結果は常に符号付きです。

**構文**

```sql
negate(x)
```

**引数**

- `x` — 反転する値。 

**返される値**

`x` の -x を返します。

**例**

**使用例**

```sql title=Query
SELECT negate(10)
```

```response title=Response
-10
```



## plus {#plus}

導入時期: v1.1


2つの値 `x` と `y` の合計を計算します。エイリアス: `x + y`（演算子）。
整数と日付または時間付き日付を加算することが可能です。前者は日付の日数を増やし、後者は時間付きの日付の秒数を増やします。
    

**構文**

```sql
plus(x, y)
```

**引数**

- `x` — 左側のオペランド。 - `y` — 右側のオペランド。 

**返される値**

`x` と `y` の合計を返します。

**例**

**2つの数を加算**

```sql title=Query
SELECT plus(5,5)
```

```response title=Response
10
```

**整数と日付を加算**

```sql title=Query
SELECT plus(toDate('2025-01-01'),5)
```

```response title=Response
2025-01-06
```



## positiveModulo {#positiveModulo}

導入時期: v22.11


`x` を `y` で割った余りを計算します。`modulo` 関数と似ていますが、`positiveModulo` は常に非負の数を返します。
    

**構文**

```sql
positiveModulo(x, y)
```

**引数**

- `x` — 被除数。 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 除数（モジュラス）。 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)


**返される値**

`x` と `y` で割り切れる最も近い整数より小さい `x` の値の差を返します。

**例**

**使用例**

```sql title=Query
SELECT positiveModulo(-1, 10)
```

```response title=Response
9
```



## positiveModuloOrNull {#positiveModuloOrNull}

導入時期: v25.5


`a` を `b` で割った余りを計算します。`positiveModulo` 関数と似ていますが、`positiveModuloOrNull` は右側の引数が 0 の場合は NULL を返します。
    

**構文**

```sql
positiveModuloOrNull(x, y)
```

**引数**

- `x` — 被除数。 [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float). - `x` — 除数（モジュラス）。 [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float). 

**返される値**

`x` と `y` で割り切れる最も近い整数より小さい `x` の値の差を返し除数がゼロのときは `null` を返します。

**例**

**positiveModuloOrNull**

```sql title=Query
SELECT positiveModuloOrNull(5, 0)
```

```response title=Response
\N
```



<!--AUTOGENERATED_END-->

---
description: 'ビット関数のドキュメント'
sidebar_label: 'ビット'
slug: /sql-reference/functions/bit-functions
title: 'ビット関数'
doc_type: 'reference'
---

# ビット関数 \\{#bit-functions\\}

ビット関数は、`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64`、`Float32`、`Float64` のいずれかの型の組み合わせに対して動作します。一部の関数は `String` および `FixedString` 型もサポートします。

結果の型は、引数のうち最大のビット幅を持つ型のビット数を幅とする整数型になります。少なくとも1つの引数が符号付きである場合、結果は符号付きの数値になります。引数が浮動小数点数型である場合、それは `Int64` 型にキャストされます。

{/* 
  以下のタグ内の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントで置き換えられます。タグを変更したり削除したりしないでください。
  詳細は次を参照してください: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## bitAnd \\{#bitAnd\\}

導入バージョン: v1.1

2 つの値に対してビット単位の AND 演算を行います。

**構文**

```sql
bitAnd(a, b)
```

**引数**

* `a` — 1 番目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
* `b` — 2 番目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**返り値**

ビット単位の演算 `a AND b` の結果を返します。

**例**

**使用例**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitAnd(a, b)
FROM bits
```

```response title=Response
┌─a─┬─b─┬─bitAnd(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            0 │
│ 1 │ 0 │            0 │
│ 1 │ 1 │            1 │
└───┴───┴──────────────┘
```

## bitCount \\{#bitCount\\}

導入バージョン: v20.3

数値の2進数表現において、1にセットされているビット数を計算します。

**構文**

```sql
bitCount(x)
```

**引数**

* `x` — 整数または浮動小数点数の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**返り値**

`x` の中で 1 に設定されているビット数を返します。[`UInt8`](../data-types/int-uint.md)。

:::note
この関数は入力値をより大きい型に変換しません（[符号拡張](https://en.wikipedia.org/wiki/Sign_extension)）。
例: `bitCount(toUInt8(-1)) = 8`。
:::

**例**

**使用例**

```sql title=Query
SELECT bin(333), bitCount(333);
```

```response title=Response
┌─bin(333)─────────┬─bitCount(333)─┐
│ 0000000101001101 │             5 │
└──────────────────┴───────────────┘
```

## bitHammingDistance \\{#bitHammingDistance\\}

導入バージョン: v21.1

2 つの数値のビット表現間の[ハミング距離](https://en.wikipedia.org/wiki/Hamming_distance)を返します。
[`SimHash`](../../sql-reference/functions/hash-functions.md#ngramSimHash) 関数と組み合わせて、準重複（類似）文字列の検出に使用できます。
距離が小さいほど、文字列同士がより類似していることを意味します。

**構文**

```sql
bitHammingDistance(x, y)
```

**引数**

* `x` — ハミング距離を計算する最初の数値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
* `y` — ハミング距離を計算する2番目の数値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**返り値**

`x` と `y` のハミング距離を返します。型は [`UInt8`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT bitHammingDistance(111, 121);
```

```response title=Response
┌─bitHammingDistance(111, 121)─┐
│                            3 │
└──────────────────────────────┘
```

## bitNot \\{#bitNot\\}

導入バージョン: v1.1

ビット単位の NOT 演算を行います。

**構文**

```sql
bitNot(a)
```

**引数**

* `a` — ビット単位の NOT 演算を適用する値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`String`](/sql-reference/data-types/string)

**戻り値**

`~a` の結果である、ビットが反転された `a` を返します。

**例**

**使用例**

```sql title=Query
SELECT
    CAST('5', 'UInt8') AS original,
    bin(original) AS original_binary,
    bitNot(original) AS result,
    bin(bitNot(original)) AS result_binary;
```

```response title=Response
┌─original─┬─original_binary─┬─result─┬─result_binary─┐
│        5 │ 00000101        │    250 │ 11111010      │
└──────────┴─────────────────┴────────┴───────────────┘
```

## bitOr \\{#bitOr\\}

導入バージョン: v1.1

2 つの値に対してビット単位 OR 演算を実行します。

**構文**

```sql
bitOr(a, b)
```

**引数**

* `a` — 最初の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
* `b` — 2 番目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**戻り値**

ビット単位 OR 演算 `a OR b` の結果を返します。

**例**

**使用例**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitOr(a, b)
FROM bits;
```

```response title=Response
┌─a─┬─b─┬─bitOr(a, b)─┐
│ 0 │ 0 │           0 │
│ 0 │ 1 │           1 │
│ 1 │ 0 │           1 │
│ 1 │ 1 │           1 │
└───┴───┴─────────────┘
```

## bitRotateLeft \\{#bitRotateLeft\\}

導入されたバージョン: v1.1

ビットを指定した数だけ左にローテートします。あふれたビットは右側に回り込みます。

**構文**

```sql
bitRotateLeft(a, N)
```

**引数**

* `a` — 回転対象の値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `N` — 左方向に回転させるビット数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`a` と同じ型の回転後の値を返します。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT 99 AS a, bin(a), bitRotateLeft(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=Response
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       141 │ 10001101       │
└────┴──────────┴───────────┴────────────────┘
```

## bitRotateRight \\{#bitRotateRight\\}

導入バージョン: v1.1

ビット列を指定した数だけ右に回転させます。はみ出したビットは左側に回り込みます。

**構文**

```sql
bitRotateRight(a, N)
```

**引数**

* `a` — 回転させる値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `N` — 右方向に回転させるビット数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`a` と同じ型の回転後の値を返します。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT 99 AS a, bin(a), bitRotateRight(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=Response
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       216 │ 11011000       │
└────┴──────────┴───────────┴────────────────┘
```

## bitShiftLeft \\{#bitShiftLeft\\}

導入バージョン: v1.1

値の2進数表現を、指定したビット数だけ左にシフトします。

`FixedString` や `String` は、単一のマルチバイト値として扱われます。

`FixedString` の値では、シフトによって範囲外に出たビットは失われます。
一方、`String` の値は追加のバイトで拡張されるため、ビットが失われることはありません。

**構文**

```sql
bitShiftLeft(a, N)
```

**引数**

* `a` — シフトする値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `N` — シフトする位置数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`a` と同じ型のシフト後の値を返します。

**例**

**バイナリエンコーディングを使用した使用例**

```sql title=Query
SELECT 99 AS a, bin(a), bitShiftLeft(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=Response
┌──a─┬─bin(99)──┬─a_shifted─┬─bin(bitShiftLeft(99, 2))─┐
│ 99 │ 01100011 │       140 │ 10001100                 │
└────┴──────────┴───────────┴──────────────────────────┘
```

**16進数エンコードの使用例**

```sql title=Query
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftLeft('abc', 4))─┐
│ abc │ 616263     │ &0        │ 06162630                    │
└─────┴────────────┴───────────┴─────────────────────────────┘
```

**FixedString エンコーディングの使用例**

```sql title=Query
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftLeft(toFixedString('abc', 3), 4))─┐
│ abc │ 616263                       │ &0        │ 162630                                        │
└─────┴──────────────────────────────┴───────────┴───────────────────────────────────────────────┘
```

## bitShiftRight \\{#bitShiftRight\\}

導入バージョン: v1.1

値の2進表現を、指定されたビット数だけ右にシフトします。

`FixedString` または `String` は、1つのマルチバイト値として扱われます。

`FixedString` 値では、シフトによって押し出されたビットは失われます。
一方、`String` 値は追加のバイトで拡張されるため、ビットは失われません。

**構文**

```sql
bitShiftRight(a, N)
```

**引数**

* `a` — シフトする値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `N` — シフトするビット数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`a` と同じ型の、シフト後の値を返します。

**例**

**バイナリ符号化での使用例**

```sql title=Query
SELECT 101 AS a, bin(a), bitShiftRight(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=Response
┌───a─┬─bin(101)─┬─a_shifted─┬─bin(bitShiftRight(101, 2))─┐
│ 101 │ 01100101 │        25 │ 00011001                   │
└─────┴──────────┴───────────┴────────────────────────────┘
```

**16進数エンコードを使った使用例**

```sql title=Query
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftRight('abc', 12))─┐
│ abc │ 616263     │           │ 0616                          │
└─────┴────────────┴───────────┴───────────────────────────────┘
```

**Fixed String エンコーディングの使用例**

```sql title=Query
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftRight(a, 12) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftRight(toFixedString('abc', 3), 12))─┐
│ abc │ 616263                       │           │ 000616                                          │
└─────┴──────────────────────────────┴───────────┴─────────────────────────────────────────────────┘
```

## bitSlice \\{#bitSlice\\}

導入バージョン: v22.2

`offset` インデックスのビット位置から始まり、`length` ビット分の部分ビット列（サブストリング）を返します。

**構文**

```sql
bitSlice(s, offset[, length])
```

**引数**

* `s` — スライス対象の String または FixedString。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` —
  開始ビット位置（1 始まりのインデックス）。
* 正の値: 文字列の先頭から数えます。
* 負の値: 文字列の末尾から数えます。

  [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
* `length` —
  省略可能。抽出するビット数。
* 正の値: `length` ビットを抽出します。
* 負の値: offset から `(string_length - |length|)` までを抽出します。
* 省略時: offset から文字列の末尾までを抽出します。
* length が 8 の倍数でない場合、結果は右側がゼロで埋められます。
  [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**返される値**

抽出されたビットを 2 進ビット列として表現した文字列を返します。結果は常にバイト境界（8 ビットの倍数）になるようにパディングされます。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 8));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 2));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 9));
SELECT bin('Hello'), bin(bitSlice('Hello', -4, 8));
```

```response title=Response
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 8))─┐
│ 0100100001100101011011000110110001101111 │ 01001000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 2))─┐
│ 0100100001100101011011000110110001101111 │ 01000000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 9))─┐
│ 0100100001100101011011000110110001101111 │ 0100100000000000             │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', -4, 8))─┐
│ 0100100001100101011011000110110001101111 │ 11110000                      │
└──────────────────────────────────────────┴───────────────────────────────┘
```

## bitTest \\{#bitTest\\}

導入バージョン: v1.1

任意の数値を[2進数表現](https://en.wikipedia.org/wiki/Binary_number)に変換し、指定した位置にあるビットの値を返します。ビットの位置は右端から左方向に、0 を起点として数えます。

**構文**

```sql
bitTest(a, i)
```

**引数**

* `a` — 変換対象の数値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
* `i` — 返すビット位置。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**返り値**

`a` の 2 進表現における位置 `i` のビット値を返します。型は [`UInt8`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT bin(2), bitTest(2, 1);
```

```response title=Response
┌─bin(2)───┬─bitTest(2, 1)─┐
│ 00000010 │             1 │
└──────────┴───────────────┘
```

## bitTestAll \\{#bitTestAll\\}

導入バージョン: v1.1

指定された位置のすべてのビットに対する[論理積](https://en.wikipedia.org/wiki/Logical_conjunction)（AND 演算子）の結果を返します。
右端を 0 として左方向に数えます。

2 つのビット間の論理 AND は、両方の入力ビットが真である場合に限り真になります。

**構文**

```sql
bitTestAll(a, index1[, index2, ... , indexN])
```

**引数**

* `a` — 整数値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `index1, ...` — 1つ以上のビット位置。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

論理積の結果を[`UInt8`](/sql-reference/data-types/int-uint)型で返します。

**例**

**使用例 1**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(43, 0, 1, 3, 5)─┐
│ 00101011 │                          1 │
└──────────┴────────────────────────────┘
```

**使用例 2**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(4⋯1, 3, 5, 2)─┐
│ 00101011 │                        0 │
└──────────┴──────────────────────────┘
```

## bitTestAny \\{#bitTestAny\\}

導入バージョン: v1.1

数値内の指定された位置にあるすべてのビットについて、[論理和](https://en.wikipedia.org/wiki/Logical_disjunction)（OR 演算）の結果を返します。
ビット位置は右から左に数え、0 から開始します。

2 つのビットの論理和は、少なくとも一方の入力ビットが真である場合に真となります。

**構文**

```sql
bitTestAny(a, index1[, index2, ... , indexN])
```

**引数**

* `a` — 整数値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `index1, ...` — 1 つ以上のビットの位置。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**返り値**

論理和の結果を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例 1**

```sql title=Query
SELECT bitTestAny(43, 0, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAny(43, 0, 2)─┐
│ 00101011 │                    1 │
└──────────┴──────────────────────┘
```

**使用例 2**

```sql title=Query
SELECT bitTestAny(43, 4, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAny(43, 4, 2)─┐
│ 00101011 │                    0 │
└──────────┴──────────────────────┘
```

## bitXor \\{#bitXor\\}

導入バージョン: v1.1

2つの値に対してビット単位の排他的論理和 (XOR) 演算を行います。

**構文**

```sql
bitXor(a, b)
```

**引数**

* `a` — 1番目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
* `b` — 2番目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**戻り値**

ビット単位の排他的論理和演算 `a XOR b` の結果を返します。

**例**

**使用例**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitXor(a, b)
FROM bits;
```

```response title=Response
┌─a─┬─b─┬─bitXor(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            1 │
│ 1 │ 0 │            1 │
│ 1 │ 1 │            0 │
└───┴───┴──────────────┘
```

{/*AUTOGENERATED_END*/ }

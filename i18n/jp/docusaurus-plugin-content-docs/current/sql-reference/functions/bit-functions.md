---
description: 'ビット関数のドキュメント'
sidebar_label: 'ビット'
slug: /sql-reference/functions/bit-functions
title: 'ビット関数'
doc_type: 'reference'
---



# ビット関数

ビット関数は、`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64`、`Float32`、`Float64`のいずれかの型の組み合わせに対して動作します。一部の関数は`String`型および`FixedString`型もサポートしています。

結果の型は、引数の最大ビット数と同じビット数を持つ整数です。引数のうち少なくとも1つが符号付きの場合、結果は符号付き数値になります。引数が浮動小数点数の場合は、Int64にキャストされます。

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## bitAnd {#bitAnd}

導入バージョン: v1.1

2つの値に対してビット単位のAND演算を実行します。

**構文**

```sql
bitAnd(a, b)
```

**引数**

- `a` — 1つ目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
- `b` — 2つ目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**戻り値**

ビット演算 `a AND b` の結果を返します。

**例**

**使用例**

```sql title=クエリ
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitAnd(a, b)
FROM bits
```

```response title=レスポンス
┌─a─┬─b─┬─bitAnd(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            0 │
│ 1 │ 0 │            0 │
│ 1 │ 1 │            1 │
└───┴───┴──────────────┘
```


## bitCount {#bitCount}

導入バージョン: v20.3

数値の2進数表現において1に設定されているビット数を計算します。

**構文**

```sql
bitCount(x)
```

**引数**

- `x` — 整数または浮動小数点数値。[`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)

**戻り値**

`x`において1に設定されているビット数を返します。[`UInt8`](../data-types/int-uint.md)。

:::note
この関数は入力値をより大きな型に変換しません([符号拡張](https://en.wikipedia.org/wiki/Sign_extension))。
例: `bitCount(toUInt8(-1)) = 8`。
:::

**例**

**使用例**

```sql title=クエリ
SELECT bin(333), bitCount(333);
```

```response title=レスポンス
┌─bin(333)─────────┬─bitCount(333)─┐
│ 0000000101001101 │             5 │
└──────────────────┴───────────────┘
```


## bitHammingDistance {#bitHammingDistance}

導入バージョン: v21.1

2つの数値のビット表現間の[ハミング距離](https://en.wikipedia.org/wiki/Hamming_distance)を返します。
[`SimHash`](../../sql-reference/functions/hash-functions.md#ngramSimHash)関数と組み合わせて、準重複文字列の検出に使用できます。
距離が小さいほど、文字列の類似度が高くなります。

**構文**

```sql
bitHammingDistance(x, y)
```

**引数**

- `x` — ハミング距離計算の第1の数値。[`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)
- `y` — ハミング距離計算の第2の数値。[`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)

**戻り値**

`x`と`y`の間のハミング距離を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT bitHammingDistance(111, 121);
```

```response title=レスポンス
┌─bitHammingDistance(111, 121)─┐
│                            3 │
└──────────────────────────────┘
```


## bitNot {#bitNot}

導入バージョン: v1.1

ビット単位のNOT演算を実行します。

**構文**

```sql
bitNot(a)
```

**引数**

- `a` — ビット単位のNOT演算を適用する値。[`(U)Int*`](/sql-reference/data-types/int-uint)、[`Float*`](/sql-reference/data-types/float)、または[`String`](/sql-reference/data-types/string)

**戻り値**

`~a`の結果、すなわち`a`のビットを反転した値を返します。

**例**

**使用例**

```sql title=クエリ
SELECT
    CAST('5', 'UInt8') AS original,
    bin(original) AS original_binary,
    bitNot(original) AS result,
    bin(bitNot(original)) AS result_binary;
```

```response title=レスポンス
┌─original─┬─original_binary─┬─result─┬─result_binary─┐
│        5 │ 00000101        │    250 │ 11111010      │
└──────────┴─────────────────┴────────┴───────────────┘
```


## bitOr {#bitOr}

導入バージョン: v1.1

2つの値に対してビット単位のOR演算を実行します。

**構文**

```sql
bitOr(a, b)
```

**引数**

- `a` — 1つ目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
- `b` — 2つ目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**戻り値**

ビット演算 `a OR b` の結果を返します。

**例**

**使用例**

```sql title=クエリ
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitOr(a, b)
FROM bits;
```

```response title=レスポンス
┌─a─┬─b─┬─bitOr(a, b)─┐
│ 0 │ 0 │           0 │
│ 0 │ 1 │           1 │
│ 1 │ 0 │           1 │
│ 1 │ 1 │           1 │
└───┴───┴─────────────┘
```


## bitRotateLeft {#bitRotateLeft}

導入バージョン: v1.1

指定された位置数だけビットを左に回転させます。左端からはみ出したビットは右端に回り込みます。

**構文**

```sql
bitRotateLeft(a, N)
```

**引数**

- `a` — 回転させる値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `N` — 左に回転させる位置数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`a`と同じ型の回転後の値を返します。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT 99 AS a, bin(a), bitRotateLeft(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=Response
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       141 │ 10001101       │
└────┴──────────┴───────────┴────────────────┘
```


## bitRotateRight {#bitRotateRight}

導入バージョン: v1.1

指定された位置数だけビットを右に回転させます。右端から溢れたビットは左端に回り込みます。

**構文**

```sql
bitRotateRight(a, N)
```

**引数**

- `a` — 回転させる値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `N` — 右に回転させる位置数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`a`と同じ型で回転後の値を返します。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT 99 AS a, bin(a), bitRotateRight(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=レスポンス
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       216 │ 11011000       │
└────┴──────────┴───────────┴────────────────┘
```


## bitShiftLeft {#bitShiftLeft}

導入バージョン: v1.1

値のバイナリ表現を、指定されたビット数だけ左にシフトします。

`FixedString`または`String`は、単一のマルチバイト値として扱われます。

`FixedString`値のビットは、シフトアウトされると失われます。
一方、`String`値は追加のバイトで拡張されるため、ビットが失われることはありません。

**構文**

```sql
bitShiftLeft(a, N)
```

**引数**

- `a` — シフトする値。[`(U)Int*`](/sql-reference/data-types/int-uint)、[`String`](/sql-reference/data-types/string)、または[`FixedString`](/sql-reference/data-types/fixedstring)
- `N` — シフトするビット位置の数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`a`と同じ型でシフトされた値を返します。

**例**

**バイナリエンコーディングの使用例**

```sql title=Query
SELECT 99 AS a, bin(a), bitShiftLeft(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=Response
┌──a─┬─bin(99)──┬─a_shifted─┬─bin(bitShiftLeft(99, 2))─┐
│ 99 │ 01100011 │       140 │ 10001100                 │
└────┴──────────┴───────────┴──────────────────────────┘
```

**16進数エンコーディングの使用例**

```sql title=Query
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftLeft('abc', 4))─┐
│ abc │ 616263     │ &0        │ 06162630                    │
└─────┴────────────┴───────────┴─────────────────────────────┘
```

**固定文字列エンコーディングの使用例**

```sql title=Query
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftLeft(toFixedString('abc', 3), 4))─┐
│ abc │ 616263                       │ &0        │ 162630                                        │
└─────┴──────────────────────────────┴───────────┴───────────────────────────────────────────────┘
```


## bitShiftRight {#bitShiftRight}

導入バージョン: v1.1

値のバイナリ表現を、指定されたビット数だけ右にシフトします。

`FixedString`または`String`は、単一のマルチバイト値として扱われます。

`FixedString`値のビットは、シフトアウトされると失われます。
一方、`String`値は追加のバイトで拡張されるため、ビットは失われません。

**構文**

```sql
bitShiftRight(a, N)
```

**引数**

- `a` — シフトする値。[`(U)Int*`](/sql-reference/data-types/int-uint)、[`String`](/sql-reference/data-types/string)、または[`FixedString`](/sql-reference/data-types/fixedstring)
- `N` — シフトするビット位置数。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`a`と同じ型でシフトされた値を返します。

**例**

**バイナリエンコーディングの使用例**

```sql title=クエリ
SELECT 101 AS a, bin(a), bitShiftRight(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=レスポンス
┌───a─┬─bin(101)─┬─a_shifted─┬─bin(bitShiftRight(101, 2))─┐
│ 101 │ 01100101 │        25 │ 00011001                   │
└─────┴──────────┴───────────┴────────────────────────────┘
```

**16進数エンコーディングの使用例**

```sql title=クエリ
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=レスポンス
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftRight('abc', 12))─┐
│ abc │ 616263     │           │ 0616                          │
└─────┴────────────┴───────────┴───────────────────────────────┘
```

**固定文字列エンコーディングの使用例**

```sql title=クエリ
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftRight(a, 12) AS a_shifted, hex(a_shifted);
```

```response title=レスポンス
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftRight(toFixedString('abc', 3), 12))─┐
│ abc │ 616263                       │           │ 000616                                          │
└─────┴──────────────────────────────┴───────────┴─────────────────────────────────────────────────┘
```


## bitSlice {#bitSlice}

導入バージョン: v22.2

`offset`インデックスから始まるビットから`length`ビット長の部分文字列を返します。

**構文**

```sql
bitSlice(s, offset[, length])
```

**引数**

- `s` — スライス対象の文字列または固定長文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `offset` —
  開始ビット位置(1ベースのインデックス)。
- 正の値: 文字列の先頭からカウントします。
- 負の値: 文字列の末尾からカウントします。

         [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)

- `length` —
  オプション。抽出するビット数。
- 正の値: `length`ビットを抽出します。
- 負の値: オフセットから`(string_length - |length|)`まで抽出します。
- 省略時: オフセットから文字列の末尾まで抽出します。
- lengthが8の倍数でない場合、結果は右側にゼロでパディングされます。
  [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)

**戻り値**

抽出されたビットを含む文字列をバイナリシーケンスとして返します。結果は常にバイト境界(8ビットの倍数)にパディングされます。[`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 8));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 2));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 9));
SELECT bin('Hello'), bin(bitSlice('Hello', -4, 8));
```

```response title=Response
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 8))─┐
│ 0100100001100101011011000110110001101111 │ 01001000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 2))─┐
│ 0100100001100101011011000110110001101111 │ 01000000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 9))─┐
│ 0100100001100101011011000110110001101111 │ 0100100000000000             │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', -4, 8))─┐
│ 0100100001100101011011000110110001101111 │ 11110000                      │
└──────────────────────────────────────────┴───────────────────────────────┘
```


## bitTest {#bitTest}

導入バージョン: v1.1

任意の数値を[2進数形式](https://en.wikipedia.org/wiki/Binary_number)に変換し、指定された位置のビット値を返します。ビット位置のカウントは右から左へ、0から開始されます。

**構文**

```sql
bitTest(a, i)
```

**引数**

- `a` — 変換する数値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)
- `i` — 取得するビットの位置。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)

**戻り値**

`a`の2進数表現における位置`i`のビット値を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT bin(2), bitTest(2, 1);
```

```response title=レスポンス
┌─bin(2)───┬─bitTest(2, 1)─┐
│ 00000010 │             1 │
└──────────┴───────────────┘
```


## bitTestAll {#bitTestAll}

導入バージョン: v1.1

指定された位置にあるすべてのビットの[論理積](https://en.wikipedia.org/wiki/Logical_conjunction)（AND演算子）の結果を返します。
ビット位置は右から左へ、0から数えます。

2つのビット間の論理ANDは、両方の入力ビットがtrueの場合にのみtrueになります。

**構文**

```sql
bitTestAll(a, index1[, index2, ... , indexN])
```

**引数**

- `a` — 整数値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `index1, ...` — ビット位置（1つまたは複数）。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

論理積の結果を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例 1**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(43, 0, 1, 3, 5)─┐
│ 00101011 │                          1 │
└──────────┴────────────────────────────┘
```

**使用例 2**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(4⋯1, 3, 5, 2)─┐
│ 00101011 │                        0 │
└──────────┴──────────────────────────┘
```


## bitTestAny {#bitTestAny}

導入バージョン: v1.1

数値内の指定された位置にあるすべてのビットの[論理和](https://en.wikipedia.org/wiki/Logical_disjunction)(OR演算子)の結果を返します。
位置は右から左へ、0から数えます。

2つのビット間の論理ORは、入力ビットの少なくとも1つがtrueである場合にtrueになります。

**構文**

```sql
bitTestAny(a, index1[, index2, ... , indexN])
```

**引数**

- `a` — 整数値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `index1, ...` — ビット位置を示す1つまたは複数の値。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

論理和の結果を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例 1**

```sql title=クエリ
SELECT bitTestAny(43, 0, 2);
```

```response title=結果
┌─bin(43)──┬─bitTestAny(43, 0, 2)─┐
│ 00101011 │                    1 │
└──────────┴──────────────────────┘
```

**使用例 2**

```sql title=クエリ
SELECT bitTestAny(43, 4, 2);
```

```response title=結果
┌─bin(43)──┬─bitTestAny(43, 4, 2)─┐
│ 00101011 │                    0 │
└──────────┴──────────────────────┘
```


## bitXor {#bitXor}

導入バージョン: v1.1

2つの値に対してビット単位の排他的論理和（XOR）演算を実行します。

**構文**

```sql
bitXor(a, b)
```

**引数**

- `a` — 1つ目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)
- `b` — 2つ目の値。[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)

**戻り値**

ビット演算 `a XOR b` の結果を返します。

**例**

**使用例**

```sql title=クエリ
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitXor(a, b)
FROM bits;
```

```response title=レスポンス
┌─a─┬─b─┬─bitXor(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            1 │
│ 1 │ 0 │            1 │
│ 1 │ 1 │            0 │
└───┴───┴──────────────┘
```

<!--AUTOGENERATED_END-->

---
'description': 'Bit Functionsのドキュメント'
'sidebar_label': 'Bit'
'slug': '/sql-reference/functions/bit-functions'
'title': 'ビット関数'
'doc_type': 'reference'
---


# ビット関数

ビット関数は、`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64`、`Float32`、または`Float64`の任意の型のペアに対して動作します。一部の関数は`String`および`FixedString`型をサポートしています。

結果の型は、その引数の最大ビット数と等しい整数です。引数のうち少なくとも1つが符号付きであれば、結果は符号付きの数になります。引数が浮動小数点数である場合、`Int64`にキャストされます。

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## bitAnd {#bitAnd}

導入されたバージョン: v1.1

2つの値の間でビット単位のAND演算を行います。

**構文**

```sql
bitAnd(a, b)
```

**引数**

- `a` — 最初の値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)
- `b` — 2番目の値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)


**返される値**

ビット演算の結果`a AND b`を返します。

**例**

**使用例**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitAnd(a, b)
FROM bits
```

```response title=Response
┌─a─┬─b─┬─bitAnd(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            0 │
│ 1 │ 0 │            0 │
│ 1 │ 1 │            1 │
└───┴───┴──────────────┘
```



## bitCount {#bitCount}

導入されたバージョン: v20.3

数の二進数表現において、1に設定されたビットの数を計算します。

**構文**

```sql
bitCount(x)
```

**引数**

- `x` — 整数または浮動小数点値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)


**返される値**

`x`において1に設定されたビットの数を返します。 [`UInt8`](../data-types/int-uint.md)。

:::note
この関数は入力値をより大きな型に変換しません（[符号拡張](https://en.wikipedia.org/wiki/Sign_extension)）。
例えば: `bitCount(toUInt8(-1)) = 8`。
:::

**例**

**使用例**

```sql title=Query
SELECT bin(333), bitCount(333);
```

```response title=Response
┌─bin(333)─────────┬─bitCount(333)─┐
│ 0000000101001101 │             5 │
└──────────────────┴───────────────┘
```



## bitHammingDistance {#bitHammingDistance}

導入されたバージョン: v21.1


2つの数のビット表現間の[ハミング距離](https://en.wikipedia.org/wiki/Hamming_distance)を返します。
半重複文字列の検出のために[`SimHash`](../../sql-reference/functions/hash-functions.md#ngramSimHash)関数と一緒に使用できます。
距離が小さいほど、文字列は類似しています。


**構文**

```sql
bitHammingDistance(x, y)
```

**引数**

- `x` — ハミング距離計算のための最初の数。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)
- `y` — ハミング距離計算のための2番目の数。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)


**返される値**

`x`と`y`の間のハミング距離を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bitHammingDistance(111, 121);
```

```response title=Response
┌─bitHammingDistance(111, 121)─┐
│                            3 │
└──────────────────────────────┘
```



## bitNot {#bitNot}

導入されたバージョン: v1.1

ビット単位のNOT演算を行います。

**構文**

```sql
bitNot(a)
```

**引数**

- `a` — ビット単位のNOT演算を適用する値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)または[`String`](/sql-reference/data-types/string)


**返される値**

`~a`、つまりビットが反転された`a`の結果を返します。

**例**

**使用例**

```sql title=Query
SELECT
    CAST('5', 'UInt8') AS original,
    bin(original) AS original_binary,
    bitNot(original) AS result,
    bin(bitNot(original)) AS result_binary;
```

```response title=Response
┌─original─┬─original_binary─┬─result─┬─result_binary─┐
│        5 │ 00000101        │    250 │ 11111010      │
└──────────┴─────────────────┴────────┴───────────────┘
```



## bitOr {#bitOr}

導入されたバージョン: v1.1

2つの値の間でビット単位のOR演算を行います。

**構文**

```sql
bitOr(a, b)
```

**引数**

- `a` — 最初の値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)
- `b` — 2番目の値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)


**返される値**

ビット演算の結果`a OR b`を返します。

**例**

**使用例**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitOr(a, b)
FROM bits;
```

```response title=Response
┌─a─┬─b─┬─bitOr(a, b)─┐
│ 0 │ 0 │           0 │
│ 0 │ 1 │           1 │
│ 1 │ 0 │           1 │
│ 1 │ 1 │           1 │
└───┴───┴─────────────┘
```



## bitRotateLeft {#bitRotateLeft}

導入されたバージョン: v1.1

ビットを特定の位置数だけ左に回転させます。 外れたビットは右に巻き戻されます。

**構文**

```sql
bitRotateLeft(a, N)
```

**引数**

- `a` — 回転する値。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `N` — 左に回転させる位置の数。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**返される値**

`a`の型に等しい回転値を返します。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT 99 AS a, bin(a), bitRotateLeft(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=Response
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       141 │ 10001101       │
└────┴──────────┴───────────┴────────────────┘
```



## bitRotateRight {#bitRotateRight}

導入されたバージョン: v1.1

ビットを特定の位置数だけ右に回転させます。 外れたビットは左に巻き戻されます。

**構文**

```sql
bitRotateRight(a, N)
```

**引数**

- `a` — 回転する値。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `N` — 右に回転させる位置の数。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**返される値**

`a`の型に等しい回転値を返します。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT 99 AS a, bin(a), bitRotateRight(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=Response
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       216 │ 11011000       │
└────┴──────────┴───────────┴────────────────┘
```



## bitShiftLeft {#bitShiftLeft}

導入されたバージョン: v1.1


値の二進数表現を指定したビット位置数だけ左にシフトします。

`FixedString`または`String`は1つのマルチバイト値として扱われます。

`FixedString`値のビットは、シフトアウトされると失われます。
対照的に、`String`値は追加のバイトで拡張されるため、ビットは失われません。


**構文**

```sql
bitShiftLeft(a, N)
```

**引数**

- `a` — シフトする値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `N` — シフトする位置数。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**返される値**

`a`の型に等しいシフト値を返します。

**例**

**バイナリエンコーディングの使用例**

```sql title=Query
SELECT 99 AS a, bin(a), bitShiftLeft(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=Response
┌──a─┬─bin(99)──┬─a_shifted─┬─bin(bitShiftLeft(99, 2))─┐
│ 99 │ 01100011 │       140 │ 10001100                 │
└────┴──────────┴───────────┴──────────────────────────┘
```

**16進数エンコーディングの使用例**

```sql title=Query
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftLeft('abc', 4))─┐
│ abc │ 616263     │ &0        │ 06162630                    │
└─────┴────────────┴───────────┴─────────────────────────────┘
```

**Fixed Stringエンコーディングの使用例**

```sql title=Query
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftLeft(toFixedString('abc', 3), 4))─┐
│ abc │ 616263                       │ &0        │ 162630                                        │
└─────┴──────────────────────────────┴───────────┴───────────────────────────────────────────────┘
```



## bitShiftRight {#bitShiftRight}

導入されたバージョン: v1.1


値の二進数表現を指定したビット位置数だけ右にシフトします。

`FixedString`または`String`は1つのマルチバイト値として扱われます。

`FixedString`値のビットは、シフトアウトされると失われます。
対照的に、`String`値は追加のバイトで拡張されるため、ビットは失われません。


**構文**

```sql
bitShiftRight(a, N)
```

**引数**

- `a` — シフトする値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `N` — シフトする位置数。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**返される値**

`a`の型に等しいシフト値を返します。

**例**

**バイナリエンコーディングの使用例**

```sql title=Query
SELECT 101 AS a, bin(a), bitShiftRight(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=Response
┌───a─┬─bin(101)─┬─a_shifted─┬─bin(bitShiftRight(101, 2))─┐
│ 101 │ 01100101 │        25 │ 00011001                   │
└─────┴──────────┴───────────┴────────────────────────────┘
```

**16進数エンコーディングの使用例**

```sql title=Query
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftRight('abc', 12))─┐
│ abc │ 616263     │           │ 0616                          │
└─────┴────────────┴───────────┴───────────────────────────────┘
```

**Fixed Stringエンコーディングの使用例**

```sql title=Query
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftRight(a, 12) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftRight(toFixedString('abc', 3), 12))─┐
│ abc │ 616263                       │           │ 000616                                          │
└─────┴──────────────────────────────┴───────────┴─────────────────────────────────────────────────┘
```



## bitSlice {#bitSlice}

導入されたバージョン: v22.2

`offset`インデックスから始まり、`length`ビット長のサブストリングを返します。

**構文**

```sql
bitSlice(s, offset[, length])
```

**引数**

- `s` — スライスするStringまたはFixed String。 [`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `offset` — 
開始ビット位置を返します（1ベースのインデックス付け）。
- 正の値: 文字列の先頭からカウントします。
- 負の値: 文字列の末尾からカウントします。

         [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)
- `length` — 
オプション。抽出するビット数。
- 正の値: `length`ビットを抽出します。
- 負の値: オフセットから`(string_length - |length|)`まで抽出します。
- 省略時: オフセットから文字列の末尾まで抽出します。
- 長さが8の倍数でない場合、結果は右側にゼロでパディングされます。
         [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)


**返される値**

抽出されたビットを含む文字列を返します。結果は常にバイト境界（8ビットの倍数）にパディングされます。 [`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 8));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 2));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 9));
SELECT bin('Hello'), bin(bitSlice('Hello', -4, 8));
```

```response title=Response
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 8))─┐
│ 0100100001100101011011000110110001101111 │ 01001000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 2))─┐
│ 0100100001100101011011000110110001101111 │ 01000000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 9))─┐
│ 0100100001100101011011000110110001101111 │ 0100100000000000             │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', -4, 8))─┐
│ 0100100001100101011011000110110001101111 │ 11110000                      │
└──────────────────────────────────────────┴───────────────────────────────┘
```



## bitTest {#bitTest}

導入されたバージョン: v1.1

任意の数を取り、[バイナリ形式](https://en.wikipedia.org/wiki/Binary_number)に変換した後、指定された位置にあるビットの値を返します。カウントは右から左へ行い、0から始まります。

**構文**

```sql
bitTest(a, i)
```

**引数**

- `a` — 変換する数。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)
- `i` — 戻り値のビットの位置。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)


**返される値**

`a`の二進数表現における位置`i`のビットの値を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT bin(2), bitTest(2, 1);
```

```response title=Response
┌─bin(2)───┬─bitTest(2, 1)─┐
│ 00000010 │             1 │
└──────────┴───────────────┘
```



## bitTestAll {#bitTestAll}

導入されたバージョン: v1.1


指定された位置にあるすべてのビットの[論理共役](https://en.wikipedia.org/wiki/Logical_conjunction)（AND演算子）の結果を返します。
カウントは右から左へ行い、0から始まります。

2つのビット間の論理ANDは、両方の入力ビットが真である場合にのみ真です。
    

**構文**

```sql
bitTestAll(a, index1[, index2, ... , indexN])
```

**引数**

- `a` — 整数値。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `index1, ...` — 1つまたは複数のビットの位置。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)


**返される値**

論理共役の結果を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例 1**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(43, 0, 1, 3, 5)─┐
│ 00101011 │                          1 │
└──────────┴────────────────────────────┘
```

**使用例 2**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(4⋯1, 3, 5, 2)─┐
│ 00101011 │                        0 │
└──────────┴──────────────────────────┘
```



## bitTestAny {#bitTestAny}

導入されたバージョン: v1.1


指定された位置にあるすべてのビットの[論理選言](https://en.wikipedia.org/wiki/Logical_disjunction)（OR演算子）の結果を返します。
カウントは右から左へ行い、0から始まります。

2つのビット間の論理ORは、少なくとも1つの入力ビットが真である場合にのみ真です。
    

**構文**

```sql
bitTestAny(a, index1[, index2, ... , indexN])
```

**引数**

- `a` — 整数値。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `index1, ...` — 1つまたは複数のビットの位置。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)


**返される値**

論理選言の結果を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例 1**

```sql title=Query
SELECT bitTestAny(43, 0, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAny(43, 0, 2)─┐
│ 00101011 │                    1 │
└──────────┴──────────────────────┘
```

**使用例 2**

```sql title=Query
SELECT bitTestAny(43, 4, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAny(43, 4, 2)─┐
│ 00101011 │                    0 │
└──────────┴──────────────────────┘
```



## bitXor {#bitXor}

導入されたバージョン: v1.1

2つの値の間でビット単位の排他的OR（XOR）演算を行います。

**構文**

```sql
bitXor(a, b)
```

**引数**

- `a` — 最初の値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)
- `b` — 2番目の値。 [`(U)Int*`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)


**返される値**

ビット演算の結果`a XOR b`を返します。

**例**

**使用例**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitXor(a, b)
FROM bits;
```

```response title=Response
┌─a─┬─b─┬─bitXor(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            1 │
│ 1 │ 0 │            1 │
│ 1 │ 1 │            0 │
└───┴───┴──────────────┘
```



<!--AUTOGENERATED_END-->

---
description: '配列関数のドキュメント'
sidebar_label: '配列'
slug: /sql-reference/functions/array-functions
title: '配列関数'
doc_type: 'reference'
---

# 配列関数 \{#array-functions\}

{/* 
  以下のタグの内側のコンテンツは、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントで置き換えられます。タグを変更または削除しないでください。
  詳細は次を参照してください: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }


## array \{#array\}

導入バージョン: v1.1

関数の引数から配列を作成します。

引数は定数であり、共通のスーパータイプを持つ型でなければなりません。
少なくとも 1 つの引数を渡す必要があります。そうしないと、どの型の配列を作成するかが明確になりません。
つまり、この関数を使用して空の配列を作成することはできません。空の配列を作成するには、`emptyArray*` 関数を使用してください。

同様の機能には `[ ]` 演算子を使用できます。

**構文**

```sql
array(x1 [, x2, ..., xN])
```

**引数**

* `x1` — 任意の型 T の定数値。この引数だけが指定された場合、配列の型は T になります。
* `[, x2, ..., xN]` — `x1` と共通のスーパータイプを持つ、追加の N 個の定数値。

**返される値**

渡された引数から求められる最小の共通型 `T` を要素型とする配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**有効な使用例**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**無効な使い方**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```


## arrayAUCPR \{#arrayAUCPR\}

導入バージョン: v20.4

適合率–再現率 (PR) 曲線の下側の面積を計算します。
適合率–再現率 (PR) 曲線は、すべてのしきい値について、縦軸に適合率、横軸に再現率をプロットすることで作成します。
得られる値は 0 から 1 の範囲を取り、値が大きいほどモデルの性能が高いことを示します。
PR AUC は不均衡なデータセットに対して特に有用であり、そのようなケースでは ROC AUC と比べて性能をより明確に比較できます。
詳細については [こちら](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[こちら](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)、および [こちら](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve) を参照してください。

**構文**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**別名**: `arrayPRAUC`

**引数**

* `cores` — 予測モデルが出力するスコア値。[`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — サンプルのラベル。通常、正例には 1、負例には 0 を指定します。[`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Enum)`](/sql-reference/data-types/array)
* `partial_offsets` —
* 省略可能。PR 曲線全体の AUC ではなく、PR 曲線の一部の面積（PR 空間の縦方向の帯域に相当）を計算するための、3 つの非負整数からなる [`Array(T)`](/sql-reference/data-types/array)。このオプションは PR AUC の分散計算に便利です。配列には次の要素を含める必要があります：[`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]。
  * `higher_partitions_tp`: より高いスコアのパーティション内の正例ラベル数。
  * `higher_partitions_fp`: より高いスコアのパーティション内の負例ラベル数。
  * `total_positives`: データセット全体における正例サンプルの総数。

:::note
`arr_partial_offsets` を使用する場合、`arr_scores` と `arr_labels` には、スコアのある区間を含むデータセット全体のうちの 1 つのパーティションだけを含める必要があります。
データセットは連続したパーティションに分割し、各パーティションにはスコアが特定の範囲に入るデータのサブセットを含める必要があります。
例えば次のようになります：

* あるパーティションには [0, 0.5) の範囲のすべてのスコアを含める。
* 別のパーティションには [0.5, 1.0] の範囲のスコアを含める。
  :::

**返される値**

適合率–再現率 (PR) 曲線の下の面積を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll \{#arrayAll\}

導入バージョン: v1.1

ラムダ `func(x [, y1, y2, ... yN])` がすべての要素に対して true を返す場合は `1` を返し、そうでない場合は `0` を返します。

**構文**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — 省略可能。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ラムダ関数がすべての要素に対して true を返す場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**すべての要素が一致する**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**すべての要素が一致しているとは限りません**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg \{#arrayAvg\}

導入バージョン: v21.1

配列の要素の平均値を返します。

ラムダ関数 `func` が指定された場合は、そのラムダの適用結果の要素の平均値を返します。

**構文**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 省略可。ソース配列（`x`）および条件配列（`y`）の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を与えるための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

ソース配列内の要素の平均値、またはラムダ関数が指定されている場合はその結果要素の平均値を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**基本的な例**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**lambda 関数での利用方法**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```


## arrayCompact \{#arrayCompact\}

導入バージョン: v20.1

配列から連続する重複要素（`null` 値も含む）を削除します。結果の配列内の値の順序は、元の配列内での順序に従います。

**構文**

```sql
arrayCompact(arr)
```

**引数**

* `arr` — 重複を削除する対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

重複を取り除いた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```


## arrayConcat \{#arrayConcat\}

導入バージョン: v1.1

引数として渡された配列を結合します。

**構文**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**引数**

* `arr1 [, arr2, ... , arrN]` — 連結する N 個の配列です。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

指定された配列引数を結合した 1 つの配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```


## arrayCount \{#arrayCount\}

導入バージョン: v1.1

`func(arr1[i], ..., arrN[i])` が true を返す要素の数を返します。
`func` が指定されていない場合、配列内のゼロ以外の要素の数を返します。

`arrayCount` は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arrayCount([func, ] arr1, ...)
```

**引数**

* `func` — 省略可能。配列の各要素に適用する関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1, ..., arrN` — N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

`func` が true を返す要素数を返します。指定されていない場合は、配列内の 0 以外の要素数を返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```


## arrayCumSum \{#arrayCumSum\}

導入バージョン: v1.1

元の配列の要素に対する部分和（累積和）からなる配列を返します。`lambda` 関数が指定されている場合、各位置の配列要素に `lambda` を適用した結果について和が計算されます。

**構文**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**引数**

* `func` — 省略可。各位置の配列要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — 数値を要素とする元の配列。[`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — 省略可。同じサイズの追加配列で、指定されている場合はラムダ関数への引数として渡されます。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

元の配列内の要素について、その部分和を要素とする配列を返します。結果の型は入力配列の要素の数値型と一致します。[`Array(T)`](/sql-reference/data-types/array)

**使用例**

**基本的な使い方**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**ラムダあり**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```


## arrayCumSumNonNegative \{#arrayCumSumNonNegative\}

導入されたバージョン: v18.12

元の配列の要素について、累積部分和（ランニングサム）の配列を返し、累積和が負になった場合はゼロに置き換えます。ラムダ関数が指定されている場合は、各位置の配列要素にラムダを適用した結果に対して和が計算されます。

**構文**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**引数**

* `func` — 省略可能。各位置の配列要素に適用するラムダ関数です。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — 数値を要素とする元の配列。[`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — 省略可能。同じサイズの追加の配列。指定されている場合、ラムダ関数への引数として渡されます。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

元の配列内の要素の部分和からなる配列を返します。このとき、累積和が負の値になった場合は 0 に置き換えられます。結果の型は入力配列の数値型と一致します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使い方**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**ラムダ使用時**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```


## arrayDifference \{#arrayDifference\}

導入バージョン: v1.1

配列内の隣接する要素同士の差分から成る配列を返します。
結果の配列の最初の要素は 0、2 番目は `arr[1] - arr[0]`、3 番目は `arr[2] - arr[1]` というように続きます。
結果の配列内の要素の型は減算に関する型推論ルールによって決定されます（例: `UInt8` - `UInt8` = `Int16`）。

**構文**

```sql
arrayDifference(arr)
```

**引数**

* `arr` — 配列の隣接要素間の差分を計算する対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

配列の隣接要素間の差分を要素とする配列を返します。型は [`UInt*`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**結果型が Int64 の場合のオーバーフロー例**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct \{#arrayDistinct\}

導入バージョン: v1.1

配列から重複した要素を取り除いた配列を返します。

**構文**

```sql
arrayDistinct(arr)
```

**引数**

* `arr` — 重複しない要素を抽出する対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

重複しない要素のみを含む配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct \{#arrayDotProduct\}

導入バージョン: v23.5

2つの配列の内積を返します。

:::note
2つのベクトルのサイズは等しくなければなりません。Array および Tuple には、異なる型の要素を混在させることもできます。
:::

**構文**

```sql
arrayDotProduct(v1, v2)
```

**引数**

* `v1` — 1つ目のベクトル。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) または [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
* `v2` — 2つ目のベクトル。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) または [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**返される値**

2つのベクトルのドット積を返します。

:::note
戻り値の型は引数の型によって決まります。Array または Tuple に要素型が混在している場合、結果の型はそれらのスーパータイプになります。
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)

**例**

**Array の例**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**タプルの例**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement \{#arrayElement\}

導入バージョン: v1.1

`n` を任意の整数型として、指定された配列のインデックス `n` の要素を取得します。
インデックスが配列の範囲外の場合は、デフォルト値（数値は 0、文字列は空文字列など）を返します。
ただし、配列引数が非定数で、インデックスに定数 0 を指定した場合は例外で、この場合は `Array indices are 1-based` というエラーが発生します。

:::note
ClickHouse の配列はインデックスが 1 始まりです。
:::

負のインデックスもサポートされています。この場合、末尾から数えた要素が選択されます。たとえば、`arr[-1]` は配列の最後の要素です。

演算子 `[n]` は同じ機能を提供します。

**構文**

```sql
arrayElement(arr, n)
```

**引数**

* `arr` — 検索対象の配列。[`Array(T)`](/sql-reference/data-types/array)。
* `n` — 取得する要素の位置。[`(U)Int*`](/sql-reference/data-types/int-uint)。

**返り値**

指定された配列引数から結合された単一の配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**使用例**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**負のインデックス**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**[n] 記法の使用**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**配列範囲外のインデックス**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```


## arrayElementOrNull \{#arrayElementOrNull\}

導入バージョン: v1.1

指定された配列の、インデックス `n` の要素を取得します。`n` には任意の整数型を指定できます。
インデックスが配列の範囲外の場合、デフォルト値ではなく `NULL` が返されます。

:::note
ClickHouse の配列のインデックスは 1 始まりです。
:::

負のインデックスもサポートされています。この場合、末尾から数えた位置に対応する要素が選択されます。例えば、`arr[-1]` は配列の最後の要素です。

**構文**

```sql
arrayElementOrNull(arrays)
```

**引数**

* `arrays` — 任意の数の配列引数。[`Array`](/sql-reference/data-types/array)

**戻り値**

渡された配列引数を結合し、1 つの配列として返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**負のインデックス**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**配列範囲外の添字**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```


## arrayEnumerate \{#arrayEnumerate\}

導入バージョン: v1.1

配列 `[1, 2, 3, ..., length (arr)]` を返します。

この関数は通常、[`ARRAY JOIN`](/sql-reference/statements/select/array-join) 句と一緒に使用します。`ARRAY JOIN` を適用した後に、各配列ごとに 1 回だけ集計を行えるようにします。
この関数は高階関数でも使用できます。たとえば、ある条件に一致する要素の配列内インデックスを取得するために使用できます。

**構文**

```sql
arrayEnumerate(arr)
```

**引数**

* `arr` — 列挙する配列。[`Array`](/sql-reference/data-types/array)

**返り値**

配列 `[1, 2, 3, ..., length(arr)]` を返します。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**ARRAY JOIN を使用した基本的な例**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense \{#arrayEnumerateDense\}

導入バージョン: v18.12

元の配列と同じサイズの配列を返します。各要素は、元の配列内でその要素が最初に出現する位置を表します。

**構文**

```sql
arrayEnumerateDense(arr)
```

**引数**

* `arr` — 列挙する配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

`arr` と同じサイズの配列を返します。各要素について、その要素が元の配列 [`Array(T)`](/sql-reference/data-types/array) 内で最初に出現する位置を示します。

**例**

**使用例**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked \{#arrayEnumerateDenseRanked\}

導入バージョン: v20.1

元の配列と同じサイズの配列を返し、元の配列内で各要素が最初に出現する位置を示します。多次元配列を列挙する際に、配列のどの深さまでたどるかを指定できます。

**構文**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**引数**

* `clear_depth` — 指定したレベルの要素を個別に列挙します。`max_arr_depth` 以下でなければなりません。[`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — 列挙対象の N 次元の配列。[`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — 有効な最大深さ。`arr` の深さ以下でなければなりません。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

各要素が元の配列内で最初に出現する位置を示す配列を返します。[`Array`](/sql-reference/data-types/array)

**例**

**基本的な使い方**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result is identical to what arrayEnumerateDense would give.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**多次元配列での使用**

```sql title=Query
-- In this example, arrayEnumerateDenseRanked is used to obtain an array indicating, for each element of the
-- multidimensional array, what its position is among elements of the same value.
-- For the first row of the passed array, [10, 10, 30, 20], the corresponding first row of the result is [1, 1, 2, 3],
-- indicating that 10 is the first number encountered in position 1 and 2, 30 the second number encountered in position 3
-- and 20 is the third number encountered in position 4.
-- For the second row, [40, 50, 10, 30], the corresponding second row of the result is [4,5,1,2], indicating that 40
-- and 50 are the fourth and fifth numbers encountered in position 1 and 2 of that row, that another 10
-- (the first encountered number) is in position 3 and 30 (the second number encountered) is in the last position.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**clear&#95;depth を増加させた例**

```sql title=Query
-- Changing clear_depth=2 results in the enumeration occurring separately for each row anew.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq \{#arrayEnumerateUniq\}

導入バージョン: v1.1

元の配列と同じ長さの配列を返し、各要素について、その値を持つ要素群の中での出現順序を示します。

この関数は、`ARRAY JOIN` と配列要素の集約を行う際に有用です。

この関数は、同じ長さの複数の配列を引数として受け取ることができます。この場合、一意性は、すべての配列で同じ位置にある要素からなるタプル単位で判定されます。

**構文**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**引数**

* `arr1` — 処理対象となる最初の配列。 [`Array(T)`](/sql-reference/data-types/array)
* `arr2, ...` — オプション。同じサイズの、タプルの一意性判定に使用する追加の配列。 [`Array(UInt32)`](/sql-reference/data-types/array)

**返り値**

各要素が、同じ値またはタプルを持つ要素同士の中での位置（順位）を表す配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**使用例**

**基本的な使い方**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**複数の配列**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**ARRAY JOIN を用いた集約**

```sql title=Query
-- Each goal ID has a calculation of the number of conversions (each element in the Goals nested data structure is a goal that was reached, which we refer to as a conversion)
-- and the number of sessions. Without ARRAY JOIN, we would have counted the number of sessions as sum(Sign). But in this particular case,
-- the rows were multiplied by the nested Goals structure, so in order to count each session one time after this, we apply a condition to the
-- value of the arrayEnumerateUniq(Goals.ID) function.

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked \{#arrayEnumerateUniqRanked\}

導入バージョン: v20.1

元の配列と同じ次元を持つ配列（または多次元配列）を返します。
各要素について、その要素と同じ値を持つ要素の中での位置を示します。
多次元配列を列挙する際に、配列のどの深さまで処理するかを指定できます。

**構文**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**引数**

* `clear_depth` — 指定したレベルの要素を個別に列挙します。`max_arr_depth` 以下の正の整数。[`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — 列挙対象の N 次元配列。[`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — 有効な最大の深さ。`arr` の深さ以下の正の整数。[`UInt*`](/sql-reference/data-types/int-uint)

**返される値**

`arr` と同じサイズの N 次元配列を返し、各要素には、同じ値を持つ要素同士の中でのその要素の位置が示されます。[`Array(T)`](/sql-reference/data-types/array)

**例**

**例 1**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniq would give for the same array.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**例2**

```sql title=Query
-- with clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniqwould give for the same array.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**例3**

```sql title=Query
-- In this example, arrayEnumerateUniqRanked is used to obtain an array indicating,
-- for each element of the multidimensional array, what its position is among elements
-- of the same value. For the first row of the passed array, [1, 2, 3], the corresponding
-- result is [1, 1, 1], indicating that this is the first time 1, 2 and 3 are encountered.
-- For the second row of the provided array, [2, 2, 1], the corresponding result is [2, 3, 3],
-- indicating that 2 is encountered for a second and third time, and 1 is encountered
-- for the second time. Likewise, for the third row of the provided array [3] the
-- corresponding result is [2] indicating that 3 is encountered for the second time.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**例4**

```sql title=Query
-- Changing clear_depth=2, results in elements being enumerated separately for each row.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept \{#arrayExcept\}

導入: v25.9

`except` に存在しない `source` の要素だけを、元の順序を保った配列として返します。

この関数は、2 つの配列の差集合演算を実行します。`source` の各要素について、その要素が `except` に存在するか（厳密な比較を用いて）確認します。存在しない場合、その要素は結果に含まれます。

この演算は次の性質を持ちます:

1. `source` における要素の順序は保持される
2. `except` に存在しない場合、`source` 内の重複要素は保持される
3. NULL は別個の値として扱われる

**構文**

```sql
arrayExcept(source, except)
```

**引数**

* `source` — フィルタリング対象となる要素を含む元の配列。  [`Array(T)`](/sql-reference/data-types/array)
* `except` — 結果から除外する要素を含む配列。  [`Array(T)`](/sql-reference/data-types/array)

**返される値**

入力配列と同じ型で、`source` のうち `except` に含まれない要素だけを含む配列を返します。  [`Array(T)`](/sql-reference/data-types/array)

**例**

**基本例**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with&#95;nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with&#95;nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**文字列**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```


## arrayExists \{#arrayExists\}

導入: v1.1

ソース配列内に、`func(x[, y1, y2, ... yN])` が true を返す要素が 1 つ以上存在する場合は `1` を返します。存在しない場合は `0` を返します。

**構文**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

少なくとも 1 つの要素でラムダ関数が true を返した場合は `1` を、そうでない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```


## arrayFill \{#arrayFill\}

導入バージョン: v20.1

`arrayFill` 関数は、ソース配列を最初の要素から最後の要素まで順に処理し、
ソース配列および条件配列の要素を用いて、各位置でラムダ条件を評価します。
位置 i においてラムダ関数の評価結果が false を返した場合、その要素は、
配列の現在の状態における位置 i-1 の要素で置き換えられます。
最初の要素は、条件に関わらず常にそのまま保持されます。

**構文**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x [, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数 `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を渡す N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

配列 [`Array(T)`](/sql-reference/data-types/array) を返します。

**例**

**単一配列の例**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**2つの配列を使用した例**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```


## arrayFilter \{#arrayFilter\}

導入: v1.1

ソース配列の各要素にラムダ関数を適用し、その結果が true を返す要素だけを含む配列を返します。

**構文**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列の一部（サブセット）を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**例 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**例 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```


## arrayFirst \{#arrayFirst\}

導入: v1.1

`func(x[, y1, y2, ... yN])` が true を返すソース配列内の最初の要素を返します。該当する要素がない場合はデフォルト値を返します。

**構文**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) と条件配列 (`y`) の要素に適用されるラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。 - `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)。 - `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数として渡す N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

`λ` が真となる最初のソース配列要素を返し、該当する要素がない場合は `T` 型のデフォルト値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**一致なし**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayFirstIndex \{#arrayFirstIndex\}

導入バージョン: v1.1

`func(x[, y1, y2, ... yN])` が true を返す最初の要素の索引を元の配列の中から返し、該当する要素がない場合は &#39;0&#39; を返します。

**構文**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

`func` が true を返すソース配列の最初の要素のインデックスを返し、それ以外の場合は `0` を返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**一致なし**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```


## arrayFirstOrNull \{#arrayFirstOrNull\}

導入バージョン: v1.1

`func(x[, y1, y2, ... yN])` が true を返すソース配列内の最初の要素を返します。該当する要素がない場合は `NULL` を返します。

**構文**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`func` が true となるソース配列の最初の要素を返し、それ以外の場合は `NULL` を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**一致するものがありません**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayFlatten \{#arrayFlatten\}

導入バージョン: v20.1

配列の配列をフラットな配列に変換します。

関数:

* 任意の深さにネストされた配列に適用できます。
* すでにフラットな配列は変更しません。

フラット化された配列には、元のすべての配列に含まれる要素がすべて含まれます。

**構文**

```sql
arrayFlatten(arr)
```

**エイリアス**: `flatten`

**引数**

* `arr` — 多次元配列。[`Array(Array(T))`](/sql-reference/data-types/array)

**返り値**

多次元配列を平坦化した配列 [`Array(T)`](/sql-reference/data-types/array) を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```


## arrayFold \{#arrayFold\}

導入バージョン: v23.10

1 つ以上の同じ長さの配列にラムダ関数を適用し、その結果をアキュムレータに蓄積します。

**構文**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**引数**

* `λ(x, x1 [, x2, x3, ... xN])` — ラムダ関数 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`。ここで `F` は、`acc` と `x` からの配列要素に適用される演算であり、その結果が次回以降の `acc` として再利用されます。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1 [, arr2, arr3, ... arrN]` — 演算対象となる N 個の配列。[`Array(T)`](/sql-reference/data-types/array)
* `acc` — 累積値。ラムダ関数の戻り値と同じ型を持ちます。

**戻り値**

最終的な `acc` の値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**フィボナッチ数列**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**複数の配列を使用する例**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```


## arrayIntersect \{#arrayIntersect\}

導入バージョン: v1.1

複数の配列を引数に取り、すべての入力配列に存在する要素からなる配列を返します。結果には一意の値のみが含まれます。

**構文**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**引数**

* `arrN` — 新しい配列を作成するための N 個の配列。[`Array(T)`](/sql-reference/data-types/array)。

**返される値**

N 個すべての配列に含まれる要素だけからなる重複のない配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**使用例**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex \{#arrayJaccardIndex\}

導入バージョン: v23.7

2つの配列の [Jaccard指数](https://en.wikipedia.org/wiki/Jaccard_index) を返します。

**構文**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**引数**

* `arr_x` — 1 番目の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — 2 番目の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr_x` と `arr_y` の Jaccard 指数を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin \{#arrayJoin\}

導入バージョン: v1.1

`arrayJoin` 関数は、配列を含む行を入力として受け取り、それを展開して複数の行を生成します — 配列内の各要素ごとに 1 行ずつ生成されます。
これは、同じ行の中で入力値を出力値に対応付ける ClickHouse の通常の関数や、
複数の行を 1 つの要約行（`GROUP BY` と併用した場合は要約行内の 1 つの値）に「圧縮」または「集約」する集約関数とは対照的です。

この関数が適用されるカラム以外のすべてのカラムの値は、そのまま単純にコピーされます。
該当カラムの値だけが、対応する配列要素の値に置き換えられます。

**構文**

```sql
arrayJoin(arr)
```

**引数**

* `arr` — 展開する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr` から展開された行の集合を返します。

**例**

**基本的な使い方**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin はクエリのすべての句に影響します**

```sql title=Query
-- The arrayJoin function affects all sections of the query, including the WHERE section. Notice the result 2, even though the subquery returned 1 row.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**複数の arrayJoin 関数の併用**

```sql title=Query
- A query can use multiple arrayJoin functions. In this case, the transformation is performed multiple times and the rows are multiplied.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**最適化による予期せぬ結果**

```sql title=Query
-- Using multiple arrayJoin with the same expression may not produce the expected result due to optimizations.
-- For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.
- e.g. arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set
    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─first_throw─┬─second_throw─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**ARRAY JOIN 構文の使い方**

```sql title=Query
-- Note the ARRAY JOIN syntax in the `SELECT` query below, which provides broader possibilities.
-- ARRAY JOIN allows you to convert multiple arrays with the same number of elements at a time.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Tuple の使用**

```sql title=Query
-- You can also use Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast \{#arrayLast\}

導入バージョン: v1.1

ソース配列の要素のうち、ラムダ `func(x [, y1, y2, ... yN])` が true を返す最後の要素を返します。該当する要素がない場合は、デフォルト値を返します。

**構文**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素に対して動作するラムダ関数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)

- `source` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1, ... , condN]` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`func` が true になるソース配列の最後の要素を返します。それ以外の場合は `T` のデフォルト値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**一致なし**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayLastIndex \{#arrayLastIndex\}

導入バージョン: v1.1

`func(x[, y1, y2, ... yN])` が true を返す、元の配列内で最後に現れる要素の索引を返します。該当する要素がない場合は &#39;0&#39; を返します。

**構文**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

`func` が true になるソース配列の最後の要素のインデックスを返し、該当する要素がない場合は `0` を返す。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**一致する要素なし**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull \{#arrayLastOrNull\}

導入: v1.1

ラムダ式 `func(x [, y1, y2, ... yN])` が true を返す、入力配列の要素のうち最後のものを返します。該当する要素がない場合は `NULL` を返します。

**構文**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x [, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素を処理するラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)
  * `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
  * `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に渡される追加の引数を提供する、N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`λ` が真ではないソース配列の最後の要素を返し、それ以外の場合は `NULL` を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**一致なし**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance \{#arrayLevenshteinDistance\}

導入バージョン: v25.4

2つの配列間のレーベンシュタイン距離を計算します。

**構文**

```sql
arrayLevenshteinDistance(from, to)
```

**引数**

* `from` — 1番目の配列。[`Array(T)`](/sql-reference/data-types/array). - `to` — 2番目の配列。[`Array(T)`](/sql-reference/data-types/array).

**戻り値**

1番目と2番目の配列間の Levenshtein 距離。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```


## arrayLevenshteinDistanceWeighted \{#arrayLevenshteinDistanceWeighted\}

導入: v25.4

2つの配列に対して、各要素ごとに任意の重みを指定して Levenshtein 距離を計算します。
配列と重み配列の要素数は一致している必要があります。

**構文**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**引数**

* `from` — 第 1 配列。[`Array(T)`](/sql-reference/data-types/array). - `to` — 第 2 配列。[`Array(T)`](/sql-reference/data-types/array). - `from_weights` — 第 1 配列に対する重み。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — 第 2 配列に対する重み。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**戻り値**

各要素に対するカスタムの重みを用いた、第 1 配列と第 2 配列間の Levenshtein 距離。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```


## arrayMap \{#arrayMap\}

導入バージョン: v1.1

元の配列の各要素にラムダ関数を適用した結果の配列を返します。

**構文**

```sql
arrayMap(func, arr)
```

**引数**

* `func` — ソース配列（`x`）および条件配列（`y`）の要素を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — 処理対象となる N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

ラムダ関数の結果から生成される配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**異なる配列から要素のタプルを生成する**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax \{#arrayMax\}

導入バージョン: v21.1

入力配列の最大の要素を返します。

ラムダ関数 `func` が指定されている場合は、そのラムダの結果の中で最大の要素を返します。

**構文**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 省略可能。ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列内の最大要素、またはラムダ関数が指定されている場合はラムダ関数の結果の最大要素を返します。

**例**

**基本例**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**lambda 関数との併用**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin \{#arrayMin\}

導入: v21.1

ソース配列の最小要素を返します。

ラムダ関数 `func` が指定されている場合は、ラムダの結果の最小要素を返します。

**構文**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 省略可。ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

ソース配列内の最小要素、またはラムダ関数が指定されている場合は、その結果の最小要素を返します。

**例**

**基本的な例**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**Lambda 関数での使用**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```


## arrayNormalizedGini \{#arrayNormalizedGini\}

導入バージョン: v25.1

正規化ジニ係数を計算します。

**構文**

```sql
arrayNormalizedGini(predicted, label)
```

**引数**

* `predicted` — 予測値。[`Array(T)`](/sql-reference/data-types/array)
* `label` — 実際の値。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

予測値のGini係数、正規化された値のGini係数、および正規化Gini係数（＝前者2つのGini係数の比）を含むタプル。[`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**例**

**使用例**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort \{#arrayPartialReverseSort\}

導入バージョン: v23.2

この関数は `arrayReverseSort` と同じですが、追加の引数 `limit` により部分的なソートが可能です。

:::tip
ソートされた要素だけを保持したい場合は `arrayResize` を使用してください。
:::

**構文**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**引数**

* `f(arr[, arr1, ... ,arrN])` — 配列 `x` の要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — `f` が複数の引数を受け取る場合の、追加の N 個の配列。[`Array(T)`](/sql-reference/data-types/array)
* `limit` — どこまでソートを行うかを示すインデックス値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

元の配列と同じサイズの配列を返します。範囲 `[1..limit]` にある要素は降順にソートされます。
残りの要素 `(limit..N]` にある要素の順序は未定義です。

**例**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```


## arrayPartialShuffle \{#arrayPartialShuffle\}

導入バージョン: v23.2

元の配列と同じサイズの配列を返します。このとき、範囲 `[1..limit]` の要素は元の配列からランダムに選ばれた部分集合になります。残りの `(limit..n]` の位置には、`[1..limit]` の範囲に含まれない要素が未定義の順序で格納されます。
`limit` の値は `[1..n]` の範囲でなければなりません。この範囲外の値は、完全な `arrayShuffle` を実行するのと同等です。

:::note
この関数は定数をマテリアライズしません。

`limit` の値は `[1..N]` の範囲である必要があります。この範囲外の値は、完全な [`arrayShuffle`](#arrayShuffle) を実行するのと同等です。
:::

**構文**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**引数**

* `arr` — シャッフルする配列。[`Array(T)`](/sql-reference/data-types/array)
* `seed` — オプション。乱数生成に使用するシード。指定しない場合はランダムなものが使用されます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `limit` — オプション。要素の交換回数の上限を `[1..N]` の範囲で指定します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

要素が部分的にシャッフルされた配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**no&#95;limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no&#95;limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort \{#arrayPartialSort\}

導入バージョン: v23.2

この関数は `arraySort` と同様ですが、ソートする要素数を制限するための追加引数 `limit` を受け取ります。

:::tip
ソートされた要素のみを残したい場合は `arrayResize` を使用します。
:::

**構文**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**引数**

* `f(arr[, arr1, ... ,arrN])` — 配列 `x` の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — `f` が複数の引数を受け取る場合の、追加の N 個の配列。[`Array(T)`](/sql-reference/data-types/array)
* `limit` — ソートが行われる上限となるインデックス値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

元の配列と同じサイズの配列を返します。範囲 `[1..limit]` にある要素は昇順にソートされます。残りの要素 `(limit..N]` の順序は未定義です。

**使用例**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```


## arrayPopBack \{#arrayPopBack\}

導入バージョン: v1.1

配列の末尾の要素を削除します。

**構文**

```sql
arrayPopBack(arr)
```

**引数**

* `arr` — 最後の要素を取り除く対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

`arr` と同じですが、`arr` の最後の要素を含まない配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```


## arrayPopFront \{#arrayPopFront\}

導入バージョン: v1.1

配列の先頭要素を削除します。

**構文**

```sql
arrayPopFront(arr)
```

**引数**

* `arr` — 先頭要素を削除する対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr` と同一だが、先頭要素を除いた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```


## arrayProduct \{#arrayProduct\}

導入バージョン: v21.1

入力配列内の要素の積を返します。

ラムダ関数 `func` が指定されている場合は、そのラムダの結果要素の積を返します。

**構文**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — オプション。ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

ソース配列内の要素の積、またはラムダ関数が指定されている場合はその結果要素の積を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**基本的な例**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**ラムダ関数での使用方法**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack \{#arrayPushBack\}

導入バージョン: v1.1

配列の末尾に要素を 1 つ追加します。

**構文**

```sql
arrayPushBack(arr, x)
```

**引数**

* `arr` — 値 `x` を末尾に追加する対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` —
* 配列の末尾に追加する単一の値。[`Array(T)`](/sql-reference/data-types/array)。

:::note

* 数値の配列には数値のみ、文字列の配列には文字列のみを追加できます。
* 数値を追加する場合、ClickHouse は配列のデータ型に合わせて `x` の型を自動的に決定します。
* `NULL` を指定できます。この関数は配列に `NULL` 要素を追加し、配列要素の型は `Nullable` に変換されます。

ClickHouse のデータ型の詳細については、[データ型](/sql-reference/data-types) を参照してください。
:::

**返される値**

`arr` と同一だが、配列の末尾に値 `x` が 1 要素追加された配列 [`Array(T)`](/sql-reference/data-types/array) を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```


## arrayPushFront \{#arrayPushFront\}

導入: v1.1

配列の先頭に要素を 1 つ追加します。

**構文**

```sql
arrayPushFront(arr, x)
```

**引数**

* `arr` — 値 `x` を末尾に追加する対象の配列。[`Array(T)`](/sql-reference/data-types/array)。- `x` —
* 配列の先頭に追加する単一の値。[`Array(T)`](/sql-reference/data-types/array)。

:::note

* 数値配列には数値のみ、文字列配列には文字列のみを追加できます。
* 数値を追加する場合、ClickHouse は自動的に `x` の型を配列のデータ型に合わせます。
* `NULL` を指定できます。この関数は配列に `NULL` 要素を追加し、配列要素の型を `Nullable` に変換します。

ClickHouse におけるデータ型の詳細は、[Data types](/sql-reference/data-types) を参照してください。
:::

**返り値**

`arr` と同一だが、配列の先頭に値 `x` が 1 つ追加された配列（[`Array(T)`](/sql-reference/data-types/array)）を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```


## arrayROCAUC \{#arrayROCAUC\}

導入バージョン: v20.4

ROC（Receiver Operating Characteristic）曲線の下の面積を計算します。
ROC 曲線は、すべてのしきい値について、縦軸に真陽性率 (TPR)、横軸に偽陽性率 (FPR) をプロットすることで作成されます。
結果の値は 0 から 1 の範囲を取り、値が大きいほどモデルの性能が高いことを示します。

ROC AUC（単に AUC とも呼ばれます）は、機械学習における概念です。
詳細については、[こちら](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[こちら](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)、および[こちら](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)を参照してください。

**構文**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**別名**: `arrayAUC`

**引数**

* `scores` — 予測モデルが出力するスコア。[`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — サンプルのラベル。通常、正例サンプルには 1、負例サンプルには 0 を指定します。[`Array((U)Int*)`](/sql-reference/data-types/array) または [`Enum`](/sql-reference/data-types/enum)
* `scale` — 省略可。正規化された面積を返すかどうかを指定します。`false` の場合は、TP (true positives) と FP (false positives) の曲線下の面積を返します。デフォルト値: `true`。[`Bool`](/sql-reference/data-types/boolean)
* `partial_offsets` —
* ROC 曲線全体の AUC ではなく、ROC 曲線下の部分的な面積（ROC 空間の垂直バンドに相当）を計算するための、非負整数 4 要素からなる配列。このオプションは、ROC AUC の分散処理に有用です。配列には次の要素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`] を含める必要があります。非負の [Integers](../data-types/int-uint.md) の [Array](/sql-reference/data-types/array)。省略可。
  * `higher_partitions_tp`: より高いスコアを持つパーティション内の正例ラベルの数。
  * `higher_partitions_fp`: より高いスコアを持つパーティション内の負例ラベルの数。
  * `total_positives`: データセット全体における正例サンプルの総数。
  * `total_negatives`: データセット全体における負例サンプルの総数。

:::note
`arr_partial_offsets` を使用する場合、`arr_scores` と `arr_labels` は、スコアのある区間を含むデータセット全体のうち 1 つのパーティションのみを表す必要があります。
データセットは連続したパーティションに分割し、各パーティションにはスコアが特定の範囲に入るデータのサブセットを含める必要があります。
例えば次のように分割できます。

* あるパーティションには範囲 [0, 0.5) のすべてのスコアを含めることができます。
* 別のパーティションには範囲 [0.5, 1.0] のスコアを含めることができます。
  :::

**戻り値**

受信者動作特性 (receiver operating characteristic, ROC) 曲線下の面積を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```


## arrayRandomSample \{#arrayRandomSample\}

導入バージョン: v23.10

入力配列から、`samples` 個のランダムな要素からなる部分集合を返します。`samples` が入力配列のサイズを超える場合、サンプル数は配列サイズに制限されます。つまり、すべての配列要素が返されますが、その順序は保証されません。この関数は、フラットな配列とネストされた配列の両方を処理します。

**構文**

```sql
arrayRandomSample(arr, samples)
```

**引数**

* `arr` — 要素をサンプリングするための入力配列または多次元配列。[`Array(T)`](/sql-reference/data-types/array)
* `samples` — ランダムサンプルに含める要素の数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

入力配列からランダムにサンプリングされた要素を含む配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**多次元配列の使用**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```


## arrayReduce \{#arrayReduce\}

導入バージョン: v1.1

配列要素に集約関数を適用し、その結果を返します。
集約関数の名前は、シングルクォートで囲んだ文字列として渡します（例: `'max'`、`'sum'`）。
パラメトリックな集約関数を使用する場合は、関数名の後ろに括弧でパラメータを指定します（例: `'uniqUpTo(6)'`）。

**構文**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**引数**

* `agg_f` — 定数でなければならない集約関数の名前。[`String`](/sql-reference/data-types/string)
* `arr1 [, arr2, ... , arrN)]` — `agg_f` の引数に対応する N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

集約関数の結果を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**複数引数を取る集約関数の例**

```sql title=Query
--If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**パラメトリック集約関数を用いた例**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges \{#arrayReduceInRanges\}

導入バージョン: v20.4

指定された範囲内の配列要素に集約関数を適用し、各範囲に対応する結果を要素とする配列を返します。
この関数は、複数の `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)` を実行した場合と同じ結果を返します。

**構文**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**引数**

* `agg_f` — 使用する集約関数の名前。[`String`](/sql-reference/data-types/string)
* `ranges` — 集約を行う範囲。タプル `(i, r)` の配列で、開始位置となるインデックス `i` と、そのインデックスから集約を行う範囲 `r` を含みます。[`Array(T)`](/sql-reference/data-types/array) または [`Tuple(T)`](/sql-reference/data-types/tuple)
* `arr1 [, arr2, ... ,arrN)]` — 集約関数への引数となる N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

指定された各範囲に対する集約関数の結果を含む配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove \{#arrayRemove\}

導入バージョン: v25.11

配列から、指定した値と等しいすべての要素を削除します。
NULL 同士は等しいものとして扱われます。

**構文**

```sql
arrayRemove(arr, elem)
```

**別名**: `array_remove`

**引数**

* `arr` — Array(T), `elem` — T

**戻り値**

元の配列 [`Array(T)`](/sql-reference/data-types/array) の部分配列を返します。

**例**

**例 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**例 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```


## arrayResize \{#arrayResize\}

導入: v1.1

配列の長さを変更します。

**構文**

```sql
arrayResize(arr, size[, extender])
```

**引数**

* `arr` — サイズを変更する配列。[`Array(T)`](/sql-reference/data-types/array)
* `size` —
  * 配列の新しい長さ。
    `size` が配列の元のサイズより小さい場合、配列は右側から切り詰められます。
    `size` が配列の元のサイズより大きい場合、配列は右側に `extender` の値、または配列要素のデータ型のデフォルト値で拡張されます。
* `extender` — 配列を拡張する際に使用する値。`NULL` を指定できます。

**戻り値**

長さが `size` の配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**例 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**例2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```


## arrayReverse \{#arrayReverse\}

導入されたバージョン: v1.1

指定された配列内の要素の順序を逆にします。

:::note
関数 `reverse(arr)` も同じ機能を持ちますが、配列に加えて他のデータ型にも対応します。
:::

**構文**

```sql
arrayReverse(arr)
```

**引数**

* `arr` — 反転する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列と同じサイズで、要素の順序を逆にした配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill \{#arrayReverseFill\}

導入バージョン: v20.1

`arrayReverseFill` 関数は、ソース配列を最後の要素から最初の要素へと順番に処理し、ソース配列および条件配列の要素を用いて各位置でラムダ式の条件を評価します。位置 i において条件が false と評価された場合、その要素は、その時点での配列の状態における位置 i+1 の要素で置き換えられます。最後の要素は、条件に関わらず常に保持されます。

**構文**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列の要素をラムダ関数の結果で置き換えた配列を返す。[`Array(T)`](/sql-reference/data-types/array)

**例**

**単一の配列を用いた例**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**2つの配列を用いた例**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```


## arrayReverseSort \{#arrayReverseSort\}

導入バージョン: v1.1

配列の要素を降順にソートします。
関数 `f` が指定されている場合、配列要素に関数を適用した結果に基づいて配列がソートされ、その後、そのソート結果が反転されます。
`f` が複数の引数を受け取る場合、`arrayReverseSort` 関数には複数の配列が渡され、これらが `func` の引数に対応します。

ソート対象の配列に `-Inf`、`NULL`、`NaN`、`Inf` が含まれている場合、次の順序でソートされます:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**引数**

* `f(y1[, y2 ... yN])` — 配列 `x` の要素に適用するラムダ関数。 - `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array) - `arr1, ..., yN` — 省略可能。`f` が複数の引数を受け取る場合に指定する、N 個の追加配列です。

**戻り値**

ラムダ関数が指定されていない場合は、配列 `x` を降順にソートした配列を返します。ラムダ関数が指定されている場合は、そのラムダ関数のロジックに従って配列をソートし、その結果を反転した配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**使用例**

**例 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**例 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```


## arrayReverseSplit \{#arrayReverseSplit\}

導入バージョン: v20.1

入力配列を複数の配列に分割します。`func(x[, y1, ..., yN])` がゼロ以外を返すと、その要素の右側で配列が分割されます。末尾の要素の後では配列は分割されません。

**構文**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 元の配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となる元の配列。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に渡す追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列の配列を返します。[`Array(Array(T))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft \{#arrayRotateLeft\}

導入バージョン: v23.8

指定された要素数分だけ配列を左方向に回転します。`n` が負の値の場合は、その絶対値分だけ右方向に回転したものとして扱われます。

**構文**

```sql
arrayRotateLeft(arr, n)
```

**引数**

* `arr` — 要素を回転させる対象の配列。[`Array(T)`](/sql-reference/data-types/array)。- `n` — 回転させる要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**返される値**

指定した要素数だけ左方向に回転させた配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**n が負の場合**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```


## arrayRotateRight \{#arrayRotateRight\}

導入バージョン: v23.8

配列を、指定した要素数だけ右方向に回転させます。`n` が負の値の場合は、その絶対値分だけ左方向に回転させたものとして扱われます。

**構文**

```sql
arrayRotateRight(arr, n)
```

**引数**

* `arr` — 要素を回転させる対象の配列。[`Array(T)`](/sql-reference/data-types/array)。

- `n` — 回転させる要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**戻り値**

指定された要素数だけ右方向に回転された配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**n が負の場合**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```


## arrayShiftLeft \{#arrayShiftLeft\}

導入バージョン: v23.8

配列を指定された要素数だけ左方向にシフトします。
新しい要素には、指定された引数、または配列要素型のデフォルト値が設定されます。
要素数が負の場合、配列は右方向にシフトされます。

**構文**

```sql
arrayShiftLeft(arr, n[, default])
```

**引数**

* `arr` — シフト対象の配列。[`Array(T)`](/sql-reference/data-types/array). - `n` — シフトする要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). - `default` — 省略可能。新しく追加される要素のデフォルト値。

**返り値**

指定した要素数だけ左方向にシフトされた配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**n が負の場合**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**デフォルト値を使用する**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```


## arrayShiftRight \{#arrayShiftRight\}

導入バージョン: v23.8

配列を、指定された要素数だけ右にシフトします。
新しい要素は、指定した引数、または配列要素型のデフォルト値で埋められます。
要素数が負の場合、配列は左にシフトされます。

**構文**

```sql
arrayShiftRight(arr, n[, default])
```

**引数**

* `arr` — 要素をシフトする対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `n` — シフトする要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `default` — 任意。新しく追加される要素のデフォルト値。

**戻り値**

指定された要素数だけ右にシフトされた配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**n が負の値の場合**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**デフォルト値を使用する**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```


## arrayShingles \{#arrayShingles\}

導入バージョン: v24.1

入力配列から、指定した長さの連続した部分配列（文字列における n-gram に類似する shingle）を要素とする配列を生成します。

**構文**

```sql
arrayShingles(arr, l)
```

**引数**

* `arr` — シングル（連続部分列）の配列を生成する対象となる配列。[`Array(T)`](/sql-reference/data-types/array)
* `l` — 各シングルの長さ。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

生成されたシングルの配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle \{#arrayShuffle\}

導入: v23.2

元の配列と同じサイズで、要素がシャッフルされた順序で含まれる配列を返します。
要素は、それらの要素の取り得るすべての順列が等しい確率で現れるように並べ替えられます。

:::note
この関数は定数をマテリアライズしません。
:::

**構文**

```sql
arrayShuffle(arr [, seed])
```

**引数**

* `arr` — シャッフルする配列。[`Array(T)`](/sql-reference/data-types/array)
* `seed (optional)` — 省略可能。乱数生成に使用されるシード。省略した場合はランダムなシードが使用されます。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

要素がシャッフルされた配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**シードなしの例（結果は不安定）**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**シード未指定時の例（結果は安定）**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```


## arraySimilarity \{#arraySimilarity\}

導入バージョン: v25.4

重み付き Levenshtein 距離に基づいて、2 つの配列の類似度を `0` から `1` の範囲で計算します。

**構文**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**引数**

* `from` — 最初の配列 [`Array(T)`](/sql-reference/data-types/array)
* `to` — 2 番目の配列 [`Array(T)`](/sql-reference/data-types/array)
* `from_weights` — 最初の配列に対する重みを表す配列。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — 2 番目の配列に対する重みを表す配列。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**戻り値**

重み付きレーベンシュタイン距離に基づいて、2 つの配列の類似度を `0` から `1` の範囲の値として返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```


## arraySlice \{#arraySlice\}

導入バージョン: v1.1

`NULL` 要素を含む、配列の部分配列（スライス）を返します。

**構文**

```sql
arraySlice(arr, offset [, length])
```

**引数**

* `arr` — スライス対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `offset` — 配列の端からの位置。正の値は左端からのオフセット、負の値は右端からのオフセットを示します。配列要素の番号は `1` から始まります。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 必要なスライスの長さ。負の値を指定すると、関数は開いたスライス `[offset, array_length - length]` を返します。値を省略した場合、関数はスライス `[offset, the_end_of_array]` を返します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

指定された `offset` 位置から、長さ `length` の配列スライスを返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```


## arraySort \{#arraySort\}

導入バージョン: v1.1

指定された配列の要素を昇順にソートします。
ラムダ関数 `f` が指定された場合、配列の各要素にラムダを適用した結果に基づいてソート順が決定されます。
ラムダが複数の引数を受け取る場合、`arraySort` 関数には複数の配列が渡され、`f` の各引数はそれぞれ対応する配列の要素に対応します。

ソート対象の配列に `-Inf`、`NULL`、`NaN`、`Inf` が含まれている場合、それらは次の順序でソートされます:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**引数**

* `f(y1[, y2 ... yN])` — 配列 `x` の要素に適用するラムダ関数。
* `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ..., yN` — 省略可。`f` が複数の引数を受け取る場合に指定する、追加の N 個の配列。

**返り値**

ラムダ関数が指定されていない場合は、配列 `arr` を昇順にソートして返します。ラムダ関数が指定されている場合は、そのロジックに従ってソートされた配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**例 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**例 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**例 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit \{#arraySplit\}

導入バージョン: v20.1

ソース配列を複数の配列に分割します。`func(x [, y1, ..., yN])` がゼロ以外の値を返した要素の直前で配列が分割されます。最初の要素の前では分割されません。

**構文**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素を処理するラムダ関数です。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)

- `source_arr` — 分割対象となるソース配列 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列 [`Array(T)`](/sql-reference/data-types/array)

**返される値**

配列の配列を返します [`Array(Array(T))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```


## arraySum \{#arraySum\}

導入: v21.1

入力配列の要素の合計を返します。

ラムダ関数 `func` が指定されている場合は、そのラムダを適用した結果要素の合計を返します。

**構文**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 省略可。ソース配列 `x` および条件配列 `y` の要素を処理するラムダ関数です。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ... , condN_arr` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

ソース配列内の要素の合計、またはラムダ関数が指定されている場合は、その結果要素の合計を返します。

**例**

**基本的な例**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**ラムダ関数との併用**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```


## arraySymmetricDifference \{#arraySymmetricDifference\}

導入バージョン: v25.4

複数の配列を受け取り、すべての入力配列に共通して存在しない要素からなる配列を返します。結果には一意な値のみが含まれます。

:::note
*2 つを超える Set* の対称差は、[数学的には](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)、奇数個の入力 Set に含まれるすべての入力要素からなる Set として定義されます。
これに対して、関数 `arraySymmetricDifference` は、すべての入力 Set に含まれない入力要素からなる Set を単純に返します。
:::

**構文**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**引数**

* `arrN` — 新しい配列を構成するための N 個の配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

すべての元の配列に共通して存在しない要素のみを含む配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**使用例**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion \{#arrayUnion\}

導入バージョン: v24.10

複数の配列を受け取り、ソース配列のいずれかに含まれるすべての要素を含む配列を返します。結果には重複のない値のみが含まれます。

**構文**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**引数**

* `arrN` — 新しい配列を作成するための N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列群から重複しない要素のみを含む配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq \{#arrayUniq\}

導入バージョン: v1.1

引数が 1 つだけ渡された場合、その配列内の異なる要素の数をカウントします。
複数の引数が渡された場合、複数の配列において同じ位置にある要素から構成される **タプル** のうち、異なるものの数をカウントします。

たとえば `SELECT arrayUniq([1,2], [3,4], [5,6])` は次のようなタプルを構成します:

* 位置 1: (1,3,5)
* 位置 2: (2,4,6)

その後、タプルのうち異なるものの個数を数えます。この場合は `2` になります。

渡されるすべての配列は同じ長さである必要があります。

:::tip
配列内のユニークな要素のリストを取得したい場合は、`arrayReduce('groupUniqArray', arr)` を使用できます。
:::

**構文**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**引数**

* `arr1` — 一意な要素数をカウントする対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, arr2, ..., arrN]` — 省略可。複数の配列において、同じ位置の要素からなる一意なタプル数をカウントするために使用する追加の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

単一の引数の場合は、一意な要素数を返します。複数の引数の場合は、
各配列で同じ位置にある要素から構成される一意なタプル数を返します。
[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**単一引数**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**複数の引数**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```


## arrayWithConstant \{#arrayWithConstant\}

導入バージョン: v20.1

長さが `length` で、すべての要素が定数 `x` の配列を作成します。

**構文**

```sql
arrayWithConstant(N, x)
```

**引数**

* `length` — 配列の長さ（要素数）。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `x` — 配列内の各要素に設定される値。任意の型。

**戻り値**

要素数 `N` で、すべての要素の値が `x` である Array を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```


## arrayZip \{#arrayZip\}

導入バージョン: v20.1

複数の配列を 1 つの配列に結合します。結果の配列には、ソース配列の対応する要素が、引数の並び順でタプルにまとめられて格納されます。

**構文**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**引数**

* `arr1, arr2, ... , arrN` — 1 つの配列に結合する N 個の配列です。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

ソース配列の要素をタプルとしてグループ化した配列を返します。タプル内のデータ型は入力配列の型と同じであり、配列が渡された順序と同じ順序になります。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned \{#arrayZipUnaligned\}

導入バージョン: v20.1

複数の配列を 1 つの配列に結合し、長さが揃っていない配列（長さが異なる配列）も許容します。結果の配列には、引数で指定された順序に従って、元の各配列の対応する要素がタプルとしてまとめられて格納されます。

**構文**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**引数**

* `arr1, arr2, ..., arrN` — 1 つの配列に結合する N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

元の配列の要素をタプル単位でグループ化した配列を返します。タプル内のデータ型は入力配列の型と同じであり、配列が渡された順序を保持します。[`Array(T)`](/sql-reference/data-types/array) または [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**例**

**使用例**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual \{#countEqual\}

導入バージョン: v1.1

配列内の要素のうち、`x` と等しいものの個数を返します。`arrayCount(elem -> elem = x, arr)` と同等です。

`NULL` 要素は、他の値とは別の値として扱われます。

**構文**

```sql
countEqual(arr, x)
```

**引数**

* `arr` — 検索対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` — 配列内でカウントする値。任意の型。

**戻り値**

配列内で `x` と等しい要素の数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```


## empty \{#empty\}

導入バージョン: v1.1

入力配列が空かどうかを判定します。

要素をまったく含まない場合、その配列は空と見なされます。

:::note
[`optimize_functions_to_subcolumns` setting](/operations/settings/settings#optimize_functions_to_subcolumns) を有効にすることで最適化できます。`optimize_functions_to_subcolumns = 1` の場合、この関数は配列カラム全体を読み取って処理する代わりに、[size0](/sql-reference/data-types/array#array-size) サブカラムのみを読み取ります。クエリ `SELECT empty(arr) FROM TABLE;` は `SELECT arr.size0 = 0 FROM TABLE;` に変換されます。
:::

この関数は String や UUID に対しても動作します。

**構文**

```sql
empty(arr)
```

**引数**

* `arr` — 入力配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

空の配列の場合は `1`、空でない配列の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate \{#emptyArrayDate\}

導入バージョン: v1.1

空の `Date` 型配列を返します

**構文**

```sql
emptyArrayDate()
```

**引数**

* なし。

**戻り値**

空の Date 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```


## emptyArrayDateTime \{#emptyArrayDateTime\}

導入: v1.1

空の DateTime 配列を返します

**構文**

```sql
emptyArrayDateTime()
```

**引数**

* なし。

**返り値**

空の DateTime 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```


## emptyArrayFloat32 \{#emptyArrayFloat32\}

導入バージョン: v1.1

空の Float32 配列を返します。

**構文**

```sql
emptyArrayFloat32()
```

**引数**

* なし。

**戻り値**

空の Float32 型配列。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```


## emptyArrayFloat64 \{#emptyArrayFloat64\}

導入バージョン: v1.1

空の Float64 型配列を返します

**構文**

```sql
emptyArrayFloat64()
```

**引数**

* なし。

**戻り値**

空の Float64 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```


## emptyArrayInt16 \{#emptyArrayInt16\}

導入: v1.1

空の Int16 配列を返します

**構文**

```sql
emptyArrayInt16()
```

**引数**

* なし。

**戻り値**

空の Int16 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```


## emptyArrayInt32 \{#emptyArrayInt32\}

導入: v1.1

空の Int32 配列を返します

**構文**

```sql
emptyArrayInt32()
```

**引数**

* なし。

**戻り値**

空の Int32 型配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```


## emptyArrayInt64 \{#emptyArrayInt64\}

導入バージョン: v1.1

空の Int64 配列を返します。

**構文**

```sql
emptyArrayInt64()
```

**引数**

* なし

**戻り値**

空の Int64 型配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```


## emptyArrayInt8 \{#emptyArrayInt8\}

導入バージョン: v1.1

空の Int8 配列を返します。

**構文**

```sql
emptyArrayInt8()
```

**引数**

* なし。

**戻り値**

空の Int8 配列です。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```


## emptyArrayString \{#emptyArrayString\}

導入: v1.1

空の String 配列を返します。

**構文**

```sql
emptyArrayString()
```

**引数**

* なし。

**戻り値**

空の String 型配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```


## emptyArrayToSingle \{#emptyArrayToSingle\}

導入バージョン: v1.1

空の配列を受け取り、デフォルト値を要素とする 1 要素配列を返します。

**構文**

```sql
emptyArrayToSingle(arr)
```

**引数**

* `arr` — 空の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列要素型のデフォルト値を 1 つだけ含む配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な例**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16 \{#emptyArrayUInt16\}

導入バージョン: v1.1

空の UInt16 配列を返します。

**構文**

```sql
emptyArrayUInt16()
```

**引数**

* なし

**返される値**

空の UInt16 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```


## emptyArrayUInt32 \{#emptyArrayUInt32\}

導入: v1.1

空の UInt32 配列を返します

**構文**

```sql
emptyArrayUInt32()
```

**引数**

* なし。

**戻り値**

空の UInt32 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```


## emptyArrayUInt64 \{#emptyArrayUInt64\}

導入バージョン: v1.1

空の UInt64 型配列を返します。

**構文**

```sql
emptyArrayUInt64()
```

**引数**

* なし。

**返り値**

空の UInt64 の配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```


## emptyArrayUInt8 \{#emptyArrayUInt8\}

導入バージョン：v1.1

空の UInt8 型の配列を返します。

**構文**

```sql
emptyArrayUInt8()
```

**引数**

* なし。

**戻り値**

空の UInt8 型配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```


## has \{#has\}

導入バージョン: v1.1

配列に指定した要素が含まれているかどうかを返します。

最初の引数が定数配列で、2 番目の引数がカラムまたは式である場合、`has(constant_array, column)` は `column IN (constant_array)` と同様に動作し、最適化のためにプライマリキーおよびデータスキップ索引を利用できます。たとえば、`has([1, 10, 100], id)` は、`id` が `PRIMARY KEY` の一部であればプライマリキー索引を活用できます。

この最適化は、カラムに単調関数が適用されている場合（例: `has([...], toDate(ts))`）にも適用されます。

**構文**

```sql
has(arr, x)
```

**引数**

* `arr` — 元の配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` — 配列内で検索する値。

**戻り値**

配列が指定された要素を含む場合は `1` を返し、含まない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用方法**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**見つかりません**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```


## hasAll \{#hasAll\}

導入バージョン: v1.1

一方の配列が他方の配列の部分集合かどうかをチェックします。

* 空の配列は任意の配列の部分集合です。
* `Null` は値として処理されます。
* 両方の配列における値の順序は関係ありません。

**構文**

```sql
hasAll(set, subset)
```

**引数**

* `set` — 要素の集合を持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)
* `subset` — `set` と共通のスーパータイプを持ち、その要素が `set` の部分集合であるかどうかを検証する対象となる任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

* `set` が `subset` のすべての要素を含む場合は `1`。
* それ以外の場合は `0`。

set と subset の要素が共通のスーパータイプを持たない場合、`NO_COMMON_TYPE` 例外を送出します。

**例**

**空配列**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**NULL 値を含む配列**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**異なる型の値を含む配列**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**String 型の値を含む配列**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**共通の要素型を持たない配列**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Raises a NO_COMMON_TYPE exception
```

**配列の配列**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```


## hasAny \{#hasAny\}

導入バージョン: v1.1

2 つの配列に、少なくとも 1 つ共通する要素があるかどうかをチェックします。

* `Null` は値として処理されます。
* 両方の配列内での値の順序は関係ありません。

**構文**

```sql
hasAny(arr_x, arr_y)
```

**引数**

* `arr_x` — 任意の型の要素を持つ配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — 配列 `arr_x` と共通の上位型を持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

* `arr_x` と `arr_y` に少なくとも 1 つ同じ要素が存在するときは `1`。
* それ以外の場合は `0`。

2 つの配列の要素に、共通の上位型を持たないものがある場合、`NO_COMMON_TYPE` 例外をスローします。

**例**

**片方の配列が空の場合**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**NULL 値を含む配列**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**異なる型の値を含む配列**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**共通の型を持たない配列**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

**配列の配列**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```


## hasSubstr \{#hasSubstr\}

導入バージョン: v20.6

`array2` のすべての要素が、`array1` の中にまったく同じ順序で出現するかどうかをチェックします。
したがって、この関数は `array1 = prefix + array2 + suffix` が成り立つ場合に限り `1` を返します。

言い換えると、この関数は `hasAll` 関数と同様に、`array2` のすべての要素が `array1` に含まれているかどうかをチェックします。
さらに、`array1` と `array2` の両方で要素が同じ順序で現れることもチェックします。

* `array2` が空の場合、この関数は `1` を返します。
* `Null` は値として処理されます。言い換えると、`hasSubstr([1, 2, NULL, 3, 4], [2,3])` は `0` を返します。ただし、`hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` は `1` を返します。
* 両方の配列における値の順序は重要です。

2 つの配列の要素の型が共通のスーパータイプを持たない場合、`NO_COMMON_TYPE` 例外をスローします。

**構文**

```sql
hasSubstr(arr1, arr2)
```

**引数**

* `arr1` — 複数の要素を持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr2` — 複数の要素を持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列 `arr1` が配列 `arr2` を含む場合は `1` を返します。そうでない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**両方の配列が空の場合**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**NULL 値を含む配列**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**異なる型の値を含む配列**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**文字列を含む配列**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**順序が定義された配列**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**順序が不正な配列**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**配列の配列**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**共通の型を持たない配列**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```


## indexOf \{#indexOf\}

導入バージョン: v1.1

配列内に値 &#39;x&#39; を持つ要素がある場合、その最初の要素のインデックス（1 始まり）を返します。
配列に検索対象の値が含まれていない場合、関数は `0` を返します。

`NULL` に設定された要素は通常の値として扱われます。

**構文**

```sql
indexOf(arr, x)
```

**引数**

* `arr` — `x` を検索する対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` — `arr` 内で最初に一致し、その位置の索引が返される要素の値。[`UInt64`](/sql-reference/data-types/int-uint)

**戻り値**

`arr` 内に `x` が存在する場合、その最初の出現位置の索引（1 始まり）を返します。存在しない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な例**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**NULL を含む配列**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```


## indexOfAssumeSorted \{#indexOfAssumeSorted\}

導入: v24.12

配列内に値 &#39;x&#39; を持つ要素が存在する場合、その最初の要素のインデックス（`1` から始まる）を返します。
検索対象の値が配列内に存在しない場合、関数は `0` を返します。

:::note
`indexOf` 関数と異なり、この関数は配列が昇順にソートされていると仮定します。
配列がソートされていない場合、結果は未定義です。
:::

**構文**

```sql
indexOfAssumeSorted(arr, x)
```

**引数**

* `arr` — 検索対象のソート済み配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` — ソート済みの `arr` 内で、索引を返す対象となる最初に一致した要素の値。[`UInt64`](/sql-reference/data-types/int-uint)

**返り値**

`arr` に `x` が存在する場合、最初の `x` の索引（1 から始まる番号）を返します。存在しない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な例**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```


## length \{#length\}

導入バージョン: v1.1

文字列または配列の長さを計算します。

* 引数が String または FixedString の場合: 文字列内のバイト数を計算します。
* 引数が Array の場合: 配列内の要素数を計算します。
* FixedString 引数に適用された場合、この関数は定数式として評価されます。

文字列中のバイト数は、Unicode の「コードポイント」の数とも、Unicode の「書記素クラスタ」
（一般的に「文字」と呼ぶもの）の数とも、表示幅とも同じではないことに注意してください。

文字列中に ASCII の NULL バイトが含まれていても問題はなく、それらもカウントされます。

**構文**

```sql
length(x)
```

**別名**: `OCTET_LENGTH`

**引数**

* `x` — バイト数（String/FixedString の場合）または要素数（Array の場合）を計算する対象の値。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Array(T)`](/sql-reference/data-types/array)

**返される値**

String/FixedString `x` のバイト数、または配列 `x` の要素数を返します。戻り値の型は [`UInt64`](/sql-reference/data-types/int-uint) です。

**例**

**String の例**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**配列の例**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**constexpr の例**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**Unicode の例**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ascii&#95;vs&#95;utf8 の使用例**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty \{#notEmpty\}

導入バージョン: v1.1

入力配列が空でないかどうかをチェックします。

配列に少なくとも 1 つの要素が含まれている場合、その配列は空でないと見なされます。

:::note
[`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns) 設定を有効にすることで最適化できます。`optimize_functions_to_subcolumns = 1` の場合、この関数は配列カラム全体を読み取り・処理する代わりに、[size0](/sql-reference/data-types/array#array-size) サブカラムのみを読み取ります。クエリ `SELECT notEmpty(arr) FROM table` は `SELECT arr.size0 != 0 FROM TABLE` に変換されます。
:::

この関数は String 型や UUID 型に対しても動作します。

**構文**

```sql
notEmpty(arr)
```

**引数**

* `arr` — 入力配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

空でない配列には `1` を、空の配列には `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```


## range \{#range\}

導入バージョン: v1.1

`start` から `end - 1` までを、`step` ごとの間隔で並べた数値の配列を返します。

サポートされる型は次のとおりです:

* `UInt8/16/32/64`

* `Int8/16/32/64`

* すべての引数 `start`、`end`、`step` は上記のいずれかの型でなければなりません。返される配列の要素の型は、引数のスーパータイプになります。

* 関数が、設定 [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block) で指定された要素数を超える長さの配列を返す場合、例外がスローされます。

* いずれかの引数が Nullable(nothing) 型の場合は `NULL` を返します。いずれかの引数が `NULL` 値（Nullable(T) 型）を含む場合、例外がスローされます。

**構文**

```sql
range([start, ] end [, step])
```

**引数**

* `start` — 省略可能。配列の最初の要素。`step` を使用する場合は必須。デフォルト値: `0`。
* `end` — 必須。配列を構築する際の終端となる数値（この値自体は含まれない）。
* `step` — 省略可能。配列内の各要素間の増分を指定します。デフォルト値: `1`。

**戻り値**

`start` から `end - 1` までを `step` ごとに並べた数値の配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate \{#replicate\}

導入バージョン: v1.1

単一の値を要素とする配列を作成します。

**構文**

```sql
replicate(x, arr)
```

**引数**

* `x` — 結果配列を埋める値。[`Any`](/sql-reference/data-types)
* `arr` — 配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr` と同じ長さで、値 `x` で埋められた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse \{#reverse\}

導入バージョン: v1.1

入力配列の要素、または入力文字列の文字の順序を逆順にします。

**構文**

```sql
reverse(arr | str)
```

**引数**

* `arr | str` — 入力の配列または文字列。[`Array(T)`](/sql-reference/data-types/array) または [`String`](/sql-reference/data-types/string)

**戻り値**

要素または文字の順序を逆にした配列または文字列を返します。

**例**

**配列を反転**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**文字列の反転**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

{/*AUTOGENERATED_END*/ }


## 距離関数 \{#distance-functions\}

サポートされているすべての関数については、[距離関数のドキュメント](../../sql-reference/functions/distance-functions.md)を参照してください。
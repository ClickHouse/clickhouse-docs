---
description: '配列関数に関するドキュメント'
sidebar_label: '配列'
slug: /sql-reference/functions/array-functions
title: '配列関数'
doc_type: 'reference'
---



# 配列関数

<!--
以下のタグ内のコンテンツは、ドキュメントフレームワークのビルド時に
system.functionsから生成されたドキュメントに置き換えられます。タグを変更または削除しないでください。
参照: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## array {#array}

導入バージョン: v1.1

関数の引数から配列を作成します。

引数は定数であり、共通のスーパータイプを共有する型である必要があります。
少なくとも1つの引数を渡す必要があります。そうでない場合、作成する配列の型が不明確になるためです。
つまり、この関数では空の配列を作成できません。空の配列を作成するには、`emptyArray*` 関数を使用してください。

同じ機能には `[ ]` 演算子を使用できます。

**構文**

```sql
array(x1 [, x2, ..., xN])
```

**引数**

- `x1` — 任意の型Tの定数値。この引数のみが指定された場合、配列は型Tになります。
- `[, x2, ..., xN]` — `x1`と共通のスーパータイプを共有する追加のN個の定数値

**戻り値**

配列を返します。ここで'T'は渡された引数の最小共通型です。[`Array(T)`](/sql-reference/data-types/array)

**例**

**有効な使用法**

```sql title=クエリ
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=レスポンス
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**無効な使用法**

```sql title=クエリ
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=レスポンス
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```


## arrayAUCPR {#arrayAUCPR}

導入バージョン: v20.4

適合率-再現率(PR)曲線の下の面積を計算します。
適合率-再現率曲線は、すべての閾値において、y軸に適合率、x軸に再現率をプロットすることで作成されます。
結果の値は0から1の範囲で、値が高いほどモデルの性能が優れていることを示します。
PR AUCは不均衡なデータセットに特に有用であり、そのような場合においてROC AUCと比較してより明確な性能比較を提供します。
詳細については、[こちら](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[こちら](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)、および[こちら](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)を参照してください。

**構文**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**エイリアス**: `arrayPRAUC`

**引数**

- `scores` — 予測モデルが与えるスコア。[`Array((U)Int*)`](/sql-reference/data-types/array)または[`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — サンプルのラベル。通常、正例には1、負例には0を使用します。[`Array((U)Int*)`](/sql-reference/data-types/array)または[`Array(Enum)`](/sql-reference/data-types/array)
- `partial_offsets` —
- オプション。AUC全体ではなく、PR曲線の下の部分面積(PR空間の垂直帯に相当)を計算するための3つの非負整数の[`Array(T)`](/sql-reference/data-types/array)。このオプションはPR AUCの分散計算に有用です。配列には次の要素[`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]を含める必要があります。
  - `higher_partitions_tp`: より高いスコアのパーティションにおける正ラベルの数。
  - `higher_partitions_fp`: より高いスコアのパーティションにおける負ラベルの数。
  - `total_positives`: データセット全体における正サンプルの総数。

:::note
`arr_partial_offsets`を使用する場合、`arr_scores`と`arr_labels`はデータセット全体の一部のパーティションのみであり、スコアの区間を含む必要があります。
データセットは連続したパーティションに分割され、各パーティションには特定の範囲内のスコアを持つデータのサブセットが含まれます。
例:

- あるパーティションには[0, 0.5)の範囲のすべてのスコアを含めることができます。
- 別のパーティションには[0.5, 1.0]の範囲のスコアを含めることができます。
  :::

**返される値**

適合率-再現率(PR)曲線の下の面積を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll {#arrayAll}

導入バージョン: v1.1

ラムダ関数 `func(x [, y1, y2, ... yN])` がすべての要素に対してtrueを返す場合は `1` を返します。それ以外の場合は `0` を返します。

**構文**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作を行うラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

ラムダ関数がすべての要素に対してtrueを返す場合は `1`、それ以外の場合は `0` を返します [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**すべての要素が一致する場合**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**すべての要素が一致しない場合**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg {#arrayAvg}

導入バージョン: v21.1

ソース配列の要素の平均値を返します。

ラムダ関数 `func` が指定されている場合、ラムダ関数の結果の平均値を返します。

**構文**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — オプション。ソース配列（`x`）と条件配列（`y`）の要素を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列の要素の平均値を返します。ラムダ関数が指定されている場合は、ラムダ関数の結果の平均値を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**基本的な例**

```sql title=クエリ
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=レスポンス
2.5
```

**ラムダ関数を使用した例**

```sql title=クエリ
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=レスポンス
6.5
```


## arrayCompact {#arrayCompact}

導入バージョン: v20.1

配列から連続する重複要素を削除します（`null`値を含む）。結果の配列内の値の順序は、元の配列の順序によって決定されます。

**構文**

```sql
arrayCompact(arr)
```

**引数**

- `arr` — 重複を削除する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

重複する値のない配列を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=レスポンス
[1,nan,2,3]
```


## arrayConcat {#arrayConcat}

導入バージョン: v1.1

引数として渡された配列を結合します。

**構文**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**引数**

- `arr1 [, arr2, ... , arrN]` — 結合する配列をN個指定します。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

指定された配列引数を結合した単一の配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```


## arrayCount {#arrayCount}

導入バージョン: v1.1

`func(arr1[i], ..., arrN[i])` が true を返す要素の数を返します。
`func` が指定されていない場合は、配列内の非ゼロ要素の数を返します。

`arrayCount` は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arrayCount([func, ] arr1, ...)
```

**引数**

- `func` — オプション。配列の各要素に適用する関数。[`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1, ..., arrN` — N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`func` が true を返す要素の数を返します。それ以外の場合は、配列内の非ゼロ要素の数を返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=レスポンス
5
```


## arrayCumSum {#arrayCumSum}

導入バージョン: v1.1

ソース配列の要素の部分和（累積和）の配列を返します。ラムダ関数が指定されている場合、各位置で配列要素にラムダを適用した結果から和が計算されます。

**構文**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**引数**

- `func` — オプション。各位置で配列要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — 数値のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — オプション。指定された場合、ラムダ関数の引数として渡される同じサイズの追加配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列の要素の部分和の配列を返します。結果の型は入力配列の数値型と一致します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使用方法**

```sql title=クエリ
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=レスポンス
[1, 2, 3, 4]
```

**ラムダを使用する場合**

```sql title=クエリ
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=レスポンス
[2, 6, 12]
```


## arrayCumSumNonNegative {#arrayCumSumNonNegative}

導入バージョン: v18.12

ソース配列の要素の部分和（累積和）の配列を返します。負の累積和はゼロに置き換えられます。ラムダ関数が指定されている場合、各位置で配列要素にラムダを適用した結果から合計が計算されます。

**構文**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**引数**

- `func` — オプション。各位置で配列要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — 数値のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — オプション。指定された場合、ラムダ関数の引数として渡される同じサイズの追加配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列の要素の部分和の配列を返します。負の累積和はゼロに置き換えられます。結果の型は入力配列の数値型と一致します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使用方法**

```sql title=クエリ
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=レスポンス
[1, 2, 0, 1]
```

**ラムダを使用した例**

```sql title=クエリ
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=レスポンス
[2, 0, 6]
```


## arrayDifference {#arrayDifference}

導入バージョン: v1.1

隣接する配列要素間の差分の配列を計算します。
結果配列の最初の要素は0、2番目は`arr[1] - arr[0]`、3番目は`arr[2] - arr[1]`のようになります。
結果配列の要素の型は、減算の型推論規則によって決定されます(例: `UInt8` - `UInt8` = `Int16`)。

**構文**

```sql
arrayDifference(arr)
```

**引数**

- `arr` — 隣接要素間の差分を計算する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

隣接する配列要素間の差分の配列を返します。[`UInt*`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=レスポンス
[0,1,1,1]
```

**結果型Int64によるオーバーフローの例**

```sql title=クエリ
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=レスポンス
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct {#arrayDistinct}

導入バージョン: v1.1

配列内の一意の要素のみを含む配列を返します。

**構文**

```sql
arrayDistinct(arr)
```

**引数**

- `arr` — 一意の要素を抽出する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

一意の要素を含む配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct {#arrayDotProduct}

導入バージョン: v23.5

2つの配列の内積を返します。

:::note
2つのベクトルのサイズは等しい必要があります。配列とタプルには、混合要素型を含めることができます。
:::

**構文**

```sql
arrayDotProduct(v1, v2)
```

**引数**

- `v1` — 第1ベクトル。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) または [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
- `v2` — 第2ベクトル。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) または [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**戻り値**

2つのベクトルの内積。

:::note
戻り値の型は引数の型によって決定されます。配列またはタプルに混合要素型が含まれている場合、結果の型はスーパータイプになります。
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)

**例**

**配列の例**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**タプルの例**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement {#arrayElement}

導入バージョン: v1.1

指定された配列からインデックス `n` の要素を取得します。`n` は任意の整数型を指定できます。
インデックスが配列の範囲外の場合、デフォルト値(数値の場合は0、文字列の場合は空文字列など)を返します。
ただし、非定数配列と定数インデックス0の引数の組み合わせの場合は例外で、この場合は `Array indices are 1-based` というエラーが発生します。

:::note
ClickHouseの配列は1始まりのインデックスです。
:::

負のインデックスもサポートされています。この場合、末尾から数えた対応する要素が選択されます。例えば、`arr[-1]` は配列の最後の要素です。

演算子 `[n]` も同じ機能を提供します。

**構文**

```sql
arrayElement(arr, n)
```

**引数**

- `arr` — 検索対象の配列。[`Array(T)`](/sql-reference/data-types/array)。
- `n` — 取得する要素の位置。[`(U)Int*`](/sql-reference/data-types/int-uint)。

**戻り値**

指定された配列から単一の要素を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=結果
2
```

**負のインデックス**

```sql title=クエリ
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=結果
3
```

**[n] 記法の使用**

```sql title=クエリ
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=結果
2
```

**配列の範囲外のインデックス**

```sql title=クエリ
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=結果
0
```


## arrayElementOrNull {#arrayElementOrNull}

導入バージョン: v1.1

指定された配列からインデックス `n` の要素を取得します。`n` は任意の整数型を指定できます。
インデックスが配列の範囲外の場合、デフォルト値の代わりに `NULL` が返されます。

:::note
ClickHouseの配列は1から始まるインデックスです。
:::

負のインデックスもサポートされています。この場合、末尾から数えた対応する要素が選択されます。例えば、`arr[-1]` は配列の最後の要素です。

**構文**

```sql
arrayElementOrNull(arrays)
```

**引数**

- `arrays` — 任意の数の配列引数。[`Array`](/sql-reference/data-types/array)

**戻り値**

指定された配列引数から単一の結合された配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=結果
2
```

**負のインデックス**

```sql title=クエリ
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=結果
3
```

**配列の範囲外のインデックス**

```sql title=クエリ
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=結果
NULL
```


## arrayEnumerate {#arrayEnumerate}

導入バージョン: v1.1

配列 `[1, 2, 3, ..., length (arr)]` を返します

この関数は通常、[`ARRAY JOIN`](/sql-reference/statements/select/array-join) 句と共に使用されます。`ARRAY JOIN` を適用した後、各配列に対して要素を一度だけカウントできます。
この関数は高階関数でも使用できます。例えば、条件に一致する要素の配列インデックスを取得する際に使用できます。

**構文**

```sql
arrayEnumerate(arr)
```

**引数**

- `arr` — 列挙する配列。[`Array`](/sql-reference/data-types/array)

**戻り値**

配列 `[1, 2, 3, ..., length (arr)]` を返します. [`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**ARRAY JOIN を使用した基本的な例**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense {#arrayEnumerateDense}

導入バージョン: v18.12

ソース配列と同じサイズの配列を返します。各要素がソース配列内で最初に出現する位置を示します。

**構文**

```sql
arrayEnumerateDense(arr)
```

**引数**

- `arr` — 列挙対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr`と同じサイズの配列を返します。各要素がソース配列内で最初に出現する位置を示します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

導入バージョン: v20.1

ソース配列と同じサイズの配列を返し、各要素がソース配列内で最初に出現する位置を示します。配列内をどの深さまで調べるかを指定することで、多次元配列の列挙が可能になります。

**構文**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**引数**

- `clear_depth` — 指定されたレベルで要素を個別に列挙します。`max_arr_depth`以下である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — 列挙対象のN次元配列。[`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — 最大有効深度。`arr`の深度以下である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

各要素がソース配列内で最初に出現する位置を示す配列を返します。[`Array`](/sql-reference/data-types/array)

**例**

**基本的な使用方法**

```sql title=クエリ
-- clear_depth=1およびmax_array_depth=1の場合、結果はarrayEnumerateDenseが返すものと同一になります。

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=レスポンス
[1,2,1,3]
```

**多次元配列での使用方法**

```sql title=クエリ
-- この例では、arrayEnumerateDenseRankedを使用して、多次元配列の各要素について、
-- 同じ値を持つ要素の中での位置を示す配列を取得します。
-- 渡された配列の1行目[10, 10, 30, 20]に対して、結果の対応する1行目は[1, 1, 2, 3]となり、
-- 10が位置1と2で最初に出現した数値、30が位置3で2番目に出現した数値、
-- 20が位置4で3番目に出現した数値であることを示しています。
-- 2行目の[40, 50, 10, 30]に対して、結果の対応する2行目は[4,5,1,2]となり、40と50が
-- その行の位置1と2で4番目と5番目に出現した数値であり、別の10
-- (最初に出現した数値)が位置3にあり、30(2番目に出現した数値)が最後の位置にあることを示しています。

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=レスポンス
[[1,1,2,3],[4,5,1,2]]
```

**clear_depthを増やした例**

```sql title=クエリ
-- clear_depth=2に変更すると、各行ごとに個別に列挙が新たに行われます。

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=レスポンス
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq {#arrayEnumerateUniq}

導入バージョン: v1.1

元の配列と同じサイズの配列を返し、各要素が同じ値を持つ要素の中で何番目に出現するかを示します。

この関数は、`ARRAY JOIN`を使用する際や配列要素の集約を行う際に有用です。

この関数は、同じサイズの複数の配列を引数として受け取ることができます。この場合、すべての配列の同じ位置にある要素のタプルに対して一意性が判定されます。

**構文**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**引数**

- `arr1` — 処理する最初の配列。[`Array(T)`](/sql-reference/data-types/array)
- `arr2, ...` — オプション。タプルの一意性判定のための同じサイズの追加配列。[`Array(UInt32)`](/sql-reference/data-types/array)

**返り値**

同じ値またはタプルを持つ要素の中での出現順序を各要素とする配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使用方法**

```sql title=クエリ
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=レスポンス
[1, 1, 2, 1]
```

**複数の配列**

```sql title=クエリ
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=レスポンス
[1,2,1,1,2,1]
```

**ARRAY JOINによる集約**

```sql title=クエリ
-- 各ゴールIDには、コンバージョン数(Goalsネスト構造の各要素は達成されたゴールであり、これをコンバージョンと呼びます)
-- とセッション数の計算があります。ARRAY JOINを使用しない場合、セッション数はsum(Sign)として計算されます。しかし、この特定のケースでは、
-- 行がネストされたGoals構造によって乗算されるため、この後に各セッションを1回だけカウントするために、
-- arrayEnumerateUniq(Goals.ID)関数の値に条件を適用します。

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=レスポンス
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

導入バージョン: v20.1

ソース配列と同じ次元の配列(または多次元配列)を返します。
各要素について、同じ値を持つ要素の中での位置を示します。
配列内をどの深さまで調べるかを指定して、多次元配列を列挙できます。

**構文**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**引数**

- `clear_depth` — 指定されたレベルで要素を個別に列挙します。`max_arr_depth`以下の正の整数。[`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — 列挙するN次元配列。[`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — 最大有効深度。`arr`の深度以下の正の整数。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

`arr`と同じサイズのN次元配列を返します。各要素は、同じ値を持つ他の要素に対するその要素の位置を示します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**例1**

```sql title=Query
-- clear_depth=1およびmax_array_depth=1の場合、arrayEnumerateUniqRankedの結果は
-- 同じ配列に対してarrayEnumerateUniqが返す結果と同一になります。

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**例2**

```sql title=Query
-- clear_depth=1およびmax_array_depth=1の場合、arrayEnumerateUniqRankedの結果は
-- 同じ配列に対してarrayEnumerateUniqが返す結果と同一になります。

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**例3**

```sql title=Query
-- この例では、arrayEnumerateUniqRankedを使用して、多次元配列の各要素について、
-- 同じ値を持つ要素の中での位置を示す配列を取得します。渡された配列の1行目
-- [1, 2, 3]に対して、対応する結果は[1, 1, 1]となり、これは1、2、3が初めて
-- 出現することを示しています。2行目[2, 2, 1]に対して、対応する結果は[2, 3, 2]となり、
-- 2が2回目と3回目に出現し、1が2回目に出現することを示しています。同様に、
-- 3行目[3]に対して、対応する結果は[2]となり、3が2回目に出現することを示しています。

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**例4**

```sql title=Query
-- clear_depth=2に変更すると、各行ごとに要素が個別に列挙されます。
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept {#arrayExcept}

導入バージョン: v25.9

`source`に含まれる要素のうち、`except`に存在しない要素を元の順序を保持して配列として返します。

この関数は2つの配列間で集合差演算を実行します。`source`の各要素について、その要素が`except`に存在するかどうかを(完全一致比較を使用して)確認します。存在しない場合、その要素は結果に含まれます。

この演算は以下の特性を維持します:

1. `source`の要素の順序が保持されます
2. `source`内の重複要素は、`except`に存在しない場合は保持されます
3. NULLは個別の値として扱われます

**構文**

```sql
arrayExcept(source, except)
```

**引数**

- `source` — フィルタリングする要素を含むソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `except` — 結果から除外する要素を含む配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`source`に含まれる要素のうち、`except`に見つからなかった要素を含む、入力配列と同じ型の配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**basic**

```sql title=クエリ
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=レスポンス
[1, 2, 2, 4]
```

**with_nulls1**

```sql title=クエリ
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=レスポンス
[1, NULL, NULL]
```

**with_nulls2**

```sql title=クエリ
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=レスポンス
[1]
```

**strings**

```sql title=クエリ
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=レスポンス
['apple', 'cherry']
```


## arrayExists {#arrayExists}

導入バージョン: v1.1

ソース配列内に `func(x[, y1, y2, ... yN])` が true を返す要素が少なくとも1つ存在する場合は `1` を返します。それ以外の場合は `0` を返します。

**構文**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素（`x`）および条件配列（`y`）を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

少なくとも1つの要素に対してラムダ関数が true を返す場合は `1`、それ以外の場合は `0` を返します [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=レスポンス
0
```


## arrayFill {#arrayFill}

導入バージョン: v20.1

`arrayFill`関数は、ソース配列を最初の要素から最後の要素まで順次処理し、ソース配列と条件配列の要素を使用して各位置でラムダ条件を評価します。位置iでラムダ関数がfalseと評価された場合、この関数は配列の現在の状態における位置i-1の要素でその要素を置き換えます。最初の要素は、条件に関係なく常に保持されます。

**構文**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x [, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数`func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列[`Array(T)`](/sql-reference/data-types/array)を返します

**例**

**単一配列の例**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**2つの配列の例**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```


## arrayFilter {#arrayFilter}

導入バージョン: v1.1

ラムダ関数が true を返すソース配列の要素のみを含む配列を返します。

**構文**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素（`x`）と条件配列（`y`）を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列のサブセットを返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**例 1**

```sql title=クエリ
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=レスポンス
['abc World']
```

**例 2**

```sql title=クエリ
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=レスポンス
[2]
```


## arrayFirst {#arrayFirst}

導入バージョン: v1.1

`func(x[, y1, y2, ... yN])` が true を返すソース配列内の最初の要素を返します。該当する要素がない場合はデフォルト値を返します。

**構文**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素（`x`）と条件配列（`y`）に対して操作を行うラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**返り値**

`λ` が true となるソース配列内の最初の要素を返します。該当する要素がない場合は `T` のデフォルト値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**一致なし**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayFirstIndex {#arrayFirstIndex}

導入バージョン: v1.1

ソース配列内で `func(x[, y1, y2, ... yN])` が true を返す最初の要素のインデックスを返します。該当する要素がない場合は `0` を返します。

**構文**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素 (`x`) と条件配列 (`y`) に対して操作を行うラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

`func` が true となるソース配列の最初の要素のインデックスを返します。該当する要素がない場合は `0` を返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**一致なし**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```


## arrayFirstOrNull {#arrayFirstOrNull}

導入バージョン: v1.1

ソース配列内で `func(x[, y1, y2, ... yN])` が true を返す最初の要素を返します。該当する要素がない場合は `NULL` を返します。

**構文**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素（`x`）と条件配列（`y`）を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`func` が true となるソース配列の最初の要素を返します。該当する要素がない場合は `NULL` を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**一致なし**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayFlatten {#arrayFlatten}

導入バージョン: v20.1

配列の配列をフラットな配列に変換します。

機能:

- 任意の深さのネストされた配列に適用されます。
- すでにフラットな配列は変更しません。

フラット化された配列には、すべてのソース配列の全要素が含まれます。

**構文**

```sql
arrayFlatten(arr)
```

**エイリアス**: `flatten`

**引数**

- `arr` — 多次元配列。[`Array(Array(T))`](/sql-reference/data-types/array)

**戻り値**

多次元配列からフラット化された配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=レスポンス
[1, 2, 3]
```


## arrayFold {#arrayFold}

導入バージョン: v23.10

1つ以上の同じサイズの配列にラムダ関数を適用し、結果をアキュムレータに集約します。

**構文**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**引数**

- `λ(x, x1 [, x2, x3, ... xN])` — ラムダ関数 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`。ここで `F` は `acc` と `x` の配列値に適用される演算であり、`acc` の結果は再利用されます。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1 [, arr2, arr3, ... arrN]` — 操作対象となるN個の配列。[`Array(T)`](/sql-reference/data-types/array)
- `acc` — ラムダ関数の戻り値の型と同じ型を持つアキュムレータ値。

**戻り値**

最終的な `acc` 値を返します。

**例**

**使用例**

```sql title=クエリ
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=レスポンス
23
```

**フィボナッチ数列**

```sql title=クエリ
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=レスポンス
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**複数の配列を使用する例**

```sql title=クエリ
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=レスポンス
300
```


## arrayIntersect {#arrayIntersect}

導入バージョン: v1.1

複数の配列を受け取り、すべてのソース配列に共通して存在する要素を含む配列を返します。結果には重複のない一意の値のみが含まれます。

**構文**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**引数**

- `arrN` — 新しい配列を作成するためのN個の配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

すべてのN個の配列に共通して存在する一意の要素を含む配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=レスポンス
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex {#arrayJaccardIndex}

導入バージョン: v23.7

2つの配列の[Jaccard係数](https://en.wikipedia.org/wiki/Jaccard_index)を返します。

**構文**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**引数**

- `arr_x` — 1つ目の配列。[`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — 2つ目の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr_x`と`arr_y`のJaccard係数を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin {#arrayJoin}

導入バージョン: v1.1

`arrayJoin`関数は配列を含む行を受け取り、それを展開して複数の行を生成します。配列の各要素に対して1行ずつ生成されます。
これは、同じ行内で入力値を出力値にマッピングするClickHouseの通常関数や、
行のグループを受け取り、単一の集約行(または`GROUP BY`と共に使用する場合は集約行内の単一の値)に「圧縮」または「削減」する集約関数とは対照的です。

この関数が適用される列の値を除き、すべての列の値は単純にコピーされます。
適用される列の値は、対応する配列の要素に置き換えられます。

**構文**

```sql
arrayJoin(arr)
```

**引数**

- `arr` — 展開する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr`から展開された行のセットを返します。

**例**

**基本的な使用方法**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoinはクエリのすべてのセクションに影響します**

```sql title=Query
-- arrayJoin関数は、WHERE句を含むクエリのすべてのセクションに影響します。サブクエリが1行を返したにもかかわらず、結果が2になることに注意してください。

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**複数のarrayJoin関数の使用**

```sql title=Query
-- クエリは複数のarrayJoin関数を使用できます。この場合、変換が複数回実行され、行が乗算されます。

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**最適化による予期しない結果**

```sql title=Query
-- 同じ式で複数のarrayJoinを使用すると、最適化により期待される結果が得られない場合があります。
-- このような場合は、結合結果に影響を与えない追加の操作で繰り返される配列式を変更することを検討してください。
-- 例: arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- 技術的には正しいですが、結果セットが消失します
    arrayJoin(arrayConcat(dice, [])) as second_throw -- 再評価を強制するために意図的に式を変更
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─最初の投げ─┬─2回目の投げ─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**ARRAY JOIN 構文を使う**

```sql title=Query
-- 以下の`SELECT`クエリにおけるARRAY JOIN構文に注目してください。これにより、より幅広い処理が可能になります。
-- ARRAY JOINを使用すると、同じ要素数を持つ複数の配列を一度に変換できます。

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Tuple 型の使用**

```sql title=Query
-- Tupleを使用することもできます

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast {#arrayLast}

導入バージョン: v1.1

ラムダ関数 `func(x [, y1, y2, ... yN])` が true を返すソース配列内の最後の要素を返します。該当する要素がない場合はデフォルト値を返します。

**構文**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素（`x`）および条件配列（`y`）を操作するラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。 - `source` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)。 - `[, cond1, ... , condN]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

`func` が true となるソース配列内の最後の要素を返します。該当する要素がない場合は `T` 型のデフォルト値を返します。

**例**

**使用例**

```sql title=クエリ
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=レスポンス
c
```

**一致なし**

```sql title=クエリ
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=レスポンス
0 UInt8
```


## arrayLastIndex {#arrayLastIndex}

導入バージョン: v1.1

`func(x[, y1, y2, ... yN])` が true を返すソース配列内の最後の要素のインデックスを返します。該当する要素がない場合は '0' を返します。

**構文**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素 (`x`) および条件配列 (`y`) を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`func` が true となるソース配列内の最後の要素のインデックスを返します。該当する要素がない場合は `0` を返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**一致なし**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull {#arrayLastOrNull}

導入バージョン: v1.1

ラムダ関数 `func(x [, y1, y2, ... yN])` が真を返すソース配列の最後の要素を返します。該当する要素がない場合は `NULL` を返します。

**構文**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x [, y1, ..., yN])` — ソース配列の要素（`x`）と条件配列（`y`）に対して動作するラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**返り値**

`λ` が真となるソース配列の最後の要素を返します。該当する要素がない場合は `NULL` を返します。

**例**

**使用例**

```sql title=クエリ
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=結果
c
```

**一致なし**

```sql title=クエリ
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=結果
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance {#arrayLevenshteinDistance}

導入バージョン: v25.4

2つの配列間のレーベンシュタイン距離を計算します。

**構文**

```sql
arrayLevenshteinDistance(from, to)
```

**引数**

- `from` — 1つ目の配列。[`Array(T)`](/sql-reference/data-types/array)。
- `to` — 2つ目の配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

1つ目の配列と2つ目の配列間のレーベンシュタイン距離。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=クエリ
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=レスポンス
1
```


## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

導入バージョン: v25.4

各要素にカスタム重みを適用した2つの配列のレーベンシュタイン距離を計算します。
配列の要素数とその重みの数は一致している必要があります。

**構文**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**引数**

- `from` — 1番目の配列。[`Array(T)`](/sql-reference/data-types/array)
- `to` — 2番目の配列。[`Array(T)`](/sql-reference/data-types/array)
- `from_weights` — 1番目の配列の重み。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — 2番目の配列の重み。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**返り値**

各要素にカスタム重みを適用した1番目の配列と2番目の配列の間のレーベンシュタイン距離 [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=クエリ
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=レスポンス
14
```


## arrayMap {#arrayMap}

Introduced in: v1.1

元の配列の各要素にラムダ関数を適用して得られた配列を返します。

**構文**

```sql
arrayMap(func, arr)
```

**引数**

- `func` — ソース配列の要素（`x`）と条件配列（`y`）に対して動作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — 処理対象のN個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ラムダ関数の結果から構成される配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**異なる配列の要素からタプルを作成**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax {#arrayMax}

導入バージョン: v21.1

ソース配列内の最大要素を返します。

ラムダ関数 `func` が指定されている場合は、ラムダ関数の結果の最大要素を返します。

**構文**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — オプション。ソース配列（`x`）と条件配列（`y`）の要素を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列内の最大要素を返します。ラムダ関数が指定されている場合は、ラムダ関数の結果の最大要素を返します。

**例**

**基本的な例**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**ラムダ関数を使用した例**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin {#arrayMin}

導入バージョン: v21.1

ソース配列内の最小要素を返します。

ラムダ関数 `func` が指定されている場合、ラムダ関数の結果の最小値を返します。

**構文**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — 省略可能。ソース配列の要素（`x`）と条件配列（`y`）を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — 省略可能。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列内の最小要素を返します。ラムダ関数が指定されている場合、ラムダ関数の結果の最小値を返します。

**例**

**基本的な例**

```sql title=クエリ
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=結果
2
```

**ラムダ関数を使用した例**

```sql title=クエリ
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=結果
4
```


## arrayNormalizedGini {#arrayNormalizedGini}

導入バージョン: v25.1

正規化ジニ係数を計算します。

**構文**

```sql
arrayNormalizedGini(predicted, label)
```

**引数**

- `predicted` — 予測値。[`Array(T)`](/sql-reference/data-types/array)
- `label` — 実測値。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

予測値のジニ係数、正規化値のジニ係数、および正規化ジニ係数(= 前2つのジニ係数の比)を含むタプル [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**例**

**使用例**

```sql title=クエリ
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=レスポンス
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort {#arrayPartialReverseSort}

導入バージョン: v23.2

この関数は `arrayReverseSort` と同じですが、部分ソートを可能にする追加の `limit` 引数があります。

:::tip
ソート済みの要素のみを保持するには `arrayResize` を使用してください。
:::

**構文**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**引数**

- `f(arr[, arr1, ... ,arrN])` — 配列 `x` の要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — `f` が複数の引数を受け取る場合の N 個の追加配列。[`Array(T)`](/sql-reference/data-types/array)
- `limit` — ソートを実行する範囲の上限インデックス値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返り値**

元の配列と同じサイズの配列を返します。範囲 `[1..limit]` の要素は降順にソートされます。残りの要素 `(limit..N]` は不定の順序になります。

**例**

**simple_int**

```sql title=クエリ
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=結果
[9, 5, 1, 3]
```

**simple_string**

```sql title=クエリ
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=結果
['lasso','gladly','expenses','embolism']
```

**retain_sorted**

```sql title=クエリ
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=結果
[9, 5]
```

**lambda_simple**

```sql title=クエリ
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=結果
[1, 3, 5, 9]
```

**lambda_complex**

```sql title=クエリ
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=結果
[0, 1, 2]
```


## arrayPartialShuffle {#arrayPartialShuffle}

導入バージョン: v23.2

元の配列と同じサイズの配列を返します。範囲 `[1..limit]` の要素は元の配列からランダムに選ばれたサブセットとなります。残りの `(limit..n]` には、`[1..limit]` の範囲に含まれない要素が不定の順序で格納されます。
limit の値は `[1..n]` の範囲内である必要があります。この範囲外の値を指定した場合は、完全な `arrayShuffle` を実行した場合と同等になります:

:::note
この関数は定数をマテリアライズしません。

`limit` の値は `[1..N]` の範囲内である必要があります。この範囲外の値を指定した場合は、完全な [`arrayShuffle`](#arrayShuffle) を実行した場合と同等になります。
:::

**構文**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**引数**

- `arr` — シャッフルする配列。[`Array(T)`](/sql-reference/data-types/array)
- `seed` — オプション。乱数生成に使用するシード値。指定しない場合は、ランダムなシード値が使用されます。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `limit` — オプション。要素の入れ替え回数の上限で、範囲は `[1..N]` です。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

要素が部分的にシャッフルされた配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**no_limit1**

```sql title=クエリ
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=レスポンス
[2, 4, 3, 1]
```

**no_limit2**

```sql title=クエリ
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=レスポンス
[4, 1, 3, 2]
```

**random_seed**

```sql title=クエリ
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=レスポンス
[3, 4, 1, 2]
```

**explicit_seed**

```sql title=クエリ
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=レスポンス
[3, 2, 1, 4]
```

**materialize**

```sql title=クエリ
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=レスポンス
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort {#arrayPartialSort}

導入バージョン: v23.2

この関数は`arraySort`と同じですが、部分ソートを可能にする追加の`limit`引数があります。

:::tip
ソート済みの要素のみを保持するには`arrayResize`を使用してください。
:::

**構文**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**引数**

- `f(arr[, arr1, ... ,arrN])` — 配列`x`の要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — `f`が複数の引数を受け取る場合の追加配列(N個)。[`Array(T)`](/sql-reference/data-types/array)
- `limit` — ソートを実行する範囲の上限インデックス値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

元の配列と同じサイズの配列を返します。範囲`[1..limit]`の要素は昇順にソートされます。残りの要素`(limit..N]`は不定の順序になります。

**例**

**simple_int**

```sql title=クエリ
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=レスポンス
[1, 3, 5, 9]
```

**simple_string**

```sql title=クエリ
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=レスポンス
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain_sorted**

```sql title=クエリ
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=レスポンス
[1, 3]
```

**lambda_simple**

```sql title=クエリ
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=レスポンス
[9, 5, 1, 3]
```

**lambda_complex**

```sql title=クエリ
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=レスポンス
[2, 1, 0]
```


## arrayPopBack {#arrayPopBack}

導入バージョン: v1.1

配列から最後の要素を削除します。

**構文**

```sql
arrayPopBack(arr)
```

**引数**

- `arr` — 最後の要素を削除する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr`と同一ですが、`arr`の最後の要素を除いた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```


## arrayPopFront {#arrayPopFront}

導入バージョン: v1.1

配列の最初の要素を削除します。

**構文**

```sql
arrayPopFront(arr)
```

**引数**

- `arr` — 最初の要素を削除する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr`の最初の要素を除いた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=レスポンス
[2, 3]
```


## arrayProduct {#arrayProduct}

導入バージョン: v21.1

ソース配列の要素の積を返します。

ラムダ関数 `func` が指定されている場合は、ラムダ関数の結果の要素の積を返します。

**構文**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — オプション。ソース配列（`x`）と条件配列（`y`）の要素を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

ソース配列の要素の積、またはラムダ関数が指定されている場合はその結果の要素の積を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**基本的な例**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**ラムダ関数を使用した例**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack {#arrayPushBack}

導入バージョン: v1.1

配列の末尾に1つの要素を追加します。

**構文**

```sql
arrayPushBack(arr, x)
```

**引数**

- `arr` — 末尾に値 `x` を追加する配列。[`Array(T)`](/sql-reference/data-types/array)
- `x` — 配列の末尾に追加する単一の値。[`Array(T)`](/sql-reference/data-types/array)

:::note

- 数値の配列には数値のみを追加でき、文字列の配列には文字列のみを追加できます。
- 数値を追加する場合、ClickHouseは配列のデータ型に合わせて `x` の型を自動的に設定します。
- `NULL` を指定できます。この関数は配列に `NULL` 要素を追加し、配列要素の型は `Nullable` に変換されます。

ClickHouseのデータ型の詳細については、[データ型](/sql-reference/data-types)を参照してください。
:::

**戻り値**

`arr` と同一の配列を返しますが、配列の末尾に追加の値 `x` が含まれます。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=レスポンス
['a','b']
```


## arrayPushFront {#arrayPushFront}

導入バージョン: v1.1

配列の先頭に1つの要素を追加します。

**構文**

```sql
arrayPushFront(arr, x)
```

**引数**

- `arr` — 値 `x` を先頭に追加する配列。[`Array(T)`](/sql-reference/data-types/array)。
- `x` — 配列の先頭に追加する単一の値。[`Array(T)`](/sql-reference/data-types/array)。

:::note

- 数値の配列には数値のみを追加でき、文字列の配列には文字列のみを追加できます。
- 数値を追加する場合、ClickHouseは配列のデータ型に合わせて `x` の型を自動的に設定します。
- `NULL` を指定できます。この関数は配列に `NULL` 要素を追加し、配列要素の型は `Nullable` に変換されます。

ClickHouseのデータ型の詳細については、[データ型](/sql-reference/data-types)を参照してください。
:::

**戻り値**

`arr` と同一の配列を返しますが、配列の先頭に追加の値 `x` が含まれます。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=レスポンス
['a','b']
```


## arrayROCAUC {#arrayROCAUC}

導入バージョン: v20.4

受信者動作特性（ROC）曲線下面積を計算します。
ROC曲線は、すべての閾値において、y軸に真陽性率（TPR）、x軸に偽陽性率（FPR）をプロットすることで作成されます。
結果の値は0から1の範囲で、値が大きいほどモデルの性能が優れていることを示します。

ROC AUC（単にAUCとも呼ばれます）は機械学習における概念です。
詳細については、[こちら](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[こちら](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)、および[こちら](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)を参照してください。

**構文**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**エイリアス**: `arrayAUC`

**引数**

- `scores` — 予測モデルが出力するスコア。[`Array((U)Int*)`](/sql-reference/data-types/array)または[`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — サンプルのラベル。通常、陽性サンプルは1、陰性サンプルは0。[`Array((U)Int*)`](/sql-reference/data-types/array)または[`Enum`](/sql-reference/data-types/enum)
- `scale` — オプション。正規化された面積を返すかどうかを決定します。falseの場合、代わりにTP（真陽性）× FP（偽陽性）曲線下面積を返します。デフォルト値: true。[`Bool`](/sql-reference/data-types/boolean)
- `partial_offsets` —
- AUC全体ではなく、ROC曲線下の部分面積（ROC空間の垂直帯に相当）を計算するための4つの非負整数の配列。このオプションはROC AUCの分散計算に有用です。配列には次の要素[`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]を含める必要があります。非負の[整数](../data-types/int-uint.md)の[配列](/sql-reference/data-types/array)。オプション。
  - `higher_partitions_tp`: より高いスコアのパーティションにおける陽性ラベルの数。
  - `higher_partitions_fp`: より高いスコアのパーティションにおける陰性ラベルの数。
  - `total_positives`: データセット全体における陽性サンプルの総数。
  - `total_negatives`: データセット全体における陰性サンプルの総数。

:::note
`arr_partial_offsets`を使用する場合、`arr_scores`と`arr_labels`はデータセット全体の一部のパーティションのみであり、スコアの区間を含む必要があります。
データセットは連続したパーティションに分割する必要があり、各パーティションには特定の範囲内のスコアを持つデータのサブセットが含まれます。
例:

- あるパーティションには[0, 0.5)の範囲のすべてのスコアを含めることができます。
- 別のパーティションには[0.5, 1.0]の範囲のスコアを含めることができます。
  :::

**返される値**

受信者動作特性（ROC）曲線下面積を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=クエリ
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=レスポンス
0.75
```


## arrayRandomSample {#arrayRandomSample}

導入バージョン: v23.10

入力配列から`samples`個のランダムな要素を含む部分集合を返します。`samples`が入力配列のサイズを超える場合、サンプルサイズは配列のサイズに制限されます。つまり、すべての配列要素が返されますが、その順序は保証されません。この関数はフラット配列とネストされた配列の両方を処理できます。

**構文**

```sql
arrayRandomSample(arr, samples)
```

**引数**

- `arr` — 要素をサンプリングする入力配列または多次元配列。[`Array(T)`](/sql-reference/data-types/array)
- `samples` — ランダムサンプルに含める要素の数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

入力配列からランダムにサンプリングされた要素を含む配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**多次元配列の使用**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```


## arrayReduce {#arrayReduce}

導入バージョン: v1.1

配列要素に集約関数を適用し、その結果を返します。
集約関数の名前は、シングルクォートで囲まれた文字列として渡します（例: `'max'`、`'sum'`）。
パラメトリック集約関数を使用する場合、パラメータは関数名の後の括弧内に指定します（例: `'uniqUpTo(6)'`）。

**構文**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**引数**

- `agg_f` — 集約関数の名前（定数である必要があります）。[`String`](/sql-reference/data-types/string)
- `arr1 [, arr2, ... , arrN)]` — `agg_f` の引数に対応するN個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

集約関数の結果を返します。

**例**

**使用例**

```sql title=クエリ
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=レスポンス
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**複数の引数を使用する集約関数の例**

```sql title=クエリ
--集約関数が複数の引数を取る場合、この関数は同じサイズの複数の配列に適用する必要があります。

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=レスポンス
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**パラメトリック集約関数の例**

```sql title=クエリ
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=レスポンス
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges {#arrayReduceInRanges}

導入バージョン: v20.4

指定された範囲内の配列要素に集約関数を適用し、各範囲に対応する結果を含む配列を返します。
この関数は、複数の `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)` を実行した場合と同じ結果を返します。

**構文**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**引数**

- `agg_f` — 使用する集約関数の名前。[`String`](/sql-reference/data-types/string)
- `ranges` — 集約を行う範囲。開始インデックス `i` と集約する範囲の長さ `r` を含むタプル `(i, r)` の配列。[`Array(T)`](/sql-reference/data-types/array) または [`Tuple(T)`](/sql-reference/data-types/tuple)
- `arr1 [, arr2, ... ,arrN)]` — 集約関数に渡すN個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

指定された範囲に対する集約関数の結果を含む配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=レスポンス
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove {#arrayRemove}

導入バージョン: v25.11

配列から指定された値と等しいすべての要素を削除します。
NULLは等しいものとして扱われます。

**構文**

```sql
arrayRemove(arr, elem)
```

**エイリアス**: `array_remove`

**引数**

- `arr` — Array(T) - `elem` — T

**戻り値**

元の配列のサブセット [`Array(T)`](/sql-reference/data-types/array) を返します

**例**

**例 1**

```sql title=クエリ
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=レスポンス
[1, 3]
```

**例 2**

```sql title=クエリ
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=レスポンス
['a', 'b']
```


## arrayResize {#arrayResize}

導入バージョン: v1.1

配列の長さを変更します。

**構文**

```sql
arrayResize(arr, size[, extender])
```

**引数**

- `arr` — サイズ変更する配列。[`Array(T)`](/sql-reference/data-types/array)
- `size` — 配列の新しい長さ。
  `size`が配列の元のサイズより小さい場合、配列は右側から切り詰められます。
  `size`が配列の初期サイズより大きい場合、配列は`extender`の値、または配列要素のデータ型のデフォルト値で右側に拡張されます。
- `extender` — 配列を拡張する際に使用する値。`NULL`を指定できます。

**戻り値**

長さ`size`の配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**例 1**

```sql title=クエリ
SELECT arrayResize([1], 3);
```

```response title=結果
[1,0,0]
```

**例 2**

```sql title=クエリ
SELECT arrayResize([1], 3, NULL);
```

```response title=結果
[1,NULL,NULL]
```


## arrayReverse {#arrayReverse}

導入バージョン: v1.1

指定された配列の要素の順序を反転します。

:::note
関数 `reverse(arr)` は同じ機能を実行しますが、配列に加えて他のデータ型でも動作します。
:::

**構文**

```sql
arrayReverse(arr)
```

**引数**

- `arr` — 反転する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列と同じサイズで、要素が逆順に並んだ配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill {#arrayReverseFill}

導入バージョン: v20.1

`arrayReverseFill`関数は、ソース配列を最後の要素から最初の要素へ順次処理し、ソース配列と条件配列の要素を使用して各位置でラムダ条件を評価します。位置iで条件がfalseと評価された場合、その要素は配列の現在の状態における位置i+1の要素で置き換えられます。最後の要素は条件に関係なく常に保持されます。

**構文**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

ラムダの結果によってソース配列の要素が置き換えられた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**単一配列の例**

```sql title=クエリ
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=レスポンス
[1, 2, 2, NULL]
```

**複数配列の例**

```sql title=クエリ
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=レスポンス
[5, 6, 6, 2]
```


## arrayReverseSort {#arrayReverseSort}

導入バージョン: v1.1

配列の要素を降順にソートします。
関数 `f` が指定されている場合、提供された配列は配列の要素に関数を適用した結果に従ってソートされ、その後ソート済み配列が反転されます。
`f` が複数の引数を受け取る場合、`arrayReverseSort` 関数には `func` の引数に対応する複数の配列が渡されます。

ソート対象の配列に `-Inf`、`NULL`、`NaN`、または `Inf` が含まれている場合、以下の順序でソートされます:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**引数**

- `f(y1[, y2 ... yN])` — 配列 `x` の要素に適用するラムダ関数。
- `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
- `arr1, ..., yN` — オプション。`f` が複数の引数を受け取る場合の N 個の追加配列。

**戻り値**

ラムダ関数が提供されていない場合は降順にソートされた配列 `x` を返し、それ以外の場合は提供されたラムダ関数のロジックに従ってソートされ反転された配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**例 1**

```sql title=クエリ
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=レスポンス
[5,3,4]
```

**例 2**

```sql title=クエリ
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=レスポンス
[4,3,5]
```


## arrayReverseSplit {#arrayReverseSplit}

導入バージョン: v20.1

ソース配列を複数の配列に分割します。`func(x[, y1, ..., yN])` がゼロ以外の値を返すと、配列はその要素の右側で分割されます。配列は最後の要素の後では分割されません。

**構文**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素（`x`）と条件配列（`y`）を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列の配列を返します。[`Array(Array(T))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft {#arrayRotateLeft}

導入バージョン: v23.8

指定された要素数だけ配列を左に回転します。`n`が負の値の場合は、その絶対値だけ右に回転します。

**構文**

```sql
arrayRotateLeft(arr, n)
```

**引数**

- `arr` — 要素を回転する配列。[`Array(T)`](/sql-reference/data-types/array)。 - `n` — 回転する要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**戻り値**

指定された要素数だけ左に回転した配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**nが負の値の場合**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```


## arrayRotateRight {#arrayRotateRight}

導入バージョン: v23.8

配列を指定された要素数だけ右に回転させます。`n`が負の値の場合は、その絶対値だけ左に回転させます。

**構文**

```sql
arrayRotateRight(arr, n)
```

**引数**

- `arr` — 要素を回転させる配列。[`Array(T)`](/sql-reference/data-types/array)。 - `n` — 回転させる要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**戻り値**

指定された要素数だけ右に回転された配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=レスポンス
[5,6,1,2,3,4]
```

**nが負の値の場合**

```sql title=クエリ
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=レスポンス
[3,4,5,6,1,2]
```


## arrayShiftLeft {#arrayShiftLeft}

導入バージョン: v23.8

指定された要素数だけ配列を左にシフトします。
新しい要素は、指定された引数または配列要素型のデフォルト値で埋められます。
要素数が負の場合、配列は右にシフトされます。

**構文**

```sql
arrayShiftLeft(arr, n[, default])
```

**引数**

- `arr` — シフトする配列。[`Array(T)`](/sql-reference/data-types/array)。
- `n` — シフトする要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。
- `default` — オプション。新しい要素のデフォルト値。

**返り値**

指定された要素数だけ左にシフトされた配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=レスポンス
[3,4,5,6,0,0]
```

**nが負の値の場合**

```sql title=クエリ
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=レスポンス
[0,0,1,2,3,4]
```

**デフォルト値の使用**

```sql title=クエリ
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=レスポンス
[3,4,5,6,42,42]
```


## arrayShiftRight {#arrayShiftRight}

導入バージョン: v23.8

配列を指定した要素数だけ右にシフトします。
新しい要素は、指定した引数または配列要素型のデフォルト値で埋められます。
要素数が負の場合、配列は左にシフトされます。

**構文**

```sql
arrayShiftRight(arr, n[, default])
```

**引数**

- `arr` — シフトする配列。[`Array(T)`](/sql-reference/data-types/array)
- `n` — シフトする要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `default` — オプション。新しい要素のデフォルト値。

**戻り値**

指定した要素数だけ右にシフトされた配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=レスポンス
[0, 0, 1, 2, 3, 4]
```

**nが負の値の場合**

```sql title=クエリ
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=レスポンス
[3, 4, 5, 6, 0, 0]
```

**デフォルト値の使用**

```sql title=クエリ
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=レスポンス
[42, 42, 1, 2, 3, 4]
```


## arrayShingles {#arrayShingles}

導入バージョン: v24.1

シングル配列を生成します(文字列のngramに類似)。つまり、入力配列から指定された長さの連続する部分配列を生成します。

**構文**

```sql
arrayShingles(arr, l)
```

**引数**

- `arr` — シングル配列を生成する対象の配列。[`Array(T)`](/sql-reference/data-types/array)
- `l` — 各シングルの長さ。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

生成されたシングルの配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=レスポンス
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle {#arrayShuffle}

導入バージョン: v23.2

元の配列と同じサイズで、要素をシャッフルした順序で格納した配列を返します。
要素は、すべての可能な順列が等しい確率で出現するように並び替えられます。

:::note
この関数は定数をマテリアライズしません。
:::

**構文**

```sql
arrayShuffle(arr [, seed])
```

**引数**

- `arr` — シャッフルする配列。[`Array(T)`](/sql-reference/data-types/array)
- `seed (オプション)` — 乱数生成に使用するシード値。指定しない場合はランダムなシード値が使用されます。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

要素がシャッフルされた配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**シード値なしの例(結果は不安定)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**シード値ありの例(結果は安定)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```


## arraySimilarity {#arraySimilarity}

導入バージョン: v25.4

重み付きレーベンシュタイン距離に基づいて、2つの配列の類似度を`0`から`1`の範囲で計算します。

**構文**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**引数**

- `from` — 最初の配列 [`Array(T)`](/sql-reference/data-types/array)
- `to` — 2番目の配列 [`Array(T)`](/sql-reference/data-types/array)
- `from_weights` — 最初の配列の重み [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — 2番目の配列の重み [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**返り値**

重み付きレーベンシュタイン距離に基づいた2つの配列の類似度を`0`から`1`の範囲で返します [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=クエリ
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=レスポンス
0.2222222222222222
```


## arraySlice {#arraySlice}

導入バージョン: v1.1

`NULL`要素を含む配列のスライスを返します。

**構文**

```sql
arraySlice(arr, offset [, length])
```

**引数**

- `arr` — スライスする配列。[`Array(T)`](/sql-reference/data-types/array)
- `offset` — 配列の端からのオフセット。正の値は左からのオフセットを示し、負の値は右からのオフセットを示します。配列要素の番号付けは`1`から始まります。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `length` — 取得するスライスの長さ。負の値を指定すると、関数は開区間のスライス`[offset, array_length - length]`を返します。値を省略すると、関数は`[offset, 配列の末尾]`のスライスを返します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

指定された`offset`から`length`個の要素を持つ配列のスライス。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=レスポンス
[2, NULL, 4]
```


## arraySort {#arraySort}

導入バージョン: v1.1

指定された配列の要素を昇順にソートします。
ラムダ関数`f`が指定されている場合、ソート順序は配列の各要素に適用されたラムダの結果によって決定されます。
ラムダが複数の引数を受け取る場合、`arraySort`関数には`f`の引数に対応する複数の配列が渡されます。

ソート対象の配列に`-Inf`、`NULL`、`NaN`、または`Inf`が含まれている場合、次の順序でソートされます:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort`は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**引数**

- `f(y1[, y2 ... yN])` — 配列`x`の要素に適用するラムダ関数。
- `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
- `arr1, ..., yN` — オプション。`f`が複数の引数を受け取る場合のN個の追加配列。

**戻り値**

ラムダ関数が指定されていない場合は昇順にソートされた配列`arr`を返し、それ以外の場合は指定されたラムダ関数のロジックに従ってソートされた配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**例1**

```sql title=クエリ
SELECT arraySort([1, 3, 3, 0]);
```

```response title=レスポンス
[0,1,3,3]
```

**例2**

```sql title=クエリ
SELECT arraySort(['hello', 'world', '!']);
```

```response title=レスポンス
['!','hello','world']
```

**例3**

```sql title=クエリ
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=レスポンス
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit {#arraySplit}

導入バージョン: v20.1

ソース配列を複数の配列に分割します。`func(x [, y1, ..., yN])` がゼロ以外の値を返すと、配列はその要素の左側で分割されます。配列は最初の要素の前では分割されません。

**構文**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列の要素（`x`）と条件配列（`y`）を操作するラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 分割対象のソース配列 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**返り値**

配列の配列を返します [`Array(Array(T))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=レスポンス
[[1, 2, 3], [4, 5]]
```


## arraySum {#arraySum}

導入バージョン: v21.1

ソース配列の要素の合計を返します。

ラムダ関数 `func` が指定されている場合、ラムダ関数の結果の合計を返します。

**構文**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — オプション。ソース配列 (`x`) と条件配列 (`y`) の要素を操作するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。[`Array(T)`](/sql-reference/data-types/array)
- `, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列の要素の合計、またはラムダ関数が指定されている場合はラムダ関数の結果の合計を返します。

**例**

**基本的な例**

```sql title=クエリ
SELECT arraySum([1, 2, 3, 4]);
```

```response title=レスポンス
10
```

**ラムダ関数を使用した例**

```sql title=クエリ
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=レスポンス
8
```


## arraySymmetricDifference {#arraySymmetricDifference}

導入バージョン: v25.4

複数の配列を受け取り、すべてのソース配列に共通して存在しない要素を含む配列を返します。結果には一意の値のみが含まれます。

:::note
_3つ以上の集合_の対称差分は、[数学的には](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)、奇数個の入力集合に出現するすべての入力要素の集合として定義されます。
一方、関数`arraySymmetricDifference`は、すべての入力集合に出現しない入力要素の集合を単純に返します。
:::

**構文**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**引数**

- `arrN` — 新しい配列を作成するためのN個の配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

すべてのソース配列に存在しない個別の要素の配列を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion {#arrayUnion}

導入バージョン: v24.10

複数の配列を受け取り、いずれかのソース配列に存在するすべての要素を含む配列を返します。結果には一意の値のみが含まれます。

**構文**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**引数**

- `arrN` — 新しい配列を作成するためのN個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列から重複を除いた要素を含む配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=レスポンス
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq {#arrayUniq}

導入バージョン: v1.1

単一の引数が渡された場合、配列内の異なる要素の数をカウントします。
複数の引数が渡された場合、複数の配列の対応する位置にある要素から構成される異なる**タプル**の数をカウントします。

例えば `SELECT arrayUniq([1,2], [3,4], [5,6])` は以下のタプルを形成します:

- 位置 1: (1,3,5)
- 位置 2: (2,4,6)

その後、一意なタプルの数をカウントします。この場合は `2` です。

渡されるすべての配列は同じ長さである必要があります。

:::tip
配列内の一意な項目のリストを取得したい場合は、`arrayReduce('groupUniqArray', arr)` を使用できます。
:::

**構文**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**引数**

- `arr1` — 一意な要素の数をカウントする配列。[`Array(T)`](/sql-reference/data-types/array)
- `[, arr2, ..., arrN]` — オプション。複数の配列の対応する位置にある要素から構成される一意なタプルの数をカウントするために使用される追加の配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

単一の引数の場合、一意な要素の数を返します。複数の引数の場合、配列の対応する位置にある要素から構成される一意なタプルの数を返します。
[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**単一引数**

```sql title=クエリ
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=レスポンス
2
```

**複数引数**

```sql title=クエリ
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=レスポンス
3
```


## arrayWithConstant {#arrayWithConstant}

導入バージョン: v20.1

定数 `x` で埋められた長さ `length` の配列を作成します。

**構文**

```sql
arrayWithConstant(N, x)
```

**引数**

- `length` — 配列の要素数。[`(U)Int*`](/sql-reference/data-types/int-uint)
- `x` — 配列内の `N` 個の要素の値。任意の型。

**返り値**

値 `x` を持つ `N` 個の要素からなる配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT arrayWithConstant(3, 1)
```

```response title=レスポンス
[1, 1, 1]
```


## arrayZip {#arrayZip}

導入バージョン: v20.1

複数の配列を単一の配列に結合します。結果の配列には、元の配列の対応する要素が、引数として指定された順序でタプルにグループ化されて含まれます。

**構文**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**引数**

- `arr1, arr2, ... , arrN` — 単一の配列に結合するN個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列の要素がタプルにグループ化された配列を返します。タプル内のデータ型は入力配列の型と同じであり、配列が渡された順序と同じ順序になります。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned {#arrayZipUnaligned}

導入バージョン: v20.1

複数の配列を単一の配列に結合します。長さの異なる配列（不揃いの配列）を許容します。結果の配列には、引数として指定された順序でタプルにグループ化された、元の配列の対応する要素が含まれます。

**構文**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**引数**

- `arr1, arr2, ..., arrN` — 単一の配列に結合するN個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列の要素がタプルにグループ化された配列を返します。タプル内のデータ型は入力配列の型と同じであり、配列が渡された順序と同じ順序になります。[`Array(T)`](/sql-reference/data-types/array) または [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**例**

**使用例**

```sql title=クエリ
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=レスポンス
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual {#countEqual}

導入バージョン: v1.1

配列内で`x`と等しい要素の数を返します。`arrayCount(elem -> elem = x, arr)`と同等です。

`NULL`要素は個別の値として扱われます。

**構文**

```sql
countEqual(arr, x)
```

**引数**

- `arr` — 検索対象の配列。[`Array(T)`](/sql-reference/data-types/array)
- `x` — 配列内でカウントする値。任意の型。

**戻り値**

配列内で`x`と等しい要素の数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=レスポンス
2
```


## empty {#empty}

導入バージョン: v1.1

入力配列が空であるかどうかを確認します。

配列は要素を含まない場合に空とみなされます。

:::note
[`optimize_functions_to_subcolumns`設定](/operations/settings/settings#optimize_functions_to_subcolumns)を有効にすることで最適化できます。`optimize_functions_to_subcolumns = 1`の場合、この関数は配列列全体を読み取って処理する代わりに、[size0](/sql-reference/data-types/array#array-size)サブ列のみを読み取ります。クエリ`SELECT empty(arr) FROM TABLE;`は`SELECT arr.size0 = 0 FROM TABLE;`に変換されます。
:::

この関数は文字列型またはUUID型でも動作します。

**構文**

```sql
empty(arr)
```

**引数**

- `arr` — 入力配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

空の配列の場合は`1`を、空でない配列の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate {#emptyArrayDate}

導入バージョン: v1.1

空のDate配列を返します

**構文**

```sql
emptyArrayDate()
```

**引数**

- なし

**戻り値**

空のDate配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```


## emptyArrayDateTime {#emptyArrayDateTime}

導入バージョン: v1.1

空のDateTime配列を返します。

**構文**

```sql
emptyArrayDateTime()
```

**引数**

- なし

**返り値**

空のDateTime配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayDateTime
```

```response title=レスポンス
[]
```


## emptyArrayFloat32 {#emptyArrayFloat32}

導入バージョン: v1.1

空のFloat32配列を返します

**Syntax**

```sql
emptyArrayFloat32()
```

**引数**

- なし

**返り値**

空のFloat32配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayFloat32
```

```response title=レスポンス
[]
```


## emptyArrayFloat64 {#emptyArrayFloat64}

導入バージョン: v1.1

空のFloat64配列を返します

**構文**

```sql
emptyArrayFloat64()
```

**引数**

- なし

**戻り値**

空のFloat64配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayFloat64
```

```response title=レスポンス
[]
```


## emptyArrayInt16 {#emptyArrayInt16}

Introduced in: v1.1

空のInt16配列を返します

**構文**

```sql
emptyArrayInt16()
```

**引数**

- なし。

**戻り値**

空のInt16配列。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```


## emptyArrayInt32 {#emptyArrayInt32}

導入バージョン: v1.1

空のInt32配列を返します

**Syntax**

```sql
emptyArrayInt32()
```

**引数**

- なし

**返り値**

空のInt32配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayInt32
```

```response title=レスポンス
[]
```


## emptyArrayInt64 {#emptyArrayInt64}

導入バージョン: v1.1

空のInt64配列を返します

**構文**

```sql
emptyArrayInt64()
```

**引数**

- なし。

**戻り値**

空のInt64配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayInt64
```

```response title=レスポンス
[]
```


## emptyArrayInt8 {#emptyArrayInt8}

Introduced in: v1.1

空のInt8配列を返します

**構文**

```sql
emptyArrayInt8()
```

**引数**

- なし。

**戻り値**

空のInt8配列。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```


## emptyArrayString {#emptyArrayString}

導入バージョン: v1.1

空の文字列配列を返します

**Syntax**

```sql
emptyArrayString()
```

**引数**

- なし

**戻り値**

空の文字列配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```


## emptyArrayToSingle {#emptyArrayToSingle}

導入バージョン: v1.1

空の配列を受け取り、デフォルト値を持つ1要素の配列を返します。

**構文**

```sql
emptyArrayToSingle(arr)
```

**引数**

- `arr` — 空の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列のデフォルト型の値を1つ持つ配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な例**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16 {#emptyArrayUInt16}

導入バージョン: v1.1

空のUInt16配列を返します

**構文**

```sql
emptyArrayUInt16()
```

**引数**

- なし

**返り値**

空のUInt16配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayUInt16
```

```response title=レスポンス
[]
```


## emptyArrayUInt32 {#emptyArrayUInt32}

導入バージョン: v1.1

空のUInt32配列を返します

**構文**

```sql
emptyArrayUInt32()
```

**引数**

- なし

**戻り値**

空のUInt32配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayUInt32
```

```response title=レスポンス
[]
```


## emptyArrayUInt64 {#emptyArrayUInt64}

導入バージョン: v1.1

空のUInt64配列を返します

**構文**

```sql
emptyArrayUInt64()
```

**引数**

- なし

**戻り値**

空のUInt64配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayUInt64
```

```response title=レスポンス
[]
```


## emptyArrayUInt8 {#emptyArrayUInt8}

導入バージョン: v1.1

空のUInt8配列を返します

**構文**

```sql
emptyArrayUInt8()
```

**引数**

- なし

**戻り値**

空のUInt8配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT emptyArrayUInt8
```

```response title=レスポンス
[]
```


## has {#has}

導入バージョン: v1.1

配列に指定された要素が含まれているかどうかを返します。

**構文**

```sql
has(arr, x)
```

**引数**

- `arr` — 元の配列。[`Array(T)`](/sql-reference/data-types/array)
- `x` — 配列内で検索する値。

**戻り値**

配列に指定された要素が含まれている場合は`1`を、含まれていない場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用法**

```sql title=クエリ
SELECT has([1, 2, 3], 2)
```

```response title=レスポンス
1
```

**要素が見つからない場合**

```sql title=クエリ
SELECT has([1, 2, 3], 4)
```

```response title=レスポンス
0
```


## hasAll {#hasAll}

導入バージョン: v1.1

ある配列が別の配列のサブセットであるかどうかをチェックします。

- 空の配列は任意の配列のサブセットです。
- `Null`は値として処理されます。
- 両方の配列内の値の順序は関係ありません。

**構文**

```sql
hasAll(set, subset)
```

**引数**

- `set` — 要素の集合を持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)
- `subset` — `set`と共通のスーパータイプを共有する任意の型の配列で、`set`のサブセットであるかどうかをテストする要素を含みます。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

- `1`、`set`が`subset`のすべての要素を含む場合。
- `0`、それ以外の場合。

`set`と`subset`の要素が共通のスーパータイプを共有しない場合、`NO_COMMON_TYPE`例外が発生します。

**例**

**空の配列**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**NULL値を含む配列**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**異なる型の値を含む配列**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**文字列値を含む配列**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**共通の型を持たない配列**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
NO_COMMON_TYPE例外が発生します
```

**配列の配列**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```


## hasAny {#hasAny}

導入バージョン: v1.1

2つの配列に共通の要素が存在するかどうかを確認します。

- `Null`は値として処理されます。
- 両配列内の値の順序は問いません。

**構文**

```sql
hasAny(arr_x, arr_y)
```

**引数**

- `arr_x` — 要素の集合を持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — 配列`arr_x`と共通のスーパータイプを共有する任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

- `1`、`arr_x`と`arr_y`が少なくとも1つの共通要素を持つ場合。
- `0`、それ以外の場合。

2つの配列の要素が共通のスーパータイプを共有しない場合、`NO_COMMON_TYPE`例外が発生します。

**例**

**一方の配列が空の場合**

```sql title=クエリ
SELECT hasAny([1], [])
```

```response title=レスポンス
0
```

**NULL値を含む配列**

```sql title=クエリ
SELECT hasAny([Null], [Null, 1])
```

```response title=レスポンス
1
```

**異なる型の値を含む配列**

```sql title=クエリ
SELECT hasAny([-128, 1., 512], [1])
```

```response title=レスポンス
1
```

**共通の型を持たない配列**

```sql title=クエリ
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=レスポンス
`NO_COMMON_TYPE`例外が発生します
```

**配列の配列**

```sql title=クエリ
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=レスポンス
1
```


## hasSubstr {#hasSubstr}

導入バージョン: v20.6

array2のすべての要素がarray1に完全に同じ順序で出現するかどうかを確認します。
したがって、この関数は、array1 = prefix + array2 + suffixの場合に限り`1`を返します。

言い換えると、この関数は`hasAll`関数と同様にarray2のすべての要素がarray1に含まれているかどうかを確認します。
さらに、array1とarray2の両方で要素が同じ順序で出現するかどうかも確認します。

- array2が空の場合、この関数は`1`を返します。
- `Null`は値として処理されます。言い換えると、`hasSubstr([1, 2, NULL, 3, 4], [2,3])`は`0`を返します。しかし、`hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])`は`1`を返します。
- 両方の配列における値の順序は重要です。

2つの配列の要素のいずれかが共通のスーパータイプを共有しない場合、`NO_COMMON_TYPE`例外が発生します。

**構文**

```sql
hasSubstr(arr1, arr2)
```

**引数**

- `arr1` — 要素のセットを持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)
- `arr2` — 要素のセットを持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列`arr1`が配列`arr2`を含む場合は`1`を返します。それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**両方の配列が空の場合**

```sql title=クエリ
SELECT hasSubstr([], [])
```

```response title=レスポンス
1
```

**NULL値を含む配列**

```sql title=クエリ
SELECT hasSubstr([1, Null], [Null])
```

```response title=レスポンス
1
```

**異なる型の値を含む配列**

```sql title=クエリ
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=レスポンス
0
```

**文字列を含む配列**

```sql title=クエリ
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=レスポンス
1
```

**有効な順序を持つ配列**

```sql title=クエリ
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=レスポンス
1
```

**無効な順序を持つ配列**

```sql title=クエリ
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=レスポンス
0
```

**配列の配列**

```sql title=クエリ
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=レスポンス
1
```

**共通の型を持たない配列**

```sql title=クエリ
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=レスポンス
`NO_COMMON_TYPE`例外が発生します
```


## indexOf {#indexOf}

導入バージョン: v1.1

配列内に値'x'を持つ最初の要素のインデックス(1から始まる)を返します。
配列に検索対象の値が含まれていない場合、関数は`0`を返します。

`NULL`に設定された要素は通常の値として扱われます。

**構文**

```sql
indexOf(arr, x)
```

**引数**

- `arr` — `x`を検索する配列。[`Array(T)`](/sql-reference/data-types/array)
- `x` — インデックスを返す対象となる`arr`内の最初の一致要素の値。[`UInt64`](/sql-reference/data-types/int-uint)

**戻り値**

`arr`内に最初の`x`が存在する場合、そのインデックス(1から始まる番号)を返します。存在しない場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な例**

```sql title=クエリ
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=結果
4
```

**nullを含む配列**

```sql title=クエリ
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=結果
3
```


## indexOfAssumeSorted {#indexOfAssumeSorted}

導入バージョン: v24.12

配列内に値'x'を持つ最初の要素のインデックス（`1`から開始）を返します。
配列に検索対象の値が含まれていない場合、関数は`0`を返します。

:::note
`indexOf`関数とは異なり、この関数は配列が昇順にソートされていることを前提としています。配列がソートされていない場合、結果は未定義です。
:::

**構文**

```sql
indexOfAssumeSorted(arr, x)
```

**引数**

- `arr` — 検索対象のソート済み配列。[`Array(T)`](/sql-reference/data-types/array)
- `x` — ソート済み配列`arr`内でインデックスを返す対象となる最初の一致要素の値。[`UInt64`](/sql-reference/data-types/int-uint)

**戻り値**

`arr`内に`x`が存在する場合、最初に出現する位置のインデックス（1から始まる番号）を返します。存在しない場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な例**

```sql title=クエリ
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=レスポンス
5
```


## length {#length}

導入バージョン: v1.1

文字列または配列の長さを計算します。

- String または FixedString 引数の場合: 文字列のバイト数を計算します。
- Array 引数の場合: 配列内の要素数を計算します。
- FixedString 引数に適用された場合、この関数は定数式になります。

文字列のバイト数は、Unicodeの「コードポイント」の数とは異なり、Unicodeの「書記素クラスタ」(通常「文字」と呼ばれるもの)の数とも異なり、表示される文字列の幅とも異なることに注意してください。

文字列内にASCII NULLバイトが含まれていても問題なく、それらもカウントされます。

**構文**

```sql
length(x)
```

**エイリアス**: `OCTET_LENGTH`

**引数**

- `x` — バイト数(String/FixedStringの場合)または要素数(Arrayの場合)を計算する値。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Array(T)`](/sql-reference/data-types/array)

**返り値**

String/FixedString `x` のバイト数 / 配列 `x` の要素数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**文字列の例**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**配列の例**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**定数式の例**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**Unicodeの例**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ASCIIとUTF-8の比較例**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty {#notEmpty}

導入バージョン: v1.1

入力配列が空でないかどうかを確認します。

配列は、少なくとも1つの要素を含む場合に空でないと見なされます。

:::note
[`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns)設定を有効にすることで最適化できます。`optimize_functions_to_subcolumns = 1`の場合、この関数は配列カラム全体を読み取って処理する代わりに、[size0](/sql-reference/data-types/array#array-size)サブカラムのみを読み取ります。クエリ`SELECT notEmpty(arr) FROM table`は`SELECT arr.size0 != 0 FROM TABLE`に変換されます。
:::

この関数はString型またはUUID型でも動作します。

**構文**

```sql
notEmpty(arr)
```

**引数**

- `arr` — 入力配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

空でない配列の場合は`1`を、空の配列の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT notEmpty([1,2]);
```

```response title=応答
1
```


## range {#range}

導入バージョン: v1.1

`start`から`end - 1`までの数値を`step`刻みで含む配列を返します。

サポートされる型:

- `UInt8/16/32/64`
- `Int8/16/32/64]`

- すべての引数`start`、`end`、`step`は上記のサポートされる型のいずれかである必要があります。返される配列の要素は引数のスーパータイプになります。
- 関数が設定[`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block)で指定された要素数を超える合計長の配列を返す場合、例外がスローされます。
- いずれかの引数がNullable(nothing)型の場合、`NULL`を返します。いずれかの引数が`NULL`値(Nullable(T)型)の場合、例外がスローされます。

**構文**

```sql
range([start, ] end [, step])
```

**引数**

- `start` — オプション。配列の最初の要素。`step`を使用する場合は必須。デフォルト値: `0`。
- `end` — 必須。配列が構築される上限値(この値は含まれません)。
- `step` — オプション。配列内の各要素間の増分ステップを決定します。デフォルト値: `1`。

**戻り値**

`start`から`end - 1`までの数値を`step`刻みで含む配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=レスポンス
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate {#replicate}

導入バージョン: v1.1

単一の値を繰り返した配列を作成します。

**構文**

```sql
replicate(x, arr)
```

**引数**

- `x` — 結果配列を埋めるための値。[`Any`](/sql-reference/data-types)
- `arr` — 配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

値`x`で埋められた、`arr`と同じ長さの配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=レスポンス
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse {#reverse}

導入バージョン: v1.1

入力配列内の要素の順序、または入力文字列内の文字の順序を反転します。

**構文**

```sql
reverse(arr | str)
```

**引数**

- `arr | str` — 元となる配列または文字列。[`Array(T)`](/sql-reference/data-types/array) または [`String`](/sql-reference/data-types/string)

**戻り値**

要素または文字の順序を反転した配列または文字列を返します。

**例**

**配列の反転**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**文字列の反転**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

<!--AUTOGENERATED_END-->


## 距離関数 {#distance-functions}

サポートされているすべての関数については、[距離関数のドキュメント](../../sql-reference/functions/distance-functions.md)を参照してください。

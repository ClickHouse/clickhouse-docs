---
'description': 'Documentation for Array Functions'
'sidebar_label': '配列'
'slug': '/sql-reference/functions/array-functions'
'title': '配列関数'
'doc_type': 'reference'
---



# Array functions

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## array {#array}

Introduced in: v1.1


関数の引数から配列を作成します。

引数は定数である必要があり、共通のスーパークラスを持つ型でなければなりません。
少なくとも1つの引数を渡す必要があります。そうしないと、どのタイプの配列を作成するのかが不明だからです。
これは、この関数を使用して空の配列を作成することができないことを意味します。空の配列を作成するには、`emptyArray*`関数を使用してください。

同じ機能を持つ`[ ]`演算子を使用できます。
    

**構文**

```sql
array(x1 [, x2, ..., xN])
```

**引数**

- `x1` — 任意の型Tの定数値。 この引数のみが提供される場合、配列は型Tになります。 - `[, x2, ..., xN]` — `x1`と共通のスーパークラスを共有するN個の追加定数値 

**返される値**

渡された引数の中で 'T' が最小の共通型の配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**有効な使用法**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**無効な使用法**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```
## arrayAUCPR {#arrayAUCPR}

Introduced in: v20.4


精度-再現率（PR）曲線の下の面積を計算します。
精度-再現率曲線は、すべての閾値にわたってy軸に精度、x軸に再現率をプロットすることによって作成されます。
結果の値は0から1の範囲になり、高い値はモデルのパフォーマンスが良好であることを示します。
PR AUCは特に不均衡なデータセットに役立ち、そのケースにおけるROC AUCと比較してパフォーマンスを明確に比較します。
詳細については、[こちら](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[こちら](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)および[こちら](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)を参照してください。


**構文**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**引数**

- `cores` — 予測モデルが提供するスコア。 [`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — サンプルのラベル。通常、正のサンプルは1、負のサンプルは0です。 [`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Enum)`](/sql-reference/data-types/array)
- `partial_offsets` — 
- オプション。 PR曲線の部分的な領域を計算するための3つの非負整数の[`Array(T)`](/sql-reference/data-types/array)で、全体のAUCの代わりに（PRスペースの垂直バンドに相当）を計算します。このオプションは、PR AUCの分散計算に有用です。 配列は次の要素を含む必要があります [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]。
    - `higher_partitions_tp`: スコアの高いパーティション内の正ラベルの数。
    - `higher_partitions_fp`: スコアの高いパーティション内の負ラベルの数。
    - `total_positives`: データセット全体の正サンプルの総数。

::::note
`arr_partial_offsets`が使用される場合、`arr_scores`と`arr_labels`は全体のデータセットの一部である必要があり、スコアのインターバルを含む必要があります。
データセットは連続したパーティションに分割され、各パーティションには、特定の範囲内にスコアが落ちるデータのサブセットが含まれます。
例えば：
- あるパーティションには、範囲[0, 0.5)内のすべてのスコアが含まれます。
- 別のパーティションには、範囲[0.5, 1.0]内のスコアが含まれます。
::::
 

**返される値**

精度-再現率（PR）曲線の下の面積を返します。 [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```
## arrayAll {#arrayAll}

Introduced in: v1.1


`func(x [, y1, y2, ... yN])`がすべての要素に対して真を返す場合、`1`を返します。それ以外の場合は`0`を返します。


**構文**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

ラムダ関数がすべての要素に対して真を返す場合は`1`、そうでない場合は`0`を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**すべての要素が一致**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**すべての要素が一致しない**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```
## arrayAvg {#arrayAvg}

Introduced in: v21.1


ソース配列の要素の平均を返します。

ラムダ関数`func`が指定されている場合、ラムダの結果の要素の平均を返します。
    

**構文**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — オプション。ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

ソース配列の要素の平均、または提供された場合はラムダの結果の要素の平均を返します。 [`Float64`](/sql-reference/data-types/float)

**例**

**基本例**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**ラムダ関数を用いた使用例**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```
## arrayCompact {#arrayCompact}

Introduced in: v20.1

配列から連続する重複要素を削除します。`null`値も含まれます。結果の配列内の値の順序は、ソース配列の順序によって決まります。

**構文**

```sql
arrayCompact(arr)
```

**引数**

- `arr` — 重複を削除するための配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

重複のない配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```
## arrayConcat {#arrayConcat}

Introduced in: v1.1

引数として渡された配列を結合します。

**構文**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**引数**

- `arr1 [, arr2, ... , arrN]` — 結合するN個の配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

提供された配列引数からの単一の結合された配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```
## arrayCount {#arrayCount}

Introduced in: v1.1


`func(arr1[i], ..., arrN[i])`が真を返す要素の数を返します。
`func`が指定されていない場合、配列内のゼロでない要素の数を返します。

`arrayCount`は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。
    

**構文**

```sql
arrayCount([func, ] arr1, ...)
```

**引数**

- `func` — オプション。配列の各要素に適用される関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1, ..., arrN` — N個の配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

`func`が真を返す要素の数を返します。そうでなければ、配列内のゼロでない要素の数を返します。 [`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```
## arrayCumSum {#arrayCumSum}

Introduced in: v1.1

ソース配列の要素の部分的（累積）合計の配列を返します。ラムダ関数が指定されている場合は、各位置の配列要素にラムダを適用して合計が計算されます。

**構文**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**引数**

- `func` — オプション。各位置の配列要素に適用されるラムダ関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — 数値型のソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — オプション。同じサイズの追加の配列で、指定した場合はラムダ関数に引数として渡されます。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

ソース配列の要素の部分的合計の配列を返します。結果の型は、入力配列の数値型に一致します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使用法**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**ラムダを使用した場合**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```
## arrayCumSumNonNegative {#arrayCumSumNonNegative}

Introduced in: v18.12

負の累積和をゼロに置き換えたソース配列の要素の部分的（累積）合計の配列を返します。ラムダ関数が指定されている場合は、各位置の配列要素にラムダを適用して合計が計算されます。

**構文**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**引数**

- `func` — オプション。各位置の配列要素に適用されるラムダ関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — 数値型のソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — オプション。同じサイズの追加の配列で、指定した場合はラムダ関数に引数として渡されます。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

負の累積和をゼロに置き換えたソース配列の要素の部分的合計の配列を返します。結果の型は、入力配列の数値型に一致します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使用法**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**ラムダを使用した場合**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```
## arrayDifference {#arrayDifference}

Introduced in: v1.1


隣接配列要素間の差の配列を計算します。
結果配列の最初の要素は0、2番目は`arr[1] - arr[0]`、3番目は`arr[2] - arr[1]`、などとなります。
結果配列内の要素の型は、減算の型推論ルールによって決まります（例： `UInt8` - `UInt8` = `Int16`）。
    

**構文**

```sql
arrayDifference(arr)
```

**引数**

- `arr` — 隣接要素の間の差を計算するための配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

隣接配列要素間の差の配列を返します。 [`UInt*`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**結果型Int64によるオーバーフローの例**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```
## arrayDistinct {#arrayDistinct}

Introduced in: v1.1

配列内の重複しない要素のみを含む配列を返します。

**構文**

```sql
arrayDistinct(arr)
```

**引数**

- `arr` — 重複要素を抽出する配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

重複しない要素を含む配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```
## arrayDotProduct {#arrayDotProduct}

Introduced in: v23.5


2つの配列のドット積を返します。

:::note
2つのベクトルのサイズは等しくなければなりません。配列とタプルには異種の要素型を含むこともできます。
:::


**構文**

```sql
arrayDotProduct(v1, v2)
```

**引数**

- `v1` — 第1ベクトル。 [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) または [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
- `v2` — 第2ベクトル。 [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) または [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)


**返される値**

2つのベクトルのドット積を返します。

:::note
戻り値の型は引数の型によって決まります。配列またはタプルに異種の要素型が含まれている場合、結果の型はスーパークラスとなります。
:::

 [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)

**例**

**配列の例**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**タプルの例**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```
## arrayElement {#arrayElement}

Introduced in: v1.1


提供された配列のインデックス`n`にある要素を取得します。ここで、`n`は任意の整数型です。
インデックスが配列の範囲外の場合は、デフォルト値（数字の場合は0、文字列の場合は空文字列など）を返しますが、
非定数配列の引数と定数インデックス0の場合は例外があり、この場合は`Array indices are 1-based`というエラーが発生します。

:::note
ClickHouseの配列は1から始まります。
:::

負のインデックスもサポートされています。この場合、末尾から数えて対応する要素が選択されます。例えば、`arr[-1]`は配列の最後のアイテムです。

演算子`[n]`は同じ機能を提供します。
    

**構文**

```sql
arrayElement(arr, n)
```

**引数**

- `arr` — 検索する配列。 [`Array(T)`](/sql-reference/data-types/array)。 - `n` — 取得する要素の位置。 [`(U)Int*`](/sql-reference/data-types/int-uint). 

**返される値**

提供された配列引数からの単一の結合された配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**負のインデックス**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**[n]表記による使用**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**インデックスが配列の範囲外**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```
## arrayElementOrNull {#arrayElementOrNull}

Introduced in: v1.1


提供された配列のインデックス`n`にある要素を取得します。ここで、`n`は任意の整数型です。
インデックスが配列の範囲外の場合、デフォルト値の代わりに`NULL`が返されます。

:::note
ClickHouseの配列は1から始まります。
:::

負のインデックスもサポートされています。この場合、末尾から数えて対応する要素が選択されます。例えば、`arr[-1]`は配列の最後のアイテムです。


**構文**

```sql
arrayElementOrNull(arrays)
```

**引数**

- `arrays` — 任意の数の配列引数。 [`Array`](/sql-reference/data-types/array)


**返される値**

提供された配列引数からの単一の結合された配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**負のインデックス**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**インデックスが配列の範囲外**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```
## arrayEnumerate {#arrayEnumerate}

Introduced in: v1.1


配列 `[1, 2, 3, ..., length (arr)]` を返します。

この関数は通常、[`ARRAY JOIN`](/sql-reference/statements/select/array-join)句で使用されます。`ARRAY JOIN`を適用した各配列に対して何かを1回だけカウントすることを可能にします。
この関数は高階関数でも使用できます。たとえば、条件に一致する要素の配列インデックスを取得するために使用できます。


**構文**

```sql
arrayEnumerate(arr)
```

**引数**

- `arr` — 列挙する配列。 [`Array`](/sql-reference/data-types/array)


**返される値**

配列 `[1, 2, 3, ..., length (arr)]` を返します。 [`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**ARRAY JOINを用いた基本的な例**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```
## arrayEnumerateDense {#arrayEnumerateDense}

Introduced in: v18.12

ソース配列の各要素が最初に出現する位置を示す、ソース配列と同じサイズの配列を返します。

**構文**

```sql
arrayEnumerateDense(arr)
```

**引数**

- `arr` — 列挙する配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

`arr`と同じサイズの配列を返し、ソース配列の各要素が最初に出現する位置を示します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```
## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

Introduced in: v20.1

ソース配列と同じサイズの配列を返し、ソース配列の各要素が最初に出現する位置を示します。これは、多次元配列を列挙するためのもので、配列の内部をどれだけ深く探すかを指定することができます。

**構文**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**引数**

- `clear_depth` — 指定されたレベルの要素を個別に列挙します。`max_arr_depth`以下の正の整数である必要があります。 [`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — 列挙するN次元配列。 [`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — 有効な最大深度。`arr`の深度以下の正の整数である必要があります。 [`UInt*`](/sql-reference/data-types/int-uint)


**返される値**

ソース配列の各要素が最初に出現する位置を示す配列を返します。 [`Array`](/sql-reference/data-types/array)

**例**

**基本的な使用法**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result is identical to what arrayEnumerateDense would give.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**多次元配列を用いた使用法**

```sql title=Query
-- In this example, arrayEnumerateDenseRanked is used to obtain an array indicating, for each element of the
-- multidimensional array, what its position is among elements of the same value.
-- For the first row of the passed array, [10, 10, 30, 20], the corresponding first row of the result is [1, 1, 2, 3],
-- indicating that 10 is the first number encountered in position 1 and 2, 30 the second number encountered in position 3
-- and 20 is the third number encountered in position 4.
-- For the second row, [40, 50, 10, 30], the corresponding second row of the result is [4,5,1,2], indicating that 40
-- and 50 are the fourth and fifth numbers encountered in position 1 and 2 of that row, that another 10
-- (the first encountered number) is in position 3 and 30 (the second number encountered) is in the last position.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**clear_depthを増加させた例**

```sql title=Query
-- Changing clear_depth=2 results in the enumeration occurring separately for each row anew.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```
## arrayEnumerateUniq {#arrayEnumerateUniq}

Introduced in: v1.1


ソース配列と同じサイズの配列を返し、各要素が同じ値を持つ要素の中でどの位置にあるかを示します。

この関数は、`ARRAY JOIN`と配列要素の集約を使用する場合に便利です。

関数は、同じサイズの複数の配列を引数として取ることができます。この場合、すべての配列内での同じ位置にある要素のタプルに対して一意性が考慮されます。


**構文**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**引数**

- `arr1` — 処理する最初の配列。 [`Array(T)`](/sql-reference/data-types/array)
- `arr2, ...` — オプション。タプルの一意性のための同じサイズの追加配列。 [`Array(UInt32)`](/sql-reference/data-types/array)


**返される値**

同じ値またはタプルを持つ要素の中での位置を示す配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使用法**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**複数の配列**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**ARRAY JOIN集約**

```sql title=Query
-- Each goal ID has a calculation of the number of conversions (each element in the Goals nested data structure is a goal that was reached, which we refer to as a conversion)
-- and the number of sessions. Without ARRAY JOIN, we would have counted the number of sessions as sum(Sign). But in this particular case,
-- the rows were multiplied by the nested Goals structure, so in order to count each session one time after this, we apply a condition to the
-- value of the arrayEnumerateUniq(Goals.ID) function.

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```
## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

Introduced in: v20.1


ソース配列と同じ次元を持つ配列（または多次元配列）を返し、各要素が同じ値を持つ要素の中での位置を示します。
これは、多次元配列を列挙するためのもので、配列の内部をどれだけ深く探すかを指定することができます。


**構文**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**引数**

- `clear_depth` — 指定されたレベルの要素を個別に列挙します。正の整数で、`max_arr_depth`以下である必要があります。 [`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — 列挙するN次元配列。 [`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — 有効な最大深度。正の整数で、`arr`の深度以下である必要があります。 [`UInt*`](/sql-reference/data-types/int-uint)


**返される値**

各要素が同じ値を持つ要素に対するその要素の位置を示す、`arr`と同じサイズのN次元配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**例1**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniq would give for the same array.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**例2**

```sql title=Query
-- with clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniqwould give for the same array.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**例3**

```sql title=Query
-- In this example, arrayEnumerateUniqRanked is used to obtain an array indicating,
-- for each element of the multidimensional array, what its position is among elements
-- of the same value. For the first row of the passed array, [1, 2, 3], the corresponding
-- result is [1, 1, 1], indicating that this is the first time 1, 2 and 3 are encountered.
-- For the second row of the provided array, [2, 2, 1], the corresponding result is [2, 3, 3],
-- indicating that 2 is encountered for a second and third time, and 1 is encountered
-- for the second time. Likewise, for the third row of the provided array [3] the
-- corresponding result is [2] indicating that 3 is encountered for the second time.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**例4**

```sql title=Query
-- Changing clear_depth=2, results in elements being enumerated separately for each row.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```
## arrayExcept {#arrayExcept}

Introduced in: v25.9


`source`から`except`に含まれない要素を含む配列を返し、元の順序を保持します。

この関数は、2つの配列間の集合差演算を実行します。`source`の各要素について、`except`にその要素が存在するかを確認（厳密な比較を使用）します。存在しない場合、結果にその要素が含まれます。

この操作は以下の特性を維持します：
1. `source`の要素の順序が保持されます
2. `except`に存在しない場合、`source`の重複が保持されます
3. NULLは別の値として処理されます
    

**構文**

```sql
arrayExcept(source, except)
```

**引数**

- `source` — フィルタリングする要素を含むソース配列。  [`Array(T)`](/sql-reference/data-types/array)
- `except` — 結果から除外する要素を含む配列。  [`Array(T)`](/sql-reference/data-types/array)


**返される値**

`except`に見つからなかった`source`の要素を含む、入力配列と同じ型の配列を返します。  [`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な例**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with_nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with_nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**strings**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```
## arrayExists {#arrayExists}

Introduced in: v1.1


ソース配列の中に`func(x[, y1, y2, ... yN])`が真を返す要素が少なくとも1つ存在する場合、`1`を返します。そうでない場合は`0`を返します。


**構文**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

ラムダ関数が少なくとも1つの要素に対して真を返す場合は`1`、そうでない場合は`0`を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```
## arrayFill {#arrayFill}

Introduced in: v20.1


`arrayFill`関数は、最初の要素から最後の要素までソース配列を順に処理し、ソースと条件の配列からの要素を用いて各位置でのラムダ条件を評価します。 ラムダ関数が位置iでfalseを評価すると、その要素は配列の現在の状態から位置i-1の要素で置き換えられます。最初の要素は条件に関係なく常に保持されます。


**構文**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x [, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数 `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**単一配列を用いた例**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**2つの配列を用いた例**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```
## arrayFilter {#arrayFilter}

Introduced in: v1.1

ラムダ関数が真を返すソース配列の要素のみを含む配列を返します。

**構文**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

ソース配列の部分集合を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**例1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**例2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```
## arrayFirst {#arrayFirst}

Introduced in: v1.1


`func(x[, y1, y2, ... yN])`が真を返すソース配列の最初の要素を返します。そうでない場合はデフォルト値を返します。
    

**構文**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数。 [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array). 

**返される値**

ラムダが真であるソース配列の最初の要素を返します。そうでない場合は型Tのデフォルト値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**一致しない場合**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```
## arrayFirstIndex {#arrayFirstIndex}

Introduced in: v1.1


`func(x[, y1, y2, ... yN])`が真を返すソース配列の最初の要素のインデックスを返します。そうでない場合は`0`を返します。


**構文**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数。 [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array). 

**返される値**

`func`が真であるソース配列の最初の要素のインデックスを返します。そうでない場合は`0`を返します。 [`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**一致しない場合**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```
## arrayFirstOrNull {#arrayFirstOrNull}

Introduced in: v1.1


`func(x[, y1, y2, ... yN])`が真を返すソース配列の最初の要素を返します。そうでない場合は`NULL`を返します。
    

**構文**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列（`x`）と条件配列（`y`）の要素に対して動作するラムダ関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

`func`が真であるソース配列の最初の要素を返します。そうでない場合は`NULL`を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**一致しない場合**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```
## arrayFlatten {#arrayFlatten}

Introduced in: v20.1


配列の配列をフラットな配列に変換します。

関数：

- 任意の深さのネストされた配列に適用されます。
- すでにフラットな配列は変更しません。

フラット化された配列には、すべてのソース配列からのすべての要素が含まれます。


**構文**

```sql
arrayFlatten(arr)
```

**引数**

- `arr` — 多次元配列。 [`Array(Array(T))`](/sql-reference/data-types/array)


**返される値**

多次元配列からフラットな配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```
## arrayFold {#arrayFold}

Introduced in: v23.10

同じサイズの1つ以上の配列にラムダ関数を適用し、結果をアキュムレータに収集します。

**構文**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**引数**

- `λ(x, x1 [, x2, x3, ... xN])` — アキュムレータ`acc`と配列の値からの演算となるラムダ関数 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1 [, arr2, arr3, ... arrN]` — 操作対象のN個の配列。 [`Array(T)`](/sql-reference/data-types/array)
- `acc` — Lambda関数の戻り値型と同じ型のアキュムレータ値。 

**返される値**

最終的な`acc`値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**フィボナッチ数列**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**複数の配列を用いた例**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```
## arrayIntersect {#arrayIntersect}

Introduced in: v1.1

複数の配列を取得し、すべてのソース配列に存在する要素を含む配列を返します。結果は一意の値のみを含みます。

**構文**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**引数**

- `arrN` — 新しい配列を作成するためのN個の配列。 [`Array(T)`](/sql-reference/data-types/array). 

**返される値**

すべてのN個の配列に存在する一意の要素を含む配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```
## arrayJaccardIndex {#arrayJaccardIndex}

Introduced in: v23.7

2つの配列の[Jaccard指数](https://en.wikipedia.org/wiki/Jaccard_index)を返します。

**構文**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**引数**

- `arr_x` — 第1の配列。 [`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — 第2の配列。 [`Array(T)`](/sql-reference/data-types/array)


**返される値**

`arr_x`と`arr_y`のJaccard指数を返します。 [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```

## arrayJoin {#arrayJoin}

Introduced in: v1.1


`arrayJoin` 関数は、配列を含む行を受け取り、それを展開して複数の行を生成します - 配列内の各要素に対して1つの行を生成します。
これは、入力値を同じ行内の出力値にマッピングする ClickHouse の通常の関数や、行のグループを「圧縮」または「集約」して単一の要約行（または `GROUP BY` と一緒に使用された場合、要約行内の単一の値）を生成する集約関数とは対照的です。

この関数が適用されるカラムの値を除いて、各カラムのすべての値は単にコピーされます。
これらは、それに対応する配列の値に置き換えられます。


**構文**

```sql
arrayJoin(arr)
```

**引数**

- `arr` — 展開する配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

`arr` から展開された行のセットを返します。

**例**

**基本的な使用法**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin はクエリのすべてのセクションに影響します**

```sql title=Query
-- The arrayJoin function affects all sections of the query, including the WHERE section. Notice the result 2, even though the subquery returned 1 row.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**複数の arrayJoin 関数の使用**

```sql title=Query
- A query can use multiple arrayJoin functions. In this case, the transformation is performed multiple times and the rows are multiplied.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**最適化による予期しない結果**

```sql title=Query
-- Using multiple arrayJoin with the same expression may not produce the expected result due to optimizations.
-- For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.
- e.g. arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set
    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```

```response title=Response
┌─first_throw─┬─second_throw─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**ARRAY JOIN 構文の使用**

```sql title=Query
-- Note the ARRAY JOIN syntax in the `SELECT` query below, which provides broader possibilities.
-- ARRAY JOIN allows you to convert multiple arrays with the same number of elements at a time.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**タプルの使用**

```sql title=Query
-- You can also use Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```
## arrayLast {#arrayLast}

Introduced in: v1.1


ラムダ `func(x [, y1, y2, ... yN])` が真を返すソース配列の最後の要素を返します。そうでなければ、デフォルト値を返します。
    

**構文**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。 
- `source` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)。 
- `[, cond1, ... , condN]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)。 

**戻り値**

`func` が真であるソース配列の最後の要素を返し、そうでなければ `T` のデフォルト値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**一致なし**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```
## arrayLastIndex {#arrayLastIndex}

Introduced in: v1.1


`func(x[, y1, y2, ... yN])` が真を返すソース配列の最後の要素のインデックスを返します。そうでなければ '0' を返します。


**構文**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

`func` が真であるソース配列の最後の要素のインデックスを返し、そうでなければ `0` を返す [`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**一致なし**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```
## arrayLastOrNull {#arrayLastOrNull}

Introduced in: v1.1


ラムダ `func(x [, y1, y2, ... yN])` が真を返すソース配列の最後の要素を返します。そうでなければ `NULL` を返します。
    

**構文**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x [, y1, ..., yN])` — ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。 
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)。 
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)。 

**戻り値**

`λ` が真でないソース配列の最後の要素を返し、そうでなければ `NULL` を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**一致なし**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```
## arrayLevenshteinDistance {#arrayLevenshteinDistance}

Introduced in: v25.4

2つの配列の間のレーヴェンシュタイン距離を計算します。

**構文**

```sql
arrayLevenshteinDistance(from, to)
```

**引数**

- `from` — 最初の配列。 [`Array(T)`](/sql-reference/data-types/array)。 
- `to` — 2番目の配列。 [`Array(T)`](/sql-reference/data-types/array)。 

**戻り値**

最初の配列と2番目の配列の間のレーヴェンシュタイン距離。 [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```
## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

Introduced in: v25.4


カスタムの重みを持つ2つの配列のレーヴェンシュタイン距離を計算します。
配列の要素数とその重みは一致している必要があります。
    

**構文**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**引数**

- `from` — 最初の配列。 [`Array(T)`](/sql-reference/data-types/array)。 
- `to` — 2番目の配列。 [`Array(T)`](/sql-reference/data-types/array)。 
- `from_weights` — 最初の配列の重み。 [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — 2番目の配列の重み。 [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)


**戻り値**

各要素のカスタム重みを持つ最初の配列と2番目の配列の間のレーヴェンシュタイン距離 [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```
## arrayMap {#arrayMap}

Introduced in: v1.1


ラムダ関数を各要素に適用して得られた配列を返します。


**構文**

```sql
arrayMap(func, arr)
```

**引数**

- `func` — ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — 処理する N 個の配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

ラムダの結果から得られた配列を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**異なる配列からの要素のタプルを作成**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```
## arrayMax {#arrayMax}

Introduced in: v21.1


ソース配列の中で最大の要素を返します。

ラムダ関数 `func` が指定されている場合は、ラムダの結果の最大要素を返します。
    

**構文**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — オプション。ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

ソース配列の中で最大の要素、または提供される場合はラムダの結果の中で最大の要素を返します。

**例**

**基本的な例**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**ラムダ関数を使用した場合**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```
## arrayMin {#arrayMin}

Introduced in: v21.1


ソース配列の中で最小の要素を返します。

ラムダ関数 `func` が指定されている場合は、ラムダの結果の最小要素を返します。
    

**構文**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — オプション。ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

ソース配列の中で最小の要素、または提供される場合はラムダの結果の中で最小の要素を返します。

**例**

**基本的な例**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**ラムダ関数を使用した場合**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```
## arrayNormalizedGini {#arrayNormalizedGini}

Introduced in: v25.1

正規化されたジニ係数を計算します。

**構文**

```sql
arrayNormalizedGini(predicted, label)
```

**引数**

- `predicted` — 予測された値。 [`Array(T)`](/sql-reference/data-types/array)
- `label` — 実際の値。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

予測値のジニ係数、正規化された値のジニ係数、および正規化されたジニ係数 (= 前者の2つのジニ係数の比) を含むタプル [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**例**

**使用例**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```
## arrayPartialReverseSort {#arrayPartialReverseSort}

Introduced in: v23.2


この関数は `arrayReverseSort` と同じですが、部分ソートを可能にする `limit` 引数が追加されています。

:::tip
並べ替えられた要素のみを保持するには `arrayResize` を使用します。
:::
    

**構文**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**引数**

- `f(arr[, arr1, ... ,arrN])` — 配列 `x` の要素に適用するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — ソートされる配列。 [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — `f` が複数の引数を受け入れる場合の N 個の追加配列。 [`Array(T)`](/sql-reference/data-types/array)
- `limit` — ソートが行われるインデックス値。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**戻り値**

元の配列と同じサイズの配列を返し、範囲 `[1..limit]` の要素が降順にソートされます。残りの要素 `(limit..N]` は順序が不明です。

**例**

**simple_int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple_string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain_sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda_simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda_complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```
## arrayPartialShuffle {#arrayPartialShuffle}

Introduced in: v23.2


元の配列のサイズと同じ配列を返し、範囲 `[1..limit]` の要素は元の配列のランダムな部分集合です。残り `(limit..n]` には、範囲 `[1..limit]` に含まれない要素が無秩序に含まれます。
`limit` の値は範囲 `[1..n]` 内にある必要があります。範囲外の値は、完全な `arrayShuffle` を実行することと同等です：

:::note
この関数は定数をマテリアライズしません。

`limit` の値は範囲 `[1..N]` にあるべきです。範囲外の値は完全な [`arrayShuffle`](#arrayShuffle) を実行することと同等です。
:::
    

**構文**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**引数**

- `arr` — シャッフルする配列。 [`Array(T)`](/sql-reference/data-types/array)
- `seed` — オプション。乱数生成に使用されるシード。指定しない場合は、ランダムなものが使用されます。 [`(U)Int*`](/sql-reference/data-types/int-uint)
- `limit` — オプション。要素のスワップを制限する数、範囲 `[1..N]` 内。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**戻り値**

部分的にシャッフルされた要素を含む配列。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**no_limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no_limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random_seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit_seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```
## arrayPartialSort {#arrayPartialSort}

Introduced in: v23.2


この関数は `arraySort` と同じですが、部分ソートを可能にする `limit` 引数が追加されています。

:::tip
並べ替えられた要素のみを保持するには `arrayResize` を使用します。
:::
    

**構文**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**引数**

- `f(arr[, arr1, ... ,arrN])` — 配列 `x` の要素に適用するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — ソートされる配列。 [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — `f` が複数の引数を受け入れる場合の N 個の追加配列。 [`Array(T)`](/sql-reference/data-types/array)
- `limit` — ソートが行われるインデックス値。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**戻り値**

元の配列と同じサイズの配列を返し、範囲 `[1..limit]` の要素が昇順にソートされます。残りの要素 `(limit..N]` は順序が不明です。

**例**

**simple_int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple_string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain_sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda_simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda_complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```
## arrayPopBack {#arrayPopBack}

Introduced in: v1.1

配列から最後の要素を削除します。

**構文**

```sql
arrayPopBack(arr)
```

**引数**

- `arr` — 最後の要素を削除する配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

最後の要素が削除された `arr` と同一の配列を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```
## arrayPopFront {#arrayPopFront}

Introduced in: v1.1

配列から最初のアイテムを削除します。

**構文**

```sql
arrayPopFront(arr)
```

**引数**

- `arr` — 最初の要素を削除する配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

最初の要素が削除された `arr` と同一の配列を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```
## arrayProduct {#arrayProduct}

Introduced in: v21.1


ソース配列の要素の積を返します。

ラムダ関数 `func` が指定されている場合は、ラムダの結果の積を返します。
    

**構文**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — オプション。ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

ソース配列の要素の積を返し、または提供される場合はラムダの結果の積を返します。 [`Float64`](/sql-reference/data-types/float)

**例**

**基本的な例**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**ラムダ関数を使用した場合**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```
## arrayPushBack {#arrayPushBack}

Introduced in: v1.1

配列の末尾に1つのアイテムを追加します。

**構文**

```sql
arrayPushBack(arr, x)
```

**引数**

- `arr` — 値 `x` を末尾に追加する配列。 [`Array(T)`](/sql-reference/data-types/array)
- `x` — 
- 配列の末尾に追加される単一の値。 [`Array(T)`](/sql-reference/data-types/array)。

:::note
- 数値の配列には数値のみが追加でき、文字列の配列には文字列のみが追加できます。
- 数値を追加する場合、ClickHouse は自動的にデータ型に合わせて `x` の型を設定します。
- `NULL` にすることができます。この関数は配列に `NULL` 要素を追加し、配列要素の型は `Nullable` に変換されます。

ClickHouse のデータ型の詳細については、[データ型](/sql-reference/data-types)を参照してください。
:::
     

**戻り値**

末尾に追加された値 `x` を持つ `arr` と同一の配列を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```
## arrayPushFront {#arrayPushFront}

Introduced in: v1.1

配列の先頭に1つの要素を追加します。

**構文**

```sql
arrayPushFront(arr, x)
```

**引数**

- `arr` — 値 `x` を先頭に追加する配列。 [`Array(T)`](/sql-reference/data-types/array)。 - `x` — 
- 配列の先頭に追加される単一の値。 [`Array(T)`](/sql-reference/data-types/array)。

:::note
- 数値の配列には数値のみが追加でき、文字列の配列には文字列のみが追加できます。
- 数値を追加する場合、ClickHouse は自動的にデータ型に合わせて `x` の型を設定します。
- `NULL` にすることができます。この関数は配列に `NULL` 要素を追加し、配列要素の型は `Nullable` に変換されます。

ClickHouse のデータ型の詳細については、[データ型](/sql-reference/data-types)を参照してください。
:::
     

**戻り値**

先頭に追加された値 `x` を持つ `arr` と同一の配列を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```
## arrayROCAUC {#arrayROCAUC}

Introduced in: v20.4


受信者動作特性 (ROC) 曲線の下の面積を計算します。
ROC曲線は、真陽性率 (TPR) を y 軸に、偽陽性率 (FPR) を x 軸にしてすべての閾値をプロットすることで作成されます。
結果の値はゼロから一の範囲であり、高い値はモデルのパフォーマンスが良いことを示します。

ROC AUC (単に AUC とも呼ばれます) は、機械学習における概念です。
詳細については、[こちら](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[こちら](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)、および[こちら](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)を参照してください。


**構文**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**引数**

- `scores` — スコア予測モデルが提供します。 [`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — サンプルのラベル、通常は正のサンプルに対しては1、負のサンプルに対しては0です。 [`Array((U)Int*)`](/sql-reference/data-types/array) または [`Enum`](/sql-reference/data-types/enum)
- `scale` — オプション。正規化された面積を返すかどうかを決定します。falseの場合、TP（真陽性）×FP（偽陽性）曲線の下の面積を返します。デフォルト値: true。 [`Bool`](/sql-reference/data-types/boolean)
- `partial_offsets` — 
- ROC曲線の全体のAUCの代わりに、ROC曲線の下の部分的な面積を計算するための4つの非負整数の配列。このオプションは、ROC AUCの分散計算に便利です。配列は次の要素を含む必要があります [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]。 [Array](/sql-reference/data-types/array) の非負の[整数](../data-types/int-uint.md)。 オプション。
    - `higher_partitions_tp`: スコアが高いパーティションにおける正のラベルの数。
    - `higher_partitions_fp`: スコアが高いパーティションにおける負のラベルの数。
    - `total_positives`: 全データセットにおける正のサンプルの合計数。
    - `total_negatives`: 全データセットにおける負のサンプルの合計数。

::::note
`arr_partial_offsets` が使用される場合、`arr_scores` および `arr_labels` は、すべてのデータセットの部分集合である必要があり、スコアの範囲を含む必要があります。
データセットは、各パーティションが特定の範囲にスコアが含まれているデータのサブセットを含む連続したパーティションに分割する必要があります。
たとえば：
- 1つのパーティションは範囲 [0, 0.5) のすべてのスコアを含む場合があります。
- 別のパーティションは範囲 [0.5, 1.0] のスコアを含む場合があります。
::::
 

**戻り値**

受信者動作特性 (ROC) 曲線の下の面積を返します。 [`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```
## arrayRandomSample {#arrayRandomSample}

Introduced in: v23.10

入力配列のランダムな `samples` 個の要素のサブセットを返します。 `samples` が入力配列のサイズを超える場合、サンプルサイズは配列のサイズに制限されます。つまり、全ての配列要素が返されますが、その順序は保証されません。この関数は、フラットな配列とネストされた配列の両方を処理できます。

**構文**

```sql
arrayRandomSample(arr, samples)
```

**引数**

- `arr` — 要素をサンプリングするための入力配列または多次元配列。 [`Array(T)`](/sql-reference/data-types/array)
- `samples` — ランダムサンプルに含める要素の数。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**戻り値**

入力配列からのランダムサンプルの要素を含む配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**多次元配列を使用する**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```
## arrayReduce {#arrayReduce}

Introduced in: v1.1


配列の要素に集約関数を適用し、その結果を返します。
集約関数の名前は、シングルクオートで囲まれた文字列 `'max'`, `'sum'` として渡されます。
パラメトリック集約関数を使用する場合、関数名の後ろに括弧内にパラメータを示します `'uniqUpTo(6)'`。


**構文**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**引数**

- `agg_f` — 定数でなければならない集約関数の名前。 [`String`](/sql-reference/data-types/string)
- `arr1 [, arr2, ... , arrN)]` — `agg_f` の引数に対応する N 個の配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

集約関数の結果を返します

**例**

**使用例**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**複数の引数を持つ集約関数の例**

```sql title=Query
--If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**パラメトリック集約関数の例**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```
## arrayReduceInRanges {#arrayReduceInRanges}

Introduced in: v20.4


指定された範囲内の配列要素に集約関数を適用し、各範囲に対応する結果を含む配列を返します。
この関数は、複数の `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)` の結果と同じ結果を返します。


**構文**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**引数**

- `agg_f` — 使用する集約関数の名前。 [`String`](/sql-reference/data-types/string)
- `ranges` — 集約を行う範囲。インデックス `i` から始まり、集約を行う範囲 `r` を含むタプル `(i, r)` の配列。 [`Array(T)`](/sql-reference/data-types/array) または [`Tuple(T)`](/sql-reference/data-types/tuple)
- `arr1 [, arr2, ... ,arrN)]` — 集約関数への引数としての N 個の配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

指定された範囲内の集約関数の結果を含む配列を返します [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```
## arrayResize {#arrayResize}

Introduced in: v1.1

配列の長さを変更します。

**構文**

```sql
arrayResize(arr, size[, extender])
```

**引数**

- `arr` — サイズを変更する配列。 [`Array(T)`](/sql-reference/data-types/array)
- `size` — 
- 配列の新しい長さ。
元の配列のサイズよりも小さい場合、配列は右側から切り詰められます。
サイズが元の配列のサイズより大きい場合、配列は右側に `extender` 値またはデータ型のデフォルト値で拡張されます。
 - `extender` — 配列を拡張するために使用する値。 `NULL` であることができます。

**戻り値**

長さ `size` の配列。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**例 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**例 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```
## arrayReverse {#arrayReverse}

Introduced in: v1.1


指定された配列の要素の順序を反転します。

:::note
`reverse(arr)` 関数は同じ機能を提供しますが、配列だけでなく他のデータ型でも動作します。
:::


**構文**

```sql
arrayReverse(arr)
```

**引数**

- `arr` — 反転する配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

反転された順序の要素を含む元の配列と同じサイズの配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```
## arrayReverseFill {#arrayReverseFill}

Introduced in: v20.1


`arrayReverseFill` 関数は、ソース配列の最後の要素から最初の要素に向かって逐次的に処理を行い、各位置でソースと条件の配列の要素を使用してラムダ条件を評価します。条件が位置 i で偽に評価されると、その要素は配列の現在の状態からの位置 i+1 の要素で置き換えられます。最後の要素は、条件に関係なく常に保持されます。
    

**構文**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

ラムダの結果に基づいてソース配列の要素を置き換えた配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**単一配列の例**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**二つの配列の例**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```
## arrayReverseSort {#arrayReverseSort}

Introduced in: v1.1


配列の要素を降順にソートします。
関数 `f` が指定されている場合、提供された配列はその関数の結果に従ってソートされ、その後ソート済みの配列は反転されます。
`f` が複数の引数を受け取る場合、`arrayReverseSort` 関数には、`func` の引数に対応する複数の配列が渡されます。

ソートする配列に `-Inf`, `NULL`, `NaN`, または `Inf` が含まれている場合、それらは以下の順序でソートされます：

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` は [高次関数](/sql-reference/functions/overview#higher-order-functions)です。
    

**構文**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**引数**

- `f(y1[, y2 ... yN])` — 配列 `x` の要素に適用するラムダ関数。 - `arr` — ソートされる配列。 [`Array(T)`](/sql-reference/data-types/array) - `arr1, ..., yN` — オプション。 `f` が複数の引数を受け入れる場合の N 個の追加配列。 

**戻り値**

ラムダ関数が提供されていない場合は降順にソートされた配列 x を返し、そうでなければ提供されたラムダ関数のロジックに従ってソートされた配列を返します。その後、反転されます。 [`Array(T)`](/sql-reference/data-types/array)。

**例**

**例 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**例 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```
## arrayReverseSplit {#arrayReverseSplit}

Introduced in: v20.1

ソース配列を複数の配列に分割します。 `func(x[, y1, ..., yN])` がゼロ以外の値を返すと、配列はその要素の右側で分割されます。配列は最後の要素の後に分割されることはありません。

**構文**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

- `func(x[, y1, ..., yN])` — ソース配列 (`x`) と条件配列 (`y`) の要素に対して操作するラムダ関数。 [`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数に追加の引数を提供する N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)


**戻り値**

配列の配列を返します。 [`Array(Array(T))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```
## arrayRotateLeft {#arrayRotateLeft}

Introduced in: v23.8

指定された数の要素だけ配列を左に回転させます。`n` の負の値は、回転の絶対値を持つ右回転として扱われます。

**構文**

```sql
arrayRotateLeft(arr, n)
```

**引数**

- `arr` — 要素を回転させる配列。 [`Array(T)`](/sql-reference/data-types/array)。 - `n` — 回転させる要素の数。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。 

**戻り値**

指定された数の要素だけ左に回転された配列。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**負の n の値**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```
## arrayRotateRight {#arrayRotateRight}

Introduced in: v23.8

指定された数の要素だけ配列を右に回転させます。`n` の負の値は、回転の絶対値を持つ左回転として扱われます。

**構文**

```sql
arrayRotateRight(arr, n)
```

**引数**

- `arr` — 要素を回転させる配列。 [`Array(T)`](/sql-reference/data-types/array)。 - `n` — 回転させる要素の数。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。 

**戻り値**

指定された数の要素だけ右に回転された配列。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**負の n の値**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```
## arrayShiftLeft {#arrayShiftLeft}

Introduced in: v23.8

指定された数の要素だけ配列を左にシフトします。新しい要素は、提供された引数または配列要素タイプのデフォルト値で埋められます。要素数が負の場合、配列は右にシフトします。

**Syntax**

```sql
arrayShiftLeft(arr, n[, default])
```

**Arguments**

- `arr` — シフトする要素の配列。[`Array(T)`](/sql-reference/data-types/array). 
- `n` — シフトする要素の数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). 
- `default` — オプション。新しい要素のデフォルト値。 

**Returned value**

指定された数の要素だけ左にシフトされた配列 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**Negative value of n**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**Using a default value**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```

## arrayShiftRight {#arrayShiftRight}

Introduced in: v23.8

指定された数の要素だけ配列を右にシフトします。新しい要素は、提供された引数または配列要素タイプのデフォルト値で埋められます。要素数が負の場合、配列は左にシフトします。

**Syntax**

```sql
arrayShiftRight(arr, n[, default])
```

**Arguments**

- `arr` — シフトする要素の配列。 [`Array(T)`](/sql-reference/data-types/array)
- `n` — シフトする要素の数。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `default` — オプション。新しい要素のデフォルト値。 

**Returned value**

指定された数の要素だけ右にシフトされた配列 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**Negative value of n**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**Using a default value**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```

## arrayShingles {#arrayShingles}

Introduced in: v24.1

シングルの配列を生成します（文字列のn-gramsに類似）。つまり、入力配列の指定された長さの連続するサブ配列です。

**Syntax**

```sql
arrayShingles(arr, l)
```

**Arguments**

- `arr` — シングルの配列を生成するための配列。 [`Array(T)`](/sql-reference/data-types/array)
- `l` — 各シングルの長さ。 [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

生成されたシングルの配列 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```

## arrayShuffle {#arrayShuffle}

Introduced in: v23.2

元の配列と同じサイズの配列を返し、順番はシャッフルされています。要素はその順番の全ての可能な順列が同じ確率で出現するように並べ替えられます。

:::note
この関数は定数を物質化しません。
:::

**Syntax**

```sql
arrayShuffle(arr [, seed])
```

**Arguments**

- `arr` — シャッフルする配列。 [`Array(T)`](/sql-reference/data-types/array)
- `seed (optional)` — オプション。乱数生成に使用されるシード。提供しなければランダムなものが使用されます。 [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

シャッフルされた要素を持つ配列 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Example without seed (unstable results)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**Example without seed (stable results)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```

## arraySimilarity {#arraySimilarity}

Introduced in: v25.4

2つの配列の類似度を重み付きLevenshtein距離に基づいて`0`から`1`の範囲で計算します。

**Syntax**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**Arguments**

- `from` — 最初の配列 [`Array(T)`](/sql-reference/data-types/array)
- `to` — 2番目の配列 [`Array(T)`](/sql-reference/data-types/array)
- `from_weights` — 最初の配列の重み。 [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — 2番目の配列の重み。 [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Returned value**

重み付きLevenshtein距離に基づいて`0`から`1`の範囲での類似度を返します [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```

## arraySlice {#arraySlice}

Introduced in: v1.1

配列のスライスを返し、`NULL`要素を含みます。

**Syntax**

```sql
arraySlice(arr, offset [, length])
```

**Arguments**

- `arr` — スライスする配列。 [`Array(T)`](/sql-reference/data-types/array)
- `offset` — 配列の端からのインデント。正の値は左のオフセット、負の値は右のインデントを示します。配列項目の番号付けは`1`から始まります。 [`(U)Int*`](/sql-reference/data-types/int-uint)
- `length` — 必要なスライスの長さ。負の値を指定すると、関数はオープンスライス`[offset, array_length - length]`を返します。値を省略すると、関数はスライス`[offset, the_end_of_array]`を返します。 [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

指定された`offset`から`length`要素のスライスを返します [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```

## arraySort {#arraySort}

Introduced in: v1.1

提供された配列の要素を昇順にソートします。lambda関数`f`が指定されている場合、ソート順は配列の各要素にlambdaを適用した結果によって決まります。lambdaが複数の引数を受け取る場合、`arraySort`関数は`f`の引数に対応するいくつかの配列を渡します。

ソートする配列に`-Inf`、`NULL`、`NaN`、または`Inf`が含まれている場合、次の順序でソートされます。

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort`は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**Syntax**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**Arguments**

- `f(y1[, y2 ... yN])` — 配列`x`の要素に適用するlambda関数。 
- `arr` — ソートされる配列。 [`Array(T)`](/sql-reference/data-types/array) 
- `arr1, ..., yN` — オプション。`f`が複数の引数を受け取る場合の追加の配列。 

**Returned value**

lambda関数が提供されていない場合は昇順にソートされた配列`arr`を返し、そうでない場合は提供されたlambda関数のロジックに従ってソートされた配列を返します [`Array(T)`](/sql-reference/data-types/array)。

**Examples**

**Example 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**Example 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**Example 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```

## arraySplit {#arraySplit}

Introduced in: v20.1

ソース配列を複数の配列に分割します。`func(x [, y1, ..., yN])`がゼロ以外の値を返すと、配列はその要素の左側で分割されます。配列は最初の要素の前では分割されません。

**Syntax**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — ソース配列(`x`)および条件配列(`y`)の要素に作用するlambda関数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). 
- `source_arr` — 分割するソース配列 [`Array(T)`](/sql-reference/data-types/array). 
- `[, cond1_arr, ... , condN_arr]` — オプション。lambda関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array). 

**Returned value**

配列の配列を返します [`Array(Array(T))`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```

## arraySum {#arraySum}

Introduced in: v21.1

ソース配列の要素の合計を返します。

lambda関数`func`が指定されている場合、lambdaの結果の要素の合計を返します。

**Syntax**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — オプション。ソース配列（`x`）および条件配列（`y`）の要素に作用するlambda関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 処理するソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `, cond1_arr, ... , condN_arr]` — オプション。lambda関数に追加の引数を提供するN個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

ソース配列の要素の合計、または提供された場合はlambdaの結果の要素の合計を返します。

**Examples**

**Basic example**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**Usage with lambda function**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```

## arraySymmetricDifference {#arraySymmetricDifference}

Introduced in: v25.4

複数の配列を受け取り、すべてのソース配列に存在しない要素を含む配列を返します。結果にはユニークな値のみが含まれます。

:::note
2つ以上の集合の対称差は_[数学的に定義された](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)のは、入力要素の中で奇数回出現する全ての要素の集合です。一方、関数`arraySymmetricDifference`は単に全ての入力集合に出現しない入力要素の集合を返します。
:::

**Syntax**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**Arguments**

- `arrN` — 新しい配列を作成するためのN配列。 [`Array(T)`](/sql-reference/data-types/array). 

**Returned value**

すべてのソース配列に存在しない異なる要素の配列を返します [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```

## arrayUnion {#arrayUnion}

Introduced in: v24.10

複数の配列を受け取り、その一つのソース配列に存在するすべての要素を含む配列を返します。結果にはユニークな値のみが含まれます。

**Syntax**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Arguments**

- `arrN` — 新しい配列を作成するためのN配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

ソース配列からの異なる要素を持つ配列を返します [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```

## arrayUniq {#arrayUniq}

Introduced in: v1.1

単一の引数が渡された場合、配列内の異なる要素の数をカウントします。複数の引数が渡された場合、複数の配列における対応する位置の要素から作られる異なる**タプル**の数をカウントします。

例えば`SELECT arrayUniq([1,2], [3,4], [5,6])`は次のタプルを形成します：
* 位置1: (1,3,5)
* 位置2: (2,4,6)

その後、ユニークなタプルの数をカウントします。この場合、`2`となります。

渡されたすべての配列は同じ長さでなければなりません。

:::tip
配列内のユニークなアイテムのリストを取得したい場合は、`arrayReduce('groupUniqArray', arr)`を使用できます。
:::

**Syntax**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**Arguments**

- `arr1` — ユニークな要素の数をカウントするための配列。 [`Array(T)`](/sql-reference/data-types/array)
- `[, arr2, ..., arrN]` — オプション。複数の配列における対応する位置のユニークなタプルの数をカウントするために使用される追加の配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

単一の引数の場合はユニークな要素の数を返し、複数の引数の場合は配列間で対応する位置にある要素から作られるユニークなタプルの数を返します。 [`UInt32`](/sql-reference/data-types/int-uint)

**Examples**

**Single argument**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**Multiple argument**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```

## arrayWithConstant {#arrayWithConstant}

Introduced in: v20.1

長さ`length`の配列を生成し、定数`x`で埋めます。

**Syntax**

```sql
arrayWithConstant(N, x)
```

**Arguments**

- `length` — 配列内の要素数。 [`(U)Int*`](/sql-reference/data-types/int-uint)
- `x` — 配列内の`N`要素の値、任意のタイプ。 

**Returned value**

値`x`の`N`要素を持つ配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```

## arrayZip {#arrayZip}

Introduced in: v20.1

複数の配列を1つの配列に結合します。結果の配列は、引数の示された順にグループ化された元の配列の対応する要素を含みます。

**Syntax**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**Arguments**

- `arr1, arr2, ... , arrN` — 1つの配列にまとめるN個の配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

タプルとしてグループ化された元の配列から要素を持つ配列を返します。タプル内のデータ型は入力配列の型と同じであり、引数として渡された配列の順序に従います。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```

## arrayZipUnaligned {#arrayZipUnaligned}

Introduced in: v20.1

複数の配列を1つの配列に結合し、アラインされていない配列（異なる長さの配列）を許可します。結果の配列は、引数の示された順にグループ化された元の配列の対応する要素を含みます。

**Syntax**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Arguments**

- `arr1, arr2, ..., arrN` — 1つの配列にまとめるN個の配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

タプルとしてグループ化された元の配列から要素を持つ配列を返します。タプル内のデータ型は入力配列の型と同じであり、引数として渡された配列の順序に従います。 [`Array(T)`](/sql-reference/data-types/array)または[`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```

## countEqual {#countEqual}

Introduced in: v1.1

配列内の`x`と等しい要素の数を返します。`arrayCount(elem -> elem = x, arr)`と同等です。

`NULL`要素は個別の値として処理されます。

**Syntax**

```sql
countEqual(arr, x)
```

**Arguments**

- `arr` — 検索対象の配列。 [`Array(T)`](/sql-reference/data-types/array)
- `x` — 配列内でカウントされる値。任意のタイプ。 

**Returned value**

配列内の`x`と等しい要素の数を返します [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```

## empty {#empty}

Introduced in: v1.1

入力配列が空であるかどうかをチェックします。

配列は要素が含まれていない場合、空と見なされます。

:::note
[`optimize_functions_to_subcolumns`設定](/operations/settings/settings#optimize_functions_to_subcolumns)を有効にすることで最適化できます。`optimize_functions_to_subcolumns = 1`を設定すると、関数は配列の全体を読み取って処理する代わりに、[size0](/sql-reference/data-types/array#array-size)サブカラムのみを読み取ります。クエリ`SELECT empty(arr) FROM TABLE;`は`SELECT arr.size0 = 0 FROM TABLE;`に変換されます。
:::

この関数は[文字列](string-functions.md#empty)や[UUID](uuid-functions.md#empty)にも適用できます。

**Syntax**

```sql
empty(arr)
```

**Arguments**

- `arr` — 入力配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

空の配列の場合は`1`、空でない配列の場合は`0`を返します [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```

## emptyArrayDate {#emptyArrayDate}

Introduced in: v1.1

空のDate配列を返します。

**Syntax**

```sql
emptyArrayDate()
```

**Arguments**

- なし。

**Returned value**

空のDate配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```

## emptyArrayDateTime {#emptyArrayDateTime}

Introduced in: v1.1

空のDateTime配列を返します。

**Syntax**

```sql
emptyArrayDateTime()
```

**Arguments**

- なし。

**Returned value**

空のDateTime配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```

## emptyArrayFloat32 {#emptyArrayFloat32}

Introduced in: v1.1

空のFloat32配列を返します。

**Syntax**

```sql
emptyArrayFloat32()
```

**Arguments**

- なし。

**Returned value**

空のFloat32配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```

## emptyArrayFloat64 {#emptyArrayFloat64}

Introduced in: v1.1

空のFloat64配列を返します。

**Syntax**

```sql
emptyArrayFloat64()
```

**Arguments**

- なし。

**Returned value**

空のFloat64配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```

## emptyArrayInt16 {#emptyArrayInt16}

Introduced in: v1.1

空のInt16配列を返します。

**Syntax**

```sql
emptyArrayInt16()
```

**Arguments**

- なし。

**Returned value**

空のInt16配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```

## emptyArrayInt32 {#emptyArrayInt32}

Introduced in: v1.1

空のInt32配列を返します。

**Syntax**

```sql
emptyArrayInt32()
```

**Arguments**

- なし。

**Returned value**

空のInt32配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```

## emptyArrayInt64 {#emptyArrayInt64}

Introduced in: v1.1

空のInt64配列を返します。

**Syntax**

```sql
emptyArrayInt64()
```

**Arguments**

- なし。

**Returned value**

空のInt64配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```

## emptyArrayInt8 {#emptyArrayInt8}

Introduced in: v1.1

空のInt8配列を返します。

**Syntax**

```sql
emptyArrayInt8()
```

**Arguments**

- なし。

**Returned value**

空のInt8配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```

## emptyArrayString {#emptyArrayString}

Introduced in: v1.1

空のString配列を返します。

**Syntax**

```sql
emptyArrayString()
```

**Arguments**

- なし。

**Returned value**

空のString配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```

## emptyArrayToSingle {#emptyArrayToSingle}

Introduced in: v1.1

空の配列を受け取り、デフォルト値と等しい単一要素の配列を返します。

**Syntax**

```sql
emptyArrayToSingle(arr)
```

**Arguments**

- `arr` — 空の配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

配列のデフォルトタイプの単一値を持つ配列を返します。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Basic example**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```

## emptyArrayUInt16 {#emptyArrayUInt16}

Introduced in: v1.1

空のUInt16配列を返します。

**Syntax**

```sql
emptyArrayUInt16()
```

**Arguments**

- なし。

**Returned value**

空のUInt16配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```

## emptyArrayUInt32 {#emptyArrayUInt32}

Introduced in: v1.1

空のUInt32配列を返します。

**Syntax**

```sql
emptyArrayUInt32()
```

**Arguments**

- なし。

**Returned value**

空のUInt32配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```

## emptyArrayUInt64 {#emptyArrayUInt64}

Introduced in: v1.1

空のUInt64配列を返します。

**Syntax**

```sql
emptyArrayUInt64()
```

**Arguments**

- なし。

**Returned value**

空のUInt64配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```

## emptyArrayUInt8 {#emptyArrayUInt8}

Introduced in: v1.1

空のUInt8配列を返します。

**Syntax**

```sql
emptyArrayUInt8()
```

**Arguments**

- なし。

**Returned value**

空のUInt8配列。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```

## has {#has}

Introduced in: v1.1

配列が指定された要素を含むかどうかを返します。

**Syntax**

```sql
has(arr, x)
```

**Arguments**

- `arr` — ソース配列。 [`Array(T)`](/sql-reference/data-types/array)
- `x` — 配列で検索される値。 

**Returned value**

指定された要素が配列に含まれている場合は`1`、そうでなければ`0`を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Basic usage**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**Not found**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```

## hasAll {#hasAll}

Introduced in: v1.1

ある配列が別の配列の部分集合であるかどうかをチェックします。

- 空の配列は任意の配列の部分集合です。
- `Null`は値として処理されます。
- 両方の配列における値の順序は重要ではありません。

**Syntax**

```sql
hasAll(set, subset)
```

**Arguments**

- `set` — 要素の集合を持つ任意のタイプの配列。 [`Array(T)`](/sql-reference/data-types/array)
- `subset` — 要素が`set`の部分集合であるかどうかをテストするために`set`と共通のスーパタイプを共有する任意のタイプの配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

- `1`、`set`が`subset`のすべての要素を含む場合。
- `0`、そうでない場合。

集合と部分集合の要素が共通のスーパタイプを共有しない場合、`NO_COMMON_TYPE`例外が発生します。

**Examples**

**Empty arrays**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**Arrays containing NULL values**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**Arrays containing values of a different type**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**Arrays containing String values**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Arrays without a common type**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Raises a NO_COMMON_TYPE exception
```

**Array of arrays**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```

## hasAny {#hasAny}

Introduced in: v1.1

2つの配列がいくつかの要素によって交差しているかどうかをチェックします。

- `Null`は値として処理されます。
- 両方の配列における値の順序は重要ではありません。

**Syntax**

```sql
hasAny(arr_x, arr_y)
```

**Arguments**

- `arr_x` — 要素の集合を持つ任意のタイプの配列。 [`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — 配列`arr_x`と共通のスーパタイプを共有する任意のタイプの配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

- `1`、`arr_x`と`arr_y`が少なくとも1つの似た要素を持つ場合。
- `0`、そうでない場合。

いずれかの要素が共通のスーパタイプを共有しない場合、`NO_COMMON_TYPE`例外が発生します。

**Examples**

**One array is empty**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**Arrays containing NULL values**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**Arrays containing values of a different type**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**Arrays without a common type**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

**Array of arrays**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```

## hasSubstr {#hasSubstr}

Introduced in: v20.6

配列2のすべての要素が配列1に同じ順序で存在するかどうかをチェックします。したがって、この関数は`array1 = prefix + array2 + suffix`が成り立つ場合にのみ`1`を返します。

言い換えれば、関数は`hasAll`関数のように配列2のすべての要素が配列1に含まれているかどうかを確認します。さらに、両方の配列で要素が同じ順序であることもチェックします。

- 配列2が空である場合は、関数は`1`を返します。
- `Null`は値として処理されます。言い換えれば、`hasSubstr([1, 2, NULL, 3, 4], [2,3])`は`0`を返します。しかし、`hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])`は`1`を返します。
- 両方の配列における値の順序は重要です。

いずれかの要素が共通のスーパタイプを共有しない場合、`NO_COMMON_TYPE`例外が発生します。

**Syntax**

```sql
hasSubstr(arr1, arr2)
```

**Arguments**

- `arr1` — 要素の集合を持つ任意のタイプの配列。 [`Array(T)`](/sql-reference/data-types/array)
- `arr2` — 要素の集合を持つ任意のタイプの配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

配列`arr1`が配列`arr2`を含む場合は`1`を返し、そうでない場合は`0`を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Both arrays are empty**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**Arrays containing NULL values**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**Arrays containing values of a different type**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**Arrays containing strings**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**Arrays with valid ordering**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**Arrays with invalid ordering**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**Array of arrays**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**Arrays without a common type**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

## indexOf {#indexOf}

Introduced in: v1.1

配列内に値'x'（1から始まる）を持つ最初の要素のインデックスを返します。配列に検索される値が含まれていない場合、この関数は`0`を返します。

`NULL`に設定されている要素は通常の値として処理されます。

**Syntax**

```sql
indexOf(arr, x)
```

**Arguments**

- `arr` — `x`を検索する配列。 [`Array(T)`](/sql-reference/data-types/array)
- `x` — インデックスを返すために`arr`内の最初の一致する要素の値。 [`UInt64`](/sql-reference/data-types/int-uint)

**Returned value**

配列内に最初の`x`が存在する場合はそのインデックス（1から番号が付けられます）を返し、そうでない場合は`0`を返します。 [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Basic example**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**Array with nulls**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```

## indexOfAssumeSorted {#indexOfAssumeSorted}

Introduced in: v24.12

配列内に値'x'（1から始まる）を持つ最初の要素のインデックスを返します。配列に検索される値が含まれていない場合、この関数は`0`を返します。

:::note
`indexOf`関数とは異なり、この関数は配列が昇順にソートされていると仮定します。配列がソートされていない場合、結果は未定義です。
:::

**Syntax**

```sql
indexOfAssumeSorted(arr, x)
```

**Arguments**

- `arr` — 検索するソート済み配列。 [`Array(T)`](/sql-reference/data-types/array)
- `x` — ソートされた`arr`内の最初の一致する要素の値。 [`UInt64`](/sql-reference/data-types/int-uint)

**Returned value**

配列内に最初の`x`が存在する場合はそのインデックス（1から番号が付けられます）を返し、そうでない場合は`0`を返します。 [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Basic example**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```

## length {#length}

Introduced in: v1.1

文字列または配列の長さを計算します。

- StringまたはFixedString引数の場合：文字列内のバイト数を計算します。
- Array引数の場合：配列の要素数を計算します。
- FixedString引数に適用される場合、関数は定数式です。

文字列内のバイト数はUnicode "code points"の数や、Unicode "grapheme clusters"（通常「文字」と呼ばれるもの）や、可視文字列の幅の数とは異なることに注意してください。

文字列にASCII NULLバイトを含めることは許容されており、それらもカウントされます。

**Syntax**

```sql
length(x)
```

**Arguments**

- `x` — バイト数（String/FixedStringの場合）または要素数（Arrayの場合）を計算するための値。 [`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)または[`Array(T)`](/sql-reference/data-types/array)

**Returned value**

String/FixedString `x`のバイト数または配列`x`の要素数を返します [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**String example**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**Array example**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**constexpr example**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**unicode example**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ascii_vs_utf8 example**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```

## notEmpty {#notEmpty}

Introduced in: v1.1

入力配列が非空であるかどうかをチェックします。

配列は少なくとも1つの要素を含む場合、非空と見なされます。

:::note
[`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns)設定を有効にすることで最適化できます。`optimize_functions_to_subcolumns = 1`を設定すると、関数は配列全体を読み取って処理するのではなく、[size0](/sql-reference/data-types/array#array-size)サブカラムのみを読み取ります。クエリ`SELECT notEmpty(arr) FROM table`は`SELECT arr.size0 != 0 FROM TABLE`に変換されます。
:::

この関数は[文字列](string-functions.md#notempty)や[UUID](uuid-functions.md#notempty)にも適用できます。

**Syntax**

```sql
notEmpty(arr)
```

**Arguments**

- `arr` — 入力配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

非空の配列の場合は`1`、空の配列の場合は`0`を返します [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```

## range {#range}

Introduced in: v1.1

`start`から`end - 1`までの数の配列をステップで返します。

サポートされるタイプは：
- `UInt8/16/32/64`
- `Int8/16/32/64`

すべての引数`start`、`end`、`step`は上記のいずれかのサポートされているタイプでなければなりません。返される配列の要素は引数のスーパタイプとなります。
- 引数のいずれかが[`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block)で設定された要素数を超える配列を返す場合、例外が発生します。
- 引数のいずれかがNullable（nothing）タイプの`NULL`を含む場合、`NULL`が返されます。引数のいずれかが`NULL`値（Nullable(T)タイプ）を持つ場合、例外が発生します。

**Syntax**

```sql
range([start, ] end [, step])
```

**Arguments**

- `start` — オプション。配列の最初の要素。`step`が使用される場合は必須。デフォルト値：`0`。 
- `end` — 必須。配列が構築される前の数。 
- `step` — オプション。配列内の各要素の間の増分ステップを指定します。デフォルト値：`1`。 

**Returned value**

`start`から`end - 1`までの数の配列をステップで返します。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```

## replicate {#replicate}

Introduced in: v1.1

単一の値を持つ配列を作成します。

**Syntax**

```sql
replicate(x, arr)
```

**Arguments**

- `x` — 結果の配列を埋める値。 [`Any`](/sql-reference/data-types)
- `arr` — 配列。 [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

`arr`と同じ長さの配列を返し、値`x`で埋められます。 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```
## reverse {#reverse}

導入日: v1.1

入力配列内の要素または入力文字列内の文字の順序を逆にします。

**構文**

```sql
reverse(arr | str)
```

**引数**

- `arr | str` — ソースの配列または文字列。 [`Array(T)`](/sql-reference/data-types/array) または [`String`](/sql-reference/data-types/string)

**返される値**

要素または文字の順序が逆になった配列または文字列を返します。

**例**

**配列を逆にする**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**文字列を逆にする**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```



<!--AUTOGENERATED_END-->
## Distance functions {#distance-functions}

サポートされているすべての関数は [distance functions documentation](../../sql-reference/functions/distance-functions.md) に記載されています。

---
description: '配列関数のドキュメント'
sidebar_label: '配列'
slug: /sql-reference/functions/array-functions
title: '配列関数'
doc_type: 'reference'
---

# 配列関連関数 {#array-functions}

{/* 
  以下のタグ内の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されるドキュメントに置き換えられます。タグ自体は変更したり削除したりしないでください。
  詳細は https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{/*AUTOGENERATED_START*/ }

## array {#array}

導入バージョン: v1.1

関数の引数から配列を作成します。

引数は定数であり、共通の上位型を持つ型でなければなりません。
どの型の配列を作成するかが不明確になるため、少なくとも 1 つの引数を渡す必要があります。
つまり、この関数を使用して空の配列を作成することはできません。空の配列を作成するには、`emptyArray*` 関数を使用してください。

同等の機能には `[ ]` 演算子を使用します。

**構文**

```sql
array(x1 [, x2, ..., xN])
```

**引数**

* `x1` — 任意の型 T の定数値。この引数だけが指定された場合、配列の型は T になります。 - `[, x2, ..., xN]` — `x1` と共通のスーパータイプを持つ追加の N 個の定数値

**戻り値**

渡された引数から求められる最小の共通型 T を要素型とする配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**有効な使用例**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**不正な使い方**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
サーバーから例外を受信しました (バージョン 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
型 Int32、DateTime、Int8 の共通スーパータイプが存在しません ...
```

## arrayAUCPR {#arrayAUCPR}

導入バージョン: v20.4

適合率‐再現率（PR）曲線における曲線下面積を計算します。
適合率‐再現率曲線は、すべてのしきい値に対して、y軸に適合率、x軸に再現率をプロットすることで作成されます。
得られる値は 0 から 1 の範囲であり、値が大きいほどモデルの性能が高いことを示します。
PR AUC は不均衡データセットに対して特に有用であり、そのようなケースでは ROC AUC と比較して性能をより明確に比較できます。
詳細については [こちら](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[こちら](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)、および [こちら](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve) を参照してください。

**構文**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**別名**: `arrayPRAUC`

**引数**

* `cores` — 予測モデルが出力するスコア。[`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — サンプルのラベル。通常、正例には 1、負例には 0 を使用します。[`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Enum)`](/sql-reference/data-types/array)
* `partial_offsets` —
* オプション。PR 曲線全体の AUC ではなく、PR 曲線下の部分領域（PR 空間の縦方向のバンドに相当）を計算するための、非負整数 3 要素からなる [`Array(T)`](/sql-reference/data-types/array)。このオプションは、PR AUC の分散計算に有用です。配列には次の要素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`] を含める必要があります。
  * `higher_partitions_tp`: より高いスコアのパーティション内にある正例ラベルの数。
  * `higher_partitions_fp`: より高いスコアのパーティション内にある負例ラベルの数。
  * `total_positives`: データセット全体に含まれる正例サンプルの総数。

:::note
`arr_partial_offsets` を使用する場合、`arr_scores` と `arr_labels` は、スコアのある区間に対応する、データセット全体の 1 つのパーティションだけを表す必要があります。
データセットは連続したパーティションに分割され、それぞれのパーティションには、スコアが特定の範囲に属するデータのサブセットが含まれている必要があります。
例えば次のようになります：

* あるパーティションには、[0, 0.5) の範囲にあるすべてのスコアを含めることができます。
* 別のパーティションには、[0.5, 1.0] の範囲にあるスコアを含めることができます。
  :::

**返り値**

適合率-再現率 (PR) 曲線下の面積を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```

## arrayAll {#arrayAll}

導入バージョン: v1.1

ラムダ式 `func(x [, y1, y2, ... yN])` がすべての要素に対して true を返す場合は `1` を返します。そうでない場合は `0` を返します。

**構文**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y1, ..., yN`）の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — 省略可能。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ラムダ関数がすべての要素に対して `true` を返す場合は `1`、それ以外の場合は `0` を返す。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**すべての要素が条件を満たす場合**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**すべての要素が一致しているとは限りません**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```

## arrayAvg {#arrayAvg}

導入バージョン: v21.1

入力配列の要素の平均値を返します。

ラムダ関数 `func` が指定された場合は、そのラムダの結果の平均値を返します。

**構文**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 省略可能。ソース配列 (`x`) および条件配列 (`y`) の要素に対して処理を行うラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を渡す N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列内の要素の平均値、またはラムダ関数が指定されている場合は、その結果要素の平均値を返します。[`Float64`](/sql-reference/data-types/float)

**使用例**

**基本的な例**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**Lambda 関数での使用方法**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```

## arrayCompact {#arrayCompact}

導入: v20.1

配列から連続する重複要素（`null` 値を含む）を削除します。結果の配列における値の順序は、元の配列内の順序によって決まります。

**構文**

```sql
arrayCompact(arr)
```

**引数**

* `arr` — 重複要素を削除する対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

重複値を含まない配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```

## arrayConcat {#arrayConcat}

導入バージョン: v1.1

引数として渡された配列を連結します。

**構文**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**引数**

* `arr1 [, arr2, ... , arrN]` — 連結する N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

引数として指定された配列を結合した 1 つの配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```

## arrayCount {#arrayCount}

導入バージョン: v1.1

`func(arr1[i], ..., arrN[i])` が true を返す要素の数を返します。
`func` が指定されていない場合は、配列内の非ゼロ要素の数を返します。

`arrayCount` は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arrayCount([func, ] arr1, ...)
```

**引数**

* `func` — 省略可能。配列の各要素に適用する関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1, ..., arrN` — N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`func` が true を返す要素の数を返します。`func` が指定されていない場合は、配列内の非ゼロ要素の数を返します。[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```

## arrayCumSum {#arrayCumSum}

導入バージョン: v1.1

元の配列の要素に対する部分和（累積和）からなる配列を返します。ラムダ関数が指定されている場合、各位置の要素にラムダを適用した結果に基づいて和を計算します。

**構文**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**引数**

* `func` — 省略可。各位置の配列要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — 数値を含む元の配列。[`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — 省略可。同じサイズの追加の配列。指定されている場合、ラムダ関数への引数として渡されます。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列の要素について、各位置までの部分和（累積和）の配列を返します。結果の型は入力配列の数値型と一致します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使い方**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**Lambda を使用する場合**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```

## arrayCumSumNonNegative {#arrayCumSumNonNegative}

導入バージョン: v18.12

元の配列の要素について、部分和（累積和）の配列を返し、負の累積和はゼロに置き換えます。ラムダ関数が指定されている場合は、各位置の配列要素にラムダを適用した結果に対する累積和を計算します。

**構文**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**引数**

* `func` — 省略可能。各位置の配列要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — 数値を含む元の配列。[`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — 省略可能。同じサイズの追加配列。指定された場合、ラムダ関数への引数として渡されます。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列内の要素の部分和からなる配列を返しますが、負の累積和はゼロに置き換えられます。結果の型は入力配列の数値型と一致します。[`Array(T)`](/sql-reference/data-types/array)

**使用例**

**基本的な使い方**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**ラムダを使用する場合**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```

## arrayDifference {#arrayDifference}

導入バージョン: v1.1

隣接する配列要素同士の差からなる配列を計算します。
結果配列の最初の要素は 0 となり、2 番目は `arr[1] - arr[0]`、3 番目は `arr[2] - arr[1]` というように続きます。
結果配列中の要素の型は、減算における型推論ルールによって決定されます（例: `UInt8` - `UInt8` = `Int16`）。

**構文**

```sql
arrayDifference(arr)
```

**引数**

* `arr` — 隣接する要素間の差分を計算する対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

隣接する配列要素間の差分を要素とする配列を返します。[`UInt*`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**結果型が Int64 の場合のオーバーフロー例**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```

## arrayDistinct {#arrayDistinct}

導入: v1.1

配列から重複を取り除き、一意な要素だけを含む配列を返します。

**構文**

```sql
arrayDistinct(arr)
```

**引数**

* `arr` — 重複のない要素を抽出する対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

重複のない要素を含む配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```

## arrayDotProduct {#arrayDotProduct}

v23.5 で導入

2 つの配列のドット積を返します。

:::note
2 つのベクトルの長さは同じである必要があります。Array および Tuple には、異なる型の要素が混在していてもかまいません。
:::

**構文**

```sql
arrayDotProduct(v1, v2)
```

**引数**

* `v1` — 1番目のベクトル。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) または [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
* `v2` — 2番目のベクトル。[`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) または [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**戻り値**

2つのベクトルのドット積。

:::note
戻り値の型は引数の型によって決まります。Array または Tuple に複数の異なる要素型が含まれている場合、結果の型はそれらのスーパータイプになります。
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal)

**例**

**Array の例**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**タプルの例**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```

## arrayElement {#arrayElement}

導入バージョン: v1.1

指定された配列の要素をインデックス `n` で取得します。ここで `n` は任意の整数型です。
インデックスが配列の範囲外の場合、デフォルト値（数値なら 0、文字列なら空文字列など）を返します。
ただし、引数が非定数配列で、インデックスに定数の 0 を指定した場合は例外で、この場合は `Array indices are 1-based` というエラーになります。

:::note
ClickHouse の配列のインデックスは 1 始まりです。
:::

負のインデックスもサポートされています。この場合、末尾から数えて番号付けされた対応する要素が選択されます。例えば、`arr[-1]` は配列の最後の要素です。

演算子 `[n]` は同じ機能を提供します。

**構文**

```sql
arrayElement(arr, n)
```

**引数**

* `arr` — 検索する配列。[`Array(T)`](/sql-reference/data-types/array)。 - `n` — 取得する要素の位置。[`(U)Int*`](/sql-reference/data-types/int-uint)。

**戻り値**

指定した配列引数を結合した 1 つの配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**負のインデックス指定**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**[n] 表記の使用**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**配列範囲外のインデックス**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```

## arrayElementOrNull {#arrayElementOrNull}

導入バージョン: v1.1

任意の整数型である `n` をインデックスとして、指定された配列の要素を取得します。
インデックスが配列の範囲外の場合、デフォルト値ではなく `NULL` が返されます。

:::note
ClickHouse の配列はインデックスが 1 から始まります。
:::

負のインデックスもサポートされています。この場合、末尾から数えた位置に対応する要素を選択します。たとえば、`arr[-1]` は配列の最後の要素です。

**構文**

```sql
arrayElementOrNull(配列)
```

**引数**

* `arrays` — 任意数の配列引数。[`Array`](/sql-reference/data-types/array)

**戻り値**

与えられた配列引数を結合した単一の配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**負のインデックス**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**配列の範囲外のインデックス**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```

## arrayEnumerate {#arrayEnumerate}

導入バージョン: v1.1

配列 `[1, 2, 3, ..., length (arr)]` を返します。

この関数は通常、[`ARRAY JOIN`](/sql-reference/statements/select/array-join) 句と一緒に使用されます。`ARRAY JOIN` を適用した後、各配列ごとに一度だけカウントできるようにします。
この関数は高階関数内でも使用できます。たとえば、条件に一致する要素の配列インデックスを取得するために使用できます。

**構文**

```sql
arrayEnumerate(arr)
```

**引数**

* `arr` — 列挙対象の配列。[`Array`](/sql-reference/data-types/array)

**戻り値**

配列 `[1, 2, 3, ..., length(arr)]` を返します。[`Array(UInt32)`](/sql-reference/data-types/array)

**例**

**ARRAY JOIN を使用した基本的な例**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```

## arrayEnumerateDense {#arrayEnumerateDense}

導入バージョン: v18.12

元の配列と同じサイズの配列を返し、各要素が元の配列内で最初に出現するインデックスを示します。

**構文**

```sql
arrayEnumerateDense(arr)
```

**引数**

* `arr` — 列挙する配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr` と同じサイズの配列を返します。各要素が元の配列 [`Array(T)`](/sql-reference/data-types/array) 内で最初に出現する位置（インデックス）を示します。

**例**

**使用例**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```

## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

導入バージョン: v20.1

元の配列と同じサイズの配列を返し、元の配列内で各要素が最初に出現する位置を示します。多次元配列を列挙する際に、配列のどの深さまで探索するかを指定できます。

**構文**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**引数**

* `clear_depth` — 指定した階層レベルの要素を個別に列挙します。`max_arr_depth` 以下である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — 列挙対象の N 次元配列。[`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — 有効な最大深さ。`arr` の深さ以下である必要があります。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

各要素が元の配列内で最初に出現した位置を示す配列を返します。[`Array`](/sql-reference/data-types/array)

**例**

**基本的な使い方**

```sql title=Query
-- clear_depth=1 かつ max_array_depth=1 の場合、結果は arrayEnumerateDense が返す値と同一です。

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**多次元配列での利用方法**

```sql title=Query
-- この例では、arrayEnumerateDenseRankedを使用して、多次元配列の各要素が
-- 同じ値を持つ要素の中で何番目に位置するかを示す配列を取得します。
-- 渡された配列の1行目[10, 10, 30, 20]に対して、結果の対応する1行目は[1, 1, 2, 3]となり、
-- これは10が位置1と2で1番目に出現する数値、30が位置3で2番目に出現する数値、
-- 20が位置4で3番目に出現する数値であることを示しています。
-- 2行目[40, 50, 10, 30]に対して、結果の対応する2行目は[4,5,1,2]となり、これは40と50が
-- その行の位置1と2で4番目と5番目に出現する数値であり、もう一つの10
-- (1番目に出現する数値)が位置3にあり、30(2番目に出現する数値)が最後の位置にあることを示しています。

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**`clear_depth` を大きく設定した例**

```sql title=Query
-- clear_depth=2 に変更すると、行ごとに列挙が個別に実行されます。

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```

## arrayEnumerateUniq {#arrayEnumerateUniq}

導入されたバージョン: v1.1

元の配列と同じサイズの配列を返し、各要素について、その値が同じである要素の中で何番目の出現であるかを示します。

この関数は、`ARRAY JOIN` と配列要素の集約を使用する場合に便利です。

この関数は、同じサイズの複数の配列を引数として受け取ることができます。この場合、一意性は、すべての配列において同じ位置にある要素のタプルに基づいて判定されます。

**構文**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**引数**

* `arr1` — 処理対象となる最初の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr2, ...` — 省略可能。タプルの一意性を判定するための、同じサイズの追加配列。[`Array(UInt32)`](/sql-reference/data-types/array)

**返される値**

各要素が、同じ値またはタプルを持つ要素群の中での位置を表す配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本的な使い方**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**複数の配列**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**ARRAY JOIN による集約**

```sql title=Query
-- 各ゴールIDには、コンバージョン数（Goalsネスト構造の各要素は達成されたゴールであり、これをコンバージョンと呼びます）
-- およびセッション数の計算が含まれます。ARRAY JOINを使用しない場合、セッション数はsum(Sign)としてカウントされます。しかし、このケースでは、
-- ネストされたGoals構造により行が複製されるため、各セッションを1回だけカウントするために、
-- arrayEnumerateUniq(Goals.ID)関数の値に条件を適用します。

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```

## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

導入: v20.1

元の配列と同じ次元を持つ配列（または多次元配列）を返し、
各要素について、同じ値を持つ要素の中でその要素が何番目に位置するかを示します。
多次元配列について、配列のどの深さまでを探索するかを指定して列挙できます。

**構文**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**引数**

* `clear_depth` — 指定したレベルの要素をそれぞれ別個に列挙します。`max_arr_depth` 以下の正の整数。[`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — 列挙対象の N 次元配列。[`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — 有効な最大の深さ。`arr` の深さ以下の正の整数。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

`arr` と同じサイズの N 次元配列を返します。各要素には、同じ値を持つ他の要素の中での位置が示されます。[`Array(T)`](/sql-reference/data-types/array)

**例**

**例 1**

```sql title=Query
-- clear_depth=1 かつ max_array_depth=1 の場合、arrayEnumerateUniqRanked の結果は
-- 同じ配列に対して arrayEnumerateUniq が返す結果と同一です。

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**例 2**

```sql title=Query
-- clear_depth=1 および max_array_depth=1 の場合、arrayEnumerateUniqRanked の結果は
-- 同じ配列に対して arrayEnumerateUniq が返す結果と同一になります。

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**例 3**

```sql title=Query
-- この例では、arrayEnumerateUniqRankedを使用して、多次元配列の各要素が
-- 同じ値を持つ要素の中で何番目に出現するかを示す配列を取得します。渡された配列の1行目[1, 2, 3]に対しては、
-- 対応する結果は[1, 1, 1]となり、1、2、3がそれぞれ初めて出現することを示しています。
-- 2行目の配列[2, 2, 1]に対しては、対応する結果は[2, 3, 3]となり、
-- 2が2回目と3回目に出現し、1が2回目に出現することを示しています。同様に、
-- 3行目の配列[3]に対しては、対応する結果は[2]となり、
-- 3が2回目に出現することを示しています。

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**例4**

```sql title=Query
-- clear_depth=2に変更すると、各行ごとに要素が個別に列挙されます。
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```

## arrayExcept {#arrayExcept}

導入バージョン: v25.9

`source` に含まれる要素のうち、`except` には存在しない要素だけを、元の順序を維持したまま返します。

この関数は、2 つの配列間で集合の差分操作を行います。`source` の各要素について、厳密な比較により同一の要素が `except` に存在するかを確認します。存在しない場合、その要素は結果に含まれます。

この操作には次の特性があります:

1. `source` の要素の順序は保持される
2. `source` 内の重複要素は、`except` に存在しない限り保持される
3. NULL は独立した値として扱われる

**構文**

```sql
arrayExcept(source, except)
```

**引数**

* `source` — フィルタ対象の要素を含む配列。[`Array(T)`](/sql-reference/data-types/array)
* `except` — 結果から除外する要素を含む配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`source` に含まれる要素のうち、`except` に存在しない要素だけを保持した、入力配列と同じ型の配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**使用例**

**基本**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with&#95;nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with&#95;nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**文字列**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```

## arrayExists {#arrayExists}

導入バージョン: v1.1

ソース配列内に、`func(x[, y1, y2, ... yN])` が true を返す要素が 1 つ以上存在する場合は `1` を返します。そうでない場合は `0` を返します。

**構文**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) と条件配列 (`y`) の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

少なくとも 1 つの要素に対してラムダ関数が `true` を返した場合は `1` を、それ以外の場合は `0` を返す。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```

## arrayFill {#arrayFill}

導入バージョン: v20.1

`arrayFill` 関数は、ソース配列を先頭の要素から最後の要素まで順に処理し、
ソース配列および条件配列の要素を用いて、各位置でラムダ式の条件を評価します。
位置 i においてラムダ関数の評価結果が false の場合、その要素は、
配列の現在の状態における位置 i-1 の要素で置き換えられます。
先頭要素は、どのような条件であっても常に保持されます。

**構文**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x [, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素に適用されるラムダ関数 `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列 [`Array(T)`](/sql-reference/data-types/array) を返します。

**使用例**

**単一配列の例**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**2 つの配列の例**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```

## arrayFilter {#arrayFilter}

導入バージョン: v1.1

ソース配列の要素のうち、ラムダ関数を適用した結果が true になるものだけを含む配列を返します。

**構文**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) および条件配列 (`y`) の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

ソース配列の部分集合を返します。[`Array(T)`](/sql-reference/data-types/array)

**使用例**

**例 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**例 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```

## arrayFirst {#arrayFirst}

導入: v1.1

`func(x[, y1, y2, ... yN])` が true を返す、元の配列内の最初の要素を返します。該当する要素がない場合はデフォルト値を返します。

**構文**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) および条件配列 (`y`) の要素に適用されるラムダ関数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)。- `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)。- `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**返される値**

`λ` が true を返す最初のソース配列の要素を返し、それ以外の場合は型 `T` のデフォルト値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**該当なし**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```

## arrayFirstIndex {#arrayFirstIndex}

導入バージョン: v1.1

`func(x[, y1, y2, ... yN])` が true を返す最初の要素のインデックスをソース配列から返します。該当する要素がない場合は &#39;0&#39; を返します。

**構文**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) および条件配列 (`y`) の要素に適用されるラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)。
* `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

`func` が true となるソース配列の最初の要素のインデックスを返し、それ以外の場合は `0` を返します。戻り値の型は [`UInt32`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**該当なし**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```

## arrayFirstOrNull {#arrayFirstOrNull}

導入バージョン: v1.1

`func(x[, y1, y2, ... yN])` が true を返す最初の要素をソース配列から返します。該当する要素がない場合は `NULL` を返します。

**構文**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列（`x`）および条件配列（`y`）の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`func` が真となるソース配列の最初の要素を返し、それ以外の場合は `NULL` を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**該当なし**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```

## arrayFlatten {#arrayFlatten}

導入バージョン: v20.1

配列の配列をフラットな配列に変換します。

この関数には次の特徴があります。

* 任意の深さにネストされた配列に適用できます。
* すでにフラットな配列は変更しません。

フラット化された配列には、すべての元の配列に含まれる要素が格納されます。

**構文**

```sql
arrayFlatten(arr)
```

**別名**: `flatten`

**引数**

* `arr` — 多次元配列。型は [`Array(Array(T))`](/sql-reference/data-types/array)

**返される値**

多次元配列をフラット化した配列 [`Array(T)`](/sql-reference/data-types/array) を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```

## arrayFold {#arrayFold}

導入バージョン: v23.10

サイズが等しい 1 つ以上の配列に対してラムダ関数を適用し、その結果をアキュムレータに蓄積します。

**構文**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**引数**

* `λ(x, x1 [, x2, x3, ... xN])` — ラムダ関数 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`。ここで `F` は `acc` と `x` からの配列値に適用される演算であり、その結果である `acc` が再利用されます。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1 [, arr2, arr3, ... arrN]` — 演算を行う N 個の配列。[`Array(T)`](/sql-reference/data-types/array)
* `acc` — ラムダ関数の戻り値と同じ型を持つアキュムレータ（累積）値。

**返される値**

最終的な `acc` の値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**フィボナッチ数列**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**複数の配列を使う例**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```

## arrayIntersect {#arrayIntersect}

導入: v1.1

複数の配列を受け取り、すべての入力配列に存在する要素だけを含む配列を返します。結果には一意の値のみが含まれます。

**構文**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**引数**

* `arrN` — 新しい配列を作成するための N 個の配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

すべての N 個の配列に共通して存在する一意な要素のみを含む配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**使用例**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```

## arrayJaccardIndex {#arrayJaccardIndex}

導入バージョン: v23.7

2 つの配列の [Jaccard index](https://en.wikipedia.org/wiki/Jaccard_index) を返します。

**構文**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**引数**

* `arr_x` — 1 つ目の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — 2 つ目の配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

`arr_x` と `arr_y` の Jaccard 指数を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```

## arrayJoin {#arrayJoin}

導入バージョン: v1.1

`arrayJoin` 関数は、配列を含む 1 行を受け取り、それを展開して、配列の各要素ごとに 1 行ずつ複数行を生成します。
これは、同じ行の中で入力値を出力値に対応づける ClickHouse の通常の関数とは対照的であり、
また、複数行を受け取ってそれらを 1 つのサマリー行に「圧縮」または「集約」する集約関数とも異なります
（`GROUP BY` と併用する場合は、サマリー行内の 1 つの値になります）。

この関数が適用される列を除き、列内のすべての値は単純にコピーされます。
適用された列の値は、対応する配列要素の値に置き換えられます。

**構文**

```sql
arrayJoin(arr)
```

**引数**

* `arr` — 展開する対象の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

`arr` を展開して得られる行の集合を返します。

**例**

**基本的な使い方**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin はクエリのすべての部分に影響します**

```sql title=Query
-- arrayJoin関数は、WHERE句を含むクエリのすべてのセクションに影響を与えます。サブクエリが1行を返しているにもかかわらず、結果が2になることに注意してください。

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**複数の arrayJoin 関数を使用する**

```sql title=Query
- クエリでは複数のarrayJoin関数を使用できます。この場合、変換が複数回実行され、行が増幅されます。

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**最適化によって生じる予期しない結果**

```sql title=Query
-- 同じ式で複数のarrayJoinを使用すると、最適化により期待した結果が得られない場合があります。
-- このような場合は、結合結果に影響しない追加の操作を加えて、繰り返される配列式を変更することを検討してください。
- 例: arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- 技術的には正しいが、結果セットが消失します
    arrayJoin(arrayConcat(dice, [])) as second_throw -- 再評価を強制するために意図的に式を変更しています
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```

```response title=Response
┌─最初の投げ─┬─2回目の投げ─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**ARRAY JOIN 構文の使用**

```sql title=Query
-- 以下の`SELECT`クエリにおけるARRAY JOIN構文に注目してください。これにより、より幅広い処理が可能になります。
-- ARRAY JOINを使用すると、同じ要素数を持つ複数の配列を同時に展開できます。

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Tuple の使用**

```sql title=Query
-- Tupleを使用することもできます

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

## arrayLast {#arrayLast}

導入バージョン: v1.1

ラムダ `func(x [, y1, y2, ... yN])` が true を返すソース配列内の最後の要素を返します。該当する要素がない場合は、デフォルト値を返します。

**構文**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) および条件配列 (`y`) の要素を処理するラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。 - `source` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)。 - `[, cond1, ... , condN]` — 任意。ラムダ関数への追加引数として渡される N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

`func` が真となるソース配列の最後の要素を返し、それ以外の場合には `T` のデフォルト値を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**該当なし**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```

## arrayLastIndex {#arrayLastIndex}

導入バージョン: v1.1

`func(x[, y1, y2, ... yN])` が true を返すソース配列内の最後の要素のインデックスを返します。該当する要素がない場合は &#39;0&#39; を返します。

**構文**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) および条件配列 (`y`) の要素に適用されるラムダ関数。 [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。 [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を与える N 個の条件配列。 [`Array(T)`](/sql-reference/data-types/array)

**返り値**

`func` が真となるソース配列の最後の要素のインデックスを返し、それ以外の場合は `0` を返す。 [`UInt32`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**該当なし**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```

## arrayLastOrNull {#arrayLastOrNull}

導入: v1.1

ラムダ式 `func(x [, y1, y2, ... yN])` が true を返す、入力配列内の最後の要素を返します。該当する要素がない場合は `NULL` を返します。

**構文**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x [, y1, ..., yN])` — ソース配列 (`x`) および条件配列 (`y`) の要素に適用されるラムダ関数。[ラムダ関数](/sql-reference/functions/overview#arrow-operator-and-lambda)。 - `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)。 - `[, cond1_arr, ... , condN_arr]` — 任意。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

`λ` が true にならないソース配列要素のうち最後のものを返し、それ以外の場合は `NULL` を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**該当なし**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```

## arrayLevenshteinDistance {#arrayLevenshteinDistance}

導入バージョン: v25.4

2つの配列間の Levenshtein 距離を計算します。

**構文**

```sql
arrayLevenshteinDistance(from, to)
```

**引数**

* `from` — 1番目の配列。[`Array(T)`](/sql-reference/data-types/array)。- `to` — 2番目の配列。[`Array(T)`](/sql-reference/data-types/array)。

**戻り値**

1番目の配列と2番目の配列のレーベンシュタイン距離。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```

## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

導入バージョン: v25.4

2 つの配列に対して、各要素に対するカスタム重みを用いてレーベンシュタイン距離を計算します。
配列とその重みの要素数は一致している必要があります。

**構文**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**引数**

* `from` — 最初の配列。[`Array(T)`](/sql-reference/data-types/array). - `to` — 2 番目の配列。[`Array(T)`](/sql-reference/data-types/array). - `from_weights` — 最初の配列に対する重み。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — 2 番目の配列に対する重み。[`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**戻り値**

各要素に対してカスタム重みを用いた、最初の配列と 2 番目の配列間の Levenshtein 距離。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```

## arrayMap {#arrayMap}

導入バージョン: v1.1

各要素にラムダ関数を適用して、元の配列から生成した配列を返します。

**構文**

```sql
arrayMap(func, arr)
```

**引数**

* `func` — ソース配列 (`x`) と条件配列 (`y`) の要素に対して処理を行うラムダ関数。[`ラムダ関数`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — 処理対象となる N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ラムダ関数の結果から生成された配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**異なる配列の要素からタプルを作成する**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```

## arrayMax {#arrayMax}

導入バージョン: v21.1

入力配列内の最大要素を返します。

ラムダ関数 `func` が指定された場合、ラムダ適用後の結果の最大要素を返します。

**構文**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — オプション。ソース配列 (`x`) および条件配列 (`y`) の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — オプション。ラムダ関数への追加引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列内の最大要素を返します。ラムダ関数が指定されている場合は、その結果の最大要素を返します。

**例**

**基本的な例**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**Lambda 関数での利用方法**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```

## arrayMin {#arrayMin}

導入されたバージョン: v21.1

ソース配列内の最小要素を返します。

ラムダ関数 `func` が指定された場合は、ラムダの評価結果の最小要素を返します。

**構文**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 省略可能。ソース配列 (`x`) と条件配列 (`y`) の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — 省略可能。ラムダ関数に渡される追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列内の最小要素、またはラムダ関数が指定されている場合は、その結果の最小要素を返します。

**例**

**基本的な例**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**Lambda 関数での使用**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```

## arrayNormalizedGini {#arrayNormalizedGini}

導入バージョン: v25.1

正規化されたジニ係数を計算します。

**構文**

```sql
arrayNormalizedGini(predicted, label)
```

**引数**

* `predicted` — 予測値。[`Array(T)`](/sql-reference/data-types/array)
* `label` — 実際の値。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

予測値の Gini 係数、正規化された値の Gini 係数、および正規化 Gini 係数（= 前者2つの Gini 係数の比）を含むタプル [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**例**

**使用例**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```

## arrayPartialReverseSort {#arrayPartialReverseSort}

導入バージョン: v23.2

この関数は `arrayReverseSort` と同じですが、追加の引数 `limit` によって配列の一部のみをソートできます。

:::tip
ソートされた要素だけを保持するには `arrayResize` を使用してください。
:::

**構文**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**引数**

* `f(arr[, arr1, ... ,arrN])` — 配列 `x` の要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — `f` が複数の引数を受け取る場合に指定する、追加の N 個の配列。[`Array(T)`](/sql-reference/data-types/array)
* `limit` — どのインデックスまでソートを行うかを示す上限値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返される値**

元の配列と同じサイズの配列を返します。範囲 `[1..limit]` 内の要素は降順にソートされます。
残りの要素 `(limit..N]` の順序は未定義です。

**例**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```

## arrayPartialShuffle {#arrayPartialShuffle}

導入バージョン: v23.2

元の配列と同じ長さの配列を返します。範囲 `[1..limit]` の要素は、元の配列からランダムに選ばれた部分集合となります。残りの範囲 `(limit..n]` には、範囲 `[1..limit]` に含まれない要素が未定義の順序で格納されます。
`limit` の値は `[1..n]` の範囲でなければなりません。この範囲外の値を指定した場合は、完全な `arrayShuffle` を実行するのと同等の動作になります。

:::note
この関数は定数をマテリアライズしません。

`limit` の値は `[1..N]` の範囲である必要があります。この範囲外の値を指定した場合は、完全な [`arrayShuffle`](#arrayShuffle) を実行するのと同等の動作になります。
:::

**構文**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**引数**

* `arr` — シャッフルする配列。[`Array(T)`](/sql-reference/data-types/array)
* `seed` — 任意。乱数生成に使用するシード。指定しない場合はランダムな値が使用されます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `limit` — 任意。要素の入れ替え回数の上限を `[1..N]` の範囲で指定します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

要素が一部シャッフルされた配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**no&#95;limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no&#95;limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize（マテリアライズ）**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```

## arrayPartialSort {#arrayPartialSort}

導入バージョン: v23.2

この関数は `arraySort` と同じですが、部分的なソートを可能にする追加の引数 `limit` を受け取ります。

:::tip
ソートされた要素のみを保持するには `arrayResize` を使用してください。
:::

**構文**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**引数**

* `f(arr[, arr1, ... ,arrN])` — 配列 `x` の要素に適用するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — `f` が複数の引数を受け取る場合の追加の N 個の配列。[`Array(T)`](/sql-reference/data-types/array)
* `limit` — ソートを行う上限となるインデックス値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

元の配列と同じサイズの配列を返します。範囲 `[1..limit]` 内の要素は昇順にソートされ、残りの要素 `(limit..N]` の順序は未定義です。

**使用例**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```

## arrayPopBack {#arrayPopBack}

導入バージョン: v1.1

配列の末尾の要素を削除します。

**構文**

```sql
arrayPopBack(arr)
```

**引数**

* `arr` — 最後の要素を削除する配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

`arr` と同一だが、`arr` の最後の要素を含まない配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```

## arrayPopFront {#arrayPopFront}

導入バージョン: v1.1

配列の先頭要素を削除します。

**構文**

```sql
arrayPopFront(arr)
```

**引数**

* `arr` — 先頭要素を削除する対象となる配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

`arr` と同一だが、`arr` の先頭要素を含まない配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```

## arrayProduct {#arrayProduct}

導入: v21.1

入力配列の要素の積を返します。

ラムダ関数 `func` が指定されている場合は、そのラムダを適用した結果の要素の積を返します。

**構文**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 省略可能。ソース配列（`x`）および条件配列（`y`）の要素を処理するラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可能。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列の要素の積、またはラムダ関数が指定されている場合はその結果要素の積を返します。[`Float64`](/sql-reference/data-types/float)

**使用例**

**基本的な例**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**Lambda 関数での利用**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```

## arrayPushBack {#arrayPushBack}

導入バージョン: v1.1

配列の末尾に要素を 1 つ追加します。

**構文**

```sql
arrayPushBack(arr, x)
```

**引数**

* `arr` — 値 `x` を末尾に追加する配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` —
* 配列の末尾に追加する単一の値。[`Array(T)`](/sql-reference/data-types/array)。

:::note

* 数値の配列には数値のみ、文字列の配列には文字列のみを追加できます。
* 数値を追加する場合、ClickHouse は配列のデータ型に合わせて `x` の型を自動的に設定します。
* `NULL` を指定できます。この関数は配列に `NULL` 要素を追加し、配列要素の型を `Nullable` に変換します。

ClickHouse におけるデータ型の詳細は、[Data types](/sql-reference/data-types) を参照してください。
:::

**戻り値**

`arr` と同一で、配列の末尾に値 `x` が 1 つ追加された配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```

## arrayPushFront {#arrayPushFront}

導入バージョン: v1.1

配列の先頭に要素を1つ追加します。

**構文**

```sql
arrayPushFront(arr, x)
```

**引数**

* `arr` — 値 `x` を末尾に追加する対象の配列。[`Array(T)`](/sql-reference/data-types/array)。
* `x` — 配列の先頭に追加する単一の値。[`Array(T)`](/sql-reference/data-types/array)。

:::note

* 数値配列には数値のみ、文字列配列には文字列のみ追加できます。
* 数値を追加する場合、ClickHouse は配列のデータ型に合わせて `x` の型を自動的に設定します。
* `NULL` を指定できます。この関数は配列に `NULL` 要素を追加し、配列要素の型を `Nullable` に変換します。

ClickHouse のデータ型の詳細については、[Data types](/sql-reference/data-types) を参照してください。
:::

**戻り値**

`arr` と同一ですが、配列の先頭に値 `x` が 1 つ追加された配列 [`Array(T)`](/sql-reference/data-types/array) を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```

## arrayROCAUC {#arrayROCAUC}

導入バージョン: v20.4

受信者操作特性（ROC）曲線の下の面積を計算します。
ROC 曲線は、すべての閾値において真陽性率 (TPR) を y 軸に、偽陽性率 (FPR) を x 軸にプロットすることで作成されます。
得られる値は 0 から 1 の範囲をとり、値が大きいほどモデルの性能が高いことを示します。

ROC AUC（単に AUC とも呼ばれます）は、機械学習における評価指標の一つです。
詳細は [こちら](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve)、[こちら](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1)、および [こちら](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve) を参照してください。

**構文**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**別名**: `arrayAUC`

**引数**

* `scores` — 予測モデルが出力するスコア。[`Array((U)Int*)`](/sql-reference/data-types/array) または [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — サンプルのラベル。通常、正例サンプルには 1、負例サンプルには 0 を使用します。[`Array((U)Int*)`](/sql-reference/data-types/array) または [`Enum`](/sql-reference/data-types/enum)
* `scale` — 省略可能。正規化された面積を返すかどうかを決定します。false の場合は、代わりに TP（true positives）× FP（false positives）曲線の下の面積を返します。デフォルト値: true。[`Bool`](/sql-reference/data-types/boolean)
* `partial_offsets` —
* 全体の AUC ではなく、ROC 曲線の一部の面積（ROC 空間における縦方向の帯に相当）を計算するための、4 つの非負整数からなる配列。このオプションは、ROC AUC の分散計算に有用です。配列には次の要素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`] を含める必要があります。非負の [整数](../data-types/int-uint.md) の [Array](/sql-reference/data-types/array)。省略可能。
  * `higher_partitions_tp`: より高いスコアのパーティションに含まれる正例ラベルの数。
  * `higher_partitions_fp`: より高いスコアのパーティションに含まれる負例ラベルの数。
  * `total_positives`: データセット全体に含まれる正例サンプルの総数。
  * `total_negatives`: データセット全体に含まれる負例サンプルの総数。

:::note
`arr_partial_offsets` が使用される場合、`arr_scores` と `arr_labels` はデータセット全体の一部のみを含み、スコアのある区間に対応している必要があります。
データセットは連続したパーティションに分割され、それぞれのパーティションはスコアが特定の範囲に入るデータの部分集合を含むようにします。
例:

* あるパーティションには [0, 0.5) の範囲のすべてのスコアを含めることができます。
* 別のパーティションには [0.5, 1.0] の範囲のスコアを含めることができます。
  :::

**戻り値**

受信者動作特性 (ROC) 曲線の下の面積を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```

## arrayRandomSample {#arrayRandomSample}

導入バージョン: v23.10

入力配列からランダムに選んだ `samples` 個の要素からなる部分集合を返します。`samples` が入力配列のサイズを超える場合、サンプル数は配列サイズに制限されます。つまり、すべての配列要素が返されますが、その順序は保証されません。この関数はフラットな配列とネストされた配列の両方を処理できます。

**構文**

```sql
arrayRandomSample(arr, samples)
```

**引数**

* `arr` — 要素をサンプリングするための入力配列または多次元配列。[`Array(T)`](/sql-reference/data-types/array)
* `samples` — ランダムサンプルに含める要素数。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

入力配列からランダムにサンプリングされた要素を含む配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**多次元配列の使用**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```

## arrayReduce {#arrayReduce}

導入バージョン: v1.1

配列要素に集約関数を適用し、その結果を返します。
集約関数の名前は、シングルクォートで囲んだ文字列として渡します（例: `'max'`, `'sum'`）。
パラメトリックな集約関数を使用する場合は、関数名の後ろに括弧でパラメータを指定します（例: `'uniqUpTo(6)'`）。

**構文**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**引数**

* `agg_f` — 定数である必要がある集計関数の名前。[`String`](/sql-reference/data-types/string)
* `arr1 [, arr2, ... , arrN)]` — `agg_f` の引数に対応する N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

集計関数の結果を返します。

**例**

**使用例**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**複数引数を取る集約関数の例**

```sql title=Query
--集約関数が複数の引数を取る場合、この関数は同じサイズの複数の配列に適用する必要があります。

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**パラメトリック集約関数の例**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```

## arrayReduceInRanges {#arrayReduceInRanges}

導入バージョン: v20.4

指定された各範囲の配列要素に集約関数を適用し、その範囲ごとの結果を要素とする配列を返します。
この関数は、`arrayReduce(agg_func, arraySlice(arr1, index, length), ...)` を複数回個別に実行した場合と同じ結果を返します。

**構文**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**引数**

* `agg_f` — 使用する集約関数の名前。[`String`](/sql-reference/data-types/string)
* `ranges` — 集約を行う範囲。`(i, r)` 形式のタプルからなる配列で、`i` は集約を開始するインデックス、`r` は集約を行う範囲を表す。[`Array(T)`](/sql-reference/data-types/array) または [`Tuple(T)`](/sql-reference/data-types/tuple)
* `arr1 [, arr2, ... ,arrN)]` — 集約関数の引数として渡す N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

指定された各範囲に対して集約関数を適用した結果を含む配列を返す。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```

## arrayRemove {#arrayRemove}

導入バージョン: v25.11

配列から、指定した値と等しいすべての要素を削除します。
NULL 同士は等しいものとして扱われます。

**構文**

```sql
arrayRemove(arr, elem)
```

**別名**: `array_remove`

**引数**

* `arr` — Array(T) - `elem` — T

**戻り値**

元の配列 [`Array(T)`](/sql-reference/data-types/array) の部分集合を返します。

**例**

**例 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**例 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```

## arrayResize {#arrayResize}

導入バージョン: v1.1

配列の長さを変更します。

**構文**

```sql
arrayResize(arr, size[, extender])
```

**引数**

* `arr` — サイズ変更する配列。[`Array(T)`](/sql-reference/data-types/array)
* `size` —
  * 配列の新しい長さ。
    `size` が元の配列の長さより小さい場合、配列は末尾から切り詰められます。
    `size` が元の配列の長さより大きい場合、配列は末尾に `extender` の値、または配列要素のデータ型のデフォルト値を追加して拡張されます。
* `extender` — 配列を拡張する際に使用する値。`NULL` を指定できます。

**返される値**

長さが `size` の配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**例 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**例 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```

## arrayReverse {#arrayReverse}

導入: v1.1

指定された配列の要素の順序を反転します。

:::note
関数 `reverse(arr)` も同じ機能を持ちますが、配列だけでなく他のデータ型にも利用できます。
:::

**構文**

```sql
arrayReverse(arr)
```

**引数**

* `arr` — 逆順に並べ替える配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列と同じサイズで、要素を逆順に並べた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```

## arrayReverseFill {#arrayReverseFill}

導入バージョン: v20.1

`arrayReverseFill` 関数は、ソース配列を最後の要素から最初の要素に向かって順に処理し、ソース配列と条件配列の要素を用いて各位置でラムダ式による条件を評価します。位置 i において条件が false と評価された場合、その要素は、配列の現在の状態における位置 i+1 の要素で置き換えられます。最後の要素は、どのような条件であっても常に保持されます。

**構文**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) および条件配列 (`y`) の要素に対して処理を行うラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となるソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ラムダ関数の結果でソース配列の要素を置き換えた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**使用例**

**単一配列の例**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**2つの配列の例**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```

## arrayReverseSort {#arrayReverseSort}

導入バージョン: v1.1

配列の要素を降順にソートします。
関数 `f` が指定された場合、指定された配列は、その要素に関数を適用した結果に従ってソートされ、その後、ソート済み配列が反転されます。
`f` が複数の引数を受け取る場合、`arrayReverseSort` 関数には複数の配列が渡され、`f` の各引数がそれぞれの配列に対応します。

ソート対象の配列に `-Inf`、`NULL`、`NaN`、`Inf` が含まれている場合、次の順序でソートされます。

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort` は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**引数**

* `f(y1[, y2 ... yN])` — 配列 `x` の要素に適用するラムダ関数。
* `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr1, ..., yN` — 任意。`f` が複数の引数を受け取る場合に指定する、追加の N 個の配列。

**返される値**

ラムダ関数が指定されていない場合は、配列 `x` を降順にソートしたものを返します。ラムダ関数が指定されている場合は、そのラムダ関数のロジックに従って配列をソートし、その結果を反転した配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**例 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**例 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```

## arrayReverseSplit {#arrayReverseSplit}

導入バージョン: v20.1

元の配列を複数の配列に分割します。`func(x[, y1, ..., yN])` が 0 以外の値を返したとき、その要素の右側で配列を分割します。最後の要素の後では配列は分割されません。

**構文**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 入力配列 (`x`) および条件配列 (`y`) の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象となる入力配列。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を提供する N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

配列の配列を返します。[`Array(Array(T))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```

## arrayRotateLeft {#arrayRotateLeft}

導入バージョン: v23.8

指定された要素数だけ配列を左方向に回転させます。`n` が負の値の場合は、その絶対値だけ右方向に回転させるものとして解釈されます。

**構文**

```sql
arrayRotateLeft(arr, n)
```

**引数**

* `arr` — 要素を回転させる配列。[`Array(T)`](/sql-reference/data-types/array)。 - `n` — 回転させる要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**戻り値**

指定された要素数だけ左に回転した配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**n が負の値**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

## arrayRotateRight {#arrayRotateRight}

導入バージョン: v23.8

指定された要素数だけ配列を右方向に回転します。`n` が負の値の場合は、その絶対値だけ左方向に回転したものとして扱われます。

**構文**

```sql
arrayRotateRight(arr, n)
```

**引数**

* `arr` — 要素を回転させる対象となる配列。[`Array(T)`](/sql-reference/data-types/array)。 - `n` — 回転させる要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)。

**戻り値**

指定された要素数だけ右に回転した配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**n が負の場合**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

## arrayShiftLeft {#arrayShiftLeft}

導入バージョン: v23.8

配列を、指定した要素数だけ左方向にシフトします。
新しい要素には、指定された引数、または配列要素型のデフォルト値が設定されます。
要素数が負の値の場合は、配列は右方向にシフトされます。

**構文**

```sql
arrayShiftLeft(arr, n[, default])
```

**引数**

* `arr` — 要素をシフトする対象の配列。[`Array(T)`](/sql-reference/data-types/array)

- `n` — シフトする要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `default` — 省略可能。新しい要素に使用するデフォルト値。

**戻り値**

指定された要素数だけ左方向にシフトされた配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**n が負の値の場合**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**デフォルト値を使用する**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```

## arrayShiftRight {#arrayShiftRight}

導入バージョン: v23.8

配列を、指定した要素数だけ右にシフトします。
新しい要素は、指定した引数または配列要素型のデフォルト値で埋められます。
要素数が負の値の場合、配列は左にシフトされます。

**構文**

```sql
arrayShiftRight(arr, n[, default])
```

**引数**

* `arr` — 要素をシフトする配列。[`Array(T)`](/sql-reference/data-types/array)
* `n` — シフトする要素数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `default` — 任意。新しく追加される要素のデフォルト値。

**戻り値**

指定した要素数だけ右にシフトされた配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**n の負の値**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**デフォルト値を使用する**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```

## arrayShingles {#arrayShingles}

導入バージョン: v24.1

入力配列から、指定された長さの連続した部分配列（文字列に対する n-gram に相当）である shingle の配列を生成します。

**構文**

```sql
arrayShingles(arr, l)
```

**引数**

* `arr` — シングル (shingle) 配列を生成する対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `l` — 各シングルの長さ。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返り値**

生成されたシングル (shingle) の配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```

## arrayShuffle {#arrayShuffle}

導入バージョン: v23.2

元の配列と同じサイズで、要素をシャッフルした順序で含む配列を返します。
要素は、その要素のあらゆる順列が等しい確率で現れるように並べ替えられます。

:::note
この関数は定数をマテリアライズしません。
:::

**構文**

```sql
arrayShuffle(arr [, seed])
```

**引数**

* `arr` — シャッフルする配列。[`Array(T)`](/sql-reference/data-types/array)
* `seed (optional)` — 省略可。乱数生成に使用するシード値。指定しない場合はランダムなシード値が使用されます。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

要素がシャッフルされた配列 [`Array(T)`](/sql-reference/data-types/array)

**例**

**シードなしの例（結果は非決定的）**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**シード未指定時の例（安定した結果）**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```

## arraySimilarity {#arraySimilarity}

導入バージョン: v25.4

重み付きレーベンシュタイン距離に基づいて、2つの配列の類似度を `0` から `1` の範囲で計算します。

**構文**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**引数**

* `from` — 1 つ目の配列 [`Array(T)`](/sql-reference/data-types/array)
* `to` — 2 つ目の配列 [`Array(T)`](/sql-reference/data-types/array)
* `from_weights` — 1 つ目の配列に対する重み [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — 2 つ目の配列に対する重み [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**戻り値**

加重レーベンシュタイン距離に基づいて、2 つの配列間の類似度（`0` から `1` の範囲）を返します。[`Float64`](/sql-reference/data-types/float)

**例**

**使用例**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```

## arraySlice {#arraySlice}

導入バージョン: v1.1

`NULL` 要素を含む配列のスライスを返します。

**構文**

```sql
arraySlice(arr, offset [, length])
```

**引数**

* `arr` — スライス対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `offset` — 配列の端からのオフセット。正の値は左側からのオフセット、負の値は右側からのオフセットを表します。配列要素の番号付けは `1` から始まります。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 取得するスライスの長さ。負の値を指定した場合、関数は `[offset, array_length - length]` の範囲のスライス（末尾側を `length` 分だけ除いたスライス）を返します。値を省略した場合、関数は `[offset, 配列の終端]` のスライスを返します。[`(U)Int*`](/sql-reference/data-types/int-uint)

**返り値**

指定された `offset` から `length` 要素分の配列スライスを返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```

## arraySort {#arraySort}

導入バージョン: v1.1

指定された配列の要素を昇順でソートします。
ラムダ関数 `f` が指定されている場合、ソート順は配列の各要素にラムダを適用した結果によって決定されます。
ラムダが複数の引数を受け取る場合、`arraySort` 関数には複数の配列が渡され、`f` の各引数はそれぞれの配列に対応します。

ソート対象の配列に `-Inf`、`NULL`、`NaN`、`Inf` が含まれる場合、それらは次の順序でソートされます:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort` は[高階関数](/sql-reference/functions/overview#higher-order-functions)です。

**構文**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**引数**

* `f(y1[, y2 ... yN])` — 配列 `x` の要素に適用するラムダ関数。 - `arr` — ソート対象の配列。[`Array(T)`](/sql-reference/data-types/array) - `arr1, ..., yN` — 省略可能。`f` が複数の引数を受け取る場合に指定する、追加の N 個の配列。

**返り値**

ラムダ関数が指定されていない場合は、配列 `arr` を昇順にソートして返します。指定されている場合は、そのラムダ関数のロジックに従ってソートされた配列を返します。[`Array(T)`](/sql-reference/data-types/array)。

**例**

**例 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**例 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**例 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```

## arraySplit {#arraySplit}

導入バージョン: v20.1

入力配列を複数の配列に分割します。`func(x [, y1, ..., yN])` がゼロ以外を返した場合、その要素の左側で配列が分割されます。最初の要素の前では配列は分割されません。

**構文**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — ソース配列 (`x`) および条件配列 (`y`) の要素を処理するラムダ関数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)。- `source_arr` — 分割対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)。- `[, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)。

**返される値**

配列の配列を返します。[`Array(Array(T))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```

## arraySum {#arraySum}

導入バージョン: v21.1

入力配列内の要素の合計を返します。

ラムダ関数 `func` が指定された場合は、そのラムダを各要素に適用した結果の合計を返します。

**構文**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**引数**

* `func(x[, y1, ..., yN])` — 省略可。ソース配列 (`x`) および条件配列 (`y`) の要素に適用されるラムダ関数。[`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 処理対象のソース配列。[`Array(T)`](/sql-reference/data-types/array)
* `, cond1_arr, ... , condN_arr]` — 省略可。ラムダ関数に追加の引数を渡すための N 個の条件配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

ソース配列内の要素の合計、またはラムダ関数が指定されている場合は、その結果要素の合計値を返します。

**使用例**

**基本的な例**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**Lambda 関数での使用方法**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```

## arraySymmetricDifference {#arraySymmetricDifference}

導入バージョン: v25.4

複数の配列を受け取り、すべての入力配列に共通して存在しない要素からなる配列を返します。結果には一意な値のみが含まれます。

:::note
*2つを超える集合*の対称差は、入力集合のうち奇数個の集合に含まれるすべての入力要素の集合として[数学的に定義されています](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)。
これに対して、関数 `arraySymmetricDifference` は、すべての入力集合に含まれない入力要素の集合のみを返します。
:::

**構文**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**引数**

* `arrN` — 新しい配列を作成するための N 個の配列。[`Array(T)`](/sql-reference/data-types/array)。

**返される値**

すべての元の配列に共通して存在しない要素のみから成る、重複のない配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```

## arrayUnion {#arrayUnion}

導入バージョン: v24.10

複数の配列を受け取り、入力配列のいずれかに存在するすべての要素を含む配列を返します。結果には一意の値のみが含まれます。

**構文**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**引数**

* `arrN` — 新しい配列を作成するための N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列群に含まれる要素のうち重複を取り除いた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```

## arrayUniq {#arrayUniq}

導入バージョン: v1.1

引数が 1 つだけ渡された場合、配列内の異なる要素の個数を数えます。
複数の引数が渡された場合、複数の配列において同じ位置にある要素からなる **タプル** を構成し、そのタプルのうち異なるものの個数を数えます。

たとえば `SELECT arrayUniq([1,2], [3,4], [5,6])` は次のタプルを生成します。

* 位置 1: (1,3,5)
* 位置 2: (2,4,6)

その後、一意なタプルの個数を数えます。この場合は `2` になります。

渡されるすべての配列は同じ長さである必要があります。

:::tip
配列内の一意な要素のリストを取得したい場合は、`arrayReduce('groupUniqArray', arr)` を使用できます。
:::

**構文**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**引数**

* `arr1` — 一意な要素の数をカウントする対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `[, arr2, ..., arrN]` — 省略可。複数の配列において同じ位置にある要素から成る一意なタプルの数をカウントするために使用される追加の配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

単一引数の場合は、一意な要素の数を返します。複数引数の場合は、
配列間で同じ位置にある要素から構成される一意なタプルの数を返します。
[`UInt32`](/sql-reference/data-types/int-uint)

**例**

**単一引数**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**複数の引数**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```

## arrayWithConstant {#arrayWithConstant}

導入バージョン: v20.1

長さ `length` の配列を作成し、そのすべての要素を定数 `x` で埋めます。

**構文**

```sql
arrayWithConstant(N, x)
```

**引数**

* `length` — 配列内の要素数。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `x` — 配列内の `N` 個の要素の値。任意の型の値を取ることができます。

**戻り値**

値が `x` の `N` 個の要素を持つ Array を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```

## arrayZip {#arrayZip}

導入バージョン: v20.1

複数の配列を1つの配列に結合します。結果の配列には、引数で指定された順序で、元の配列の対応する要素がタプルにまとめられて含まれます。

**構文**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**引数**

* `arr1, arr2, ... , arrN` — 結合して 1 つの配列にする N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

元の配列の要素をタプルごとにまとめた配列を返します。タプル内のデータ型は入力配列の型と同一であり、配列が渡された順序と同じ順序になります。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```

## arrayZipUnaligned {#arrayZipUnaligned}

導入バージョン: v20.1

複数の配列を 1 つの配列に結合し、長さが揃っていない配列（長さの異なる配列）も扱います。結果の配列には、引数で指定した順序に従い、元の各配列の対応する要素をまとめたタプルが含まれます。

**構文**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**引数**

* `arr1, arr2, ..., arrN` — 1 つの配列に結合する N 個の配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

ソース配列の要素をタプルごとにまとめた配列を返します。タプル内のデータ型は入力配列の型と同一であり、配列が渡された順序どおりに並びます。[`Array(T)`](/sql-reference/data-types/array) または [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**例**

**使用例**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```

## countEqual {#countEqual}

導入: v1.1

配列内で `x` に等しい要素の個数を返します。`arrayCount(elem -> elem = x, arr)` と同等です。

`NULL` 要素は個別の値として扱われます。

**構文**

```sql
countEqual(arr, x)
```

**引数**

* `arr` — 検索対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` — 配列内でカウントする値。任意の型。

**戻り値**

`x` と等しい配列要素の数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```

## empty {#empty}

導入バージョン: v1.1

入力配列が空かどうかを確認します。

配列に要素が 1 つも含まれていない場合、その配列は空とみなされます。

:::note
[`optimize_functions_to_subcolumns` 設定](/operations/settings/settings#optimize_functions_to_subcolumns)を有効にすることで最適化できます。`optimize_functions_to_subcolumns = 1` の場合、この関数は配列列全体を読み取って処理する代わりに、[size0](/sql-reference/data-types/array#array-size) サブカラムのみを読み取ります。クエリ `SELECT empty(arr) FROM TABLE;` は `SELECT arr.size0 = 0 FROM TABLE;` に変換されます。
:::

この関数は String 型や UUID 型にも使用できます。

**構文**

```sql
empty(arr)
```

**引数**

* `arr` — 入力配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

空配列の場合は `1`、空でない配列の場合は `0` を返します。戻り値の型は [`UInt8`](/sql-reference/data-types/int-uint) です。

**例**

**使用例**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```

## emptyArrayDate {#emptyArrayDate}

導入バージョン: v1.1

空の Date 型配列を返します。

**構文**

```sql
emptyArrayDate()
```

**引数**

* なし。

**戻り値**

空の Date 型配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```

## emptyArrayDateTime {#emptyArrayDateTime}

導入されたバージョン: v1.1

空の DateTime 配列を返します。

**構文**

```sql
emptyArrayDateTime()
```

**引数**

* なし

**戻り値**

空の DateTime 型の配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```

## emptyArrayFloat32 {#emptyArrayFloat32}

導入バージョン: v1.1

空の Float32 配列を返します。

**構文**

```sql
emptyArrayFloat32()
```

**引数**

* なし。

**戻り値**

空の Float32 配列。 [`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```

## emptyArrayFloat64 {#emptyArrayFloat64}

導入バージョン: v1.1

空の Float64 型配列を返します

**構文**

```sql
emptyArrayFloat64()
```

**引数**

* なし

**戻り値**

空の Float64 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```

## emptyArrayInt16 {#emptyArrayInt16}

導入バージョン: v1.1

空の Int16 配列を返します

**構文**

```sql
emptyArrayInt16()
```

**引数**

* なし。

**戻り値**

空の Int16 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```

## emptyArrayInt32 {#emptyArrayInt32}

導入: v1.1

空の Int32 配列を返します。

**構文**

```sql
emptyArrayInt32()
```

**引数**

* なし。

**戻り値**

空の Int32 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```

## emptyArrayInt64 {#emptyArrayInt64}

導入バージョン: v1.1

空の Int64 配列を返します

**構文**

```sql
emptyArrayInt64()
```

**引数**

* なし。

**戻り値**

空の Int64 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```

## emptyArrayInt8 {#emptyArrayInt8}

導入バージョン: v1.1

空の Int8 型の配列を返します。

**構文**

```sql
emptyArrayInt8()
```

**引数**

* なし。

**戻り値**

空の Int8 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```

## emptyArrayString {#emptyArrayString}

導入バージョン: v1.1

空の String 型配列を返します。

**構文**

```sql
emptyArrayString()
```

**引数**

* なし。

**戻り値**

空の String 型配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```

## emptyArrayToSingle {#emptyArrayToSingle}

導入されたバージョン: v1.1

空の配列を受け取り、デフォルト値と同じ値を持つ 1 要素の配列を返します。

**構文**

```sql
emptyArrayToSingle(arr)
```

**引数**

* `arr` — 空の配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

配列要素型 `T` のデフォルト値 1 つを含む配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**基本例**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```

## emptyArrayUInt16 {#emptyArrayUInt16}

導入: v1.1

空の UInt16 配列を返します。

**構文**

```sql
emptyArrayUInt16()
```

**引数**

* なし。

**戻り値**

空の UInt16 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```

## emptyArrayUInt32 {#emptyArrayUInt32}

導入バージョン: v1.1

空の UInt32 型の配列を返します。

**構文**

```sql
emptyArrayUInt32()
```

**引数**

* なし。

**戻り値**

空の UInt32 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```

## emptyArrayUInt64 {#emptyArrayUInt64}

導入バージョン: v1.1

空の UInt64 型の配列を返します。

**構文**

```sql
emptyArrayUInt64()
```

**引数**

* なし。

**返り値**

空の UInt64 配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```

## emptyArrayUInt8 {#emptyArrayUInt8}

導入バージョン: v1.1

空の UInt8 配列を返します。

**構文**

```sql
emptyArrayUInt8()
```

**引数**

* なし。

**戻り値**

空のUInt8配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```

## has {#has}

導入バージョン: v1.1

指定した要素が配列に含まれているかどうかを返します。

**構文**

```sql
has(arr, x)
```

**引数**

* `arr` — 元の配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` — 配列内で検索する値。

**戻り値**

配列が指定した要素を含む場合は `1` を、含まない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用例**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**見つかりませんでした**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```

## hasAll {#hasAll}

導入バージョン: v1.1

ある配列が別の配列の部分集合であるかどうかを確認します。

* 空の配列は任意の配列の部分集合です。
* `Null` は値として処理されます。
* どちらの配列においても、値の順序は問題になりません。

**構文**

```sql
hasAll(set, subset)
```

**引数**

* `set` — 要素の集合を持つ任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)
* `subset` — `set` と共通のスーパータイプを持ち、`set` の部分集合かどうかをテストする対象の要素を含む任意の型の配列。[`Array(T)`](/sql-reference/data-types/array)

**返り値**

* `set` に `subset` のすべての要素が含まれている場合は `1`。
* それ以外の場合は `0`。

`set` と `subset` の要素が共通のスーパータイプを持たない場合は、`NO_COMMON_TYPE` 例外をスローします。

**使用例**

**空配列**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**NULL 値を含む配列**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**異なる型の値を含む配列**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**文字列値を含む配列**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**共通の型を持たない配列**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
NO_COMMON_TYPE例外を発生させます
```

**配列の配列**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```

## hasAny {#hasAny}

導入バージョン: v1.1

2 つの配列に、少なくとも 1 つ共通する要素（交差）があるかどうかを判定します。

* `Null` は値として扱われます。
* 両方の配列内の値の順序は関係ありません。

**構文**

```sql
hasAny(arr_x, arr_y)
```

**引数**

* `arr_x` — 任意の型の要素を含む配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — 配列 `arr_x` と共通のスーパータイプを持つ任意の型の要素からなる配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

* `arr_x` と `arr_y` に少なくとも 1 つ同じ要素がある場合は `1`。
* それ以外の場合は `0`。

2 つの配列の要素のいずれかが共通のスーパータイプを持たない場合、`NO_COMMON_TYPE` 例外を送出します。

**例**

**一方の配列が空の場合**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**NULL 値を含む配列**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**異なる型の値を含む配列**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**共通の型を持たない配列**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
`NO_COMMON_TYPE` 例外を発生させます
```

**配列の配列**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```

## hasSubstr {#hasSubstr}

導入バージョン: v20.6

array2 のすべての要素が、同一の順序で array1 内に出現するかどうかを判定します。
したがって、この関数は array1 = prefix + array2 + suffix の場合に限り `1` を返します。

言い換えると、この関数は `hasAll` 関数と同様に、array2 のすべての要素が array1 に含まれているかどうかを確認します。
さらに、それらの要素が array1 と array2 の両方で同じ順序で現れることも確認します。

* array2 が空の場合、関数は `1` を返します。
* `Null` は値として扱われます。つまり、`hasSubstr([1, 2, NULL, 3, 4], [2,3])` は `0` を返します。一方、`hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` は `1` を返します。
* 両方の配列における要素の順序は重要です。

2 つの配列のいずれかの要素が共通のスーパータイプを持たない場合、`NO_COMMON_TYPE` 例外をスローします。

**構文**

```sql
hasSubstr(arr1, arr2)
```

**引数**

* `arr1` — 任意の型の要素からなる配列。[`Array(T)`](/sql-reference/data-types/array)
* `arr2` — 任意の型の要素からなる配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列 `arr1` が配列 `arr2` を含む場合は `1` を返します。そうでない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**両方の配列が空の場合**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**NULL 値を含む配列**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**異なる型の値を含む配列**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**文字列を含む配列**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**有効な順序付けのある配列**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**不正な順序の配列**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**配列の配列**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**共通の型を持たない配列**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
`NO_COMMON_TYPE` 例外を発生させます
```

## indexOf {#indexOf}

導入バージョン: v1.1

配列内に値 &#39;x&#39; を持つ要素が存在する場合、その最初の要素のインデックス（1 から始まる）を返します。
配列に検索対象の値が含まれていない場合、関数は `0` を返します。

`NULL` に設定された要素は通常の値として扱われます。

**構文**

```sql
indexOf(arr, x)
```

**引数**

* `arr` — `x` を検索する対象の配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` — `arr` 内で最初に一致し、そのインデックスを返す要素の値。[`UInt64`](/sql-reference/data-types/int-uint)

**返り値**

`arr` 内に `x` が存在する場合、最初の `x` のインデックス（1 始まり）を返します。存在しない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な例**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**NULL 値を含む配列**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```

## indexOfAssumeSorted {#indexOfAssumeSorted}

導入バージョン: v24.12

配列内に値 &#39;x&#39; がある場合、最初に現れる要素のインデックス（`1` から開始）を返します。
配列に検索対象の値が含まれていない場合、関数は `0` を返します。

:::note
`indexOf` 関数とは異なり、この関数は配列が昇順にソートされていることを前提とします。
配列がソートされていない場合、結果は未定義です。
:::

**構文**

```sql
indexOfAssumeSorted(arr, x)
```

**引数**

* `arr` — 検索対象となるソート済み配列。[`Array(T)`](/sql-reference/data-types/array)
* `x` — ソート済み `arr` 内で、インデックスを取得する対象となる最初に一致する要素の値。[`UInt64`](/sql-reference/data-types/int-uint)

**返り値**

`x` が存在する場合は、`arr` 内で最初に現れる `x` のインデックス（1 から始まる番号）を返します。存在しない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な例**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```

## length {#length}

導入バージョン: v1.1

文字列または配列の長さを計算します。

* String または FixedString 引数の場合: 文字列内のバイト数を計算します。
* Array 引数の場合: 配列内の要素数を計算します。
* FixedString 引数に適用された場合、この関数は定数式になります。

文字列のバイト数は、Unicode の「コードポイント」の数とも、
Unicode の「書記素クラスター」（一般的に「文字」と呼ぶもの）の数とも、
見た目上の文字列幅とも一致しないことに注意してください。

文字列に ASCII の NULL バイトを含めても問題はなく、それらも長さとしてカウントされます。

**構文**

```sql
length(x)
```

**エイリアス**: `OCTET_LENGTH`

**引数**

* `x` — バイト数（String/FixedString の場合）または要素数（Array の場合）を計算する対象の値。[`String`](/sql-reference/data-types/string)、[`FixedString`](/sql-reference/data-types/fixedstring)、または [`Array(T)`](/sql-reference/data-types/array)

**戻り値**

String/FixedString `x` のバイト数、または配列 `x` の要素数を返します。型は [`UInt64`](/sql-reference/data-types/int-uint) です。

**例**

**String の例**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**配列の例**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**constexpr の例**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**Unicodeの例**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ascii&#95;vs&#95;utf8 の例**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```

## notEmpty {#notEmpty}

導入バージョン: v1.1

入力配列が空でないかどうかをチェックします。

少なくとも 1 つの要素を含む配列は、空でないと見なされます。

:::note
[`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns) 設定を有効にすることで最適化できます。`optimize_functions_to_subcolumns = 1` の場合、この関数は配列列全体を読み取って処理する代わりに、[size0](/sql-reference/data-types/array#array-size) サブカラムのみを読み取ります。クエリ `SELECT notEmpty(arr) FROM table` は `SELECT arr.size0 != 0 FROM TABLE` に変換されます。
:::

この関数は String 型や UUID 型に対しても動作します。

**構文**

```sql
notEmpty(arr)
```

**引数**

* `arr` — 入力配列。[`Array(T)`](/sql-reference/data-types/array)

**戻り値**

配列が空でない場合は `1`、空の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```

## range {#range}

導入バージョン: v1.1

`start` から `end - 1` までを `step` ごとに並べた数値の配列を返します。

サポートされている型は次のとおりです:

* `UInt8/16/32/64`

* `Int8/16/32/64`

* すべての引数 `start`、`end`、`step` は上記のいずれかのサポート対象の型でなければなりません。返される配列の要素の型は、引数の上位型になります。

* 関数が返す配列の要素数の合計が、設定 [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block) で指定された要素数を超える場合は、例外がスローされます。

* いずれかの引数が Nullable(nothing) 型の場合は `NULL` を返します。いずれかの引数が `NULL` 値（Nullable(T) 型）を持つ場合は、例外がスローされます。

**構文**

```sql
range([start, ] end [, step])
```

**引数**

* `start` — 省略可能。配列の先頭要素。`step` を使用する場合は必須。デフォルト値: `0`。 - `end` — 必須。配列に含める値の上限となる数値（この値の直前までが配列に含まれる）。 - `step` — 省略可能。配列内の各要素間の増分値を指定する。デフォルト値: `1`。

**戻り値**

`start` から `end - 1` までを `step` 刻みで並べた数値の配列。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```

## replicate {#replicate}

導入バージョン: v1.1

単一の値からなる配列を作成します。

**構文**

```sql
replicate(x, arr)
```

**引数**

* `x` — 結果配列を埋める値。[`Any`](/sql-reference/data-types)
* `arr` — 配列。[`Array(T)`](/sql-reference/data-types/array)

**返される値**

`arr` と同じ長さで、値 `x` が詰められた配列を返します。[`Array(T)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```

## reverse {#reverse}

導入バージョン: v1.1

入力配列の要素、または入力文字列の文字の順序を反転します。

**構文**

```sql
reverse(arr | str)
```

**引数**

* `arr | str` — 元の配列または文字列。[`Array(T)`](/sql-reference/data-types/array) または [`String`](/sql-reference/data-types/string)

**戻り値**

要素または文字の順序を逆にした配列または文字列を返します。

**例**

**配列を逆順にする**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**文字列の反転**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

{/*AUTOGENERATED_END*/ }

## 距離関数 {#distance-functions}

サポートされているすべての関数は、[距離関数のドキュメント](../../sql-reference/functions/distance-functions.md)で説明されています。

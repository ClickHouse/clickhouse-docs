---
description: 'エンコード関数に関するドキュメント'
sidebar_label: 'エンコード'
slug: /sql-reference/functions/encoding-functions
title: 'エンコード関数'
keywords: ['encoding', 'regular functions', 'encode', 'decode']
doc_type: 'reference'
---



# エンコーディング関数

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## bech32Decode {#bech32Decode}

導入バージョン: v25.6

bech32またはbech32mアルゴリズムによって生成されたBech32アドレス文字列をデコードします。

:::note
エンコード関数とは異なり、`Bech32Decode`はパディングされたFixedStringを自動的に処理します。
:::

**構文**

```sql
bech32Decode(address)
```

**引数**

- `address` — デコードするBech32文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

文字列のエンコードに使用された`(hrp, data)`で構成されるタプルを返します。データはバイナリ形式です。[`Tuple(String, String)`](/sql-reference/data-types/tuple)

**例**

**アドレスのデコード**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z') AS tup)
```

```response title=Response
bc   751E76E8199196D454941C45D1B3A323F1433BD6
```

**テストネットアドレス**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('tb1w508d6qejxtdg4y5r3zarvary0c5xw7kzp034v') AS tup)
```

```response title=Response
tb   751E76E8199196D454941C45D1B3A323F1433BD6
```


## bech32Encode {#bech32Encode}

導入バージョン: v25.6

[Bech32またはBech32m](https://en.bitcoin.it/wiki/Bech32)アルゴリズムを使用して、人間が読める部分(HRP)とともにバイナリデータ文字列をエンコードします。

:::note
[`FixedString`](../data-types/fixedstring.md)データ型を使用する場合、値が行を完全に埋めない場合はヌル文字でパディングされます。
`bech32Encode`関数はhrp引数に対してこれを自動的に処理しますが、data引数の値はパディングされていてはなりません。
このため、すべての値が同じ長さであることが確実であり、`FixedString`カラムもその長さに設定されていることを保証できる場合を除き、データ値に[`FixedString`](../data-types/fixedstring.md)データ型を使用することは推奨されません。
:::

**構文**

```sql
bech32Encode(hrp, data[, witver])
```

**引数**

- `hrp` — コードの「人間が読める部分」を指定する`1 - 83`文字の小文字文字列。通常は'bc'または'tb'。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `data` — エンコードするバイナリデータの文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `witver` — オプション。witnessバージョン(デフォルト = 1)。実行するアルゴリズムのバージョンを指定する`UInt*`。Bech32の場合は`0`、Bech32mの場合は`1`以上。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

人間が読める部分、常に'1'である区切り文字、およびデータ部分で構成されるBech32アドレス文字列を返します。文字列の長さは90文字を超えることはありません。アルゴリズムが入力から有効なアドレスを生成できない場合、空の文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**デフォルトのBech32m**

```sql title=Query
-- witnessバージョンが指定されていない場合、デフォルトは1で、更新されたBech32mアルゴリズムが使用されます。
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'))
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7k8zcwmq
```

**Bech32アルゴリズム**

```sql title=Query
-- witnessバージョン0を指定すると、異なるアドレス文字列が生成されます。
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 0)
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z
```

**カスタムHRP**

```sql title=Query
-- SegWitアドレス形式では'bc'(メインネット)と'tb'(テストネット)のみが許可されたhrp値ですが、
-- Bech32では上記の要件を満たす任意のhrpを使用できます。
SELECT bech32Encode('abcdefg', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 10)
```

```response title=Response
abcdefg1w508d6qejxtdg4y5r3zarvary0c5xw7k9rp8r4
```


## bin {#bin}

導入バージョン: v21.8

引数のバイナリ表現を含む文字列を返します。型ごとに以下のロジックに従います:

| 型                         | 説明                                                                                                                                                                                                                                                            |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `(U)Int*`                  | 最上位ビットから最下位ビットへバイナリ桁を出力します(ビッグエンディアンまたは「人間が読める」順序)。最上位の非ゼロバイトから開始します(先頭のゼロバイトは省略されます)が、先頭の桁がゼロの場合は常に各バイトの8桁を出力します。 |
| `Date` および `DateTime`      | 対応する整数としてフォーマットされます(Dateの場合はエポックからの日数、DateTimeの場合はunixタイムスタンプの値)。                                                                                                                                            |
| `String` および `FixedString` | すべてのバイトは単純に8つのバイナリ数としてエンコードされます。ゼロバイトは省略されません。                                                                                                                                                                      |
| `Float*` および `Decimal`     | メモリ内の表現としてエンコードされます。リトルエンディアンアーキテクチャをサポートしているため、リトルエンディアンでエンコードされます。先頭/末尾のゼロバイトは省略されません。                                                                                                   |
| `UUID`                     | ビッグエンディアン順序の文字列としてエンコードされます。                                                                                                                                                                                                                                    |

**構文**

```sql
bin(arg)
```

**引数**

- `arg` — バイナリに変換する値。[`String`](/sql-reference/data-types/string)、[`FixedString`](/sql-reference/data-types/fixedstring)、[`(U)Int*`](/sql-reference/data-types/int-uint)、[`Float*`](/sql-reference/data-types/float)、[`Decimal`](/sql-reference/data-types/decimal)、[`Date`](/sql-reference/data-types/date)、または[`DateTime`](/sql-reference/data-types/datetime)

**戻り値**

引数のバイナリ表現を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**単純な整数**

```sql title=クエリ
SELECT bin(14)
```

```response title=レスポンス
┌─bin(14)──┐
│ 00001110 │
└──────────┘
```

**Float32数値**

```sql title=クエリ
SELECT bin(toFloat32(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=レスポンス
┌─bin_presentation─────────────────┐
│ 00000000000000000111000001000001 │
│ 00000000000000001000000001000001 │
└──────────────────────────────────┘
```

**Float64数値**

```sql title=クエリ
SELECT bin(toFloat64(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=レスポンス
┌─bin_presentation─────────────────────────────────────────────────┐
│ 0000000000000000000000000000000000000000000000000010111001000000 │
│ 0000000000000000000000000000000000000000000000000011000001000000 │
└──────────────────────────────────────────────────────────────────┘
```

**UUID変換**

```sql title=クエリ
SELECT bin(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')) AS bin_uuid
```

```response title=レスポンス
┌─bin_uuid─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ 01100001111100001100010000000100010111001011001100010001111001111001000001111011101001100000000001101010110100111101101110100000 │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```


## bitPositionsToArray {#bitPositionsToArray}

導入バージョン: v21.7

この関数は、符号なし整数の2進数表現において1となっているビットの位置を昇順で返します。
符号付き整数が入力された場合は、まず符号なし整数にキャストされます。

**構文**

```sql
bitPositionsToArray(arg)
```

**引数**

- `arg` — 整数値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

入力値の2進数表現において1となっているビットの位置を昇順に並べた配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**単一ビットが設定されている場合**

```sql title=Query
SELECT bitPositionsToArray(toInt8(1)) AS bit_positions
```

```response title=Response
┌─bit_positions─┐
│ [0]           │
└───────────────┘
```

**すべてのビットが設定されている場合**

```sql title=Query
SELECT bitPositionsToArray(toInt8(-1)) AS bit_positions
```

```response title=Response
┌─bit_positions─────────────┐
│ [0, 1, 2, 3, 4, 5, 6, 7]  │
└───────────────────────────┘
```


## bitmaskToArray {#bitmaskToArray}

導入バージョン: v1.1

この関数は整数を2の累乗の和に分解します。
2の累乗は昇順でソートされた配列として返されます。

**構文**

```sql
bitmaskToArray(num)
```

**引数**

- `num` — 整数値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

入力された数値の和となる2の累乗を昇順でソートした配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**基本的な例**

```sql title=クエリ
SELECT bitmaskToArray(50) AS powers_of_two
```

```response title=結果
┌─powers_of_two───┐
│ [2, 16, 32]     │
└─────────────────┘
```

**単一の2の累乗**

```sql title=クエリ
SELECT bitmaskToArray(8) AS powers_of_two
```

```response title=結果
┌─powers_of_two─┐
│ [8]           │
└───────────────┘
```


## bitmaskToList {#bitmaskToList}

導入バージョン: v1.1

bitmaskToArrayと同様ですが、2の累乗をカンマ区切りの文字列として返します。

**構文**

```sql
bitmaskToList(num)
```

**引数**

- `num` — 整数値。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

2の累乗をカンマ区切りで含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な例**

```sql title=クエリ
SELECT bitmaskToList(50) AS powers_list
```

```response title=レスポンス
┌─powers_list───┐
│ 2, 16, 32     │
└───────────────┘
```


## char {#char}

導入バージョン: v20.1

渡された引数の数と等しい長さの文字列を返します。各バイトは対応する引数の値を持ちます。数値型の複数の引数を受け付けます。

引数の値が`UInt8`データ型の範囲外の場合、丸めやオーバーフローが発生する可能性を伴って`UInt8`に変換されます。

**構文**

```sql
char(num1[, num2[, ...]])
```

**引数**

- `num1[, num2[, num3 ...]]` — 整数として解釈される数値引数。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)または[`Float*`](/sql-reference/data-types/float)

**戻り値**

指定されたバイトの文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な例**

```sql title=Query
SELECT char(104.1, 101, 108.9, 108.9, 111) AS hello;
```

```response title=Response
┌─hello─┐
│ hello │
└───────┘
```

**任意のエンコーディングの構築**

```sql title=Query
-- 対応するバイトを渡すことで、任意のエンコーディングの文字列を構築できます。
-- 例: UTF8
SELECT char(0xD0, 0xBF, 0xD1, 0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1, 0x82) AS hello;
```

```response title=Response
┌─hello──┐
│ привет │
└────────┘
```


## hex {#hex}

導入バージョン: v1.1

引数の16進数表現を含む文字列を返します。型ごとに以下のロジックに従います:

| 型                         | 説明                                                                                                                                                                                                                                                                            |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `(U)Int*`                  | 最上位ビットから最下位ビットへ16進数の桁(「ニブル」)を出力します(ビッグエンディアンまたは「人間が読みやすい」順序)。最上位の非ゼロバイトから開始します(先頭のゼロバイトは省略されます)が、先頭の桁がゼロであっても各バイトの両方の桁を常に出力します。 |
| `Date` および `DateTime`      | 対応する整数としてフォーマットされます(Dateの場合はエポックからの日数、DateTimeの場合はUnixタイムスタンプの値)。                                                                                                                                                            |
| `String` および `FixedString` | すべてのバイトは単純に2つの16進数としてエンコードされます。ゼロバイトは省略されません。                                                                                                                                                                                                   |
| `Float*` および `Decimal`     | メモリ内の表現としてエンコードされます。ClickHouseは内部的に常にリトルエンディアンとして値を表現するため、そのようにエンコードされます。先頭/末尾のゼロバイトは省略されません。                                                                                       |
| `UUID`                     | ビッグエンディアン順序の文字列としてエンコードされます。                                                                                                                                                                                                                                                    |

この関数は大文字の`A-F`を使用し、プレフィックス(`0x`など)やサフィックス(`h`など)は使用しません。

**構文**

```sql
hex(arg)
```

**引数**

- `arg` — 16進数に変換する値。[`String`](/sql-reference/data-types/string)、[`(U)Int*`](/sql-reference/data-types/int-uint)、[`Float*`](/sql-reference/data-types/float)、[`Decimal`](/sql-reference/data-types/decimal)、[`Date`](/sql-reference/data-types/date)、または[`DateTime`](/sql-reference/data-types/datetime)

**戻り値**

引数の16進数表現を含む文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**単純な整数**

```sql title=Query
SELECT hex(1)
```

```response title=Response
01
```

**Float32の数値**

```sql title=Query
SELECT hex(toFloat32(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 00007041         │
│ 00008041         │
└──────────────────┘
```

**Float64の数値**

```sql title=Query
SELECT hex(toFloat64(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 0000000000002E40 │
│ 0000000000003040 │
└──────────────────┘
```

**UUIDの変換**

```sql title=Query
SELECT lower(hex(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'))) AS uuid_hex
```

```response title=Response
┌─uuid_hex─────────────────────────┐
│ 61f0c4045cb311e7907ba6006ad3dba0 │
└──────────────────────────────────┘
```


## hilbertDecode {#hilbertDecode}

導入バージョン: v24.6

ヒルベルト曲線インデックスを符号なし整数のタプルにデコードし、多次元空間における座標を表します。

`hilbertEncode`関数と同様に、この関数には2つの動作モードがあります:

- **シンプルモード**
- **拡張モード**

**シンプルモード**

最大2つの符号なし整数を引数として受け取り、`UInt64`コードを生成します。

**拡張モード**

最初の引数として範囲マスク(タプル)を受け取り、その他の引数として最大2つの符号なし整数を受け取ります。マスク内の各数値は、対応する引数が左シフトされるビット数を設定し、その範囲内で引数を効果的にスケーリングします。

範囲拡張は、大きく異なる範囲(またはカーディナリティ)を持つ引数に対して類似した分布が必要な場合に有用です。例えば、'IPアドレス' `(0...FFFFFFFF)`と'国コード' `(0...FF)`などです。エンコード関数と同様に、最大8つの数値に制限されています。

**構文**

```sql
hilbertDecode(tuple_size, code)
```

**引数**

- `tuple_size` — `2`以下の整数値。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)または[`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — `UInt64`コード。[`UInt64`](/sql-reference/data-types/int-uint)

**戻り値**

指定されたサイズのタプルを返します。[`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**例**

**シンプルモード**

```sql title=Query
SELECT hilbertDecode(2, 31)
```

```response title=Response
["3", "4"]
```

**単一引数**

```sql title=Query
-- 1つの引数に対するヒルベルトコードは常に引数自体(タプルとして)です。
SELECT hilbertDecode(1, 1)
```

```response title=Response
["1"]
```

**拡張モード**

```sql title=Query
-- ビットシフトを指定するタプルを持つ単一引数は、それに応じて右シフトされます。
SELECT hilbertDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**カラムの使用**

```sql title=Query
-- まずテーブルを作成し、データを挿入します
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';
insert into hilbert_numbers (*) values(1,2);

-- 関数の引数として定数の代わりにカラム名を使用します
SELECT untuple(hilbertDecode(2, hilbertEncode(n1, n2))) FROM hilbert_numbers;
```

```response title=Response
1    2
```


## hilbertEncode {#hilbertEncode}

導入バージョン: v24.6

符号なし整数のリストに対してヒルベルト曲線のコードを計算します。

この関数には2つの動作モードがあります:

- **シンプルモード**
- **拡張モード**

**シンプルモード**

最大2つの符号なし整数を引数として受け取り、UInt64コードを生成します。

**拡張モード**

最初の引数として範囲マスク([Tuple](../../sql-reference/data-types/tuple.md))を受け取り、
その他の引数として最大2つの[符号なし整数](../../sql-reference/data-types/int-uint.md)を受け取ります。

マスク内の各数値は、対応する引数を左シフトするビット数を設定し、
引数をその範囲内で効果的にスケーリングします。

**構文**

```sql
-- シンプルモード
hilbertEncode(args)

-- 拡張モード
hilbertEncode(range_mask, args)
```

**引数**

- `args` — 最大2つの`UInt`値または`UInt`型のカラム。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 拡張モード用に、最大2つの`UInt`値または`UInt`型のカラム。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

`UInt64`コードを返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**シンプルモード**

```sql title=Query
SELECT hilbertEncode(3, 4)
```

```response title=Response
31
```

**拡張モード**

```sql title=Query
-- 範囲の拡張は、大きく異なる範囲(またはカーディナリティ)を持つ引数に対して
-- 類似した分布が必要な場合に有用です。
-- 例: 'IPアドレス' (0...FFFFFFFF) と '国コード' (0...FF)。
-- 注意: タプルのサイズは他の引数の数と等しくなければなりません。
SELECT hilbertEncode((10, 6), 1024, 16)
```

```response title=Response
4031541586602
```

**単一引数**

```sql title=Query
-- タプルなしの単一引数の場合、次元マッピングが不要なため、
-- 関数は引数自体をヒルベルトインデックスとして返します。
SELECT hilbertEncode(1)
```

```response title=Response
1
```

**拡張単一引数**

```sql title=Query
-- ビットシフトを指定するタプルと共に単一引数が提供された場合、
-- 関数は指定されたビット数だけ引数を左シフトします。
SELECT hilbertEncode(tuple(2), 128)
```

```response title=Response
512
```

**カラムの使用**

```sql title=Query
-- まずテーブルを作成してデータを挿入します
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1;
insert into hilbert_numbers (*) values(1, 2);

-- 定数の代わりにカラム名を関数の引数として使用します
SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;
```

```response title=Response
13
```


## mortonDecode {#mortonDecode}

導入バージョン: v24.6

モートン符号化（Zカーブ）を対応する符号なし整数のタプルにデコードします。

`mortonEncode`関数と同様に、この関数には2つの動作モードがあります:

- **シンプルモード**
- **拡張モード**

**シンプルモード**

第1引数として結果のタプルサイズを、第2引数としてコードを受け取ります。

**拡張モード**

第1引数として範囲マスク(タプル)を、第2引数としてコードを受け取ります。
マスク内の各数値は範囲の縮小量を設定します:

- `1` - 縮小なし
- `2` - 2倍縮小
- `3` - 3倍縮小
  ⋮
- 最大8倍縮小

範囲拡張は、大きく異なる範囲(またはカーディナリティ)を持つ引数に対して類似した分布が必要な場合に有用です。例: 'IPアドレス' `(0...FFFFFFFF)`と'国コード' `(0...FF)`。エンコード関数と同様に、最大8個の数値に制限されています。

**構文**

```sql
-- シンプルモード
mortonDecode(tuple_size, code)

-- 拡張モード
mortonDecode(range_mask, code)
```

**引数**

- `tuple_size` — 8以下の整数値。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 拡張モード用の各引数のマスク。マスクは符号なし整数のタプルです。マスク内の各数値は範囲の縮小量を設定します。[`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — UInt64コード。[`UInt64`](/sql-reference/data-types/int-uint)

**戻り値**

指定されたサイズのタプルを返します。[`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**例**

**シンプルモード**

```sql title=Query
SELECT mortonDecode(3, 53)
```

```response title=Response
["1", "2", "3"]
```

**単一引数**

```sql title=Query
SELECT mortonDecode(1, 1)
```

```response title=Response
["1"]
```

**拡張モード、1つの引数を縮小**

```sql title=Query
SELECT mortonDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**カラムの使用**

```sql title=Query
-- まずテーブルを作成してデータを挿入
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- 関数の引数として定数の代わりにカラム名を使用
SELECT untuple(mortonDecode(8, mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8))) FROM morton_numbers;
```

```response title=Response
1 2 3 4 5 6 7 8
```


## mortonEncode {#mortonEncode}

導入バージョン: v24.6

符号なし整数のリストに対してモートン符号化（Zカーブ）を計算します。

この関数には2つの動作モードがあります：

- **シンプルモード**
- **拡張モード**

**シンプルモード**

最大8個の符号なし整数を引数として受け取り、`UInt64`コードを生成します。

**拡張モード**

最初の引数として範囲マスク（[Tuple](../data-types/tuple.md)）を受け取り、
その他の引数として最大8個の[符号なし整数](../data-types/int-uint.md)を受け取ります。

マスク内の各数値は範囲拡張の量を設定します：

- 1 - 拡張なし
- 2 - 2倍拡張
- 3 - 3倍拡張
  ⋮
- 最大8倍拡張

**構文**

```sql
-- シンプルモード
mortonEncode(args)

-- 拡張モード
mortonEncode(range_mask, args)
```

**引数**

- `args` — 最大8個の符号なし整数、または前述の型のカラム。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 拡張モード用の各引数のマスク。マスクは`1`から`8`の符号なし整数のタプルです。マスク内の各数値は範囲拡張の量を設定します。[`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)

**戻り値**

`UInt64`コードを返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**シンプルモード**

```sql title=クエリ
SELECT mortonEncode(1, 2, 3)
```

```response title=結果
53
```

**拡張モード**

```sql title=クエリ
-- 範囲拡張は、大きく異なる範囲（またはカーディナリティ）を持つ引数に対して
-- 類似した分布が必要な場合に有用です
-- 例：'IPアドレス'（0...FFFFFFFF）と'国コード'（0...FF）
-- 注意：タプルのサイズは他の引数の数と等しくなければなりません。
SELECT mortonEncode((1,2), 1024, 16)
```

```response title=結果
1572864
```

**単一引数**

```sql title=クエリ
-- 1つの引数に対するモートン符号化は常に引数自体になります
SELECT mortonEncode(1)
```

```response title=結果
1
```

**拡張された単一引数**

```sql title=クエリ
SELECT mortonEncode(tuple(2), 128)
```

```response title=結果
32768
```

**カラムの使用**

```sql title=クエリ
-- まずテーブルを作成してデータを挿入します
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- 定数の代わりにカラム名を関数の引数として使用します
SELECT mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8) FROM morton_numbers;
```

```response title=結果
2155374165
```


## sqidDecode {#sqidDecode}

導入バージョン: v24.1

[sqid](https://sqids.org/)を数値の配列に戻します。

**構文**

```sql
sqidDecode(sqid)
```

**引数**

- `sqid` — デコードするsqid。[`String`](/sql-reference/data-types/string)

**戻り値**

`sqid`から数値の配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT sqidDecode('gXHfJ1C6dN');
```

```response title=レスポンス
┌─sqidDecode('gXHfJ1C6dN')─────┐
│ [1, 2, 3, 4, 5]              │
└──────────────────────────────┘
```


## sqidEncode {#sqidEncode}

導入バージョン: v24.1

数値を[sqid](https://sqids.org/)（YouTubeのようなID文字列）に変換します。

**構文**

```sql
sqidEncode(n1[, n2, ...])
```

**エイリアス**: `sqid`

**引数**

- `n1[, n2, ...]` — 任意の個数の数値。[`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**戻り値**

ハッシュIDを[`String`](/sql-reference/data-types/string)として返します

**例**

**使用例**

```sql title=Query
SELECT sqidEncode(1, 2, 3, 4, 5);
```

```response title=Response
┌─sqidEncode(1, 2, 3, 4, 5)─┐
│ gXHfJ1C6dN                │
└───────────────────────────┘
```


## unbin {#unbin}

導入バージョン: v21.8

引数内の2進数の各ペアを数値として解釈し、その数値が表すバイトに変換します。この関数はbinの逆操作を実行します。

数値引数に対して`unbin()`は`bin()`の逆を返しません。結果を数値に変換したい場合は、reverseおよび`reinterpretAs<Type>`関数を使用できます。

:::note
`unbin`が`clickhouse-client`内から呼び出された場合、バイナリ文字列はUTF-8を使用して表示されます。
:::

2進数の`0`と`1`をサポートします。2進数の桁数は8の倍数である必要はありません。引数文字列に2進数以外のものが含まれている場合、結果は未定義となります(例外はスローされません)。

**構文**

```sql
unbin(arg)
```

**引数**

- `arg` — 任意の数の2進数を含む文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

バイナリ文字列(BLOB)を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な使用方法**

```sql title=クエリ
SELECT UNBIN('001100000011000100110010'), UNBIN('0100110101111001010100110101000101001100')
```

```response title=レスポンス
┌─unbin('001100000011000100110010')─┬─unbin('0100110101111001010100110101000101001100')─┐
│ 012                               │ MySQL                                             │
└───────────────────────────────────┴───────────────────────────────────────────────────┘
```

**数値への変換**

```sql title=クエリ
SELECT reinterpretAsUInt64(reverse(unbin('1110'))) AS num
```

```response title=レスポンス
┌─num─┐
│  14 │
└─────┘
```


## unhex {#unhex}

導入バージョン: v1.1

[`hex`](#hex)の逆操作を実行します。引数内の16進数の各ペアを数値として解釈し、その数値が表すバイトに変換します。戻り値はバイナリ文字列（BLOB）です。

結果を数値に変換する場合は、`reverse`関数と`reinterpretAs<Type>`関数を使用できます。

:::note
`clickhouse-client`は文字列をUTF-8として解釈します。
そのため、`hex`が返す値が予期しない形で表示されることがあります。
:::

大文字と小文字の両方の`A-F`に対応しています。
16進数の桁数は偶数である必要はありません。
奇数の場合、最後の桁は`00-0F`バイトの下位半分として解釈されます。
引数文字列に16進数以外の文字が含まれている場合、実装定義の結果が返されます（例外はスローされません）。
数値引数の場合、unhex()はhex(N)の逆操作を実行しません。

**構文**

```sql
unhex(arg)
```

**引数**

- `arg` — 任意の数の16進数を含む文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

バイナリ文字列（BLOB）を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な使用方法**

```sql title=Query
SELECT unhex('303132'), UNHEX('4D7953514C')
```

```response title=Response
┌─unhex('303132')─┬─unhex('4D7953514C')─┐
│ 012             │ MySQL               │
└─────────────────┴─────────────────────┘
```

**数値への変換**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unhex('FFF'))) AS num
```

```response title=Response
┌──num─┐
│ 4095 │
└──────┘
```

<!--AUTOGENERATED_END-->

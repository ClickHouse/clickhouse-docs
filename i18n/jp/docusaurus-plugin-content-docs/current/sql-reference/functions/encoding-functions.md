---
'description': 'Documentation for encoding functions'
'sidebar_label': 'Encoding'
'slug': '/sql-reference/functions/encoding-functions'
'title': 'エンコーディング関数'
'keywords':
- 'encoding'
- 'regular functions'
- 'encode'
- 'decode'
'doc_type': 'reference'
---


# エンコーディング関数

<!-- 
以下のタグの内部コンテンツは、docフレームワークのビルド時に system.functions から生成されたドキュメントで置き換えられます。タグを変更したり削除したりしないでください。
参照: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## bech32Decode {#bech32Decode}

導入したバージョン: v25.6


bech32またはbech32mアルゴリズムによって生成されたBech32アドレス文字列をデコードします。

:::note
encode関数とは異なり、`Bech32Decode`は自動的にパディングされたFixedStringsを処理します。
:::
    

**構文**

```sql
bech32Decode(address)
```

**引数**

- `address` — デコードするBech32文字列。 [`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)


**返される値**

デコードに使用された `(hrp, data)` のタプルを返します。データはバイナリ形式です。 [`Tuple(String, String)`](/sql-reference/data-types/tuple)

**例**

**アドレスのデコード**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z') AS tup)
```

```response title=Response
bc   751E76E8199196D454941C45D1B3A323F1433BD6
```

**テストネットアドレス**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('tb1w508d6qejxtdg4y5r3zarvary0c5xw7kzp034v') AS tup)
```

```response title=Response
tb   751E76E8199196D454941C45D1B3A323F1433BD6
```



## bech32Encode {#bech32Encode}

導入したバージョン: v25.6


[Bech32またはBech32m](https://en.bitcoin.it/wiki/Bech32)アルゴリズムを使用して、バイナリデータ文字列と人間が読みやすい部分 (HRP) をエンコードします。

:::note
[`FixedString`](../data-types/fixedstring.md)データ型を使用する場合、値が行を完全に埋めない場合は、ヌル文字でパディングされます。
`bech32Encode`関数はhrp引数の自動処理を行いますが、data引数の値はパディングされてはいけません。
このため、すべての値が同じ長さであることを確認している場合を除き、データ値に[`FixedString`](../data-types/fixedstring.md)データ型を使用することはお勧めできません。
:::
    

**構文**

```sql
bech32Encode(hrp, data[, witver])
```

**引数**

- `hrp` — コードの「人間が読みやすい部分」を指定する `1 - 83` の小文字の文字列。通常は 'bc' または 'tb'。 [`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
- `data` — エンコードするバイナリデータの文字列。 [`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
- `witver` — オプション。ウィットネスバージョン (デフォルト = 1)。実行するアルゴリズムのバージョンを指定する `UInt*`。 `0` はBech32、`1`以上はBech32m。 [`UInt*`](/sql-reference/data-types/int-uint)


**返される値**

人間が読みやすい部分、区切り文字（常に '1'）、およびデータ部分から構成されるBech32アドレス文字列を返します。文字列の長さは90文字を超えないことが保証されます。アルゴリズムが入力から有効なアドレスを生成できない場合、空の文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**デフォルトBech32m**

```sql title=Query
-- When no witness version is supplied, the default is 1, the updated Bech32m algorithm.
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'))
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7k8zcwmq
```

**Bech32アルゴリズム**

```sql title=Query
-- A witness version of 0 will result in a different address string.
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 0)
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z
```

**カスタムHRP**

```sql title=Query
-- While 'bc' (Mainnet) and 'tb' (Testnet) are the only allowed hrp values for the
-- SegWit address format, Bech32 allows any hrp that satisfies the above requirements.
SELECT bech32Encode('abcdefg', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 10)
```

```response title=Response
abcdefg1w508d6qejxtdg4y5r3zarvary0c5xw7k9rp8r4
```



## bin {#bin}

導入したバージョン: v21.8


引数のバイナリ表現を含む文字列を返します。異なる型に対する以下のロジックに従います。

| 型                       | 説明                                                                                                                                                                                                                                                           |
|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `(U)Int*`                  | 最も重要なビットから最も重要でないビットまで（ビッグエンディアンまたは「人間が読みやすい」順序）でビン桁を印刷します。最も重要なゼロ以外のバイト（先頭のゼロバイトは省略されます）で始まりますが、先頭の桁がゼロの場合は、各バイトのすべての桁を常に印刷します。|
| `Date` および `DateTime` | 対応する整数（Dateの場合はエポックからの日数、DateTimeの場合はUnixタイムスタンプの値）としてフォーマットされます。                                                                                                                                           |
| `String` および `FixedString` | すべてのバイトは単に8つのバイナリ数としてエンコードされます。ゼロバイトは省略されません。                                                                                                                                                                                     |
| `Float*` および `Decimal` | メモリ内の表現としてエンコードされます。私たちはリトルエンディアンアーキテクチャをサポートしているため、リトルエンディアンでエンコードされます。ゼロ先頭/末尾バイトは省略されません。                                                                                                  |
| `UUID`                     | ビッグエンディアン順序の文字列としてエンコードされます。                                                                                                                                                                                                                                   |
    

**構文**

```sql
bin(arg)
```

**引数**

- `arg` — バイナリに変換する値。 [`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal) または [`Date`](/sql-reference/data-types/date) または [`DateTime`](/sql-reference/data-types/datetime)


**返される値**

引数のバイナリ表現を持つ文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**シンプルな整数**

```sql title=Query
SELECT bin(14)
```

```response title=Response
┌─bin(14)──┐
│ 00001110 │
└──────────┘
```

**Float32の数値**

```sql title=Query
SELECT bin(toFloat32(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────┐
│ 00000000000000000111000001000001 │
│ 00000000000000001000000001000001 │
└──────────────────────────────────┘
```

**Float64の数値**

```sql title=Query
SELECT bin(toFloat64(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────────────────────────────────────┐
│ 0000000000000000000000000000000000000000000000000010111001000000 │
│ 0000000000000000000000000000000000000000000000000011000001000000 │
└──────────────────────────────────────────────────────────────────┘
```

**UUIDの変換**

```sql title=Query
SELECT bin(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')) AS bin_uuid
```

```response title=Response
┌─bin_uuid─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ 01100001111100001100010000000100010111001011001100010001111001111001000001111011101001100000000001101010110100111101101110100000 │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```



## bitPositionsToArray {#bitPositionsToArray}

導入したバージョン: v21.7


この関数は、符号なし整数のバイナリ表現における1ビットの位置（昇順）を返します。
符号付き入力整数は最初に符号なし整数にキャストされます。
    

**構文**

```sql
bitPositionsToArray(arg)
```

**引数**

- `arg` — 整数値。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**返される値**

入力のバイナリ表現における1ビットの昇順に並んだ位置の配列を返します。 [`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**1ビットが設定されている**

```sql title=Query
SELECT bitPositionsToArray(toInt8(1)) AS bit_positions
```

```response title=Response
┌─bit_positions─┐
│ [0]           │
└───────────────┘
```

**すべてのビットが設定されている**

```sql title=Query
SELECT bitPositionsToArray(toInt8(-1)) AS bit_positions
```

```response title=Response
┌─bit_positions─────────────┐
│ [0, 1, 2, 3, 4, 5, 6, 7]  │
└───────────────────────────┘
```



## bitmaskToArray {#bitmaskToArray}

導入したバージョン: v1.1


この関数は整数を2のべき乗の合計に分解します。
2のべき乗は昇順で配列として返されます。
    

**構文**

```sql
bitmaskToArray(num)
```

**引数**

- `num` — 整数値。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**返される値**

入力数に合計する昇順の2のべき乗の配列を返します。 [`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**基本的な例**

```sql title=Query
SELECT bitmaskToArray(50) AS powers_of_two
```

```response title=Response
┌─powers_of_two───┐
│ [2, 16, 32]     │
└─────────────────┘
```

**単一の2のべき乗**

```sql title=Query
SELECT bitmaskToArray(8) AS powers_of_two
```

```response title=Response
┌─powers_of_two─┐
│ [8]           │
└───────────────┘
```



## bitmaskToList {#bitmaskToList}

導入したバージョン: v1.1


bitmaskToArrayのように、2のべき乗をカンマ区切りの文字列として返します。
    

**構文**

```sql
bitmaskToList(num)
```

**引数**

- `num` — 整数値。 [`(U)Int*`](/sql-reference/data-types/int-uint)


**返される値**

カンマ区切りの2のべき乗を含む文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**基本的な例**

```sql title=Query
SELECT bitmaskToList(50) AS powers_list
```

```response title=Response
┌─powers_list───┐
│ 2, 16, 32     │
└───────────────┘
```



## char {#char}

導入したバージョン: v20.1


与えられた引数の数と同じ長さの文字列を返し、各バイトの値は対応する引数に等しくなります。数値型の複数の引数を受け入れます。

引数の値が `UInt8` データ型の範囲外である場合、それは潜在的な丸めおよびオーバーフローを伴って `UInt8` に変換されます。
        

**構文**

```sql
char(num1[, num2[, ...]])
```

**引数**

- `num1[, num2[, num3 ...]]` — 整数として解釈される数値引数。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float)


**返される値**

指定されたバイトの文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**基本的な例**

```sql title=Query
SELECT char(104.1, 101, 108.9, 108.9, 111) AS hello;
```

```response title=Response
┌─hello─┐
│ hello │
└───────┘
```

**任意のエンコーディングの構築**

```sql title=Query
-- You can construct a string of arbitrary encoding by passing the corresponding bytes.
-- for example UTF8
SELECT char(0xD0, 0xBF, 0xD1, 0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1, 0x82) AS hello;
```

```response title=Response
┌─hello──┐
│ привет │
└────────┘
```



## hex {#hex}

導入したバージョン: v1.1


引数の16進数表現を含む文字列を返します。以下の異なる型に対するロジックに従います。

| 型                       | 説明                                                                                                                                                                                                                                                                            |
|----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `(U)Int*`                  | 最も重要な桁から最も重要でない桁まで（ビッグエンディアンまたは「人間が読みやすい」順序）で16進桁（「ニブル」）を印刷します。最も重要なゼロ以外のバイト（先頭のゼロバイトは省略）が最初に来ますが、先頭桁がゼロであっても各バイトの両桁を常に印刷します。 |
| `Date` および `DateTime` | 対応する整数（Dateの場合はエポックからの日数、DateTimeの場合はUnixタイムスタンプの値）としてフォーマットされます。                                                                                                                                                            |
| `String` および `FixedString` | すべてのバイトは単に2つの16進数としてエンコードされます。ゼロバイトは省略されません。                                                                                                                                                                                                   |
| `Float*` および `Decimal` | メモリ内の表現としてエンコードされます。ClickHouseは常に内部値をリトルエンディアンとして表現するため、そのようにエンコードされます。ゼロ先頭/末尾バイトは省略されません。                                                                                                                   |
| `UUID`                     | ビッグエンディアン順序の文字列としてエンコードされます。                                                                                                                                                                                                                                                    |

この関数は、アルファベットの大文字 `A-F` を使用し、接頭辞（`0x`など）や接尾辞（`h`など）は使用しません。
    

**構文**

```sql
hex(arg)
```

**引数**

- `arg` — 16進数に変換する値。 [`String`](/sql-reference/data-types/string) または [`(U)Int*`](/sql-reference/data-types/int-uint) または [`Float*`](/sql-reference/data-types/float) または [`Decimal`](/sql-reference/data-types/decimal) または [`Date`](/sql-reference/data-types/date) または [`DateTime`](/sql-reference/data-types/datetime)


**返される値**

引数の16進数表現を持つ文字列を返します。 [`String`](/sql-reference/data-types/string)

**例**

**シンプルな整数**

```sql title=Query
SELECT hex(1)
```

```response title=Response
01
```

**Float32の数値**

```sql title=Query
SELECT hex(toFloat32(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 00007041         │
│ 00008041         │
└──────────────────┘
```

**Float64の数値**

```sql title=Query
SELECT hex(toFloat64(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 0000000000002E40 │
│ 0000000000003040 │
└──────────────────┘
```

**UUIDの変換**

```sql title=Query
SELECT lower(hex(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'))) AS uuid_hex
```

```response title=Response
┌─uuid_hex─────────────────────────┐
│ 61f0c4045cb311e7907ba6006ad3dba0 │
└──────────────────────────────────┘
```



## hilbertDecode {#hilbertDecode}

導入したバージョン: v24.6


Hilbert曲線インデックスをデコードして、マルチディメンショナル空間の座標を表す符号なし整数のタプルに戻します。

`hilbertEncode`関数と同様に、この関数は2つの動作モードを持っています。
- **シンプル**
- **拡張**

**シンプルモード**

最大2つの符号なし整数を引数として受け取り、`UInt64`コードを生成します。

**拡張モード**

最初の引数として範囲マスク（タプル）を受け取り、最大2つの符号なし整数を他の引数として受け取ります。マスク内の各数値は、対応する引数が左にシフトされるビット数を構成し、実質的にその範囲内で引数をスケーリングします。

範囲の拡張は、異常に異なる範囲（または基数）を持つ引数の間で類似の分布を必要とする場合に有益です。例えば、「IPアドレス」 `(0...FFFFFFFF)` と「国コード」 `(0...FF)` です。エンコード関数と同様に、これは最大8つの数値に制限されています。
    

**構文**

```sql
hilbertDecode(tuple_size, code)
```

**引数**

- `tuple_size` — `2`を超えない整数値。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint) または [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — `UInt64`コード。 [`UInt64`](/sql-reference/data-types/int-uint)


**返される値**

指定されたサイズのタプルを返します。 [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**例**

**シンプルモード**

```sql title=Query
SELECT hilbertDecode(2, 31)
```

```response title=Response
["3", "4"]
```

**単一引数**

```sql title=Query
-- Hilbert code for one argument is always the argument itself (as a tuple).
SELECT hilbertDecode(1, 1)
```

```response title=Response
["1"]
```

**拡張モード**

```sql title=Query
-- A single argument with a tuple specifying bit shifts will be right-shifted accordingly.
SELECT hilbertDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**カラムの使用**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';
insert into hilbert_numbers (*) values(1,2);

-- Use column names instead of constants as function arguments
SELECT untuple(hilbertDecode(2, hilbertEncode(n1, n2))) FROM hilbert_numbers;
```

```response title=Response
1    2
```



## hilbertEncode {#hilbertEncode}

導入したバージョン: v24.6


符号なし整数のリストに対するHilbert曲線のコードを計算します。

この関数には2つの動作モードがあります。
- **シンプル**
- **拡張**

**シンプルモード**

最大2つの符号なし整数を引数として受け取り、`UInt64`コードを生成します。

**拡張モード**

最初の引数として範囲マスク ([Tuple](../../sql-reference/data-types/tuple.md)) を受け取り、最大2つの[符号なし整数](../../sql-reference/data-types/int-uint.md)を他の引数として受け取ります。

マスク内の各数値は、対応する引数が左にシフトされるビット数を構成し、実質的にその範囲内で引数をスケーリングします。
    

**構文**

```sql
-- Simplified mode
hilbertEncode(args)

-- Expanded mode
hilbertEncode(range_mask, args)
```

**引数**

- `args` — 最大2つの `UInt`値または`UInt`型のカラム。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 拡張モードの場合、最大2つの `UInt`値または `UInt`型のカラム。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**返される値**

`UInt64`コードを返します。 [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**シンプルモード**

```sql title=Query
SELECT hilbertEncode(3, 4)
```

```response title=Response
31
```

**拡張モード**

```sql title=Query
-- Range expansion can be beneficial when you need a similar distribution for
-- arguments with wildly different ranges (or cardinality).
-- For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF).
-- Note: tuple size must be equal to the number of the other arguments.
SELECT hilbertEncode((10, 6), 1024, 16)
```

```response title=Response
4031541586602
```

**単一引数**

```sql title=Query
-- For a single argument without a tuple, the function returns the argument
-- itself as the Hilbert index, since no dimensional mapping is needed.
SELECT hilbertEncode(1)
```

```response title=Response
1
```

**拡張単一引数**

```sql title=Query
-- If a single argument is provided with a tuple specifying bit shifts, the function
-- shifts the argument left by the specified number of bits.
SELECT hilbertEncode(tuple(2), 128)
```

```response title=Response
512
```

**カラムの使用**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1;
insert into hilbert_numbers (*) values(1, 2);

-- Use column names instead of constants as function arguments
SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;
```

```response title=Response
13
```



## mortonDecode {#mortonDecode}

導入したバージョン: v24.6


モートンエンコーディング（ZCurve）を対応する符号なし整数タプルにデコードします。

`mortonEncode`関数と同様に、この関数には2つの動作モードが存在します。
- **シンプル**
- **拡張**

**シンプルモード**

結果のタプルサイズを最初の引数として受け取り、コードを2番目の引数として受け取ります。

**拡張モード**

範囲マスク（タプル）を最初の引数として受け取り、コードを2番目の引数として受け取ります。
マスク内の各数値は範囲の縮小量を構成します：

* `1` - 縮小なし
* `2` - 2倍の縮小
* `3` - 3倍の縮小
⋮
* 最大8倍の縮小。

範囲の拡張は、異常に異なる範囲（または基数）を持つ引数の間で類似の分布を必要とする場合に有益です。例えば、「IPアドレス」 `(0...FFFFFFFF)` と「国コード」 `(0...FF)` です。エンコード関数と同様に、これは最大8つの数値に制限されています。
    

**構文**

```sql
-- Simple mode
mortonDecode(tuple_size, code)

-- Expanded mode
mortonDecode(range_mask, code)
```

**引数**

- `tuple_size` — 8を超えない整数値。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 拡張モードの場合、各引数のマスク。マスクは符号なし整数のタプルです。マスク内の各数値は範囲の縮小量を構成します。 [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — `UInt64`コード。 [`UInt64`](/sql-reference/data-types/int-uint)


**返される値**

指定されたサイズのタプルを返します。 [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**例**

**シンプルモード**

```sql title=Query
SELECT mortonDecode(3, 53)
```

```response title=Response
["1", "2", "3"]
```

**単一引数**

```sql title=Query
SELECT mortonDecode(1, 1)
```

```response title=Response
["1"]
```

**拡張モード、一つの引数を縮小**

```sql title=Query
SELECT mortonDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**カラムの使用**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- Use column names instead of constants as function arguments
SELECT untuple(mortonDecode(8, mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8))) FROM morton_numbers;
```

```response title=Response
1 2 3 4 5 6 7 8
```



## mortonEncode {#mortonEncode}

導入したバージョン: v24.6


符号なし整数のリストに対してモートンエンコーディング（ZCurve）を計算します。

この関数には2つの動作モードがあります。
- **シンプル**
- **拡張**

**シンプルモード**

最大8つの符号なし整数を引数として受け取り、`UInt64`コードを生成します。

**拡張モード**

最初の引数として範囲マスク ([Tuple](../data-types/tuple.md)) を受け取り、最大8つの [符号なし整数](../data-types/int-uint.md) を他の引数として受け取ります。

マスク内の各数値は範囲の拡張量を構成します：
* 1 - 拡張なし
* 2 - 2倍の拡張
* 3 - 3倍の拡張
⋮
* 最大8倍の拡張。
    

**構文**

```sql
-- Simplified mode
mortonEncode(args)

-- Expanded mode
mortonEncode(range_mask, args)
```

**引数**

- `args` — 最大8つの符号なし整数または前述の型のカラム。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 拡張モードの場合、各引数のマスク。マスクは `1` - `8` の範囲の符号なし整数のタプルです。マスク内の各数値は範囲の縮小量を構成します。 [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)


**返される値**

`UInt64`コードを返します。 [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**シンプルモード**

```sql title=Query
SELECT mortonEncode(1, 2, 3)
```

```response title=Response
53
```

**拡張モード**

```sql title=Query
-- Range expansion can be beneficial when you need a similar distribution for
-- arguments with wildly different ranges (or cardinality)
-- For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF).
-- Note: the Tuple size must be equal to the number of the other arguments.
SELECT mortonEncode((1,2), 1024, 16)
```

```response title=Response
1572864
```

**単一引数**

```sql title=Query
-- Morton encoding for one argument is always the argument itself
SELECT mortonEncode(1)
```

```response title=Response
1
```

**拡張単一引数**

```sql title=Query
SELECT mortonEncode(tuple(2), 128)
```

```response title=Response
32768
```

**カラムの使用**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- Use column names instead of constants as function arguments
SELECT mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8) FROM morton_numbers;
```

```response title=Response
2155374165
```



## sqidDecode {#sqidDecode}

導入したバージョン: v24.1


[sqid](https://sqids.org/)を数字の配列に戻します。
    

**構文**

```sql
sqidDecode(sqid)
```

**引数**

- `sqid` — デコードするsqid。 [`String`](/sql-reference/data-types/string)


**返される値**

`sqid`からの数字の配列を返します。 [`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT sqidDecode('gXHfJ1C6dN');
```

```response title=Response
┌─sqidDecode('gXHfJ1C6dN')─────┐
│ [1, 2, 3, 4, 5]              │
└──────────────────────────────┘
```



## sqidEncode {#sqidEncode}

導入したバージョン: v24.1


数字を[sqid](https://sqids.org/)に変換し、YoutubeのようなID文字列を生成します。
    

**構文**

```sql
sqidEncode(n1[, n2, ...])
```

**引数**

- `n1[, n2, ...]` — 任意の数の数値。 [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**返される値**

ハッシュIDを返します。 [`String`](/sql-reference/data-types/string)

**例**

**使用例**

```sql title=Query
SELECT sqidEncode(1, 2, 3, 4, 5);
```

```response title=Response
┌─sqidEncode(1, 2, 3, 4, 5)─┐
│ gXHfJ1C6dN                │
└───────────────────────────┘
```



## unbin {#unbin}

導入したバージョン: v21.8


引数内の各ペアのバイナリ桁を数値として解釈し、その数値によって表されるバイトに変換します。この関数はbinの逆の操作を行います。

数値引数に対して、`unbin()`は`bin()`の逆を返しません。結果を数値に変換したい場合は、`reverse`および`reinterpretAs<Type>`関数を使用することができます。

:::note
`unbin`が`clickhouse-client`内から呼び出されると、バイナリ文字列がUTF-8として表示されます。
:::

バイナリ桁 `0` および `1` をサポートします。バイナリ桁の数は8の倍数である必要はありません。引数の文字列にバイナリ桁以外のものが含まれている場合、結果は未定義（例外はスローされません）。
    

**構文**

```sql
unbin(arg)
```

**引数**

- `arg` — 任意の数のバイナリ桁を含む文字列。 [`String`](/sql-reference/data-types/string)


**返される値**

バイナリ文字列（BLOB）を返します。 [`String`](/sql-reference/data-types/string)

**例**

**基本的な使用法**

```sql title=Query
SELECT UNBIN('001100000011000100110010'), UNBIN('0100110101111001010100110101000101001100')
```

```response title=Response
┌─unbin('001100000011000100110010')─┬─unbin('0100110101111001010100110101000101001100')─┐
│ 012                               │ MySQL                                             │
└───────────────────────────────────┴───────────────────────────────────────────────────┘
```

**数値に変換**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unbin('1110'))) AS num
```

```response title=Response
┌─num─┐
│  14 │
└─────┘
```



## unhex {#unhex}

導入したバージョン: v1.1


[`hex`](#hex)の逆の操作を行います。引数内の各ペアの16進数桁を数値として解釈し、その数値によって表されるバイトに変換します。返される値はバイナリ文字列（BLOB）です。

結果を数値に変換したい場合は、`reverse`および`reinterpretAs<Type>`関数を使用することができます。

:::note
`clickhouse-client`は文字列をUTF-8として解釈します。
これにより、`hex`によって返された値が驚くべき方法で表示される可能性があります。
:::

大文字および小文字の `A-F` の両方をサポートします。
16進数の桁の数は偶数である必要はありません。
奇数の場合、最後の桁は `00-0F` バイトの最も重要でない半分として解釈されます。
引数の文字列に16進数以外のものが含まれている場合、実装定義された結果が返されます（例外はスローされません）。
数値引数に対して、`unhex()`の逆の操作は行われません。


**構文**

```sql
unhex(arg)
```

**引数**

- `arg` — 任意の数の16進数桁を含む文字列。 [`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)


**返される値**

バイナリ文字列（BLOB）を返します。 [`String`](/sql-reference/data-types/string)

**例**

**基本的な使用法**

```sql title=Query
SELECT unhex('303132'), UNHEX('4D7953514C')
```

```response title=Response
┌─unhex('303132')─┬─unhex('4D7953514C')─┐
│ 012             │ MySQL               │
└─────────────────┴─────────────────────┘
```

**数値に変換**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unhex('FFF'))) AS num
```

```response title=Response
┌──num─┐
│ 4095 │
└──────┘
```



<!--AUTOGENERATED_END-->

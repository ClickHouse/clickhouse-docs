---
description: 'エンコード関数のドキュメント'
sidebar_label: 'エンコード'
slug: /sql-reference/functions/encoding-functions
title: 'エンコード関数'
keywords: ['エンコーディング', '通常の関数', 'エンコード', 'デコード']
doc_type: 'reference'
---

# エンコード関数 {#encoding-functions}

{/* 
  以下のタグの内部の内容は、ドキュメントフレームワークのビルド時に
  system.functions から生成されるドキュメントに置き換えられます。タグを変更または削除しないでください。
  詳しくは https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{/*AUTOGENERATED_START*/ }

## bech32Decode {#bech32Decode}

導入バージョン: v25.6

bech32 または bech32m アルゴリズムのいずれかによって生成された Bech32 アドレス文字列をデコードします。

:::note
`encode` 関数とは異なり、`Bech32Decode` はパディング済みの FixedString 型を自動的に処理します。
:::

**構文**

```sql
bech32Decode(address)
```

**引数**

* `address` — デコードする Bech32 形式の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

文字列のエンコードに使用された `(hrp, data)` からなるタプルを返します。`data` はバイナリ形式です。[`Tuple(String, String)`](/sql-reference/data-types/tuple)

**例**

**アドレスのデコード**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z') AS tup)
```

```response title=Response
bc   751E76E8199196D454941C45D1B3A323F1433BD6
```

**Testnet address**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('tb1w508d6qejxtdg4y5r3zarvary0c5xw7kzp034v') AS tup)
```

```response title=Response
tb   751E76E8199196D454941C45D1B3A323F1433BD6
```



## bech32Encode {#bech32Encode}

Introduced in: v25.6


Encodes a binary data string, along with a human-readable part (HRP), using the [Bech32 or Bech32m](https://en.bitcoin.it/wiki/Bech32) algorithms.

:::note
When using the [`FixedString`](../data-types/fixedstring.md) data type, if a value does not fully fill the row it is padded with null characters.
While the `bech32Encode` function will handle this automatically for the hrp argument, for the data argument the values must not be padded.
For this reason it is not recommended to use the [`FixedString`](../data-types/fixedstring.md) data type for your data values unless you are
certain that they are all the same length and ensure that your `FixedString` column is set to that length as well.
:::
    

**Syntax**

```sql
bech32Encode(hrp, data[, witver])
```

**Arguments**

- `hrp` — A String of `1 - 83` lowercase characters specifying the "human-readable part" of the code. Usually 'bc' or 'tb'. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `data` — A String of binary data to encode. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)
- `witver` — Optional. The witness version (default = 1). An `UInt*` specifying the version of the algorithm to run. `0` for Bech32 and `1` or greater for Bech32m. [`UInt*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a Bech32 address string, consisting of the human-readable part, a separator character which is always '1', and a data part. The length of the string will never exceed 90 characters. If the algorithm cannot generate a valid address from the input, it will return an empty string. [`String`](/sql-reference/data-types/string)

**Examples**

**Default Bech32m**

```sql title=Query
-- witness バージョンが指定されていない場合、デフォルトは 1 となり、更新された Bech32m アルゴリズムが使用されます。
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'))
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7k8zcwmq
```

**Bech32 algorithm**

```sql title=Query
-- witness バージョンを 0 に設定すると、異なるアドレス文字列が生成されます。
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 0)
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z
```

**Custom HRP**

```sql title=Query
-- 'bc'（メインネット）と'tb'（テストネット）はSegWitアドレス形式で許可されている唯一のhrp値ですが、
-- Bech32は上記の要件を満たす任意のhrpを使用できます。
SELECT bech32Encode('abcdefg', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 10)
```

```response title=Response
abcdefg1w508d6qejxtdg4y5r3zarvary0c5xw7k9rp8r4
```



## bin {#bin}

Introduced in: v21.8


Returns a string containing the argument's binary representation according
to the following logic for different types:

| Type                       | Description                                                                                                                                                                                                                                                           |
|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `(U)Int*`                  | Prints bin digits from the most significant to least significant (big-endian or "human-readable" order). It starts with the most significant non-zero byte (leading zero bytes are omitted) but always prints eight digits of every byte if the leading digit is zero.|
| `Date` and `DateTime`      | Formatted as corresponding integers (the number of days since epoch for Date and the value of unix timestamp for DateTime).                                                                                                                                           |
| `String` and `FixedString` | All bytes are simply encoded as eight binary numbers. Zero bytes are not omitted.                                                                                                                                                                                     |
| `Float*` and `Decimal`     | Encoded as their representation in memory. As we support little-endian architecture, they are encoded in little-endian. Zero leading/trailing bytes are not omitted.                                                                                                  |
| `UUID`                     | Encoded as big-endian order string.                                                                                                                                                                                                                                   |
    

**Syntax**

```sql
bin(arg)
```

**Arguments**

- `arg` — A value to convert to binary. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring) or [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal) or [`Date`](/sql-reference/data-types/date) or [`DateTime`](/sql-reference/data-types/datetime)


**Returned value**

Returns a string with the binary representation of the argument. [`String`](/sql-reference/data-types/string)

**Examples**

**Simple integer**

```sql title=Query
SELECT bin(14)
```

```response title=Response
┌─bin(14)──┐
│ 00001110 │
└──────────┘
```

**Float32 numbers**

```sql title=Query
SELECT bin(toFloat32(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────┐
│ 00000000000000000111000001000001 │
│ 00000000000000001000000001000001 │
└──────────────────────────────────┘
```

**Float64 numbers**

```sql title=Query
SELECT bin(toFloat64(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────────────────────────────────────┐
│ 0000000000000000000000000000000000000000000000000010111001000000 │
│ 0000000000000000000000000000000000000000000000000011000001000000 │
└──────────────────────────────────────────────────────────────────┘
```

**UUID conversion**

```sql title=Query
SELECT bin(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')) AS bin_uuid
```

```response title=Response
┌─bin_uuid─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ 01100001111100001100010000000100010111001011001100010001111001111001000001111011101001100000000001101010110100111101101110100000 │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```



## bitPositionsToArray {#bitPositionsToArray}

Introduced in: v21.7


This function returns the positions (in ascending order) of the 1 bits in the binary representation of an unsigned integer.
Signed input integers are first casted to an unsigned integer.
    

**Syntax**

```sql
bitPositionsToArray(引数)
```

**Arguments**

- `arg` — An integer value. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array with the ascendingly ordered positions of 1 bits in the binary representation of the input. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Single bit set**

```sql title=Query
SELECT bitPositionsToArray(toInt8(1)) AS bit_positions
```

```response title=Response
┌─bit_positions─┐
│ [0]           │
└───────────────┘
```

**All bits set**

```sql title=Query
SELECT bitPositionsToArray(toInt8(-1)) AS bit_positions
```

```response title=Response
┌─bit_positions─────────────┐
│ [0, 1, 2, 3, 4, 5, 6, 7]  │
└───────────────────────────┘
```



## bitmaskToArray {#bitmaskToArray}

Introduced in: v1.1


This function decomposes an integer into a sum of powers of two.
The powers of two are returned as an ascendingly ordered array.
    

**Syntax**

```sql
bitmaskToArray(num)
```

**Arguments**

- `num` — An integer value. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array with the ascendingly ordered powers of two which sum up to the input number. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Basic example**

```sql title=Query
SELECT bitmaskToArray(50) AS powers_of_two
```

```response title=Response
┌─powers_of_two───┐
│ [2, 16, 32]     │
└─────────────────┘
```

**Single power of two**

```sql title=Query
SELECT bitmaskToArray(8) AS powers_of_two
```

```response title=Response
┌─powers_of_two─┐
│ [8]           │
└───────────────┘
```



## bitmaskToList {#bitmaskToList}

Introduced in: v1.1


Like bitmaskToArray but returns the powers of two as a comma-separated string.
    

**Syntax**

```sql
bitmaskToList(num)
```

**Arguments**

- `num` — An integer value. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a string containing comma-separated powers of two. [`String`](/sql-reference/data-types/string)

**Examples**

**Basic example**

```sql title=Query
SELECT bitmaskToList(50) AS powers_list
```

```response title=Response
┌─powers_list───┐
│ 2, 16, 32     │
└───────────────┘
```



## char {#char}

Introduced in: v20.1


Returns a string with length equal to the number of arguments passed where each byte
has the value of the corresponding argument. Accepts multiple arguments of numeric types.

If the value of the argument is out of range of the `UInt8` data type, then it is converted
to `UInt8` with potential rounding and overflow.
        

**Syntax**

```sql
char(num1[, num2[, ...]])
```

**Arguments**

- `num1[, num2[, num3 ...]]` — Numerical arguments interpreted as integers. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)


**Returned value**

Returns a string of the given bytes. [`String`](/sql-reference/data-types/string)

**Examples**

**Basic example**

```sql title=Query
SELECT char(104.1, 101, 108.9, 108.9, 111) AS hello;
```

```response title=Response
┌─hello─┐
│ hello │
└───────┘
```

**Constructing arbitrary encodings**

```sql title=Query
-- 対応するバイト列を渡すことで、任意のエンコーディングの文字列を生成できます。
-- 例えば UTF-8 の場合
SELECT char(0xD0, 0xBF, 0xD1, 0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1, 0x82) AS hello;
```

```response title=Response
┌─hello──┐
│ привет │
└────────┘
```



## hex {#hex}

Introduced in: v1.1


Returns a string containing the argument's hexadecimal representation according
to the following logic for different types:

| Type                       | Description                                                                                                                                                                                                                                                                            |
|----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `(U)Int*`                  | Prints hex digits ("nibbles") from the most significant to least significant (big-endian or "human-readable" order). It starts with the most significant non-zero byte (leading zero bytes are omitted) but always prints both digits of every byte even if the leading digit is zero. |
| `Date` and `DateTime`      | Formatted as corresponding integers (the number of days since epoch for Date and the value of unix timestamp for DateTime).                                                                                                                                                            |
| `String` and `FixedString` | All bytes are simply encoded as two hexadecimal numbers. Zero bytes are not omitted.                                                                                                                                                                                                   |
| `Float*` and `Decimal`     | Encoded as their representation in memory. ClickHouse represents the values internally always as little endian, therefore they are encoded as such. Zero leading/trailing bytes are not omitted.                                                                                                                   |
| `UUID`                     | Encoded as big-endian order string.                                                                                                                                                                                                                                                    |

The function uses uppercase letters `A-F` and not using any prefixes (like `0x`) or suffixes (like `h`).
    

**Syntax**

```sql
hex(arg)
```

**Arguments**

- `arg` — A value to convert to hexadecimal. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal) or [`Date`](/sql-reference/data-types/date) or [`DateTime`](/sql-reference/data-types/datetime)


**Returned value**

Returns a string with the hexadecimal representation of the argument. [`String`](/sql-reference/data-types/string)

**Examples**

**Simple integer**

```sql title=Query
SELECT hex(1)
```

```response title=Response
01
```

**Float32 numbers**

```sql title=Query
SELECT hex(toFloat32(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 00007041         │
│ 00008041         │
└──────────────────┘
```

**Float64 numbers**

```sql title=Query
SELECT hex(toFloat64(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 0000000000002E40 │
│ 0000000000003040 │
└──────────────────┘
```

**UUID conversion**

```sql title=Query
SELECT lower(hex(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'))) AS uuid_hex
```

```response title=Response
┌─uuid_hex─────────────────────────┐
│ 61f0c4045cb311e7907ba6006ad3dba0 │
└──────────────────────────────────┘
```



## hilbertDecode {#hilbertDecode}

Introduced in: v24.6


Decodes a Hilbert curve index back into a tuple of unsigned integers, representing coordinates in multi-dimensional space.

As with the `hilbertEncode` function, this function has two modes of operation:
- **Simple**
- **Expanded**

**Simple mode**

Accepts up to 2 unsigned integers as arguments and produces a `UInt64` code.

**Expanded mode**

Accepts a range mask (tuple) as a first argument and up to 2 unsigned integers as
other arguments. Each number in the mask configures the number of bits by which
the corresponding argument will be shifted left, effectively scaling the argument
within its range.

Range expansion can be beneficial when you need a similar distribution for
arguments with wildly different ranges (or cardinality) For example: 'IP Address' `(0...FFFFFFFF)`
and 'Country code' `(0...FF)`. As with the encode function, this is limited to 8
numbers at most.
    

**Syntax**

```sql
hilbertDecode(tuple_size, code)
```

**Arguments**

- `tuple_size` — Integer value of no more than `2`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint) or [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — `UInt64` code. [`UInt64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a tuple of the specified size. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**Examples**

**Simple mode**

```sql title=Query
SELECT hilbertDecode(2, 31)
```

```response title=Response
["3", "4"]
```

**Single argument**

```sql title=Query
-- 1つの引数に対するヒルベルト符号は、常にその引数自体（タプルとして）です。
SELECT hilbertDecode(1, 1)
```

```response title=Response
["1"]
```

**Expanded mode**

```sql title=Query
-- ビットシフトを指定するタプルを持つ単一の引数は、それに応じて右シフトされます。
SELECT hilbertDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**Column usage**

```sql title=Query
-- まずテーブルを作成し、いくつかのデータを挿入します
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';
insert into hilbert_numbers (*) values(1,2);

-- 関数の引数には定数ではなくカラム名を使用します
SELECT untuple(hilbertDecode(2, hilbertEncode(n1, n2))) FROM hilbert_numbers;
```

```response title=Response
1    2
```



## hilbertEncode {#hilbertEncode}

Introduced in: v24.6


Calculates code for Hilbert Curve for a list of unsigned integers.

The function has two modes of operation:
- **Simple**
- **Expanded**

**Simple mode**

Accepts up to 2 unsigned integers as arguments and produces a UInt64 code.

**Expanded mode**

Accepts a range mask ([Tuple](../../sql-reference/data-types/tuple.md)) as the
first argument and up to 2 [unsigned integers](../../sql-reference/data-types/int-uint.md)
as other arguments.

Each number in the mask configures the number of bits by which the corresponding
argument will be shifted left, effectively scaling the argument within its range.
    

**Syntax**

```sql
-- シンプルモード
hilbertEncode(args)

-- 拡張モード
hilbertEncode(range_mask, args)
```

**Arguments**

- `args` — Up to two `UInt` values or columns of type `UInt`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — For the expanded mode, up to two `UInt` values or columns of type `UInt`. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a `UInt64` code. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Simple mode**

```sql title=Query
SELECT hilbertEncode(3, 4)
```

```response title=Response
31
```

**Expanded mode**

```sql title=Query
-- 範囲の拡張は、範囲（またはカーディナリティ）が大きく異なる引数に対しても、
-- 似たような分布が必要な場合に有用です。
-- 例: 「IPアドレス」(0...FFFFFFFF) と 「国コード」(0...FF)。
-- 注意: タプルのサイズは、他の引数の個数と等しくなければなりません。
SELECT hilbertEncode((10, 6), 1024, 16)
```

```response title=Response
4031541586602
```

**Single argument**

```sql title=Query
-- タプルではない単一の引数が指定された場合、この関数は
-- 次元マッピングが不要なため、その引数自体を Hilbert インデックスとして返します。
SELECT hilbertEncode(1)
```

```response title=Response
1
```

**Expanded single argument**

```sql title=Query
-- タプルでビットシフトを指定した単一の引数が提供された場合、
-- 関数は指定されたビット数だけ引数を左にシフトします。
SELECT hilbertEncode(tuple(2), 128)
```

```response title=Response
512
```

**Column usage**

```sql title=Query
-- まずテーブルを作成し、いくつかデータを挿入します
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1;
insert into hilbert_numbers (*) values(1, 2);

-- 関数の引数には定数ではなくカラム名を使用します
SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;
```

```response title=Response
13
```



## mortonDecode {#mortonDecode}

Introduced in: v24.6


Decodes a Morton encoding (ZCurve) into the corresponding unsigned integer tuple.

As with the `mortonEncode` function, this function has two modes of operation:
- **Simple**
- **Expanded**

**Simple mode**

Accepts a resulting tuple size as the first argument and the code as the second argument.

**Expanded mode**

Accepts a range mask (tuple) as the first argument and the code as the second argument.
Each number in the mask configures the amount of range shrink:

* `1` - no shrink
* `2` - 2x shrink
* `3` - 3x shrink
⋮
* Up to 8x shrink.

Range expansion can be beneficial when you need a similar distribution for
arguments with wildly different ranges (or cardinality). For example: 'IP Address' `(0...FFFFFFFF)`
and 'Country code' `(0...FF)`. As with the encode function, this is limited to
8 numbers at most.
    

**Syntax**

```sql
-- シンプルモード
mortonDecode(tuple_size, code)

-- 拡張モード
mortonDecode(range_mask, code)
```

**Arguments**

- `tuple_size` — Integer value no more than 8. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — For the expanded mode, the mask for each argument. The mask is a tuple of unsigned integers. Each number in the mask configures the amount of range shrink. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — UInt64 code. [`UInt64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a tuple of the specified size. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**Examples**

**Simple mode**

```sql title=Query
SELECT mortonDecode(3, 53)
```

```response title=Response
["1", "2", "3"]
```

**Single argument**

```sql title=Query
SELECT mortonDecode(1, 1)
```

```response title=Response
["1"]
```

**Expanded mode, shrinking one argument**

```sql title=Query
SELECT mortonDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**Column usage**

```sql title=Query
-- まずテーブルを作成し、データを挿入します
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- 関数の引数として定数の代わりに列名を使用します
SELECT untuple(mortonDecode(8, mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8))) FROM morton_numbers;
```

```response title=Response
1 2 3 4 5 6 7 8
```



## mortonEncode {#mortonEncode}

Introduced in: v24.6


Calculates the Morton encoding (ZCurve) for a list of unsigned integers.

The function has two modes of operation:
- **Simple**
- *Expanded**

**Simple mode**

Accepts up to 8 unsigned integers as arguments and produces a `UInt64` code.

**Expanded mode**

Accepts a range mask ([Tuple](../data-types/tuple.md)) as the first argument and
up to 8 [unsigned integers](../data-types/int-uint.md) as other arguments.

Each number in the mask configures the amount of range expansion:
* 1 - no expansion
* 2 - 2x expansion
* 3 - 3x expansion
⋮
* Up to 8x expansion.
    

**Syntax**

```sql
-- 簡易モード
mortonEncode(args)

-- 拡張モード
mortonEncode(range_mask, args)
```

**Arguments**

- `args` — Up to 8 unsigned integers or columns of the aforementioned type. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — For the expanded mode, the mask for each argument. The mask is a tuple of unsigned integers from `1` - `8`. Each number in the mask configures the amount of range shrink. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)


**Returned value**

Returns a `UInt64` code. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Simple mode**

```sql title=Query
SELECT mortonEncode(1, 2, 3)
```

```response title=Response
53
```

**Expanded mode**

```sql title=Query
-- 範囲拡張は、大きく異なる範囲（またはカーディナリティ）を持つ
-- 引数に対して類似した分布が必要な場合に有用です
-- 例：「IPアドレス」（0...FFFFFFFF）と「国コード」（0...FF）
-- 注：タプルのサイズは他の引数の数と一致する必要があります。
SELECT mortonEncode((1,2), 1024, 16)
```

```response title=Response
1572864
```

**Single argument**

```sql title=Query
-- 1つの引数に対するMortonエンコーディングは常に引数自体です
SELECT mortonEncode(1)
```

```response title=Response
1
```

**Expanded single argument**

```sql title=Query
SELECT mortonEncode(tuple(2), 128)
```

```response title=Response
32768
```

**Column usage**

```sql title=Query
-- まずテーブルを作成し、いくつかデータを挿入します
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- 関数の引数には定数ではなくカラム名を指定します
SELECT mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8) FROM morton_numbers;
```

```response title=Response
2155374165
```



## sqidDecode {#sqidDecode}

Introduced in: v24.1


Transforms a [sqid](https://sqids.org/) back into an array of numbers.
    

**Syntax**

```sql
sqidDecode(sqid)
```

**Arguments**

- `sqid` — The sqid to decode. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns an array of numbers from `sqid`. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT sqidDecode('gXHfJ1C6dN');
```

```response title=Response
┌─sqidDecode('gXHfJ1C6dN')─────┐
│ [1, 2, 3, 4, 5]              │
└──────────────────────────────┘
```



## sqidEncode {#sqidEncode}

Introduced in: v24.1


Transforms numbers into a [sqid](https://sqids.org/), a Youtube-like ID string.
    

**Syntax**

```sql
sqidEncode(n1[, n2, ...])
```

**Aliases**: `sqid`

**Arguments**

- `n1[, n2, ...]` — Arbitrarily many numbers. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a hash ID [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
SELECT sqidEncode(1, 2, 3, 4, 5);
```

```response title=Response
┌─sqidEncode(1, 2, 3, 4, 5)─┐
│ gXHfJ1C6dN                │
└───────────────────────────┘
```



## unbin {#unbin}

Introduced in: v21.8


Interprets each pair of binary digits (in the argument) as a number and converts it to the byte represented by the number. The functions performs the opposite operation to bin.

For a numeric argument `unbin()` does not return the inverse of `bin()`. If you want to convert the result to a number, you can use the reverse and `reinterpretAs<Type>` functions.

:::note
If `unbin` is invoked from within the `clickhouse-client`, binary strings are displayed using UTF-8.
:::

Supports binary digits `0` and `1`. The number of binary digits does not have to be multiples of eight. If the argument string contains anything other than binary digits,
the result is undefined (no exception is thrown).
    

**Syntax**

```sql
unbin(arg)
```

**Arguments**

- `arg` — A string containing any number of binary digits. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns a binary string (BLOB). [`String`](/sql-reference/data-types/string)

**Examples**

**Basic usage**

```sql title=Query
SELECT UNBIN('001100000011000100110010'), UNBIN('0100110101111001010100110101000101001100')
```

```response title=Response
┌─unbin('001100000011000100110010')─┬─unbin('0100110101111001010100110101000101001100')─┐
│ 012                               │ MySQL                                             │
└───────────────────────────────────┴───────────────────────────────────────────────────┘
```

**Convert to number**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unbin('1110'))) AS num
```

```response title=Response
┌─num─┐
│  14 │
└─────┘
```



## unhex {#unhex}

Introduced in: v1.1


Performs the opposite operation of [`hex`](#hex). It interprets each pair of hexadecimal digits (in the argument) as a number and converts
it to the byte represented by the number. The returned value is a binary string (BLOB).

If you want to convert the result to a number, you can use the `reverse` and `reinterpretAs<Type>` functions.

:::note
`clickhouse-client` interprets strings as UTF-8.
This may cause that values returned by `hex` to be displayed surprisingly.
:::

Supports both uppercase and lowercase letters `A-F`.
The number of hexadecimal digits does not have to be even.
If it is odd, the last digit is interpreted as the least significant half of the `00-0F` byte.
If the argument string contains anything other than hexadecimal digits, some implementation-defined result is returned (an exception isn't thrown).
For a numeric argument the inverse of hex(N) is not performed by unhex().


**Syntax**

```sql
unhex(arg)
```

**Arguments**

- `arg` — A string containing any number of hexadecimal digits. [`String`](/sql-reference/data-types/string) or [`FixedString`](/sql-reference/data-types/fixedstring)


**Returned value**

Returns a binary string (BLOB). [`String`](/sql-reference/data-types/string)

**Examples**

**Basic usage**

```sql title=Query
SELECT unhex('303132'), UNHEX('4D7953514C')
```

```response title=Response
┌─unhex('303132')─┬─unhex('4D7953514C')─┐
│ 012             │ MySQL               │
└─────────────────┴─────────────────────┘
```

**Convert to number**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unhex('FFF'))) AS num
```

```response title=Response
┌──num─┐
│ 4095 │
└──────┘
```

{/*AUTOGENERATED_END*/ }

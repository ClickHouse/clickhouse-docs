---
description: '文字列を検索するための関数に関するドキュメント'
sidebar_label: '文字列検索'
slug: /sql-reference/functions/string-search-functions
title: '文字列検索用関数'
doc_type: 'reference'
---



# 文字列検索関数

このセクションのすべての関数は、デフォルトで大文字と小文字を区別して検索します。大文字と小文字を区別しない検索は、通常、別の関数バリアントで提供されます。

:::note
大文字と小文字を区別しない検索は、英語の大文字・小文字変換規則に従います。例えば、英語で `i` を大文字にすると
`I` になりますが、トルコ語では `İ` になります。英語以外の言語では予期しない結果になる可能性があります。
:::

このセクションの関数は、検索対象の文字列(このセクションでは `haystack` と呼びます)と検索文字列(このセクションでは `needle` と呼びます)がシングルバイトエンコードされたテキストであることを前提としています。この前提が
満たされない場合、例外はスローされず、結果は未定義となります。UTF-8エンコードされた文字列での検索は、通常、別の関数
バリアントで提供されます。同様に、UTF-8関数バリアントを使用し、入力文字列がUTF-8エンコードされたテキストでない場合、例外はスローされず、
結果は未定義となります。自動的なUnicode正規化は実行されませんが、
[normalizeUTF8\*()](https://clickhouse.com../functions/string-functions/) 関数を使用することで対応できます。

[一般的な文字列関数](string-functions.md)と[文字列置換関数](string-replace-functions.md)については別途説明しています。

:::note
以下のドキュメントは `system.functions` システムテーブルから生成されています。
:::

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->


<!--AUTOGENERATED_START-->

## countMatches {#countMatches}

Introduced in: v21.1

文字列内で正規表現にマッチした回数を返します。

:::note バージョン依存の動作
この関数の動作はClickHouseのバージョンに依存します:

- バージョン < v25.6 では、パターンが受け入れられる場合でも、最初の空マッチで関数はカウントを停止します。
- バージョン >= 25.6 では、空マッチが発生した場合でも関数は実行を継続します。レガシー動作は設定 `count_matches_stop_at_empty_match = true` を使用して復元できます;
  :::

**構文**

```sql
countMatches(haystack, pattern)
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `pattern` — 正規表現パターン。[`String`](/sql-reference/data-types/string)

**戻り値**

見つかったマッチの数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**数字列のカウント**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```


## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

Introduced in: v21.1

[`countMatches`](#countMatches)と同様ですが、大文字と小文字を区別せずにマッチングを行います。

**構文**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `pattern` — 正規表現パターン。[`const String`](/sql-reference/data-types/string)

**戻り値**

マッチした数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字と小文字を区別しないカウント**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```


## countSubstrings {#countSubstrings}

導入バージョン: v21.1

文字列 `haystack` 内に部分文字列 `needle` が出現する回数を返します。

**構文**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**引数**

- `haystack` — 検索を実行する文字列。[String](../../sql-reference/data-types/string.md) または [Enum](../../sql-reference/data-types/enum.md)。 - `needle` — 検索する部分文字列。[String](../../sql-reference/data-types/string.md)。 - `start_pos` — 検索を開始する `haystack` 内の位置(1始まり)。[UInt](../../sql-reference/data-types/int-uint.md)。省略可能。

**戻り値**

出現回数。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT countSubstrings('aaaa', 'aa');
```

```response title=レスポンス
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**start_pos 引数を使用する場合**

```sql title=クエリ
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=レスポンス
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```


## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

導入バージョン: v21.1

[`countSubstrings`](#countSubstrings)と同様ですが、大文字と小文字を区別せずにカウントします。

**構文**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)または[`Enum`](/sql-reference/data-types/enum)
- `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
- `start_pos` — オプション。検索を開始する`haystack`内の位置(1始まり)。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

haystack内のneedleの出現回数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**start_pos引数を使用した場合**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```


## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

導入バージョン: v21.1

[`countSubstrings`](#countSubstrings)と同様ですが、大文字小文字を区別せずにカウントし、haystackがUTF-8文字列であることを前提とします。

**構文**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**引数**

- `haystack` — 検索対象のUTF-8文字列。[`String`](/sql-reference/data-types/string)または[`Enum`](/sql-reference/data-types/enum)
- `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
- `start_pos` — オプション。検索を開始する`haystack`内の位置(1始まり)。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

haystack内でneedleが出現する回数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=結果
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**start_pos引数を使用した場合**

```sql title=クエリ
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=結果
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```


## extract {#extract}

導入バージョン: v1.1

文字列内で正規表現に最初にマッチした部分を抽出します。
'haystack'が'pattern'にマッチしない場合、空文字列が返されます。

この関数はRE2正規表現ライブラリを使用します。サポートされている構文については[re2](https://github.com/google/re2/wiki/Syntax)を参照してください。

正規表現にキャプチャグループ(サブパターン)が含まれている場合、関数は入力文字列を最初のキャプチャグループに対してマッチングします。

**構文**

```sql
extract(haystack, pattern)
```

**引数**

- `haystack` — 抽出元の文字列。[`String`](/sql-reference/data-types/string)
- `pattern` — 正規表現。通常はキャプチャグループを含みます。[`const String`](/sql-reference/data-types/string)

**戻り値**

抽出されたフラグメントを文字列として返します。[`String`](/sql-reference/data-types/string)

**例**

**メールアドレスからドメインを抽出**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**マッチしない場合は空文字列を返す**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```


## extractAll {#extractAll}

導入バージョン: v1.1

[`extract`](#extract)と同様ですが、文字列内で正規表現に一致するすべての箇所を配列として返します。
'haystack'が'pattern'正規表現に一致しない場合は、空の配列が返されます。

正規表現にキャプチャグループ(サブパターン)が含まれている場合、関数は入力文字列を最初のキャプチャグループに対してマッチングします。

**構文**

```sql
extractAll(haystack, pattern)
```

**引数**

- `haystack` — フラグメントを抽出する文字列。[`String`](/sql-reference/data-types/string)
- `pattern` — 正規表現。オプションでキャプチャグループを含むことができます。[`const String`](/sql-reference/data-types/string)

**戻り値**

抽出されたフラグメントの配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**すべての数値を抽出**

```sql title=クエリ
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=レスポンス
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**キャプチャグループを使用した抽出**

```sql title=クエリ
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=レスポンス
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```


## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

導入バージョン: v20.5

指定された正規表現を使用して文字列内のすべてのグループにマッチし、配列の配列を返します。各配列には同じキャプチャグループからのすべてのキャプチャが含まれ、グループ番号順に整理されています。

**構文**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**引数**

- `s` — 抽出元の入力文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — マッチに使用する正規表現。[`const String`](/sql-reference/data-types/string)または[`const FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

配列の配列を返します。各内部配列には、すべてのマッチにわたる1つのキャプチャグループからのすべてのキャプチャが含まれます。最初の内部配列にはグループ1からのすべてのキャプチャが含まれ、2番目にはグループ2からのキャプチャが含まれます。マッチが見つからない場合は空の配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=レスポンス
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```


## extractGroups {#extractGroups}

導入バージョン: v20.5

正規表現にマッチする重複しない部分文字列から、すべてのグループを抽出します。

**構文**

```sql
extractAllGroups(s, regexp)
```

**引数**

- `s` — 抽出元の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — 正規表現。定数。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

関数が少なくとも1つのマッチするグループを見つけた場合、group_id（`1` から `N`、ここで `N` は正規表現内のキャプチャグループの数）でグループ化された Array(Array(String)) カラムを返します。マッチするグループがない場合は、空の配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=レスポンス
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```


## hasAllTokens {#hasAllTokens}

導入バージョン: v25.10

[`hasAnyTokens`](#hasAnyTokens)と同様ですが、`needle`文字列または配列内のすべてのトークンが`input`文字列と一致する場合は1を返し、それ以外の場合は0を返します。`input`が列の場合、この条件を満たすすべての行を返します。

:::note
最適なパフォーマンスを得るには、列`input`に[テキストインデックス](../../engines/table-engines/mergetree-family/invertedindexes)を定義する必要があります。
テキストインデックスが定義されていない場合、この関数はブルートフォース列スキャンを実行するため、インデックス検索よりも桁違いに遅くなります。
:::

検索の前に、この関数は以下をトークン化します:

- `input`引数（常に）
- `needle`引数（[String](../../sql-reference/data-types/string.md)として指定された場合）
  テキストインデックスに指定されたトークナイザーを使用します。
  列にテキストインデックスが定義されていない場合は、代わりに`splitByNonAlpha`トークナイザーが使用されます。
  `needle`引数が[Array(String)](../../sql-reference/data-types/array.md)型の場合、各配列要素はトークンとして扱われ、追加のトークン化は行われません。

重複するトークンは無視されます。
例えば、needles = ['ClickHouse', 'ClickHouse']は['ClickHouse']と同じように扱われます。

**構文**

```sql
hasAllTokens(input, needles)
```

**エイリアス**: `hasAllToken`

**引数**

- `input` — 入力列。[`String`](/sql-reference/data-types/string)、[`FixedString`](/sql-reference/data-types/fixedstring)、[`Array(String)`](/sql-reference/data-types/array)、または[`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — 検索するトークン。最大64個のトークンをサポートします。[`String`](/sql-reference/data-types/string)または[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

すべてのneedlesが一致する場合は1を返します。それ以外の場合は0を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**文字列列の使用例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**配列内で検索するneedlesをそのまま（トークン化なし）指定する**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**`tokens`関数を使用してneedlesを生成する**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**配列列とマップ列の使用例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response

```

**配列列を使用した例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeysを使用した例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```


```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapValues の例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```


## hasAnyTokens {#hasAnyTokens}

導入バージョン: v25.10

`needle`文字列または配列内の少なくとも1つのトークンが`input`文字列と一致する場合は1を返し、それ以外の場合は0を返します。`input`が列の場合、この条件を満たすすべての行を返します。

:::note
最適なパフォーマンスを得るには、列`input`に[テキストインデックス](../../engines/table-engines/mergetree-family/invertedindexes)を定義する必要があります。
テキストインデックスが定義されていない場合、この関数はブルートフォースによる列スキャンを実行するため、インデックス検索よりも桁違いに遅くなります。
:::

検索の前に、この関数は以下をトークン化します

- `input`引数(常に)
- `needle`引数([String](../../sql-reference/data-types/string.md)として指定された場合)
  テキストインデックスに指定されたトークナイザーを使用します。
  列にテキストインデックスが定義されていない場合は、代わりに`splitByNonAlpha`トークナイザーが使用されます。
  `needle`引数が[Array(String)](../../sql-reference/data-types/array.md)型の場合、各配列要素はトークンとして扱われ、追加のトークン化は行われません。

重複するトークンは無視されます。
例えば、['ClickHouse', 'ClickHouse']は['ClickHouse']と同じように扱われます。

**構文**

```sql
hasAnyTokens(input, needles)
```

**エイリアス**: `hasAnyToken`

**引数**

- `input` — 入力列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)または[`Array(String)`](/sql-reference/data-types/array)または[`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — 検索するトークン。最大64個のトークンをサポートします。[`String`](/sql-reference/data-types/string)または[`Array(String)`](/sql-reference/data-types/array)

**返り値**

少なくとも1つの一致があった場合は`1`を返します。それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**文字列列の使用例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**配列内で検索するneedlesをそのまま(トークン化なし)指定する**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**`tokens`関数を使用してneedlesを生成する**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**配列列とマップ列の使用例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response

```

**配列列を使用した例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeysを使用した例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```


```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**mapValues の例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```


## hasSubsequence {#hasSubsequence}

導入バージョン: v23.7

needleがhaystackの部分列であるかどうかを判定します。
文字列の部分列とは、元の文字列から0個以上の文字を削除し、残りの文字の順序を変更せずに得られる文字列のことです。

**構文**

```sql
hasSubsequence(haystack, needle)
```

**引数**

- `haystack` — 部分列を検索する対象の文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索対象の部分列。[`String`](/sql-reference/data-types/string)

**戻り値**

needleがhaystackの部分列である場合は`1`を、そうでない場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的な部分列の判定**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**部分列が見つからない場合**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```


## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

導入バージョン: v23.7

[`hasSubsequence`](#hasSubsequence)と同様ですが、大文字と小文字を区別せずに検索します。

**構文**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**引数**

- `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索する部分列。[`String`](/sql-reference/data-types/string)

**戻り値**

needleがhaystackの部分列である場合は1、それ以外の場合は0を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=レスポンス
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```


## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

導入バージョン: v23.7

[`hasSubsequenceUTF8`](#hasSubsequenceUTF8)と同様ですが、大文字と小文字を区別せずに検索します。

**構文**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**引数**

- `haystack` — 検索対象となるUTF8エンコードされた文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索するUTF8エンコードされた部分列文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

needleがhaystackの部分列である場合は1、それ以外の場合は0を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```


## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

導入バージョン: v23.7

[`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence)と同様ですが、haystackとneedleがUTF-8エンコードされた文字列であることを前提としています。

**構文**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索する部分列。[`String`](/sql-reference/data-types/string)

**戻り値**

`needle`が`haystack`の部分列である場合は`1`を返し、そうでない場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**一致しない部分列**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```


## hasToken {#hasToken}

導入バージョン: v20.1

指定されたトークンがhaystack内に存在するかどうかを確認します。

トークンは、連続する文字`[0-9A-Za-z_]`の最長部分列として定義されます。つまり、数字、ASCII文字、アンダースコアです。

**構文**

```sql
hasToken(haystack, token)
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `token` — 検索するトークン。[`const String`](/sql-reference/data-types/string)

**戻り値**

トークンが見つかった場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**トークン検索**

```sql title=クエリ
SELECT hasToken('clickhouse test', 'test')
```

```response title=レスポンス
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```


## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

導入バージョン: v

tokenbf_v1インデックスを使用して、haystack内でneedleを大文字小文字を区別せずに検索します。

**構文**

```sql

```

**引数**

- なし。

**戻り値**

**例**


## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

導入バージョン: v

tokenbf_v1インデックスを使用して、haystack内でneedleを大文字小文字を区別せずに検索します。needleの形式が不正な場合はnullを返します。

**構文**

```sql

```

**引数**

- なし。

**戻り値**

**例**


## hasTokenOrNull {#hasTokenOrNull}

導入バージョン: v20.1

[`hasToken`](#hasToken)と同様ですが、トークンの形式が不正な場合はnullを返します。

**構文**

```sql
hasTokenOrNull(haystack, token)
```

**引数**

- `haystack` — 検索対象の文字列。定数である必要があります。[`String`](/sql-reference/data-types/string)
- `token` — 検索するトークン。[`const String`](/sql-reference/data-types/string)

**戻り値**

トークンが見つかった場合は`1`、見つからなかった場合は`0`、トークンの形式が不正な場合はnullを返します。[`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**例**

**使用例**

```sql title=クエリ
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=レスポンス
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```


## ilike {#ilike}

導入バージョン: v20.6

[`like`](#like)と同様ですが、大文字小文字を区別せずに検索します。

**構文**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**引数**

- `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — マッチングに使用するLIKEパターン。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列がLIKEパターンにマッチする場合(大文字小文字を区別しない)は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT ilike('ClickHouse', '%house%');
```

```response title=結果
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```


## like {#like}

導入バージョン: v1.1

文字列 `haystack` が `LIKE` 式 `pattern` に一致するかどうかを返します。

`LIKE` 式には通常の文字と以下のメタシンボルを含めることができます:

- `%` は任意の数の任意の文字(ゼロ文字を含む)を示します。
- `_` は単一の任意の文字を示します。
- `\` はリテラル `%`、`_`、`\` をエスケープするために使用します。

マッチングはUTF-8に基づいて行われます。例えば、`_` はUTF-8で2バイトで表現されるUnicodeコードポイント `¥` に一致します。

haystack または `LIKE` 式が有効なUTF-8でない場合、動作は未定義です。

自動的なUnicode正規化は行われません。正規化には `normalizeUTF8*` 関数を使用できます。

リテラルの `%`、`_`、`\`(`LIKE` のメタ文字)に一致させるには、バックスラッシュを前に付けます: `\%`、`\_`、`\\`。
バックスラッシュは、`%`、`_`、`\` 以外の文字の前に付けられた場合、特別な意味を失います(つまり、リテラルとして解釈されます)。

:::note
ClickHouseでは文字列内のバックスラッシュも[クォートする必要があります](../syntax.md#string)。そのため、実際には `\\%`、`\\_`、`\\\\` と記述する必要があります。
:::

`%needle%` の形式の `LIKE` 式の場合、この関数は `position` 関数と同じ速度で動作します。
その他のすべての LIKE 式は内部的に正規表現に変換され、`match` 関数と同様のパフォーマンスで実行されます。

**構文**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**引数**

- `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — マッチングする `LIKE` パターン。`%`(任意の数の文字に一致)、`_`(単一の文字に一致)、エスケープ用の `\` を含めることができます。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列が `LIKE` パターンに一致する場合は `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**単一文字のワイルドカード**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**一致しないパターン**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```


## locate {#locate}

導入バージョン: v18.16

[`position`](#position)と同様ですが、引数`haystack`と`needle`が入れ替わっています。

:::note バージョン依存の動作
この関数の動作はClickHouseのバージョンに依存します:

- v24.3未満のバージョンでは、`locate`は関数`position`のエイリアスであり、引数`(haystack, needle[, start_pos])`を受け付けていました。
- v24.3以降のバージョンでは、`locate`は独立した関数となり(MySQLとの互換性向上のため)、引数`(needle, haystack[, start_pos])`を受け付けます。
  以前の動作は設定`function_locate_has_mysql_compatible_argument_order = false`を使用することで復元できます。
  :::

**構文**

```sql
locate(needle, haystack[, start_pos])
```

**引数**

- `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)または[`Enum`](/sql-reference/data-types/enum)
- `start_pos` — オプション。検索を開始する`haystack`内の位置(1始まり)。[`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は1から数えたバイト単位の開始位置を返し、見つからなかった場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用方法**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```


## match {#match}

導入バージョン: v1.1

指定された文字列が指定された正規表現パターンに一致するかどうかを確認します。

この関数はRE2正規表現ライブラリを使用します。サポートされている構文については[re2](https://github.com/google/re2/wiki/Syntax)を参照してください。

マッチングはUTF-8を前提として動作します。例えば、`¥`は内部的には2バイトを使用しますが、マッチングでは単一のコードポイントとして扱われます。
正規表現にNULLバイトを含めることはできません。
haystackまたはpatternが有効なUTF-8でない場合、動作は未定義です。

re2のデフォルト動作とは異なり、`.`は改行にマッチします。これを無効にするには、パターンの先頭に`(?-s)`を付けてください。

パターンは自動的に両端でアンカーされます(パターンが'^'で始まり'$'で終わるかのように)。

部分文字列を検索するだけであれば、[`like`](#like)または[`position`](#position)関数を使用できます - これらの関数はこの関数よりもはるかに高速に動作します。

代替演算子構文: `haystack REGEXP pattern`

**構文**

```sql
match(haystack, pattern)
```

**エイリアス**: `REGEXP_MATCHES`

**引数**

- `haystack` — パターンを検索する文字列。[`String`](/sql-reference/data-types/string)
- `pattern` — 正規表現パターン。[`const String`](/sql-reference/data-types/string)

**戻り値**

パターンが一致する場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的なパターンマッチング**

```sql title=クエリ
SELECT match('Hello World', 'Hello.*')
```

```response title=レスポンス
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**パターンが一致しない場合**

```sql title=クエリ
SELECT match('Hello World', 'goodbye.*')
```

```response title=レスポンス
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```


## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

導入バージョン: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny)と同様ですが、一定の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)内でhaystackに一致するすべてのインデックスを任意の順序で配列として返します。

**構文**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `distance` — ファジーマッチングの最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — マッチング対象のパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

指定された編集距離内でhaystackに一致するすべてのインデックス(1から開始)を任意の順序で配列として返します。一致するものが見つからない場合は空の配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```


## multiFuzzyMatchAny {#multiFuzzyMatchAny}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny)と同様ですが、いずれかのパターンが一定の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)内でhaystackに一致する場合に1を返します。
この関数は[hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching)ライブラリの実験的機能に依存しており、一部のエッジケースでは処理速度が低下する可能性があります。
パフォーマンスは編集距離の値と使用されるパターンに依存しますが、非ファジーバリアントと比較して常に処理コストが高くなります。

:::note
`multiFuzzyMatch*()`関数ファミリーは、hyperscanの制限により、UTF-8正規表現をサポートしていません(バイト列として扱われます)。
:::

**構文**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `distance` — ファジーマッチングの最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — オプション。照合するパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

指定された編集距離内でいずれかのパターンがhaystackに一致する場合は`1`を返し、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```


## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

導入バージョン: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny)と同様ですが、指定した[編集距離](https://en.wikipedia.org/wiki/Edit_distance)内でhaystackに一致するパターンのインデックスを返します。

**構文**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `distance` — ファジーマッチングの最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — マッチング対象のパターン配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

指定された編集距離内でhaystackに一致するパターンのインデックス(1から開始)を返します。一致しない場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```


## multiMatchAllIndices {#multiMatchAllIndices}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny)と同様ですが、haystackに一致するすべてのインデックスを配列として返します。

**構文**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `pattern` — マッチングに使用する正規表現。[`String`](/sql-reference/data-types/string)

**戻り値**

haystackに一致するすべてのインデックス(1から開始)の配列。一致するものが見つからない場合は空の配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=クエリ
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=レスポンス
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```


## multiMatchAny {#multiMatchAny}

導入バージョン: v20.1

複数の正規表現パターンのうち、少なくとも1つが対象文字列に一致するかどうかを確認します。

文字列内で複数の部分文字列を検索するだけの場合は、代わりに関数[`multiSearchAny`](#multiSearchAny)を使用できます。この関数よりもはるかに高速に動作します。

**構文**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**引数**

- `haystack` — パターンを検索する文字列。[`String`](/sql-reference/data-types/string)
- `pattern1[, pattern2, ...]` — 1つ以上の正規表現パターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

いずれかのパターンが一致する場合は`1`を返し、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**複数パターンのマッチング**

```sql title=クエリ
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=レスポンス
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**パターンが一致しない場合**

```sql title=クエリ
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=レスポンス
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```


## multiMatchAnyIndex {#multiMatchAnyIndex}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny)と同様ですが、haystackに一致したパターンのインデックスを返します。

**構文**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `pattern` — マッチング対象の正規表現。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

一致した最初のパターンのインデックス(1から開始)を返します。一致するものがない場合は0を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=レスポンス
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```


## multiSearchAllPositions {#multiSearchAllPositions}

導入バージョン: v20.1

[`position`](#position)と同様ですが、`haystack`文字列内の複数の`needle`部分文字列の位置（バイト単位、1から開始）の配列を返します。

すべての`multiSearch*()`関数は、最大2^8個のneedleまでサポートします。

**構文**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 検索する1つ以上の部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

部分文字列が見つかった場合はバイト単位の開始位置（1から数える）、見つからなかった場合は`0`を含む配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**複数のneedleの検索**

```sql title=クエリ
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=レスポンス
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```


## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

導入バージョン: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions)と同様ですが、大文字小文字を区別しません。

**構文**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 検索する1つ以上の部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

部分文字列が見つかった場合は1から数えたバイト単位の開始位置の配列を返し、見つからなかった場合は`0`を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**大文字小文字を区別しない複数検索**

```sql title=クエリ
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=レスポンス
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```


## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

導入バージョン: v20.1

[`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8)と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象となるUTF-8エンコードされた文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索するUTF-8エンコードされた部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

部分文字列が見つかった場合、バイト単位の開始位置を1から数えた配列。部分文字列が見つからなかった場合は0を返します。[`Array`](/sql-reference/data-types/array)

**例**

**大文字と小文字を区別しないUTF-8検索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```


## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

導入バージョン: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions)と同様ですが、`haystack`と`needle`の部分文字列がUTF-8エンコードされた文字列であることを前提とします。

**構文**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**引数**

- `haystack` — 検索対象となるUTF-8エンコードされた文字列。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 検索するUTF-8エンコードされた部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

部分文字列が見つかった場合は1から数えたバイト単位の開始位置の配列を返し、見つからなかった場合は`0`を返します。[`Array`](/sql-reference/data-types/array)

**例**

**UTF-8マルチ検索**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```


## multiSearchAny {#multiSearchAny}

導入バージョン: v20.1

複数の検索文字列のうち、少なくとも1つが対象文字列に一致するかどうかを確認します。

関数[`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive)、[`multiSearchAnyUTF8`](#multiSearchAnyUTF8)、および[`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8)は、この関数の大文字小文字を区別しないバリアントやUTF-8対応バリアントを提供します。

**構文**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 検索する部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

少なくとも1つの一致があった場合は`1`を、一致がなかった場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**いずれかの一致を検索**

```sql title=クエリ
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=レスポンス
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```


## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

導入バージョン: v20.1

[multiSearchAny](#multiSearchAny)と同様ですが、大文字小文字を区別しません。

**構文**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索する部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

大文字小文字を区別しない一致が少なくとも1つ存在する場合は`1`を返し、存在しない場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない検索**

```sql title=クエリ
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=結果
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```


## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

導入バージョン: v20.1

[multiSearchAnyUTF8](#multiSearchAnyUTF8)と同様ですが、大文字小文字を区別しません。

**構文**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象のUTF-8文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索するUTF-8部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

大文字小文字を区別しない一致が少なくとも1つ存在する場合は`1`を返し、存在しない場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**UTF-8文字列'Здравствуйте'に文字'з'（小文字）が含まれているかを確認**

```sql title=クエリ
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=レスポンス
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

導入バージョン: v20.1

[multiSearchAny](#multiSearchAny)と同様ですが、`haystack`と`needle`の部分文字列がUTF-8エンコードされた文字列であることを前提とします。

**構文**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象のUTF-8文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索する部分文字列のUTF-8配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

少なくとも1つの一致があった場合は`1`を、一致がなかった場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**UTF-8文字列'你好，世界'（'Hello, world'）に、你または界の文字が含まれているかを確認する**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstIndex {#multiSearchFirstIndex}

導入バージョン: v20.1

haystack文字列内で複数のneedle文字列を検索し(大文字小文字を区別)、最初に見つかったneedleの1始まりのインデックスを返します。

**構文**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `needles` — 検索する文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

haystack内で最初に見つかったneedleの1始まりのインデックス(needles配列内の位置)を返します。needleが見つからない場合は0を返します。検索は大文字小文字を区別します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=結果
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**大文字小文字を区別する動作**

```sql title=クエリ
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=結果
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**一致が見つからない場合**

```sql title=クエリ
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=結果
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```


## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

導入バージョン: v20.1

文字列 `haystack` 内で最も左側に見つかった needle_i のインデックス `i`(1から開始)を返します。見つからない場合は0を返します。
大文字小文字を区別しません。

**構文**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索する部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最も左側に見つかった needle のインデックス(1から開始)を返します。一致しない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=レスポンス
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

導入バージョン: v20.1

haystack文字列内で複数のneedle文字列を大文字小文字を区別せず検索し(UTF-8エンコーディング対応)、最初に見つかったneedleの1始まりのインデックスを返します。

**構文**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
- `needles` — 検索する文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

haystack内で最初に見つかったneedleの1始まりのインデックス(needles配列内の位置)を返します。needleが見つからない場合は0を返します。検索は大文字小文字を区別せず、UTF-8文字エンコーディングに対応しています。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8の大文字小文字処理**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**一致なし**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```


## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

導入バージョン: v20.1

文字列 `haystack` 内で最も左側に見つかった needle_i のインデックス `i`（1から開始）を返します。見つからない場合は0を返します。
`haystack` と `needle` はUTF-8エンコードされた文字列であることを前提とします。

**構文**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象のUTF-8文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索するUTF-8部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最も左側に見つかったneedleのインデックス（1から開始）を返します。一致しない場合は0を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstPosition {#multiSearchFirstPosition}

導入バージョン: v20.1

[`position`](#position)と同様ですが、複数の`needle`文字列のいずれかに一致する`haystack`文字列内の最も左側のオフセットを返します。

関数[`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive)、[`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8)、および[`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8)は、この関数の大文字小文字を区別しないバリアントおよび/またはUTF-8対応バリアントを提供します。

**構文**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**引数**

- `haystack` — 検索が実行される文字列。[`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 検索対象となる1つ以上の部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の`needle`文字列のいずれかに一致する`haystack`文字列内の最も左側のオフセットを返します。一致しない場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**最初の位置の検索**

```sql title=クエリ
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=レスポンス
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition)と同様ですが、大文字小文字を区別しません。

**構文**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索する部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の`needle`文字列のいずれかに一致する`haystack`文字列内の最も左側のオフセットを返します。一致するものがない場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない最初の位置**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition)と同様ですが、`haystack`と`needle`をUTF-8文字列として扱い、大文字小文字を区別しません。

**構文**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象のUTF-8文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索するUTF-8部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

複数の`needle`文字列のいずれかに一致する`haystack`文字列内の最も左側のオフセットを、大文字小文字を区別せずに返します。一致しない場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**UTF-8文字列'Здравствуй, мир'（'Hello, world'）内で、指定されたneedleのいずれかに一致する最も左側のオフセットを検索**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition)と同様ですが、`haystack`と`needle`がUTF-8文字列であることを前提としています。

**構文**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

- `haystack` — 検索対象のUTF-8文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索するUTF-8部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の`needle`文字列のいずれかに一致する`haystack`文字列内の最も左側のオフセット。一致しない場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**UTF-8文字列'Здравствуй, мир'（'Hello, world'）内で、指定されたneedleのいずれかに一致する最も左側のオフセットを検索**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```


## ngramDistance {#ngramDistance}

導入バージョン: v20.1

2つの文字列間の4-gram距離を計算します。
この計算では、2つの4-gramマルチセット間の対称差を数え、それらの基数の合計で正規化します。
戻り値が小さいほど、文字列の類似度が高くなります。

大文字小文字を区別しない検索やUTF8形式での検索には、[`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive)、[`ngramDistanceUTF8`](#ngramDistanceUTF8)、[`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8)関数を使用してください。

**構文**

```sql
ngramDistance(haystack, needle)
```

**引数**

- `haystack` — 比較する文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 比較する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`0`から`1`の間のFloat32数値を返します。戻り値が小さいほど、文字列の類似度が高くなります。[`Float32`](/sql-reference/data-types/float)

**例**

**4-gram距離の計算**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```


## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance)の大文字小文字を区別しないバリアントです。
2つの文字列間の4-gram距離を大文字小文字を区別せずに計算します。
戻り値が小さいほど、文字列の類似度が高くなります。

**構文**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**引数**

- `haystack` — 比較する1つ目の文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 比較する2つ目の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`0`から`1`の範囲のFloat32数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**大文字小文字を区別しない4-gram距離**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```


## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance)の大文字小文字を区別しないUTF-8版を提供します。
`needle`と`haystack`の文字列がUTF-8エンコードされた文字列であることを前提とし、大文字小文字を区別しません。
2つのUTF-8文字列間の3-gram距離を大文字小文字を区別せずに計算します。
戻り値が小さいほど、文字列の類似度が高くなります。

**構文**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**引数**

- `haystack` — 1番目のUTF-8エンコードされた比較文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 2番目のUTF-8エンコードされた比較文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`0`から`1`の間のFloat32数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**大文字小文字を区別しないUTF-8 3-gram距離**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```


## ngramDistanceUTF8 {#ngramDistanceUTF8}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance)のUTF-8版を提供します。
`needle`と`haystack`の文字列がUTF-8でエンコードされていることを前提とします。
2つのUTF-8文字列間の3-gram距離を計算します。
戻り値が小さいほど、文字列の類似度が高くなります。

**構文**

```sql
ngramDistanceUTF8(haystack, needle)
```

**引数**

- `haystack` — 1つ目のUTF-8エンコードされた比較文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 2つ目のUTF-8エンコードされた比較文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`0`から`1`の間のFloat32数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**UTF-8 3-gram距離**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```


## ngramSearch {#ngramSearch}

導入バージョン: v20.1

2つの文字列間の4-gram距離が指定された閾値以下であるかどうかを判定します。

大文字小文字を区別しない検索、またはUTF-8形式での検索には、`ngramSearchCaseInsensitive`、`ngramSearchUTF8`、`ngramSearchCaseInsensitiveUTF8`関数を使用してください。

**構文**

```sql
ngramSearch(haystack, needle)
```

**引数**

- `haystack` — 比較する文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 検索する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の4-gram距離が閾値(デフォルトは`1.0`)以下の場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**4-gramを使用した検索**

```sql title=クエリ
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=結果
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```


## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

導入バージョン: v20.1

[`ngramSearch`](#ngramSearch)の大文字小文字を区別しないバリアントを提供します。
needle文字列とhaystack文字列間の非対称差分を計算します。すなわち、needleのn-gram数から共通のn-gram数を引き、needleのn-gram数で正規化した値です。
2つの文字列間の4-gram距離が指定された閾値以下であるかを、大文字小文字を区別せずにチェックします。

**構文**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**引数**

- `haystack` — 比較する文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 比較する文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の4-gram距離が閾値(デフォルトは`1.0`)以下の場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**4-gramを使用した大文字小文字を区別しない検索**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```


## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

導入バージョン: v20.1

[`ngramSearch`](#ngramSearch)の大文字小文字を区別しないUTF-8版を提供します。
`haystack`と`needle`がUTF-8文字列であることを前提とし、大文字小文字を区別しません。
2つのUTF-8文字列間の3-gram距離が指定された閾値以下であるかを、大文字小文字を区別せずにチェックします。

**構文**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**引数**

- `haystack` — 比較するUTF-8文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 比較するUTF-8文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の3-gram距離が閾値(デフォルトは`1.0`)以下の場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**3-gramを使用した大文字小文字を区別しないUTF-8検索**

```sql title=クエリ
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=結果
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```


## ngramSearchUTF8 {#ngramSearchUTF8}

導入バージョン: v20.1

`ngramSearch`のUTF-8版を提供します。
`haystack`と`needle`がUTF-8文字列であることを前提とします。
2つのUTF-8文字列間の3-gram距離が指定された閾値以下であるかを判定します。

**構文**

```sql
ngramSearchUTF8(haystack, needle)
```

**引数**

- `haystack` — 比較対象のUTF-8文字列。[`String`](/sql-reference/data-types/string)
- `needle` — 比較対象のUTF-8文字列。[`String`](/sql-reference/data-types/string)

**返り値**

文字列間の3-gram距離が閾値(デフォルトは`1.0`)以下の場合は`1`を、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**3-gramを使用したUTF-8検索**

```sql title=クエリ
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=レスポンス
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```


## notILike {#notILike}

導入バージョン: v20.6

文字列が大文字小文字を区別せずにパターンに一致しないかどうかを確認します。パターンには、SQL LIKEマッチング用の特殊文字`%`と`_`を含めることができます。

**構文**

```sql
notILike(haystack, pattern)
```

**引数**

- `haystack` — 検索対象の入力文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — マッチング対象のSQL LIKEパターン。`%`は任意の数の文字(ゼロ文字を含む)に一致し、`_`は正確に1文字に一致します。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列がパターンに一致しない場合(大文字小文字を区別しない)は`1`を返し、それ以外の場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=クエリ
SELECT notILike('ClickHouse', '%house%');
```

```response title=レスポンス
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```


## notLike {#notLike}

導入バージョン: v1.1

[`like`](#like)と同様ですが、結果を反転します。

**構文**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)または[`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — マッチング対象のLIKEパターン。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列が`LIKE`パターンに一致しない場合は`1`、一致する場合は`0`を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**パターンが一致しない場合**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```


## position {#position}

導入バージョン: v1.1

文字列 `haystack` 内の部分文字列 `needle` の位置(バイト単位、1から開始)を返します。

部分文字列 `needle` が空の場合、以下のルールが適用されます:

- `start_pos` が指定されていない場合: `1` を返す
- `start_pos = 0` の場合: `1` を返す
- `start_pos >= 1` かつ `start_pos <= length(haystack) + 1` の場合: `start_pos` を返す
- それ以外の場合: `0` を返す

同じルールは関数 [`locate`](#locate)、[`positionCaseInsensitive`](#positionCaseInsensitive)、[`positionUTF8`](#positionUTF8)、および [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8) にも適用されます。

**構文**

```sql
position(haystack, needle[, start_pos])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
- `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
- `start_pos` — 検索を開始する `haystack` 内の位置(1から開始)。省略可能。[`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は1から数えたバイト単位の開始位置を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用法**

```sql title=クエリ
SELECT position('Hello, world!', '!')
```

```response title=レスポンス
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**start_pos 引数を使用する場合**

```sql title=クエリ
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=レスポンス
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Needle IN haystack 構文**

```sql title=クエリ
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=レスポンス
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**空の needle 部分文字列**

```sql title=クエリ
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=レスポンス
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```


## positionCaseInsensitive {#positionCaseInsensitive}

導入バージョン: v1.1

[`position`](#position)と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**エイリアス**: `instr`

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)または[`Enum`](/sql-reference/data-types/enum)
- `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
- `start_pos` — オプション。`haystack`内で検索を開始する位置(1始まり)。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は1から数えたバイト単位の開始位置を返し、見つからなかった場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字と小文字を区別しない検索**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```


## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

導入バージョン: v1.1

[`positionUTF8`](#positionUTF8)と同様ですが、大文字小文字を区別せずに検索します。

**構文**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)または[`Enum`](/sql-reference/data-types/enum)
- `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
- `start_pos` — オプション。検索を開始する`haystack`内の位置(1始まり)。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は1から数えたバイト単位の開始位置を返し、見つからなかった場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しないUTF-8検索**

```sql title=クエリ
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=レスポンス
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```


## positionUTF8 {#positionUTF8}

導入バージョン: v1.1

[`position`](#position)と同様ですが、`haystack`と`needle`がUTF-8エンコードされた文字列であることを前提とします。

**構文**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**引数**

- `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)または[`Enum`](/sql-reference/data-types/enum)
- `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
- `start_pos` — オプション。検索を開始する`haystack`内の位置(1始まり)。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

部分文字列が見つかった場合は1から数えたバイト単位の開始位置を返し、見つからなかった場合は`0`を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**UTF-8文字のカウント**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

<!--AUTOGENERATED_END-->

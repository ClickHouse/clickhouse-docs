---
description: '文字列検索関数に関するドキュメント'
sidebar_label: '文字列検索'
slug: /sql-reference/functions/string-search-functions
title: '文字列検索関数'
doc_type: 'reference'
---

# 文字列検索用の関数 \{#functions-for-searching-in-strings\}

このセクションのすべての関数は、デフォルトでは大文字・小文字を区別して検索します。大文字・小文字を区別しない検索は、通常は別の関数バリアントとして提供されます。

:::note
大文字・小文字を区別しない検索では、英語の小文字・大文字の規則に従います。たとえば、英語では小文字の `i` の大文字は `I` ですが、トルコ語では `İ` になります。そのため、英語以外の言語では期待と異なる結果になる場合があります。
:::

このセクションの関数は、検索対象の文字列（このセクションでは `haystack` と呼ぶ）と検索文字列（`needle` と呼ぶ）が、1 バイトでエンコードされたテキストであることも前提としています。この前提が満たされない場合でも、例外はスローされず、結果は未定義です。UTF-8 エンコードされた文字列での検索は、通常は別の関数バリアントとして提供されます。同様に、UTF-8 用の関数バリアントを使用している場合に、入力文字列が UTF-8 エンコードされたテキストでなくても、例外はスローされず、結果は未定義です。自動的な Unicode 正規化は行われませんが、必要に応じて
[normalizeUTF8*()](/sql-reference/functions/string-functions#normalizeUTF8NFC) 関数を使用できます。

[一般的な文字列関数](string-functions.md)と[文字列置換用の関数](string-replace-functions.md)については別途説明します。

:::note
以下のドキュメントは、`system.functions` システムテーブルから生成されています。
:::

{/* 
  以下のタグ内の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントに置き換えられます。タグを変更または削除しないでください。
  詳細については https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{/*AUTOGENERATED_START*/ }


## countMatches \{#countMatches\}

導入バージョン: v21.1

文字列中の正規表現のマッチ数を返します。

:::note バージョン依存の動作
この関数の動作は ClickHouse のバージョンに依存します:

* v25.6 より前のバージョンでは、パターンが空文字にマッチする場合でも、最初の空マッチが発生した時点でカウントを停止します。
* v25.6 以降のバージョンでは、空マッチが発生しても処理を継続します。レガシーな動作は、設定 `count_matches_stop_at_empty_match = true` を使用することで復元できます。
  :::

**構文**

```sql
countMatches(haystack, pattern)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`String`](/sql-reference/data-types/string)

**返される値**

一致した件数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**数字列のカウント**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```


## countMatchesCaseInsensitive \{#countMatchesCaseInsensitive\}

導入されたバージョン: v21.1

[`countMatches`](#countMatches) と同様ですが、大文字小文字を区別せずにマッチングを行います。

**構文**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`const String`](/sql-reference/data-types/string)

**戻り値**

見つかった一致の数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字と小文字を区別しないカウント**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```


## countSubstrings \{#countSubstrings\}

導入バージョン: v21.1

部分文字列 `needle` が文字列 `haystack` 内に出現する回数を返します。

**構文**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索対象の文字列。[String](../../sql-reference/data-types/string.md) または [Enum](../../sql-reference/data-types/enum.md)。 - `needle` — 検索する部分文字列。[String](../../sql-reference/data-types/string.md)。 - `start_pos` — 検索を開始する `haystack` 内の位置（1始まり）。[UInt](../../sql-reference/data-types/int-uint.md)。省略可能。

**返される値**

出現回数。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**start&#95;pos 引数ありの場合**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```


## countSubstringsCaseInsensitive \{#countSubstringsCaseInsensitive\}

導入バージョン: v21.1

[`countSubstrings`](#countSubstrings) と同様ですが、大文字・小文字を区別せずにカウントします。

**構文**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1 始まりのインデックス）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

`haystack` 内における `needle` の出現回数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**start&#95;pos 引数付き**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```


## countSubstringsCaseInsensitiveUTF8 \{#countSubstringsCaseInsensitiveUTF8\}

導入バージョン: v21.1

[`countSubstrings`](#countSubstrings) と同様ですが、大文字と小文字を区別せずにカウントし、haystack 文字列が UTF-8 であると仮定します。

**構文**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1 始まりのインデックス）。[`UInt*`](/sql-reference/data-types/int-uint)

**返される値**

`haystack` 内で `needle` が出現する回数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**start&#95;pos 引数付き**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```


## extract \{#extract\}

導入バージョン: v1.1

文字列から、正規表現に最初にマッチした部分文字列を抽出します。
もし &#39;haystack&#39; が &#39;pattern&#39; にマッチしない場合は、空文字列が返されます。

この関数は RE2 正規表現ライブラリを使用します。サポートされている構文については [re2](https://github.com/google/re2/wiki/Syntax) を参照してください。

正規表現にキャプチャグループ（サブパターン）が含まれている場合、この関数は入力文字列を最初のキャプチャグループに対して照合します。

**構文**

```sql
extract(haystack, pattern)
```

**引数**

* `haystack` — 抽出元の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 通常はキャプチャグループを含む正規表現。[`const String`](/sql-reference/data-types/string)

**戻り値**

抽出された部分文字列を文字列として返します。[`String`](/sql-reference/data-types/string)

**例**

**メールアドレスからドメインを抽出**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**一致しない場合は空文字列を返す**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```


## extractAll \{#extractAll\}

導入バージョン: v1.1

[`extract`](#extract) と同様ですが、文字列内で正規表現に一致するすべての箇所を配列として返します。
&#39;haystack&#39; が &#39;pattern&#39; の正規表現に一致しない場合は、空の配列が返されます。

正規表現にキャプチャグループ（サブパターン）が含まれている場合、この関数は入力文字列に対して最初のキャプチャグループを基準にマッチングを行います。

**構文**

```sql
extractAll(haystack, pattern)
```

**引数**

* `haystack` — フラグメント（部分文字列）を抽出する元の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 任意でキャプチャグループを含む正規表現。[`const String`](/sql-reference/data-types/string)

**返される値**

抽出されたフラグメントの配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**すべての数値を抽出する**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**キャプチャグループを使って抽出**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```


## extractAllGroupsHorizontal \{#extractAllGroupsHorizontal\}

導入バージョン: v20.5

指定した正規表現で文字列を検索し、一致したすべてのグループを配列の配列として返します。各配列には、同じキャプチャグループのすべてのキャプチャがグループ番号ごとに整理されて格納されます。

**構文**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**引数**

* `s` — 抽出対象の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 一致判定に用いる正規表現。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)

**返される値**

配列の配列を返します。各内側の配列には、1 つのキャプチャグループに対応する、すべてのマッチからのキャプチャが含まれます。最初の内側の配列にはグループ 1 からのすべてのキャプチャ、2 番目にはグループ 2 からのすべてのキャプチャ、というように続きます。マッチが見つからない場合は空配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```


## extractGroups \{#extractGroups\}

導入バージョン: v20.5

正規表現にマッチする互いに重ならない部分文字列から、すべてのキャプチャグループを抽出します。

**構文**

```sql
extractAllGroups(s, regexp)
```

**引数**

* `s` — 抽出対象の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 正規表現。定数。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)

**返り値**

関数が少なくとも 1 つのマッチンググループを見つけた場合、group&#95;id ごとにまとめられた Array(Array(String)) カラムを返します（`1` から `N`。ここで `N` は regexp 内のキャプチャグループ数）。マッチンググループがない場合は空の配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```


## hasAllTokens \{#hasAllTokens\}

導入: v25.10

[`hasAnyTokens`](#hasAnyTokens)と同様ですが、`needle`文字列または配列内のすべてのトークンが`input`文字列と一致する場合は1を返し、それ以外の場合は0を返します。`input`がカラムの場合、この条件を満たすすべての行を返します。

:::note
最適なパフォーマンスを得るには、カラム `input` に[テキスト索引](../../engines/table-engines/mergetree-family/textindexes)を定義しておく必要があります。
テキスト索引が定義されていない場合、この関数はブルートフォースによるカラムスキャンを実行するため、索引検索と比較して桁違いに遅くなります。
:::

検索前に、関数はトークン化を実行します

* 常に `input` 引数と
* `needle` 引数が [String](../../sql-reference/data-types/string.md) 型で指定されている場合は、
  テキストインデックスに対して定義されているトークナイザーを使用して処理されます。
  カラムにテキストインデックスが定義されていない場合は、代わりに `splitByNonAlpha` トークナイザーが使用されます。
  `needle` 引数が [Array(String)](../../sql-reference/data-types/array.md) 型の場合、配列の各要素はトークンとして扱われ、追加のトークナイズ処理は行われません。

重複するトークンは無視されます。
例えば、needles = [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] は [&#39;ClickHouse&#39;] と同様に扱われます。

**構文**

```sql
hasAllTokens(input, needles)
```

**別名**: `hasAllToken`

**引数**

* `input` — 入力カラム。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Array(String)`](/sql-reference/data-types/array) または [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — 検索するトークン。最大 64 個まで指定できます。[`String`](/sql-reference/data-types/string) または [`Array(String)`](/sql-reference/data-types/array)

**返り値**

すべてのneedleが一致する場合は1を返します。それ以外の場合は0を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**文字列カラムの使用例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**検索する文字列をそのまま（トークン化なし）配列で指定する**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**`tokens`関数を使用して検索対象を生成する**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**配列およびマップカラムの使用例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**配列カラムの例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeysの使用例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapValues使用例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```


## hasAnyTokens \{#hasAnyTokens\}

導入バージョン: v25.10

`needle` 文字列または配列内のトークンのうち少なくとも 1 つが `input` 文字列にマッチする場合は 1 を返し、それ以外の場合は 0 を返します。`input` がカラムの場合、この条件を満たすすべての行を返します。

:::note
最適なパフォーマンスを得るために、カラム `input` には [text index](../../engines/table-engines/mergetree-family/textindexes) が定義されている必要があります。
text index が定義されていない場合、関数はインデックス検索よりも桁違いに遅い総当たりのカラム走査を行います。
:::

検索を行う前に、この関数は次をトークン化します。

* `input` 引数（常に）
* `needle` 引数（[String](../../sql-reference/data-types/string.md) として与えられた場合）

これらのトークン化には、text index に対して指定された tokenizer を使用します。
カラムに text index が定義されていない場合は、代わりに `splitByNonAlpha` tokenizer が使用されます。
`needle` 引数が [Array(String)](../../sql-reference/data-types/array.md) 型の場合、各配列要素はトークンとして扱われ、追加のトークン化は行われません。

重複するトークンは無視されます。
たとえば、[&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] は [&#39;ClickHouse&#39;] と同じように扱われます。

**構文**

```sql
hasAnyTokens(input, needles)
```

**別名**: `hasAnyToken`

**引数**

* `input` — 入力カラム。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Array(String)`](/sql-reference/data-types/array) または [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — 検索するトークン。最大 64 個のトークンを指定できます。[`String`](/sql-reference/data-types/string) または [`Array(String)`](/sql-reference/data-types/array)

**返される値**

少なくとも 1 件の一致が見つかった場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**文字列カラムでの使用例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**検索する文字列（トークン化せず AS-IS のまま）を配列で指定します**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**`tokens` 関数で needle を生成する**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**配列カラムおよびマップカラムの使用例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**配列カラムの例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys を使った例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**mapValues を使った例**


```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```


## hasSubsequence \{#hasSubsequence\}

導入バージョン: v23.7

文字列 `haystack` の中に、文字列 `needle` が部分列として含まれているかを判定します。
文字列の部分列とは、残りの文字の順序を変えずに、いくつか、またはいっさいの文字を削除することで別の文字列から得られる文字列の並びを指します。

**構文**

```sql
hasSubsequence(haystack, needle)
```

**引数**

* `haystack` — 部分文字列を検索する対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`needle` が `haystack` の部分文字列であれば `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的な部分文字列チェック**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**部分文字列は見つかりません**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```


## hasSubsequenceCaseInsensitive \{#hasSubsequenceCaseInsensitive\}

導入バージョン: v23.7

[`hasSubsequence`](#hasSubsequence) と同様ですが、検索時に大文字と小文字を区別しません。

**構文**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 検索を行う対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)

**返される値**

`needle` が `haystack` の部分文字列であれば 1、それ以外の場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```


## hasSubsequenceCaseInsensitiveUTF8 \{#hasSubsequenceCaseInsensitiveUTF8\}

導入バージョン: v23.7

[`hasSubsequenceUTF8`](#hasSubsequenceUTF8) と同様ですが、大文字と小文字を区別せずに検索します。

**構文**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 検索を行う UTF-8 エンコードされた文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 エンコードされた部分列。[`String`](/sql-reference/data-types/string)

**返される値**

`needle` が `haystack` の部分列である場合は 1 を返し、それ以外の場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```


## hasSubsequenceUTF8 \{#hasSubsequenceUTF8\}

導入バージョン: v23.7

[`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence) と同様の関数ですが、`haystack` と `needle` が UTF-8 でエンコードされた文字列であることを前提とします。

**構文**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)

**返される値**

`needle` が `haystack` の部分文字列であれば `1`、そうでなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**一致しない部分列**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```


## hasToken \{#hasToken\}

導入されたバージョン: v20.1

指定したトークンが検索対象文字列（haystack）内に存在するかを確認します。

[tokenizer] として [splitByNonAlpha](/sql-reference/functions/splitting-merging-functions.md/#splitByNonAlpha) を使用します。つまり、トークンは連続した文字 `[0-9A-Za-z_]`（つまり、数字、ASCII 英字、アンダースコア）からなる、可能な限り長い部分列として定義されます。

**構文**

```sql
hasToken(haystack, token)
```

**引数**

* `haystack` — トークンを検索する対象の文字列。[`String`](/sql-reference/data-types/string)
* `token` — 検索するトークン。[`const String`](/sql-reference/data-types/string)

**戻り値**

トークンが見つかった場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**トークン検索**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```


## hasTokenCaseInsensitive \{#hasTokenCaseInsensitive\}

導入バージョン: v

`tokenbf&#95;v1` 索引を使用して、haystack 内の needle を大文字小文字を区別せずに検索します。

**構文**

```sql
```

**引数**

* なし。

**戻り値**

**例**


## hasTokenCaseInsensitiveOrNull \{#hasTokenCaseInsensitiveOrNull\}

導入バージョン: v

`tokenbf_v1` 索引を用いて、`haystack` 内で `needle` を大文字小文字を区別せずに検索します。`needle` が不正な形式の場合は null を返します。

**構文**

```sql
```

**引数**

* なし

**戻り値**

**例**


## hasTokenOrNull \{#hasTokenOrNull\}

導入バージョン: v20.1

[`hasToken`](#hasToken) と同様ですが、トークンの形式が不正な場合は null を返します。

**構文**

```sql
hasTokenOrNull(haystack, token)
```

**引数**

* `haystack` — 検索対象の文字列。定数である必要があります。[`String`](/sql-reference/data-types/string)
* `token` — 検索するトークン。[`const String`](/sql-reference/data-types/string)

**返される値**

トークンが見つかった場合は `1`、見つからない場合は `0`、トークンの形式が不正な場合は NULL を返します。[`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**例**

**使用例**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```


## ilike \{#ilike\}

導入バージョン: v20.6

[`like`](#like) と同様ですが、大文字と小文字を区別しない検索を行います。

**構文**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合に使用する LIKE パターン。[`String`](/sql-reference/data-types/string)

**返される値**

文字列が LIKE パターンに一致する場合は `1` を返し（一致判定は大文字小文字を区別しません）、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```


## like \{#like\}

導入バージョン: v1.1

文字列 `haystack` が `LIKE` 式 `pattern` にマッチするかどうかを返します。

`LIKE` 式には通常の文字に加えて、次のメタ記号を含めることができます：

* `%` は任意の数の任意の文字（0 文字も含む）を表します。
* `_` は 1 文字の任意の文字を表します。
* `\` はリテラルの `%`、`_`、`\` をエスケープするために使用します。

マッチングは UTF-8 に基づきます。例えば `_` は、UTF-8 で 2 バイトで表現される Unicode コードポイント `¥` にマッチします。

`haystack` または `LIKE` 式が有効な UTF-8 でない場合、動作は未定義です。

Unicode 正規化は自動では実行されません。そのためには `normalizeUTF8*` 関数群を使用できます。

リテラルの `%`、`_`、`\`（これらは `LIKE` のメタ文字です）にマッチさせるには、先頭にバックスラッシュを付けて `\%`、`\_`、`\\` のように記述します。
バックスラッシュが `%`、`_`、`\` 以外の文字の前に付く場合、その特別な意味を失い（すなわちリテラルとして解釈され）ます。

:::note
ClickHouse では文字列中のバックスラッシュも[クオートする必要がある](../syntax.md#string)ため、実際には `\\%`、`\\_`、`\\\\` のように記述する必要があります。
:::

`%needle%` 形式の `LIKE` 式に対しては、この関数は `position` 関数と同等の速度で動作します。
それ以外の `LIKE` 式は内部的に正規表現に変換され、`match` 関数と同程度のパフォーマンスで実行されます。

**構文**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合対象の `LIKE` パターン。`%`（任意個の文字に一致）、`_`（任意の1文字に一致）、およびエスケープ用の `\` を含めることができます。[`String`](/sql-reference/data-types/string)

**返される値**

文字列が `LIKE` パターンに一致する場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**1文字ワイルドカード**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**マッチしないパターン**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```


## locate \{#locate\}

導入バージョン: v18.16

[`position`](#position) と同様ですが、引数 `haystack` と `needle` の順序が入れ替わっています。

:::note Version dependent behavior
この関数の動作は ClickHouse のバージョンに依存します。

* v24.3 未満のバージョンでは、`locate` は関数 `position` のエイリアスであり、引数 `(haystack, needle[, start_pos])` を受け付けます。
* v24.3 以上のバージョンでは、`locate` は個別の関数（MySQL との互換性向上のため）であり、引数 `(needle, haystack[, start_pos])` を受け付けます。
  以前の動作は、設定 `function_locate_has_mysql_compatible_argument_order = false` を用いることで復元できます。
  :::

**構文**

```sql
locate(needle, haystack[, start_pos])
```

**引数**

* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `haystack` — 検索を行う対象の文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置 (1 始まり)。[`UInt`](/sql-reference/data-types/int-uint)

**返される値**

部分文字列が見つかった場合は、バイト単位で 1 から数えた開始位置を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な使い方**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```


## match \{#match\}

導入バージョン: v1.1

指定された文字列が、指定された正規表現パターンにマッチするかどうかをチェックします。

この関数は RE2 正規表現ライブラリを使用します。サポートされている構文については [re2](https://github.com/google/re2/wiki/Syntax) を参照してください。

マッチングは UTF-8 を前提として動作します。たとえば `¥` は内部的には 2 バイトを使用しますが、マッチングでは 1 つのコードポイントとして扱われます。
正規表現には NULL バイトを含めてはいけません。
`haystack` またはパターンが有効な UTF-8 でない場合の動作は未定義です。

re2 のデフォルト動作とは異なり、`.` は改行にもマッチします。これを無効にするには、パターンの先頭に `(?-s)` を付けてください。

パターンは両端で自動的にアンカーされます（パターンが先頭に &#39;^&#39;、末尾に &#39;$&#39; が付いているかのように扱われます）。

部分文字列だけを検索したい場合は、代わりに関数 [`like`](#like) または [`position`](#position) を使用できます。これらはこの関数よりもはるかに高速に動作します。

代替の演算子構文: `haystack REGEXP pattern`。

**構文**

```sql
match(haystack, pattern)
```

**エイリアス**: `REGEXP_MATCHES`

**引数**

* `haystack` — パターンを検索する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`const String`](/sql-reference/data-types/string)

**戻り値**

パターンがマッチした場合は `1`、それ以外は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的なパターンマッチング**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**パターンが一致しない場合**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```


## multiFuzzyMatchAllIndices \{#multiFuzzyMatchAllIndices\}

導入バージョン: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny) と同様ですが、一定の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)内で `haystack` にマッチするすべてのインデックスを、順不同の配列として返します。

**構文**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**引数**

* `haystack` — 検索を行う対象の文字列。[`String`](/sql-reference/data-types/string)
* `distance` — あいまい一致に用いる最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 照合対象となるパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

指定した編集距離以内で `haystack` にマッチするすべてのインデックス（1 から始まる）を、順序は問わずに含む配列を返します。一致が見つからない場合は空配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```


## multiFuzzyMatchAny \{#multiFuzzyMatchAny\}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と似ていますが、任意のパターンが一定の [編集距離](https://en.wikipedia.org/wiki/Edit_distance) 以内で対象文字列（haystack）にマッチした場合に 1 を返します。
この関数は [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) ライブラリの実験的機能に依存しており、一部のケースでは低速になる可能性があります。
パフォーマンスは編集距離の値と使用するパターンに依存しますが、常に非ファジーなバリアントよりもコストが高くなります。

:::note
`multiFuzzyMatch*()` 関数群は、hyperscan の制約により UTF-8 の正規表現をサポートしません（UTF-8 文字列としてではなくバイト列として扱われます）。
:::

**構文**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `distance` — あいまい検索における最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — オプション。マッチさせるパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

指定した編集距離以内でいずれかのパターンが haystack にマッチした場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```


## multiFuzzyMatchAnyIndex \{#multiFuzzyMatchAnyIndex\}

導入: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny) と同様ですが、一定の [編集距離](https://en.wikipedia.org/wiki/Edit_distance) 内で検索対象文字列にマッチするいずれかのインデックスを返します。

**構文**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `distance` — あいまい一致における最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 照合するパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

指定された編集距離以内で `haystack` に一致するパターンのインデックス（1 起算）を返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```


## multiMatchAllIndices \{#multiMatchAllIndices\}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と似ていますが、haystack 内でマッチしたすべてのインデックスを順不同の配列として返します。

**構文**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 照合に使用する正規表現パターン。[`String`](/sql-reference/data-types/string)

**返される値**

`haystack` にマッチしたパターンのインデックス（1 起算）を、順不同ですべて含む配列。マッチが見つからない場合は空配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```


## multiMatchAny \{#multiMatchAny\}

導入バージョン: v20.1

複数の正規表現パターンのうち、少なくとも 1 つが対象文字列（haystack）にマッチするかどうかを判定します。

文字列内で複数の部分文字列を検索したいだけの場合は、代わりに関数 [`multiSearchAny`](#multiSearchAny) を使用できます。`multiMatchAny` よりもはるかに高速に動作します。

**構文**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**引数**

* `haystack` — パターンを検索する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern1[, pattern2, ...]` — 1つ以上の正規表現パターンからなる配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

いずれかのパターンにマッチした場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**複数パターンのマッチ**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**一致するパターンはありません**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```


## multiMatchAnyIndex \{#multiMatchAnyIndex\}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と同様ですが、`haystack` にマッチしたインデックスのいずれかを返します。

**構文**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索を実行する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 検索に使用する正規表現。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

最初にマッチしたパターンのインデックス（1 起算）を返し、マッチが見つからない場合は 0 を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```


## multiSearchAllPositions \{#multiSearchAllPositions\}

導入バージョン: v20.1

[`position`](#position) と同様ですが、`haystack` 文字列内で複数の `needle` 部分文字列が出現する位置（バイト単位、1 始まり）の配列を返します。

すべての `multiSearch*()` 関数は、最大 2^8 個の `needle` のみをサポートします。

**構文**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を行う対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象とする 1 つ以上の部分文字列からなる配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

部分文字列が見つかった場合は、1 から数えたバイト単位の開始位置を、見つからなかった場合は `0` を要素として持つ配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**複数 needle の検索**

```sql title=Query
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```


## multiSearchAllPositionsCaseInsensitive \{#multiSearchAllPositionsCaseInsensitive\}

導入バージョン: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions) と同様ですが、大文字小文字を区別しません。

**構文**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる 1 つ以上の部分文字列からなる配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

部分文字列が見つかった場合は、バイト単位で 1 から数えた開始位置を返し、見つからなかった場合は `0` を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**大文字小文字を区別しないマルチ検索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```


## multiSearchAllPositionsCaseInsensitiveUTF8 \{#multiSearchAllPositionsCaseInsensitiveUTF8\}

導入バージョン: v20.1

[`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を行う対象の UTF-8 エンコードされた文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する UTF-8 エンコードされた部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

部分文字列が見つかった場合、その開始位置をバイト単位かつ 1 起算で格納した配列。見つからなかった場合は 0 を返します。[`Array`](/sql-reference/data-types/array)

**例**

**大文字・小文字を区別しない UTF-8 検索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```


## multiSearchAllPositionsUTF8 \{#multiSearchAllPositionsUTF8\}

導入バージョン: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions) と同様ですが、`haystack` および `needle` の部分文字列が UTF-8 でエンコードされている文字列であると仮定します。

**構文**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を行う UTF-8 エンコードされた文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる UTF-8 エンコードされた部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

見つかった部分文字列について、バイト単位で、1 から数えた開始位置を要素とする配列を返します。部分文字列が見つからなかった場合、その要素は `0` になります。[`Array`](/sql-reference/data-types/array)

**使用例**

**UTF-8 マルチ検索**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```


## multiSearchAny \{#multiSearchAny\}

導入バージョン: v20.1

複数の検索文字列（needle）のうち少なくとも 1 つが、対象文字列（haystack）にマッチするかどうかを判定します。

関数 [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive)、[`multiSearchAnyUTF8`](#multiSearchAnyUTF8)、[`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) は、この関数の大文字小文字を区別しないものや UTF-8 に対応したものなどのバリアントを提供します。

**構文**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象とする部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

少なくとも 1 件一致があれば `1` を返し、一致が 1 件もなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**いずれかに一致するかの検索**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```


## multiSearchAnyCaseInsensitive \{#multiSearchAnyCaseInsensitive\}

導入バージョン: v20.1

[multiSearchAny](#multiSearchAny) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

大文字小文字を区別しない一致が少なくとも 1 件あれば `1` を返し、一致が 1 件もない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない検索**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```


## multiSearchAnyCaseInsensitiveUTF8 \{#multiSearchAnyCaseInsensitiveUTF8\}

導入バージョン: v20.1

[multiSearchAnyUTF8](#multiSearchAnyUTF8) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を行う UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象とする UTF-8 の部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

少なくとも 1 件でも大文字小文字を区別しない一致があれば `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**UTF-8 文字列 &#39;Здравствуйте&#39; に対して、小文字の文字 &#39;з&#39; が含まれているかを確認する**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchAnyUTF8 \{#multiSearchAnyUTF8\}

導入バージョン: v20.1

[multiSearchAny](#multiSearchAny) と同様ですが、`haystack` および `needle` の部分文字列が UTF-8 エンコードされた文字列であることを前提とします。

**構文**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象の UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

1 件以上の一致があれば `1` を返し、一致が 1 件もなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**UTF-8 文字列 &#39;你好，世界&#39;（&#39;Hello, world&#39;）について、文字列中に 你 または 界 の文字が 1 つでも含まれているかを確認する**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstIndex \{#multiSearchFirstIndex\}

導入バージョン: v20.1

複数の needle 文字列を haystack 文字列内で検索し（大文字と小文字を区別）、最初に見つかった needle のインデックス（1 始まり）を返します。

**構文**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needles` — 検索する文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

`haystack` 内で最初に見つかった文字列について、その文字列が `needles` 配列内で占める 1 から始まるインデックス（位置）を返します。いずれの文字列も見つからない場合は 0 を返します。検索は大文字と小文字を区別します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**大文字小文字を区別する場合の挙動**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**一致が見つかりません**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```


## multiSearchFirstIndexCaseInsensitive \{#multiSearchFirstIndexCaseInsensitive\}

導入バージョン: v20.1

文字列 `haystack` の中で最も左側に見つかった needle&#95;i のインデックス `i`（1 から開始）を返し、見つからない場合は 0 を返します。
大文字と小文字を区別しません。

**構文**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最も左側（先頭側）で見つかった needle のインデックス（1 から始まる）を返します。一致がない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstIndexCaseInsensitiveUTF8 \{#multiSearchFirstIndexCaseInsensitiveUTF8\}

導入バージョン: v20.1

UTF-8 エンコーディングに対応した大文字・小文字を区別しない検索で、`haystack` 文字列の中から複数の `needle` 文字列を探し、最初に見つかった `needle` の 1 から始まるインデックスを返します。

**構文**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needles` — 検索する文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

`haystack` 内で最初に見つかった `needle` の、1 始まりのインデックス値（`needles` 配列内での位置）を返します。どれも見つからない場合は 0 を返します。検索は大文字小文字を区別せず、UTF-8 文字エンコーディングに対応します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8 における大文字・小文字の扱い**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**一致するものが見つかりません**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```


## multiSearchFirstIndexUTF8 \{#multiSearchFirstIndexUTF8\}

導入バージョン: v20.1

文字列 `haystack` の中で最も左側で見つかった needle&#95;i のインデックス `i`（1 から数え始める）を返し、見つからなかった場合は 0 を返します。
`haystack` と `needle` は UTF-8 でエンコードされた文字列であると仮定します。

**構文**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索が行われる UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最も左側で見つかった `needle` のインデックス（1 から始まる）を返します。マッチがない場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```


## multiSearchFirstPosition \{#multiSearchFirstPosition\}

導入バージョン: v20.1

[`position`](#position) と同様ですが、複数の `needle` 文字列のいずれかに一致する `haystack` 文字列内の、最も左側のオフセットを返します。

関数 [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive)、[`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8)、[`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) は、この関数の大文字小文字を区別しない版および/または UTF-8 対応版を提供します。

**構文**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる 1 つ以上の部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

複数の `needle` 文字列のいずれかに一致する `haystack` 文字列内の最も左側のオフセットを返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**先頭位置の検索**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionCaseInsensitive \{#multiSearchFirstPositionCaseInsensitive\}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、大文字・小文字を区別しません。

**構文**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

複数の `needle` 文字列のいずれかに一致する `haystack` 文字列内の最も左端のオフセットを返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない先頭位置**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionCaseInsensitiveUTF8 \{#multiSearchFirstPositionCaseInsensitiveUTF8\}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、`haystack` と `needle` を UTF-8 文字列として扱い、大文字・小文字を区別しません。

**構文**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

大文字小文字を区別せずに複数の `needle` 文字列のいずれかに一致する、`haystack` 文字列内の最も左側のオフセットを返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**与えられた needle のいずれかに一致する UTF-8 文字列 &#39;Здравствуй, мир&#39;（&#39;Hello, world&#39;）内の最も左側のオフセットを検索します。**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```


## multiSearchFirstPositionUTF8 \{#multiSearchFirstPositionUTF8\}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、`haystack` と `needle` が UTF-8 でエンコードされた文字列であると仮定します。

**構文**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の `needle` 文字列のいずれかに一致する、`haystack` 文字列内の最も左端のオフセット。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**与えられたいずれかの needle に一致する、UTF-8 文字列「Здравствуй, мир」（&quot;Hello, world&quot;）内の最も左端のオフセットを検索します**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```


## ngramDistance \{#ngramDistance\}

導入バージョン: v20.1

2 つの文字列間の 4-gram 距離を計算します。
そのために、2 つの 4-gram のマルチセット間の対称差をカウントし、それをそれぞれの基数の合計で正規化します。
返される値が小さいほど、文字列同士がより類似していることを示します。

大文字小文字を区別しない検索や UTF-8 形式での使用には、[`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive)、[`ngramDistanceUTF8`](#ngramDistanceUTF8)、[`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8) 関数を使用します。

**構文**

```sql
ngramDistance(haystack, needle)
```

**引数**

* `haystack` — 比較対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較対象の文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`0` から `1` の間の Float32 型の数値を返します。返される値が小さいほど、文字列同士の類似度が高くなります。[`Float32`](/sql-reference/data-types/float)

**使用例**

**4-gram 距離の計算**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```


## ngramDistanceCaseInsensitive \{#ngramDistanceCaseInsensitive\}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の大文字小文字を区別しないバリアントを提供します。
2つの文字列の 4-グラム距離を、大文字小文字を無視して計算します。
返される値が小さいほど、文字列同士の類似度が高くなります。

**構文**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 1 番目の比較文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 2 番目の比較文字列。[`String`](/sql-reference/data-types/string)

**返り値**

`0` から `1` の間の Float32 型の数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**大文字小文字を区別しない 4-gram 距離**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```


## ngramDistanceCaseInsensitiveUTF8 \{#ngramDistanceCaseInsensitiveUTF8\}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の大文字小文字を区別しない UTF-8 版を提供します。
`needle` と `haystack` の文字列が UTF-8 でエンコードされた文字列であると仮定し、大文字小文字を無視します。
2 つの UTF-8 文字列間の 3-gram 距離を、大文字小文字を無視して計算します。
戻り値が小さいほど、文字列同士の類似度が高くなります。

**構文**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 1 番目の UTF-8 エンコードされた比較用文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 2 番目の UTF-8 エンコードされた比較用文字列。[`String`](/sql-reference/data-types/string)

**返り値**

`0` から `1` の間の Float32 型の値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**大文字と小文字を区別しない UTF-8 3-グラム距離**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```


## ngramDistanceUTF8 \{#ngramDistanceUTF8\}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の UTF-8 版を提供します。
`needle` と `haystack` の文字列が UTF-8 でエンコードされていることを前提とします。
2 つの UTF-8 文字列間の 3-グラム距離を計算します。
返される値が小さいほど、文字列同士の類似度が高くなります。

**構文**

```sql
ngramDistanceUTF8(haystack, needle)
```

**引数**

* `haystack` — 1 番目の UTF-8 でエンコードされた比較用文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 2 番目の UTF-8 でエンコードされた比較用文字列。[`String`](/sql-reference/data-types/string)

**返り値**

`0` から `1` の間の Float32 型の数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**UTF-8 3-グラム距離**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```


## ngramSearch \{#ngramSearch\}

導入バージョン: v20.1

2 つの文字列間の 4-gram 距離が、指定されたしきい値以下かどうかを判定します。

大文字小文字を区別しない検索や UTF-8 形式での検索を行う場合は、`ngramSearchCaseInsensitive`、`ngramSearchUTF8`、`ngramSearchCaseInsensitiveUTF8` 関数を使用します。

**構文**

```sql
ngramSearch(haystack, needle)
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する文字列。[`String`](/sql-reference/data-types/string)

**返される値**

文字列間の 4-gram 距離がしきい値（デフォルトでは `1.0`）以下の場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**4-gram を使用した検索**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```


## ngramSearchCaseInsensitive \{#ngramSearchCaseInsensitive\}

導入バージョン: v20.1

[`ngramSearch`](#ngramSearch) の大文字・小文字を区別しないバリアントを提供します。
needle 文字列と haystack 文字列の非対称差を計算します。すなわち、needle の n-gram の個数から共通の n-gram の個数を引いたものを、needle の n-gram の個数で正規化した値です。
2つの文字列の 4-gram 距離が、指定されたしきい値以下かどうかを、大文字・小文字を無視して判定します。

**構文**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 比較対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較対象となる文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の 4-グラム距離が閾値（デフォルトでは `1.0`）以下の場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**4-グラムを使用した大文字小文字を区別しない検索**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```


## ngramSearchCaseInsensitiveUTF8 \{#ngramSearchCaseInsensitiveUTF8\}

導入バージョン: v20.1

[`ngramSearch`](#ngramSearch) の大文字・小文字を区別しない UTF-8 版を提供します。
`haystack` と `needle` が UTF-8 文字列であると仮定し、大文字・小文字を無視します。
2 つの UTF-8 文字列間の 3-gram 距離が、指定されたしきい値以下かどうかを、大文字・小文字を無視して判定します。

**構文**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 比較に使用する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較に使用する UTF-8 文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の 3-gram 距離がしきい値（デフォルトは `1.0`）以下の場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**3-gram を用いた大文字小文字を区別しない UTF-8 検索**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```


## ngramSearchUTF8 \{#ngramSearchUTF8\}

導入バージョン: v20.1

`ngramSearch` の UTF-8 版です。
`haystack` と `needle` が UTF-8 文字列であることを前提とします。
2 つの UTF-8 文字列間の 3-gram 距離が、指定されたしきい値以下かどうかをチェックします。

**構文**

```sql
ngramSearchUTF8(haystack, needle)
```

**引数**

* `haystack` — 比較対象の UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較対象の UTF-8 文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の 3-gram 距離が閾値（デフォルトでは `1.0`）以下の場合は `1` を、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**3-gram を用いた UTF-8 検索**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```


## notILike \{#notILike\}

導入バージョン: v20.6

文字列がパターンに一致しないかどうかを、大文字小文字を区別せずにチェックします。パターンには、SQL の LIKE マッチング用の特殊文字 `%` と `_` を含めることができます。

**構文**

```sql
notILike(haystack, pattern)
```

**引数**

* `haystack` — 検索対象となる入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — SQL の LIKE 演算子で使用するパターン。`%` は任意の長さの文字列（長さ 0 を含む）にマッチし、`_` は任意の 1 文字にマッチします。[`String`](/sql-reference/data-types/string)

**返り値**

文字列がパターンにマッチしない場合は `1` を返し（大文字小文字を区別せずに比較）、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```


## notLike \{#notLike\}

導入バージョン: v1.1

[`like`](#like) と同様ですが、結果を否定します。

**構文**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**引数**

* `haystack` — 検索を実行する検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合に使用する LIKE パターン。[`String`](/sql-reference/data-types/string)

**返される値**

文字列が LIKE パターンに一致しない場合は `1`、一致する場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**マッチしないパターン**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```


## position \{#position\}

導入バージョン: v1.1

文字列 `haystack` 内で、部分文字列 `needle` が出現する位置（バイト単位、1 始まり）を返します。

部分文字列 `needle` が空文字の場合、次のルールが適用されます:

* `start_pos` が指定されていない場合: `1` を返す
* `start_pos = 0` の場合: `1` を返す
* `start_pos >= 1` かつ `start_pos <= length(haystack) + 1` の場合: `start_pos` を返す
* それ以外の場合: `0` を返す

同じルールは、関数 [`locate`](#locate)、[`positionCaseInsensitive`](#positionCaseInsensitive)、[`positionUTF8`](#positionUTF8)、[`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8) にも適用されます。

**構文**

```sql
position(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 検索を開始する `haystack` 内の位置 (1 起算)。省略可能。[`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、バイト単位の開始位置 (1 起算) を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**使用例**

**基本的な使い方**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**start&#95;pos 引数を指定する場合**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**「Needle IN haystack」構文**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**空の検索文字列**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```


## positionCaseInsensitive \{#positionCaseInsensitive\}

導入バージョン: v1.1

[`position`](#position) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**別名**: `instr`

**引数**

* `haystack` — 検索対象の文字列。 [`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。 [`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可。検索を開始する `haystack` 内の位置（1始まり）。 [`UInt*`](/sql-reference/data-types/int-uint)

**返される値**

部分文字列が見つかった場合は、その開始位置をバイト単位で 1 から数えて返し、見つからなかった場合は `0` を返します。 [`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない検索**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```


## positionCaseInsensitiveUTF8 \{#positionCaseInsensitiveUTF8\}

導入バージョン: v1.1

[`positionUTF8`](#positionUTF8) と同様ですが、大文字と小文字を区別せずに検索します。

**構文**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可。検索を開始する `haystack` 内の位置（1始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、1 起算のバイト単位での開始位置を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない UTF-8 検索**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```


## positionUTF8 \{#positionUTF8\}

導入バージョン: v1.1

[`position`](#position) と同様ですが、`haystack` と `needle` が UTF-8 エンコードされた文字列であることを想定します。

**構文**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1 始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**返り値**

部分文字列が見つかった場合は、その開始位置をバイト単位で 1 から数えた値として返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**UTF-8 文字数のカウント**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

---
description: '文字列内検索関数に関するドキュメント'
sidebar_label: '文字列検索'
slug: /sql-reference/functions/string-search-functions
title: '文字列内検索関数'
doc_type: 'reference'
---

# 文字列検索用関数 \{#functions-for-searching-in-strings\}

このセクションのすべての関数は、デフォルトでは大文字小文字を区別して検索します。大文字小文字を区別しない検索は、通常は別の関数バリアントとして提供されます。

:::note
大文字小文字を区別しない検索は、英語の小文字・大文字の規則に従います。例えば、英語では小文字の `i` の大文字は `I` ですが、トルコ語では `İ` となります。そのため、英語以外の言語では想定外の結果になる可能性があります。
:::

このセクションの関数は、検索対象の文字列（このセクションでは `haystack` と呼びます）および検索文字列（このセクションでは `needle` と呼びます）がシングルバイトエンコードされたテキストであることを前提としています。この前提が
満たされていない場合でも、例外はスローされず、結果は未定義となります。UTF-8 エンコードされた文字列での検索は、通常は別の関数バリアントとして提供されます。同様に、UTF-8 用の関数バリアントを使用し、入力文字列が UTF-8 エンコードされたテキストでない場合も、例外はスローされず、
結果は未定義となります。なお、自動的な Unicode 正規化は行われませんが、そのためには
[normalizeUTF8*()](/sql-reference/functions/string-functions#normalizeUTF8NFC) 関数を使用できます。

[一般的な文字列関数](string-functions.md) および [文字列置換用関数](string-replace-functions.md) は別途説明されています。

:::note
以下のドキュメントは、`system.functions` システムテーブルから生成されています。
:::

{/* 
  以下のタグ内のコンテンツは、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントに置き換えられます。これらのタグは変更・削除しないでください。
  詳細は https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{/*AUTOGENERATED_START*/ }

## countMatches \{#countMatches\}

導入バージョン: v21.1

文字列内で正規表現にマッチする回数を返します。

:::note Version dependent behavior
この関数の動作は ClickHouse のバージョンに依存します:

* v25.6 より前のバージョンでは、パターンが空文字列にマッチし得る場合であっても、最初の空マッチが発生した時点でカウントを停止します。
* v25.6 以降のバージョンでは、空マッチが発生しても処理を継続します。従来の動作は、`count_matches_stop_at_empty_match = true` の設定を使用して復元できます。
  :::

**構文**

```sql
countMatches(haystack, pattern)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`String`](/sql-reference/data-types/string)

**返される値**

見つかった一致の数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**使用例**

**数字列をカウントする**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```

## countMatchesCaseInsensitive \{#countMatchesCaseInsensitive\}

導入バージョン: v21.1

[`countMatches`](#countMatches) と同様ですが、大文字と小文字を区別せずにマッチングを行います。

**構文**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`const String`](/sql-reference/data-types/string)

**返り値**

見つかった一致件数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**使用例**

**大文字小文字を区別しないカウント**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```

## countSubstrings \{#countSubstrings\}

導入バージョン: v21.1

部分文字列 `needle` が文字列 `haystack` の中に何回出現するかの回数を返します。

**構文**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を行う対象の文字列。[String](../../sql-reference/data-types/string.md) または [Enum](../../sql-reference/data-types/enum.md)。 - `needle` — 検索する部分文字列。[String](../../sql-reference/data-types/string.md)。 - `start_pos` — 検索を開始する `haystack` 内の位置（1 始まり）。[UInt](../../sql-reference/data-types/int-uint.md)。省略可能。

**戻り値**

出現回数。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**start&#95;pos 引数を指定する場合**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```

## countSubstringsCaseInsensitive \{#countSubstringsCaseInsensitive\}

導入バージョン: v21.1

[`countSubstrings`](#countSubstrings) と同様ですが、大文字・小文字を区別せずにカウントします。

**構文**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1 始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

`haystack` 内での `needle` の出現回数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**start&#95;pos 引数あり**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```

## countSubstringsCaseInsensitiveUTF8 \{#countSubstringsCaseInsensitiveUTF8\}

導入バージョン: v21.1

[`countSubstrings`](#countSubstrings) と同様ですが、大文字小文字を区別せずにカウントし、`haystack` が UTF-8 文字列であることを前提とします。

**構文**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索対象となる UTF-8 文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

`haystack` 内に出現する `needle` の回数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**start&#95;pos 引数を指定する場合**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```

## extract \{#extract\}

導入バージョン: v1.1

文字列から正規表現に一致する最初の部分文字列を抽出します。
&#39;haystack&#39; が &#39;pattern&#39; にマッチしない場合は、空文字列を返します。

この関数は RE2 正規表現ライブラリを使用します。サポートされている構文については [re2](https://github.com/google/re2/wiki/Syntax) を参照してください。

正規表現にキャプチャグループ（サブパターン）が含まれている場合、関数は入力文字列に対して最初のキャプチャグループを照合します。

**構文**

```sql
extract(haystack, pattern)
```

**引数**

* `haystack` — 抽出元となる文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 通常はキャプチャグループを含む正規表現。[`const String`](/sql-reference/data-types/string)

**返り値**

抽出された部分文字列を文字列として返します。[`String`](/sql-reference/data-types/string)

**例**

**メールアドレスからドメインを抽出**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**一致がない場合、空文字列を返す**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```

## extractAll \{#extractAll\}

導入バージョン: v1.1

[`extract`](#extract) と同様ですが、文字列内で正規表現にマッチしたすべての一致を配列として返します。
&#39;haystack&#39; が &#39;pattern&#39; の正規表現にマッチしない場合は、空配列が返されます。

正規表現にキャプチャグループ（サブパターン）が含まれている場合、この関数は入力文字列を最初のキャプチャグループに対して照合します。

**構文**

```sql
extractAll(haystack, pattern)
```

**引数**

* `haystack` — 部分文字列を抽出する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 任意でキャプチャグループを含む正規表現。[`const String`](/sql-reference/data-types/string)

**戻り値**

抽出された部分文字列の配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**使用例**

**すべての数値を抽出する**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**キャプチャグループを使用して抽出**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```

## extractAllGroupsHorizontal \{#extractAllGroupsHorizontal\}

導入: v20.5

指定された正規表現を使用して文字列内のすべてのグループに一致させ、配列の配列を返します。各配列には、同一のキャプチャグループに属するすべてのキャプチャがグループ番号ごとに整理されて格納されます。

**構文**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**引数**

* `s` — 抽出対象の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — マッチングに使用する正規表現。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)

**返される値**

配列の配列を返します。各内側の配列には、すべてのマッチに対して、同一のキャプチャグループから取得されたすべてのキャプチャが含まれます。最初の内側の配列にはグループ 1 からのすべてのキャプチャ、2 番目の配列にはグループ 2 からのすべてのキャプチャ、という形式になります。マッチが見つからない場合は空の配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```

## extractGroups \{#extractGroups\}

導入バージョン: v20.5

正規表現にマッチした、重なりのない部分文字列に含まれるすべてのグループを抽出します。

**構文**

```sql
extractAllGroups(s, regexp)
```

**引数**

* `s` — 抽出対象の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 正規表現の定数。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)

**戻り値**

関数が少なくとも 1 つのマッチするグループを見つけた場合、`group_id`（`1` から `N`。ここで `N` は regexp 内のキャプチャグループの数）ごとにまとめられた Array(Array(String)) カラムを返します。一致するグループがない場合は、空の配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## hasAllTokens \{#hasAllTokens\}

導入バージョン: v25.10

[`hasAnyTokens`](#hasAnyTokens) と同様に動作しますが、`needle` 文字列または配列内のすべてのトークンが `input` 文字列にマッチする場合に 1 を返し、それ以外の場合は 0 を返します。`input` がカラムの場合、この条件を満たすすべての行を返します。

:::note
最適なパフォーマンスのためには、カラム `input` に [テキスト索引](../../engines/table-engines/mergetree-family/textindexes) が定義されている必要があります。
テキスト索引が定義されていない場合、この関数は総当たりのカラム走査を実行し、これは索引検索よりも桁違いに遅くなります。
:::

検索の前に、この関数は次をトークン化します

* `input` 引数（常に）および
* `needle` 引数（[String](../../sql-reference/data-types/string.md) として与えられた場合）
  に対して、テキスト索引に指定されたトークナイザを使用します。
  カラムにテキスト索引が定義されていない場合は、代わりに `splitByNonAlpha` トークナイザが使用されます。
  `needle` 引数が [Array(String)](../../sql-reference/data-types/array.md) 型の場合、各配列要素は 1 つのトークンとして扱われ、追加のトークン化は行われません。

重複するトークンは無視されます。
例えば、needles = [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] は [&#39;ClickHouse&#39;] と同様に扱われます。

**構文**

```sql
hasAllTokens(input, needles)
```

**エイリアス**: `hasAllToken`

**引数**

* `input` — 入力カラム。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Array(String)`](/sql-reference/data-types/array) または [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — 検索対象のトークン。[`String`](/sql-reference/data-types/string) または [`Array(String)`](/sql-reference/data-types/array)
* `tokenizer` — 使用するトークナイザ。有効な引数は `splitByNonAlpha`、`ngrams`、`splitByString`、`array`、`sparseGrams` です。省略可能であり、明示的に設定しない場合は `splitByNonAlpha` がデフォルトになります。[`const String`](/sql-reference/data-types/string)

**戻り値**

指定したすべてのトークンが一致する場合は 1、それ以外の場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**文字列ニードルを使った基本的な使用法**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**配列内で、トークナイズせず AS-IS のまま検索する文字列（needle）を指定する**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**`tokens` 関数を使ってニードルを生成する**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**第3引数でカスタムトークナイザを使用する**

```sql title=Query
SELECT hasAllTokens('abcdef', 'abc', 'ngrams(3)');
```

```response title=Response
┌─hasAllTokens('abcdef', 'abc', 'ngrams(3)')─┐
│                                            1 │
└──────────────────────────────────────────────┘
```

**配列カラムとマップカラムの使用例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**配列カラムの例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys の例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapValues の例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```

## hasAnyTokens \{#hasAnyTokens\}

導入バージョン: v25.10

`needle` 文字列または配列内のトークンのうち少なくとも 1 つが `input` 文字列にマッチする場合は 1 を返し、それ以外の場合は 0 を返します。`input` がカラムの場合、この条件を満たすすべての行を返します。

:::note
最適なパフォーマンスのため、カラム `input` には [text index](../../engines/table-engines/mergetree-family/textindexes) が定義されている必要があります。
text index が定義されていない場合、この関数はブルートフォースによるカラムスキャンを実行し、索引ルックアップと比べて桁違いに遅くなります。
:::

検索を行う前に、この関数は次をトークン化します。

* `input` 引数（常に）と
* `needle` 引数（[String](../../sql-reference/data-types/string.md) として指定された場合）
  これらには、text index に対して指定された tokenizer が使用されます。
  カラムに text index が定義されていない場合は、代わりに `splitByNonAlpha` tokenizer が使用されます。
  `needle` 引数が [Array(String)](../../sql-reference/data-types/array.md) 型の場合、各配列要素はそれ自体がトークンとして扱われ、追加のトークン化は行われません。

重複するトークンは無視されます。
たとえば、[&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] は [&#39;ClickHouse&#39;] と同じように扱われます。

**構文**

```sql
hasAnyTokens(input, needles)
```

**別名**: `hasAnyToken`

**引数**

* `input` — 入力カラム。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Array(String)`](/sql-reference/data-types/array) または [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — 検索するトークン。[`String`](/sql-reference/data-types/string) または [`Array(String)`](/sql-reference/data-types/array)
* `tokenizer` — 使用する tokenizer を指定します。利用可能な値は `splitByNonAlpha`、`ngrams`、`splitByString`、`array`、`sparseGrams` です。省略可能で、明示的に指定しない場合は `splitByNonAlpha` がデフォルト値になります。[`const String`](/sql-reference/data-types/string)

**戻り値**

少なくとも 1 つ一致がある場合は `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**文字列 needle の基本的な使用方法**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**トークナイズせずに文字列をそのまま検索するための検索対象文字列を配列で指定します**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**`tokens` 関数で needle を生成する**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**配列およびマップ型カラムの使用例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**配列カラムの例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys の使用例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**mapValues の使用例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

## hasSubsequence \{#hasSubsequence\}

導入バージョン: v23.7

`needle` が `haystack` の部分列かどうかを判定します。
文字列の部分列とは、ある文字列から 0 個以上の文字を削除し、残りの文字の順序を変えずに得られる文字列の並びのことです。

**構文**

```sql
hasSubsequence(haystack, needle)
```

**引数**

* `haystack` — 部分文字列を検索する対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)

**返り値**

`needle` が `haystack` の部分文字列であれば `1` を、そうでなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的な部分文字列チェック**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**部分文字列が見つかりません**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitive \{#hasSubsequenceCaseInsensitive\}

導入バージョン: v23.7

[`hasSubsequence`](#hasSubsequence) と同様に動作しますが、検索時に大文字と小文字を区別しません。

**構文**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分列。[`String`](/sql-reference/data-types/string)

**戻り値**

`needle` が `haystack` の部分列である場合は 1 を、そうでない場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitiveUTF8 \{#hasSubsequenceCaseInsensitiveUTF8\}

導入バージョン: v23.7

[`hasSubsequenceUTF8`](#hasSubsequenceUTF8) と同様ですが、大文字・小文字を区別せずに検索します。

**構文**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 検索を実行する UTF-8 エンコード済みの文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する UTF-8 エンコード済みの部分シーケンスとなる文字列。[`String`](/sql-reference/data-types/string)

**返される値**

`needle` が `haystack` の部分シーケンスである場合は 1、それ以外の場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```

## hasSubsequenceUTF8 \{#hasSubsequenceUTF8\}

導入バージョン: v23.7

[`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence) と同様ですが、haystack と needle が UTF-8 エンコードされた文字列であることを前提とします。

**構文**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分列。[`String`](/sql-reference/data-types/string)

**戻り値**

`needle` が `haystack` の部分列であれば `1` を返し、それ以外の場合は `0` を返します。 [`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**一致しない部分列**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```

## hasToken \{#hasToken\}

導入バージョン: v20.1

指定したトークンが検索対象文字列（haystack）に含まれているかどうかを確認します。

トークナイザとして [splitByNonAlpha](/sql-reference/functions/splitting-merging-functions.md/#splitByNonAlpha) を使用します。つまり、トークンは `[0-9A-Za-z_]`（数字、ASCII 文字、およびアンダースコア）からなる連続した文字列のうち、可能な限り長い部分列として定義されます。

**構文**

```sql
hasToken(haystack, token)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `token` — 検索するトークン。[`const String`](/sql-reference/data-types/string)

**戻り値**

トークンが見つかった場合は `1` を返し、見つからなかった場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**トークン検索**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```

## hasTokenCaseInsensitive \{#hasTokenCaseInsensitive\}

導入バージョン: v20.1

tokenbf&#95;v1 索引を使用して、haystack 内の needle を大文字小文字を区別せずに検索します。

**構文**

```sql
```

**引数**

* なし

**戻り値**

**例**

## hasTokenCaseInsensitiveOrNull \{#hasTokenCaseInsensitiveOrNull\}

導入バージョン: v23.1

`tokenbf_v1` 索引を使用して、haystack 内で needle を大文字小文字を区別せずに検索します。needle が不正な形式の場合は null を返します。

**構文**

```sql
```

**引数**

* なし。

**戻り値**

**例**

## hasTokenOrNull \{#hasTokenOrNull\}

導入バージョン: v20.1

[`hasToken`](#hasToken) と同様ですが、トークンが不正形式の場合は null を返します。

**構文**

```sql
hasTokenOrNull(haystack, token)
```

**引数**

* `haystack` — 検索対象の文字列。定数でなければなりません。[`String`](/sql-reference/data-types/string)
* `token` — 検索するトークン。[`const String`](/sql-reference/data-types/string)

**返される値**

トークンが見つかった場合は `1`、見つからない場合は `0` を返します。トークンが不正な形式の場合は null を返します。[`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**例**

**使用例**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```

## ilike \{#ilike\}

導入されたバージョン: v20.6

[`like`](#like) と同様ですが、大文字と小文字を区別せずに検索します。

**構文**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合対象の LIKE パターン。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列が LIKE パターンに一致した場合は `1`（大文字小文字を区別せずに比較）、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```

## like \{#like\}

導入バージョン: v1.1

文字列 `haystack` が `LIKE` 式 `pattern` にマッチするかどうかを返します。

`LIKE` 式には通常の文字に加えて、次のメタ文字を含めることができます。

* `%` は任意の数の任意の文字（0 文字も可）を表します。
* `_` は 1 文字の任意の文字を表します。
* `\` はリテラルの `%`、`_`、`\` をエスケープするために使用します。

マッチングは UTF-8 に基づいて行われます。たとえば、`_` は UTF-8 では 2 バイトで表現される Unicode コードポイント `¥` にマッチします。

`haystack` または `LIKE` 式が有効な UTF-8 でない場合、その動作は未定義です。

Unicode の正規化は自動では行われません。必要に応じて `normalizeUTF8*` 関数を使用してください。

リテラルの `%`、`_` および `\`（これらは `LIKE` のメタ文字です）とマッチさせるには、先頭にバックスラッシュを付けて `\%`、`\_`、`\\` と記述します。
バックスラッシュが `%`、`_`、`\` 以外の文字の前に付く場合、その特別な意味は失われ（すなわちリテラルとして解釈され）ます。

:::note
ClickHouse では、文字列内のバックスラッシュも[クオートする必要がある](../syntax.md#string)ため、実際には `\\%`、`\\_`、`\\\\` と記述する必要があります。
:::

`%needle%` という形式の `LIKE` 式の場合、この関数は `position` 関数と同等の速度で動作します。
それ以外の `LIKE` 式は内部的に正規表現へ変換され、関数 `match` と同程度のパフォーマンスで実行されます。

**構文**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合に使用する `LIKE` パターン。`%`（任意の長さの文字列にマッチ）、`_`（任意の1文字にマッチ）、およびエスケープ用の `\` を含めることができます。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列が `LIKE` パターンにマッチした場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**1文字ワイルドカード**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**マッチしないパターン**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```

## locate \{#locate\}

導入バージョン: v18.16

[`position`](#position) と同様ですが、引数 `haystack` と `needle` の順序が逆になっています。

:::note Version dependent behavior
この関数の動作は ClickHouse のバージョンによって異なります:

* v24.3 未満のバージョンでは、`locate` は関数 `position` のエイリアスであり、引数 `(haystack, needle[, start_pos])` を受け取っていました。
* v24.3 以上のバージョンでは、`locate` は個別の関数（MySQL との互換性向上のため）となり、引数 `(needle, haystack[, start_pos])` を受け取ります。
  以前の動作は、設定 `function_locate_has_mysql_compatible_argument_order = false` を使用することで復元できます。
  :::

**構文**

```sql
locate(needle, haystack[, start_pos])
```

**引数**

* `needle` — 検索対象となる部分文字列。[`String`](/sql-reference/data-types/string)
* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置 (1 始まり)。[`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、1 から数えるバイト単位での開始位置を返し、見つからなかった場合は `0` を返す。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用方法**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```

## match \{#match\}

導入バージョン: v1.1

指定された文字列が、指定された正規表現パターンにマッチするかを判定します。

この関数は RE2 正規表現ライブラリを使用します。サポートされている構文については [re2](https://github.com/google/re2/wiki/Syntax) を参照してください。

マッチングは UTF-8 を前提として動作します。例えば `¥` は内部的には 2 バイトを使用しますが、マッチング時には 1 つのコードポイントとして扱われます。
正規表現には NULL バイトを含めることはできません。
`haystack` または `pattern` が不正な UTF-8 の場合、その挙動は未定義です。

re2 のデフォルト動作と異なり、`.` は改行にもマッチします。これを無効にするには、パターンの先頭に `(?-s)` を付けてください。

パターンは両端で自動的にアンカーされます（パターンが先頭に `^` を、末尾に `$` を付けたかのように扱われます）。

部分文字列を検索したいだけであれば、代わりに [`like`](#like) や [`position`](#position) 関数を使用できます。これらはこの関数よりもはるかに高速に動作します。

代替の演算子構文: `haystack REGEXP pattern`。

**構文**

```sql
match(haystack, pattern)
```

**別名**: `REGEXP_MATCHES`

**引数**

* `haystack` — パターンを検索する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`const String`](/sql-reference/data-types/string)

**返される値**

パターンが一致する場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**基本的なパターンマッチ**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**パターンが一致しない場合**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```

## multiFuzzyMatchAllIndices \{#multiFuzzyMatchAllIndices\}

導入バージョン: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny) と同様ですが、一定の [編集距離](https://en.wikipedia.org/wiki/Edit_distance) 以内で haystack にマッチするすべてのインデックスを、任意の順序の配列として返します。

**構文**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `distance` — あいまい一致における最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 照合対象となるパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

`haystack` に対して、指定した編集距離以内でマッチするすべてのインデックス（1 から始まる）を、順不同で要素とする配列を返します。マッチが見つからない場合は空配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```

## multiFuzzyMatchAny \{#multiFuzzyMatchAny\}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と同様ですが、一定の [編集距離](https://en.wikipedia.org/wiki/Edit_distance) 以内でパターンのいずれかが haystack にマッチした場合に 1 を返します。
この関数は [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) ライブラリの実験的機能に依存しており、特定のエッジケースでは低速になる可能性があります。
パフォーマンスは編集距離の値と使用するパターンに依存しますが、常に非ファジー版と比べて計算コストが高くなります。

:::note
`multiFuzzyMatch*()` 関数ファミリーは、hyperscan の制約により UTF-8 正規表現をサポートしていません（バイト列として扱われます）。
:::

**構文**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `distance` — ファジーマッチングにおける最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 省略可能。一致判定に使用するパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

指定した編集距離以内で、いずれかのパターンが `haystack` に一致した場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```

## multiFuzzyMatchAnyIndex \{#multiFuzzyMatchAnyIndex\}

導入バージョン: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny) と同様ですが、検索対象文字列に対して、定数の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)以内で一致する任意のインデックスを返します。

**構文**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `distance` — ファジーマッチングにおける最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 照合対象となるパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

指定された編集距離の範囲内で `haystack` に一致する任意のパターンのインデックス（1 から始まる）を返し、一致するパターンがない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```

## multiMatchAllIndices \{#multiMatchAllIndices\}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と似ていますが、`haystack` にマッチするすべてのインデックスを要素とする配列を、任意の順序で返します。

**構文**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 照合に使用する正規表現パターン。[`String`](/sql-reference/data-types/string)

**戻り値**

haystack 内で一致したすべてのインデックス（1 起算）を、順不同で含む配列。一致が見つからない場合は空配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```

## multiMatchAny \{#multiMatchAny\}

導入バージョン: v20.1

複数の正規表現パターンのうち、少なくとも 1 つが haystack（検索対象の文字列）にマッチするかどうかを判定します。

文字列内で複数の部分文字列を検索したいだけの場合は、代わりに関数 [`multiSearchAny`](#multiSearchAny) を使用してください。この関数よりもはるかに高速に動作します。

**構文**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**引数**

* `haystack` — パターンを検索する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern1[, pattern2, ...]` — 1 つ以上の正規表現パターンからなる配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

いずれかのパターンにマッチした場合は `1`、それ以外は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**複数パターンでのマッチング**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**どのパターンにも一致しません**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```

## multiMatchAnyIndex \{#multiMatchAnyIndex\}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と同様ですが、haystack にマッチする任意の索引を返します。

**構文**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索を実行する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 照合に使用する正規表現。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最初にマッチしたパターンの位置（1 から始まる）を返します。マッチが見つからない場合は 0 を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```

## multiSearchAllPositions \{#multiSearchAllPositions\}

導入バージョン: v20.1

[`position`](#position) と似ていますが、`haystack` 文字列内の複数の `needle` となる部分文字列について、位置（バイト単位、1 起算）の配列を返します。

すべての `multiSearch*()` 関数は、`needle` を最大 2^8 個までしかサポートしません。

**構文**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を実行する対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる 1 つ以上の部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

部分文字列が見つかった場合は、バイト単位かつ 1 起算の開始位置を、見つからなかった場合は `0` を要素とする配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**使用例**

**複数 needle の検索**

```sql title=Query
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitive \{#multiSearchAllPositionsCaseInsensitive\}

導入バージョン: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を実行する対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる 1 つ以上の部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

各部分文字列に対して、見つかった場合はバイト単位かつ 1 始まりの開始位置、見つからなかった場合は `0` を要素とする配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**大文字小文字を区別しない複数検索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitiveUTF8 \{#multiSearchAllPositionsCaseInsensitiveUTF8\}

導入バージョン: v20.1

[`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を行う UTF-8 エンコード文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する UTF-8 エンコード部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

部分文字列が見つかった場合の、1 から数えたバイト単位での開始位置の配列。部分文字列が見つからなかった場合は 0 を返します。[`Array`](/sql-reference/data-types/array)

**例**

**大文字・小文字を区別しない UTF-8 検索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```

## multiSearchAllPositionsUTF8 \{#multiSearchAllPositionsUTF8\}

導入バージョン: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions) と同様ですが、`haystack` および `needle` の部分文字列が UTF-8 でエンコードされた文字列であることを前提とします。

**構文**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を行う UTF-8 エンコード済み文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる UTF-8 エンコード済み部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

部分文字列が見つかった場合、その開始位置（バイト単位、1 起算）の配列を返し、見つからなかった場合は `0` を返します。[`Array`](/sql-reference/data-types/array)

**例**

**UTF-8 マルチ検索**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```

## multiSearchAny \{#multiSearchAny\}

導入バージョン: v20.1

指定された複数の needle 文字列のうち少なくとも 1 つが、haystack 文字列にマッチするかどうかを判定します。

関数 [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive)、[`multiSearchAnyUTF8`](#multiSearchAnyUTF8)、[`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) は、この関数の大文字小文字を区別しないおよび/または UTF-8 対応のバリアントを提供します。

**構文**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

少なくとも 1 件一致があれば `1` を返し、一致が 1 件もなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**いずれかへの一致検索**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitive \{#multiSearchAnyCaseInsensitive\}

導入バージョン: v20.1

[multiSearchAny](#multiSearchAny) と同様ですが、大文字・小文字を区別しません。

**構文**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象の部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

大文字小文字を区別しない一致が少なくとも 1 つあれば `1`、1 つもなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**大文字小文字を区別しない検索**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitiveUTF8 \{#multiSearchAnyCaseInsensitiveUTF8\}

導入されたバージョン: v20.1

[multiSearchAnyUTF8](#multiSearchAnyUTF8) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象の UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

大文字小文字を区別しない一致が少なくとも 1 つあれば `1` を返し、1 つもなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**UTF-8 文字列 &#39;Здравствуйте&#39; が与えられたときに、小文字の文字 &#39;з&#39; が含まれているかを確認する**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchAnyUTF8 \{#multiSearchAnyUTF8\}

導入バージョン: v20.1

[multiSearchAny](#multiSearchAny) と同様ですが、`haystack` 文字列および `needle` 部分文字列が UTF-8 エンコードされた文字列であると仮定します。

**構文**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象の UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する UTF-8 文字列の部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

少なくとも 1 件一致があれば `1` を返し、一致が 1 件もなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**UTF-8 文字列 &#39;你好，世界&#39;（&#39;Hello, world&#39;）が与えられたとき、その文字列内に 你 または 界 の文字が含まれているかを確認します。**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndex \{#multiSearchFirstIndex\}

導入バージョン: v20.1

複数の needle 文字列を haystack 文字列内で検索し（大文字と小文字は区別）、最初に見つかった needle のインデックス（1 から数えた位置）を返します。

**構文**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needles` — 検索する文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

`haystack` 内で最初に見つかった `needle` の、1 始まりのインデックス（`needles` 配列内での位置）を返します。`needle` が 1 つも見つからない場合は 0 を返します。検索は大文字と小文字を区別します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**大文字小文字を区別する場合の挙動**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**一致が見つかりません**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitive \{#multiSearchFirstIndexCaseInsensitive\}

導入バージョン: v20.1

文字列 `haystack` 内で最も左側に見つかった `needle_i` のインデックス `i`（1 から始まる）を返し、見つからない場合は 0 を返します。
大文字小文字を区別せずに検索します。

**構文**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最も左側で見つかった `needle` のインデックス（1 から始まる）を返します。一致がない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitiveUTF8 \{#multiSearchFirstIndexCaseInsensitiveUTF8\}

導入バージョン: v20.1

UTF-8 エンコーディングをサポートしつつ、大文字小文字を区別せずに、haystack 文字列内で複数の needle 文字列を検索し、最初に見つかった needle の 1 始まりのインデックスを返します。

**構文**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needles` — 検索する文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

`haystack` 内で最初に見つかった要素の、1 から始まるインデックス（`needles` 配列内の位置）を返します。どれも見つからなかった場合は 0 を返します。検索は大文字と小文字を区別せず、UTF-8 文字エンコーディングに対応しています。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8 における大文字・小文字の扱い**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**一致するものが見つかりません**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexUTF8 \{#multiSearchFirstIndexUTF8\}

導入バージョン: v20.1

文字列 `haystack` の中で、最も左側で最初に見つかった needle&#95;i に対応するインデックス `i`（1 から始まる）を返し、該当するものがない場合は 0 を返します。
`haystack` および `needle` は UTF-8 でエンコードされた文字列であると仮定します。

**構文**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を行う UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最も左側で見つかった `needle` のインデックス（1 から始まる）を返します。一致がない場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstPosition \{#multiSearchFirstPosition\}

導入バージョン: v20.1

[`position`](#position) と同様ですが、複数の `needle` 文字列のいずれかと一致する `haystack` 文字列内の最も左端のオフセットを返します。

[`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive)、[`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8)、[`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) は、この関数の大文字小文字を区別しない、または UTF-8 対応のバリアントを提供します。

**構文**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索する 1 つ以上の部分文字列からなる配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

`haystack` 文字列中で、複数の `needle` 文字列のいずれかに一致する最も左側のオフセットを返します。一致がなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**先頭位置の検索**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitive \{#multiSearchFirstPositionCaseInsensitive\}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、大文字・小文字を区別しません。

**構文**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を行う対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の `needle` 文字列のいずれかに一致する、`haystack` 文字列内の最も左側のオフセットを返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない最初の位置**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitiveUTF8 \{#multiSearchFirstPositionCaseInsensitiveUTF8\}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、`haystack` と `needle` を UTF-8 文字列として扱い、大文字小文字を区別しません。

**構文**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の `needle` 文字列のいずれかと大文字小文字を区別せずに一致する、`haystack` 文字列内の最も左側のオフセットを返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**与えられた needle のいずれかに一致する、UTF-8 文字列 &#39;Здравствуй, мир&#39;（&#39;Hello, world&#39;）内の最も左側のオフセットを検索する**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionUTF8 \{#multiSearchFirstPositionUTF8\}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、`haystack` と `needle` が UTF-8 文字列であると仮定します。

**構文**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の `needle` 文字列のいずれかに一致する `haystack` 文字列内の最も左側のオフセット。一致がない場合は `0` を返す。[`UInt64`](/sql-reference/data-types/int-uint)

**使用例**

**UTF-8 文字列 &#39;Здравствуй, мир&#39;（&#39;Hello, world&#39;）に対して、指定された `needle` のいずれかに一致する最も左側のオフセットを求めます**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```

## ngramDistance \{#ngramDistance\}

導入バージョン: v20.1

2 つの文字列間の 4-gram 距離を計算します。
そのために、2 つの 4-gram の多重集合間の対称差を数え、その値をそれぞれの要素数の合計で正規化します。
返される値が小さいほど、文字列同士はより類似しています。

大文字と小文字を区別しない検索や UTF-8 形式での使用には、関数 [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive)、[`ngramDistanceUTF8`](#ngramDistanceUTF8)、[`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8) を使用してください。

**構文**

```sql
ngramDistance(haystack, needle)
```

**引数**

* `haystack` — 比較に用いる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較に用いる文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`0` から `1` の範囲の Float32 値を返します。返される値が小さいほど、文字列同士がより類似していることを示します。[`Float32`](/sql-reference/data-types/float)

**例**

**4-gram 距離を計算する**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitive \{#ngramDistanceCaseInsensitive\}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の大文字小文字を区別しないバリアントです。
大文字小文字を無視して、2つの文字列間の 4-gram 距離を計算します。
返される値が小さいほど、文字列同士はより類似しています。

**構文**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 1 番目の比較文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 2 番目の比較文字列。[`String`](/sql-reference/data-types/string)

**返り値**

`0` から `1` の間の Float32 型の数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**大文字小文字を区別しない 4-gram の距離**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitiveUTF8 \{#ngramDistanceCaseInsensitiveUTF8\}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の大文字小文字を区別しない UTF-8 版を提供します。
`needle` と `haystack` の文字列が UTF-8 エンコードされた文字列であることを前提とし、大文字小文字を無視します。
2 つの UTF-8 文字列間の 3-gram 距離を、大文字小文字を無視して計算します。
返される値が小さいほど、2 つの文字列はより類似しています。

**構文**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 1 番目の UTF-8 エンコードされた比較文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 2 番目の UTF-8 エンコードされた比較文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`0` から `1` の間の Float32 型の数値を返します。[`Float32`](/sql-reference/data-types/float)

**使用例**

**大文字小文字を区別しない UTF-8 3-gram 距離**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```

## ngramDistanceUTF8 \{#ngramDistanceUTF8\}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の UTF-8 版を提供します。
`needle` と `haystack` の文字列が UTF-8 でエンコードされていると仮定します。
2 つの UTF-8 文字列間の 3-gram 距離を計算します。
返される値が小さいほど、文字列同士の類似度は高くなります。

**構文**

```sql
ngramDistanceUTF8(haystack, needle)
```

**引数**

* `haystack` — 1 番目の UTF-8 でエンコードされた比較用文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 2 番目の UTF-8 でエンコードされた比較用文字列。[`String`](/sql-reference/data-types/string)

**返り値**

`0` から `1` の間の Float32 型の値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**UTF-8 3-gram 距離**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```

## ngramSearch \{#ngramSearch\}

導入バージョン: v20.1

2 つの文字列間の 4-gram 距離が指定された閾値以下かどうかをチェックします。

大文字小文字を区別しない検索や UTF-8 形式での検索を行う場合は、`ngramSearchCaseInsensitive`、`ngramSearchUTF8`、`ngramSearchCaseInsensitiveUTF8` 関数を使用します。

**構文**

```sql
ngramSearch(haystack, needle)
```

**引数**

* `haystack` — 比較される文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較される文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

2つの文字列間の 4-gram 距離がしきい値（デフォルトは `1.0`）以下であれば `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**4-gram を使った検索**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```

## ngramSearchCaseInsensitive \{#ngramSearchCaseInsensitive\}

導入バージョン: v20.1

[`ngramSearch`](#ngramSearch) の大文字小文字を区別しないバリアントを提供します。
needle 文字列と haystack 文字列の非対称な差分を計算します。具体的には、needle の n-gram 数から共通する n-gram の数を引いたものを、needle の n-gram 数で正規化した値です。
大文字小文字を無視して、2 つの文字列間の 4-gram の距離が指定されたしきい値以下かどうかをチェックします。

**構文**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する文字列。[`String`](/sql-reference/data-types/string)

**返り値**

2 つの文字列間の 4-gram 距離がしきい値（デフォルトでは `1.0`）以下であれば `1`、それ以外の場合は `0` を返します（[`UInt8`](/sql-reference/data-types/int-uint)）。

**例**

**4-gram を用いた大文字小文字を区別しない検索**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

## ngramSearchCaseInsensitiveUTF8 \{#ngramSearchCaseInsensitiveUTF8\}

導入バージョン: v20.1

[`ngramSearch`](#ngramSearch) の大文字小文字を区別しない UTF-8 版を提供します。
`haystack` と `needle` が UTF-8 文字列であることを前提とし、大文字小文字を無視します。
大文字小文字を無視して、2 つの UTF-8 文字列間の 3-gram 距離が指定されたしきい値以下かどうかを判定します。

**構文**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 比較に使用する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較に使用する UTF-8 文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の 3-gram 距離が閾値（デフォルトは `1.0`）以下の場合は `1` を、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**3-gram を使用した UTF-8 の大文字小文字を区別しない検索**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```

## ngramSearchUTF8 \{#ngramSearchUTF8\}

導入バージョン: v20.1

`ngramSearch` の UTF-8 版を提供します。
`haystack` と `needle` が UTF-8 エンコードされた文字列であると仮定します。
2 つの UTF-8 文字列間の 3-gram 距離が、指定されたしきい値以下であるかどうかを判定します。

**構文**

```sql
ngramSearchUTF8(haystack, needle)
```

**引数**

* `haystack` — 比較対象の UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較対象の UTF-8 文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の 3-gram 距離がしきい値（デフォルトは `1.0`）以下の場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**3-gram を使用した UTF-8 検索**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```

## notILike \{#notILike\}

導入バージョン: v20.6

文字列がパターンに一致しないかどうかを、大文字小文字を区別せずにチェックします。パターンには、SQL の LIKE 照合用の特殊文字 `%` と `_` を含めることができます。

**構文**

```sql
notILike(haystack, pattern)
```

**引数**

* `haystack` — 検索対象の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合に使用する SQL の LIKE パターン。`%` は任意の文字列（長さ 0 を含む）に一致し、`_` はちょうど 1 文字に一致する。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列がパターンと一致しない場合は `1` を返し（一致判定は大文字小文字を区別しない）、それ以外の場合は `0` を返す。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**使用方法の例**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```

## notLike \{#notLike\}

導入: v1.1

[`like`](#like) と同様ですが、結果を否定します。

**構文**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**引数**

* `haystack` — 検索を実行する対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合に使用する LIKE パターン文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列が `LIKE` パターンに一致しない場合は `1`、それ以外は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**マッチしないパターン**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```

## position \{#position\}

導入バージョン: v1.1

文字列 `haystack` の中で、部分文字列 `needle` が現れる位置（バイト単位、1 始まり）を返します。

部分文字列 `needle` が空文字の場合、次のルールが適用されます:

* `start_pos` が指定されていない場合: `1` を返す
* `start_pos = 0` の場合: `1` を返す
* `start_pos >= 1` かつ `start_pos <= length(haystack) + 1` の場合: `start_pos` を返す
* それ以外の場合: `0` を返す

同じルールは、関数 [`locate`](#locate)、[`positionCaseInsensitive`](#positionCaseInsensitive)、[`positionUTF8`](#positionUTF8)、[`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8) にも適用されます。

**構文**

```sql
position(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 検索を開始する `haystack` 内の位置 (1 始まり)。省略可能。[`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合、その開始位置をバイト単位で 1 から数えた値として返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用例**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**start&#95;pos 引数ありの場合**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**needle IN haystack 構文**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**空の検索文字列**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```

## positionCaseInsensitive \{#positionCaseInsensitive\}

導入バージョン: v1.1

[`position`](#position) と同様で、比較時に大文字と小文字を区別しません。

**構文**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**別名**: `instr`

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可。検索を開始する `haystack` 内の位置 (1 を起点とする)。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、1 を起点とするバイト単位の開始位置を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字と小文字を区別しない検索**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```

## positionCaseInsensitiveUTF8 \{#positionCaseInsensitiveUTF8\}

導入バージョン: v1.1

[`positionUTF8`](#positionUTF8) と同様ですが、大文字小文字を区別せずに検索します。

**構文**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置 (1 起算)。[`UInt*`](/sql-reference/data-types/int-uint)

**返される値**

部分文字列が見つかった場合は、1 起算のバイトオフセットを返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字・小文字を区別しない UTF-8 検索**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```

## positionUTF8 \{#positionUTF8\}

導入: v1.1

[`position`](#position) と同様ですが、`haystack` および `needle` が UTF-8 でエンコードされた文字列であることを前提とします。

**構文**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1 始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、1 から数えたバイト単位の開始位置を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**UTF-8 文字数のカウント**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

---
description: '文字列検索用関数のドキュメント'
sidebar_label: '文字列の検索'
slug: /sql-reference/functions/string-search-functions
title: '文字列の検索関数'
doc_type: 'reference'
---

# 文字列検索用の関数 {#functions-for-searching-in-strings}

このセクションのすべての関数は、デフォルトでは大文字・小文字を区別して検索します。大文字・小文字を区別しない検索は、通常は別の関数バリアントとして提供されています。

:::note
大文字・小文字を区別しない検索は、英語の小文字・大文字の規則に従います。例えば、英語における小文字 `i` の大文字は `I` ですが、トルコ語では `İ` になります。そのため、英語以外の言語では予期しない結果になる可能性があります。
:::

このセクションの関数は、検索対象の文字列（このセクションでは `haystack` と呼びます）と検索文字列（このセクションでは `needle` と呼びます）が、単一バイト文字エンコーディングされたテキストであることを前提としています。この前提が満たされない場合でも、例外はスローされず、結果は未定義です。UTF-8 エンコードされた文字列に対する検索は、通常は別の関数バリアントとして提供されています。同様に、UTF-8 対応の関数バリアントを使用していても、入力文字列が UTF-8 エンコードされたテキストでない場合、例外はスローされず、結果は未定義です。自動的な Unicode 正規化は行われない点に注意してください。ただし、そのためには
[normalizeUTF8*()](https://clickhouse.com../functions/string-functions/) 関数を使用できます。

[一般的な文字列関数](string-functions.md)および[文字列置換用の関数](string-replace-functions.md)については別途説明しています。

:::note
以下のドキュメントは、`system.functions` システムテーブルから生成されています。
:::

{/* 
  以下のタグの内側の内容は、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントで置き換えられます。タグは変更や削除を行わないでください。
  参照: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## countMatches {#countMatches}

導入バージョン: v21.1

文字列内で正規表現にマッチした回数を返します。

:::note バージョン依存の挙動
この関数の挙動は ClickHouse のバージョンに依存します。

* v25.6 未満のバージョンでは、パターンが空文字列にもマッチしうる場合でも、最初の空マッチでカウントを停止します。
* v25.6 以上のバージョンでは、空マッチが発生しても処理を継続します。従来の挙動は、設定 `count_matches_stop_at_empty_match = true` を使用して復元できます。
  :::

**構文**

```sql
countMatches(haystack, pattern)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`String`](/sql-reference/data-types/string)

**返り値**

見つかった一致の数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**数字列のカウント**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```

## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

導入バージョン: v21.1

[`countMatches`](#countMatches) と同様ですが、大文字と小文字を区別せずにマッチングを行います。

**構文**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`const String`](/sql-reference/data-types/string)

**戻り値**

マッチした件数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字・小文字を区別しないカウント**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```

## countSubstrings {#countSubstrings}

導入バージョン: v21.1

部分文字列 `needle` が文字列 `haystack` 内に出現する回数を返します。

**構文**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を行う対象の文字列。[String](../../sql-reference/data-types/string.md) または [Enum](../../sql-reference/data-types/enum.md)。 - `needle` — 検索する部分文字列。[String](../../sql-reference/data-types/string.md)。 - `start_pos` — 検索を開始する `haystack` 内の位置 (1 始まり)。[UInt](../../sql-reference/data-types/int-uint.md)。省略可能。

**返される値**

出現回数。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**start&#95;pos 引数あり**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```

## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

導入バージョン: v21.1

[`countSubstrings`](#countSubstrings) と同様ですが、大文字と小文字を区別せずにカウントします。

**構文**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

`haystack` 内に出現する `needle` の回数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**start&#95;pos 引数を指定した場合**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```

## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

導入バージョン: v21.1

[`countSubstrings`](#countSubstrings) と同様ですが、大文字小文字を区別せずにカウントし、haystack が UTF-8 文字列であることを前提とします。

**構文**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索対象の UTF-8 文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1 始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

`haystack` 内に出現する `needle` の回数を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**start&#95;pos 引数を指定した場合**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```

## extract {#extract}

導入バージョン: v1.1

文字列内で、正規表現に最初にマッチした部分を抽出します。
`haystack` が `pattern` にマッチしない場合、空文字列が返されます。

この関数は RE2 正規表現ライブラリを使用します。サポートされている構文については [re2](https://github.com/google/re2/wiki/Syntax) を参照してください。

正規表現にキャプチャグループ（サブパターン）が含まれている場合、この関数は入力文字列から、最初のキャプチャグループに対応する部分文字列を抽出します。

**構文**

```sql
extract(haystack, pattern)
```

**引数**

* `haystack` — 抽出対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現。通常はキャプチャグループを含みます。[`const String`](/sql-reference/data-types/string)

**戻り値**

抽出された部分を文字列として返します。型は [`String`](/sql-reference/data-types/string) です。

**使用例**

**メールアドレスからドメインを抽出する**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**一致しない場合は空文字列を返します**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```

## extractAll {#extractAll}

導入: v1.1

[`extract`](#extract) と同様ですが、文字列内で正規表現に一致したすべての結果を配列として返します。
&#39;haystack&#39; が &#39;pattern&#39; の正規表現に一致しない場合、空の配列が返されます。

正規表現にキャプチャグループ（サブパターン）が含まれている場合、この関数は最初のキャプチャグループに対して入力文字列を照合します。

**構文**

```sql
extractAll(haystack, pattern)
```

**引数**

* `haystack` — フラグメント（部分文字列）を抽出する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 任意でキャプチャグループを含む正規表現。[`const String`](/sql-reference/data-types/string)

**戻り値**

抽出されたフラグメントの配列を返します。[`Array(String)`](/sql-reference/data-types/array)

**例**

**すべての数値を抽出**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**キャプチャグループを使って抽出する**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```

## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

導入バージョン: v20.5

指定された正規表現を使用して文字列中のすべてのグループに対してマッチングを行い、配列の配列を返します。各配列には、同じキャプチャグループからのすべてのキャプチャがグループ番号ごとにまとめて格納されます。

**構文**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**引数**

* `s` — 抽出対象の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 照合に使用する正規表現。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)

**返り値**

配列の配列を返します。各内側の配列には、すべての一致にわたって 1 つのキャプチャグループから得られたすべてのキャプチャが含まれます。最初の内側の配列にはグループ 1 からのすべてのキャプチャ、2 番目にはグループ 2 からのすべてのキャプチャ、というように続きます。一致が見つからない場合は空配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```

## extractGroups {#extractGroups}

導入: v20.5

正規表現にマッチする、非重複の部分文字列からすべてのグループを抽出します。

**構文**

```sql
extractAllGroups(s, regexp)
```

**引数**

* `s` — 抽出対象の入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 正規表現。定数。[`const String`](/sql-reference/data-types/string) または [`const FixedString`](/sql-reference/data-types/fixedstring)

**返される値**

関数が 1 つ以上の一致するグループを見つけた場合、グループ ID（`1` から `N`、ここで `N` は regexp 内のキャプチャグループ数）ごとにまとめられた Array(Array(String)) 列を返します。一致するグループがない場合は空配列を返します。[`Array(Array(String))`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## hasAllTokens {#hasAllTokens}

導入バージョン: v25.10

[`hasAnyTokens`](#hasAnyTokens) と同様ですが、`needle` 文字列または配列内のすべてのトークンが `input` 文字列にマッチする場合は 1 を返し、それ以外の場合は 0 を返します。`input` がカラムの場合、この条件を満たすすべての行を返します。

:::note
最適なパフォーマンスのため、カラム `input` には [text index](../../engines/table-engines/mergetree-family/invertedindexes) が定義されている必要があります。
text index が定義されていない場合、この関数はカラム全体の総当たりスキャンを実行し、インデックス検索と比較して桁違いに遅くなります。
:::

検索を行う前に、この関数は次をトークン化します。

* `input` 引数（常に）
* `needle` 引数（[String](../../sql-reference/data-types/string.md) として指定された場合）。この場合、text index に対して指定された tokenizer を使用します。
  カラムに text index が定義されていない場合は、代わりに `splitByNonAlpha` tokenizer が使用されます。
  `needle` 引数が [Array(String)](../../sql-reference/data-types/array.md) 型の場合、配列の各要素はトークンとして扱われ、追加のトークン化は行われません。

重複するトークンは無視されます。
たとえば、needles = [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] は [&#39;ClickHouse&#39;] と同じように扱われます。

**構文**

```sql
hasAllTokens(input, needles)
```

**エイリアス**: `hasAllToken`

**引数**

* `input` — 入力カラム。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Array(String)`](/sql-reference/data-types/array) または [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — 検索するトークン。トークンは最大 64 個まで指定できます。[`String`](/sql-reference/data-types/string) または [`Array(String)`](/sql-reference/data-types/array)

**返される値**

すべてのトークンが一致した場合は 1 を返し、それ以外の場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**文字列カラムに対する使用例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**配列内で、トークナイズせずにそのまま (AS-IS) 検索するニードルを指定します**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**`tokens` 関数を使用してニードルを生成する**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**Array 列および Map 列の使用例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**配列列の例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys の使用例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapValues の例**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```

## hasAnyTokens {#hasAnyTokens}

導入バージョン: v25.10

`needle` 文字列または配列内のトークンのうち少なくとも 1 つが `input` 文字列に一致する場合は 1 を返し、それ以外の場合は 0 を返します。`input` がカラムの場合、この条件を満たすすべての行を返します。

:::note
最適なパフォーマンスを得るためには、カラム `input` に [text index](../../engines/table-engines/mergetree-family/invertedindexes) が定義されている必要があります。
text index が定義されていない場合、この関数はインデックス検索よりも桁違いに遅い総当たりのカラムスキャンを実行します。
:::

検索を行う前に、この関数は次の対象をトークン化します。

* `input` 引数（常に）
* `needle` 引数（[String](../../sql-reference/data-types/string.md) として与えられた場合）

これらは text index に指定された tokenizer を使用してトークン化されます。
カラムに text index が定義されていない場合は、代わりに `splitByNonAlpha` tokenizer が使用されます。
`needle` 引数が [Array(String)](../../sql-reference/data-types/array.md) 型である場合、配列要素それぞれがトークンとして扱われ、追加のトークン化は行われません。

重複するトークンは無視されます。
例えば、[&#39;ClickHouse&#39;, &#39;ClickHouse&#39;] は [&#39;ClickHouse&#39;] と同じものとして扱われます。

**構文**

```sql
hasAnyTokens(input, needles)
```

**エイリアス**: `hasAnyToken`

**引数**

* `input` — 入力列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring) または [`Array(String)`](/sql-reference/data-types/array) または [`Array(FixedString)`](/sql-reference/data-types/array)
* `needles` — 検索するトークン。最大 64 個のトークンをサポートします。[`String`](/sql-reference/data-types/string) または [`Array(String)`](/sql-reference/data-types/array)

**戻り値**

少なくとも 1 件一致があれば `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**文字列列での使用例**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**トークン化せず AS-IS で検索する文字列を配列として指定します**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**`tokens` 関数を使って needle を生成する**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**Array 型および Map 型列の使用例**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**配列カラムの例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys の例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**mapValues の例**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

## hasSubsequence {#hasSubsequence}

導入バージョン: v23.7

文字列 `haystack` の中に、文字列 `needle` が部分列として含まれているかどうかを判定します。
文字列の部分列とは、残りの文字の順序を変えずに、ある文字列からいくつか、または 1 つも文字を削除せずに得られる文字列のことです。

**構文**

```sql
hasSubsequence(haystack, needle)
```

**引数**

* `haystack` — 部分列を検索する対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分列。[`String`](/sql-reference/data-types/string)

**戻り値**

`needle` が `haystack` の部分列であれば `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**基本的な部分列チェック**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**該当する部分列は見つかりません**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

導入バージョン: v23.7

[`hasSubsequence`](#hasSubsequence) と同様ですが、大文字と小文字を区別せずに検索します。

**構文**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 検索が実行される文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる部分列。[`String`](/sql-reference/data-types/string)

**返される値**

`needle` が `haystack` の部分列であれば 1、そうでなければ 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

導入バージョン: v23.7

[`hasSubsequenceUTF8`](#hasSubsequenceUTF8) と同様ですが、大文字と小文字を区別せずに検索します。

**構文**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 検索を行う UTF-8 エンコードされた文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 エンコードされた部分文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`needle` が `haystack` の部分文字列であれば 1、そうでなければ 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```

## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

導入バージョン: v23.7

[`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence) と同様ですが、`haystack` と `needle` が UTF-8 でエンコードされた文字列であると仮定します。

**構文**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分列。[`String`](/sql-reference/data-types/string)

**戻り値**

`needle` が `haystack` の部分列であれば `1` を返し、それ以外は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**一致しない部分列**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```

## hasToken {#hasToken}

導入バージョン: v20.1

指定されたトークンが対象文字列内に存在するかを判定します。

トークンは、連続する文字 `[0-9A-Za-z_]`（数字、ASCII 英字、およびアンダースコア）からなる、可能な限り最長の部分列として定義されます。

**構文**

```sql
hasToken(haystack, token)
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `token` — 検索するトークン。[`const String`](/sql-reference/data-types/string)

**戻り値**

トークンが見つかった場合は `1`、見つからない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**トークン検索**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```

## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

導入バージョン: v

`tokenbf_v1` インデックスを使用して、`haystack` 内で `needle` を大文字・小文字を区別せずに検索します。

**構文**

```sql
```

**引数**

* なし。

**戻り値**

**例**

## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

導入バージョン: v

`tokenbf_v1` インデックスを使用して、`haystack` 内の `needle` を大文字小文字を区別せずに検索します。`needle` が不正な形式の場合は `null` を返します。

**構文**

```sql
```

**引数**

* なし。

**戻り値**

**例**

## hasTokenOrNull {#hasTokenOrNull}

導入バージョン: v20.1

[`hasToken`](#hasToken) と同様ですが、トークンが不正な形式の場合は null を返します。

**構文**

```sql
hasTokenOrNull(haystack, token)
```

**引数**

* `haystack` — 検索対象となる文字列。定数である必要があります。[`String`](/sql-reference/data-types/string)
* `token` — 検索するトークン。定数文字列です。[`const String`](/sql-reference/data-types/string)

**戻り値**

トークンが見つかった場合は `1`、見つからない場合は `0` を返し、トークンが不正な形式の場合は `null` を返します。[`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**例**

**使用例**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```

## ilike {#ilike}

導入バージョン: v20.6

[`like`](#like) と同様ですが、大文字と小文字を区別せずに検索します。

**構文**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合に使用する LIKE パターン。[`String`](/sql-reference/data-types/string)

**返される値**

文字列が LIKE パターンにマッチした場合は `1`（大文字小文字は区別しない）、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```

## like {#like}

導入バージョン: v1.1

文字列 `haystack` が `LIKE` 式 `pattern` にマッチするかどうかを返します。

`LIKE` 式には通常の文字と、次のメタ文字を含めることができます。

* `%` は任意の長さの任意の文字列（長さ 0 も含む）を表します。
* `_` は任意の 1 文字を表します。
* `\` はリテラルの `%`、`_`、`\` をエスケープするために使用します。

マッチングは UTF-8 に基づいて行われます。たとえば `_` は、UTF-8 では 2 バイトで表現される Unicode コードポイント `¥` にマッチします。

`haystack` または `LIKE` 式が不正な UTF-8 の場合、その動作は未定義です。

Unicode の正規化は自動では行われません。必要に応じて `normalizeUTF8*` 関数を使用してください。

リテラルの `%`、`_`、`\`（`LIKE` のメタ文字）にマッチさせるには、先頭にバックスラッシュを付けて `\%`、`\_`、`\\` のように記述します。
バックスラッシュが `%`、`_`、`\` 以外の文字の前に付いている場合、その特別な意味は失われ（すなわちリテラルとして解釈され）ます。

:::note
ClickHouse では、文字列内のバックスラッシュも[クォートする必要がある](../syntax.md#string)ため、実際には `\\%`、`\\_`、`\\\\` と書く必要があります。
:::

`%needle%` という形式の `LIKE` 式に対しては、この関数は `position` 関数と同等の速度です。
それ以外の `LIKE` 式は内部的に正規表現に変換され、関数 `match` と同程度の性能で実行されます。

**構文**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合に使用する `LIKE` パターン。`%`（任意の長さの文字列に一致）、`_`（任意の1文字に一致）、およびエスケープ用の `\` を含めることができます。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列が `LIKE` パターンに一致する場合は `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**1文字ワイルドカード**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**マッチしないパターン**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```

## locate {#locate}

導入バージョン: v18.16

[`position`](#position) と同様ですが、引数 `haystack` と `needle` の順序が逆になっています。

:::note バージョンによる動作の違い
この関数の動作は ClickHouse のバージョンに依存します:

* v24.3 未満のバージョンでは、`locate` は関数 `position` のエイリアスであり、引数 `(haystack, needle[, start_pos])` を受け取っていました。
* v24.3 以上のバージョンでは、`locate` は個別の関数（MySQL との互換性向上のため）となり、引数 `(needle, haystack[, start_pos])` を受け取ります。\
  以前の動作は、設定 `function_locate_has_mysql_compatible_argument_order = false` を使用することで復元できます。
  :::

**構文**

```sql
locate(needle, haystack[, start_pos])
```

**引数**

* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `start_pos` — 省略可能。検索を開始する `haystack` 内の位置（1 始まり）。[`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、先頭位置（バイト単位、1 起算）を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用方法**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```

## match {#match}

導入バージョン: v1.1

指定された文字列が、指定された正規表現パターンにマッチするかを確認します。

この関数は RE2 正規表現ライブラリを使用します。サポートされている構文については [re2](https://github.com/google/re2/wiki/Syntax) を参照してください。

マッチングは UTF-8 を前提として動作します。例えば、`¥` は内部的には 2 バイトで表現されますが、マッチング時には 1 つのコードポイントとして扱われます。
正規表現には NULL バイトを含めてはいけません。
`haystack` またはパターンが無効な UTF-8 の場合、その動作は未定義です。

re2 のデフォルト動作と異なり、`.` は改行にもマッチします。これを無効にするには、パターンの先頭に `(?-s)` を付けてください。

パターンは両端で自動的にアンカーされます（パターンが &#39;^&#39; で始まり &#39;$&#39; で終わるかのように扱われます）。

部分文字列のみを検索したい場合は、代わりに関数 [`like`](#like) または [`position`](#position) を使用できます。これらはこの関数よりもはるかに高速に動作します。

演算子の別構文: `haystack REGEXP pattern`。

**構文**

```sql
match(haystack, pattern)
```

**別名**: `REGEXP_MATCHES`

**引数**

* `haystack` — パターンを検索する文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 正規表現パターン。[`const String`](/sql-reference/data-types/string)

**戻り値**

パターンが一致した場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**基本的なパターンマッチング**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**パターンが一致しません**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```

## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

導入バージョン: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny) と似ていますが、一定の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)以内で haystack に一致する、すべてのインデックスを任意の順序で要素とする配列を返します。

**構文**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**引数**

* `haystack` — 検索を実行する対象の文字列。[`String`](/sql-reference/data-types/string)
* `distance` — ファジーマッチにおける最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 照合対象となるパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

指定した編集距離以内で `haystack` にマッチする、`pattern` 配列内のすべてのインデックス（1 から開始）を任意の順序で含む配列を返します。一致が見つからない場合は空配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```

## multiFuzzyMatchAny {#multiFuzzyMatchAny}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と同様ですが、検索対象文字列に対して、いずれかのパターンが一定の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)以内でマッチした場合に 1 を返します。
この関数は [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) ライブラリの実験的機能に依存しており、一部の特殊なケースでは低速になる可能性があります。
パフォーマンスは編集距離の値と使用されるパターンに依存しますが、常に非ファジーなバリアントよりもコストが高くなります。

:::note
`multiFuzzyMatch*()` 関数ファミリーは、hyperscan の制約により UTF-8 の正規表現をサポートしません（バイト列として扱います）。
:::

**構文**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `distance` — あいまい一致における最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — オプション。照合対象となるパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

指定された編集距離以内で、いずれかのパターンが `haystack` にマッチした場合は `1` を、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```

## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

導入バージョン: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny) と同様ですが、一定の[編集距離](https://en.wikipedia.org/wiki/Edit_distance)以内で検索対象にマッチするインデックスのいずれかを返します。

**構文**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `distance` — あいまい一致における最大編集距離。[`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 照合対象となるパターンの配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

指定した編集距離以内で `haystack` に一致するパターンのいずれかについて、そのインデックス（1 から始まる）を返し、一致しない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```

## multiMatchAllIndices {#multiMatchAllIndices}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と同様ですが、順不同で haystack にマッチするすべてのインデックスを配列で返します。

**構文**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — マッチに使用する正規表現。[`String`](/sql-reference/data-types/string)

**返される値**

`haystack` にマッチしたすべてのインデックス（1 から始まる）の配列。順不同。一致が見つからない場合は空配列を返す。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**使用例**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```

## multiMatchAny {#multiMatchAny}

導入バージョン: v20.1

複数の正規表現パターンのうち少なくとも1つが対象文字列にマッチするかを判定します。

文字列内で複数の部分文字列を検索したいだけであれば、代わりに関数 [`multiSearchAny`](#multiSearchAny) を使用できます。本関数よりもはるかに高速に動作します。

**構文**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**引数**

* `haystack` — パターンを検索する対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern1[, pattern2, ...]` — 1 つ以上の正規表現パターンからなる配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

いずれかのパターンにマッチした場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**複数パターンでのマッチング**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**一致するパターンがありません**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```

## multiMatchAnyIndex {#multiMatchAnyIndex}

導入バージョン: v20.1

[`multiMatchAny`](#multiMatchAny) と同様ですが、検索対象（haystack）内でマッチした位置のいずれかのインデックスを返します。

**構文**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**引数**

* `haystack` — 検索を行う対象の文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — マッチさせる正規表現パターン。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最初にマッチしたパターンのインデックス（1 から始まる）を返し、マッチが見つからない場合は 0 を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```

## multiSearchAllPositions {#multiSearchAllPositions}

導入バージョン: v20.1

[`position`](#position) と似ていますが、`haystack` 文字列内の複数の `needle` 部分文字列に対する位置（バイト単位、1 起算）の配列を返します。

すべての `multiSearch*()` 関数は、最大 2^8 個の `needle` までしかサポートしません。

**構文**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる 1 個以上の部分文字列からなる配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

各部分文字列について、見つかった場合は 1 から数えたバイト単位での開始位置、見つからなかった場合は `0` を要素とする配列を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**複数 needle の検索**

```sql title=Query
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

導入バージョン: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions) と同様ですが、大文字小文字を区別しません。

**構文**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索する 1 つ以上の部分文字列からなる配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

見つかった各部分文字列について、1 から数えたバイト単位の開始位置を要素とする配列を返します。部分文字列が見つからなかった場合、その要素として `0` を返します。[`Array(UInt64)`](/sql-reference/data-types/array)

**例**

**大文字小文字を区別しない複数文字列検索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

導入バージョン: v20.1

[`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 でエンコードされた文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 でエンコードされた部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

見つかった部分文字列それぞれについて、バイト単位（1 からカウント）での開始位置を要素とする配列。部分文字列が見つからなかった場合は 0 を返します。[`Array`](/sql-reference/data-types/array)

**例**

**大文字小文字を区別しない UTF-8 検索**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```

## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

導入バージョン: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions) と同様ですが、`haystack` および `needle` の部分文字列が UTF-8 でエンコードされた文字列であることを前提とします。

**構文**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を行う UTF-8 でエンコードされた文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象となる UTF-8 でエンコードされた部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

部分文字列が見つかった場合は 1 から数えたバイト単位での開始位置を、見つからなかった場合は `0` を要素とする配列を返します。[`Array`](/sql-reference/data-types/array)

**例**

**UTF-8 マルチ検索**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```

## multiSearchAny {#multiSearchAny}

導入バージョン: v20.1

複数のニードル文字列のうち少なくとも 1 つが、ヘイスタック文字列にマッチするかどうかをチェックします。

関数 [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive)、[`multiSearchAnyUTF8`](#multiSearchAnyUTF8)、[`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) は、この関数の大文字小文字を区別しない、または UTF-8 対応のバリエーションを提供します。

**構文**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象とする部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

1 つ以上の一致があれば `1` を返し、一致が 1 つもなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**いずれかへのマッチ検索**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

導入バージョン: v20.1

[multiSearchAny](#multiSearchAny) と同様ですが、大文字と小文字は区別しません。

**構文**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象の部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

少なくとも 1 件の大文字小文字を区別しない一致があれば `1` を返し、なければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**使用例**

**大文字小文字を区別しない検索**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

導入バージョン: v20.1

[multiSearchAnyUTF8](#multiSearchAnyUTF8) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象の UTF-8 部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

少なくとも 1 件の大文字小文字を区別しない一致があれば `1` を返し、1 件も一致がなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**UTF-8 文字列 &#39;Здравствуйте&#39; に小文字の文字 &#39;з&#39; が含まれているかを確認します**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

導入バージョン: v20.1

[multiSearchAny](#multiSearchAny) と同様ですが、`haystack` および `needle` の部分文字列が UTF-8 でエンコードされた文字列であると見なします。

**構文**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

少なくとも 1 件の一致があれば `1` を返し、一致が 1 件もなければ `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**UTF-8 文字列 &#39;你好，世界&#39;（&#39;Hello, world&#39;）が与えられたとき、その文字列内に 你 または 界 の文字が存在するかどうかを確認します**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndex {#multiSearchFirstIndex}

導入バージョン: v20.1

大文字小文字を区別して、複数の needle 文字列を haystack 文字列内で検索し、最初に見つかった needle の 1 から始まるインデックスを返します。

**構文**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needles` — 検索する文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

`haystack` 内で最初に見つかった `needle` の、`needles` 配列における 1 起算のインデックス（位置）を返します。どの `needle` も見つからない場合は 0 を返します。検索は大文字・小文字を区別します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**大文字と小文字を区別する挙動**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**一致するものが見つかりません**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

導入バージョン: v20.1

文字列 `haystack` 内で最も左（先頭）側で見つかった needle&#95;i のインデックス `i`（1 起算）を返し、それ以外の場合は 0 を返します。
大文字と小文字を区別しません。

**構文**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索する部分文字列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

最も左側で見つかった `needle` のインデックス（1 起算）を返します。一致がない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

導入バージョン: v20.1

UTF-8 エンコーディングをサポートし、大文字・小文字を区別せずに、ある文字列（検索対象）の中から複数の検索文字列を検索し、最初に見つかった検索文字列の 1 始まりのインデックスを返します。

**構文**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string)
* `needles` — 検索する文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

`haystack` 内で最初に見つかった `needle` の 1 始まりのインデックス値（`needles` 配列内での位置）を返します。`needle` が 1 つも見つからない場合は 0 を返します。検索は大文字小文字を区別せず、UTF-8 の文字エンコーディングに対応します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8 における大文字・小文字の扱い**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**一致するものが見つかりません**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

導入バージョン: v20.1

文字列 `haystack` 内で最も左側に見つかった needle&#95;i のインデックス `i`（1 から開始）を返し、該当するものがない場合は 0 を返します。
`haystack` と `needle` は UTF-8 でエンコードされた文字列であると仮定します。

**構文**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を実行する UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**返り値**

最も左側で見つかった needle のインデックス（1 起算）を返します。一致がない場合は 0 を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstPosition {#multiSearchFirstPosition}

導入バージョン: v20.1

[`position`](#position) と同様ですが、複数の `needle` 文字列のいずれかに一致する、`haystack` 文字列内の最も左側の位置（オフセット）を返します。

[`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive)、[`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8)、[`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) 関数は、この関数の大文字小文字を区別しない／UTF-8 対応のバリアントを提供します。

**構文**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**引数**

* `haystack` — 検索を行う対象の文字列。[`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 検索対象とする 1 つ以上の部分文字列を要素とする配列。[`Array(String)`](/sql-reference/data-types/array)

**返される値**

`haystack` 文字列の中で、複数の `needle` 文字列のいずれかに一致する最も左側のオフセット（位置）を返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**先頭位置の検索**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の `needle` 文字列のいずれかに一致する `haystack` 文字列内の最も左側の位置（オフセット）を返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない場合の最初の位置**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、`haystack` と `needle` を UTF-8 文字列として扱い、大文字小文字を区別しません。

**構文**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を行う UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列からなる配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

`haystack` 文字列の中で、複数の `needle` 文字列のいずれかに一致する最も左側のオフセットを、大文字小文字を区別せずに返します。一致がない場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**与えられた needle のいずれかに一致する、UTF-8 文字列 &#39;Здравствуй, мир&#39;（&#39;Hello, world&#39;）内の最も左側のオフセットを検索**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

導入バージョン: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition) と同様ですが、`haystack` と `needle` を UTF-8 エンコードされた文字列であると仮定します。

**構文**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**引数**

* `haystack` — 検索を行う UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 検索対象となる UTF-8 部分文字列の配列。[`Array(String)`](/sql-reference/data-types/array)

**戻り値**

複数の `needle` のうちいずれかに一致する、`haystack` 文字列内の最も左にあるオフセット。一致するものがない場合は `0` を返す。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**UTF-8 文字列 &#39;Здравствуй, мир&#39;（&#39;Hello, world&#39;）内で、与えられた needle のいずれかに一致する最も左にあるオフセットを求める**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```

## ngramDistance {#ngramDistance}

導入バージョン: v20.1

2つの文字列間の 4-gram 距離を計算します。
このために、2つの 4-gram マルチセット間の対称差を数え、その値をそれぞれの要素数の総和で正規化します。
返される値が小さいほど、文字列同士はより類似しています。

大文字小文字を区別しない検索や UTF-8 形式での検索には、[`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive)、[`ngramDistanceUTF8`](#ngramDistanceUTF8)、[`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8) 関数を使用します。

**構文**

```sql
ngramDistance(haystack, needle)
```

**引数**

* `haystack` — 比較対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較対象となる文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

`0` から `1` の間の Float32 型の数値を返します。返される値が小さいほど、文字列同士の類似度は高くなります。[`Float32`](/sql-reference/data-types/float)

**例**

**4-グラム距離を計算**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の大文字小文字を区別しないバージョンを提供します。
2 つの文字列の 4-グラム距離を、大文字小文字を無視して計算します。
返される値が小さいほど、文字列同士の類似度が高くなります。

**構文**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 1 番目の比較文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 2 番目の比較文字列。[`String`](/sql-reference/data-types/string)

**返される値**

`0` 以上 `1` 以下の `Float32` 型の数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**大文字小文字を区別しない 4-gram 距離**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の、大文字小文字を区別しない UTF-8 版を提供します。
`needle` と `haystack` の文字列が UTF-8 でエンコードされていることを前提とし、大文字小文字を無視します。
2 つの UTF-8 文字列間の 3-gram 距離を、大文字小文字を無視して計算します。
返される値が小さいほど、文字列同士がより類似していることを意味します。

**構文**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 1 番目の UTF-8 エンコードされた比較文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 2 番目の UTF-8 エンコードされた比較文字列。[`String`](/sql-reference/data-types/string)

**返される値**

`0` から `1` の間の Float32 型の数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**大文字小文字を区別しない UTF-8 3-グラム距離**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```

## ngramDistanceUTF8 {#ngramDistanceUTF8}

導入バージョン: v20.1

[`ngramDistance`](#ngramDistance) の UTF-8 版を提供します。
`needle` と `haystack` の文字列が UTF-8 エンコードされた文字列であると仮定します。
2 つの UTF-8 文字列間の 3-gram 距離を計算します。
返される値が小さいほど、文字列同士はより類似しています。

**構文**

```sql
ngramDistanceUTF8(haystack, needle)
```

**引数**

* `haystack` — 比較対象となる最初の UTF-8 エンコード済み文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較対象となる2番目の UTF-8 エンコード済み文字列。[`String`](/sql-reference/data-types/string)

**返される値**

`0` から `1` の間の `Float32` 型の数値を返します。[`Float32`](/sql-reference/data-types/float)

**例**

**UTF-8 3-gram 距離**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```

## ngramSearch {#ngramSearch}

導入バージョン: v20.1

2 つの文字列間の 4-gram 距離が、指定されたしきい値以下かどうかを判定します。

大文字小文字を区別しない検索や UTF-8 形式の検索には、`ngramSearchCaseInsensitive`、`ngramSearchUTF8`、`ngramSearchCaseInsensitiveUTF8` 関数を使用します。

**構文**

```sql
ngramSearch(haystack, needle)
```

**引数**

* `haystack` — 比較に用いる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較に用いる文字列。[`String`](/sql-reference/data-types/string)

**返される値**

文字列間の 4-gram 距離がしきい値（デフォルトは `1.0`）以下の場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**4-gram を使用した検索**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```

## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

導入バージョン: v20.1

[`ngramSearch`](#ngramSearch) の大文字・小文字を区別しないバージョンを提供します。
ニードル文字列とヘイスタック文字列の非対称な差分を計算します。つまり、ニードルから得られる n-gram の数から共通する n-gram の数を引き、その値をニードルの n-gram 数で正規化したものです。
大文字・小文字を無視して、2 つの文字列の 4-gram 距離が指定されたしきい値以下かどうかをチェックします。

**構文**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**引数**

* `haystack` — 比較対象となる文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較対象となる文字列。[`String`](/sql-reference/data-types/string)

**返り値**

2つの文字列間の4-グラム距離がしきい値（デフォルトは `1.0`）以下の場合は `1` を返し、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**4-グラムを使用した大文字・小文字を区別しない検索**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

導入バージョン: v20.1

[`ngramSearch`](#ngramSearch) の大文字小文字を区別しない UTF-8 版を提供します。
`haystack` と `needle` は UTF-8 文字列であると仮定し、大文字小文字を無視します。
2 つの UTF-8 文字列間の 3-グラム距離が、指定されたしきい値以下かどうかを、大文字小文字を無視して判定します。

**構文**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**引数**

* `haystack` — 比較に用いる UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較に用いる UTF-8 文字列。[`String`](/sql-reference/data-types/string)

**返される値**

文字列間の 3-gram 距離がしきい値（デフォルトでは `1.0`）以下の場合は `1` を、そうでない場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**3-gram を使用した大文字小文字を区別しない UTF-8 検索**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```

## ngramSearchUTF8 {#ngramSearchUTF8}

導入バージョン: v20.1

`ngramSearch` の UTF-8 版を提供します。
`haystack` と `needle` が UTF-8 文字列であることを前提とします。
2 つの UTF-8 文字列間の 3-グラム距離が、指定されたしきい値以下かどうかを確認します。

**構文**

```sql
ngramSearchUTF8(haystack, needle)
```

**引数**

* `haystack` — 比較対象となる UTF-8 文字列。[`String`](/sql-reference/data-types/string)
* `needle` — 比較対象となる UTF-8 文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列間の 3-gram 距離がしきい値（デフォルトは `1.0`）以下であれば `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**3-gram を使用した UTF-8 検索**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```

## notILike {#notILike}

導入バージョン: v20.6

文字列がパターンに一致しないかどうかを、大文字小文字を区別せずに判定します。パターンには、SQL の LIKE マッチング用の特殊文字 `%` および `_` を含めることができます。

**構文**

```sql
notILike(haystack, pattern)
```

**引数**

* `haystack` — 検索対象となる入力文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合に使用する SQL LIKE パターン。`%` は任意の長さ（0 文字を含む）の文字列に一致し、`_` はちょうど 1 文字に一致する。[`String`](/sql-reference/data-types/string)

**戻り値**

文字列がパターンに一致しない場合は `1` を返し（比較は大文字小文字を区別しない）、それ以外の場合は `0` を返す。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```

## notLike {#notLike}

導入: v1.1

[`like`](#like) と似ていますが、結果を否定します。

**構文**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 照合する LIKE パターン。[`String`](/sql-reference/data-types/string)

**返り値**

文字列が `LIKE` パターンに一致しない場合は `1`、それ以外の場合は `0` を返します。[`UInt8`](/sql-reference/data-types/int-uint)

**例**

**使用例**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**非マッチパターン**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```

## position {#position}

導入: v1.1

部分文字列 `needle` が文字列 `haystack` 内に現れる位置（バイト単位、1 始まり）を返します。

部分文字列 `needle` が空文字列の場合、以下の規則が適用されます:

* `start_pos` が指定されていない場合: `1` を返す
* `start_pos = 0` の場合: `1` を返す
* `start_pos >= 1` かつ `start_pos <= length(haystack) + 1` の場合: `start_pos` を返す
* それ以外の場合: `0` を返す

同じ規則は、関数 [`locate`](#locate)、[`positionCaseInsensitive`](#positionCaseInsensitive)、[`positionUTF8`](#positionUTF8)、[`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8) にも適用されます。

**構文**

```sql
position(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 検索を開始する `haystack` 内の位置 (1 始まり)。省略可能。[`UInt`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、バイト単位で 1 から数えた開始位置を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**基本的な使用例**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**start&#95;pos 引数を指定する場合**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Needle IN haystack 構文**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**空の検索文字列**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```

## positionCaseInsensitive {#positionCaseInsensitive}

導入バージョン: v1.1

[`position`](#position) と同様ですが、大文字と小文字を区別しません。

**構文**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**別名**: `instr`

**引数**

* `haystack` — 検索対象の文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索する部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可。検索を開始する `haystack` 内の位置（1始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、先頭から 1 始まりでバイト単位の開始位置を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない検索**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```

## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

導入バージョン: v1.1

[`positionUTF8`](#positionUTF8) と同様ですが、大文字小文字を区別せずに検索します。

**構文**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を実行する対象の文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — 省略可。検索を開始する `haystack` 内の位置（1 始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、その開始位置をバイト単位で 1 始まりとして返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**大文字小文字を区別しない UTF-8 検索**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```

## positionUTF8 {#positionUTF8}

導入バージョン: v1.1

[`position`](#position) と同様ですが、`haystack` と `needle` が UTF-8 でエンコードされた文字列であると仮定します。

**構文**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**引数**

* `haystack` — 検索を行う文字列。[`String`](/sql-reference/data-types/string) または [`Enum`](/sql-reference/data-types/enum)
* `needle` — 検索対象の部分文字列。[`String`](/sql-reference/data-types/string)
* `start_pos` — オプション。検索を開始する `haystack` 内の位置（1 始まり）。[`UInt*`](/sql-reference/data-types/int-uint)

**戻り値**

部分文字列が見つかった場合は、その開始位置（バイト単位、1 始まり）を返し、見つからなかった場合は `0` を返します。[`UInt64`](/sql-reference/data-types/int-uint)

**例**

**UTF-8 文字数のカウント**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

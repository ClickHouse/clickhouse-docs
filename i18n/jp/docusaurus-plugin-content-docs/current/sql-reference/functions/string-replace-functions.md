---
description: '文字列置換関数のドキュメント'
sidebar_label: '文字列置換'
slug: /sql-reference/functions/string-replace-functions
title: '文字列置換関数'
doc_type: 'reference'
keywords: ['文字列置換']
---

# 文字列置換用関数 {#functions-for-string-replacement}

[一般的な文字列関数](string-functions.md)と[文字列検索用関数](string-search-functions.md)は別途説明されています。

:::note
以下のドキュメントは `system.functions` システムテーブルから生成されています。
:::

{/* 
  以下のタグ内のコンテンツは、ドキュメントフレームワークのビルド時に
  system.functions から自動生成されたドキュメントで置き換えられます。タグを変更したり削除したりしないでください。
  詳細は https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md を参照してください。
  */ }

{/*AUTOGENERATED_START*/ }

## format {#format}

導入バージョン: v20.1

`pattern` 文字列を、引数として指定した値（文字列、整数など）でフォーマットします。Python のフォーマット機能と同様に動作します。
パターン文字列には、中かっこ `{}` で囲まれた置換フィールドを含めることができます。
中かっこ内に含まれない部分はリテラル文字列と見なされ、そのまま出力にコピーされます。
リテラルの中かっこ文字は、二重の中かっこ `{{` および `}}` でエスケープできます。
フィールド名には 0 から始まる数値、または空文字列を指定できます。空文字列の場合は、暗黙的に単調増加する番号が割り当てられます。

**構文**

```sql
format(pattern, s0[, s1, ...])
```

**引数**

* `pattern` — プレースホルダーを含むフォーマット文字列。[`String`](/sql-reference/data-types/string)
* `s0[, s1, ...]` — pattern に埋め込む 1 つ以上の値。[`Any`](/sql-reference/data-types)

**戻り値**

フォーマット済みの文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**番号付きプレースホルダー**

```sql title=Query
SELECT format('{1} {0} {1}', '世界', 'こんにちは')
```

```response title=Response
┌─format('{1} {0} {1}', 'World', 'Hello')─┐
│ Hello World Hello                       │
└─────────────────────────────────────────┘
```

**暗黙の番号付け**

```sql title=Query
SELECT format('{} {}', 'こんにちは', '世界')
```

```response title=Response
┌─format('{} {}', 'Hello', 'World')─┐
│ Hello World                       │
└───────────────────────────────────┘
```

## overlay {#overlay}

導入バージョン: v24.9

文字列 `input` の一部を、インデックス `offset`（1 始まり）で指定される位置から、別の文字列 `replace` で置き換えます。

**構文**

```sql
overlay(s, replace, offset[, length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `replace` — 置換に使用する文字列。[`const String`](/sql-reference/data-types/string)
* `offset` — 整数型 `Int`（1 始まり）。`offset` が負の場合は、文字列 `s` の末尾から数えます。[`Int`](/sql-reference/data-types/int-uint)
* `length` — 省略可能。整数型 `Int`。`length` は、入力文字列 `s` のうち置換対象となる部分文字列の長さを指定します。`length` が指定されていない場合、`s` から削除されるバイト数は `replace` の長さと同じになります。指定されている場合は `length` バイトが削除されます。[`Int`](/sql-reference/data-types/int-uint)

**戻り値**

置換後の文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**基本的な置換**

```sql title=Query
SELECT overlay('私の父はメキシコ出身です。', '母', 4) AS res;
```

```response title=Response
┌─res──────────────────────┐
│ 私の母はメキシコ出身です。│
└──────────────────────────┘
```

**長さ指定付き置換**

```sql title=Query
SELECT overlay('私の父はメキシコ出身です。', '父', 4, 6) AS res;
```

```response title=Response
┌─res───────────────────┐
│ 父はメキシコ出身です。│
└───────────────────────┘
```

## overlayUTF8 {#overlayUTF8}

導入バージョン: v24.9

文字列 `s` の一部を、1 始まりのインデックス `offset` の位置から、別の文字列 `replace` で置き換えます。
文字列が有効な UTF-8 でエンコードされたテキストであることを前提とします。
この前提が満たされない場合でも、例外はスローされず、結果は未定義です。

**構文**

```sql
overlayUTF8(s, replace, offset[, length])
```

**引数**

* `s` — 入力文字列。[`String`](/sql-reference/data-types/string)
* `replace` — 置換後の文字列。[`const String`](/sql-reference/data-types/string)
* `offset` — 整数型 `Int`（1 始まりのインデックス）。`offset` が負の値の場合、入力文字列 `s` の末尾からのオフセットとして解釈されます。[`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 省略可能。入力文字列 `s` の中で置換対象となる部分文字列の長さを指定します。`length` が指定されていない場合、`s` から削除される文字数は `replace` の長さと等しくなり、指定されている場合は `length` 文字が削除されます。[`(U)Int*`](/sql-reference/data-types/int-uint)

**戻り値**

置換後の文字列を返します。[`String`](/sql-reference/data-types/string)

**使用例**

**UTF-8 の置換**

```sql title=Query
SELECT overlayUTF8('私の父はオーストリア出身です。', 'トルコ', 20) AS res;
```

```response title=Response
┌─res───────────────────────────┐
│ Mein Vater ist aus der Türkei.│
└───────────────────────────────┘
```

## printf {#printf}

導入バージョン: v24.8

`printf` 関数は、C++ の printf 関数と同様に、引数として指定された値（文字列、整数、浮動小数点数など）を使って、与えられた文字列をフォーマットします。
フォーマット文字列には、`%` 文字で始まる書式指定子を含めることができます。
`%` とそれに続く書式指定子に含まれない部分はリテラルテキストとして扱われ、そのまま出力にコピーされます。
リテラルの `%` 文字は `%%` でエスケープできます。

**構文**

```sql
printf(format[, sub1, sub2, ...])
```

**引数**

* `format` — `%` 指定子を含むフォーマット文字列。[`String`](/sql-reference/data-types/string)
* `sub1, sub2, ...` — 省略可。フォーマット文字列内に埋め込む 0 個以上の値。[`Any`](/sql-reference/data-types)

**戻り値**

フォーマット済みの文字列を返します。[`String`](/sql-reference/data-types/string)

**使用例**

**C++ スタイルのフォーマット**

```sql title=Query
SELECT printf('%%%s %s %d', 'Hello', 'World', 2024);
```

```response title=Response
┌─printf('%%%s %s %d', 'Hello', 'World', 2024)─┐
│ %Hello World 2024                            │
└──────────────────────────────────────────────┘
```

## regexpQuoteMeta {#regexpQuoteMeta}

導入バージョン: v20.1

正規表現において特別な意味を持つ次の文字の前にバックスラッシュを追加します: `\0`, `\\`, `|`, `(`, `)`, `^`, `$`, `.`, `[`, `]`, `?`, `*`, `+`, `{`, `:`, `-`。
この実装は `re2::RE2::QuoteMeta` とは細部で挙動が異なります。
ゼロバイト文字を `\x00` ではなく `\0` としてエスケープし、必要な文字だけをエスケープします。

**構文**

```sql
regexpQuoteMeta(s)
```

**引数**

* `s` — 正規表現でエスケープする必要がある文字を含む入力文字列。[`String`](/sql-reference/data-types/string)

**戻り値**

正規表現の特殊文字をエスケープした文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**正規表現の特殊文字をエスケープする**

```sql title=Query
SELECT regexpQuoteMeta('Hello. [World]? (Yes)*') AS res
```

```response title=Response
┌─res───────────────────────────┐
│ Hello\. \[World\]\? \(Yes\)\* │
└───────────────────────────────┘
```

## replaceAll {#replaceAll}

導入バージョン: v1.1

`haystack` 内にある部分文字列 `pattern` のすべての出現を、文字列 `replacement` で置換します。

**構文**

```sql
replaceAll(haystack, pattern, replacement)
```

**別名**: `replace`

**引数**

* `haystack` — 検索対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 検索して置換する部分文字列。[`const String`](/sql-reference/data-types/string)
* `replacement` — `pattern` を置き換える文字列。[`const String`](/sql-reference/data-types/string)

**返される値**

`pattern` のすべての出現箇所を置換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**すべての出現箇所を置換**

```sql title=Query
SELECT replaceAll('Hello, Hello world', 'Hello', 'Hi') AS res;
```

```response title=Response
┌─res──────────┐
│ Hi, Hi world │
└──────────────┘
```

## replaceOne {#replaceOne}

導入バージョン: v1.1

`haystack` 内で `pattern` が最初に出現する箇所を、文字列 `replacement` に置き換えます。

**構文**

```sql
replaceOne(haystack, pattern, replacement)
```

**引数**

* `haystack` — 検索対象となる入力文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 検索および置換の対象となる部分文字列。[`const String`](/sql-reference/data-types/string)
* `replacement` — `pattern` を置き換える文字列。[`const String`](/sql-reference/data-types/string)

**返却値**

`pattern` の最初の出現箇所を置換した文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**最初の出現箇所を置換**

```sql title=Query
SELECT replaceOne('Hello, Hello world', 'Hello', 'Hi') AS res;
```

```response title=Response
┌─res─────────────┐
│ やあ、Hello world │
└─────────────────┘
```

## replaceRegexpAll {#replaceRegexpAll}

導入: v1.1

`replaceRegexpOne` と同様ですが、パターンに一致するすべての出現箇所を置換します。
例外として、正規表現が空の部分文字列にマッチした場合、その置換は 1 回しか行われません。

**構文**

```sql
replaceRegexpAll(haystack, pattern, replacement)
```

**別名**: `REGEXP_REPLACE`

**引数**

* `haystack` — 検索対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 検索する正規表現パターン。[`const String`](/sql-reference/data-types/string)
* `replacement` — パターンを置き換える文字列。後方参照などの置換パターンを含めることができる。[`const String`](/sql-reference/data-types/string)

**戻り値**

正規表現にマッチした部分がすべて置き換えられた文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**すべての文字を2回繰り返した文字で置き換える**

```sql title=Query
SELECT replaceRegexpAll('Hello123', '.', '\\\\0\\\\0') AS res
```

```response title=Response
┌─res──────────────────┐
│ HHeelllloo112233     │
└──────────────────────┘
```

**空文字列の置換例**

```sql title=Query
SELECT replaceRegexpAll('Hello, World!', '^', 'here: ') AS res
```

```response title=Response
┌─res─────────────────┐
│ here: こんにちは、世界！ │
└─────────────────────┘
```

## replaceRegexpOne {#replaceRegexpOne}

導入バージョン: v1.1

`haystack` 内で、正規表現パターン `pattern`（re2 構文）にマッチする部分文字列の最初の出現箇所を、文字列 `replacement` で置換します。
`replacement` には、`\0-\9` の置換指定を含めることができます。
置換指定 `\1-\9` は第1〜第9のキャプチャグループ（サブマッチ）に対応し、置換指定 `\0` はマッチ全体に対応します。
`pattern` または `replacement` の文字列内でリテラルな `\` 文字を使用するには、`\` を使ってエスケープしてください。
また、文字列リテラルでは追加のエスケープが必要になる点にも注意してください。

**構文**

```sql
replaceRegexpOne(haystack, pattern, replacement)
```

**引数**

* `haystack` — 検索対象となる入力文字列。[`String`](/sql-reference/data-types/string)
* `pattern` — 検索する正規表現パターン。[`const String`](/sql-reference/data-types/string)
* `replacement` — パターンを置き換える文字列。後方参照などの置換式を含めることができる。[`const String`](/sql-reference/data-types/string)

**返される値**

最初にマッチした部分が置換された文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**ISO 日付をアメリカ式の日付形式に変換する**

```sql title=Query
SELECT DISTINCT
    EventDate,
    replaceRegexpOne(toString(EventDate), '(\\d{4})-(\\d{2})-(\\d{2})', '\\2/\\3/\\1') AS res
FROM test.hits
LIMIT 7
FORMAT TabSeparated
```

```response title=Response
2014-03-17      03/17/2014
2014-03-18      03/18/2014
2014-03-19      03/19/2014
2014-03-20      03/20/2014
2014-03-21      03/21/2014
2014-03-22      03/22/2014
2014-03-23      03/23/2014
```

**文字列を10回コピーする**

```sql title=Query
SELECT replaceRegexpOne('Hello, World!', '.*', '\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0') AS res
```

```response title=Response
┌─res────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ こんにちは、世界！こんにちは、世界！こんにちは、世界！こんにちは、世界！こんにちは、世界！こんにちは、世界！こんにちは、世界！こんにちは、世界！こんにちは、世界！こんにちは、世界！ │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

## translate {#translate}

導入バージョン: v22.7

文字列 `s` 内の文字を、`from` と `to` 文字列で定義された 1 対 1 の文字マッピングを使って置換します。
`from` と `to` は定数の ASCII 文字列である必要があります。
`from` と `to` の長さが同じ場合、`s` 内に現れる `from` の 1 文字目はすべて `to` の 1 文字目に、`from` の 2 文字目はすべて `to` の 2 文字目に、というように順に置換されます。
`from` に含まれる文字数が `to` より多い場合、`from` の末尾側で `to` に対応する文字を持たないすべての文字は、`s` から削除されます。
`s` 内の非 ASCII 文字は、この関数によって変更されません。

**構文**

```sql
translate(s, from, to)
```

**引数**

* `s` — 変換対象の入力文字列。[`String`](/sql-reference/data-types/string)
* `from` — 置換対象の文字を含む定数 ASCII 文字列。[`const String`](/sql-reference/data-types/string)
* `to` — 置換後の文字を含む定数 ASCII 文字列。[`const String`](/sql-reference/data-types/string)

**戻り値**

文字の変換が適用された文字列を返します。[`String`](/sql-reference/data-types/string)

**例**

**文字の対応付け**

```sql title=Query
SELECT translate('Hello, World!', 'delor', 'DELOR') AS res
```

```response title=Response
┌─res───────────┐
│ HELLO, WORLD! │
└───────────────┘
```

**長さの違い**

```sql title=Query
SELECT translate('clickhouse', 'clickhouse', 'CLICK') AS res
```

```response title=Response
┌─res───┐
│ クリック │
└───────┘
```

## translateUTF8 {#translateUTF8}

導入バージョン: v22.7

[`translate`](#translate) と同様ですが、`s`、`from`、`to` の各引数が UTF-8 エンコードされた文字列であると仮定します。

**構文**

```sql
translateUTF8(s, from, to)
```

**引数**

* `s` — 変換対象の UTF-8 入力文字列。[`String`](/sql-reference/data-types/string)
* `from` — 置換対象の文字を含む定数 UTF-8 文字列。[`const String`](/sql-reference/data-types/string)
* `to` — 置換後の文字を含む定数 UTF-8 文字列。[`const String`](/sql-reference/data-types/string)

**返される値**

`String` 型の値を返します。[`String`](/sql-reference/data-types/string)

**例**

**UTF-8 文字の変換**

```sql title=Query
SELECT translateUTF8('Münchener Straße', 'üß', 'us') AS res;
```

```response title=Response
┌─res──────────────┐
│ Munchener Strase │
└──────────────────┘
```

{/*AUTOGENERATED_END*/ }

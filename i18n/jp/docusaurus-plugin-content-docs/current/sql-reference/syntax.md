---
description: '構文に関するドキュメント'
displayed_sidebar: 'sqlreference'
sidebar_label: '構文'
sidebar_position: 2
slug: /sql-reference/syntax
title: '構文'
doc_type: 'reference'
---

このセクションでは、ClickHouse の SQL 構文について説明します。
ClickHouse は SQL をベースにした構文を採用しており、さまざまな拡張機能と最適化を提供します。



## クエリの解析 {#query-parsing}

ClickHouseには2種類のパーサーがあります:

- _完全なSQLパーサー_（再帰下降パーサー）
- _データフォーマットパーサー_（高速ストリームパーサー）

完全なSQLパーサーは、両方のパーサーを使用する`INSERT`クエリを除き、すべての場合に使用されます。

以下のクエリを見てみましょう:

```sql
INSERT INTO t VALUES (1, 'Hello, world'), (2, 'abc'), (3, 'def')
```

既に述べたように、`INSERT`クエリは両方のパーサーを使用します。
`INSERT INTO t VALUES`の部分は完全なパーサーによって解析され、
データ`(1, 'Hello, world'), (2, 'abc'), (3, 'def')`はデータフォーマットパーサー（高速ストリームパーサー）によって解析されます。

<details>
<summary>完全なパーサーを有効にする</summary>

[`input_format_values_interpret_expressions`](../operations/settings/settings-formats.md#input_format_values_interpret_expressions)設定を使用することで、データに対して完全なパーサーを有効にすることもできます。

この設定を`1`に設定すると、
ClickHouseはまず高速ストリームパーサーで値の解析を試みます。
それが失敗した場合、ClickHouseはデータに対して完全なパーサーを使用し、SQL[式](#expressions)として扱います。

</details>

データは任意のフォーマットを持つことができます。
クエリを受信すると、サーバーはリクエストの最大[max_query_size](../operations/settings/settings.md#max_query_size)バイト（デフォルトでは1MB）までをRAMで処理し、
残りはストリーム解析されます。
これは、大規模な`INSERT`クエリに関する問題を回避するためであり、ClickHouseでデータを挿入する際の推奨方法です。

`INSERT`クエリで[`Values`](/interfaces/formats/Values)フォーマットを使用する場合、
データが`SELECT`クエリの式と同じように解析されるように見えるかもしれませんが、実際にはそうではありません。
`Values`フォーマットははるかに制限されています。

このセクションの残りの部分では、完全なパーサーについて説明します。

:::note
フォーマットパーサーの詳細については、[フォーマット](../interfaces/formats.md)セクションを参照してください。
:::


## 空白文字 {#spaces}

- 構文要素間(クエリの先頭と末尾を含む)には、任意の数の空白文字を使用できます。
- 空白文字には、スペース、タブ、改行(LF)、キャリッジリターン(CR)、フォームフィードが含まれます。


## コメント {#comments}

ClickHouseはSQLスタイルとCスタイルの両方のコメントをサポートしています:

- SQLスタイルのコメントは`--`、`#!`、または`# `で始まり、行末まで続きます。`--`と`#!`の後のスペースは省略できます。
- Cスタイルのコメントは`/*`から`*/`までの範囲で、複数行にわたることができます。スペースは必須ではありません。


## キーワード {#keywords}

ClickHouseのキーワードは、文脈に応じて_大文字小文字を区別する_場合と_区別しない_場合があります。

キーワードが**大文字小文字を区別しない**のは、以下に該当する場合です:

- SQL標準。例えば、`SELECT`、`select`、`SeLeCt`はすべて有効です。
- 一部の主要なDBMS(MySQLやPostgres)の実装。例えば、`DateTime`は`datetime`と同じです。

:::note
データ型名が大文字小文字を区別するかどうかは、[system.data_type_families](/operations/system-tables/data_type_families)テーブルで確認できます。
:::

標準SQLとは対照的に、その他のすべてのキーワード(関数名を含む)は**大文字小文字を区別します**。

さらに、キーワードは予約語ではありません。
対応する文脈においてのみ、キーワードとして扱われます。
キーワードと同じ名前の[識別子](#identifiers)を使用する場合は、二重引用符またはバッククォートで囲んでください。

例えば、テーブル`table_name`に`"FROM"`という名前のカラムがある場合、以下のクエリは有効です:

```sql
SELECT "FROM" FROM table_name
```


## 識別子 {#identifiers}

識別子には以下が含まれます:

- クラスタ、データベース、テーブル、パーティション、およびカラムの名前
- [関数](#functions)
- [データ型](../sql-reference/data-types/index.md)
- [式のエイリアス](#expression-aliases)

識別子は引用符で囲むことも囲まないこともできますが、囲まない方が推奨されます。

引用符で囲まれていない識別子は正規表現 `^[a-zA-Z_][0-9a-zA-Z_]*$` に一致する必要があり、[キーワード](#keywords)と同一であってはなりません。
有効な識別子と無効な識別子の例については、以下の表を参照してください:

| 有効な識別子                              | 無効な識別子                    |
| ---------------------------------------------- | -------------------------------------- |
| `xyz`, `_internal`, `Id_with_underscores_123_` | `1x`, `tom@gmail.com`, `äußerst_schön` |

キーワードと同じ識別子を使用したい場合、または識別子に他の記号を使用したい場合は、二重引用符またはバッククォートで囲んでください。例: `"id"`, `` `id` ``

:::note
引用符で囲まれた識別子のエスケープに適用される規則は、文字列リテラルにも同様に適用されます。詳細については[文字列](#string)を参照してください。
:::


## リテラル {#literals}

ClickHouseにおいて、リテラルとはクエリ内で直接表現される値です。
言い換えれば、クエリ実行中に変化しない固定値を指します。

リテラルには以下の種類があります:

- [文字列](#string)
- [数値](#numeric)
- [複合](#compound)
- [`NULL`](#null)
- [ヒアドキュメント](#heredoc)(カスタム文字列リテラル)

以下のセクションでは、これらについて詳しく説明します。

### 文字列 {#string}

文字列リテラルはシングルクォートで囲む必要があります。ダブルクォートはサポートされていません。

エスケープは以下のいずれかの方法で行います:

- 前にシングルクォートを置く方法。シングルクォート文字`'`(この文字のみ)を`''`としてエスケープできます。
- 前にバックスラッシュを置く方法。以下の表に示すサポートされているエスケープシーケンスを使用します。

:::note
バックスラッシュは、以下に示す文字以外の文字の前に置かれた場合、特殊な意味を失い、文字通りに解釈されます。
:::

| サポートされているエスケープ                       | 説明                                                             |
| -------------------------------------- | ----------------------------------------------------------------------- |
| `\xHH`                                 | 8ビット文字指定。任意の数の16進数字(H)が続きます。 |
| `\N`                                   | 予約済み、何もしません(例: `SELECT 'a\Nb'`は`ab`を返します)                |
| `\a`                                   | 警告                                                                   |
| `\b`                                   | バックスペース                                                               |
| `\e`                                   | エスケープ文字                                                        |
| `\f`                                   | フォームフィード                                                               |
| `\n`                                   | ラインフィード                                                               |
| `\r`                                   | キャリッジリターン                                                         |
| `\t`                                   | 水平タブ                                                          |
| `\v`                                   | 垂直タブ                                                            |
| `\0`                                   | ヌル文字                                                          |
| `\\`                                   | バックスラッシュ                                                               |
| `\'`(または`''`)                         | シングルクォート                                                            |
| `\"`                                   | ダブルクォート                                                            |
| `` ` ``                                | バッククォート                                                                |
| `\/`                                   | スラッシュ                                                           |
| `\=`                                   | 等号                                                              |
| ASCII制御文字(c &lt;= 31) |                                                                         |

:::note
文字列リテラルでは、少なくとも`'`と`\`をエスケープコード`\'`(または`''`)と`\\`を使用してエスケープする必要があります。
:::

### 数値 {#numeric}

数値リテラルは以下のように解析されます:

- リテラルにマイナス記号`-`が前置されている場合、トークンはスキップされ、解析後に結果が否定されます。
- 数値リテラルは最初に[strtoull](https://en.cppreference.com/w/cpp/string/byte/strtoul)関数を使用して64ビット符号なし整数として解析されます。
  - 値に`0b`または`0x`/`0X`が前置されている場合、数値はそれぞれ2進数または16進数として解析されます。
  - 値が負で絶対値が2<sup>63</sup>より大きい場合、エラーが返されます。
- 解析に失敗した場合、値は次に[strtod](https://en.cppreference.com/w/cpp/string/byte/strtof)関数を使用して浮動小数点数として解析されます。
- それ以外の場合、エラーが返されます。

リテラル値は、その値が収まる最小の型にキャストされます。
例えば:

- `1`は`UInt8`として解析されます
- `256`は`UInt16`として解析されます。

:::note 重要
64ビットより広い整数値(`UInt128`、`Int128`、`UInt256`、`Int256`)を正しく解析するには、より大きな型にキャストする必要があります:

```sql
-170141183460469231731687303715884105728::Int128
340282366920938463463374607431768211455::UInt128
-57896044618658097711785492504343953926634992332820282019728792003956564819968::Int256
115792089237316195423570985008687907853269984665640564039457584007913129639935::UInt256
```

これにより上記のアルゴリズムがバイパスされ、任意精度をサポートするルーチンで整数が解析されます。

そうしない場合、リテラルは浮動小数点数として解析され、切り捨てによる精度の損失が発生します。
:::

詳細については、[データ型](../sql-reference/data-types/index.md)を参照してください。

数値リテラル内のアンダースコア`_`は無視され、可読性を向上させるために使用できます。

以下の数値リテラルがサポートされています:


| 数値リテラル                              | 例                                              |
| ----------------------------------------- | ----------------------------------------------- |
| **整数**                                  | `1`, `10_000_000`, `18446744073709551615`, `01` |
| **小数**                                  | `0.1`                                           |
| **指数表記**                              | `1e100`, `-1e-100`                              |
| **浮動小数点数**                          | `123.456`, `inf`, `nan`                         |
| **16進数**                                | `0xc0fe`                                        |
| **SQL標準互換16進数文字列**               | `x'c0fe'`                                       |
| **2進数**                                 | `0b1101`                                        |
| **SQL標準互換2進数文字列**                | `b'1101'`                                       |

:::note
8進数リテラルは、解釈時の誤りを避けるためサポートされていません。
:::

### 複合型 {#compound}

配列は角括弧 `[1, 2, 3]` で構築されます。タプルは丸括弧 `(1, 'Hello, world!', 2)` で構築されます。
厳密には、これらはリテラルではなく、それぞれ配列作成演算子とタプル作成演算子を用いた式です。
配列は少なくとも1つの要素を含む必要があり、タプルは少なくとも2つの要素を含む必要があります。

:::note
`SELECT`クエリの`IN`句にタプルが現れる場合は特殊なケースとなります。
クエリ結果にはタプルを含めることができますが、タプルはデータベースに保存できません（[Memory](../engines/table-engines/special/memory.md)エンジンを使用するテーブルを除く）。
:::

### NULL {#null}

`NULL`は値が欠落していることを示すために使用されます。
テーブルフィールドに`NULL`を格納するには、そのフィールドが[Nullable](../sql-reference/data-types/nullable.md)型である必要があります。

:::note
`NULL`については以下の点に注意してください：

- データ形式（入力または出力）によって、`NULL`は異なる表現を持つ場合があります。詳細については、[データ形式](/interfaces/formats)を参照してください。
- `NULL`の処理には微妙な点があります。たとえば、比較演算の引数の少なくとも1つが`NULL`である場合、その演算の結果も`NULL`になります。乗算、加算、その他の演算についても同様です。各演算のドキュメントを読むことを推奨します。
- クエリでは、[`IS NULL`](/sql-reference/functions/functions-for-nulls#isNull)および[`IS NOT NULL`](/sql-reference/functions/functions-for-nulls#isNotNull)演算子、ならびに関連する関数`isNull`と`isNotNull`を使用して`NULL`をチェックできます。
:::

### ヒアドキュメント {#heredoc}

[ヒアドキュメント](https://en.wikipedia.org/wiki/Here_document)は、元の書式を維持しながら文字列（多くの場合複数行）を定義する方法です。
ヒアドキュメントは、2つの`$`記号の間に配置されるカスタム文字列リテラルとして定義されます。

例：

```sql
SELECT $heredoc$SHOW CREATE VIEW my_view$heredoc$;

┌─'SHOW CREATE VIEW my_view'─┐
│ SHOW CREATE VIEW my_view   │
└────────────────────────────┘
```

:::note

- 2つのヒアドキュメント記号間の値は「そのまま」処理されます。
:::

:::tip

- ヒアドキュメントを使用して、SQLやHTML、XMLコードなどの断片を埋め込むことができます。
:::


## クエリパラメータの定義と使用 {#defining-and-using-query-parameters}

クエリパラメータを使用すると、具体的な識別子の代わりに抽象的なプレースホルダーを含む汎用クエリを記述できます。
クエリパラメータを含むクエリが実行されると、
すべてのプレースホルダーが解決され、実際のクエリパラメータ値に置き換えられます。

クエリパラメータを定義する方法は2つあります:

- `SET param_<name>=<value>`
- `--param_<name>='<value>'`

2番目の方法を使用する場合、コマンドラインで `clickhouse-client` の引数として渡されます。ここで:

- `<name>` はクエリパラメータの名前です。
- `<value>` はその値です。

クエリパラメータは `{<name>: <datatype>}` を使用してクエリ内で参照できます。ここで `<name>` はクエリパラメータ名、`<datatype>` は変換先のデータ型です。

<details>
<summary>SETコマンドを使用した例</summary>

例えば、以下のSQLは `a`、`b`、`c`、`d` という名前のパラメータを定義しており、それぞれ異なるデータ型を持ちます:

```sql
SET param_a = 13;
SET param_b = 'str';
SET param_c = '2022-08-04 18:30:53';
SET param_d = {'10': [11, 12], '13': [14, 15]};

SELECT
   {a: UInt32},
   {b: String},
   {c: DateTime},
   {d: Map(String, Array(UInt8))};

13    str    2022-08-04 18:30:53    {'10':[11,12],'13':[14,15]}
```

</details>

<details>
<summary>clickhouse-clientを使用した例</summary>

`clickhouse-client` を使用している場合、パラメータは `--param_name=value` として指定します。例えば、以下のパラメータは `message` という名前を持ち、`String` として取得されます:

```bash
clickhouse-client --param_message='hello' --query="SELECT {message: String}"

hello
```

クエリパラメータがデータベース、テーブル、関数、またはその他の識別子の名前を表す場合は、その型として `Identifier` を使用します。例えば、以下のクエリは `uk_price_paid` という名前のテーブルから行を返します:

```sql
SET param_mytablename = "uk_price_paid";
SELECT * FROM {mytablename:Identifier};
```

</details>

:::note
クエリパラメータは、任意のSQLクエリの任意の場所で使用できる一般的なテキスト置換ではありません。
主に `SELECT` 文において、識別子やリテラルの代わりに使用されるように設計されています。
:::


## 関数 {#functions}

関数呼び出しは、識別子の後に丸括弧で囲まれた引数リスト(空の場合もあります)を記述します。
標準SQLとは異なり、引数リストが空の場合でも括弧は必須です。
例:

```sql
now()
```

以下の種類があります:

- [通常の関数](/sql-reference/functions/overview)
- [集約関数](/sql-reference/aggregate-functions)

一部の集約関数は、括弧内に2つの引数リストを含むことができます。例:

```sql
quantile (0.9)(x)
```

これらの集約関数は「パラメトリック」関数と呼ばれ、
最初のリストの引数は「パラメータ」と呼ばれます。

:::note
パラメータを持たない集約関数の構文は、通常の関数と同じです。
:::


## 演算子 {#operators}

演算子は、クエリ解析時に優先順位と結合性を考慮して、対応する関数に変換されます。

例えば、以下の式は

```text
1 + 2 * 3 + 4
```

次のように変換されます

```text
plus(plus(1, multiply(2, 3)), 4)`
```


## データ型とデータベーステーブルエンジン {#data-types-and-database-table-engines}

`CREATE`クエリ内のデータ型とテーブルエンジンは、識別子や関数と同様に記述されます。
つまり、括弧内に引数リストを含む場合と含まない場合があります。

詳細については、以下のセクションを参照してください:

- [データ型](/sql-reference/data-types/index.md)
- [テーブルエンジン](/engines/table-engines/index.md)
- [CREATE](/sql-reference/statements/create/index.md)


## 式 {#expressions}

式は以下のいずれかになります:

- 関数
- 識別子
- リテラル
- 演算子の適用
- 括弧内の式
- サブクエリ
- アスタリスク

また、[エイリアス](#expression-aliases)を含むこともできます。

式のリストは、カンマで区切られた1つ以上の式です。
関数と演算子は、引数として式を取ることができます。

定数式は、クエリ解析時(実行前)に結果が確定する式です。
例えば、リテラルを使用した式は定数式です。


## 式のエイリアス {#expression-aliases}

エイリアスは、クエリ内の[式](#expressions)に対してユーザーが定義する名前です。

```sql
expr AS alias
```

上記の構文の各部分について、以下で説明します。

| 構文の部分 | 説明                                                                                                                                       | 例                                                                 | 注記                                                                                                                                                       |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `AS`           | エイリアスを定義するためのキーワード。`SELECT`句では、`AS`キーワードを使用せずにテーブル名またはカラム名のエイリアスを定義できます。 | `SELECT table_name_alias.column_name FROM table_name table_name_alias`. | [CAST](/sql-reference/functions/type-conversion-functions#cast)関数では、`AS`キーワードは別の意味を持ちます。関数の説明を参照してください。 |
| `expr`         | ClickHouseがサポートする任意の式。                                                                                                           | `SELECT column_name * 2 AS double FROM some_table`                      |                                                                                                                                                             |
| `alias`        | `expr`の名前。エイリアスは[識別子](#identifiers)の構文に準拠する必要があります。                                                               | `SELECT "table t".column_name FROM table_name AS "table t"`.            |                                                                                                                                                             |

### 使用上の注意 {#notes-on-usage}

- エイリアスはクエリまたはサブクエリに対してグローバルであり、クエリの任意の箇所で任意の式に対してエイリアスを定義できます。例:

```sql
SELECT (1 AS n) + 2, n
```

- エイリアスはサブクエリ内およびサブクエリ間では参照できません。例えば、次のクエリを実行すると、ClickHouseは`Unknown identifier: num`という例外を生成します:

```sql
SELECT (SELECT sum(b.a) + num FROM b) - a.a AS num FROM a
```

- サブクエリの`SELECT`句で結果カラムに対してエイリアスが定義されている場合、これらのカラムは外側のクエリから参照できます。例:

```sql
SELECT n + m FROM (SELECT 1 AS n, 2 AS m)
```

- カラム名やテーブル名と同じエイリアスには注意が必要です。次の例を考えてみましょう:

```sql
CREATE TABLE t
(
    a Int,
    b Int
)
ENGINE = TinyLog();

SELECT
    argMax(a, b),
    sum(b) AS b
FROM t;

Received exception from server (version 18.14.17):
Code: 184. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: Aggregate function sum(b) is found inside another aggregate function in query.
```

上記の例では、カラム`b`を持つテーブル`t`を宣言しました。
次に、データを選択する際に`sum(b) AS b`というエイリアスを定義しました。
エイリアスはグローバルであるため、
ClickHouseは式`argMax(a, b)`内のリテラル`b`を式`sum(b)`に置き換えました。
この置き換えにより例外が発生しました。

:::note
[prefer_column_name_to_alias](/operations/settings/settings#prefer_column_name_to_alias)を`1`に設定することで、このデフォルトの動作を変更できます。
:::


## Asterisk {#asterisk}

`SELECT`クエリでは、アスタリスクで式を置き換えることができます。
詳細については、[SELECT](/sql-reference/statements/select/index.md#asterisk)セクションを参照してください。

---
title: '概要'
description: 'ClickHouse をオブザーバビリティ基盤として利用する'
slug: /use-cases/observability/introduction
keywords: ['オブザーバビリティ', 'ログ', 'トレース', 'メトリクス', 'OpenTelemetry', 'Grafana', 'OTel']
show_related_blogs: true
doc_type: 'guide'
---

import observability_1 from '@site/static/images/use-cases/observability/observability-1.png';
import observability_2 from '@site/static/images/use-cases/observability/observability-2.png';
import Image from '@theme/IdealImage';


# オブザーバビリティに ClickHouse を活用する



## はじめに {#introduction}

このガイドは、ClickHouse を用いて、ログおよびトレースに特化した SQL ベースの独自オブザーバビリティソリューションを構築したいユーザー向けに作成されています。ここでは、インジェストに関する考慮事項、アクセスパターンに最適化したスキーマ設計、非構造化ログの構造化など、独自ソリューションを構築するうえで必要となるあらゆる側面を取り上げます。

ClickHouse 単体は、オブザーバビリティ向けのいわゆる「箱から出してすぐ使える」ソリューションではありません。しかし、オブザーバビリティデータ向けの非常に高効率なストレージエンジンとして利用でき、他に類を見ない圧縮率ときわめて高速なクエリ応答時間を実現できます。ユーザーがオブザーバビリティソリューションの一部として ClickHouse を利用するためには、ユーザーインターフェースとデータ収集フレームワークの両方が必要です。現時点では、オブザーバビリティシグナルの可視化には **Grafana** を、データ収集には **OpenTelemetry** を使用することを推奨しています（いずれも公式にサポートされている連携です）。

<Image img={observability_1} alt="Simple OTel" size="md"/>

<br />

:::note OpenTelemetry だけではありません
データ収集には OpenTelemetry (OTel) プロジェクトを使用することを推奨していますが、Vector や Fluentd などの他のフレームワークやツールを用いても同様のアーキテクチャを実現できます（Fluent Bit を用いた[例](https://clickhouse.com/blog/kubernetes-logs-to-clickhouse-fluent-bit)を参照してください）。可視化ツールについても、Superset や Metabase などの代替ツールが存在します。
:::



## なぜ ClickHouse を使うのか {#why-use-clickhouse}

あらゆる集中型 Observability ストアで最も重要な機能は、多様なソースから集まる膨大なログデータを高速に集約・分析・検索できることです。この集中管理によりトラブルシューティングが効率化され、サービス障害の根本原因を特定しやすくなります。

ユーザーはコストにこれまで以上に敏感になっており、既成のサービスが提供価値に比べて高価で予測しづらいと感じています。そのため、クエリ性能が許容できる範囲にある、コスト効率が高く予測可能なログストレージの価値はこれまでになく高まっています。

その性能とコスト効率の高さから、ClickHouse は Observability 製品におけるログおよびトレースのストレージエンジンとして、事実上の標準となっています。

より具体的には、次の点から ClickHouse は Observability データの保存に理想的です。

- **圧縮** - Observability データには、HTTP コードやサービス名など、値が限られた集合から取られるフィールドが含まれるのが一般的です。ClickHouse のカラム指向ストレージは、値がソートされた状態で格納されるため、このようなデータを非常に高い圧縮率で保存できます。特に、時系列データ向けの各種専用コーデックと組み合わせることで効果が高まります。他のデータストアでは、JSON 形式など元データと同程度のストレージ容量を必要とするのに対し、ClickHouse はログとトレースを平均で最大 14 倍程度まで圧縮します。大規模な Observability 環境における大幅なストレージ節約に加え、この圧縮によりディスクから読み出すデータ量が減るため、クエリの高速化にも寄与します。
- **高速な集約** - Observability ソリューションでは、エラーレートを示す折れ線グラフやトラフィックソースを示す棒グラフなど、チャートによるデータの可視化が大きな役割を占めます。これらのチャートを支える集約、すなわち GROUP BY は、インシデントの原因調査ワークフローにおいてフィルタを適用した際にも、高速かつ応答性良く動作する必要があります。ClickHouse のカラム指向フォーマットとベクトル化クエリエンジンの組み合わせは高速集約に最適であり、スパースインデックスによりユーザー操作に応じたデータの高速フィルタリングが可能です。
- **高速な線形スキャン** - 他のテクノロジーでは、ログの高速クエリに転置インデックスを用いますが、これは必然的に高いディスクおよびリソース消費につながります。ClickHouse も追加のオプションインデックス種別として転置インデックスを提供していますが、線形スキャンは高度に並列化されており、（別途設定しない限り）マシン上の利用可能な全コアを使用します。これにより、[高度に最適化されたテキストマッチ演算子](/sql-reference/functions/string-search-functions)を用いて、（圧縮後で）毎秒数十 GB のデータを走査してマッチを検索することが可能です。
- **SQL の親しみやすさ** - SQL は、すべてのエンジニアが慣れ親しんでいるユビキタスな言語です。50 年以上の発展を経て、データ分析の事実上の標準言語としての地位を確立しており、現在でも[3 番目に人気のあるプログラミング言語](https://clickhouse.com/blog/the-state-of-sql-based-observability#lingua-franca)です。Observability も、SQL が最適な、数ある「データの問題」のひとつにすぎません。
- **分析関数** - ClickHouse は、SQL クエリをより簡潔かつ記述しやすくするために設計された分析関数で ANSI SQL を拡張しています。これらは、データを多角的に切り分ける必要があるルートコーズ解析を行うユーザーにとって不可欠です。
- **セカンダリインデックス** - ClickHouse は、特定のクエリパターンを高速化するためにブルームフィルターなどのセカンダリインデックスをサポートします。これらはカラム単位で任意に有効化できるため、ユーザーはコストと性能のトレードオフをきめ細かく制御・評価できます。
- **オープンソースとオープン標準** - オープンソースデータベースとして、ClickHouse は OpenTelemetry などのオープン標準を採用しています。プロジェクトにコントリビュートし積極的に参加できる点は魅力であり、同時にベンダーロックインの課題を回避できます。



## いつ観測基盤に ClickHouse を使うべきか {#when-should-you-use-clickhouse-for-observability}

観測データに ClickHouse を用いる場合、ユーザーは SQL ベースのオブザーバビリティを受け入れる必要があります。SQL ベースのオブザーバビリティの経緯については [このブログ記事](https://clickhouse.com/blog/the-state-of-sql-based-observability) を推奨しますが、要約すると次のとおりです。

SQL ベースのオブザーバビリティが適しているのは、次のような場合です:

- あなた、またはあなたのチームが SQL に慣れている（もしくは学びたいと思っている）場合
- ベンダーロックインを避けて拡張性を得るために、OpenTelemetry のようなオープン標準に準拠したい場合
- 収集から保存、可視化まで、オープンソースのイノベーションに支えられたエコシステムを運用する意思がある場合
- 管理対象の観測データ量が中規模から大規模（あるいは非常に大規模）に成長すると見込んでいる場合
- TCO（総所有コスト）を自らコントロールし、観測コストの雪だるま式な増加を避けたい場合
- コストを抑えるためだけに、観測データの保持期間を短くせざるを得ない状況に縛られたくない場合

一方で、SQL ベースのオブザーバビリティが適していない可能性があるのは、次のような場合です:

- SQL を学ぶ（あるいは自動生成する）ことが、あなたやチームにとって魅力的ではない場合
- パッケージ化されたエンドツーエンドのオブザーバビリティソリューションを求めている場合
- 観測データ量がごく小さく（例: &lt;150 GiB）、今後も増加が見込まれない場合
- ユースケースがメトリクス中心で、PromQL を必要とする場合。その場合でも、メトリクスには Prometheus を用いながら、ログとトレースには ClickHouse を利用し、Grafana を使ってプレゼンテーション層で統合することは可能です。
- エコシステムがさらに成熟し、SQL ベースのオブザーバビリティがよりターンキーな形で提供されるまで待ちたい場合



## ログとトレース

Observability のユースケースには、ログ、トレース、メトリクスという 3 つの明確な柱があります。それぞれ異なるデータ型とアクセスパターンを持ちます。

現在、ClickHouse は次の 2 種類の Observability データの保存先として推奨されます。

* **Logs** - ログは、システム内で発生するイベントをタイムスタンプ付きで記録したもので、ソフトウェア動作のさまざまな側面に関する詳細な情報を含みます。ログのデータは一般的に非構造化または半構造化であり、エラーメッセージ、ユーザーアクティビティのログ、システム変更、その他のイベントを含むことがあります。ログは、トラブルシューティング、異常検知、そしてシステム内で問題が発生する前後の具体的なイベントを把握するうえで重要です。

```response
54.36.149.41 - - [22/Jan/2019:03:56:14 +0330] "GET
/filter/27|13%20%D9%85%DA%AF%D8%A7%D9%BE%DB%8C%DA%A9%D8%B3%D9%84,27|%DA%A9%D9%85%D8%AA%D8%B1%20%D8%A7%D8%B2%205%20%D9%85%DA%AF%D8%A7%D9%BE%DB%8C%DA%A9%D8%B3%D9%84,p53 HTTP/1.1" 200 30577 "-" "Mozilla/5.0 (compatible; AhrefsBot/6.1; +http://ahrefs.com/robot/)" "-"
```

* **Traces** - Traces は、分散システム内でリクエストがさまざまなサービスを経由して進む過程を捉え、その経路とパフォーマンスを詳細に示します。Traces のデータはスパンとトレースで構成される高度に構造化された形式であり、リクエストが辿る各ステップとそのタイミング情報をマッピングします。Traces はシステムパフォーマンスに関する有用な洞察を提供し、ボトルネックやレイテンシの問題を特定し、マイクロサービスの効率を最適化するのに役立ちます。

:::note メトリクス
ClickHouse はメトリクスデータの保存にも使用できますが、この柱は ClickHouse においてはまだ成熟度が低く、Prometheus データフォーマットや PromQL への対応など、一部機能のサポートが保留状態です。
:::

### 分散トレーシング

分散トレーシングはオブザーバビリティの重要な機能です。分散トレース（単にトレースとも呼ばれます）は、システム内を通過するリクエストの経路をマッピングします。リクエストはエンドユーザーまたはアプリケーションから発生し、システム全体に広がり、通常はマイクロサービス間の一連のアクションフローを生み出します。このシーケンスを記録し、その後続のイベントを相関付けられるようにすることで、アーキテクチャがどれほど複雑であっても、あるいはサーバーレスであっても、オブザーバビリティのユーザーや SRE がアプリケーションフロー内の問題を診断できるようにします。

各トレースはいくつかのスパンで構成されており、リクエストに関連付けられた最初のスパンはルートスパンと呼ばれます。このルートスパンは、リクエスト全体を開始から終了まで捉えます。ルートの下に続くスパンは、リクエスト中に発生するさまざまなステップや操作についての詳細な洞察を提供します。トレーシングがなければ、分散システムにおけるパフォーマンス問題の診断は非常に困難になり得ます。トレーシングは、リクエストがシステム内を移動する際のイベントシーケンスを詳細化することで、分散システムのデバッグおよび理解のプロセスを容易にします。

多くのオブザーバビリティベンダーは、この情報をウォーターフォール形式で可視化し、相対的なタイミングを長さが比例した横棒で表現します。たとえば Grafana では次のようになります。

<Image img={observability_2} alt="トレースの例" size="lg" border />

ログとトレースの概念を深く理解したいユーザーには、[OpenTelemetry ドキュメント](https://opentelemetry.io/docs/concepts/) を強く推奨します。

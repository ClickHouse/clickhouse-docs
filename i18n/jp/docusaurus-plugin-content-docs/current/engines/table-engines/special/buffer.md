---
description: '書き込みデータを RAM にバッファリングし、定期的に別のテーブルへフラッシュします。読み取り時には、バッファと別のテーブルの両方から同時にデータを読み取ります。'
sidebar_label: 'Buffer'
sidebar_position: 120
slug: /engines/table-engines/special/buffer
title: 'Buffer テーブルエンジン'
doc_type: 'reference'
---



# Bufferテーブルエンジン

書き込むデータをRAMにバッファリングし、定期的に別のテーブルにフラッシュします。読み取り操作では、バッファと別のテーブルの両方から同時にデータが読み取られます。

:::note
Bufferテーブルエンジンの代替として、[非同期挿入](/guides/best-practices/asyncinserts.md)を有効にすることを推奨します。
:::

```sql
Buffer(database, table, num_layers, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes [,flush_time [,flush_rows [,flush_bytes]]])
```

### エンジンパラメータ {#engine-parameters}

#### `database` {#database}

`database` – データベース名。`currentDatabase()`または文字列を返す他の定数式を使用できます。

#### `table` {#table}

`table` – データのフラッシュ先テーブル。

#### `num_layers` {#num_layers}

`num_layers` – 並列化レイヤー。物理的には、テーブルは`num_layers`個の独立したバッファとして表現されます。

#### `min_time`、`max_time`、`min_rows`、`max_rows`、`min_bytes`、および`max_bytes` {#min_time-max_time-min_rows-max_rows-min_bytes-and-max_bytes}

バッファからデータをフラッシュする条件。

### オプションのエンジンパラメータ {#optional-engine-parameters}

#### `flush_time`、`flush_rows`、および`flush_bytes` {#flush_time-flush_rows-and-flush_bytes}

バックグラウンドでバッファからデータをフラッシュする条件（省略またはゼロの場合は`flush*`パラメータなしを意味します）。

すべての`min*`条件が満たされるか、少なくとも1つの`max*`条件が満たされた場合、データはバッファからフラッシュされ、宛先テーブルに書き込まれます。

また、少なくとも1つの`flush*`条件が満たされた場合、バックグラウンドでフラッシュが開始されます。これは`max*`とは異なり、`flush*`ではBufferテーブルへの`INSERT`クエリにレイテンシを追加しないよう、バックグラウンドフラッシュを個別に設定できます。

#### `min_time`、`max_time`、および`flush_time` {#min_time-max_time-and-flush_time}

バッファへの最初の書き込みからの経過時間（秒）の条件。

#### `min_rows`、`max_rows`、および`flush_rows` {#min_rows-max_rows-and-flush_rows}

バッファ内の行数の条件。

#### `min_bytes`、`max_bytes`、および`flush_bytes` {#min_bytes-max_bytes-and-flush_bytes}

バッファ内のバイト数の条件。

書き込み操作では、データは1つ以上のランダムなバッファ（`num_layers`で設定）に挿入されます。または、挿入するデータ部分が十分に大きい場合（`max_rows`または`max_bytes`より大きい場合）、バッファを経由せずに宛先テーブルに直接書き込まれます。

データをフラッシュする条件は、`num_layers`個の各バッファに対して個別に計算されます。例えば、`num_layers = 16`かつ`max_bytes = 100000000`の場合、最大RAM消費量は1.6 GBとなります。

例:

```sql
CREATE TABLE merge.hits_buffer AS merge.hits ENGINE = Buffer(merge, hits, 1, 10, 100, 10000, 1000000, 10000000, 100000000)
```

`merge.hits`と同じ構造を持つ`merge.hits_buffer`テーブルを作成し、Bufferエンジンを使用します。このテーブルへの書き込み時には、データはRAMにバッファリングされ、後で'merge.hits'テーブルに書き込まれます。単一のバッファが作成され、以下のいずれかの条件でデータがフラッシュされます:

- 最後のフラッシュから100秒が経過した場合（`max_time`）、または
- 100万行が書き込まれた場合（`max_rows`）、または
- 100 MBのデータが書き込まれた場合（`max_bytes`）、または
- 10秒が経過し（`min_time`）、かつ10,000行（`min_rows`）、かつ10 MB（`min_bytes`）のデータが書き込まれた場合

例えば、1行だけが書き込まれた場合、100秒後には必ずフラッシュされます。しかし、多数の行が書き込まれた場合は、データはより早くフラッシュされます。

サーバーが停止した場合、`DROP TABLE`または`DETACH TABLE`の実行時には、バッファリングされたデータも宛先テーブルにフラッシュされます。

データベース名とテーブル名には、単一引用符で囲んだ空文字列を設定できます。これは宛先テーブルが存在しないことを示します。この場合、データフラッシュ条件に達すると、バッファは単純にクリアされます。これは、メモリ内にデータのウィンドウを保持する際に有用です。


Buffer テーブルから読み取る場合、データは（存在する場合は）バッファと宛先テーブルの両方から処理されます。
なお、Buffer テーブルはインデックスをサポートしません。言い換えると、バッファ内のデータはフルスキャンする必要があり、大きなバッファでは処理が遅くなる可能性があります（従属テーブル内のデータについては、そのテーブルがサポートするインデックスが使用されます）。

Buffer テーブル内の列集合が従属テーブルの列集合と一致しない場合、両方のテーブルに存在する列の部分集合のみが挿入されます。

Buffer テーブルと従属テーブルのいずれかの列で型が一致しない場合、エラーメッセージがサーバーログに出力され、バッファはクリアされます。
バッファをフラッシュする時点で従属テーブルが存在しない場合も同様です。

:::note
2021 年 10 月 26 日以前のリリースで Buffer テーブルに対して ALTER を実行すると `Block structure mismatch` エラーが発生します（[#15117](https://github.com/ClickHouse/ClickHouse/issues/15117) および [#30565](https://github.com/ClickHouse/ClickHouse/pull/30565) を参照）。そのため、Buffer テーブルを削除してから再作成する以外に方法はありません。Buffer テーブルに対して ALTER を実行しようとする前に、このエラーが使用中のリリースで修正されていることを確認してください。
:::

サーバーが異常終了した場合、バッファ内のデータは失われます。

`FINAL` および `SAMPLE` は Buffer テーブルに対して正しく動作しません。これらの条件は宛先テーブルに渡されますが、バッファ内データの処理には使用されません。これらの機能が必要な場合は、書き込みにのみ Buffer テーブルを使用し、読み取りは宛先テーブルから行うことを推奨します。

Buffer テーブルにデータを追加する際には、いずれかのバッファがロックされます。これにより、テーブルからの読み取り操作が同時に行われている場合に遅延が発生します。

Buffer テーブルに挿入されたデータは、従属テーブル内で異なる順序や異なるブロックに配置される可能性があります。このため、Buffer テーブルを使用して CollapsingMergeTree に正しく書き込むことは困難です。問題を回避するには、`num_layers` を 1 に設定できます。

宛先テーブルがレプリケートされている場合、Buffer テーブルへの書き込み時には、レプリケートテーブルに期待される特性の一部が失われます。行の順序やデータパーツのサイズがランダムに変化することでデータの重複排除が機能しなくなり、レプリケートテーブルへの信頼できる「exactly once」（厳密に 1 回だけ）の書き込みを行うことができなくなります。

これらの欠点により、Buffer テーブルの使用はまれなケースにのみ推奨されます。

Buffer テーブルは、ある時間単位あたりに多数のサーバーから非常に多くの INSERT を受け取り、挿入前にデータをバッファリングできず、その結果 INSERT が十分な速度で実行できない場合に使用されます。

Buffer テーブルであっても、1 行ずつデータを挿入することは意味がない点に注意してください。この方法では毎秒数千行程度しか処理できませんが、より大きなブロックでデータを挿入すれば、毎秒 100 万行以上の速度を達成できます。

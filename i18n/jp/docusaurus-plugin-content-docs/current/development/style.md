---
description: 'ClickHouse における C++ 開発のためのコーディングスタイルガイド'
sidebar_label: 'C++ スタイルガイド'
sidebar_position: 70
slug: /development/style
title: 'C++ スタイルガイド'
doc_type: 'guide'
---



# C++ スタイルガイド



## 一般的な推奨事項 {#general-recommendations}

以下は推奨事項であり、必須要件ではありません。
コードを編集する際は、既存のコードのフォーマットに従うことが望ましいです。
コードスタイルは一貫性を保つために必要です。一貫性により、コードが読みやすくなり、検索も容易になります。
多くのルールには論理的な理由はなく、確立された慣行に基づいて定められています。


## フォーマット {#formatting}

**1.** フォーマットのほとんどは `clang-format` によって自動的に行われます。

**2.** インデントは4スペースです。タブで4スペースが追加されるように開発環境を設定してください。

**3.** 開き波括弧と閉じ波括弧は別の行に配置する必要があります。

```cpp
inline void readBoolText(bool & x, ReadBuffer & buf)
{
    char tmp = '0';
    readChar(tmp, buf);
    x = tmp != '0';
}
```

**4.** 関数本体全体が単一の `statement` である場合、1行に配置できます。波括弧の周囲にスペースを配置してください(行末のスペースを除く)。

```cpp
inline size_t mask() const                { return buf_size() - 1; }
inline size_t place(HashValue x) const    { return x & mask(); }
```

**5.** 関数の場合、括弧の周囲にスペースを入れないでください。

```cpp
void reinsert(const Value & x)
```

```cpp
memcpy(&buf[place_value], &x, sizeof(x));
```

**6.** `if`、`for`、`while` およびその他の式では、開き括弧の前にスペースを挿入します(関数呼び出しとは対照的に)。

```cpp
for (size_t i = 0; i < rows; i += storage.index_granularity)
```

**7.** 二項演算子(`+`、`-`、`*`、`/`、`%`、...)および三項演算子 `?:` の周囲にスペースを追加してください。

```cpp
UInt16 year = (s[0] - '0') * 1000 + (s[1] - '0') * 100 + (s[2] - '0') * 10 + (s[3] - '0');
UInt8 month = (s[5] - '0') * 10 + (s[6] - '0');
UInt8 day = (s[8] - '0') * 10 + (s[9] - '0');
```

**8.** 改行を入れる場合は、演算子を新しい行に配置し、その前のインデントを増やしてください。

```cpp
if (elapsed_ns)
    message << " ("
        << rows_read_on_server * 1000000000 / elapsed_ns << " rows/s., "
        << bytes_read_on_server * 1000.0 / elapsed_ns << " MB/s.) ";
```

**9.** 必要に応じて、行内の整列にスペースを使用できます。

```cpp
dst.ClickLogID         = click.LogID;
dst.ClickEventID       = click.EventID;
dst.ClickGoodEvent     = click.GoodEvent;
```

**10.** 演算子 `.`、`->` の周囲にスペースを使用しないでください。

必要に応じて、演算子を次の行に折り返すことができます。この場合、その前のオフセットを増やします。

**11.** 単項演算子(`--`、`++`、`*`、`&`、...)と引数を区切るためにスペースを使用しないでください。

**12.** カンマの後にスペースを入れますが、前には入れません。同じ規則が `for` 式内のセミコロンにも適用されます。

**13.** `[]` 演算子を区切るためにスペースを使用しないでください。

**14.** `template <...>` 式では、`template` と `<` の間にスペースを使用します。`<` の後または `>` の前にはスペースを入れません。

```cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
{}
```

**15.** クラスと構造体では、`public`、`private`、`protected` を `class/struct` と同じレベルに記述し、残りのコードをインデントします。

```cpp
template <typename T>
class MultiVersion
{
public:
    /// Version of object for usage. shared_ptr manage lifetime of version.
    using Version = std::shared_ptr<const T>;
    ...
}
```

**16.** ファイル全体で同じ `namespace` が使用され、他に重要なものがない場合、`namespace` 内でオフセットは必要ありません。

**17.** `if`、`for`、`while`、またはその他の式のブロックが単一の `statement` で構成されている場合、波括弧は省略可能です。代わりに `statement` を別の行に配置してください。この規則は、ネストされた `if`、`for`、`while`、... にも有効です。

ただし、内側の `statement` に波括弧または `else` が含まれている場合、外側のブロックは波括弧で記述する必要があります。

```cpp
/// 書き込みを終了する。
for (auto & stream : streams)
    stream.second->finalize();
```

**18.** 行末にスペースを入れないでください。

**19.** ソースファイルはUTF-8でエンコードされています。


**20.** 文字列リテラルでは、ASCII 以外の文字を使用できます。

```cpp
<< ", " << (timer.elapsed() / chunks_stats.hits) << " μsec/hit.";
```

**21.** 1 行の中に複数の式を書かないでください。

**22.** 関数内のコードは意味のまとまりごとにまとめ、まとまり同士の間は空行は最大 1 行までとしてください。

**23.** 関数やクラスなどは、1 行または 2 行の空行で区切ってください。

**24.** `A const`（値に対するもの）は、型名の前に書かなければなりません。

```cpp
//正しい
const char * pos
const std::string & s
//誤り
char const * pos
```

**25.** ポインタまたは参照を宣言する際は、`*` および `&` 記号の両側にスペースを入れること。

```cpp
//正しい
const char * pos
//誤り
const char* pos
const char *pos
```

**26.** テンプレート型を使用する場合は（ごく単純な場合を除き）、`using` キーワードでエイリアスを定義します。

言い換えると、テンプレートパラメータは `using` 宣言においてのみ指定し、コード中で繰り返さないようにします。

`using` は、関数内などのローカルスコープでも宣言できます。

```cpp
//正しい例
using FileStreams = std::map<std::string, std::shared_ptr<Stream>>;
FileStreams streams;
//誤った例
std::map<std::string, std::shared_ptr<Stream>> streams;
```

**27.** 1つの宣言文で、異なる型の変数を複数宣言しないこと。

```cpp
//不適切
int x, *y;
```

**28.** Cスタイルのキャストは使用しないこと。

```cpp
//不適切
std::cerr << (int)c <<; std::endl;
//適切
std::cerr << static_cast<int>(c) << std::endl;
```

**29.** クラスおよび構造体では、各可視性のスコープごとにメンバーと関数を分けてまとめます。

**30.** 小さなクラスおよび構造体では、メソッドの宣言と実装を分離する必要はありません。

これは、あらゆるクラスや構造体における小さなメソッドについても同様です。

テンプレートクラスおよび構造体では、メソッドの宣言と実装を分離しないでください（そうしないと同じ翻訳単位内で定義しなければならないためです）。

**31.** 行の折り返しは、80 文字ではなく 140 文字で行ってかまいません。

**32.** 後置が必要でない場合は、常に前置インクリメント／デクリメント演算子を使用してください。

```cpp
for (Names::const_iterator it = column_names.begin(); it != column_names.end(); ++it)
```


## コメント {#comments}

**1.** コードの自明でない部分すべてに必ずコメントを追加してください。

これは非常に重要です。コメントを書くことで、そのコードが不要であることや、設計が誤っていることに気づくことがあります。

```cpp
/** 使用可能なメモリの一部。
  * 例えば、internal_bufferが1MBで、ファイルから読み取り用にバッファに10バイトのみがロードされた場合、
  * working_bufferのサイズは10バイトのみになります
  * (working_buffer.end()は、読み取り可能なこれら10バイトの直後の位置を指します)。
  */
```

**2.** コメントは必要に応じて詳細に記述できます。

**3.** コメントは説明対象のコードの前に配置してください。まれに、コメントをコードの後ろの同じ行に記述することもできます。

```cpp
/** クエリを解析して実行します。
*/
void executeQuery(
    ReadBuffer & istr, /// クエリの読み取り元(該当する場合はINSERTのデータも含む)
    WriteBuffer & ostr, /// 結果の書き込み先
    Context & context, /// DB、テーブル、データ型、エンジン、関数、集約関数など...
    BlockInputStreamPtr & query_plan, /// クエリがどのように実行されたかの説明をここに記述できます
    QueryProcessingStage::Enum stage = QueryProcessingStage::Complete /// SELECTクエリをどの段階まで処理するか
    )
```

**4.** コメントは英語のみで記述してください。

**5.** ライブラリを作成する場合は、メインヘッダーファイルにそれを説明する詳細なコメントを含めてください。

**6.** 追加情報を提供しないコメントは追加しないでください。特に、次のような空のコメントは残さないでください。

```cpp
/*
* プロシージャ名:
* 元のプロシージャ名:
* 作成者:
* 作成日:
* 変更日:
* 変更者:
* 元のファイル名:
* 目的:
* 意図:
* 指定:
* 使用されるクラス:
* 定数:
* ローカル変数:
* パラメータ:
* 作成日:
* 目的:
*/
```

この例はリソース http://home.tamk.fi/~jaalto/course/coding-style/doc/unmaintainable-code/ から引用しています。

**7.** 各ファイルの先頭に不要なコメント(作成者、作成日など)を記述しないでください。

**8.** 単一行コメントは3つのスラッシュ `///` で始まり、複数行コメントは `/**` で始まります。これらのコメントは「ドキュメント」とみなされます。

注意: これらのコメントからドキュメントを生成するためにDoxygenを使用できます。ただし、IDEでコードをナビゲートする方が便利であるため、Doxygenは一般的には使用されません。

**9.** 複数行コメントの先頭と末尾に空行を入れてはいけません(複数行コメントを閉じる行を除く)。

**10.** コードをコメントアウトする場合は、「ドキュメント」コメントではなく、基本的なコメントを使用してください。

**11.** コミットする前に、コメントアウトされたコード部分を削除してください。

**12.** コメントやコードで不適切な言葉を使用しないでください。

**13.** 大文字を使用しないでください。過度な句読点を使用しないでください。

```cpp
/// WHAT THE FAIL???
```

**14.** 区切り文字を作成するためにコメントを使用しないでください。

```cpp
///******************************************************
```

**15.** コメント内で議論を始めないでください。

```cpp
/// Why did you do this stuff?
```

**16.** ブロックの末尾にそれが何についてのものかを説明するコメントを書く必要はありません。

```cpp
/// for
```


## 命名規則 {#names}

**1.** 変数名とクラスメンバー名には、小文字とアンダースコアを使用します。

```cpp
size_t max_block_size;
```

**2.** 関数(メソッド)名には、小文字で始まるキャメルケースを使用します。

```cpp
std::string getName() const override { return "Memory"; }
```

**3.** クラス(構造体)名には、大文字で始まるキャメルケースを使用します。インターフェースには、I以外の接頭辞は使用しません。

```cpp
class StorageMemory : public IStorage
```

**4.** `using`はクラスと同じ方法で命名します。

**5.** テンプレート型引数の名前:単純な場合は`T`、`T`と`U`、または`T1`、`T2`を使用します。

より複雑な場合は、クラス名の規則に従うか、接頭辞`T`を追加します。

```cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
```

**6.** テンプレート定数引数の名前:変数名の規則に従うか、単純な場合は`N`を使用します。

```cpp
template <bool without_www>
struct ExtractDomain
```

**7.** 抽象クラス(インターフェース)には、接頭辞`I`を追加できます。

```cpp
class IProcessor
```

**8.** 変数をローカルで使用する場合は、短い名前を使用できます。

それ以外の場合は、意味を説明する名前を使用します。

```cpp
bool info_successfully_loaded = false;
```

**9.** `define`とグローバル定数の名前には、アンダースコア付きの全て大文字を使用します。

```cpp
#define MAX_SRC_TABLE_NAMES_TO_STORE 1000
```

**10.** ファイル名は、その内容と同じスタイルを使用する必要があります。

ファイルに単一のクラスが含まれている場合は、クラスと同じ方法でファイルに名前を付けます(キャメルケース)。

ファイルに単一の関数が含まれている場合は、関数と同じ方法でファイルに名前を付けます(キャメルケース)。

**11.** 名前に略語が含まれている場合:

- 変数名の場合、略語は小文字を使用する必要があります `mysql_connection`(`mySQL_connection`ではありません)。
- クラス名と関数名の場合、略語の大文字を保持します`MySQLConnection`(`MySqlConnection`ではありません)。

**12.** クラスメンバーを初期化するためだけに使用されるコンストラクタ引数は、クラスメンバーと同じ方法で命名する必要がありますが、末尾にアンダースコアを付けます。

```cpp
FileQueueProcessor(
    const std::string & path_,
    const std::string & prefix_,
    std::shared_ptr<FileHandler> handler_)
    : path(path_),
    prefix(prefix_),
    handler(handler_),
    log(&Logger::get("FileQueueProcessor"))
{
}
```

引数がコンストラクタ本体で使用されない場合、アンダースコアの接尾辞は省略できます。

**13.** ローカル変数とクラスメンバーの名前に違いはありません(接頭辞は不要です)。

```cpp
timer (not m_timer)
```

**14.** `enum`内の定数には、大文字で始まるキャメルケースを使用します。全て大文字も許容されます。`enum`が非ローカルの場合は、`enum class`を使用します。

```cpp
enum class CompressionMethod
{
    QuickLZ = 0,
    LZ4     = 1,
};
```

**15.** すべての名前は英語である必要があります。ヘブライ語の音訳は許可されていません。

    T_PAAMAYIM_NEKUDOTAYIMは不可

**16.** 略語は、よく知られている場合(Wikipediaや検索エンジンで略語の意味を簡単に見つけることができる場合)に許容されます。

    `AST`、`SQL`

    `NVDH`(ランダムな文字)は不可

短縮版が一般的に使用されている場合、不完全な単語は許容されます。

コメント内に完全な名前が隣接して含まれている場合は、略語を使用することもできます。

**17.** C++ソースコードを含むファイル名には、`.cpp`拡張子が必要です。ヘッダーファイルには、`.h`拡張子が必要です。


## コードの書き方 {#how-to-write-code}

**1.** メモリ管理

手動メモリ解放（`delete`）はライブラリコードでのみ使用できます。

ライブラリコードでは、`delete`演算子はデストラクタ内でのみ使用できます。

アプリケーションコードでは、メモリはそれを所有するオブジェクトによって解放される必要があります。

例：

- 最も簡単な方法は、オブジェクトをスタックに配置するか、別のクラスのメンバーにすることです。
- 多数の小さなオブジェクトには、コンテナを使用します。
- ヒープに存在する少数のオブジェクトの自動解放には、`shared_ptr/unique_ptr`を使用します。

**2.** リソース管理

`RAII`を使用し、上記を参照してください。

**3.** エラー処理

例外を使用します。ほとんどの場合、例外をスローするだけで、キャッチする必要はありません（`RAII`のため）。

オフラインデータ処理アプリケーションでは、例外をキャッチしないことが許容される場合が多くあります。

ユーザーリクエストを処理するサーバーでは、通常、接続ハンドラの最上位レベルで例外をキャッチすれば十分です。

スレッド関数では、すべての例外をキャッチして保持し、`join`後にメインスレッドで再スローする必要があります。

```cpp
/// まだ計算が行われていない場合は、最初のブロックを同期的に計算する
if (!started)
{
    calculate();
    started = true;
}
else /// 計算がすでに進行中の場合は、結果を待つ
    pool.wait();

if (exception)
    exception->rethrow();
```

例外を処理せずに隠してはいけません。すべての例外を盲目的にログに記録するだけにしてはいけません。

```cpp
//正しくない
catch (...) {}
```

一部の例外を無視する必要がある場合は、特定のものに対してのみ行い、残りは再スローしてください。

```cpp
catch (const DB::Exception & e)
{
    if (e.code() == ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION)
        return nullptr;
    else
        throw;
}
```

レスポンスコードや`errno`を持つ関数を使用する場合は、常に結果を確認し、エラーの場合は例外をスローしてください。

```cpp
if (0 != close(fd))
    throw ErrnoException(ErrorCodes::CANNOT_CLOSE_FILE, "Cannot close file {}", file_name);
```

コード内の不変条件をチェックするためにassertを使用できます。

**4.** 例外の型

アプリケーションコードで複雑な例外階層を使用する必要はありません。例外テキストはシステム管理者が理解できるものである必要があります。

**5.** デストラクタからの例外のスロー

これは推奨されませんが、許可されています。

以下のオプションを使用してください：

- 例外につながる可能性のあるすべての作業を事前に行う関数（`done()`または`finalize()`）を作成します。その関数が呼び出された場合、後でデストラクタで例外が発生しないようにする必要があります。
- 複雑すぎるタスク（ネットワーク経由でメッセージを送信するなど）は、クラスのユーザーが破棄前に呼び出す必要がある別のメソッドに配置できます。
- デストラクタで例外が発生した場合、それを隠すよりもログに記録する方が良いです（ロガーが利用可能な場合）。
- シンプルなアプリケーションでは、例外を処理するために`std::terminate`（C++11でデフォルトの`noexcept`の場合）に依存することが許容されます。

**6.** 無名コードブロック

特定の変数をローカルにするために、単一の関数内に別のコードブロックを作成できます。これにより、ブロックを終了するときにデストラクタが呼び出されます。

```cpp
Block block = data.in->read();

{
    std::lock_guard<std::mutex> lock(mutex);
    data.ready = true;
    data.block = block;
}

ready_any.set();
```

**7.** マルチスレッド

オフラインデータ処理プログラムでは：

- 単一のCPUコアで可能な限り最高のパフォーマンスを得るようにしてください。必要に応じて、コードを並列化できます。

サーバーアプリケーションでは：

- リクエストを処理するためにスレッドプールを使用します。現時点では、ユーザー空間のコンテキストスイッチングを必要とするタスクはありません。

並列化にはforkは使用されません。

**8.** スレッドの同期

多くの場合、異なるスレッドが異なるメモリセル（さらに良いのは異なるキャッシュライン）を使用し、スレッド同期を使用しない（`joinAll`を除く）ことが可能です。

同期が必要な場合、ほとんどの場合、`lock_guard`の下でmutexを使用すれば十分です。

その他の場合は、システム同期プリミティブを使用してください。ビジーウェイトは使用しないでください。

アトミック操作は最も単純な場合にのみ使用する必要があります。

それがあなたの主要な専門分野でない限り、ロックフリーデータ構造を実装しようとしないでください。

**9.** ポインタと参照

ほとんどの場合、参照を優先してください。

**10.** `const`

定数参照、定数へのポインタ、`const_iterator`、および`const`メソッドを使用してください。

`const`をデフォルトと考え、必要な場合にのみ非`const`を使用してください。


変数を値渡しする場合、`const` を使うことには通常意味がありません。

**11.** unsigned。

必要に応じて `unsigned` を使用します。

**12.** 数値型。

`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64`、および `size_t`、`ssize_t`、`ptrdiff_t` 型を使用します。

次の型は数値型として使用しないでください: `signed/unsigned long`、`long long`、`short`、`signed/unsigned char`、`char`。

**13.** 引数の受け渡し。

複雑な値がムーブされる場合は値渡しを行い、`std::move` を使用します。ループ内で値を更新したい場合は参照渡しを行います。

関数がヒープ上で生成されたオブジェクトの所有権を取得する場合、引数の型は `shared_ptr` または `unique_ptr` にします。

**14.** 戻り値。

ほとんどの場合は単に `return` を使用します。`return std::move(res)` と書かないでください。

関数がヒープ上にオブジェクトを確保してそれを返す場合は、`shared_ptr` または `unique_ptr` を使用します。

まれに（ループ内で値を更新する場合など）引数経由で値を返す必要があるかもしれません。この場合、その引数は参照とするべきです。

```cpp
using AggregateFunctionPtr = std::shared_ptr<IAggregateFunction>;

/** 名前から集約関数を作成します。
  */
class AggregateFunctionFactory
{
public:
    AggregateFunctionFactory();
    AggregateFunctionPtr get(const String & name, const DataTypes & argument_types) const;
```

**15.** `namespace`.

アプリケーションコード用に、別個の `namespace` を用意する必要はありません。

小規模なライブラリでも同様に不要です。

中規模から大規模のライブラリでは、すべてを `namespace` の中にまとめてください。

ライブラリの `.h` ファイルでは、アプリケーションコードには不要な実装の詳細を隠すために、`namespace detail` を使用できます。

`.cpp` ファイルでは、シンボルを隠すために `static` または無名の `namespace` を使用できます。

また、`enum` に対して `namespace` を使用することで、対応する名前が外側の `namespace` に出てしまうのを防ぐことができます（ただし、`enum class` を使うほうが望ましいです）。

**16.** 遅延初期化。

初期化に引数が必要な場合、通常はデフォルトコンストラクタは定義すべきではありません。

後になって初期化を遅らせる必要が出てきた場合は、無効なオブジェクトを生成するデフォルトコンストラクタを追加できます。あるいは、オブジェクトの数が少ない場合は、`shared_ptr/unique_ptr` を使用することもできます。

```cpp
Loader(DB::Connection * connection_, const std::string & query, size_t max_block_size_);

/// 遅延初期化用
Loader() {}
```

**17.** 仮想関数。

クラスがポリモーフィズム（多態性）の用途を意図していない場合、関数を `virtual` にする必要はありません。これはデストラクタにも当てはまります。

**18.** エンコーディング。

常に UTF-8 を使用します。`std::string` と `char *` を使用してください。`std::wstring` と `wchar_t` は使用しないでください。

**19.** ログ出力。

コード中の各所にあるサンプルを参照してください。

コミットする前に、意味のないログやデバッグ用ログ、その他あらゆる種類のデバッグ出力を削除してください。

ループ内でのログ出力は、`Trace` レベルであっても避けるべきです。

ログは、どのログレベルでも読みやすくなければなりません。

ログ出力は、主としてアプリケーションコード内でのみ使用してください。

ログメッセージは英語で記述しなければなりません。

ログは、可能であればシステム管理者が理解できる内容であるべきです。

ログに不適切な表現（罵り言葉など）を使用しないでください。

ログでは UTF-8 エンコーディングを使用してください。まれなケースでは、ログ内で非 ASCII 文字を使用しても構いません。

**20.** 入出力。

アプリケーション性能にとって重要な内部ループでは `iostreams` を使用しないでください（`stringstream` は決して使用しないでください）。

代わりに `DB/IO` ライブラリを使用してください。

**21.** 日付と時刻。

`DateLUT` ライブラリを参照してください。

**22.** include。

インクルードガードの代わりに常に `#pragma once` を使用してください。

**23.** using。

`using namespace` は使用しません。特定の名前に対して `using` を使用しても構いません。ただし、クラスまたは関数の内部のローカルな範囲に限定してください。

**24.** 必要な場合を除き、関数に末尾戻り値記法（`trailing return type`）を使用しないでください。

```cpp
auto f() -> void
```

**25.** 変数の宣言と初期化

```cpp
//正しい方法
std::string s = "Hello";
std::string s{"Hello"};

//間違った方法
auto s = std::string{"Hello"};
```

**26.** 仮想関数については、基底クラスでは `virtual` を記述し、派生クラスでは `virtual` の代わりに `override` を記述します。


## C++の未使用機能 {#unused-features-of-c}

**1.** 仮想継承は使用されていません。

**2.** モダンC++において便利な糖衣構文を持つ構造。例:

```cpp
// 糖衣構文を使わない従来の方法
template <typename G, typename = std::enable_if_t<std::is_same<G, F>::value, void>> // std::enable_ifによるSFINAE、::valueの使用
std::pair<int, int> func(const E<G> & e) // 明示的に指定された戻り値の型
{
    if (elements.count(e)) // .count()によるメンバーシップテスト
    {
        // ...
    }

    elements.erase(
        std::remove_if(
            elements.begin(), elements.end(),
            [&](const auto x){
                return x == 1;
            }),
        elements.end()); // remove-eraseイディオム

    return std::make_pair(1, 2); // make_pair()によるペアの作成
}

// 糖衣構文を使用した場合(C++14/17/20)
template <typename G>
requires std::same_v<G, F> // C++20コンセプトによるSFINAE、C++14テンプレートエイリアスの使用
auto func(const E<G> & e) // auto戻り値型(C++14)
{
    if (elements.contains(e)) // C++20の.containsによるメンバーシップテスト
    {
        // ...
    }

    elements.erase_if(
        elements,
        [&](const auto x){
            return x == 1;
        }); // C++20のstd::erase_if

    return {1, 2}; // または: return std::pair(1, 2); // 初期化リストまたは値初期化によるペアの作成(C++17)
}
```


## プラットフォーム {#platform}

**1.** 特定のプラットフォーム向けにコードを記述します。

ただし、他の条件が同じであれば、クロスプラットフォームまたは移植可能なコードが推奨されます。

**2.** 言語: C++20(利用可能な[C++20機能](https://en.cppreference.com/w/cpp/compiler_support#C.2B.2B20_features)の一覧を参照)。

**3.** コンパイラ: `clang`。本文書執筆時点(2025年3月)では、clangバージョン19以上を使用してコードをコンパイルしています。

標準ライブラリ(`libc++`)を使用します。

**4.** OS: Linux Ubuntu、Precise以降のバージョン。

**5.** コードはx86_64 CPUアーキテクチャ向けに記述されています。

CPU命令セットは、当社のサーバー間でサポートされる最小セットです。現在はSSE 4.2です。

**6.** いくつかの例外を除き、`-Wall -Wextra -Werror -Weverything`コンパイルフラグを使用します。

**7.** 静的リンクが困難なライブラリを除き、すべてのライブラリで静的リンクを使用します(`ldd`コマンドの出力を参照)。

**8.** コードはリリース設定で開発およびデバッグされます。


## ツール {#tools}

**1.** KDevelopは優れたIDEです。

**2.** デバッグには、`gdb`、`valgrind`（`memcheck`）、`strace`、`-fsanitize=...`、または`tcmalloc_minimal_debug`を使用します。

**3.** プロファイリングには、`Linux Perf`、`valgrind`（`callgrind`）、または`strace -cf`を使用します。

**4.** ソースコードはGitで管理されています。

**5.** ビルドには`CMake`を使用します。

**6.** プログラムは`deb`パッケージでリリースされます。

**7.** masterへのコミットはビルドを破壊してはいけません。

ただし、選択されたリビジョンのみが動作可能とみなされます。

**8.** コードが部分的にしか完成していない場合でも、可能な限り頻繁にコミットしてください。

この目的のためにブランチを使用してください。

`master`ブランチのコードがまだビルド可能でない場合は、`push`する前にビルドから除外してください。数日以内に完成させるか削除する必要があります。

**9.** 重要でない変更については、ブランチを使用してサーバーに公開してください。

**10.** 使用されていないコードはリポジトリから削除されます。


## ライブラリ {#libraries}

**1.** C++20標準ライブラリを使用します(実験的な拡張機能の使用も可)。また、`boost`および`Poco`フレームワークも使用します。

**2.** OSパッケージのライブラリの使用は許可されていません。プリインストールされたライブラリの使用も同様に許可されていません。すべてのライブラリは、ソースコードの形式で`contrib`ディレクトリに配置し、ClickHouseと共にビルドする必要があります。詳細については、[サードパーティライブラリを追加するためのガイドライン](/development/contrib#adding-and-maintaining-third-party-libraries)を参照してください。

**3.** 既に使用されているライブラリを常に優先します。


## 一般的な推奨事項 {#general-recommendations-1}

**1.** できるだけ少ないコードを書くこと。

**2.** 最もシンプルな解決策を試すこと。

**3.** コードがどのように動作し、内部ループがどのように機能するかを理解するまでコードを書かないこと。

**4.** 最もシンプルなケースでは、クラスや構造体の代わりに`using`を使用すること。

**5.** 可能であれば、コピーコンストラクタ、代入演算子、デストラクタ(クラスに少なくとも1つの仮想関数が含まれている場合の仮想デストラクタを除く)、ムーブコンストラクタ、ムーブ代入演算子を書かないこと。言い換えれば、コンパイラが生成する関数が正しく動作するようにすること。`default`を使用できる。

**6.** コードの簡素化を推奨する。可能な限りコードのサイズを削減すること。


## その他の推奨事項 {#additional-recommendations}

**1.** `stddef.h` の型に対して `std::` を明示的に指定すること

は推奨されません。つまり、`std::size_t` ではなく `size_t` と記述することを推奨します。こちらの方が短いためです。

`std::` を追加することは許容されます。

**2.** 標準Cライブラリの関数に対して `std::` を明示的に指定すること

は推奨されません。つまり、`std::memcpy` ではなく `memcpy` と記述してください。

理由は、`memmem` のような類似の非標準関数が存在するためです。これらの関数は時折使用されます。これらの関数は `namespace std` には存在しません。

すべての箇所で `memcpy` の代わりに `std::memcpy` と記述すると、`std::` のない `memmem` が不自然に見えてしまいます。

それでも、好みに応じて `std::` を使用することは可能です。

**3.** 標準C++ライブラリに同じ関数が存在する場合にC言語の関数を使用すること。

より効率的である場合、これは許容されます。

例えば、大きなメモリブロックをコピーする場合は、`std::copy` ではなく `memcpy` を使用してください。

**4.** 複数行の関数引数。

以下のいずれの折り返しスタイルも許容されます:

```cpp
function(
  T1 x1,
  T2 x2)
```

```cpp
function(
  size_t left, size_t right,
  const & RangesInDataParts ranges,
  size_t limit)
```

```cpp
function(size_t left, size_t right,
  const & RangesInDataParts ranges,
  size_t limit)
```

```cpp
function(size_t left, size_t right,
      const & RangesInDataParts ranges,
      size_t limit)
```

```cpp
function(
      size_t left,
      size_t right,
      const & RangesInDataParts ranges,
      size_t limit)
```

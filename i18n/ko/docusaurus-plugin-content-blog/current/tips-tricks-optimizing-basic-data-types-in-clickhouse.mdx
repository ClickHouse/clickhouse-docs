---
title: ClickHouse에서 기본 데이터 타입을 최적화하는 팁과 기법
description: "ClickHouse에서 기본 데이터 타입을 최적화하는 팁과 기법"
date: 2024-07-02
tags: ['성능 및 최적화']
keywords: ['기본 데이터 타입 최적화']
---

{frontMatter.description}

{/* 이하 생략 */}

## 질문 \{#question\}

쿼리의 속도와 저장 공간을 최적화하기 위해 ClickHouse에서 어떤 데이터 타입을 사용하는 것이 좋습니까?

## Answer \{#answer\}

다른 시스템에서 자동 변환을 사용하거나 데이터 타입을 선택할 때, 흔히 「많을수록 좋다」, 「더 쉬운 것을 선택한다」, 「가장 범용적인 것을 선택한다」와 같은 방식을 택하는 경우가 많습니다. 이는 수백만 행, 많게는 수십억 행 정도의 비교적 작은 데이터셋에서는 잘 동작할 수 있습니다. 이런 종류의 데이터셋에서는 사용자의 쿼리 성능 차이가 사용 사례에서 크지 않기 때문에 눈에 띄지 않을 수도 있고, 그 경우에는 허용 가능한 선택입니다.

그러나 데이터가 증가하여 차이가 눈에 띄기 시작하면 이러한 선택은 더 이상 적절하지 않습니다.

예를 들어, 쿼리가 50ms가 걸리는 것과 500ms가 걸리는 것의 차이는 webUI와 같은 대부분의 사용 사례에서는 괜찮을 수 있지만, 전자는 후자보다 10배 빠른 것입니다. 비록 프런트엔드 사용자 입장에서는 그 차이가 크게 느껴지지 않을 수도 있습니다.

예시 초기 테이블:

```
timestamp Datetime64(9),
group_id Int64,
vendor_id String,
product_id String,
category1 Int64,
code_name String,
paid_status String,
country_code String,
description String,
price Float64,
attributes Map(String, String)
```

예제 데이터:

```
3456, 0123456789, bd6087b7-6026-4974-9122-bc99faae5d84, "2024-03-01 01:00:01.000", 98, "bear", paid", "us", "corvette model car", 123.45, {"color" : "blue", "size" : "S"}
156, 0000012345, bd6087b7-6026-4974-9122-bc99faae5d84, "2024-03-01 01:00:02:123", 45, "tiger", "not paid", "uk", "electric car", 53432.10, {"color" : "red", "model" : "X"} 
...
```

아래는 이 데이터를 최적화할 수 있는 몇 가지 권장 사항입니다:

`timestamp : DateTime64(9)`
과학적 정밀도가 필요한 경우가 아니라면, 9자리 정밀도(나노초)까지 사용할 필요는 거의 없습니다. 표시나 정렬에는 사용할 수 있지만, 검색용 쿼리나 기본 키(primary key) 등에는 보통 필요하지 않습니다.

* **권장 사항:**
  PK용, ORDER BY용: DateTime
  표시나 정렬용: 추가 컬럼 사용 - 예: `timestamp_microseconds : DateTime64(6)`

`group_id : Int64`
정수로 보이므로, 이 컬럼에 필요한 최대값을 수용할 수 있는 가장 작은 정수 타입을 선택하는 것이 좋습니다. 이 샘플 데이터셋과 컬럼 이름을 볼 때 10의 18제곱(퀸틸리언) 값까지 필요할 가능성은 낮아 보이며, 최대 약 16,000개 값이면 충분하므로 Int16으로도 충분할 수 있습니다.

* **권장 사항**: Int16

`vendor_id : String`
숫자로 보이지만 앞에 0이 포함되어 있어 포맷을 유지하는 것이 중요해 보입니다. 또한 문자 길이도 일정 개수로 제한되어 있는 것으로 보입니다.

* **권장 사항**: FixedString(10)

`product_id : String`
이 값은 영숫자 조합으로 직관적으로는 문자열처럼 보이지만, 실제로는 UUID입니다.

* **권장 사항**: UUID

`category1 : Int64`
값의 범위가 작고 카테고리 개수도 많지 않으며, 크게 증가하지 않거나 제한적일 것으로 보입니다. 값이 255 미만입니다.

* **권장 사항**: UInt8

`code_name : String`
이 필드는 사용될 문자열의 종류가 제한적일 수 있어 보입니다.
이처럼 문자열 값의 종류가 수백 개에서 수천 개 정도인 경우, 낮은 카디널리티 컬럼이 도움이 됩니다.

* **권장 사항**: LowCardinality(String)

`paid_status : String`
값은 「paid」 또는 「not&#95;paid」 두 가지 문자열입니다. 가능한 값이 두 개뿐인 경우에는 boolean을 사용하는 것이 좋습니다.

* **권장 사항**: Bool

`country_code : String`
때로는 여러 최적화 조건을 동시에 만족하는 컬럼이 있습니다. 이 예에서는 국가 코드의 종류가 한정되어 있고, 모두 두 글자 식별자입니다.

* **권장 사항**: LowCardinality(FixedString(2))

`price : Float64`
고정된 정밀도가 명확히 정의되는 경우, 특히 금융 데이터와 계산에는 Float 사용이 권장되지 않습니다. 필요한 정밀도에 맞는 Decimal 타입을 사용하는 것이 가장 좋습니다. 이 사용 사례에서는 항목 가격이 999,999.00을 넘지 않을 가능성이 큽니다.

* **권장 사항**: Decimal(10,2)

`attributes : map`\
맵에 동적 속성이 포함된 테이블이 자주 존재합니다. 키나 값을 검색하는 작업은 보통 더 느립니다. 맵을 더 빠르게 만드는 방법이 몇 가지 있습니다. 대부분의 레코드에 존재하는 키가 있다면 해당 키는 별도의 컬럼에 낮은 카디널리티로 두고, 희소하게 나타나는 키는 또 다른 컬럼에 높은 카디널리티로 두는 것이 가장 좋습니다. 이렇게 분리한 다음에는 스킵 인덱스를 생성하는 것이 더 효율적인데, 쿼리의 복잡성은 다소 증가할 수 있습니다.

* **권장 사항:** lc&#95;attributes: Map(String, String), hc&#95;attributes: Map(String, String).

쿼리 특성에 따라, 스킵 인덱스를 생성하거나/또는 속성을 추출하는 데 사용할 수 있는 옵션은 다음과 같습니다.\
Array Join을 사용하여 구체화된 뷰(Materialized View)를 통해 컬럼으로 추출:\
https://clickhouse.com/docs/knowledgebase/using-array-join-to-extract-and-query-attributes\
키에 대해 스킵 인덱스를 사용하는 방법:\
https://clickhouse.com/docs/knowledgebase/improve-map-performance
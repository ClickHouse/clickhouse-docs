---
date: 2023-05-02
title: TTL 규칙은 언제 적용되며, 이를 제어할 수 있습니까?
description: ClickHouse의 TTL 규칙은 결국 적용되며, `merge_with_ttl_timeout` 설정을 사용하여 실행 시점을 제어할 수 있습니다. TTL 적용을 강제로 수행하고 TTL 실행을 담당하는 백그라운드 스레드를 관리하는 방법을 알아보십시오.
tags: ['핵심 데이터 개념']
keywords: ['TTL']
---

{frontMatter.description}

{/* 일부 생략 */}

## TTL 규칙 및 제어 \{#ttl-rules-and-control\}

TTL은 ***결국(eventually)*** 적용됩니다. 이는 무엇을 의미합니까? `MergeTree` 테이블 설정 [`merge_with_ttl_timeout`](https://clickhouse.com/docs/engines/table-engines/mergetree-family/mergetree#merge_with_ttl_timeout)은 delete TTL이 포함된 머지를 다시 수행하기 전까지 대기할 최소 지연 시간을 초 단위로 지정합니다. 기본값은 14,400초(4시간)입니다. 하지만 이는 최소 지연 시간일 뿐이며, delete TTL을 위한 머지가 실제로 트리거될 때까지는 더 오래 걸릴 수 있습니다.

다음 쿼리를 사용하여 `merge_with_ttl_timeout`과 같은 현재 TTL 설정을 모두 확인할 수 있습니다:

```sql
SELECT *
FROM system.merge_tree_settings
WHERE name like '%ttl%'
```

응답은 다음과 같은 형태입니다.

```response
┌─name───────────────────────────────────────────────────────────┬─value───┬─changed─┬─description────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬─min──┬─max──┬─readonly─┬─type───┐
│ max_replicated_merges_with_ttl_in_queue                        │ 1       │       0 │ How many tasks of merging parts with TTL are allowed simultaneously in ReplicatedMergeTree queue.                                                                                          │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ max_number_of_merges_with_ttl_in_pool                          │ 2       │       0 │ When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL. This is to leave free threads for regular merges and avoid "Too many parts" │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ merge_tree_clear_old_broken_detached_parts_ttl_timeout_seconds │ 2592000 │       1 │ Remove old broken detached parts in the background if they remained intouched for a specified by this setting period of time.                                                              │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │
│ merge_with_ttl_timeout                                         │ 14400   │       0 │ Minimal time in seconds, when merge with delete TTL can be repeated.                                                                                                                       │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Int64  │
│ merge_with_recompression_ttl_timeout                           │ 14400   │       0 │ Minimal time in seconds, when merge with recompression TTL can be repeated.                                                                                                                │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Int64  │
│ ttl_only_drop_parts                                            │ 0       │       0 │ Only drop altogether the expired parts and not partially prune them.                                                                                                                       │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Bool   │
│ materialize_ttl_recalculate_only                               │ 0       │       0 │ Only recalculate ttl info when MATERIALIZE TTL                                                                                                                                             │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ Bool   │
└────────────────────────────────────────────────────────────────┴─────────┴─────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────┴──────┴──────────┴────────┘
```

`SHOW CREATE TABLE`을 사용하여 테이블에 TTL 규칙이 포함되어 있는지와, 위에서 설명한 설정들의 값이 테이블 `SETTINGS`에 의해 변경되었는지 확인할 수 있습니다:`

```sql
SHOW CREATE TABLE <TableName>
```

## TTL 규칙 강제 적용 \{#force-a-ttl-rule-to-be-applied\}

가장 우아한 해결 방법은 아니지만, `MATERIALIZE TTL`을 명시적으로 호출하면 테이블의 모든 TTL 규칙이 즉시 적용되도록 강제할 수 있습니다:

```sql
ALTER TABLE my_table
    MATERIALIZE TTL
```

## TTL에 영향을 주는 백그라운드 스레드 \{#background-threads-affecting-ttl\}

백그라운드 풀에 작동하는 스레드가 충분하지 않으면 TTL 규칙이 적용되지 않을 수 있습니다. 예를 들어 데이터를 대량으로 삽입하면 전체 백그라운드 풀이 일반 머지 작업에 모두 사용될 수 있습니다. 이때는 백그라운드 풀 크기를 늘릴 수 있습니다.

다음 쿼리로 현재 백그라운드 풀 크기를 확인할 수 있습니다:

```sql
SELECT *
FROM system.settings
WHERE name = 'background_pool_size';
```

응답은 다음과 같습니다:

```response
┌─name─────────────────┬─value─┬─changed─┬─description─────────────────────┬─min──┬─max──┬─readonly─┬─type───┬─default─┬─alias_for─┐
│ background_pool_size │ 16    │       0 │ Obsolete setting, does nothing. │ ᴺᵁᴸᴸ │ ᴺᵁᴸᴸ │        0 │ UInt64 │ 16      │           │
└──────────────────────┴───────┴─────────┴─────────────────────────────────┴──────┴──────┴──────────┴────────┴─────────┴───────────┘
```

[`background_pool_size` setting](https://clickhouse.com/docs/operations/server-configuration-parameters/settings#background_pool_size)를 수정하는 방법은 문서를 참고하십시오. 이 설정은 다음과 같이 구성되어 있습니다:

```xml
<background_pool_size>16</background_pool_size>
```

다음 쿼리를 사용하면 현재 백그라운드 풀의 활동을 확인할 수 있습니다:

```sql
SELECT *
FROM system.metrics
WHERE metric like 'Background%'
```

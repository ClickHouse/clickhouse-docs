---
title: '쿼리의 메모리 제한 초과'
description: '쿼리에서 발생하는 메모리 제한 초과 오류 트러블슈팅'
date: 2025-07-25
tags: ['오류 및 예외']
keywords: ['OOM', '메모리 제한 초과']
---

{frontMatter.description}

{/* 생략 */}

import Image from '@theme/IdealImage';
import joins from '@site/static/images/knowledgebase/memory-limit-exceeded-for-query.png';

## 쿼리의 메모리 한도 초과 \{#troubleshooting-out-of-memory-issues\}

새로운 사용자에게 ClickHouse는 마치 마법처럼 보일 수 있습니다. 어떤 쿼리든 매우 빠르게
실행되며, 매우 큰 데이터셋과 가장 복잡한 쿼리에서도 마찬가지입니다. 하지만 실제
운영 환경에서는 결국 ClickHouse의 한계까지 시험하게 됩니다. 메모리 한도를 초과하는 쿼리는
여러 가지 원인으로 인해 발생할 수 있습니다. 가장 일반적으로는 카디널리티가 높은 필드에 대한 대규모 조인이나
집계가 원인이 됩니다. 성능이 중요하고 이러한 쿼리가 꼭 필요하다면, 종종 단순히 스케일 업(scale up)을
권장합니다. ClickHouse Cloud는 쿼리가 항상 빠르게 응답할 수 있도록 이를 자동으로, 그리고 손쉽게
처리합니다. 다만 자가 관리형 환경에서는 이것이 항상 간단한 일은 아니며, 최적의 성능이
반드시 요구되지 않을 수도 있습니다. 이러한 경우 사용자에게는 몇 가지 선택지가 있습니다.

### Aggregations \{#aggregations\}

메모리를 많이 사용하는 집계나 정렬 시나리오에서는
[`max_bytes_before_external_group_by`](/operations/settings/settings#max_bytes_before_external_group_by)
와 [`max_bytes_before_external_sort`](/operations/settings/settings#max_bytes_ratio_before_external_sort) 설정을 각각 사용할 수 있습니다.
전자는 [여기](/sql-reference/statements/select/group-by/#group-by-in-external-memory)에서 자세히 설명합니다.

요약하면, 이 설정을 사용하면 집계 수행 시 메모리 임계값을 초과할 경우 디스크로 「스필(spill)」되도록 할 수 있습니다.
이는 쿼리 성능에 불가피하게 영향을 주지만, 쿼리에서 OOM(Out Of Memory) 오류가 발생하지 않도록 하는 데 도움이 됩니다.
후자의 정렬 관련 설정은 메모리를 많이 사용하는 정렬에서 발생하는 유사한 문제를 해결하는 데 도움이 됩니다.
이는 조정 노드가 하위 세그먼트로부터 정렬된 응답을 받는 분산 환경에서 특히 중요합니다.
이 경우, 조정 서버는 사용 가능한 메모리보다 큰 데이터셋을 정렬하도록 요구받을 수 있습니다.
[`max_bytes_before_external_sort`](/operations/settings/settings#max_bytes_ratio_before_external_sort)를 사용하면 정렬 작업도 디스크로 스필되도록 허용할 수 있습니다.
이 설정은 특히 쿼리가 분산된 상태에서 `GROUP BY` 이후에 `LIMIT`과 함께 `ORDER BY`가 있는 경우에 유용합니다.

### Joins \{#joins\}

조인의 경우, 사용자는 다양한 `JOIN` 알고리즘을 선택할 수 있으며, 이는 필요한 메모리를 줄이는 데 도움이 됩니다. 기본적으로 조인은 해시 조인(hash join)을 사용하며, 이는 기능 측면에서 가장 완전하고 종종 최고의 성능을 제공합니다. 이 알고리즘은 `JOIN`의 오른쪽 테이블을 메모리 내 해시 테이블에 로드한 뒤, 왼쪽 테이블을 그 해시 테이블에 대해 평가합니다. 메모리 사용을 최소화하려면 더 작은 테이블을 오른쪽에 두는 것이 좋습니다. 하지만 이 접근 방식도 메모리 제약이 심한 경우에는 한계가 있습니다. 이러한 경우에는 [`join_algorithm`](/operations/settings/settings#join_algorithm) 설정을 통해 `partial_merge` 조인을 활성화할 수 있습니다. 이는 [sort-merge algorithm](https://en.wikipedia.org/wiki/Sort-merge_join)의 변형으로, 먼저 오른쪽 테이블을 블록 단위로 정렬하고 각 블록에 대한 min-max 인덱스를 생성합니다. 그런 다음 왼쪽 테이블의 일부를 조인 키로 정렬한 후, 이를 오른쪽 테이블과 조인합니다. min-max 인덱스는 필요 없는 오른쪽 테이블 블록을 건너뛰는 데 사용됩니다. 이는 성능을 어느 정도 희생하는 대신 메모리 사용량을 줄여 줍니다. 이 개념을 한 단계 더 확장한 `full_sorting_merge` 알고리즘은 오른쪽 테이블이 매우 커서 메모리에 적재할 수 없고, 예를 들어 복잡한 서브쿼리처럼 조회(lookups)가 사실상 불가능한 경우에도 `JOIN`을 수행할 수 있게 합니다. 이 경우, 메모리에 맞지 않으면 오른쪽과 왼쪽 테이블 모두 디스크에서 정렬되며, 이를 통해 큰 테이블 간에도 조인을 수행할 수 있습니다.

<Image img={joins} size="md" alt="조인 알고리즘" />

버전 20.3부터 ClickHouse는 `join_algorithm` 설정에 auto라는 값을 지원합니다. 이는 ClickHouse에 적응형 조인 방식을 적용하도록 지시하며, 메모리 한계에 도달하기 전까지는 해시 조인 알고리즘을 우선 사용하고, 한계를 초과하면 `partial_merge` 알고리즘을 시도합니다. 마지막으로, 조인과 관련하여 독자는 분산 조인의 동작 방식과 그 메모리 사용량을 최소화하는 방법을 숙지하는 것이 좋습니다. 자세한 내용은 [여기](/sql-reference/operators/in#distributed-subqueries)에서 확인할 수 있습니다.
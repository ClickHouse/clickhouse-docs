---
title: ClickHouse에서 PIVOT을 사용할 수 있습니까?
description: "ClickHouse에는 PIVOT 절이 없지만 aggregate function combinators를 사용해 이와 유사한 기능을 상당 부분 구현할 수 있습니다. UK 주택 가격 데이터 세트를 사용해 그 방법을 살펴보겠습니다."
date: 2024-12-11
tags: ['데이터 모델링', '핵심 데이터 개념']
keywords: ['PIVOT', 'Aggregate Function Combinators']
---

{frontMatter.description}

{/* 생략 */}

## 소개 \{#introduction\}

ClickHouse에는 피벗(pivot) 연산자가 없지만, [aggregate function combinators](/sql-reference/aggregate-functions/combinators) (집계 함수 조합자), 특히 [`-Map` 접미사](/sql-reference/aggregate-functions/combinators#-map)가 있는 것들을 사용하여 유사한 동작을 구현할 수 있습니다.

이 글에서는 그 방법을 살펴봅니다.
아래에는 동일한 내용을 다루는 동영상도 있습니다:

<iframe width="560" height="315" src="https://www.youtube.com/embed/nlRMOmwYtF4?si=0TZSNg-uo7zjiO52" title="YouTube 동영상 플레이어" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen />

## 집계 함수 콤비네이터 이해하기 \{#understanding-aggregate-function-combinators\}

간단한 예제부터 시작하겠습니다. 먼저 다음 명령으로 [clickhouse-local](/operations/utilities/clickhouse-local)을(를) 실행합니다.

```bash
clickhouse -m --output_format_pretty_row_numbers=0
```

다음 쿼리는 `sumMap` 함수를 호출하며, 이 함수는 맵을 인자로 받아 각 키의 값을 합산합니다:

```sql
SELECT sumMap(map('ClickHouse', 1, 'ClickBench', 2));
```

```text
┌─sumMap(map('ClickHouse', 1, 'ClickBench', 2))─┐
│ {'ClickBench':2,'ClickHouse':1}               │
└───────────────────────────────────────────────┘
```

전달한 맵을 그대로 반환하기 때문에 그다지 흥미로운 예시는 아닙니다.
이제 여러 행에 걸친 맵들을 대상으로 `sumMap`을 호출해 보겠습니다.

```sql
WITH values AS (
  SELECT map('ClickHouse', 3) AS value
  UNION ALL
  SELECT map('ClickBench', 2, 'ClickHouse', 4) AS value
)
SELECT sumMap(value)
FROM values;
```

```text
┌─sumMap(value)───────────────────┐
│ {'ClickBench':2,'ClickHouse':7} │
└─────────────────────────────────┘
```

키 `ClickHouse`는 두 행 모두에 나타났고 해당 값들이 합산되었습니다. 키 `ClickBench`는 한 행에만 존재했기 때문에 단일 값만 더하게 되고, 그 결과로 그 값이 그대로 반환됩니다!

또한 `maxMap`을 사용하여 키별 최댓값을 찾을 수도 있습니다:

```sql
WITH values AS (
  SELECT map('ClickHouse', 3) AS value
  UNION ALL
  SELECT map('ClickBench', 2, 'ClickHouse', 4) AS value
)
SELECT maxMap(value)
FROM values;
```

```text
┌─maxMap(value)───────────────────┐
│ {'ClickBench':2,'ClickHouse':4} │
└─────────────────────────────────┘
```

또는 `avgMap`을 사용하여 키별 평균값을 구할 수 있습니다.

```sql
WITH values AS (
  SELECT map('ClickHouse', 3) AS value
  UNION ALL
  SELECT map('ClickBench', 2, 'ClickHouse', 4) AS value
)
SELECT avgMap(value)
FROM values;
```

```text
┌─avgMap(value)─────────────────────┐
│ {'ClickBench':2,'ClickHouse':3.5} │
└───────────────────────────────────┘
```

이제 이러한 함수 결합자가 어떻게 동작하는지 어느 정도 이해하는 데 도움이 되었기를 바랍니다.

## 실제 활용 예: 영국 주택 가격 데이터셋 \{#real-world-application-uk-housing-prices-dataset\}

이제 앞에서 살펴본 내용을 [ClickHouse SQL playground](https://clickhouse.com/blog/announcing-the-new-sql-playground)의 더 큰 데이터셋에 적용해 보겠습니다.

`clickhouse-client`를 사용하여 playground에 연결할 수 있습니다:

```bash
clickhouse client -m \
  -h sql-clickhouse.clickhouse.com \
  -u demo \
  --secure
```

`uk_price_paid` 테이블에 쿼리를 실행할 것이므로, 해당 테이블의 데이터를 살펴보겠습니다.

```sql
SELECT * FROM uk.uk_price_paid LIMIT 1 FORMAT Vertical;
```

```text
Row 1:
──────
price:     145000
date:      2008-11-19
postcode1:
postcode2:
type:      semi-detached
is_new:    0
duration:  leasehold
addr1:
addr2:
street:    CURLEW DRIVE
locality:  SCARBOROUGH
town:      SCARBOROUGH
district:  SCARBOROUGH
county:    NORTH YORKSHIRE
category:  0
```

위에서 본 것처럼 이 테이블에는 영국 주택 매매와 관련된 다양한 필드가 포함되어 있습니다.

### 10년 단위 그룹화 및 집계 \{#grouping-and-aggregating-by-decade\}

데이터셋에서 각 10년대마다 카운티(county)별 가격 중앙값을 계산해 보겠습니다.

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    medianMap(map(year, price)) AS medianPrices
FROM uk.uk_price_paid
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10;
```

```text
    ┌─county─────────────┬─medianPrices───────────────────────────────────────┐
 1. │ GREATER LONDON     │ {1990:89972.5,2000:215000,2010:381500,2020:485000} │
 2. │ TYNE AND WEAR      │ {1990:46500,2000:93000,2010:130000,2020:139000}    │
 3. │ WEST MIDLANDS      │ {1990:50000,2000:110000,2010:149950,2020:185000}   │
 4. │ GREATER MANCHESTER │ {1990:47000,2000:97000,2010:141171,2020:178000}    │
 5. │ MERSEYSIDE         │ {1990:46750,2000:94972.5,2010:128000,2020:149000}  │
 6. │ HERTFORDSHIRE      │ {1990:86500,2000:193000,2010:315000,2020:415000}   │
 7. │ WEST YORKSHIRE     │ {1990:48995,2000:99950,2010:139000,2020:164950}    │
 8. │ BRIGHTON AND HOVE  │ {1990:70000,2000:173000,2010:288000,2020:387000}   │
 9. │ DORSET             │ {1990:76500,2000:182000,2010:250000,2020:315000}   │
10. │ HAMPSHIRE          │ {1990:79950,2000:177500,2010:260000,2020:335000}   │
    └────────────────────┴────────────────────────────────────────────────────┘
```

### 결과 필터링 \{#filtering-results\}

결과를 필터링하여 2010년부터의 데이터만 포함되도록 할 수 있습니다:

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    medianMap(map(year, price)) AS medianPrices
FROM uk.uk_price_paid
WHERE year >= 2010
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10;
```

```text
    ┌─county─────────────┬─medianPrices────────────────┐
 1. │ GREATER LONDON     │ {2010:384975,2020:485919.5} │
 2. │ TYNE AND WEAR      │ {2010:130000,2020:140000}   │
 3. │ WEST MIDLANDS      │ {2010:146500,2020:185000}   │
 4. │ GREATER MANCHESTER │ {2010:140000,2020:177500}   │
 5. │ MERSEYSIDE         │ {2010:130000,2020:150000}   │
 6. │ HERTFORDSHIRE      │ {2010:315000,2020:415000}   │
 7. │ WEST YORKSHIRE     │ {2010:140000,2020:162500}   │
 8. │ BRIGHTON AND HOVE  │ {2010:287500,2020:387000}   │
 9. │ DORSET             │ {2010:255750,2020:315000}   │
10. │ HAMPSHIRE          │ {2010:265000,2020:330000}   │
    └────────────────────┴─────────────────────────────┘
```

## 여러 집계를 함께 사용하기 \{#combining-multiple-aggregations\}

10년 단위별 최대 가격을 찾으려면, 앞에서 살펴본 `maxMap` 함수를 사용하면 됩니다.

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    medianMap(map(year, price)) AS medianPrices,
    maxMap(map(year, price)) AS maxPrices
FROM uk.uk_price_paid
WHERE year >= 2010
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10;
```

```text
    ┌─county─────────────┬─medianPrices──────────────┬─maxPrices───────────────────────┐
 1. │ GREATER LONDON     │ {2010:385000,2020:485250} │ {2010:594300000,2020:630000000} │
 2. │ TYNE AND WEAR      │ {2010:130000,2020:141000} │ {2010:448300979,2020:93395000}  │
 3. │ WEST MIDLANDS      │ {2010:149000,2020:184250} │ {2010:415000000,2020:104500000} │
 4. │ GREATER MANCHESTER │ {2010:140000,2020:175000} │ {2010:107086856,2020:319186000} │
 5. │ MERSEYSIDE         │ {2010:129950,2020:150000} │ {2010:300000000,2020:93395000}  │
 6. │ HERTFORDSHIRE      │ {2010:315000,2020:415000} │ {2010:254325163,2020:93395000}  │
 7. │ WEST YORKSHIRE     │ {2010:138500,2020:165000} │ {2010:246300000,2020:109686257} │
 8. │ BRIGHTON AND HOVE  │ {2010:285000,2020:387000} │ {2010:200000000,2020:71540000}  │
 9. │ DORSET             │ {2010:250000,2020:315000} │ {2010:150000000,2020:20230000}  │
10. │ HAMPSHIRE          │ {2010:264000,2020:330000} │ {2010:150000000,2020:48482500}  │
    └────────────────────┴───────────────────────────┴─────────────────────────────────┘
```

## map 값에 함수 적용하기 \{#applying-functions-to-map-values\}

다른 방법으로 `avgMap`을 사용하여 평균 가격을 계산할 수 있습니다.
해당 값들은 소수점 이하 자릿수가 매우 많으므로, [`mapApply`](/sql-reference/functions/tuple-map-functions#mapApply) 함수를 사용해 맵의 각 값에 대해 [`floor`](/sql-reference/functions/rounding-functions#floor) 함수를 호출하여 자릿수를 정리할 수 있습니다:

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    medianMap(map(year, price)) AS medianPrices,
    mapApply((k, v) -> (k, floor(v)), avgMap(map(year, price))) AS avgPrices
FROM uk.uk_price_paid
WHERE year >= 2010
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10;
```

```text
    ┌─county─────────────┬─medianPrices──────────────┬─avgPrices─────────────────┐
 1. │ GREATER LONDON     │ {2010:382000,2020:490000} │ {2010:626091,2020:807240} │
 2. │ TYNE AND WEAR      │ {2010:127000,2020:140000} │ {2010:176955,2020:225770} │
 3. │ WEST MIDLANDS      │ {2010:148500,2020:183000} │ {2010:204128,2020:257226} │
 4. │ GREATER MANCHESTER │ {2010:140000,2020:177500} │ {2010:195592,2020:251165} │
 5. │ MERSEYSIDE         │ {2010:127995,2020:150000} │ {2010:182194,2020:206062} │
 6. │ HERTFORDSHIRE      │ {2010:317500,2020:415000} │ {2010:414134,2020:529409} │
 7. │ WEST YORKSHIRE     │ {2010:140000,2020:164500} │ {2010:185121,2020:234870} │
 8. │ BRIGHTON AND HOVE  │ {2010:285000,2020:387000} │ {2010:372285,2020:527184} │
 9. │ DORSET             │ {2010:250000,2020:315000} │ {2010:305581,2020:370739} │
10. │ HAMPSHIRE          │ {2010:265000,2020:330000} │ {2010:335945,2020:425196} │
    └────────────────────┴───────────────────────────┴───────────────────────────┘
```

## 유연한 그룹화: 카운티, 구역, 우편번호 \{#flexible-grouping-counties-districts-and-postcodes\}

이제 다른 필드로 그룹화를 시도해 보겠습니다.
이번에는 카운티와 구역별로 그룹화하여 10년 단위 가격 중앙값을 계산해 보겠습니다:

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    county,
    district,
    medianMap(map(year, price)) AS medianPrices
FROM uk.uk_price_paid
WHERE year >= 2010
GROUP BY ALL
ORDER BY max(price) DESC
LIMIT 10
```

```text
    ┌─county─────────────┬─district───────────────┬─medianPrices────────────────┐
 1. │ GREATER LONDON     │ CROYDON                │ {2010:298475,2020:400000}   │
 2. │ GREATER LONDON     │ CITY OF WESTMINSTER    │ {2010:800000,2020:935000}   │
 3. │ GREATER LONDON     │ SOUTHWARK              │ {2010:437000,2020:540000}   │
 4. │ TYNE AND WEAR      │ NEWCASTLE UPON TYNE    │ {2010:144000,2020:162500}   │
 5. │ WEST MIDLANDS      │ WALSALL                │ {2010:137450,2020:162000}   │
 6. │ GREATER LONDON     │ CITY OF LONDON         │ {2010:725875,2020:840000}   │
 7. │ GREATER LONDON     │ HILLINGDON             │ {2010:329125,2020:439000}   │
 8. │ GREATER MANCHESTER │ MANCHESTER             │ {2010:144972.5,2020:190000} │
 9. │ GREATER LONDON     │ HAMMERSMITH AND FULHAM │ {2010:622250,2020:750000}   │
10. │ GREATER LONDON     │ ISLINGTON              │ {2010:500000,2020:640000}   │
    └────────────────────┴────────────────────────┴─────────────────────────────┘
```

연도별로 그룹화한 다음 맵에서 `postcode1`과 `postcode2`를 이어 붙일 수도 있습니다.

```sql
WITH year(toStartOfInterval(date, toIntervalYear(10))) AS year
SELECT
    year,
    medianMap(map(postcode1 || ' ' || postcode2, price)) AS medianPrices
FROM uk.uk_price_paid
WHERE postcode1 LIKE 'NP1'
GROUP BY ALL;
```

```text
   ┌─year─┬─medianPrices────────────────────────────────────────────────────────┐
1. │ 1990 │ {'NP1 4PB':9000}                                                    │
2. │ 2000 │ {'NP1 4SR':28475,'NP1 7HZ':200000}                                  │
3. │ 2010 │ {'NP1 4PB':5000,'NP1 4QJ':1075000,'NP1 4SR':58000,'NP1 8BR':200000} │
4. │ 2020 │ {'NP1 5DW':140000}                                                  │
   └──────┴─────────────────────────────────────────────────────────────────────┘
```

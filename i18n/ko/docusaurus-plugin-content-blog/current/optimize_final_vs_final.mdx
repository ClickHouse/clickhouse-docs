---
date: 2025-07-20
title: OPTIMIZE FINAL과 FINAL의 차이점은 무엇입니까?
tags: ['핵심 데이터 개념(Core Data Concepts)']
keywords: ['OPTIMIZE FINAL', 'FINAL']
description: 'OPTIMIZE FINAL과 FINAL의 차이점과 각각을 언제 사용하고 언제 피해야 하는지에 대해 설명합니다.'
---

{frontMatter.description}

{/* 생략 */}

# `OPTIMIZE FINAL`과 `FINAL`의 차이점 \{#what-is-the-difference-between-optimize-final-and-final\}

`OPTIMIZE FINAL`은 디스크에 저장된 데이터를 물리적으로, 영구적으로 재구성하고
최적화하는 DDL 명령(DDL Command)입니다. `MergeTree` 테이블에서 데이터 파트를 물리적으로
병합하면서, 저장소에서 중복된 행을 제거하여 데이터 중복 제거를 수행합니다.

`FINAL`은 저장된 데이터 구조를 변경하지 않고 중복이 제거된 결과를 제공하는
**쿼리 실행 시점**의 수정자(Query Modifier)입니다. 읽기 시점에 병합 로직을 수행하여 동작합니다.
이는 일시적이며, 현재 쿼리 결과에만 영향을 줍니다.

일반적으로 `OPTIMIZE FINAL`은 상당한 성능 오버헤드가 있기 때문에 사용을
피하도록 권장되지만, 이 둘을 혼동해서는 안 됩니다. 특히 `ReplacingMergeTree`와 같이
최종적으로 백그라운드 병합 과정에서 아직 대체되지 않은 중복 행을
포함할 수 있는 테이블 엔진을 사용할 때, 중복이 제거된 결과를 얻기 위해
`FINAL`을 사용하는 것이 필요한 경우가 자주 있습니다.

아래 표는 주요 차이점을 요약합니다:

|Aspect	           |`OPTIMIZE FINAL`                            | `FINAL`                                            |
|------------------|--------------------------------------------|----------------------------------------------------|
|Type              | DDL 명령(DDL Command)                      | 쿼리 수정자(Query Modifier)                        |
|Effect            | 영구적인 스토리지 최적화                   | 일시적인 쿼리 실행 시점 중복 제거                 |
|Performance       | 한 번 높은 비용이 들지만 이후 쿼리는 더 빠름 | 개별 비용은 낮지만 쿼리마다 반복 수행됨           |
|Data Modification | 예 - 스토리지를 물리적으로 변경            | 아니요 - 읽기 전용 동작                           |
|Use Case          | 주기적인 유지 관리/최적화                  | 실시간 중복 제거 쿼리                             |

## 각 방법을 언제 사용할지 \{#when-to-use-each\}

`OPTIMIZE FINAL`은 다음과 같은 경우에 사용합니다:

* 쿼리 성능을 영구적으로 개선하고 싶을 때
* 일회성 최적화 비용을 감당할 수 있을 때
* 정기적으로 테이블을 유지 관리할 때
* 중복 데이터를 물리적으로 정리하고 싶을 때

`FINAL`은 다음과 같은 경우에 사용합니다:

* 즉시 중복 제거된 결과가 필요할 때
* 영구적인 최적화를 기다릴 수 없거나 원하지 않을 때
* 가끔만 중복 제거된 데이터가 필요할 때
* 자주 변경되는 데이터를 다루고 있을 때

두 기능 모두 유용한 도구이지만, ClickHouse의 중복 제거 전략에서 서로 다른 목적을 가집니다.
---
date: 2023-03-17
title: 문제 해결을 위한 유용한 쿼리
description: ClickHouse 문제를 진단할 때 테이블 크기, 장시간 실행 중인 쿼리, 오류 등을 모니터링하는 데 사용할 수 있는 유용한 쿼리 모음입니다.
tags: ['Settings']
keywords: ['유용한 쿼리']
---

{frontMatter.description}

{/* 생략 */}

## 문제 해결에 유용한 쿼리 \{#useful-queries-for-troubleshooting\}

순서는 상관없지만, ClickHouse 문제를 해결하고 어떤 일이 발생하고 있는지 파악하는 데 유용한 몇 가지 쿼리를 소개합니다.

또한 [ClickHouse 모니터링을 위한 필수 쿼리](https://clickhouse.com/blog/monitoring-troubleshooting-select-queries-clickhouse)를 정리한 훌륭한 블로그도 있습니다.

## 기본값에서 변경된 설정 확인하기 \{#view-which-settings-have-been-changed-from-the-default\}

```sql
SELECT
    name,
    value
FROM system.settings
WHERE changed
```

## 모든 테이블의 크기 확인하기 \{#get-the-size-of-all-your-tables\}

```sql
SELECT table,
    formatReadableSize(sum(bytes)) as size
    FROM system.parts
    WHERE active
GROUP BY table
```

다음과 같은 응답이 반환됩니다:

```response
┌─table───────────┬─size──────┐
│ stat            │ 38.89 MiB │
│ customers       │ 525.00 B  │
│ my_sparse_table │ 40.73 MiB │
│ crypto_prices   │ 32.18 MiB │
│ hackernews      │ 6.23 GiB  │
└─────────────────┴───────────┘
```

## 테이블의 행 수와 일간 평균 크기 \{#row-count-and-average-day-size-of-your-table\}

```sql
SELECT
    table,
    formatReadableSize(size) AS size,
    rows,
    days,
    formatReadableSize(avgDaySize) AS avgDaySize
FROM
(
    SELECT
        table,
        sum(bytes) AS size,
        sum(rows) AS rows,
        min(min_date) AS min_date,
        max(max_date) AS max_date,
        max_date - min_date AS days,
        size / (max_date - min_date) AS avgDaySize
    FROM system.parts
    WHERE active
    GROUP BY table
    ORDER BY rows DESC
)
```

## 컬럼별 압축 비율 및 메모리 내 기본 인덱스 크기 \{#compression-columns-percentage-as-well-as-the-size-of-primary-index-in-memory\}

컬럼별로 데이터가 얼마나 압축되었는지 확인할 수 있습니다. 이 쿼리는 메모리에 상주하는 기본 인덱스의 크기도 반환합니다. 기본 인덱스는 메모리에 상주해야 하므로, 이 정보를 파악하는 것이 중요합니다.

```sql
SELECT
    parts.*,
    columns.compressed_size,
    columns.uncompressed_size,
    columns.compression_ratio,
    columns.compression_percentage
FROM
(
    SELECT
        table,
        formatReadableSize(sum(data_uncompressed_bytes)) AS uncompressed_size,
        formatReadableSize(sum(data_compressed_bytes)) AS compressed_size,
        round(sum(data_compressed_bytes) / sum(data_uncompressed_bytes), 3) AS compression_ratio,
        round(100 - ((sum(data_compressed_bytes) * 100) / sum(data_uncompressed_bytes)), 3) AS compression_percentage
    FROM system.columns
    GROUP BY table
) AS columns
RIGHT JOIN
(
    SELECT
        table,
        sum(rows) AS rows,
        max(modification_time) AS latest_modification,
        formatReadableSize(sum(bytes)) AS disk_size,
        formatReadableSize(sum(primary_key_bytes_in_memory)) AS primary_keys_size,
        any(engine) AS engine,
        sum(bytes) AS bytes_size
    FROM system.parts
    WHERE active
    GROUP BY
        database,
        table
) AS parts ON columns.table = parts.table
ORDER BY parts.bytes_size DESC
```

## 지난 10분 동안 클라이언트가 보낸 쿼리 수 \{#number-of-queries-sent-by-client-in-the-last-10-minutes\}

`toIntervalMinute(10)` 함수의 시간 간격은 필요에 따라 늘리거나 줄일 수 있습니다.

```sql
SELECT
    client_name,
    count(),
    query_kind,
    toStartOfMinute(event_time) AS event_time_m
FROM system.query_log
WHERE (type = 'QueryStart') AND (event_time > (now() - toIntervalMinute(10)))
GROUP BY
    event_time_m,
    client_name,
    query_kind
ORDER BY
    event_time_m DESC,
    count() ASC
```

## 각 파티션의 파트 수 \{#number-of-parts-in-each-partition\}

```sql
SELECT
    concat(database, '.', table),
    partition_id,
    count()
FROM system.parts
WHERE active
GROUP BY
    database,
    table,
    partition_id
```

## 오래 실행되는 쿼리 찾기 \{#finding-long-running-queries\}

다음 쿼리는 멈춰 있는 쿼리를 찾는 데 도움이 됩니다:

```sql
SELECT
    elapsed,
    initial_user,
    client_name,
    hostname(),
    query_id,
    query
FROM clusterAllReplicas(default, system.processes)
ORDER BY elapsed DESC
```

가장 문제가 되는 실행 중인 쿼리의 query id를 사용하면 디버깅에 도움이 되는 스택 트레이스를 얻을 수 있습니다.

```
SET allow_introspection_functions=1;

SELECT
    arrayStringConcat(
        arrayMap(
            x,
            y -> concat(x, ': ', y),
            arrayMap(x -> addressToLine(x), trace),
            arrayMap(x -> demangle(addressToSymbol(x)), trace)
        ),
        '\n'
    ) as trace
FROM
    system.stack_trace
WHERE
    query_id = '0bb6e88b-9b9a-4ffc-b612-5746c859e360';
```

## 가장 최근 오류 확인 \{#view-the-most-recent-errors\}

```
SELECT *
FROM system.errors
ORDER BY last_error_time DESC
```

응답은 다음과 같습니다.

```response
┌─name──────────────────┬─code─┬─value─┬─────last_error_time─┬─last_error_message──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬─last_error_trace─┬─remote─┐
│ UNKNOWN_TABLE         │   60 │     3 │ 2023-03-14 01:02:35 │ Table system.stack_trace doesn't exist                                                                                                              │ []               │      0 │
│ BAD_GET               │  170 │     1 │ 2023-03-14 00:58:55 │ Requested cluster 'default' not found                                                                                                               │ []               │      0 │
│ UNKNOWN_IDENTIFIER    │   47 │     1 │ 2023-03-14 00:49:12 │ Missing columns: 'parts.table' 'table' while processing query: 'table = parts.table', required columns: 'table' 'parts.table' 'table' 'parts.table' │ []               │      0 │
│ NO_ELEMENTS_IN_CONFIG │  139 │     2 │ 2023-03-14 00:42:11 │ Certificate file is not set.                                                                                                                        │ []               │      0 │
└───────────────────────┴──────┴───────┴─────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────────┴────────┘
```

## CPU와 메모리 사용량이 가장 높은 상위 10개 쿼리 \{#top-10-queries-that-are-using-the-most-cpu-and-memory\}

```sql
SELECT
    type,
    event_time,
    initial_query_id,
    formatReadableSize(memory_usage) AS memory,
    `ProfileEvents.Values`[indexOf(`ProfileEvents.Names`, 'UserTimeMicroseconds')] AS userCPU,
    `ProfileEvents.Values`[indexOf(`ProfileEvents.Names`, 'SystemTimeMicroseconds')] AS systemCPU,
    normalizedQueryHash(query) AS normalized_query_hash
FROM system.query_log
ORDER BY memory_usage DESC
LIMIT 10
```

## PROJECTION이 사용 중인 디스크 공간은 얼마나 되나요 \{#how-much-disk-space-are-my-projection-using\}

```sql
SELECT
    name,
    parent_name,
    formatReadableSize(bytes_on_disk) AS bytes,
    formatReadableSize(parent_bytes_on_disk) AS parent_bytes,
    bytes_on_disk / parent_bytes_on_disk AS ratio
FROM system.projection_parts
```

## 전체 데이터베이스에서 system.parts 및 마크 기준 디스크 사용량, 파트 수, 행 수 확인하기 \{#show-disk-storage-number-of-parts-number-of-rows-in-systemparts-and-marks-across-databases\}

```sql
SELECT
    database,
    table,
    partition,
    count() AS parts,
    formatReadableSize(sum(bytes_on_disk)) AS bytes_on_disk,
    formatReadableQuantity(sum(rows)) AS rows,
    sum(marks) AS marks
FROM system.parts
WHERE (database != 'system') AND active
GROUP BY
    database,
    table,
    partition
ORDER BY database ASC
```

## 최근에 기록된 신규 파트의 세부 정보 나열 \{#list-details-of-recently-written-new-parts\}

이 세부 정보에는 생성 시점, 크기, 행 수 등 다양한 정보가 포함됩니다.

```sql
SELECT
    modification_time,
    rows,
    formatReadableSize(bytes_on_disk),
    *
FROM clusterAllReplicas(default, system.parts)
WHERE (database = 'default') AND active AND (level = 0)
ORDER BY modification_time DESC
LIMIT 100
```

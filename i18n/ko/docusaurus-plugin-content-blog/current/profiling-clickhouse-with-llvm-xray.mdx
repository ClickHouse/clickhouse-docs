---
title: "LLVM의 XRay로 ClickHouse 프로파일링하기"
date: 2024-11-13
description: "LLVM의 XRay 계측 프로파일러를 사용해 ClickHouse를 프로파일링하고, 트레이스를 시각화하며, 성능을 분석하는 방법을 설명합니다."
tags: ['성능 및 최적화', '도구 및 유틸리티']
---

import Image from "@theme/IdealImage";
import clickhouse from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/profile.png'
import time_order from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/time-order.png'
import left_heavy from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/left-heavy.png'
import sandwich from '@site/static/images/knowledgebase/profiling-clickhouse-with-llvm-xray/sandwich.png'

{frontMatter.description}

{/* 생략 */}

## 프로파일러의 종류 \{#types-of-profilers\}

LLVM에는 이미 코드를 계측하여 [계측 프로파일링(instrumentation
profiling)](https://en.wikipedia.org/wiki/Profiling_\(computer_programming\)#Instrumentation)을 수행할 수 있는 도구가 포함되어 있습니다. [샘플링 또는 통계적 프로파일링(sampling or statistical profiling)](https://en.wikipedia.org/wiki/Profiling_\(computer_programming\)#Statistical_profilers)과 달리, 어떤 호출도 빠뜨리지 않고 매우 정밀하지만, 코드를 계측해야 하고 더 많은 리소스를 소모한다는 비용이 있습니다.

간단히 말해, 계측 프로파일러는 모든 함수 호출을 추적하기 위해 새로운 코드를 삽입합니다. 통계적 프로파일러는 코드를 수정할 필요 없이 애플리케이션 상태를 확인하기 위해 주기적으로 스냅샷을 찍으면서 코드를 실행할 수 있게 해 줍니다. 따라서 스냅샷을 찍는 시점에 실행 중인 함수만 고려됩니다. [perf](https://en.wikipedia.org/wiki/Perf_%28Linux%29)는 매우 잘 알려진 통계적 프로파일러입니다.

## XRay 통합을 사용한 ClickHouse 프로파일링 \{#profiling-clickhouse-using-xray-integration\}

ClickHouse 25.12에서는 XRay가 통합되어 함수에 새로운 계측 지점을 원활하게 추가할 수 있습니다.
따라서 모든 공식 릴리스에는 이미 이 기능이 포함되어 있으며, 필요할 때만 트리거할 수 있고, 비활성화된
상태에서는 전체 성능에 영향을 주지 않습니다. 최소한의 계측 지점만 활성화하여 유용한 정보를 얻는 것이
목표입니다.

[SYSTEM INSTRUMENT ADD
PROFILE](https://clickhouse.com/docs/sql-reference/statements/system#instrument-add-profile)
SQL 문을 사용하여 새로운 프로파일링 계측 지점을 추가할 수 있습니다. 계측할 함수 목록은
[system.symbols](https://clickhouse.com/docs/operations/system-tables/symbols) 시스템 테이블에서 수집할 수 있습니다. 예를 들어,
실행에 어느 정도 시간이 걸리는지 확인하기에 편리한 `sleepForNanoseconds` 함수를 프로파일링한다고
가정해 보겠습니다.

```sql
SYSTEM INSTRUMENT ADD 'sleepForNanoseconds' PROFILE
```

그런 다음, 프로파일링하려는 기간 동안 애플리케이션을 실행한 뒤 중지합니다.

```sql
SYSTEM INSTRUMENT REMOVE ALL
```

`system.trace_log`에 수집된 데이터를 [Chrome 형식](https://clickhouse.com/docs/operations/system-tables/trace_log#chrome-event-trace-format)으로 변환하여 [Perfetto](https://ui.perfetto.dev)에서 시각화합니다. 각 항목마다 `query_id`, `cpu_id`, `stacktrace`를 확인할 수 있습니다.

<Image img={clickhouse} size="md" alt="time-order" />

## XRay를 사용하여 네이티브 애플리케이션 프로파일링하기 \{#profiling-a-native-application-using-xray\}

다음 섹션은 XRay가 내부적으로 어떻게 동작하는지와 네이티브 애플리케이션을 프로파일링하기 위해 이를 바로 어떻게 사용할 수 있는지를 이해하기 위한 참고용으로 남겨 둔 것입니다.

### 코드 계측하기 \{#instrument-the-code\}

다음과 같은 소스 코드가 있다고 가정합니다:

```cpp
#include <chrono>
#include <cstdio>
#include <thread>

void one()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
}

void two()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(5));
}

int main()
{
    printf("Start\n");

    for (int i = 0; i < 10; ++i)
    {
        one();
        two();
    }

    printf("Finish\n");
}
```

XRay로 계측하려면 다음과 같이 몇 가지 플래그를 추가해야 합니다:

```bash
clang++ -o test test.cpp -fxray-instrument -fxray-instruction-threshold=1
```

* 코드를 계측하기 위해 `-fxray-instrument` 옵션이 필요합니다.
* `-fxray-instruction-threshold=1`은 예제처럼 매우 작은 함수까지 모두 계측하도록 설정합니다. 기본값에서는 [최소 200개의 명령어](https://llvm.org/docs/XRay.html#instrumenting-your-c-c-objective-c-application)를 가진 함수만 계측합니다.

바이너리에 새로운 섹션이 생성되었는지 확인하여 코드가 올바르게 계측되었는지 검증할 수 있습니다.

```bash
objdump -h -j xray_instr_map test

test:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
 17 xray_instr_map 000005c0  000000000002f91c  000000000002f91c  0002f91c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
```

### 적절한 환경 변수 값으로 프로세스를 실행하여 트레이스를 수집합니다 \{#run-the-process-with-proper-env-var-values-to-collect-the-trace\}

기본적으로 명시적으로 요청하지 않으면 프로파일러가 아무 것도 수집하지 않습니다. 즉,
프로파일링을 수행하지 않는 경우 오버헤드는 무시할 만한 수준입니다. 프로파일러가 언제 수집을 시작하고
어떤 방식으로 동작할지 구성하기 위해 `XRAY_OPTIONS`에 다양한 값을 설정할 수 있습니다.

```bash
XRAY_OPTIONS="patch_premain=true xray_mode=xray-basic verbosity=1" ./test
==74394==XRay: Log file in 'xray-log.test.14imlN'
Start
Finish
==74394==Cleaned up log for TID: 74394
```

### 트레이스 변환 \{#convert-the-trace\}

XRay 트레이스는 여러 가지 형식으로 변환할 수 있습니다. `trace_event` 형식은 파싱하기 쉽고 이미 이를 지원하는 도구도 여러 가지 있기 때문에, 여기서는 이 형식을 사용합니다:

```bash
llvm-xray convert --symbolize --instr_map=./test --output-format=trace_event xray-log.test.14imlN | gzip > test-trace.txt.gz
```

### 트레이스 시각화 \{#visualize-the-trace\}

웹 기반 UI인 [speedscope.app](https://www.speedscope.app/)이나
[Perfetto](https://ui.perfetto.dev)를 사용할 수 있습니다.

Perfetto는 여러 스레드를 시각화하고 데이터에 대해 쿼리를 실행하기 더 쉽지만, speedscope는 플레임그래프와 데이터의 「sandwich view」를 생성하는 데 더 적합합니다.

#### 시간 순 \{#time-order\}

<Image img={time_order} size="md" alt="time-order" />

#### 왼쪽으로 치우침 \{#left-heavy\}

<Image img={left_heavy} size="md" alt="왼쪽으로 치우침" />

#### 샌드위치 \{#sandwitch\}

<Image img={sandwich} size="md" alt="샌드위치" />

## 문서 확인하기 \{#check-out-the-docs\}

* [SYSTEM INSTRUMENT](https://clickhouse.com/docs/sql-reference/statements/system#instrument) — 계측 지점을
  추가하거나 제거합니다.
* [system.instrumentation](https://clickhouse.com/docs/operations/system-tables/instrumentation)
  — 계측된 지점을 확인합니다.
* [system.symbols](https://clickhouse.com/docs/operations/system-tables/symbols) — 계측 지점을 추가하기 위한
  심볼을 확인합니다.
* [system.trace&#95;log](https://clickhouse.com/docs/operations/system-tables/trace_log) — 계측 지점을 사용해
  수집한 데이터를 확인합니다.
* [XRay Instrumentation](https://llvm.org/docs/XRay.html)
* 더 자세한 내용을 알아보려면 [Debugging with XRay](https://llvm.org/docs/XRayExample.html) 문서를 참조하십시오.
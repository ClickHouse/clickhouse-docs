---
title: 동기식 데이터 읽기
description: "새 설정 `allow_asynchronous_read_from_io_pool_for_merge_tree`를 사용하면 나머지 쿼리 실행 파이프라인의 스레드 수보다 더 많은 읽기 스레드(스트림)를 사용할 수 있습니다."
date: 2023-03-01
tags: ['Settings', '성능 및 최적화']
keywords: ['동기식', '비동기식', '데이터 읽기']
---

import Image from "@theme/IdealImage";
import sync_read from "@site/static/images/knowledgebase/sync_read.png";
import async_read from "@site/static/images/knowledgebase/async_read.png";
import optimize_read from "@site/static/images/knowledgebase/optimize_read.png";

{frontMatter.description}

{/* 내용 생략 */}

## 동기식 데이터 읽기 \{#synchronous-data-reading\}

새로운 설정인 allow&#95;asynchronous&#95;read&#95;from&#95;io&#95;pool&#95;for&#95;merge&#95;tree를 사용하면 읽기 스레드(스트림) 개수를 나머지 쿼리 실행 파이프라인의 스레드 개수보다 더 많게 설정할 수 있습니다.

일반적으로 [max&#95;threads](https://clickhouse.com/docs/operations/settings/settings/#settings-max_threads) 설정은 병렬 읽기 스레드 수와 병렬 쿼리 처리 스레드 수를 [제어합니다](https://clickhouse.com/company/events/query-performance-introspection):

<Image img={sync_read} size="md" alt="동기식 데이터 읽기 다이어그램" />

데이터는 디스크에서 컬럼별로, 「순서대로」 읽힙니다.

### 비동기 데이터 읽기 \{#asynchronous-data-reading\}

새로운 설정 [allow&#95;asynchronous&#95;read&#95;from&#95;io&#95;pool&#95;for&#95;merge&#95;tree](https://github.com/ClickHouse/ClickHouse/pull/43260)는 읽기 스레드(스트림) 수가 나머지 쿼리 실행 파이프라인의 스레드 수보다 많을 수 있도록 허용하여 **저사양 CPU의 ClickHouse Cloud 서비스에서 콜드 쿼리 속도를 높이고**, **I/O 바운드 쿼리 성능을 향상**합니다.
이 설정이 활성화되면 읽기 스레드 수는 [max&#95;streams&#95;for&#95;merge&#95;tree&#95;reading](https://github.com/ClickHouse/ClickHouse/pull/43260) 설정으로 제어됩니다:

<Image img={async_read} size="md" alt="비동기 데이터 읽기 다이어그램" />

데이터는 서로 다른 컬럼에서 비동기적으로, 병렬로 읽습니다.

또한 읽기 스레드(스트림) 수와 나머지 쿼리 실행 파이프라인의 스레드 수 사이의 비율을 설정하는 [max&#95;streams&#95;to&#95;max&#95;threads&#95;ratio](https://github.com/ClickHouse/ClickHouse/pull/43260) 설정도 있습니다. 그러나 벤치마크 결과에서는 `max_streams_for_merge_tree_reading` 설정만큼의 효과는 나타나지 않았습니다.

### optimize_read_in_order는 어떨까요? \{#what-about-optimize_read_in_order\}

[optimize&#95;read&#95;in&#95;order 최적화](https://clickhouse.com/docs/sql-reference/statements/select/order-by/#optimization-of-data-reading)를 사용하면 ClickHouse는 쿼리의 정렬 순서가 디스크에 저장된 데이터의 물리적 순서를 반영하는 경우 메모리에서 데이터를 다시 정렬하는 과정을 [건너뛸](https://clickhouse.com/blog/clickhouse-faster-queries-with-projections-and-primary-indexes) 수 있습니다. **하지만 이를 위해서는 (비동기 읽기와 달리) 데이터를 순서대로 읽어야 합니다.**

<Image img={optimize_read} size="md" alt="순서대로 읽기 최적화 다이어그램" />

### optimize_read_in_order는 비동기 읽기보다 우선 적용됩니다 \{#optimize_read_in_order-has-precedence-over-asynchronous-reading\}

ClickHouse에서 `optimize_read_in_order` 최적화를 적용할 수 있다고 판단하면 `allow_asynchronous_read_from_io_pool_for_merge_tree` 설정은 무시되어 적용되지 않습니다.

### 위의 모든 내용을 보여주는 예제 \{#example-demonstrating-all-of-the-above\}

* [UK Property Price Paid 테이블](https://clickhouse.com/docs/getting-started/example-datasets/uk-price-paid)을 생성하고 데이터를 로드합니다.

* `max_threads`의 설정값을 확인합니다 (기본값은 쿼리를 실행하는 노드에서 ClickHouse가 인식하는 CPU 코어 수입니다).

```
SELECT getSetting('max_threads');


┌─getSetting('max_threads')─┐
│                        10 │
└───────────────────────────┘
```

* 기본 스레드 수로 데이터 읽기와 처리를 수행하는 쿼리 파이프라인을 확인합니다

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid;

┌─explain──────────────────────┐
│ (Expression)                 │
│ ExpressionTransform × 10     │
│   (ReadFromMergeTree)        │
│   MergeTreeThread × 10 0 → 1 │
└──────────────────────────────┘
```

* 읽기에는 60개의 비동기 스레드를, 쿼리 실행 파이프라인의 나머지 단계에는 기본 스레드 수를 사용하는 쿼리 파이프라인을 확인합니다

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
SETTINGS
    allow_asynchronous_read_from_io_pool_for_merge_tree = 1,
    max_streams_for_merge_tree_reading = 60;


┌─explain────────────────────────┐
│ (Expression)                   │
│ ExpressionTransform × 10       │
│   (ReadFromMergeTree)          │
│   Resize 60 → 10               │
│     MergeTreeThread × 60 0 → 1 │
└────────────────────────────────┘
```

* 데이터 읽기와 처리 모두에 대해 20개의 스레드를 사용하는 쿼리 파이프라인을 확인합니다

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
SETTINGS
    max_threads = 20;


┌─explain──────────────────────┐
│ (Expression)                 │
│ ExpressionTransform × 20     │
│   (ReadFromMergeTree)        │
│   MergeTreeThread × 20 0 → 1 │
└──────────────────────────────┘
```

* 비동기 읽기 스레드 60개와 나머지 쿼리 실행 파이프라인용 스레드 20개로 쿼리 파이프라인을 확인합니다

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
SETTINGS
    max_threads = 20,
    allow_asynchronous_read_from_io_pool_for_merge_tree = 1,
    max_streams_for_merge_tree_reading = 60;


┌─explain────────────────────────┐
│ (Expression)                   │
│ ExpressionTransform × 20       │
│   (ReadFromMergeTree)          │
│   Resize 60 → 20               │
│     MergeTreeThread × 60 0 → 1 │
└────────────────────────────────┘
```

* `optimize_read_in_order optimization`을 적용할 수 있을 때, 비동기 읽기 스레드는 60개, 나머지 쿼리 실행 파이프라인에는 20개의 스레드를 사용하는 쿼리 파이프라인을 확인합니다

```
EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
ORDER BY postcode1, postcode2
SETTINGS
    max_threads = 20,
    allow_asynchronous_read_from_io_pool_for_merge_tree= 1,
    max_streams_for_merge_tree_reading= 60;


┌─explain───────────────────────────┐
│ (Expression)                      │
│ ExpressionTransform               │
│   (Sorting)                       │
│   MergingSortedTransform 20 → 1   │
│     (Expression)                  │
│     ExpressionTransform × 20      │
│       (ReadFromMergeTree)         │
│       MergeTreeInOrder × 20 0 → 1 │
└───────────────────────────────────┘


-- note that this is equivalent to disabling allow_asynchronous_read_from_io_pool_for_merge_tree

EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
ORDER BY postcode1, postcode2
SETTINGS
    max_threads = 20,
    allow_asynchronous_read_from_io_pool_for_merge_tree = 0,
    max_streams_for_merge_tree_reading = 0;


┌─explain───────────────────────────┐
│ (Expression)                      │
│ ExpressionTransform               │
│   (Sorting)                       │
│   MergingSortedTransform 20 → 1   │
│     (Expression)                  │
│     ExpressionTransform × 20      │
│       (ReadFromMergeTree)         │
│       MergeTreeInOrder × 20 0 → 1 │
└───────────────────────────────────┘

-- note that you can enforce allow_asynchronous_read_from_io_pool_for_merge_tree by disabling optimize_read_in_order

EXPLAIN PIPELINE
SELECT *
FROM uk_price_paid
ORDER BY
    postcode1 ASC,
    postcode2 ASC
SETTINGS
    max_threads = 20,
    allow_asynchronous_read_from_io_pool_for_merge_tree = 1,
    max_streams_for_merge_tree_reading = 60,
    optimize_read_in_order = 0;


┌─explain──────────────────────────────┐
│ (Expression)                         │
│ ExpressionTransform                  │
│   (Sorting)                          │
│   MergingSortedTransform 20 → 1      │
│     MergeSortingTransform × 20       │
│       (Expression)                   │
│       ExpressionTransform × 20       │
│         (ReadFromMergeTree)          │
│         Resize 60 → 20               │
│           MergeTreeThread × 60 0 → 1 │
└──────────────────────────────────────┘


```

---
'slug': '/cloud/get-started/cloud/use-cases/AI_ML'
'title': '기계 학습'
'description': 'Learn how ClickHouse powers 기계 학습 applications across the ML pipeline.'
'keywords':
- 'use cases'
- 'Machine Learning'
- 'Generative AI'
'sidebar_label': '기계 학습'
'doc_type': 'guide'
---

import machine_learning_data_layer from '@site/static/images/cloud/onboard/discover/use_cases/ml_data_layer.png'
import online_feature_store from '@site/static/images/cloud/onboard/discover/use_cases/ml_data_layer.png'
import Image from '@theme/IdealImage';


## 머신 러닝 데이터 레이어 {#machine-learning-data-layer}

아마도 머신 러닝 실무자의 시간이 80%는 데이터를 정리하는 데 소비된다는 이야기를 들어보셨을 것입니다.  
이 신화가 사실이든 아니든 상관없이, 데이터는 머신 러닝 문제의 핵심에 해당하며, 시작부터 끝까지 그럴 것입니다.  
RAG 파이프라인을 구축하든, 모델의 미세 조정, 자체 모델 훈련, 모델 성능 평가를 하든, 데이터는 모든 문제의 뿌리입니다.

데이터 관리가 까다로울 수 있으며, 이에 따라 특정 머신 러닝 데이터 문제를 해결하기 위해 생산성을 높이도록 설계된 도구들의 홍수가 발생했습니다.  
이러한 도구들은 일반적으로 특정 하위 문제에 쉽게 적용할 수 있도록 단순해 보이는 의견이 있는 인터페이스를 갖춘 보다 일반적인 솔루션을 둘러싼 추상화 레이어의 형태를 취하는 경우가 많습니다.  
실제로 이는 특정 작업의 용이성과 단순성을 선호하는 대가로 일반적인 솔루션의 유연성을 줄입니다.

<Image img={machine_learning_data_layer} size="sm"/>

이 접근 방식에는 몇 가지 단점이 있습니다.  
상세한 도구, 제품 및 서비스의 계단식 구성은, 일반적인 솔루션과 지원 응용 프로그램 코드와 결합할 때보다 더 많은 아키텍처의 복잡성과 데이터 비용의 위험을 초래합니다.  
도구와 서비스의 끝없는 목록에 실수로 빠지는 것은 쉽고, 각 도구와 서비스는 단지 한 단계의 작업에만 사용됩니다.

이러한 위험에 대한 두 가지 일반적인 측면이 있습니다:

1. **학습, 유지 보수 및 전환 비용**

머신 러닝 아키텍처는 다양한 도구와 구성 요소로 인해 너무 복잡해지면 학습하고 관리하기 어려운 단편화된 환경을 형성할 수 있습니다. 이는 실패의 지점과 비용 증가를 초래합니다.

2. **데이터 중복 및 전송 비용**

머신 러닝 파이프라인에서 여러 개의 불연속적이지만 겹치는 데이터 시스템을 사용하는 것은 데이터 전송에 불필요하고 종종 비용이 많이 드는 오버헤드를 도입할 수 있습니다.

이 트레이드오프의 훌륭한 예가 벡터 데이터베이스입니다.  
벡터 데이터베이스는 벡터를 저장하고 검색하는 데 필요한 초특화된 머신 러닝 작업을 위해 설계되었습니다.  
이것이 일부 아키텍처에서 올바른 선택일 수 있지만, 다른 아키텍처에서는 벡터 데이터베이스가 통합, 관리 및 데이터 전송을 위해 또 다른 시스템이 될 수 있는 불필요한 새로운 추가일 수 있습니다.  
대부분의 최신 일반적인 데이터베이스는 기본적으로(또는 플러그인을 통해) 벡터 지원을 제공하며, 더 넓고 교차적인 기능을 가지고 있습니다.  
다시 말해, 이러한 아키텍처에서 벡터를 특별히 처리하기 위해 새로운 데이터베이스가 필요하지 않을 수 있습니다.  
중요성은 벡터 전용 편의 기능(예: 내장된 임베딩 모델)이 임무의 중요한 요소인지 그리고 비용을 정당화할 수 있는지로 축소됩니다.

### 데이터 탐색 {#data-exploration}

머신 러닝 문제, 목표 및 성공 기준을 정의한 후, 모델 훈련 및 평가에 사용될 관련 데이터를 탐색하는 것이 일반적인 첫 번째 단계입니다.

이 단계에서는 데이터의 특성, 분포 및 관계를 이해하기 위해 분석됩니다.  
이 평가 및 이해의 과정은 반복적이며, 종종 데이터셋 전반에 걸쳐 일련의 즉흥 쿼리를 실행하게 됩니다. 이 때 쿼리 응답성이 중요합니다(비용 효율성과 정확성 같은 다른 요소와 함께).  
기업들이 머신 러닝 목적으로 활용할 데이터의 양을 늘려감에 따라, 기존 데이터를 조사하는 문제는 더 어려워집니다.

전통적인 데이터 시스템에서는 분석 및 평가 쿼리가 대규모에서 지치게 하거나 금지될 정도로 느려지기 때문입니다.  
몇몇 업체들은 쿼리 시간을 단축하기 위해 상당히 증가된 비용을 부과하며, 쿼리당 요금이나 스캔한 바이트 수에 따라 즉흥 평가를 억제합니다.  
엔지니어들은 이러한 한계를 타협하기 위해 데이터의 하위 집합을 자신의 로컬 머신으로 가져오는 경우도 있습니다.

반면 ClickHouse는 실시간 데이터 웨어하우스이므로 사용자는 분석 계산에 대한 업계 최고의 쿼리 속도의 이점을 누릴 수 있습니다.  
추가적으로 ClickHouse는 처음부터 높은 성능을 제공하며, 가격이 비싼 상위 티어 뒤에 중요한 쿼리 가속 기능을 가두지 않습니다.  
ClickHouse는 Iceberg, Delta Lake 및 Hudi와 같은 일반 형식에 대한 지원을 통해 객체 저장소 또는 데이터 레이크에서 데이터를 직접 쿼리할 수 있습니다.  
이는 데이터가 존재하는 위치에 관계없이 ClickHouse가 머신 러닝 워크로드를 위한 통합된 접근 및 계산 레이어로 기능할 수 있다는 것을 의미합니다.

ClickHouse에는 페타바이트 규모의 데이터에 대해 확장 가능한 다양한 미리 구축된 통계 및 집계 기능이 있어 복잡한 계산을 실행하는 간단한 SQL을 쉽게 작성하고 유지할 수 있습니다.  
가장 세분화된 정밀 데이터 유형 및 코덱을 지원하므로 데이터의 세분성을 줄이는 것에 대해 걱정할 필요가 없습니다.

사용자는 SQL 쿼리를 사용하여 ClickHouse 내에서 직접 데이터를 변환할 수 있거나 삽입 전에 변환할 수 있지만, ClickHouse는 또한 [chDB](/chdb)를 통해 Python과 같은 프로그래밍 환경에서도 사용할 수 있습니다.  
이것은 내장된 ClickHouse를 Python 모듈로 노출하고 노트북 내에서 큰 데이터 프레임을 변환하고 조작하는 데 사용될 수 있습니다.  
따라서 데이터 엔지니어는 클라이언트 측에서 변환 작업을 수행할 수 있으며, 결과는 중앙 집중식 ClickHouse 인스턴스의 피처 테이블로 실재화될 수 있습니다.

### 데이터 준비 및 피처 추출 {#data-preparation-and-feature-extraction}

그런 다음 데이터가 준비됩니다: 정리되고 변환되며 모델이 훈련되고 평가될 피처가 추출됩니다.  
이 구성 요소는 때때로 피처 생성 또는 추출 파이프라인이라고 불리며, 새로운 도구가 자주 도입되는 머신 러닝 데이터 레이어의 또 다른 조각입니다.  
Neptune 및 Hopsworks와 같은 MLOps 플레이어는 이러한 파이프라인을 조정하는 데 사용되는 다양한 데이터 변환 제품의 예를 제공합니다.  
그러나 데이터베이스에서 작동하는 별도의 도구이기 때문에 이들은 부서질 위험이 있으며, 수동으로 수정해야 하는 중단을 초래할 수 있습니다.

대조적으로 데이터 변환은 [물리화된 뷰](/materialized-views)를 통해 ClickHouse 내에서 직접 쉽게 수행할 수 있습니다.  
이들은 새로운 데이터가 ClickHouse 소스 테이블에 삽입될 때 자동으로 트리거되며, 데이터가 도착할 때 쉽게 추출, 변환 및 수정하는 데 사용됩니다 - 이는 맞춤형 파이프라인을 직접 구축하고 모니터링할 필요성을 없애줍니다.  
이러한 변환이 메모리에 맞지 않을 수 있는 전체 데이터셋에 대한 집계를 요구할 경우, ClickHouse를 활용하면 지역 머신에서 데이터 프레임과 함께 작업하기 위해 이 단계를 조정할 필요가 없습니다.  
더 편리하게 로컬에서 평가할 수 있는 데이터셋의 경우, [ClickHouse local](/operations/utilities/clickhouse-local)과 [chDB](/chdb)가 훌륭한 대안이 되어, 사용자가 Pandas와 같은 표준 Python 데이터 라이브러리와 함께 ClickHouse를 활용할 수 있도록 합니다.

### 훈련 및 평가 {#training-and-evaluation}

이 시점에서 피처는 훈련, 검증 및 테스트 세트로 나뉘게 됩니다.  
이 데이터 세트는 버전 관리되고, 각각의 단계에서 활용됩니다.

파이프라인의 이 단계에서 머신 러닝 데이터 레이어에 또 다른 전문 도구, 즉 피처 저장소를 도입하는 것이 일반적입니다.  
피처 저장소는 모델 훈련, 추론 및 평가를 위한 데이터 관리를 위한 편의 기능을 제공하는 데이터베이스 주위의 추상화 레이어입니다.  
이러한 편의 기능의 예로는 버전 관리, 접근 관리 및 피처 정의를 SQL 문으로 자동 변환하는 기능이 포함됩니다.

피처 저장소의 경우 ClickHouse는 다음과 같은 역할을 수행할 수 있습니다:

**데이터 소스** - Iceberg 및 Delta Lake와 같은 데이터 레이크 형식을 포함하여 70개 이상의 파일 형식으로 데이터를 쿼리하거나 수집할 수 있는 기능을 갖춘 ClickHouse는 데이터를 보관하거나 쿼리하는 데 이상적인 장기 저장소입니다.  
객체 저장소를 이용하여 저장소와 계산을 분리함으로써, ClickHouse Cloud는 데이터를 무기한 보관할 수 있도록 하며 - 계산을 축소하거나 완전히 비활성화하여 비용을 최소화합니다.  
유연한 코덱과 결합된 컬럼 지향 저장소 및 디스크의 데이터 정렬은 압축 비율을 극대화하므로 필요한 저장소를 최소화합니다.  
사용자는 ClickHouse와 데이터 레이크를 쉽게 결합할 수 있으며, 객체 저장소의 데이터를 제자리에서 쿼리할 수 있는 내장 함수를 갖추고 있습니다.

**변환 엔진** - SQL은 데이터 변환을 선언하는 자연스러운 수단을 제공합니다.  
ClickHouse의 분석 및 통계 기능으로 확장될 때 이러한 변환은 간결하고 최적화됩니다.  
ClickHouse 테이블에 적용되는 것 외에도 ClickHouse가 데이터 저장소로 사용되는 경우, 테이블 함수는 Parquet와 같은 형식으로 저장된 데이터에 대해 SQL 쿼리를 작성할 수 있게 합니다.  
전체 병렬 쿼리 실행 엔진과 컬럼 지향 저장 형식의 조합으로 ClickHouse는 PB 단위의 데이터에서 평균 초 단위로 집계를 수행할 수 있습니다 - 메모리 내 데이터 프레임에서의 변환과는 달리 사용자는 메모리 한계가 없습니다.  
또한 물리화된 뷰는 데이터 삽입 시 변환될 수 있어 쿼리 시점에서 데이터 로드 시간으로 컴퓨트를 과부하 시킵니다.  
이러한 뷰는 데이터 분석 및 요약에 적합한 동일한 범위의 분석 및 통계 기능을 활용할 수 있습니다.  
ClickHouse의 기존 분석 기능이 부족하거나 사용자 정의 라이브러리 통합이 필요할 경우, 사용자는 사용자 정의 함수(UDF)를 활용할 수도 있습니다.

#### 오프라인 피처 저장소 {#offline-feature-store}

오프라인 피처 저장소는 모델 훈련에 사용됩니다.  
이는 일반적으로 피처 자체가 배치 프로세스 데이터 변환 파이프라인을 통해 생성되며(위 섹션에서 설명한 대로) 이러한 피처의 가용성에 반드시 엄격한 지연 요구 사항이 있는 것은 아닙니다.

여러 출처에서 데이터를 읽고 SQL 쿼리를 통해 변환을 적용하는 기능으로, 이러한 쿼리의 결과는 `INSERT INTO SELECT` 문을 통해 ClickHouse에 지속될 수 있습니다.  
변환이 엔터티 ID로 그룹화되고 여러 컬럼을 결과로 반환하는 경우, ClickHouse의 스키마 추론은 이러한 결과로부터 필요한 유형을 자동으로 감지하고 이를 저장하기 위한 적절한 테이블 스키마를 생성할 수 있습니다.  
임의 숫자 생성 및 통계 샘플링을 위한 함수는 모델 훈련 파이프라인으로 제공하기 위해 데이터가 초당 수백만 행으로 효율적으로 반복되고 확장될 수 있도록 합니다.

종종 피처는 특정 시점의 엔티티 및 피처 값이 표시된 타임스탬프가 있는 테이블로 표현됩니다.  
앞서 설명했듯이, 훈련 파이프라인은 종종 특정 시점 및 그룹에서 피처의 상태가 필요합니다. ClickHouse의 스파스 인덱스는 시점 쿼리 및 피처 선택 필터를 충족하기 위해 데이터를 신속하게 필터링할 수 있습니다.  
Spark, Redshift 및 BigQuery와 같은 다른 기술은 특정 시점에서 피처의 상태를 식별하기 위해 느린 상태 유지 윈도우 방식에 의존하는 반면, ClickHouse는 ASOF (as-of-this-time) LEFT JOIN 쿼리 및 argMax 기능을 지원합니다.  
이 접근 방식은 구문을 단순화할 뿐만 아니라 정렬 및 병합 알고리즘을 통해 대형 데이터셋에서 높은 성능을 발휘합니다.  
이를 통해 피처 그룹을 신속하게 구축할 수 있어 훈련 이전의 데이터 준비 시간을 단축할 수 있습니다.

#### 온라인 피처 저장소 {#online-feature-store}

온라인 피처 저장소는 추론에 사용되는 최신 버전의 피처를 저장하는 데 사용되며, 실시간으로 적용됩니다.  
이는 이러한 피처가 실시간 머신 러닝 서비스의 일환으로 사용되기 때문에 최소한의 지연 시간으로 계산되어야 함을 의미합니다.

<Image img={online_feature_store} size="sm"/>

실시간 분석 데이터베이스인 ClickHouse는 낮은 지연 시간으로 높은 동시 쿼리 워크로드를 처리할 수 있습니다.  
일반적으로 데이터가 비정규화되어야 하지만, 이것은 훈련 시점과 추론 시점에 사용되는 피처 그룹의 저장과 일치합니다.  
중요하게도 ClickHouse는 로그 구조 병합 트리 덕분에 높은 쓰기 작업 부하를 받으면서도 이러한 쿼리 성능을 제공합니다.  
이러한 속성은 온라인 저장소에서 피처를 최신 상태로 유지하기 위해 필요합니다.  
피처가 이미 오프라인 저장소 내에 사용 가능하기 때문에, 동일한 ClickHouse 클러스터 내에서 또는 `remoteSecure`와 같은 기존 기능을 통해 다른 인스턴스 내에서 새로운 테이블로 쉽게 실체화할 수 있습니다.  
ClickHouse Cloud 내의 [ClickPipes](/integrations/clickpipes/kafka)를 통한 정확히 한 번 수행하는 Kafka Connect 제공 또는 Kafka와의 통합은 스트리밍 소스에서의 데이터를 손쉽고 신뢰할 수 있도록 소비할 수 있게 만듭니다.

많은 현대 시스템이 오프라인 및 온라인 저장소 모두를 필요로 하며, 여기서 두 개의 전문 피처 저장소가 필요하다고 결론을 쉽게 내릴 수 있습니다.  
하지만 이는 두 저장소를 동기화 상태로 유지하는 것의 복잡성을 추가하며, 물론 여기에는 이들 간의 데이터 복제 비용도 포함됩니다.

ClickHouse와 같은 실시간 데이터 웨어하우스는 오프라인 및 온라인 피처 관리를 모두 지원하는 단일 시스템입니다.  
ClickHouse는 스트리밍 및 기록 데이터를 효율적으로 처리하며, 실시간 추론 및 오프라인 학습을 제공하는 피처를 지원하는 데 필요한 무제한 확장성, 성능 및 동시성을 갖추고 있습니다.

이 단계에서 피처 저장소 제품을 사용하는 것과 실시간 데이터 웨어하우스를 직접 활용하는 것 간의 트레이드오프를 고려할 때, 버전 관리와 같은 편의 기능은 테이블 또는 스키마 설계와 같은 오래된 데이터베이스 패러다임을 통해 달성할 수 있다는 점을 강조할 가치가 있습니다.  
피처 정의를 SQL 문으로 변환하는 다른 기능은 존재하는 추상화 레이어의 의견보다는 응용 프로그램 또는 비즈니스 논리의 일환으로 더 큰 유연성을 제공할 수 있습니다.

### 추론 {#inference}

모델 추론은 훈련된 모델을 실행하여 출력을 받는 과정입니다.  
데이터베이스 작업(예: 새 레코드 삽입 또는 레코드 쿼리)으로 인해 추론이 트리거될 때, 이 추론 단계는 맞춤형 작업 또는 응용 프로그램 코드로 관리될 수 있습니다.

반면, 데이터 레이어 자체에서 관리될 수도 있습니다. ClickHouse [사용자 정의 함수 (UDF)](/sql-reference/functions/udf)를 사용하면 사용자가 삽입 또는 쿼리 시 ClickHouse에서 모델을 직접 호출할 수 있는 기능을 제공합니다.  
이는 들어오는 데이터를 모델에 전달하고 출력을 받고 이 결과를 수집된 데이터와 함께 자동으로 저장할 수 있게 합니다 - 다른 프로세스나 작업을 시작할 필요 없이 말입니다.  
이 과정은 이 단계를 관리하기 위한 단일 인터페이스인 SQL을 제공합니다.

### 벡터 저장소 {#vector-store}

벡터 저장소는 벡터를 저장하고 검색하는 데 최적화된 특정 유형의 데이터베이스로, 일반적으로 데이터의 임베딩(예: 텍스트 또는 이미지)으로, 이들은 그 기본 의미를 숫자로 포착합니다.  
벡터는 오늘날의 생성적 AI 물결의 핵심이며, 무수한 애플리케이션에서 사용됩니다.

벡터 데이터베이스에서 주요 작업은 수학적 측정 기준에 따라 서로 "가장 가까운" 벡터를 찾는 "유사성 검색"입니다.  
벡터 데이터베이스는 검토를 가능한 한 빠르게 만드는 특정 전술을 사용하기 때문에 인기를 얻었습니다 - 벡터 비교를 대신해서 입력 벡터를 저장된 모든 벡터와 비교하는 대신 벡터 비교를 근사화합니다.

이 새로운 도구 클래스의 문제는 일반적인 데이터베이스, ClickHouse를 포함하여, 기본적으로 벡터 지원을 제공하며 이러한 근사화 접근 방식을 내장하고 있는 경우가 많다는 것입니다.  
특히 ClickHouse는 높은 성능의 대규모 분석을 위해 설계되었으며 - 비근사적인 벡터 비교를 매우 효과적으로 수행할 수 있습니다.  
이는 속도를 희생하지 않고도 정확한 결과를 얻을 수 있음을 의미합니다.

### 가시성 {#observability}

귀하의 머신 러닝 애플리케이션이 라이브 상태가 되면, 모델의 행동, 성능 및 개선 가능 영역에 대한 귀중한 통찰을 제공하는 데이터(로그 및 추적 데이터 포함)를 생성하게 됩니다.  

SQL 기반의 가시성은 ClickHouse의 또 다른 주요 사용 사례로, ClickHouse는 대안보다 10-100배 더 비용 효율적인 것으로 나타났습니다.  
사실, 많은 가시성 제품은 내부적으로 ClickHouse로 구축되어 있습니다.  
ClickHouse는 업계 최고의 수집 비율과 압축 비율을 제공하여, 모든 규모의 머신 러닝 가시성을 지원하는 비용 효율성과 빠른 속도를 제공합니다.

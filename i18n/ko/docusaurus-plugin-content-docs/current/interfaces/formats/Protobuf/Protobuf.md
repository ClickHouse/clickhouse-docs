---
'alias': []
'description': 'Protobuf 형식에 대한 Documentation'
'input_format': true
'keywords':
- 'Protobuf'
'output_format': true
'slug': '/interfaces/formats/Protobuf'
'title': 'Protobuf'
'doc_type': 'guide'
---


| Input | Output | Alias |
|-------|--------|-------|
| ✔     | ✔      |       |

## 설명 {#description}

`Protobuf` 형식은 [프로토콜 버퍼](https://protobuf.dev/) 형식입니다.

이 형식은 쿼리 간에 캐시되는 외부 형식 스키마를 필요로 합니다.

ClickHouse는 다음을 지원합니다:
- `proto2` 및 `proto3` 구문 모두.
- `Repeated`/`optional`/`required` 필드.

ClickHouse는 테이블 컬럼과 프로토콜 버퍼의 메시지 타입 필드 간의 대응 관계를 찾기 위해 그 이름을 비교합니다.
이 비교는 대소문자를 구분하지 않으며, 문자 `_` (언더스코어)와 `.` (닷)은 동등하게 간주됩니다.
컬럼과 프로토콜 버퍼 메시지의 필드의 타입이 다르다면 필요한 변환이 적용됩니다.

중첩 메시지를 지원합니다. 예를 들어, 다음 메시지 타입의 필드 `z`에 대한 경우:

```capnp
message MessageType {
  message XType {
    message YType {
      int32 z;
    };
    repeated YType y;
  };
  XType x;
};
```

ClickHouse는 `x.y.z` (또는 `x_y_z` 또는 `X.y_Z` 등)이라는 이름의 컬럼을 찾으려고 합니다.

중첩 메시지는 [중첩 데이터 구조](/sql-reference/data-types/nested-data-structures/index.md)의 입력 또는 출력에 적합합니다.

다음과 같은 protobuf 스키마에 정의된 기본 값은 적용되지 않고, 대신 [테이블 기본값](/sql-reference/statements/create/table#default_values)이 사용됩니다:

```capnp
syntax = "proto2";

message MessageType {
  optional int32 result_per_page = 3 [default = 10];
}
```

메시지가 [oneof](https://protobuf.dev/programming-guides/proto3/#oneof)를 포함하고 있고 `input_format_protobuf_oneof_presence`가 설정되면, ClickHouse는 어떤 oneof 필드가 발견되었는지를 나타내는 컬럼을 채웁니다.

```capnp
syntax = "proto3";

message StringOrString {
  oneof string_oneof {
    string string1 = 1;
    string string2 = 42;
  }
}
```

```sql
CREATE TABLE string_or_string ( string1 String, string2 String, string_oneof Enum('no'=0, 'hello' = 1, 'world' = 42))  Engine=MergeTree ORDER BY tuple();
INSERT INTO string_or_string from INFILE '$CURDIR/data_protobuf/String1' SETTINGS format_schema='$SCHEMADIR/string_or_string.proto:StringOrString' FORMAT ProtobufSingle;
SELECT * FROM string_or_string
```

```text
   ┌─────────┬─────────┬──────────────┐
   │ string1 │ string2 │ string_oneof │
   ├─────────┼─────────┼──────────────┤
1. │         │ string2 │ world        │
   ├─────────┼─────────┼──────────────┤
2. │ string1 │         │ hello        │
   └─────────┴─────────┴──────────────┘
```

존재를 나타내는 컬럼의 이름은 oneof의 이름과 같아야 합니다. 중첩 메시지가 지원됩니다 (기본 예제 참고) ([basic-examples](#basic-examples)).
허용되는 타입은 Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Enum, Enum8 또는 Enum16입니다.
Enum (그리고 Enum8 또는 Enum16)에는 하나의 태그로 존재하지 않음을 나타내기 위해 0이 포함되어야 하며, 문자열 표현은 중요하지 않습니다.

설정 [`input_format_protobuf_oneof_presence`](/operations/settings/settings-formats.md#input_format_protobuf_oneof_presence)는 기본적으로 비활성화되어 있습니다.

ClickHouse는 `length-delimited` 형식으로 protobuf 메시지를 입력하고 출력합니다.
이는 모든 메시지 앞에 해당 길이가 [가변 너비 정수 (varint)](https://developers.google.com/protocol-buffers/docs/encoding#varints)로 기록되어야 함을 의미합니다.

## 사용 예 {#example-usage}

### 데이터 읽기 및 쓰기 {#basic-examples}

:::note 예제 파일
이 예제에서 사용된 파일은 [예제 리포지토리](https://github.com/ClickHouse/formats/ProtoBuf)에서 확인할 수 있습니다.
:::

이 예제에서는 `protobuf_message.bin` 파일에서 ClickHouse 테이블로 데이터를 읽고, 이후 `Protobuf` 형식을 사용하여 `protobuf_message_from_clickhouse.bin`이라는 파일로 다시 씁니다.

`schemafile.proto` 파일이 주어졌을 때:

```capnp
syntax = "proto3";  

message MessageType {  
  string name = 1;  
  string surname = 2;  
  uint32 birthDate = 3;  
  repeated string phoneNumbers = 4;  
};
```

<details>
<summary>바이너리 파일 생성</summary>

이미 `Protobuf` 형식으로 데이터를 직렬화하고 역직렬화하는 방법을 아는 경우 이 단계를 건너뛸 수 있습니다.

Python을 사용하여 일부 데이터를 `protobuf_message.bin`으로 직렬화하고, ClickHouse로 읽습니다.
다른 언어를 사용하고 싶다면, 다음도 참고하세요: ["인기 있는 언어에서 length-delimited Protobuf 메시지를 읽기/쓰기"](https://cwiki.apache.org/confluence/display/GEODE/Delimiting+Protobuf+Messages).

다음 명령을 실행하여 `schemafile.proto`와 동일한 디렉토리에 `schemafile_pb2.py`라는 Python 파일을 생성합니다. 이 파일은 `UserData` Protobuf 메시지를 나타내는 Python 클래스를 포함합니다:

```bash
protoc --python_out=. schemafile.proto
```

이제 `schemafile_pb2.py`와 동일한 디렉토리에 `generate_protobuf_data.py`라는 새로운 Python 파일을 생성하고, 다음 코드를 붙여넣습니다:

```python
import schemafile_pb2  # Module generated by 'protoc'
from google.protobuf import text_format
from google.protobuf.internal.encoder import _VarintBytes # Import the internal varint encoder

def create_user_data_message(name, surname, birthDate, phoneNumbers):
    """
    Creates and populates a UserData Protobuf message.
    """
    message = schemafile_pb2.MessageType()
    message.name = name
    message.surname = surname
    message.birthDate = birthDate
    message.phoneNumbers.extend(phoneNumbers)
    return message


# The data for our example users
data_to_serialize = [
    {"name": "Aisha", "surname": "Khan", "birthDate": 19920815, "phoneNumbers": ["(555) 247-8903", "(555) 612-3457"]},
    {"name": "Javier", "surname": "Rodriguez", "birthDate": 20001015, "phoneNumbers": ["(555) 891-2046", "(555) 738-5129"]},
    {"name": "Mei", "surname": "Ling", "birthDate": 19980616, "phoneNumbers": ["(555) 956-1834", "(555) 403-7682"]},
]

output_filename = "protobuf_messages.bin"


# Open the binary file in write-binary mode ('wb')
with open(output_filename, "wb") as f:
    for item in data_to_serialize:
        # Create a Protobuf message instance for the current user
        message = create_user_data_message(
            item["name"],
            item["surname"],
            item["birthDate"],
            item["phoneNumbers"]
        )

        # Serialize the message
        serialized_data = message.SerializeToString()

        # Get the length of the serialized data
        message_length = len(serialized_data)

        # Use the Protobuf library's internal _VarintBytes to encode the length
        length_prefix = _VarintBytes(message_length)

        # Write the length prefix
        f.write(length_prefix)
        # Write the serialized message data
        f.write(serialized_data)

print(f"Protobuf messages (length-delimited) written to {output_filename}")


# --- Optional: Verification (reading back and printing) ---

# For reading back, we'll also use the internal Protobuf decoder for varints.
from google.protobuf.internal.decoder import _DecodeVarint32

print("\n--- Verifying by reading back ---")
with open(output_filename, "rb") as f:
    buf = f.read() # Read the whole file into a buffer for easier varint decoding
    n = 0
    while n < len(buf):
        # Decode the varint length prefix
        msg_len, new_pos = _DecodeVarint32(buf, n)
        n = new_pos

        # Extract the message data
        message_data = buf[n:n+msg_len]
        n += msg_len

        # Parse the message
        decoded_message = schemafile_pb2.MessageType()
        decoded_message.ParseFromString(message_data)
        print(text_format.MessageToString(decoded_message, as_utf8=True))
```

이제 명령 줄에서 스크립트를 실행합니다. 파이썬 가상 환경에서 실행하는 것이 좋으며, `uv`를 사용하는 것을 예로 들 수 있습니다:

```bash
uv venv proto-venv
source proto-venv/bin/activate
```

다음과 같은 파이썬 라이브러리를 설치해야 합니다:

```bash
uv pip install --upgrade protobuf
```

스크립트를 실행하여 바이너리 파일을 생성합니다:

```bash
python generate_protobuf_data.py
```

</details>

스키마와 일치하는 ClickHouse 테이블을 생성합니다:

```sql
CREATE DATABASE IF NOT EXISTS test;
CREATE TABLE IF NOT EXISTS test.protobuf_messages (
  name String,
  surname String,
  birthDate UInt32,
  phoneNumbers Array(String)
)
ENGINE = MergeTree()
ORDER BY tuple()
```

명령 줄에서 테이블에 데이터를 삽입합니다:

```bash
cat protobuf_messages.bin | clickhouse-client --query "INSERT INTO test.protobuf_messages SETTINGS format_schema='schemafile:MessageType' FORMAT Protobuf"
```

`Protobuf` 형식을 사용하여 데이터를 바이너리 파일로 다시 쓸 수도 있습니다:

```sql
SELECT * FROM test.protobuf_messages INTO OUTFILE 'protobuf_message_from_clickhouse.bin' FORMAT Protobuf SETTINGS format_schema = 'schemafile:MessageType'
```

Protobuf 스키마를 사용하여 ClickHouse에서 파일 `protobuf_message_from_clickhouse.bin`에 작성된 데이터를 지금 역직렬화할 수 있습니다.

### ClickHouse Cloud를 사용한 데이터 읽기 및 쓰기 {#basic-examples-cloud}

ClickHouse Cloud에서는 Protobuf 스키마 파일을 업로드할 수 없습니다. 그러나 `format_protobuf_schema` 설정을 사용하여 쿼리에서 스키마를 지정할 수 있습니다. 이 예제에서는 로컬 머신에서 직렬화된 데이터를 읽어 ClickHouse Cloud의 테이블에 삽입하는 방법을 보여줍니다.

이전 예와 같이 ClickHouse Cloud에서 Protobuf 스키마에 따라 테이블을 생성합니다:

```sql
CREATE DATABASE IF NOT EXISTS test;
CREATE TABLE IF NOT EXISTS test.protobuf_messages (
  name String,
  surname String,
  birthDate UInt32,
  phoneNumbers Array(String)
)
ENGINE = MergeTree()
ORDER BY tuple()
```

설정 `format_schema_source`는 `format_schema`의 출처를 정의합니다.

가능한 값:
- 'file' (기본값): Cloud에서 지원되지 않음
- 'string': `format_schema`는 스키마의 리터럴 내용입니다.
- 'query': `format_schema`는 스키마를 가져오기 위한 쿼리입니다.

### `format_schema_source='string'` {#format-schema-source-string}

데이터를 ClickHouse Cloud에 삽입할 때, 스키마를 문자열로 지정하여 실행합니다:

```bash
cat protobuf_messages.bin | clickhouse client --host <hostname> --secure --password <password> --query "INSERT INTO testing.protobuf_messages SETTINGS format_schema_source='syntax = "proto3";message MessageType {  string name = 1;  string surname = 2;  uint32 birthDate = 3;  repeated string phoneNumbers = 4;};', format_schema='schemafile:MessageType' FORMAT Protobuf"
```

테이블에 삽입된 데이터를 선택합니다:

```sql
clickhouse client --host <hostname> --secure --password <password> --query "SELECT * FROM testing.protobuf_messages"
```

```response
Aisha Khan 19920815 ['(555) 247-8903','(555) 612-3457']
Javier Rodriguez 20001015 ['(555) 891-2046','(555) 738-5129']
Mei Ling 19980616 ['(555) 956-1834','(555) 403-7682']
```

### `format_schema_source='query'` {#format-schema-source-query}

Protobuf 스키마를 테이블에 저장할 수도 있습니다.

ClickHouse Cloud에서 데이터 삽입을 위한 테이블을 생성합니다:

```sql
CREATE TABLE testing.protobuf_schema (
  schema String
)
ENGINE = MergeTree()
ORDER BY tuple();
```

```sql
INSERT INTO testing.protobuf_schema VALUES ('syntax = "proto3";message MessageType {  string name = 1;  string surname = 2;  uint32 birthDate = 3;  repeated string phoneNumbers = 4;};');
```

ClickHouse Cloud에 데이터를 삽입할 때, 실행할 쿼리로 스키마를 지정합니다:

```bash
cat protobuf_messages.bin | clickhouse client --host <hostname> --secure --password <password> --query "INSERT INTO testing.protobuf_messages SETTINGS format_schema_source='SELECT schema FROM testing.protobuf_schema', format_schema='schemafile:MessageType' FORMAT Protobuf"
```

테이블에 삽입된 데이터를 선택합니다:

```sql
clickhouse client --host <hostname> --secure --password <password> --query "SELECT * FROM testing.protobuf_messages"
```

```response
Aisha Khan 19920815 ['(555) 247-8903','(555) 612-3457']
Javier Rodriguez 20001015 ['(555) 891-2046','(555) 738-5129']
Mei Ling 19980616 ['(555) 956-1834','(555) 403-7682']
```

### 자동 생성된 스키마 사용 {#using-autogenerated-protobuf-schema}

데이터에 대한 외부 Protobuf 스키마가 없는 경우에도 자동 생성된 스키마를 사용하여 Protobuf 형식으로 데이터를 입력/출력할 수 있습니다. 이를 위해 `format_protobuf_use_autogenerated_schema` 설정을 사용합니다.

예를 들어:

```sql
SELECT * FROM test.hits format Protobuf SETTINGS format_protobuf_use_autogenerated_schema=1
```

이 경우 ClickHouse는 [`structureToProtobufSchema`](/sql-reference/functions/other-functions#structureToProtobufSchema) 기능을 사용하여 테이블 구조에 따라 Protobuf 스키마를 자동 생성합니다. 그런 다음 이 스키마를 사용하여 Protobuf 형식으로 데이터를 직렬화합니다.

자동 생성된 스키마로 Protobuf 파일을 읽을 수도 있습니다. 이 경우 파일이 동일한 스키마를 사용하여 생성되어야 합니다:

```bash
$ cat hits.bin | clickhouse-client --query "INSERT INTO test.hits SETTINGS format_protobuf_use_autogenerated_schema=1 FORMAT Protobuf"
```

설정 [`format_protobuf_use_autogenerated_schema`](/operations/settings/settings-formats.md#format_protobuf_use_autogenerated_schema)는 기본적으로 활성화되어 있으며 [`format_schema`](/operations/settings/formats#format_schema)가 설정되지 않은 경우에 적용됩니다.

입력/출력 시 자동 생성된 스키마를 파일에 저장할 수도 있으며, 이때 [`output_format_schema`](/operations/settings/formats#output_format_schema) 설정을 사용합니다. 예를 들어:

```sql
SELECT * FROM test.hits format Protobuf SETTINGS format_protobuf_use_autogenerated_schema=1, output_format_schema='path/to/schema/schema.proto'
```

이 경우 자동 생성된 Protobuf 스키마는 `path/to/schema/schema.capnp` 파일에 저장됩니다.

### 프로토콜 버퍼 캐시 삭제 {#drop-protobuf-cache}

[`format_schema_path`](/operations/server-configuration-parameters/settings.md/#format_schema_path)에서 로드된 Protobuf 스키마를 다시 로드하려면 [`SYSTEM DROP ... FORMAT CACHE`](/sql-reference/statements/system.md/#system-drop-schema-format) 문을 사용하십시오.

```sql
SYSTEM DROP FORMAT SCHEMA CACHE FOR Protobuf
```

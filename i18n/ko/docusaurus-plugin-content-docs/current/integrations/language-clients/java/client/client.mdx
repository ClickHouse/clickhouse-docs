---
sidebar_label: '클라이언트'
sidebar_position: 2
keywords: ['clickhouse', 'java', 'client', 'integrate']
description: 'Java ClickHouse 커넥터'
slug: /integrations/language-clients/java/client
title: 'Java 클라이언트'
doc_type: 'reference'
integration:
  - support_level: 'core'
  - category: 'language_client'
---

import ClientVersionDropdown from '@theme/ClientVersionDropdown/ClientVersionDropdown';
import Version from '@theme/ClientVersionDropdown/Version';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import WideTableWrapper from '@site/src/components/WideTableWrapper/WideTableWrapper';

<ClientVersionDropdown
  versions={[
{
'version': 'v0.8+'
},
{
'version': 'v0.7.x'
}
]}
>
  <Version>
    프로토콜을 통해 데이터베이스 서버와 통신하는 Java 클라이언트 라이브러리입니다. 현재 구현은 [HTTP 인터페이스](/interfaces/http)만 지원합니다.
    이 라이브러리는 서버에 요청을 전송하기 위한 자체 API를 제공합니다. 또한 다양한 바이너리 데이터 형식(RowBinary* 및 Native*)을 처리할 수 있는 도구도 제공합니다.

    ## 설정 \{#setup\}

    * Maven Central (프로젝트 웹 페이지): https://mvnrepository.com/artifact/com.clickhouse/client-v2
    * Nightly 빌드(저장소 링크): https://central.sonatype.com/repository/maven-snapshots/
    * 이전 Nightly 빌드용 Artifactory(저장소 링크): https://s01.oss.sonatype.org/content/repositories/snapshots/

    <br />

    <Tabs groupId="client-setup">
      <TabItem value="maven" label="Maven">
        ```xml
        <dependency>
            <groupId>com.clickhouse</groupId>
            <artifactId>client-v2</artifactId>
            <version>0.9.6</version>
        </dependency>
        ```
      </TabItem>

      <TabItem value="gradle-kt" label="Gradle (Kotlin)">
        ```kotlin
        // https://mvnrepository.com/artifact/com.clickhouse/client-v2
        implementation("com.clickhouse:client-v2:0.9.6")
        ```
      </TabItem>

      <TabItem value="gradle" label="Gradle">
        ```groovy
        // https://mvnrepository.com/artifact/com.clickhouse/client-v2
        implementation 'com.clickhouse:client-v2:0.9.6'
        ```
      </TabItem>
    </Tabs>

    <br />

    ## 초기화 \{#initialization\}

    Client 객체는 `com.clickhouse.client.api.Client.Builder#build()`를 통해 초기화됩니다. 각 클라이언트는 고유한 컨텍스트를 가지며, 클라이언트 간에 객체가 공유되지 않습니다.
    Builder는 편리한 설정을 위한 구성 메서드를 제공합니다.

    예시:

    ```java showLineNumbers
     Client client = new Client.Builder()
                    .addEndpoint("https://clickhouse-cloud-instance:8443/")
                    .setUsername(user)
                    .setPassword(password)
                    .build();
    ```

    `Client`는 `AutoCloseable`이며 더 이상 필요하지 않을 경우 닫아야 합니다.

    ### 인증 \{#authentication\}

    인증은 초기화 단계에서 클라이언트별로 구성됩니다. 지원되는 인증 방법은 세 가지입니다: 비밀번호, 액세스 토큰(Access Token), SSL 클라이언트 인증서(SSL Client Certificate).

    비밀번호 인증을 사용하려면 `setUsername(String)` 및 `setPassword(String)`을 호출하여 사용자 이름과 비밀번호를 설정해야 합니다:

    ```java showLineNumbers
     Client client = new Client.Builder()
            .addEndpoint("https://clickhouse-cloud-instance:8443/")
            .setUsername(user)
            .setPassword(password)
            .build();
    ```

    액세스 토큰을 이용한 인증에서는 `setAccessToken(String)`을 호출하여 액세스 토큰을 설정해야 합니다:

    ```java showLineNumbers
     Client client = new Client.Builder()
            .addEndpoint("https://clickhouse-cloud-instance:8443/")
            .setAccessToken(userAccessToken)
            .build();
    ```

    SSL 클라이언트 인증서를 통한 인증을 사용하려면 `setUsername(String)`, `useSSLAuthentication(boolean)`, `setClientCertificate(String)`, `setClientKey(String)`을 각각 호출하여 사용자 이름을 설정하고, SSL 인증을 활성화하며, 클라이언트 인증서와 클라이언트 키를 설정해야 합니다:

    ```java showLineNumbers
    Client client = new Client.Builder()
            .useSSLAuthentication(true)
            .setUsername("some_user")
            .setClientCertificate("some_user.crt")
            .setClientKey("some_user.key")
    ```

    :::note
    SSL 인증은 프로덕션 환경에서 문제 해결이 어려울 수 있습니다. SSL 라이브러리에서 발생하는 많은 오류가 충분한 정보를 제공하지 않기 때문입니다. 예를 들어, 클라이언트 인증서와 키가 일치하지 않으면 서버가 즉시 연결을 종료합니다(HTTP의 경우 HTTP 요청이 전송되기도 전에 이루어지는 연결 초기화 단계에서 종료되므로 어떤 응답도 전송되지 않습니다).

    인증서와 키를 검증하려면 [openssl](https://docs.openssl.org/master/man1/openssl/)과 같은 도구를 사용하세요:

    * 키 무결성 확인: `openssl rsa -in [key-file.key] -check -noout`
    * 클라이언트 인증서의 CN이 사용자와 일치하는지 확인합니다:
      * 사용자 인증서에서 CN을 추출합니다 - `openssl x509 -noout -subject -in [user.cert]`
      * 데이터베이스에 동일한 값이 설정되어 있는지 확인합니다: `select name, auth_type, auth_params from system.users where auth_type = 'ssl_certificate'` (쿼리는 `auth_params`를 ` {"common_names":["some_user"]}`와 같은 형식으로 출력합니다)

    :::

    ## 구성 \{#configuration\}

    모든 설정은 인스턴스 메서드(구성 메서드)로 정의되며, 각 값이 적용되는 범위와 컨텍스트를 명확히 합니다.
    주요 구성 매개변수는 하나의 범위(클라이언트 또는 작업)에서 정의되며, 서로를 덮어쓰지 않습니다.

    구성은 클라이언트를 생성할 때 정의됩니다. `com.clickhouse.client.api.Client.Builder`를 참조하세요.

    ## 클라이언트 구성 \{#client-configuration\}

    <Tabs groupId="client-config">
      <TabItem value="연결" label="연결 및 엔드포인트">
        | Method                                                                  | Arguments                                                                | Description                                                       | Default   | Key                         |
        | ----------------------------------------------------------------------- | ------------------------------------------------------------------------ | ----------------------------------------------------------------- | --------- | --------------------------- |
        | `addEndpoint(String endpoint)`                                          | `endpoint` - URL 형식의 서버 주소                                               | 사용 가능한 서버 목록에 서버 엔드포인트를 추가합니다. 현재는 하나의 엔드포인트만 지원됩니다.              | `none`    | `none`                      |
        | `addEndpoint(Protocol protocol, String host, int port, boolean secure)` | `protocol` - 연결 프로토콜<br />`host` - IP 또는 호스트 이름<br />`secure` - HTTPS 사용 | 사용 가능한 서버 목록에 서버 엔드포인트를 추가합니다. 현재는 하나의 엔드포인트만 지원됩니다.              | `none`    | `none`                      |
        | `enableConnectionPool(boolean enable)`                                  | `enable` - 활성/비활성 플래그                                                    | 커넥션 풀을 사용할지 여부를 설정합니다.                                            | `true`    | `connection_pool_enabled`   |
        | `setMaxConnections(int maxConnections)`                                 | `maxConnections` - 커넥션 개수                                                | 클라이언트가 각 서버 엔드포인트에 대해 열 수 있는 최대 커넥션 수를 설정합니다.                     | `10`      | `max_open_connections`      |
        | `setConnectionTTL(long timeout, ChronoUnit unit)`                       | `timeout` - 타임아웃 값<br />`unit` - 시간 단위                                   | 커넥션이 비활성으로 간주되는 TTL을 설정합니다.                                       | `-1`      | `connection_ttl`            |
        | `setKeepAliveTimeout(long timeout, ChronoUnit unit)`                    | `timeout` - 타임아웃 값<br />`unit` - 시간 단위                                   | HTTP 커넥션 Keep-Alive 타임아웃을 설정합니다. Keep-Alive를 비활성화하려면 `0`으로 설정합니다. | -         | `http_keep_alive_timeout`   |
        | `setConnectionReuseStrategy(ConnectionReuseStrategy strategy)`          | `strategy` - `LIFO` 또는 `FIFO`                                            | 커넥션 풀이 사용할 커넥션 재사용 전략을 선택합니다.                                     | `FIFO`    | `connection_reuse_strategy` |
        | `setDefaultDatabase(String database)`                                   | `database` - 데이터베이스 이름                                                   | 기본 데이터베이스를 설정합니다.                                                 | `default` | `database`                  |
      </TabItem>

      <TabItem value="인증" label="인증">
        | Method                                               | Arguments                                 | Description                                                             | Default   | Key                   |
        | ---------------------------------------------------- | ----------------------------------------- | ----------------------------------------------------------------------- | --------- | --------------------- |
        | `setUsername(String username)`                       | `username` - 인증에 사용할 사용자 이름               | 추가 설정을 통해 선택되는 인증 방법에 사용할 사용자 이름을 설정합니다.                                | `default` | `user`                |
        | `setPassword(String password)`                       | `password` - 비밀값                          | 비밀번호 인증에 사용할 비밀값을 설정하고, 해당 인증 방법을 실질적으로 선택합니다.                          | -         | `password`            |
        | `setAccessToken(String accessToken)`                 | `accessToken` - 액세스 토큰 문자열                | 인증에 사용할 액세스 토큰을 설정하며, 이에 상응하는 인증 방법을 선택합니다.                             | -         | `access_token`        |
        | `useSSLAuthentication(boolean useSSLAuthentication)` | `useSSLAuthentication` - SSL 인증 사용 여부 플래그 | SSL 클라이언트 인증서를 인증 방법으로 설정합니다.                                           | -         | `ssl_authentication`  |
        | `useHTTPBasicAuth(boolean useBasicAuth)`             | `useBasicAuth` - 활성화/비활성화 플래그             | 사용자-비밀번호 인증에 기본 HTTP 인증을 사용할지 여부를 설정합니다. 특수 문자가 포함된 비밀번호로 인한 문제를 방지합니다. | `true`    | `http_use_basic_auth` |
        | `useBearerTokenAuth(String bearerToken)`             | `bearerToken` - 인코딩된 Bearer 토큰            | Bearer 토큰 인증 사용 여부와 사용할 토큰을 지정합니다. 토큰은 있는 그대로 전송됩니다.                    | -         | `bearer_token`        |
      </TabItem>

      <TabItem value="타임아웃" label="타임아웃 및 재시도">
        | Method                                                       | Arguments                                  | Description                                          | Default                                                      | Key                          |
        | ------------------------------------------------------------ | ------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ | ---------------------------- |
        | `setConnectTimeout(long timeout, ChronoUnit unit)`           | `timeout` - 타임아웃 값<br />`unit` - 시간 단위     | 모든 아웃바운드 연결에 대해 연결을 시작할 때의 타임아웃을 설정합니다.              | -                                                            | `connection_timeout`         |
        | `setConnectionRequestTimeout(long timeout, ChronoUnit unit)` | `timeout` - 타임아웃 값<br />`unit` - 시간 단위     | 연결 요청 타임아웃을 설정합니다. 이 값은 커넥션 풀에서 연결을 가져올 때에만 적용됩니다.   | `10000`                                                      | `connection_request_timeout` |
        | `setSocketTimeout(long timeout, ChronoUnit unit)`            | `timeout` - 타임아웃 값<br />`unit` - 시간 단위     | 읽기 및 쓰기 작업에 영향을 주는 소켓 타임아웃을 설정합니다                    | `0`                                                          | `socket_timeout`             |
        | `setExecutionTimeout(long timeout, ChronoUnit timeUnit)`     | `timeout` - 타임아웃 값<br />`timeUnit` - 시간 단위 | 쿼리의 최대 실행 타임아웃을 설정합니다                                | `0`                                                          | `max_execution_time`         |
        | `retryOnFailures(ClientFaultCause ...causes)`                | `causes` - `ClientFaultCause`의 enum 상수     | 복구 가능하거나 재시도 가능한 오류 유형을 설정합니다.                       | `NoHttpResponse` `ConnectTimeout` `ConnectionRequestTimeout` | `client_retry_on_failures`   |
        | `setMaxRetries(int maxRetries)`                              | `maxRetries` - 재시도 횟수                      | `retryOnFailures`로 정의된 오류에 대해 허용되는 최대 재시도 횟수를 설정합니다. | `3`                                                          | `retry`                      |
      </TabItem>

      <TabItem value="소켓" label="소켓 옵션">
        | Method                               | Arguments                 | Description                                                                           | Default | Key                  |
        | ------------------------------------ | ------------------------- | ------------------------------------------------------------------------------------- | ------- | -------------------- |
        | `setSocketRcvbuf(long size)`         | `size` - 바이트 단위 크기        | TCP 소켓 수신 버퍼를 설정합니다. 이 버퍼는 JVM 메모리 외부에 있습니다.                                          | `8196`  | `socket_rcvbuf`      |
        | `setSocketSndbuf(long size)`         | `size` - 바이트 단위 크기        | TCP 소켓 송신 버퍼를 설정합니다. 이 버퍼는 JVM 메모리 외부에 있습니다.                                          | `8196`  | `socket_sndbuf`      |
        | `setSocketKeepAlive(boolean value)`  | `value` - 활성/비활성 플래그      | 모든 TCP 소켓에 대해 `SO_KEEPALIVE` 옵션을 설정합니다. TCP Keep Alive는 연결의 생존 여부를 확인하는 메커니즘을 활성화합니다. | -       | `socket_keepalive`   |
        | `setSocketTcpNodelay(boolean value)` | `value` - 활성/비활성 플래그      | 모든 TCP 소켓에 대해 `SO_NODELAY` 옵션을 설정합니다. 이 TCP 옵션은 소켓이 가능한 한 빨리 데이터를 전송하도록 합니다.          | -       | `socket_tcp_nodelay` |
        | `setSocketLinger(int secondsToWait)` | `secondsToWait` - 초 단위 시간 | 클라이언트가 생성하는 모든 TCP 소켓의 linger 시간을 설정합니다.                                              | -       | `socket_linger`      |
      </TabItem>

      <TabItem value="압축" label="압축">
        | Method                                    | Arguments              | Description                                          | Default | Key                                        |
        | ----------------------------------------- | ---------------------- | ---------------------------------------------------- | ------- | ------------------------------------------ |
        | `compressServerResponse(boolean enabled)` | `enabled` - 활성/비활성 플래그 | 서버가 응답을 압축할지 여부를 설정합니다.                              | `true`  | `compress`                                 |
        | `compressClientRequest(boolean enabled)`  | `enabled` - 활성/비활성 플래그 | 클라이언트가 요청을 압축할지 여부를 설정합니다.                           | `false` | `decompress`                               |
        | `useHttpCompression(boolean enabled)`     | `enabled` - 활성/비활성 플래그 | 해당 옵션이 활성화된 경우 클라이언트/서버 통신에 HTTP 압축을 사용할지 여부를 설정합니다. | -       | -                                          |
        | `appCompressedData(boolean enabled)`      | `enabled` - 활성/비활성 플래그 | 압축을 애플리케이션에서 처리한다는 것을 클라이언트에 알립니다.                   | `false` | `app_compressed_data`                      |
        | `setLZ4UncompressedBufferSize(int size)`  | `size` - 바이트 단위 크기     | 비압축 데이터 스트림의 일부를 수신할 버퍼의 크기를 설정합니다.                  | `65536` | `compression.lz4.uncompressed_buffer_size` |
        | `disableNativeCompression`                | `disable` - 비활성화 플래그   | 기본(native) 압축을 비활성화합니다. `true`로 설정하면 기본 압축이 비활성화됩니다. | `false` | `disable_native_compression`               |
      </TabItem>

      <TabItem value="ssl" label="SSL/보안">
        | Method                                      | Arguments                 | Description                                                         | Default | Key                  |
        | ------------------------------------------- | ------------------------- | ------------------------------------------------------------------- | ------- | -------------------- |
        | `setSSLTrustStore(String path)`             | `path` - 로컬 시스템의 파일 경로    | 클라이언트가 서버 호스트 검증을 위해 SSL truststore를 사용하도록 설정합니다.                   | -       | `trust_store`        |
        | `setSSLTrustStorePassword(String password)` | `password` - 비밀 값         | `setSSLTrustStore`로 지정한 SSL truststore의 잠금을 해제하는 데 사용할 비밀번호를 설정합니다. | -       | `key_store_password` |
        | `setSSLTrustStoreType(String type)`         | `type` - truststore 유형 이름 | `setSSLTrustStore`로 지정한 truststore의 유형을 설정합니다.                      | -       | `key_store_type`     |
        | `setRootCertificate(String path)`           | `path` - 로컬 시스템의 파일 경로    | 클라이언트가 서버 호스트 검증을 위해 지정된 루트(CA) 인증서를 사용하도록 설정합니다.                   | -       | `sslrootcert`        |
        | `setClientCertificate(String path)`         | `path` - 로컬 시스템의 파일 경로    | SSL 연결을 초기화하고 SSL 인증에 사용할 클라이언트 인증서 경로를 설정합니다.                      | -       | `sslcert`            |
        | `setClientKey(String path)`                 | `path` - 로컬 시스템의 파일 경로    | 서버와의 SSL 통신을 암호화하는 데 사용할 클라이언트 개인 키를 설정합니다.                         | -       | `ssl_key`            |
        | `sslSocketSNI(String sni)`                  | `sni` - 서버 이름 문자열         | SSL/TLS 연결에서 SNI(Server Name Indication)에 사용할 서버 이름을 설정합니다.         | -       | `ssl_socket_sni`     |
      </TabItem>

      <TabItem value="프록시" label="프록시">
        | Method                                            | Arguments                                                           | Description                   | Default | Key                                      |
        | ------------------------------------------------- | ------------------------------------------------------------------- | ----------------------------- | ------- | ---------------------------------------- |
        | `addProxy(ProxyType type, String host, int port)` | `type` - 프록시 유형<br />`host` - 프록시 호스트 이름 또는 IP<br />`port` - 프록시 포트 | 서버와의 통신에 사용할 프록시를 설정합니다.      | -       | `proxy_type`, `proxy_host`, `proxy_port` |
        | `setProxyCredentials(String user, String pass)`   | `user` - 프록시 사용자 이름<br />`pass` - 비밀번호                              | 프록시 인증에 사용할 사용자 자격 증명을 설정합니다. | -       | `proxy_user`, `proxy_password`           |
      </TabItem>

      <TabItem value="http" label="HTTP 및 헤더">
        | Method                                      | Arguments                                  | Description                           | Default | Key    |
        | ------------------------------------------- | ------------------------------------------ | ------------------------------------- | ------- | ------ |
        | `setHttpCookiesEnabled(boolean enabled)`    | `enabled` - 활성화/비활성화 플래그                   | HTTP 쿠키를 저장하고 서버로 다시 전송할지 여부를 설정합니다.  | -       | -      |
        | `httpHeader(String key, String value)`      | `key` - HTTP 헤더 키<br />`value` - 문자열 값     | 단일 HTTP 헤더의 값을 설정합니다. 이전 값은 덮어씁니다.    | `none`  | `none` |
        | `httpHeader(String key, Collection values)` | `key` - HTTP 헤더 키<br />`values` - 문자열 값 목록 | 단일 HTTP 헤더의 여러 값을 설정합니다. 이전 값은 덮어씁니다. | `none`  | `none` |
        | `httpHeaders(Map headers)`                  | `headers` - HTTP 헤더가 담긴 맵                  | 여러 HTTP 헤더 값을 한 번에 설정합니다.             | `none`  | `none` |
      </TabItem>

      <TabItem value="server-settings" label="서버 설정">
        | Method                                          | Arguments                            | Description                                                                                                 | Default | Key    |
        | ----------------------------------------------- | ------------------------------------ | ----------------------------------------------------------------------------------------------------------- | ------- | ------ |
        | `serverSetting(String name, String value)`      | `name` - 설정 이름<br />`value` - 설정 값   | 각 쿼리 실행 시 서버로 함께 전달할 설정을 지정합니다. 개별 작업 설정이 이를 재정의할 수 있습니다. [설정 목록](/operations/settings/query-level)         | `none`  | `none` |
        | `serverSetting(String name, Collection values)` | `name` - 설정 이름<br />`values` - 설정 값들 | 여러 값을 서버로 전달할 설정을 지정합니다. 예를 들어 [roles](/interfaces/http#setting-role-with-query-parameters)와 같이 사용할 수 있습니다. | `none`  | `none` |
      </TabItem>

      <TabItem value="시간대" label="시간대">
        | Method                                         | Arguments                                    | Description                                                          | Default | Key                    |
        | ---------------------------------------------- | -------------------------------------------- | -------------------------------------------------------------------- | ------- | ---------------------- |
        | `useServerTimeZone(boolean useServerTimeZone)` | `useServerTimeZone` - flag to enable/disable | DateTime 및 Date 컬럼 값을 디코딩할 때 클라이언트가 서버 타임존을 사용할지 설정합니다.              | `true`  | `use_server_time_zone` |
        | `useTimeZone(String timeZone)`                 | `timeZone` - java valid timezone ID          | DateTime 및 Date 컬럼 값을 디코딩할 때 지정된 타임존을 사용할지 설정합니다. 서버 타임존 설정을 재정의합니다. | -       | `use_time_zone`        |
        | `setServerTimeZone(String timeZone)`           | `timeZone` - java valid timezone ID          | 서버 측 타임존을 설정합니다. 기본적으로 UTC 타임존이 사용됩니다.                               | `UTC`   | `server_time_zone`     |
      </TabItem>

      <TabItem value="고급" label="고급">
        | Method                                                                    | Arguments                                                     | Description                                                                               | Default  | Key                          |
        | ------------------------------------------------------------------------- | ------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | -------- | ---------------------------- |
        | `setOption(String key, String value)`                                     | `key` - 구성 옵션 키<br />`value` - 옵션 값                           | 클라이언트 옵션의 원시 값을 설정합니다. 속성 파일에서 구성을 읽어올 때 유용합니다.                                           | -        | -                            |
        | `useAsyncRequests(boolean async)`                                         | `async` - 활성화/비활성화 플래그                                        | 클라이언트가 요청을 별도의 스레드에서 실행할지 여부를 설정합니다. 애플리케이션이 멀티 스레드 작업을 더 잘 구성할 수 있으므로 기본적으로 비활성화되어 있습니다. | `false`  | `async`                      |
        | `setSharedOperationExecutor(ExecutorService executorService)`             | `executorService` - ExecutorService 인스턴스                      | 작업을 위한 ExecutorService를 설정합니다.                                                            | `none`   | `none`                       |
        | `setClientNetworkBufferSize(int size)`                                    | `size` - 바이트 단위 크기                                            | 소켓과 애플리케이션 사이에서 데이터를 복사하는 데 사용되는 애플리케이션 메모리 공간 내 버퍼의 크기를 설정합니다.                           | `300000` | `client_network_buffer_size` |
        | `allowBinaryReaderToReuseBuffers(boolean reuse)`                          | `reuse` - 활성화/비활성화 플래그                                        | 활성화된 경우 리더가 숫자 변환(transcoding)을 위해 미리 할당된 버퍼를 재사용합니다. 숫자 데이터에 대한 GC 부하를 줄여 줍니다.           | -        | -                            |
        | `columnToMethodMatchingStrategy(ColumnToMethodMatchingStrategy strategy)` | `strategy` - 매칭 전략 구현체                                        | DTO를 등록할 때 DTO 클래스 필드와 DB 컬럼을 매칭하기 위해 사용할 사용자 정의 전략을 설정합니다.                               | `none`   | `none`                       |
        | `setClientName(String clientName)`                                        | `clientName` - 애플리케이션 이름 문자열                                  | 호출하는 애플리케이션에 대한 추가 정보를 설정합니다. `User-Agent` 헤더로 전달됩니다.                                     | -        | `client_name`                |
        | `registerClientMetrics(Object registry, String name)`                     | `registry` - Micrometer registry 인스턴스<br />`name` - 메트릭 그룹 이름 | Micrometer(https://micrometer.io/) registry 인스턴스에 센서를 등록합니다.                              | -        | -                            |
        | `setServerVersion(String version)`                                        | `version` - 서버 버전 문자열                                         | 버전 자동 감지를 피하기 위해 서버 버전을 설정합니다.                                                            | -        | `server_version`             |
        | `typeHintMapping(Map typeHintMapping)`                                    | `typeHintMapping` - 타입 힌트 맵                                   | ClickHouse 타입에 대한 타입 힌트 매핑을 설정합니다. 예를 들어, 다차원 배열이 Java 컨테이너로 표현되도록 할 수 있습니다.              | -        | `type_hint_mapping`          |
      </TabItem>
    </Tabs>

    <br />

    ### 서버 설정 \{#server-settings\}

    서버 측 설정은 클라이언트를 생성할 때 클라이언트 수준에서 한 번만 설정할 수 있으며(`Builder`의 `serverSetting` 메서드 참조), 작업 수준에서도 설정할 수 있습니다(작업 설정 클래스의 `serverSetting` 메서드 참조).

    ```java showLineNumbers
     try (Client client = new Client.Builder().addEndpoint(Protocol.HTTP, "localhost", mockServer.port(), false)
            .setUsername("default")
            .setPassword(ClickHouseServerForTest.getPassword())
            .compressClientRequest(true)

            // Client level
            .serverSetting("max_threads", "10")
            .serverSetting("async_insert", "1")
            .serverSetting("roles", Arrays.asList("role1", "role2"))

            .build()) {

    	// Operation level
    	QuerySettings querySettings = new QuerySettings();
    	querySettings.serverSetting("session_timezone", "Europe/Zurich");

    	...
    }
    ```

    ⚠️ `setOption` 메서드(`Client.Builder` 또는 작업 설정 클래스)를 통해 옵션을 설정하는 경우, 서버 설정 이름 앞에 `clickhouse_setting_` 접두사를 붙여야 합니다. 이 경우 `com.clickhouse.client.api.ClientConfigProperties#serverSetting()` 메서드가 유용할 수 있습니다.

    ### 커스텀 HTTP 헤더 \{#custom-http-header\}

    커스텀 HTTP 헤더는 모든 작업(클라이언트 수준)에 대해 또는 단일 작업(작업 수준)에 대해 설정할 수 있습니다.

    ```java showLineNumbers

    QuerySettings settings = new QuerySettings()
        .httpHeader(HttpHeaders.REFERER, clientReferer)
        .setQueryId(qId);

    ```

    `setOption` 메서드(`Client.Builder` 또는 작업 설정 클래스)를 통해 옵션을 설정하는 경우, 사용자 정의 헤더 이름 앞에 `http_header_` 접두사를 붙여야 합니다. 이때 `com.clickhouse.client.api.ClientConfigProperties#httpHeader()` 메서드를 사용하면 편리합니다.

    ## 공통 정의 \{#common-definitions\}

    ### ClickHouseFormat \{#clickhouseformat\}

    [지원되는 형식](/interfaces/formats)의 열거형(Enum)입니다. ClickHouse가 지원하는 모든 형식을 포함합니다.

    * `raw` - 사용자가 원시 데이터를 직접 트랜스코딩해야 합니다
    * `full` - 클라이언트가 자체적으로 데이터를 트랜스코딩할 수 있으며 원시 데이터 스트림을 그대로 수신할 수 있습니다
    * `-` - 이 형식에서는 ClickHouse가 해당 연산을 지원하지 않습니다

    이 클라이언트 버전에서 지원하는 항목은 다음과 같습니다:

    | 형식                                                                                                           |   입력  |   출력  |
    | ------------------------------------------------------------------------------------------------------------ | :---: | :---: |
    | [TabSeparated](/interfaces/formats/TabSeparated)                                                             |   원시  |   원시  |
    | [TabSeparatedRaw](/interfaces/formats/TabSeparatedRaw)                                                       |   원시  |   원시  |
    | [TabSeparatedWithNames](/interfaces/formats/TabSeparatedWithNames)                                           |   원시  |   원시  |
    | [TabSeparatedWithNamesAndTypes](/interfaces/formats/TabSeparatedWithNamesAndTypes)                           |   원시  |   원시  |
    | [TabSeparatedRawWithNames](/interfaces/formats/TabSeparatedRawWithNames)                                     |   원시  |   원시  |
    | [TabSeparatedRawWithNamesAndTypes](/interfaces/formats/TabSeparatedRawWithNamesAndTypes)                     |   원시  |   원시  |
    | [Template](/interfaces/formats/Template)                                                                     |   원시  |   원시  |
    | [TemplateIgnoreSpaces](/interfaces/formats/TemplateIgnoreSpaces)                                             |   원시  |   *   |
    | [CSV](/interfaces/formats/CSV)                                                                               |   원시  |   원시  |
    | [CSVWithNames](/interfaces/formats/CSVWithNames)                                                             |   원시  |   원시  |
    | [CSVWithNamesAndTypes](/interfaces/formats/CSVWithNamesAndTypes)                                             |   원시  |   원시  |
    | [CustomSeparated](/interfaces/formats/CustomSeparated)                                                       |   원시  |   원시  |
    | [CustomSeparatedWithNames](/interfaces/formats/CustomSeparatedWithNames)                                     |   원시  |   원시  |
    | [CustomSeparatedWithNamesAndTypes](/interfaces/formats/CustomSeparatedWithNamesAndTypes)                     |   원시  |   원시  |
    | [SQLInsert](/interfaces/formats/SQLInsert)                                                                   |   -   |   원시  |
    | [Values](/interfaces/formats/Values)                                                                         |   원시  |   원시  |
    | [Vertical](/interfaces/formats/Vertical)                                                                     |   *   |   원시  |
    | [JSON](/interfaces/formats/JSON)                                                                             |   원시  |   원시  |
    | [JSONAsString](/interfaces/formats/JSONAsString)                                                             |   원시  |   -   |
    | [JSONAsObject](/interfaces/formats/JSONAsObject)                                                             |   원시  |   *   |
    | [JSONStrings](/interfaces/formats/JSONStrings)                                                               |   원시  |   원시  |
    | [JSONColumns](/interfaces/formats/JSONColumns)                                                               |   원시  |   원시  |
    | [JSONColumnsWithMetadata](/interfaces/formats/JSONColumnsWithMetadata)                                       |   원시  |   원시  |
    | [JSONCompact](/interfaces/formats/JSONCompact)                                                               |   원시  |   원시  |
    | [JSONCompactStrings](/interfaces/formats/JSONCompactStrings)                                                 |   -   |   원시  |
    | [JSONCompactColumns](/interfaces/formats/JSONCompactColumns)                                                 |   원시  | 원시 형식 |
    | [JSONEachRow](/interfaces/formats/JSONEachRow)                                                               | 원시 형식 | 원시 형식 |
    | [PrettyJSONEachRow](/interfaces/formats/PrettyJSONEachRow)                                                   |   *   | 원시 형식 |
    | [JSONEachRowWithProgress](/interfaces/formats/JSONEachRowWithProgress)                                       |   -   | 원시 형식 |
    | [JSONStringsEachRow](/interfaces/formats/JSONStringsEachRow)                                                 | 원시 형식 | 원시 형식 |
    | [JSONStringsEachRowWithProgress](/interfaces/formats/JSONStringsEachRowWithProgress)                         |   *   | 원시 형식 |
    | [JSONCompactEachRow](/interfaces/formats/JSONCompactEachRow)                                                 | 원시 형식 | 원시 형식 |
    | [JSONCompactEachRowWithNames](/interfaces/formats/JSONCompactEachRowWithNames)                               | 원시 형식 | 원시 형식 |
    | [JSONCompactEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactEachRowWithNamesAndTypes)               | 원시 형식 | 원시 형식 |
    | [JSONCompactStringsEachRow](/interfaces/formats/JSONCompactStringsEachRow)                                   | 원시 형식 | 원시 형식 |
    | [JSONCompactStringsEachRowWithNames](/interfaces/formats/JSONCompactStringsEachRowWithNames)                 | 원시 형식 | 원시 형식 |
    | [JSONCompactStringsEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactStringsEachRowWithNamesAndTypes) | 원시 형식 | 원시 형식 |
    | [JSONObjectEachRow](/interfaces/formats/JSONObjectEachRow)                                                   | 원시 형식 | 원시 형식 |
    | [BSONEachRow](/interfaces/formats/BSONEachRow)                                                               | 원시 형식 | 원시 형식 |
    | [TSKV](/interfaces/formats/TSKV)                                                                             | 원시 형식 | 원시 형식 |
    | [Pretty](/interfaces/formats/Pretty)                                                                         |   -   | 원시 형식 |
    | [PrettyNoEscapes](/interfaces/formats/PrettyNoEscapes)                                                       |   *   | 원시 형식 |
    | [PrettyMonoBlock](/interfaces/formats/PrettyMonoBlock)                                                       |   -   | 원시 형식 |
    | [PrettyNoEscapesMonoBlock](/interfaces/formats/PrettyNoEscapesMonoBlock)                                     |   *   | 원시 형식 |
    | [PrettyCompact](/interfaces/formats/PrettyCompact)                                                           |   -   | 원시 형식 |
    | [PrettyCompactNoEscapes](/interfaces/formats/PrettyCompactNoEscapes)                                         |   *   | 원시 형식 |
    | [PrettyCompactMonoBlock](/interfaces/formats/PrettyCompactMonoBlock)                                         |   -   | 원시 형식 |
    | [PrettyCompactNoEscapesMonoBlock](/interfaces/formats/PrettyCompactNoEscapesMonoBlock)                       |   *   | 원시 형식 |
    | [PrettySpace](/interfaces/formats/PrettySpace)                                                               |   -   | 원시 형식 |
    | [PrettySpaceNoEscapes](/interfaces/formats/PrettySpaceNoEscapes)                                             |   *   | 원시 형식 |
    | [PrettySpaceMonoBlock](/interfaces/formats/PrettySpaceMonoBlock)                                             |   -   | 원시 형식 |
    | [PrettySpaceNoEscapesMonoBlock](/interfaces/formats/PrettySpaceNoEscapesMonoBlock)                           |   *   | 원시 형식 |
    | [Prometheus](/interfaces/formats/Prometheus)                                                                 |   -   |   원시  |
    | [Protobuf](/interfaces/formats/Protobuf)                                                                     |   원시  |   원시  |
    | [ProtobufSingle](/interfaces/formats/ProtobufSingle)                                                         |   원시  |   원시  |
    | [ProtobufList](/interfaces/formats/ProtobufList)                                                             |   원시  |   원시  |
    | [Avro](/interfaces/formats/Avro)                                                                             |   원시  |   원시  |
    | [AvroConfluent](/interfaces/formats/AvroConfluent)                                                           |   원시  |   *   |
    | [Parquet](/interfaces/formats/Parquet)                                                                       |   원시  |   원시  |
    | [ParquetMetadata](/interfaces/formats/ParquetMetadata)                                                       |   원시  |   -   |
    | [Arrow](/interfaces/formats/Arrow)                                                                           |   원시  |   원시  |
    | [ArrowStream](/interfaces/formats/ArrowStream)                                                               |   원시  |   원시  |
    | [ORC](/interfaces/formats/ORC)                                                                               |   원시  |   원시  |
    | [One](/interfaces/formats/One)                                                                               |   원시  |   *   |
    | [Npy](/interfaces/formats/Npy)                                                                               |   원시  |   원시  |
    | [RowBinary](/interfaces/formats/RowBinary)                                                                   |   전체  |   전체  |
    | [RowBinaryWithNames](/interfaces/formats/RowBinaryWithNamesAndTypes)                                         |   전체  |   전체  |
    | [RowBinaryWithNamesAndTypes](/interfaces/formats/RowBinaryWithNamesAndTypes)                                 |   전체  |   전체  |
    | [RowBinaryWithDefaults](/interfaces/formats/RowBinaryWithDefaults)                                           |   전체  |   -   |
    | [Native](/interfaces/formats/Native)                                                                         |   전체  |   원시  |
    | [Null](/interfaces/formats/Null)                                                                             |   *   |   원시  |
    | [XML](/interfaces/formats/XML)                                                                               |   -   |   원시  |
    | [CapnProto](/interfaces/formats/CapnProto)                                                                   |   원시  |   원시  |
    | [LineAsString](/interfaces/formats/LineAsString)                                                             |   원시  |   원시  |
    | [Regexp](/interfaces/formats/Regexp)                                                                         |   원시  |   *   |
    | [RawBLOB](/interfaces/formats/RawBLOB)                                                                       |   원시  |   원시  |
    | [MsgPack](/interfaces/formats/MsgPack)                                                                       |   원시  |   원시  |
    | [MySQLDump](/interfaces/formats/MySQLDump)                                                                   |   원시  |   -   |
    | [DWARF](/interfaces/formats/DWARF)                                                                           |   원시  |   *   |
    | [Markdown](/interfaces/formats/Markdown)                                                                     |   -   |   원본  |
    | [양식](/interfaces/formats/Form)                                                                               |   원본  |   *   |

    ## Insert API \{#insert-api\}

    ### insert(String tableName, InputStream data, ClickHouseFormat format) \{#insertstring-tablename-inputstream-data-clickhouseformat-format\}

    지정된 형식으로 인코딩된 바이트 `InputStream`으로 데이터를 입력받습니다. `data`는 `format` 형식으로 인코딩되어 있어야 합니다.

    **시그니처**

    ```java
    CompletableFuture<InsertResponse> insert(String tableName, InputStream data, ClickHouseFormat format, InsertSettings settings)
    CompletableFuture<InsertResponse> insert(String tableName, InputStream data, ClickHouseFormat format)
    ```

    **파라미터**

    `tableName` - 대상 테이블의 이름.

    `data` - 인코딩된 데이터가 담긴 입력 스트림입니다.

    `format` - 데이터가 인코딩된 형식입니다.

    `settings` - 요청 설정.

    **반환값**

    `InsertResponse` 타입의 Future로, 작업 결과와 서버 측 메트릭 등 추가 정보를 포함합니다.

    **예시**

    ```java showLineNumbers
    try (InputStream dataStream = getDataStream()) {
        try (InsertResponse response = client.insert(TABLE_NAME, dataStream, ClickHouseFormat.JSONEachRow,
                insertSettings).get(3, TimeUnit.SECONDS)) {

            log.info("Insert finished: {} rows written", response.getMetrics().getMetric(ServerMetrics.NUM_ROWS_WRITTEN).getLong());
        } catch (Exception e) {
            log.error("Failed to write JSONEachRow data", e);
            throw new RuntimeException(e);
        }
    }

    ```

    ### insert(String tableName, List&lt;?&gt; data, InsertSettings settings) \{#insertstring-tablename-listlt-data-insertsettings-settings\}

    데이터베이스에 쓰기 요청을 보냅니다. 객체 목록은 효율적인 형식으로 변환된 후 서버로 전송됩니다. 목록 항목의 클래스는 `register(Class, TableSchema)` 메서드를 사용하여 미리 등록해야 합니다.

    **시그니처**

    ```java
    client.insert(String tableName, List<?> data, InsertSettings settings)
    client.insert(String tableName, List<?> data)
    ```

    **파라미터**

    `tableName` - 대상 테이블 이름.

    `data` - DTO(Data Transfer Object) 객체들의 컬렉션입니다.

    `settings` - 요청 설정입니다.

    **반환값**

    `InsertResponse` 타입의 Future로, 작업 결과와 서버 측 메트릭과 같은 추가 정보를 반환합니다.

    **예제**

    ```java showLineNumbers
    // Important step (done once) - register class to pre-compile object serializer according to the table schema.
    client.register(ArticleViewEvent.class, client.getTableSchema(TABLE_NAME));

    List<ArticleViewEvent> events = loadBatch();

    try (InsertResponse response = client.insert(TABLE_NAME, events).get()) {
        // handle response, then it will be closed and connection that served request will be released.
    }
    ```

    ### InsertSettings \{#insertsettings\}

    삽입 작업을 위한 구성 옵션입니다.

    **구성 방법**

    | 메서드                                             | 설명                                                                                      |
    | ----------------------------------------------- | --------------------------------------------------------------------------------------- |
    | `setQueryId(String queryId)`                    | 작업에 할당될 쿼리 ID를 설정합니다. 기본값은 `null`입니다.                                                   |
    | `setDeduplicationToken(String token)`           | 중복 제거 토큰을 설정합니다. 이 토큰은 서버로 전송되며, 쿼리를 식별하는 데 사용할 수 있습니다. 기본값은 `null`입니다.                 |
    | `setInputStreamCopyBufferSize(int size)`        | 복사용 버퍼 크기입니다. 이 버퍼는 쓰기 작업 중에 사용자 제공 입력 스트림에서 출력 스트림으로 데이터를 복사할 때 사용됩니다. 기본값은 `8196`입니다. |
    | `serverSetting(String name, String value)`      | 개별 작업에 대해 서버 측 설정을 지정합니다.                                                               |
    | `serverSetting(String name, Collection values)` | 작업에 대해 여러 값을 가지는 개별 서버 설정을 지정합니다. 컬렉션의 각 항목은 `String` 값이어야 합니다.                         |
    | `setDBRoles(Collection dbRoles)`                | 작업을 실행하기 전에 적용할 DB 역할을 설정합니다. 컬렉션의 항목은 `String` 값이어야 합니다.                               |
    | `setOption(String option, Object value)`        | 구성 옵션을 원시(raw) 형식으로 설정합니다. 이는 서버 설정이 아닙니다.                                              |

    ### InsertResponse \{#insertresponse\}

    삽입 작업의 결과를 보유하는 응답 객체입니다. 클라이언트가 서버로부터 응답을 받은 경우에만 사용 가능합니다.

    :::note
    이전 응답의 모든 데이터를 완전히 읽기 전까지는 해당 연결을 재사용할 수 없으므로, 연결을 해제하려면 이 객체를 가능한 한 빨리 닫아야 합니다.
    :::

    | 메서드                             | 설명                                              |
    | ------------------------------- | ----------------------------------------------- |
    | `OperationMetrics getMetrics()` | 작업 메트릭 객체를 반환합니다.                               |
    | `String getQueryId()`           | 애플리케이션에서(작업 설정 또는 서버를 통해) 작업에 할당한 쿼리 ID를 반환합니다. |

    ## 쿼리 API \{#query-api\}

    ### query(String sqlQuery) \{#querystring-sqlquery\}

    `sqlQuery`를 있는 그대로 전송합니다. 응답 형식은 쿼리 설정에 의해 지정됩니다. `QueryResponse`는 해당 형식을 처리하는 리더가 읽어야 하는 응답 스트림에 대한 참조를 보유합니다.

    **시그니처**

    ```java
    CompletableFuture<QueryResponse> query(String sqlQuery, QuerySettings settings)
    CompletableFuture<QueryResponse> query(String sqlQuery)
    ```

    **파라미터**

    `sqlQuery` - 단일 SQL 문입니다. 쿼리는 있는 그대로 서버로 전송됩니다.

    `settings` - 요청 설정입니다.

    **반환값**

    `QueryResponse` 타입을 반환하는 Future - 결과 데이터셋과 서버 측 메트릭과 같은 추가 정보를 포함합니다. 데이터셋을 모두 소비한 후 Response 객체를 닫아야 합니다.

    **예시**

    ```java
    final String sql = "select * from " + TABLE_NAME + " where title <> '' limit 10";

    // Default format is RowBinaryWithNamesAndTypesFormatReader so reader have all information about columns
    try (QueryResponse response = client.query(sql).get(3, TimeUnit.SECONDS);) {

        // Create a reader to access the data in a convenient way
        ClickHouseBinaryFormatReader reader = client.newBinaryFormatReader(response);

        while (reader.hasNext()) {
            reader.next(); // Read the next record from stream and parse it

            // get values
            double id = reader.getDouble("id");
            String title = reader.getString("title");
            String url = reader.getString("url");

            // collecting data
        }
    } catch (Exception e) {
        log.error("Failed to read data", e);
    }

    // put business logic outside of the reading block to release http connection asap.
    ```

    ### query(String sqlQuery, Map&lt;String, Object&gt; queryParams, QuerySettings settings) \{#querystring-sqlquery-mapltstring-object-queryparams-querysettings-settings\}

    `sqlQuery`를 그대로 전송합니다. 또한 서버가 SQL 표현식을 컴파일할 수 있도록 쿼리 매개변수도 함께 전송합니다.

    **시그니처**

    ```java
    CompletableFuture<QueryResponse> query(String sqlQuery, Map<String, Object> queryParams, QuerySettings settings)
    ```

    **매개변수**

    `sqlQuery` - `{}` 플레이스홀더를 포함하는 SQL 표현식입니다.

    `queryParams` - 서버에서 SQL 표현식을 완성하는 데 사용할 변수 맵입니다.

    `settings` - 요청 설정입니다.

    **반환값**

    `QueryResponse` 타입의 향후 계획 - 결과 데이터셋과 서버 측 메트릭과 같은 추가 정보를 포함합니다. 데이터셋을 모두 읽은 후 Response 객체를 닫아야 합니다.

    **예시**

    ```java showLineNumbers

    // define parameters. They will be sent to the server along with the request.
    Map<String, Object> queryParams = new HashMap<>();
    queryParams.put("param1", 2);

    try (QueryResponse response =
            client.query("SELECT * FROM " + table + " WHERE col1 >= {param1:UInt32}", queryParams, new QuerySettings()).get()) {

        // Create a reader to access the data in a convenient way
        ClickHouseBinaryFormatReader reader = client.newBinaryFormatReader(response);

        while (reader.hasNext()) {
            reader.next(); // Read the next record from stream and parse it

            // reading data
        }

    } catch (Exception e) {
        log.error("Failed to read data", e);
    }

    ```

    ### queryAll(String sqlQuery) \{#queryallstring-sqlquery\}

    `RowBinaryWithNamesAndTypes` 형식의 데이터를 쿼리합니다. 결과는 컬렉션으로 반환됩니다. 읽기 성능은 리더와 동일하지만, 전체 데이터셋을 메모리에 보관하기 위해 더 많은 메모리가 필요합니다.

    **시그니처**

    ```java
    List<GenericRecord> queryAll(String sqlQuery)
    ```

    **파라미터**

    `sqlQuery` - 서버의 데이터를 조회하기 위한 SQL 표현식입니다.

    **반환값**

    결과 데이터에 대해 행 단위 접근을 제공하는 `GenericRecord` 객체 목록으로 표현된 완전한 데이터셋입니다.

    **예시**

    ```java showLineNumbers
    try {
        log.info("Reading whole table and process record by record");
        final String sql = "select * from " + TABLE_NAME + " where title <> ''";

        // Read whole result set and process it record by record
        client.queryAll(sql).forEach(row -> {
            double id = row.getDouble("id");
            String title = row.getString("title");
            String url = row.getString("url");

            log.info("id: {}, title: {}, url: {}", id, title, url);
        });
    } catch (Exception e) {
        log.error("Failed to read data", e);
    }
    ```

    ### QuerySettings \{#querysettings\}

    쿼리 작업 구성 옵션입니다.

    **구성 방법**

    | 메서드                                               | 설명                                                                                                                     |
    | ------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
    | `setQueryId(String queryId)`                      | 작업에 할당할 쿼리 ID를 설정합니다.                                                                                                  |
    | `setFormat(ClickHouseFormat format)`              | 응답 형식을 설정합니다. 전체 형식 목록은 `RowBinaryWithNamesAndTypes`를 참조하십시오.                                                          |
    | `setMaxExecutionTime(Integer maxExecutionTime)`   | 서버에서 작업의 최대 실행 시간 제한을 설정합니다. 읽기 타임아웃에는 영향을 주지 않습니다.                                                                    |
    | `waitEndOfQuery(Boolean waitEndOfQuery)`          | 쿼리 실행이 완료될 때까지 응답을 보내지 않도록 서버에 요청합니다.                                                                                  |
    | `setUseServerTimeZone(Boolean useServerTimeZone)` | 연산 결과에 포함된 날짜/시간 타입을 파싱할 때 서버 시간대(클라이언트 설정 참조)를 사용합니다. 기본값은 `false`입니다.                                                |
    | `setUseTimeZone(String timeZone)`                 | 시간 변환에 `timeZone`을 사용하도록 서버에 요청합니다. [session&#95;timezone](/operations/settings/settings#session_timezone)을(를) 참조하십시오. |
    | `serverSetting(String name, String value)`        | 개별 작업에 대한 서버 측 설정을 구성합니다.                                                                                              |
    | `serverSetting(String name, Collection values)`   | 작업에 대해 여러 값을 가지는 개별 서버 설정을 지정합니다. 컬렉션의 각 항목은 `String` 값이어야 합니다.                                                        |
    | `setDBRoles(Collection dbRoles)`                  | 작업을 실행하기 전에 설정할 DB 역할을 지정합니다. 컬렉션의 항목은 `String` 값이어야 합니다.                                                              |
    | `setOption(String option, Object value)`          | 원시(raw) 형식으로 구성 옵션을 설정합니다. 서버 설정이 아닙니다.                                                                                |

    ### QueryResponse \{#queryresponse\}

    쿼리 실행 결과를 담고 있는 응답 객체입니다. 클라이언트가 서버로부터 응답을 받은 경우에만 사용 가능합니다.

    :::note
    이전 응답의 모든 데이터를 완전히 읽기 전까지는 연결을 재사용할 수 없으므로, 연결을 해제하기 위해 이 객체를 가능한 한 빨리 닫으십시오.
    :::

    | 메서드                             | 설명                                                 |
    | ------------------------------- | -------------------------------------------------- |
    | `ClickHouseFormat getFormat()`  | 응답 데이터가 어떤 포맷으로 인코딩되었는지 반환합니다.                     |
    | `InputStream getInputStream()`  | 지정된 포맷으로 인코딩된 비압축 데이터 바이트 스트림을 반환합니다.              |
    | `OperationMetrics getMetrics()` | 작업 메트릭을 포함하는 객체를 반환합니다.                            |
    | `String getQueryId()`           | 애플리케이션이 작업에 할당한 쿼리 ID(작업 설정 또는 서버를 통해 설정됨)를 반환합니다. |
    | `TimeZone getTimeZone()`        | 응답의 Date/DateTime 타입을 처리할 때 사용할 타임존을 반환합니다.        |

    ### 예시 \{#examples\}

    * 예제 코드는 [저장소](https://github.com/ClickHouse/clickhouse-java/tree/main/examples/client-v2)에서 확인할 수 있습니다.
    * Spring 서비스 [구현 예제](https://github.com/ClickHouse/clickhouse-java/tree/main/examples/demo-service)를 참고하십시오

    ## 공통 API \{#common-api\}

    ### getTableSchema(String table) \{#gettableschemastring-table\}

    `table`에 대한 테이블 스키마를 가져옵니다.

    **시그니처**

    ```java
    TableSchema getTableSchema(String table)
    TableSchema getTableSchema(String table, String database)
    ```

    **파라미터**

    `table` - 스키마 데이터를 조회할 테이블 이름입니다.

    `database` - 대상 테이블이 정의된 데이터베이스.

    **반환값**

    테이블의 컬럼 목록을 포함하는 `TableSchema` 객체를 반환합니다.

    ### getTableSchemaFromQuery(String sql) \{#gettableschemafromquerystring-sql\}

    SQL 문으로부터 스키마를 조회합니다.

    **시그니처**

    ```java
    TableSchema getTableSchemaFromQuery(String sql)
    ```

    **파라미터**

    `sql` - 스키마를 반환해야 하는 &quot;SELECT&quot; SQL 문입니다.

    **반환값**

    `sql` 표현식과 일치하는 컬럼을 포함하는 `TableSchema` 객체를 반환합니다.

    ### TableSchema \{#tableschema\}

    ### register(Class&lt;?&gt; clazz, TableSchema schema) \{#registerclasslt-clazz-tableschema-schema\}

    Java 클래스가 `schema`를 사용하여 데이터를 쓰고 읽을 수 있도록 직렬화 및 역직렬화 레이어를 컴파일합니다. 이 메서드는 getter/setter 쌍과 해당 컬럼에 대한 직렬화기 및 역직렬화기를 생성합니다.
    컬럼 매칭은 메서드 이름에서 컬럼 이름을 추출하여 수행됩니다. 예를 들어, `getFirstName`은 `first_name` 또는 `firstname` 컬럼에 대응됩니다.

    **서명**

    ```java
    void register(Class<?> clazz, TableSchema schema)
    ```

    **파라미터**

    `clazz` - 데이터를 읽고 쓰는 데 사용되는 POJO를 나타내는 클래스입니다.

    `schema` - POJO 속성과 매칭하는 데 사용할 데이터 스키마입니다.

    **예시**

    ```java showLineNumbers
    client.register(ArticleViewEvent.class, client.getTableSchema(TABLE_NAME));
    ```

    ## 사용 예제 \{#usage-examples\}

    전체 예제 코드는 저장소의 &#39;example` [폴더](https://github.com/ClickHouse/clickhouse-java/tree/main/examples)에 있습니다:

    * [client-v2](https://github.com/ClickHouse/clickhouse-java/tree/main/examples/client-v2) - 주요 예제 모음입니다.
    * [demo-service](https://github.com/ClickHouse/clickhouse-java/tree/main/examples/demo-service) - Spring Boot 애플리케이션에서 클라이언트를 사용하는 방법을 보여주는 예제입니다.
    * [demo-kotlin-service](https://github.com/ClickHouse/clickhouse-java/tree/main/examples/demo-kotlin-service) - Ktor 기반 Kotlin 애플리케이션에서 클라이언트를 사용하는 방법을 보여주는 예제입니다.

    ## 데이터 읽기 \{#reading-data\}

    데이터를 읽는 일반적인 방식은 두 가지입니다:

    * 데이터가 포함된 `InputStream`을 담고 있는 저수준 `QueryResponse` 객체를 반환하는 `query()` 메서드입니다. 일반적으로 스트리밍 읽기를 위해 `ClickHouseBinaryFormatReader`와 함께 사용되지만,
      다른 사용자 정의 리더 구현과 함께 사용할 수도 있습니다. `QueryResponse`는 결과 집합 메타데이터와 메트릭에 대한 접근도 제공합니다.
    * `queryAll()` 메서드와 `GenericRecord`를 사용하면 행 단위로 데이터를 편리하게 접근할 수 있습니다. 이 경우 전체 결과 집합이 메모리에 로드됩니다.
    * `queryRecords()` 메서드는 `com.clickhouse.client.api.query.Records`를 반환하며, 이는 `GenericRecord` 객체에 대한 이터레이터입니다. 이 메서드는 스트리밍 방식(데이터를 메모리에 적재하지 않음)을 사용하며, `GenericRecord`를 활용해 데이터에 접근합니다.

    **참고:** 스트리밍 방식은 데이터가 네트워크 스트림에서 직접 읽히므로, 충분히 빠르게 읽지 않으면 서버 쓰기 타임아웃이 발생할 수 있습니다.

    ### 배열 읽기 \{#reading-arrays\}

    **`ClickHouseBinaryFormatReader` 메서드**

    * `getList(...)` - 모든 `Array(...)`를 `List<T>` 형태로 읽습니다. 유연한 타입의 읽기에 적합한 기본값입니다. 중첩 배열을 지원합니다.
    * `getByteArray(...)`, `getShortArray(...)`, `getIntArray(...)`, `getLongArray(...)`, `getFloatArray(...)`, `getDoubleArray(...)`, `getBooleanArray(...)` - 원시 타입과 호환되는 값들로 구성된 1차원 배열에 가장 적합합니다.
    * `getStringArray(...)` - `Array(String)` 타입(및 이름으로 표현되는 enum 값)에 사용합니다.
    * `getObjectArray(...)` - 중첩 배열을 포함한 모든 `Array(...)` 요소 타입에 사용할 수 있는 범용 옵션입니다. 널 허용 값 및 중첩 배열을 포함하는 배열을 읽을 때 사용합니다.

    모든 메서드는 인덱스 기반 및 이름 기반 오버로드를 사용할 수 있습니다. 인덱스는 1부터 시작합니다. 인덱스 기반 방식은 컬럼에 직접 접근합니다.
    이름 기반 메서드는 매번 인덱스를 조회해야 합니다.

    ```java
    try (QueryResponse response = client.query("SELECT * FROM my_table").get()) {
        ClickHouseBinaryFormatReader reader = client.newBinaryFormatReader(response);
        while (reader.next() != null) {
            
            Object[] uint64 = reader.getObjectArray("uint64_arr"); // Array(UInt64) -> BigInteger[]
            Object[] arr2d = reader.getObjectArray("arr2d");       // Array(Array(Int64)) -> Object[]

            // nested arrays are returned as nested Object[]:
            Object[] firstInner = (Object[]) arr2d[0];
            Long firstValue = (Long) firstInner[0];
        }
    }
    ```

    **`GenericRecord` 메서드**

    * `getList(...)` - 모든 `Array(...)`를 `List<T>`로 읽습니다. 유연한 타입 읽기에 적합한 기본값입니다. 중첩 배열을 지원합니다.
    * `getByteArray(...)`, `getShortArray(...)`, `getIntArray(...)`, `getLongArray(...)`, `getFloatArray(...)`, `getDoubleArray(...)`, `getBooleanArray(...)` - 기본(primitive) 타입과 호환되는 값으로 구성된 1차원 배열에 가장 적합합니다.
    * `getStringArray(...)` - `Array(String)` 타입(및 이름으로 표현되는 enum 값)에 사용됩니다.
    * `getObjectArray(...)` - 중첩 배열을 포함하여 모든 `Array(...)` 요소 타입에 사용할 수 있는 제네릭 옵션입니다. 널 허용 값을 포함한 배열 및 중첩 배열을 읽을 때 사용합니다.

    모든 메서드에서 인덱스 기반 및 이름 기반 오버로드를 사용할 수 있습니다. 인덱스는 1부터 시작합니다. 인덱스 기반 메서드는 컬럼에 직접 접근합니다.
    이름 기반 메서드는 사용할 때마다 인덱스 조회가 필요합니다.

    ````java
    try (QueryResponse response = client.query("SELECT * FROM my_table").get()) {
        List<GenericRecord> rows = client.queryAll(
            "SELECT int_arr, arr2d_nullable FROM test_arrays ORDER BY id");

        for (GenericRecord row : rows) {
            Object[] intArr = row.getObjectArray("int_arr");                 // Array(Int32) -> Integer[]
            Object[] arr2d = row.getObjectArray("arr2d_nullable");           // Array(Array(Nullable(Int32)))

            Object[] inner = (Object[]) arr2d[0];
            Object maybeNull = inner[1]; // may be null
        }
    }


    ## Migration Guide                   


    Old client (V1) was using `com.clickhouse.client.ClickHouseClient#builder` as start point. The new client (V2) uses similar pattern with `com.clickhouse.client.api.Client.Builder`. Main
    differences are:
    - no service loader is used to grab implementation. The `com.clickhouse.client.api.Client` is facade class for all kinds of implementation in the future.
    - a fewer sources of configuration: one is provided to the builder and one is with operation settings (`QuerySettings`, `InsertSettings`). Previous version had configuration per node and was loading
    env. variables in some cases.

    ### Configuration Parameters Match                            

    There are 3 enum classes related to configuration in V1:
    - `com.clickhouse.client.config.ClickHouseDefaults` - configuration parameters that supposed to be set in most use cases. Like `USER` and `PASSWORD`.
    - `com.clickhouse.client.config.ClickHouseClientOption` - configuration parameters specific for the client. Like `HEALTH_CHECK_INTERVAL`.
    - `com.clickhouse.client.http.config.ClickHouseHttpOption` - configuration parameters specific for HTTP interface. Like `RECEIVE_QUERY_PROGRESS`.

    They were designed to group parameters and provide clear separation. However in some cases it lead to a confusion (is there a difference between `com.clickhouse.client.config.ClickHouseDefaults#ASYNC` and
    `com.clickhouse.client.config.ClickHouseClientOption#ASYNC`). The new V2 client uses `com.clickhouse.client.api.Client.Builder` as single dictionary of all possible client configuration options.There is
    `com.clickhouse.client.api.ClientConfigProperties` where all configuration parameter names are listed.

    Table below shows what old options are supported in the new client and their new meaning.

    **Legend:** ✔ = supported, ✗ = dropped

    <Tabs groupId="v1-migration">
    <TabItem value="connection-auth" label="Connection & Auth">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseDefaults#HOST` | `Client.Builder#addEndpoint` | |
    | `ClickHouseDefaults#PROTOCOL` | ✗ | Only HTTP supported in V2 |
    | `ClickHouseDefaults#DATABASE`<br/>`ClickHouseClientOption#DATABASE` | `Client.Builder#setDefaultDatabase` | |
    | `ClickHouseDefaults#USER` | `Client.Builder#setUsername` | |
    | `ClickHouseDefaults#PASSWORD` | `Client.Builder#setPassword` | |
    | `ClickHouseClientOption#CONNECTION_TIMEOUT` | `Client.Builder#setConnectTimeout` | |
    | `ClickHouseClientOption#CONNECTION_TTL` | `Client.Builder#setConnectionTTL` | |
    | `ClickHouseHttpOption#MAX_OPEN_CONNECTIONS` | `Client.Builder#setMaxConnections` | |
    | `ClickHouseHttpOption#KEEP_ALIVE`<br/>`ClickHouseHttpOption#KEEP_ALIVE_TIMEOUT` | `Client.Builder#setKeepAliveTimeout` | |
    | `ClickHouseHttpOption#CONNECTION_REUSE_STRATEGY` | `Client.Builder#setConnectionReuseStrategy` | |
    | `ClickHouseHttpOption#USE_BASIC_AUTHENTICATION` | `Client.Builder#useHTTPBasicAuth` | |

    </TabItem>

    <TabItem value="ssl" label="SSL & Security">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseDefaults#SSL_CERTIFICATE_TYPE` | ✗ | |
    | `ClickHouseDefaults#SSL_KEY_ALGORITHM` | ✗ | |
    | `ClickHouseDefaults#SSL_PROTOCOL` | ✗ | |
    | `ClickHouseClientOption#SSL` | ✗ | See `Client.Builder#addEndpoint` |
    | `ClickHouseClientOption#SSL_MODE` | ✗ | |
    | `ClickHouseClientOption#SSL_ROOT_CERTIFICATE` | `Client.Builder#setRootCertificate` | SSL Auth should be enabled by `useSSLAuthentication` |
    | `ClickHouseClientOption#SSL_CERTIFICATE` | `Client.Builder#setClientCertificate` | |
    | `ClickHouseClientOption#SSL_KEY` | `Client.Builder#setClientKey` | |
    | `ClickHouseClientOption#KEY_STORE_TYPE` | `Client.Builder#setSSLTrustStoreType` | |
    | `ClickHouseClientOption#TRUST_STORE` | `Client.Builder#setSSLTrustStore` | |
    | `ClickHouseClientOption#KEY_STORE_PASSWORD` | `Client.Builder#setSSLTrustStorePassword` | |
    | `ClickHouseClientOption#SSL_SOCKET_SNI` | `Client.Builder#sslSocketSNI` | |
    | `ClickHouseClientOption#CUSTOM_SOCKET_FACTORY` | ✗ | |
    | `ClickHouseClientOption#CUSTOM_SOCKET_FACTORY_OPTIONS` | ✗ | See `Client.Builder#sslSocketSNI` to set SNI |

    </TabItem>

    <TabItem value="socket" label="Socket Options">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseClientOption#SOCKET_TIMEOUT` | `Client.Builder#setSocketTimeout` | |
    | `ClickHouseClientOption#SOCKET_REUSEADDR` | `Client.Builder#setSocketReuseAddress` | |
    | `ClickHouseClientOption#SOCKET_KEEPALIVE` | `Client.Builder#setSocketKeepAlive` | |
    | `ClickHouseClientOption#SOCKET_LINGER` | `Client.Builder#setSocketLinger` | |
    | `ClickHouseClientOption#SOCKET_IP_TOS` | ✗ | |
    | `ClickHouseClientOption#SOCKET_TCP_NODELAY` | `Client.Builder#setSocketTcpNodelay` | |
    | `ClickHouseClientOption#SOCKET_RCVBUF` | `Client.Builder#setSocketRcvbuf` | |
    | `ClickHouseClientOption#SOCKET_SNDBUF` | `Client.Builder#setSocketSndbuf` | |

    </TabItem>

    <TabItem value="compression" label="Compression">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseClientOption#COMPRESS` | `Client.Builder#compressServerResponse` | See also `useHttpCompression` |
    | `ClickHouseClientOption#DECOMPRESS` | `Client.Builder#compressClientRequest` | See also `useHttpCompression` |
    | `ClickHouseClientOption#COMPRESS_ALGORITHM` | ✗ | `LZ4` for non-http. Http uses `Accept-Encoding` |
    | `ClickHouseClientOption#DECOMPRESS_ALGORITHM` | ✗ | `LZ4` for non-http. Http uses `Content-Encoding` |
    | `ClickHouseClientOption#COMPRESS_LEVEL` | ✗ | |
    | `ClickHouseClientOption#DECOMPRESS_LEVEL` | ✗ | |

    </TabItem>

    <TabItem value="proxy" label="Proxy">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseClientOption#PROXY_TYPE` | `Client.Builder#addProxy` | |
    | `ClickHouseClientOption#PROXY_HOST` | `Client.Builder#addProxy` | |
    | `ClickHouseClientOption#PROXY_PORT` | `Client.Builder#addProxy` | |
    | `ClickHouseClientOption#PROXY_USERNAME` | `Client.Builder#setProxyCredentials` | |
    | `ClickHouseClientOption#PROXY_PASSWORD` | `Client.Builder#setProxyCredentials` | |

    </TabItem>

    <TabItem value="timeouts-retry" label="Timeouts & Retry">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseClientOption#MAX_EXECUTION_TIME` | `Client.Builder#setExecutionTimeout` | |
    | `ClickHouseClientOption#RETRY` | `Client.Builder#setMaxRetries` | See also `retryOnFailures` |
    | `ClickHouseHttpOption#AHC_RETRY_ON_FAILURE` | `Client.Builder#retryOnFailures` | |
    | `ClickHouseClientOption#FAILOVER` | ✗ | |
    | `ClickHouseClientOption#REPEAT_ON_SESSION_LOCK` | ✗ | |
    | `ClickHouseClientOption#SESSION_ID` | ✗ | |
    | `ClickHouseClientOption#SESSION_CHECK` | ✗ | |
    | `ClickHouseClientOption#SESSION_TIMEOUT` | ✗ | |

    </TabItem>

    <TabItem value="timezone" label="Timezone">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseDefaults#SERVER_TIME_ZONE`<br/>`ClickHouseClientOption#SERVER_TIME_ZONE` | `Client.Builder#setServerTimeZone` | |
    | `ClickHouseClientOption#USE_SERVER_TIME_ZONE` | `Client.Builder#useServerTimeZone` | |
    | `ClickHouseClientOption#USE_SERVER_TIME_ZONE_FOR_DATES` | | |
    | `ClickHouseClientOption#USE_TIME_ZONE` | `Client.Builder#useTimeZone` | |

    </TabItem>

    <TabItem value="buffers" label="Buffers & Performance">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseClientOption#BUFFER_SIZE` | `Client.Builder#setClientNetworkBufferSize` | |
    | `ClickHouseClientOption#BUFFER_QUEUE_VARIATION` | ✗ | |
    | `ClickHouseClientOption#READ_BUFFER_SIZE` | ✗ | |
    | `ClickHouseClientOption#WRITE_BUFFER_SIZE` | ✗ | |
    | `ClickHouseClientOption#REQUEST_CHUNK_SIZE` | ✗ | |
    | `ClickHouseClientOption#REQUEST_BUFFERING` | ✗ | |
    | `ClickHouseClientOption#RESPONSE_BUFFERING` | ✗ | |
    | `ClickHouseClientOption#MAX_BUFFER_SIZE` | ✗ | |
    | `ClickHouseClientOption#MAX_QUEUED_BUFFERS` | ✗ | |
    | `ClickHouseClientOption#MAX_QUEUED_REQUESTS` | ✗ | |
    | `ClickHouseClientOption#REUSE_VALUE_WRAPPER` | ✗ | |

    </TabItem>

    <TabItem value="threading" label="Threading & Async">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseDefaults#ASYNC`<br/>`ClickHouseClientOption#ASYNC` | `Client.Builder#useAsyncRequests` | |
    | `ClickHouseDefaults#MAX_SCHEDULER_THREADS` | ✗ | see `setSharedOperationExecutor` |
    | `ClickHouseDefaults#MAX_THREADS` | ✗ | see `setSharedOperationExecutor` |
    | `ClickHouseDefaults#THREAD_KEEPALIVE_TIMEOUT` | see `setSharedOperationExecutor` | |
    | `ClickHouseClientOption#MAX_THREADS_PER_CLIENT` | ✗ | |
    | `ClickHouseClientOption#MAX_CORE_THREAD_TTL` | ✗ | |

    </TabItem>

    <TabItem value="http-headers" label="HTTP & Headers">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseHttpOption#CUSTOM_HEADERS` | `Client.Builder#httpHeaders` | |
    | `ClickHouseHttpOption#CUSTOM_PARAMS` | ✗ | See `Client.Builder#serverSetting` |
    | `ClickHouseClientOption#CLIENT_NAME` | `Client.Builder#setClientName` | |
    | `ClickHouseHttpOption#CONNECTION_PROVIDER` | ✗ | |
    | `ClickHouseHttpOption#DEFAULT_RESPONSE` | ✗ | |
    | `ClickHouseHttpOption#SEND_HTTP_CLIENT_ID` | ✗ | |
    | `ClickHouseHttpOption#AHC_VALIDATE_AFTER_INACTIVITY` | ✗ | Always enabled when Apache Http Client is used |

    </TabItem>

    <TabItem value="format-query" label="Format & Query">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseDefaults#FORMAT`<br/>`ClickHouseClientOption#FORMAT` | ✗ | Moved to operation settings (`QuerySettings` and `InsertSettings`) |
    | `ClickHouseClientOption#QUERY_ID` | ✗ | See `QuerySettings` and `InsertSettings` |
    | `ClickHouseClientOption#LOG_LEADING_COMMENT` | ✗ | See `QuerySettings#logComment` and `InsertSettings#logComment` |
    | `ClickHouseClientOption#MAX_RESULT_ROWS` | ✗ | Is server side setting |
    | `ClickHouseClientOption#RESULT_OVERFLOW_MODE` | ✗ | Is server side setting |
    | `ClickHouseHttpOption#RECEIVE_QUERY_PROGRESS` | ✗ | Server side setting |
    | `ClickHouseHttpOption#WAIT_END_OF_QUERY` | ✗ | Server side setting |
    | `ClickHouseHttpOption#REMEMBER_LAST_SET_ROLES` | `Client#setDBRoles` | Runtime config now. See also `QuerySettings#setDBRoles` and `InsertSettings#setDBRoles` |

    </TabItem>

    <TabItem value="node-discovery" label="Node Discovery & Load Balancing">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseClientOption#AUTO_DISCOVERY` | ✗ | |
    | `ClickHouseClientOption#LOAD_BALANCING_POLICY` | ✗ | |
    | `ClickHouseClientOption#LOAD_BALANCING_TAGS` | ✗ | |
    | `ClickHouseClientOption#HEALTH_CHECK_INTERVAL` | ✗ | |
    | `ClickHouseClientOption#HEALTH_CHECK_METHOD` | ✗ | |
    | `ClickHouseClientOption#NODE_DISCOVERY_INTERVAL` | ✗ | |
    | `ClickHouseClientOption#NODE_DISCOVERY_LIMIT` | ✗ | |
    | `ClickHouseClientOption#NODE_CHECK_INTERVAL` | ✗ | |
    | `ClickHouseClientOption#NODE_GROUP_SIZE` | ✗ | |
    | `ClickHouseClientOption#CHECK_ALL_NODES` | ✗ | |

    </TabItem>

    <TabItem value="misc" label="Miscellaneous">

    | V1 Configuration | V2 Builder Method | Comments |
    |------------------|-------------------|----------|
    | `ClickHouseDefaults#AUTO_SESSION` | ✗ | Session support will be reviewed |
    | `ClickHouseDefaults#BUFFERING` | ✗ | |
    | `ClickHouseDefaults#MAX_REQUESTS` | ✗ | |
    | `ClickHouseDefaults#ROUNDING_MODE` | | |
    | `ClickHouseDefaults#SERVER_VERSION`<br/>`ClickHouseClientOption#SERVER_VERSION` | `Client.Builder#setServerVersion` | |
    | `ClickHouseDefaults#SRV_RESOLVE` | ✗ | |
    | `ClickHouseClientOption#CUSTOM_SETTINGS` | | |
    | `ClickHouseClientOption#PRODUCT_NAME` | ✗ | Use client name |
    | `ClickHouseClientOption#RENAME_RESPONSE_COLUMN` | ✗ | |
    | `ClickHouseClientOption#SERVER_REVISION` | ✗ | |
    | `ClickHouseClientOption#TRANSACTION_TIMEOUT` | ✗ | |
    | `ClickHouseClientOption#WIDEN_UNSIGNED_TYPES` | ✗ | |
    | `ClickHouseClientOption#USE_BINARY_STRING` | ✗ | |
    | `ClickHouseClientOption#USE_BLOCKING_QUEUE` | ✗ | |
    | `ClickHouseClientOption#USE_COMPILATION` | ✗ | |
    | `ClickHouseClientOption#USE_OBJECTS_IN_ARRAYS` | ✗ | |
    | `ClickHouseClientOption#MAX_MAPPER_CACHE` | ✗ | |
    | `ClickHouseClientOption#MEASURE_REQUEST_TIME` | ✗ | |

    </TabItem>
    </Tabs>


    ### General Differences

    - Client V2 uses less proprietary classes to increase portability. For example, V2 works with any implementation of `java.io.InputStream` for
    writing data to a server.
    - Client V2 `async` settings is `off` by default. It means no extra threads and more application control over client. This setting should be `off` for majority of use cases. Enabling `async` will create a separate thread for a request. It only make sense when using application controlled
    executor (see `com.clickhouse.client.api.Client.Builder#setSharedOperationExecutor`)

    ### Writing Data

    - use any implementation of `java.io.InputStream`. V1 `com.clickhouse.data.ClickHouseInputStream` is supported but NOT recommended.
    - once end of input stream is detected it handled accordingly. Previously output stream of a request should be closed.

    __V1 Insert TSV formatted data.__
    ```java
    InputStream inData = getInData();
    ClickHouseRequest.Mutation request = client.read(server)
            .write()
            .table(tableName)
            .format(ClickHouseFormat.TSV);
    ClickHouseConfig config = request.getConfig();
    CompletableFuture<ClickHouseResponse> future;
    try (ClickHousePipedOutputStream requestBody = ClickHouseDataStreamFactory.getInstance()
            .createPipedOutputStream(config)) {
        // start the worker thread which transfer data from the input into ClickHouse
        future = request.data(requestBody.getInputStream()).execute();

        // Copy data from inData stream to requestBody stream

        // We need to close the stream before getting a response
        requestBody.close();

        try (ClickHouseResponse response = future.get()) {
            ClickHouseResponseSummary summary = response.getSummary();
            Assert.assertEquals(summary.getWrittenRows(), numRows, "Num of written rows");
        }
    }

    ````

    **V2 TSV 형식의 데이터를 삽입합니다.**

    ```java
    InputStream inData = getInData();
    InsertSettings settings = new InsertSettings().setInputStreamCopyBufferSize(8198 * 2); // set copy buffer size
    try (InsertResponse response = client.insert(tableName, inData, ClickHouseFormat.TSV, settings).get(30, TimeUnit.SECONDS)) {

      // Insert is complete at this point

    } catch (Exception e) {
     // Handle exception
    }
    ```

    * 호출해야 하는 메서드는 하나뿐입니다. 별도의 요청 객체를 생성할 필요가 없습니다.
    * 모든 데이터 복사가 완료되면 요청 본문(request body) 스트림은 자동으로 닫힙니다.
    * 새로운 저수준 API인 `com.clickhouse.client.api.Client#insert(java.lang.String, java.util.List<java.lang.String>, com.clickhouse.client.api.DataStreamWriter, com.clickhouse.data.ClickHouseFormat, com.clickhouse.client.api.insert.InsertSettings)`를 사용할 수 있습니다. `com.clickhouse.client.api.DataStreamWriter`는 사용자 정의 데이터 쓰기 로직을 구현하도록 설계되었습니다. 예를 들어 큐에서 데이터를 읽어와 쓰는 로직을 구현할 때 사용할 수 있습니다.

    ### 데이터 읽기

    * 데이터는 기본적으로 `RowBinaryWithNamesAndTypes` 형식으로 읽어집니다. 현재는 데이터 바인딩이 필요한 경우 이 형식만 지원됩니다.
    * 데이터는 `List<GenericRecord> com.clickhouse.client.api.Client#queryAll(java.lang.String)` 메서드를 사용하여 레코드 컬렉션으로 읽을 수 있습니다. 이 메서드는 데이터를 메모리에 로드한 후 연결을 해제합니다. 별도의 추가 처리는 필요하지 않습니다. `GenericRecord`는 데이터에 접근할 수 있도록 하며, 일부 형 변환 기능을 구현합니다.

    ```java
    Collection<GenericRecord> records = client.queryAll("SELECT * FROM table");
    for (GenericRecord record : records) {
        int rowId = record.getInteger("rowID");
        String name = record.getString("name");
        LocalDateTime ts = record.getLocalDateTime("ts");
    }

    ```
  </Version>

  <Version>
    프로토콜을 통해 데이터베이스 서버와 통신하는 Java 클라이언트 라이브러리입니다. 현재 구현은 [HTTP 인터페이스](/interfaces/http)만 지원합니다. 이 라이브러리는 서버로 요청을 전송하기 위한 자체 API를 제공합니다.

    :::warning 지원 중단
    이 라이브러리는 곧 지원이 중단될 예정입니다. 새 프로젝트에는 최신 [Java Client](/integrations/language-clients/java/client/client.mdx)를 사용하세요.
    :::

    ## 설정

    <Tabs groupId="client-v1-setup">
      <TabItem value="maven" label="Maven">
        ```xml
        <!-- 참고: https://mvnrepository.com/artifact/com.clickhouse/clickhouse-http-client -->
        <dependency>
            <groupId>com.clickhouse</groupId>
            <artifactId>clickhouse-http-client</artifactId>
            <version>0.7.2</version>
        </dependency>
        ```
      </TabItem>

      <TabItem value="gradle-kt" label="Gradle (Kotlin)">
        ```kotlin
        // 참고: https://mvnrepository.com/artifact/com.clickhouse/clickhouse-http-client
        implementation("com.clickhouse:clickhouse-http-client:0.7.2")
        ```
      </TabItem>

      <TabItem value="gradle" label="Gradle">
        ```groovy
        // 참고: https://mvnrepository.com/artifact/com.clickhouse/clickhouse-http-client
        implementation 'com.clickhouse:clickhouse-http-client:0.7.2'
        ```
      </TabItem>
    </Tabs>

    버전 `0.5.0`부터 드라이버는 의존성으로 추가해야 하는 새로운 클라이언트 HTTP 라이브러리를 사용합니다.

    <Tabs groupId="client-v1-http-client">
      <TabItem value="maven" label="Maven">
        ```xml
        <!-- https://mvnrepository.com/artifact/org.apache.httpcomponents.client5/httpclient5 -->
        <dependency>
            <groupId>org.apache.httpcomponents.client5</groupId>
            <artifactId>httpclient5</artifactId>
            <version>5.3.1</version>
        </dependency>
        ```
      </TabItem>

      <TabItem value="gradle-kt" label="Gradle (Kotlin)">
        ```kotlin
        // https://mvnrepository.com/artifact/org.apache.httpcomponents.client5/httpclient5
        implementation("org.apache.httpcomponents.client5:httpclient5:5.3.1")
        ```
      </TabItem>

      <TabItem value="gradle" label="Gradle">
        ```groovy
        // https://mvnrepository.com/artifact/org.apache.httpcomponents.client5/httpclient5
        implementation 'org.apache.httpcomponents.client5:httpclient5:5.3.1'
        ```
      </TabItem>
    </Tabs>

    ## 초기화

    연결 URL 형식: `protocol://host[:port][/database][?param[=value][&param[=value]][#tag[,tag]]`, 예를 들어:

    * `http://localhost:8443?ssl=true&sslmode=NONE`
    * `https://(https://explorer@play.clickhouse.com:443`

    단일 노드에 연결하세요:

    ```java showLineNumbers
    ClickHouseNode server = ClickHouseNode.of("http://localhost:8123/default?compress=0");
    ```

    여러 노드로 구성된 클러스터에 연결하세요:

    ```java showLineNumbers
    ClickHouseNodes servers = ClickHouseNodes.of(
        "jdbc:ch:http://server1.domain,server2.domain,server3.domain/my_db"
        + "?load_balancing_policy=random&health_check_interval=5000&failover=2");
    ```

    ## 쿼리 API

    ```java showLineNumbers
    try (ClickHouseClient client = ClickHouseClient.newInstance(ClickHouseProtocol.HTTP);
         ClickHouseResponse response = client.read(servers)
            .format(ClickHouseFormat.RowBinaryWithNamesAndTypes)
            .query("select * from numbers limit :limit")
            .params(1000)
            .executeAndWait()) {
                ClickHouseResponseSummary summary = response.getSummary();
                long totalRows = summary.getTotalRowsToRead();
    }
    ```

    ## 스트리밍 쿼리 API

    ```java showLineNumbers
    try (ClickHouseClient client = ClickHouseClient.newInstance(ClickHouseProtocol.HTTP);
         ClickHouseResponse response = client.read(servers)
            .format(ClickHouseFormat.RowBinaryWithNamesAndTypes)
            .query("select * from numbers limit :limit")
            .params(1000)
            .executeAndWait()) {
                for (ClickHouseRecord r : response.records()) {
                int num = r.getValue(0).asInteger();
                // type conversion
                String str = r.getValue(0).asString();
                LocalDate date = r.getValue(0).asDate();
            }
    }
    ```

    [저장소](https://github.com/ClickHouse/clickhouse-java/tree/main/examples/client)에서 [전체 코드 예제](https://github.com/ClickHouse/clickhouse-java/blob/main/examples/client/src/main/java/com/clickhouse/examples/jdbc/Main.java#L73)를 참조하세요.

    ## Insert API

    ```java showLineNumbers

    try (ClickHouseClient client = ClickHouseClient.newInstance(ClickHouseProtocol.HTTP);
         ClickHouseResponse response = client.read(servers).write()
            .format(ClickHouseFormat.RowBinaryWithNamesAndTypes)
            .query("insert into my_table select c2, c3 from input('c1 UInt8, c2 String, c3 Int32')")
            .data(myInputStream) // `myInputStream` is source of data in RowBinary format
            .executeAndWait()) {
                ClickHouseResponseSummary summary = response.getSummary();
                summary.getWrittenRows();
    }
    ```

    [저장소](https://github.com/ClickHouse/clickhouse-java/tree/main/examples/client)에서 [전체 코드 예제](https://github.com/ClickHouse/clickhouse-java/blob/main/examples/client/src/main/java/com/clickhouse/examples/jdbc/Main.java#L39)를 참조하세요.

    **RowBinary 인코딩**

    RowBinary 형식은 [해당 페이지](/interfaces/formats/RowBinaryWithNamesAndTypes)에 설명되어 있습니다.

    예제 코드는 [code](https://github.com/ClickHouse/clickhouse-kafka-connect/blob/main/src/main/java/com/clickhouse/kafka/connect/sink/db/ClickHouseWriter.java#L622)에서 확인할 수 있습니다.

    ## 주요 기능

    ### 압축

    클라이언트는 기본적으로 LZ4 압축을 사용하며, 이를 위해 다음 종속성이 필요합니다:

    <Tabs groupId="client-v1-compression-deps">
      <TabItem value="maven" label="Maven">
        ```xml
        <!-- 참고: https://mvnrepository.com/artifact/org.lz4/lz4-java -->
        <dependency>
            <groupId>org.lz4</groupId>
            <artifactId>lz4-java</artifactId>
            <version>1.8.0</version>
        </dependency>
        ```
      </TabItem>

      <TabItem value="gradle-kt" label="Gradle (Kotlin)">
        ```kotlin
        // 참고: https://mvnrepository.com/artifact/org.lz4/lz4-java
        implementation("org.lz4:lz4-java:1.8.0")
        ```
      </TabItem>

      <TabItem value="gradle" label="Gradle">
        ```groovy
        // 참고: https://mvnrepository.com/artifact/org.lz4/lz4-java
        implementation 'org.lz4:lz4-java:1.8.0'
        ```
      </TabItem>
    </Tabs>

    연결 URL에서 `compress_algorithm=gzip`으로 설정하여 gzip을 대신 사용하실 수 있습니다.

    또는 여러 가지 방법으로 압축을 비활성화할 수 있습니다.

    1. 연결 URL에서 `compress=0`으로 지정하여 압축을 비활성화합니다: `http://localhost:8123/default?compress=0`
    2. 클라이언트 구성에서 비활성화하십시오:

    ```java showLineNumbers
    ClickHouseClient client = ClickHouseClient.builder()
       .config(new ClickHouseConfig(Map.of(ClickHouseClientOption.COMPRESS, false)))
       .nodeSelector(ClickHouseNodeSelector.of(ClickHouseProtocol.HTTP))
       .build();
    ```

    다양한 압축 옵션에 대해 자세히 알아보려면 [압축 문서](/data-compression/compression-modes)를 참조하십시오.

    ### 여러 쿼리

    동일한 세션 내에서 워커 스레드(worker thread)에서 여러 쿼리를 순차적으로 실행하세요:

    ```java showLineNumbers
    CompletableFuture<List<ClickHouseResponseSummary>> future = ClickHouseClient.send(servers.apply(servers.getNodeSelector()),
        "create database if not exists my_base",
        "use my_base",
        "create table if not exists test_table(s String) engine=Memory",
        "insert into test_table values('1')('2')('3')",
        "select * from test_table limit 1",
        "truncate table test_table",
        "drop table if exists test_table");
    List<ClickHouseResponseSummary> results = future.get();
    ```

    ### 명명된 매개변수(Named Parameters)

    매개변수 목록에서 위치에만 의존하지 않고 이름으로 매개변수를 전달할 수 있습니다. 이 기능은 `params` 함수를 사용해 활용할 수 있습니다.

    ```java showLineNumbers
    try (ClickHouseClient client = ClickHouseClient.newInstance(ClickHouseProtocol.HTTP);
         ClickHouseResponse response = client.read(servers)
            .format(ClickHouseFormat.RowBinaryWithNamesAndTypes)
            .query("select * from my_table where name=:name limit :limit")
            .params("Ben", 1000)
            .executeAndWait()) {
                //...
            }
    }
    ```

    :::note 매개변수
    `String` 타입(`String`, `String[]`, `Map<String, String>`)과 관련된 모든 `params` 시그니처는 전달되는 키가 유효한 ClickHouse SQL 문자열임을 전제로 합니다. 예를 들면:

    ```java showLineNumbers
    try (ClickHouseClient client = ClickHouseClient.newInstance(ClickHouseProtocol.HTTP);
         ClickHouseResponse response = client.read(servers)
            .format(ClickHouseFormat.RowBinaryWithNamesAndTypes)
            .query("select * from my_table where name=:name")
            .params(Map.of("name","'Ben'"))
            .executeAndWait()) {
                //...
            }
    }
    ```

    String 객체를 ClickHouse SQL로 직접 파싱하지 않으려면 `com.clickhouse.data` 패키지에 있는 헬퍼 함수 `ClickHouseValues.convertToSqlExpression`을 사용하세요:

    ```java showLineNumbers
    try (ClickHouseClient client = ClickHouseClient.newInstance(ClickHouseProtocol.HTTP);
         ClickHouseResponse response = client.read(servers)
            .format(ClickHouseFormat.RowBinaryWithNamesAndTypes)
            .query("select * from my_table where name=:name")
            .params(Map.of("name", ClickHouseValues.convertToSqlExpression("Ben's")))
            .executeAndWait()) {
                //...
            }
    }
    ```

    위 예제에서 `ClickHouseValues.convertToSqlExpression`은 내부의 작은따옴표를 이스케이프 처리하고, 변수 양쪽을 유효한 작은따옴표로 감쌉니다.

    `Integer`, `UUID`, `Array`, `Enum` 등의 다른 타입은 `params`에서 자동으로 변환됩니다.
    :::

    ## 노드 디스커버리

    Java 클라이언트는 ClickHouse 노드를 자동으로 검색하는 기능을 제공합니다. 자동 검색은 기본적으로 비활성화되어 있습니다. 수동으로 활성화하려면 `auto_discovery`를 `true`로 설정하세요:

    ```java
    properties.setProperty("auto_discovery", "true");
    ```

    또는 연결 URL에서 다음과 같이 설정합니다:

    ```plaintext
    jdbc:ch://my-server/system?auto_discovery=true
    ```

    자동 검색이 활성화된 경우 연결 URL에 모든 ClickHouse 노드를 지정할 필요가 없습니다. URL에 지정된 노드는 시드 노드로 취급되며, Java 클라이언트는 system 테이블 및/또는 Keeper/ZooKeeper에서 추가 노드를 자동으로 탐지합니다.

    다음 옵션으로 자동 검색을 구성할 수 있습니다:

    | 속성                              | 기본값     | 설명                                                                |
    | ------------------------------- | ------- | ----------------------------------------------------------------- |
    | auto&#95;discovery              | `false` | 클라이언트가 system 테이블 및/또는 Keeper/ZooKeeper에서 추가 노드를 자동으로 탐지할지 여부입니다. |
    | node&#95;discovery&#95;interval | `0`     | 노드 탐지 간격(밀리초)입니다. 0 이하의 값으로 설정하면 한 번만 탐지합니다.                      |
    | node&#95;discovery&#95;limit    | `100`   | 한 번에 탐지할 수 있는 최대 노드 수입니다. 0 이하의 값으로 설정하면 제한이 없음을 의미합니다.           |

    ### 로드 밸런싱

    Java 클라이언트는 로드 밸런싱 정책에 따라 요청을 보낼 ClickHouse 노드를 선택합니다. 일반적으로 로드 밸런싱 정책은 다음과 같은 역할을 합니다:

    1. 관리 중인 노드 목록에서 노드 하나를 선택합니다.
    2. 노드 상태를 관리합니다.
    3. 자동 검색이 활성화된 경우, 노드 검색용 백그라운드 프로세스를 필요에 따라 스케줄링하고 헬스 체크를 실행합니다.

    다음은 로드 밸런싱을 구성하기 위한 옵션 목록입니다.

    | 속성                            | 기본값                                      | 설명                                                                                                                                                                                                                                                                                                                                                  |
    | ----------------------------- | ---------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | load&#95;balancing&#95;policy | `""`                                     | 로드 밸런싱 정책은 다음 중 하나일 수 있습니다: <li>`firstAlive` - 요청이 관리 노드 목록에서 정상 상태인 첫 번째 노드로 전송됩니다.</li><li>`random` - 요청이 관리 노드 목록에서 임의의 노드로 전송됩니다.</li><li>`roundRobin` - 요청이 관리 노드 목록의 각 노드로 차례대로 전송됩니다.</li><li>`ClickHouseLoadBalancingPolicy`를 구현하는 완전히 한정된 클래스 이름(fully qualified class name) - 사용자 정의 로드 밸런싱 정책</li>지정하지 않으면 요청은 관리 노드 목록의 첫 번째 노드로 전송됩니다. |
    | load&#95;balancing&#95;tags   | `""`                                     | 노드를 필터링하기 위한 로드 밸런싱 태그입니다. 요청은 지정된 태그를 가진 노드로만 전송됩니다.                                                                                                                                                                                                                                                                                               |
    | health&#95;check&#95;interval | `0`                                      | 헬스 체크 간격(밀리초)입니다. 값이 0 이하이면 한 번만 수행됩니다.                                                                                                                                                                                                                                                                                                             |
    | health&#95;check&#95;method   | `ClickHouseHealthCheckMethod.SELECT_ONE` | 헬스 체크 방식입니다. 다음 중 하나일 수 있습니다: <li>`ClickHouseHealthCheckMethod.SELECT_ONE` - `select 1` 쿼리로 확인합니다</li> <li>`ClickHouseHealthCheckMethod.PING` - 프로토콜 수준의 확인 방식으로, 일반적으로 더 빠릅니다</li>                                                                                                                                                                 |
    | node&#95;check&#95;interval   | `0`                                      | 노드 검사 간격(밀리초)이며, 음수 값은 0으로 간주됩니다. 마지막 검사 이후 지정된 시간이 경과하면 노드 상태를 확인합니다.<br />`health_check_interval`과 `node_check_interval`의 차이는, `health_check_interval` 옵션은 노드 목록(전체 또는 장애 노드)에 대한 상태를 확인하는 백그라운드 작업을 스케줄링하는 반면, `node_check_interval`은 특정 노드에 대해 마지막 검사 이후 상태를 다시 확인하기까지 얼마나 시간이 경과해야 하는지를 지정한다는 점입니다                                             |
    | check&#95;all&#95;nodes       | `false`                                  | 모든 노드에 대해 헬스 체크를 수행할지, 비정상 노드에 대해서만 수행할지 지정합니다.                                                                                                                                                                                                                                                                                                     |

    ### 장애 조치 및 재시도

    Java 클라이언트는 실패한 쿼리에 대한 장애 조치 및 재시도 동작을 구성할 수 있는 옵션을 제공합니다:

    | 속성                                 | 기본값    | 설명                                                                                                                                                 |
    | ---------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------- |
    | failover                           | `0`    | 하나의 요청에 대해 허용되는 failover의 최대 횟수입니다. 값이 0이거나 음수이면 failover를 수행하지 않습니다. Failover는 장애가 발생한 요청을 복구하기 위해 부하 분산 정책에 따라 요청을 다른 노드로 전송합니다.                 |
    | retry                              | `0`    | 요청에 대해 재시도가 발생할 수 있는 최대 횟수입니다. 0 또는 음수 값은 재시도를 수행하지 않음을 의미합니다. 재시도는 ClickHouse 서버가 `NETWORK_ERROR` 오류 코드를 반환한 경우에만 동일한 노드로 요청을 다시 전송합니다.           |
    | repeat&#95;on&#95;session&#95;lock | `true` | 세션이 잠겨 있을 때 `session_timeout` 또는 `connect_timeout`에 따라 시간 초과될 때까지 실행을 반복할지 여부입니다. ClickHouse 서버가 `SESSION_IS_LOCKED` 오류 코드를 반환하면 실패한 요청을 다시 시도합니다. |

    ### 커스텀 HTTP 헤더 추가하기

    Java 클라이언트는 요청에 사용자 정의 HTTP 헤더를 추가해야 하는 경우 HTTP/S 전송 계층을 지원합니다.
    `custom_http_headers` 속성을 사용하십시오. 헤더는 `,`로 구분되어야 하며, 헤더 키/값은 `=`를 사용하여 구분합니다.

    ## Java Client 지원

    ```java
    options.put("custom_http_headers", "X-ClickHouse-Quota=test, X-ClickHouse-Test=test");
    ```

    ## JDBC 드라이버

    ```java
    properties.setProperty("custom_http_headers", "X-ClickHouse-Quota=test, X-ClickHouse-Test=test");
    ```
  </Version>
</ClientVersionDropdown>
---
sidebar_label: 'JDBC'
sidebar_position: 4
keywords: ['clickhouse', 'java', 'jdbc', 'driver', 'integrate']
description: 'ClickHouse JDBC 드라이버'
slug: /integrations/language-clients/java/jdbc
title: 'JDBC 드라이버'
doc_type: 'reference'
integration:
  - support_level: 'core'
  - category: 'language_client'
---

import ClientVersionDropdown from '@theme/ClientVersionDropdown/ClientVersionDropdown';
import Version from '@theme/ClientVersionDropdown/Version';
import WideTableWrapper from '@site/src/components/WideTableWrapper/WideTableWrapper';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<ClientVersionDropdown
  versions={[
{
    'version': 'v0.8+'
},
{
    'version': 'v0.7.x'
}
]}
>
  <Version>
    :::note
    `clickhouse-jdbc`는 최신 Java 클라이언트를 사용하여 표준 JDBC 인터페이스를 구현합니다.
    성능 또는 직접 액세스가 중요한 경우 최신 Java 클라이언트를 직접 사용하시기 바랍니다.
    :::

    ## 환경 요구 사항 \{#environment-requirements\}

    * [OpenJDK](https://openjdk.java.net) 버전 8 이상

    ### 설정 \{#setup\}

    <Tabs groupId="jdbc-base-dependencies">
      <TabItem value="maven" label="Maven">
        ```xml
        <!-- https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc -->
        <dependency>
            <groupId>com.clickhouse</groupId>
            <artifactId>clickhouse-jdbc</artifactId>
            <version>0.9.6</version>
            <classifier>all</classifier>
        </dependency>
        ```
      </TabItem>

      <TabItem value="gradle-kt" label="Gradle (Kotlin)">
        ```kotlin
        // https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc
        implementation("com.clickhouse:clickhouse-jdbc:0.9.6:all")
        ```
      </TabItem>

      <TabItem value="gradle" label="Gradle">
        ```groovy
        // https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc
        implementation 'com.clickhouse:clickhouse-jdbc:0.9.6:all'
        ```
      </TabItem>
    </Tabs>

    클래스패스에 JAR를 추가해야 하는 애플리케이션에서 JDBC 드라이버를 사용하는 경우, 다음 위치에서 JAR를 다운로드하여 추가하십시오:

    * [Maven Central](https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc)에서 라이브러리를 가져와 클래스패스에 추가하십시오
      * 버전 `0.9.4`부터는 https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc-all 라는 아티팩트가 제공됩니다.
      * 모든 shaded 의존성이 포함된 JAR 파일을 받으려면 qualifier를 `all`로 지정하십시오.
    * 또는 공식 저장소의 [여기](https://github.com/ClickHouse/clickhouse-java/releases)에서 다운로드할 수 있습니다.

    ## 구성 \{#configuration\}

    **드라이버 클래스**: `com.clickhouse.jdbc.ClickHouseDriver`

    :::note
    `com.clickhouse.jdbc.ClickHouseDriver`는 새로운 JDBC 구현과 이전 JDBC 구현을 위한 파사드 클래스입니다. 기본적으로 새로운 JDBC 구현을 사용합니다.
    연결 속성에서 `clickhouse.jdbc.v1` 속성을 `true`로 설정하면 이전 JDBC 구현을 사용할 수 있습니다.

    `com.clickhouse.jdbc.Driver`는 새로운 JDBC 구현입니다.
    `com.clickhouse.jdbc.DriverV1`은 기존 JDBC 구현입니다.

    :::

    **URL 구문**: `jdbc:(ch|clickhouse)[:<protocol>]://endpoint[:port][/<database>][?param1=value1&param2=value2][#tag1,tag2,...]`, 예를 들어:

    * `jdbc:clickhouse:http://localhost:8123`
    * `jdbc:clickhouse:https://localhost:8443?ssl=true`

    URL 구문에 대해 유의할 사항은 다음과 같습니다:

    * URL에는 엔드포인트를 **하나만** 지정할 수 있습니다
    * 기본 프로토콜인 &#39;HTTP&#39;가 아닌 경우 프로토콜을 명시해야 합니다.
    * 기본 포트인 &#39;8123&#39;이 아닌 경우 포트를 지정해야 합니다
    * 드라이버는 포트 번호를 보고 프로토콜을 추측하지 않으므로 프로토콜을 반드시 명시적으로 지정해야 합니다
    * 프로토콜을 명시한 경우 `ssl` 매개변수를 별도로 지정할 필요가 없습니다.

    ### 연결 속성(Connection Properties) \{#connection-properties\}

    주요 구성 매개변수는 [Java 클라이언트](/integrations/language-clients/java/client#client-configuration)에 정의되어 있습니다. 이러한 매개변수는 드라이버에 그대로 전달해야 합니다. 드라이버에는 클라이언트 구성에 포함되지 않는 별도의 속성도 있으며, 이는 아래에 나열되어 있습니다.

    **드라이버 속성**:

    | 속성                                  | 기본값      | 설명                                                                                                                           |
    | ----------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------- |
    | `disable_frameworks_detection`      | `true`   | User-Agent 기반 프레임워크 감지를 비활성화합니다                                                                                              |
    | `jdbc_ignore_unsupported_values`    | `false`  | 드라이버의 동작에 영향을 주지 않는 경우 `SQLFeatureNotSupportedException` 발생을 억제합니다                                                           |
    | `clickhouse.jdbc.v1`                | `false`  | 새 JDBC 구현 대신 이전 JDBC 구현을 사용합니다                                                                                               |
    | `default_query_settings`            | `null`   | 쿼리 실행 시 기본 쿼리 설정을 함께 전달할 수 있도록 합니다                                                                                           |
    | `jdbc_resultset_auto_close`         | `true`   | `Statement`를 닫을 때 `ResultSet`을 자동으로 닫습니다                                                                                     |
    | `beta.row_binary_for_simple_insert` | `false`  | `RowBinary` writer 기반의 `PreparedStatement` 구현을 사용합니다. `INSERT INTO ... VALUES` 형식의 쿼리에서만 동작합니다.                              |
    | `jdbc_resultset_auto_close`         | `true`   | `Statement`가 닫히면 `ResultSet`을 자동으로 닫습니다                                                                                      |
    | `jdbc_use_max_result_rows`          | `false`  | 서버 속성 `max_result_rows`를 사용해 쿼리 결과로 반환되는 행 수를 제한할 수 있도록 합니다. 활성화되면 사용자가 설정한 overflow 모드보다 우선 적용됩니다. 자세한 내용은 JavaDoc을 참조하십시오. |
    | `jdbc_sql_parser`                   | `JAVACC` | 사용할 SQL 파서를 구성합니다. 선택할 수 있는 값은 `ANTLR4`, `ANTLR4_PARAMS_PARSER`, `JAVACC`입니다.                                                |

    :::note 서버 설정

    모든 서버 설정에는 `clickhouse_setting_` 접두사를 붙여야 합니다 (클라이언트 [구성](/integrations/language-clients/java/client#server-settings)과 동일합니다).

    ```java
    Properties config = new Properties();
    config.setProperty("user", "default");
    config.setProperty("password", getPassword());

    // set server setting
    config.put(ClientConfigProperties.serverSetting("allow_experimental_time_time64_type"), "1");

    Connection conn = Driver.connect("jdbc:ch:http://localhost:8123/", config);
    ```

    :::

    **구성 예제**:

    ```java
    Properties properties = new Properties();
    properties.setProperty("user", "default");
    properties.setProperty("password", getPassword());
    properties.setProperty("client_name", "my-app-01"); // when http protocol is used it will be `http_user_agent` in the query log but not `client_name`.

    Connection conn = Driver.connect("jdbc:ch:http://localhost:8123/", properties);
    ```

    다음 JDBC URL과 동등합니다:

    ```sql
    jdbc:ch:http://localhost:8123/?user=default&password=password&client_name=my-app-01 
    // credentials shoud be passed in `Properties`. Here it is just for example.
    ```

    참고: JDBC URL이나 속성을 URL 인코딩할 필요가 없습니다. 자동으로 인코딩됩니다.

    ## 지원되는 데이터 유형 \{#supported-data-types\}

    JDBC Driver는 기반 [java client](/integrations/java#supported-data-types)와 동일한 데이터 형식을 지원합니다.

    ### JDBC 타입 매핑 \{#jdbc-type-mapping\}

    다음 매핑이 적용됩니다:

    * `ResultSet#getObject(columnIndex)` 메서드는 해당하는 Java 클래스의 객체를 반환합니다. (`Int8` -&gt; `java.lang.Byte`, `Int16` -&gt; `java.lang.Short` 등)
    * `ResultSetMetaData#getColumnType(columnIndex)` 메서드는 해당 JDBC 타입을 반환합니다. (`Int8` -&gt; `java.lang.Byte`, `Int16` -&gt; `java.lang.Short` 등)

    매핑을 변경하는 방법은 다음과 같습니다:

    * `ResultSet#getObject(columnIndex, class)` 메서드는 값을 `class` 타입으로 변환하려고 시도합니다. 일부 변환에는 제약이 있습니다. 자세한 내용은 각 섹션을 참조하십시오.

    **숫자형 타입(Numeric Types)**

    | ClickHouse 타입 | JDBC 타입  | Java 클래스             |
    | ------------- | -------- | -------------------- |
    | Int8          | TINYINT  | java.lang.Byte       |
    | Int16         | SMALLINT | java.lang.Short      |
    | Int32         | INTEGER  | java.lang.Integer    |
    | Int64         | BIGINT   | java.lang.Long       |
    | Int128        | OTHER    | java.math.BigInteger |
    | Int256        | OTHER    | java.math.BigInteger |
    | UInt8         | OTHER    | java.lang.Short      |
    | UInt16        | OTHER    | java.lang.Integer    |
    | UInt32        | OTHER    | java.lang.Long       |
    | UInt64        | OTHER    | java.math.BigInteger |
    | UInt128       | OTHER    | java.math.BigInteger |
    | UInt256       | OTHER    | java.math.BigInteger |
    | Float32       | REAL     | java.lang.Float      |
    | Float64       | DOUBLE   | java.lang.Double     |
    | Decimal32     | DECIMAL  | java.math.BigDecimal |
    | Decimal64     | DECIMAL  | java.math.BigDecimal |
    | Decimal128    | DECIMAL  | java.math.BigDecimal |
    | Decimal256    | DECIMAL  | java.math.BigDecimal |
    | Bool          | BOOLEAN  | java.lang.Boolean    |

    * 숫자형 데이터 타입은 서로 간에 변환할 수 있습니다. 따라서 `Int8` 값을 `Float64`로 읽을 수 있고, 그 반대도 가능합니다.:
      * `rs.getObject(1, Float64.class)`는 `Int8` 컬럼의 `Float64` 값을 반환합니다.
      * `rs.getLong(1)`는 `Int8` 컬럼의 `Long` 값을 반환합니다.
      * `rs.getByte(1)`는 `Int16` 컬럼의 값이 `Byte`에 들어갈 수 있는 경우 `Byte` 값으로 반환할 수 있습니다.
    * 더 넓은 범위의 타입에서 더 좁은 범위의 타입으로의 변환은 데이터 손상 위험 때문에 권장되지 않습니다.
    * `Bool` 타입은 숫자 타입처럼 동작하기도 합니다.
    * 모든 숫자 타입은 `java.lang.String`으로 읽을 수 있습니다.

    **문자열 타입(String Types)**

    | ClickHouse 타입 | JDBC 타입 | Java 클래스         |
    | ------------- | ------- | ---------------- |
    | String        | VARCHAR | java.lang.String |
    | FixedString   | VARCHAR | java.lang.String |

    * `String`은 `java.lang.String` 또는 `byte[]` 타입으로만 읽을 수 있습니다.
    * `FixedString`은 있는 그대로 읽되, 컬럼 길이에 맞도록 0으로 패딩됩니다. (예를 들어 `'John'`에 대한 `FixedString(10)`은 `'John\0\0\0\0\0\0\0\0\0'`으로 읽힙니다.)

    **Enum 유형**

    | ClickHouse 타입 | JDBC 타입 | Java 클래스         |
    | ------------- | ------- | ---------------- |
    | Enum8         | OTHER   | java.lang.String |
    | Enum16        | OTHER   | java.lang.String |

    * `Enum8`과 `Enum16`은 기본적으로 `java.lang.String` 타입에 매핑됩니다.
    * Enum 값은 지정된 getter 메서드 또는 `getObject(columnIndex, Integer.class)` 메서드를 사용하여 숫자 값으로 읽을 수 있습니다.
    * `Enum16`은 내부적으로 `short`에, `Enum8`은 `byte`에 매핑됩니다. 데이터가 손상될 수 있으므로 `Enum16`을 `byte`로 읽는 것은 피해야 합니다.
    * Enum 값은 `PreparedStatement`에서 문자열 값이나 숫자 값으로 설정할 수 있습니다.

    **날짜/시간 타입(Date/Time Types)**

    | ClickHouse 타입 | JDBC 타입   | Java 클래스           |
    | ------------- | --------- | ------------------ |
    | Date          | DATE      | java.sql.Date      |
    | Date32        | DATE      | java.sql.Date      |
    | DateTime      | TIMESTAMP | java.sql.Timestamp |
    | DateTime64    | TIMESTAMP | java.sql.Timestamp |
    | Time          | TIME      | java.sql.Time      |
    | Time64        | TIME      | java.sql.Time      |

    * 날짜/시간 타입은 JDBC와의 호환성을 높이기 위해 `java.sql` 타입으로 매핑됩니다. 다만 `ResultSet#getObject(columnIndex, Class<T>)`를 사용하여 두 번째 인자로 해당 클래스를 전달하면 `java.time.LocalDate`, `java.time.LocalDateTime`, `java.time.LocalTime`을(를) 반환받을 수도 있습니다.
      * `rs.getObject(1, java.time.LocalDate.class)`는 `Date` 컬럼의 `java.time.LocalDate` 값을 반환합니다.
      * `rs.getObject(1, java.time.LocalDateTime.class)`는 `DateTime` 컬럼의 `java.time.LocalDateTime` 값을 반환합니다.
      * `rs.getObject(1, java.time.LocalTime.class)`는 `Time` 컬럼의 `java.time.LocalTime` 값을 반환합니다.
    * `Date`, `Date32`, `Time`, `Time64` 데이터 타입은 서버 타임존의 영향을 받지 않습니다.
    * `DateTime`, `DateTime64`는 서버 또는 세션 시간대의 영향을 받습니다.
    * `DateTime` 및 `DateTime64` 값은 `getObject(colIndex, ZonedDateTime.class)`를 사용하여 `ZonedDateTime`으로 조회할 수 있습니다.

    **중첩 타입(Nested Types)**

    | ClickHouse 타입 | JDBC 타입         | Java 클래스                  |
    | ------------- | --------------- | ------------------------- |
    | Array         | ARRAY           | java.sql.Array            |
    | Tuple         | OTHER           | com.clickhouse.data.Tuple |
    | 맵             | JAVA&#95;OBJECT | java.util.Map             |
    | Nested        | ARRAY           | java.sql.Array            |

    * `Array`는 JDBC와의 호환성을 위해 기본적으로 `java.sql.Array`에 매핑됩니다. 이는 반환된 배열 값의 타입에 대한 정보를 더 풍부하게 제공하여 타입 추론에 도움이 되도록 하기 위한 것입니다.
    * `Array`는 원본 배열과 동일한 내용을 담은 `java.sql.ResultSet`을 반환하는 `getResultSet()` 메서드를 구현합니다.
    * 컬렉션 타입을 `java.lang.String`으로 읽는 것은 데이터를 올바르게 표현하는 방식이 아니므로 이렇게 읽어서는 안 됩니다(예: 배열에서는 문자열 값에 따옴표가 붙지 않습니다).
    * `Map`은 값을 `getObject(columnIndex, Class<T>)` 메서드로만 읽을 수 있으므로 `JAVA_OBJECT`에 매핑됩니다.
      * `Map`은 이름이 붙은 컬럼이 없으므로 `java.sql.Struct`가 아닙니다.
    * `Tuple`은 서로 다른 타입을 포함할 수 있기 때문에 `Object[]`에 매핑되며, `List`를 사용하는 것은 유효하지 않습니다.
    * `Tuple`은 `getObject(columnIndex, Array.class)` 메서드를 사용해 `Array`로 읽을 수 있습니다. 이때 `Array#baseTypeName`은 `Tuple` 컬럼 정의를 반환합니다.

    **배열 쓰기**

    `java.sql.Connection#createArrayOf`를 사용하여 `java.sql.Array` 객체를 생성합니다. 이 객체는 서로 다른 데이터베이스에서 배열 처리를 통일되게 하기 위해 설계되었습니다.
    Array 팩토리 메서드에 구성을 전달하려면 Connection이 필요합니다.

    이 메서드는 두 개의 인수를 받습니다:

    * `typeName` - 배열 요소의 타입 이름을 나타냅니다. 예를 들어 `Array(Int32)` -&gt; `"Int32"`입니다.
    * `elements` - 실제 배열 요소입니다. 예: `[[1, 2, 3], [4, 5, 6]]` -&gt; `new Integer[][] {{1, 2, 3}, {4, 5, 6}}`.

    Tuple은 `Object[]` 또는 `java.sql.Struct`로 표현할 수 있습니다 (튜플 작성 방법은 아래를 참조하세요).

    **예제**

    ```java
    try (Connection conn = ...) {
        Array array = conn.createArrayOf("Int32", new Integer[][] {{1, 2, 3}, {4, 5, 6}});
        try (PreparedStatement ps = conn.prepareStatement("INSERT INTO mytable (arr) VALUES (?)")) {
            ps.setArray(1, array);
            ps.executeUpdate();
        }
    }
    ```

    **배열 읽기**

    `Array` 객체를 읽으려면 `ResultSet#getArray(columnIndex)`를 사용합니다. 이 객체는 중첩 깊이에 관계없이 배열에 접근하는 데 사용할 수 있습니다.
    `Array#getResultSet()` 메서드는 배열 요소를 `java.sql.ResultSet`과 유사한 보다 일관된 방식으로 읽을 때 사용할 수 있습니다. 배열 요소의 정확한 타입을 알지 못할 때 유용합니다.

    **예제**

    ```java
    try (Connection conn = ...) {
        try (PreparedStatement ps = conn.prepareStatement("SELECT ?::Array(Int32)")) {
            ps.setArray(1, array);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    Array array = rs.getArray(1);

                    Object[] arr = (Object[]) array;
                    Arrays.stream(arr).forEach(this::handleArrayElement);

                    // or by using `ResultSet`
                    ResultSet resultSet = array.getResultSet();
                    while (resultSet.next()) {
                        // ...
                    }
                }
            }
        } 
    }
    ```

    **튜플 쓰기**

    튜플은 `com.clickhouse.data.Tuple` 객체에 매핑되며, `setObject(columnIndex, tuple)` 메서드를 호출하여 이 객체로 작성해야 합니다.
    더 나은 이식성을 위해 `java.sql.Struct` 객체를 사용하여 튜플을 작성할 수도 있습니다.

    **예제**

    ```java
    try (Connection conn = ...) {
        Tuple tuple = new Tuple(1, "test", LocalDate.parse("2026-03-02"));
        try (PreparedStatement ps = conn.prepareStatement("INSERT INTO mytable (tuple) VALUES (?)")) {
            ps.setObject(1, tuple);
            ps.executeUpdate();
        }
    }

    try (Connection conn = ...) {
        Struct struct = conn.createStruct("Tuple(Int32, String, Date)", new Object[] {1, "test", LocalDate.parse("2026-03-02")});
        try (PreparedStatement ps = conn.prepareStatement("INSERT INTO mytable (tuple) VALUES (?)")) {
            ps.setStruct(1, struct);
            ps.executeUpdate();
        }
    }
    ```

    **튜플 읽기**

    `getObject(columnIndex)` 메서드는 `Object[]`를 반환합니다. `Tuple`은 `getObject(columnIndex, Array.class)` 메서드를 사용하면 `java.sql.Array`로 읽을 수 있습니다.

    **예제**

    ```java
    try (Connection conn = ...) {
        try (PreparedStatement stmt = conn.prepareStatement("SELECT ?::Tuple(String, Int32, Date)")) {
            Array tuple = conn.createArrayOf("Tuple(String, Int32, Date)",  new Object[]{"test", 123, LocalDate.parse("2026-03-02")});
            stmt.setObject(1, tuple);
            try (ResultSet rs = stmt.executeQuery()) {
                rs.next();
                Array dbTuple = rs.getArray(1);
                Assert.assertEquals(dbTuple, tuple);
                Object arr = rs.getObject(1);
                Assert.assertEquals(arr, tuple.getArray());
            }
        }
    }

    ```

    **맵 쓰기**

    맵은 `java.collections.Map` 객체로만 쓸 수 있습니다. 이 타입은 key-value 쌍을 필요로 하기 때문입니다(`java.sql.Struct`는 key-value 쌍을 지원하지 않습니다).

    **예제**

    ```java
    try (Connection conn = ...) {
        Map<String, Integer> map = new HashMap<>();
        map.put("key1", 1);
        map.put("key2", 2);
        try (PreparedStatement ps = conn.prepareStatement("INSERT INTO mytable (map) VALUES (?)")) {
            ps.setObject(1, map);
            ps.executeUpdate();
        }
    }
    ```

    **맵 읽기**

    맵은 `getObject(columnIndex, Map.class)` 메서드를 사용하여 `java.collections.Map` 객체로 읽을 수 있습니다.

    **예제**

    ```java
    try (Connection conn = ...) {
        try (PreparedStatement ps = conn.prepareStatement("SELECT ?::Map(String, Int32)")) {
            ps.setStruct(1, struct);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    Map<String, Integer> map = rs.getObject(1, Map.class);
                    // ...
                }
            }
        }
    }
    ```

    **중첩 데이터 쓰기**

    `java.sql.Struct` 객체를 인스턴스화하려면 `java.sql.Connection#createStruct`를 사용하십시오. 이 객체는 서로 다른 데이터베이스 간에 중첩 처리를 통합하도록 설계되었습니다.
    Struct 팩토리 메서드에 구성을 전달하려면 Connection이 필요합니다.

    이 메서드는 두 개의 인수를 받습니다:

    * `typeName` - 중첩 요소의 타입 이름입니다. 예를 들어 `Nested(Tuple(Int32, String))` -&gt; `"Nested(Tuple(Int32, String))"`입니다.
    * `elements` - 실제 중첩된 요소입니다. 예를 들어 `[1, 'test']` -&gt; `new Object[] {1, 'test'}`로 변환됩니다.

    **예제**

    ```java
    try (Connection conn = ...) {
        Struct struct = conn.createStruct("Nested(Tuple(Int32, String))", new Object[] {1, 'test'});
        try (PreparedStatement ps = conn.prepareStatement("INSERT INTO mytable (nested) VALUES (?)")) {
            ps.setStruct(1, struct);
            ps.executeUpdate();
        }
    }
    ```

    **중첩 데이터 읽기**

    `Nested` 객체를 읽기 위해서는 `ResultSet#getStruct(columnIndex, StructDescriptor)`를 사용합니다. 이 객체를 사용하면 중첩 깊이에 상관없이 임의의 깊이의 중첩 구조에 접근할 수 있습니다.
    `Struct#getResultSet()` 메서드는 `java.sql.ResultSet`과 유사하게 보다 일관된 방식으로 중첩 요소를 읽는 데 사용할 수 있습니다. 중첩 요소의 구체적인 타입을 알 수 없을 때 유용합니다.

    **예제**

    ```java
    try (Connection conn = ...) {
        try (PreparedStatement ps = conn.prepareStatement("SELECT ?::Nested(Tuple(Int32, String))")) {
            ps.setStruct(1, struct);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    Struct struct = rs.getStruct(1);
                    Object[] tuple = (Object[]) struct;
                    Arrays.stream(tuple).forEach(this::handleTupleElement);

                    // or by using `ResultSet`
                    ResultSet resultSet = struct.getResultSet();
                    while (resultSet.next()) {
                        // ...
                    }
                }
            }
        }
    }
    ```

    **지리 타입(Geo Types)**

    | ClickHouse 타입 | JDBC 타입 | Java 클래스       |
    | ------------- | ------- | -------------- |
    | Point         | OTHER   | double[]       |
    | Ring          | OTHER   | double[][]     |
    | Polygon       | OTHER   | double[][][]   |
    | MultiPolygon  | OTHER   | double[][][][] |

    **널 허용 및 LowCardinality 타입**

    * `Nullable` 및 `LowCardinality`는 다른 타입을 감싸는 특수 타입입니다.
    * `Nullable`은 `ResultSetMetaData`에서 타입 이름이 반환되는 방식에 영향을 줍니다

    **특수 유형**

    | ClickHouse 타입           | JDBC 타입  | Java 클래스              |
    | ----------------------- | -------- | --------------------- |
    | UUID                    | OTHER    | java.util.UUID        |
    | IPv4                    | OTHER    | java.net.Inet4Address |
    | IPv6                    | OTHER    | java.net.Inet6Address |
    | JSON                    | OTHER    | java.lang.String      |
    | AggregateFunction       | OTHER    | (이진 표현)               |
    | SimpleAggregateFunction | (래핑된 타입) | (래핑된 클래스)             |

    * `UUID`는 JDBC 표준 타입이 아닙니다. 그러나 JDK에는 포함됩니다. 기본적으로 `getObject()` 메서드를 호출하면 `java.util.UUID`가 반환됩니다.
    * `getObject(columnIndex, String.class)` 메서드를 사용하면 `UUID`를 `String` 형태로 읽거나 쓸 수 있습니다.
    * `IPv4`와 `IPv6`는 JDBC 표준 타입이 아닙니다. 하지만 JDK에는 포함되어 있습니다. 기본적으로 `getObject()` 메서드는 `java.net.Inet4Address`와 `java.net.Inet6Address`를 반환합니다.
    * `IPv4` 및 `IPv6`는 `getObject(columnIndex, String.class)` 메서드를 사용하여 `String`으로 읽고 쓸 수 있습니다.

    ### 날짜, 시간 및 시간대 처리하기 \{#handling-dates-times-and-timezones\}

    `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp`는 시간대(Timezone) 계산을 복잡하게 만들 수 있습니다. 물론 지원되기는 하지만,
    [java.time](https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html) 패키지 사용을 고려하십시오. `ZonedDateTime`과
    `OffsetDateTime`은 java.sql.Timestamp, java.sql.Date, java.sql.Time을 대신하기에 훌륭한 대안입니다.

    :::note[Date vs DateTime]
    `Date`는 타임존 없이 저장되며, `DateTime`은 타임존과 함께 저장됩니다. 주의하지 않으면 예상치 못한 결과가 발생할 수 있습니다.
    :::

    ## 연결 생성하기 \{#creating-connection\}

    ```java
    String url = "jdbc:ch://my-server:8123/system";

    Properties properties = new Properties();
    DataSource dataSource = new DataSource(url, properties);//DataSource or DriverManager are the main entry points
    try (Connection conn = dataSource.getConnection()) {
    ... // do something with the connection
    ```

    ## 자격 증명 및 설정 제공하기 \{#supplying-credentials-and-settings\}

    ```java showLineNumbers
    String url = "jdbc:ch://localhost:8123?jdbc_ignore_unsupported_values=true&socket_timeout=10";

    Properties info = new Properties();
    info.put("user", "default");
    info.put("password", "password");
    info.put("database", "some_db");

    //Creating a connection with DataSource
    DataSource dataSource = new DataSource(url, info);
    try (Connection conn = dataSource.getConnection()) {
    ... // do something with the connection
    }

    //Alternate approach using the DriverManager
    try (Connection conn = DriverManager.getConnection(url, info)) {
    ... // do something with the connection
    }
    ```

    ## 단순 문(Simple Statement) \{#simple-statement\}

    ```java showLineNumbers

    try (Connection conn = dataSource.getConnection(...);
        Statement stmt = conn.createStatement()) {
        ResultSet rs = stmt.executeQuery("select * from numbers(50000)");
        while(rs.next()) {
            // ...
        }
    }
    ```

    ## 삽입 \{#insert\}

    ```java showLineNumbers
    try (PreparedStatement ps = conn.prepareStatement("INSERT INTO mytable VALUES (?, ?)")) {
        ps.setString(1, "test"); // id
        ps.setObject(2, LocalDateTime.now()); // timestamp
        ps.addBatch();
        ...
        ps.executeBatch(); // stream everything on-hand into ClickHouse
    }
    ```

    ## `HikariCP` \{#hikaricp\}

    ```java showLineNumbers
    // connection pooling won't help much in terms of performance,
    // because the underlying implementation has its own pool.
    // for example: HttpURLConnection has a pool for sockets
    HikariConfig poolConfig = new HikariConfig();
    poolConfig.setConnectionTimeout(5000L);
    poolConfig.setMaximumPoolSize(20);
    poolConfig.setMaxLifetime(300_000L);
    poolConfig.setDataSource(new ClickHouseDataSource(url, properties));

    try (HikariDataSource ds = new HikariDataSource(poolConfig);
         Connection conn = ds.getConnection();
         Statement s = conn.createStatement();
         ResultSet rs = s.executeQuery("SELECT * FROM system.numbers LIMIT 3")) {
        while (rs.next()) {
            // handle row
            log.info("Integer: {}, String: {}", rs.getInt(1), rs.getString(1));//Same column but different types
        }
    }
    ```

    ## 추가 정보 \{#more-information\}

    자세한 내용은 [GitHub 저장소](https://github.com/ClickHouse/clickhouse-java)와 [Java 클라이언트 문서](/integrations/language-clients/java/client/client.mdx)를 참조하세요.

    ## 문제 해결 \{#troubleshooting\}

    ### 로깅 \{#logging\}

    드라이버는 로깅을 위해 [slf4j](https://www.slf4j.org/)를 사용하며, `classpath`에서 사용 가능한 첫 번째 구현체를 사용합니다.

    ### 대용량 삽입 시 JDBC 타임아웃 해결하기 \{#resolving-jdbc-timeout-on-large-inserts\}

    ClickHouse에서 실행 시간이 긴 대용량 삽입 작업을 수행하는 경우 다음과 같은 JDBC 타임아웃 오류가 발생할 수 있습니다:

    ```plaintext
    Caused by: java.sql.SQLException: Read timed out, server myHostname [uri=https://hostname.aws.clickhouse.cloud:8443]
    ```

    이러한 오류는 데이터 삽입 프로세스를 중단시키고 시스템 안정성에 영향을 줄 수 있습니다. 이 문제를 해결하려면 클라이언트 OS의 타임아웃 설정을 조정해야 할 수 있습니다.

    #### Mac OS \{#mac-os\}

    Mac OS에서 다음 설정을 조정하여 문제를 해결할 수 있습니다:

    * `net.inet.tcp.keepidle`: 60000
    * `net.inet.tcp.keepintvl`: 45000
    * `net.inet.tcp.keepinit`: 45000
    * `net.inet.tcp.keepcnt`: 8
    * `net.inet.tcp.always_keepalive`: 1

    #### Linux \{#linux\}

    Linux에서는 동일한 설정만으로는 문제가 해결되지 않을 수 있습니다. Linux가 소켓 keep-alive 설정을 처리하는 방식의 차이로 인해 추가 단계가 필요합니다. 다음 단계를 수행하세요:

    1. `/etc/sysctl.conf` 또는 관련 구성 파일에서 다음 Linux 커널 매개변수를 조정하십시오:

    * `net.inet.tcp.keepidle`: 60000
    * `net.inet.tcp.keepintvl`: 45000
    * `net.inet.tcp.keepinit`: 45000
    * `net.inet.tcp.keepcnt`: 8
    * `net.inet.tcp.always_keepalive`: 1
    * `net.ipv4.tcp_keepalive_intvl`: 75
    * `net.ipv4.tcp_keepalive_probes`: 9
    * `net.ipv4.tcp_keepalive_time`: 60 (기본값(300초)보다 더 낮은 값으로 설정하는 것을 고려해 볼 수 있습니다)

    2. 커널 매개변수를 수정한 후 다음 명령어를 실행하여 변경 내용을 적용하십시오:

    ```shell
    sudo sysctl -p
    ```

    해당 설정을 완료한 후, 클라이언트가 소켓에서 Keep Alive 옵션을 활성화하는지 확인하십시오:

    ```java
    properties.setProperty("socket_keepalive", "true");
    ```

    ## 마이그레이션 가이드 \{#migration-guide\}

    ### 주요 변경 사항 \{#key-changes\}

    | 기능                                | V1 (기존)    | V2 (새 버전)                 |
    | --------------------------------- | ---------- | ------------------------- |
    | 트랜잭션 지원                           | 부분적으로만 지원됨 | 지원되지 않음                   |
    | 응답 컬럼 이름 변경                       | 부분적으로만 지원됨 | 지원되지 않음                   |
    | 다중 문장 SQL(Multi-Statement SQL)    | 지원되지 않음    | 허용되지 않음                   |
    | 명명된 매개변수                          | 지원됨        | 지원되지 않음(JDBC 사양에 정의되지 않음) |
    | `PreparedStatement`를 사용한 데이터 스트리밍 | 지원됨        | 지원되지 않음                   |

    * JDBC V2는 더 경량화되어 구현되었으며, 이 과정에서 일부 기능이 제거되었습니다.
      * 스트리밍 데이터는 JDBC 사양과 Java 표준의 일부가 아니므로 JDBC V2에서는 지원되지 않습니다.
    * JDBC V2는 명시적인 구성이 필요합니다. 기본 장애 조치(failover) 설정은 제공되지 않습니다.
      * URL에 프로토콜을 명시해야 합니다. 포트 번호를 기반으로 한 암시적 프로토콜 감지는 허용되지 않습니다.

    ### 구성 변경 사항 \{#configuration-changes\}

    열거형(enum)은 두 가지만 존재합니다:

    * `com.clickhouse.jdbc.DriverProperties` - 드라이버 자체의 구성 속성입니다.
    * `com.clickhouse.client.api.ClientConfigProperties` - 클라이언트 구성 속성을 나타냅니다. 클라이언트 구성
      변경 사항은 [Java 클라이언트 문서](/integrations/language-clients/java/client/client.mdx#migration_from_v1_config)에 설명되어 있습니다.

    연결 속성은 다음과 같이 파싱됩니다:

    * URL에서 속성을 먼저 파싱합니다. 이렇게 URL에서 추출된 속성은 다른 모든 속성보다 우선합니다.
    * 드라이버 속성은 클라이언트로 전달되지 않습니다.
    * 엔드포인트(호스트, 포트, 프로토콜)는 URL에서 추출됩니다.

    Example:

    ```java
    String url = "jdbc:ch://my-server:8443/default?" +
                "jdbc_ignore_unsupported_values=true&" +
                "socket_rcvbuf=800000";

    Properties properties = new Properties();
    properties.setProperty("socket_rcvbuf", "900000");
    try (Connection conn = DriverManager.getConnection(url, properties)) {
        // Connection will use socket_rcvbuf=800000 and jdbc_ignore_unsupported_values=true
        // Endpoints: my-server:8443 protocol: http (not secure)
        // Database: default
    }
    ```

    ### 데이터 유형 변경 \{#data-types-changes\}

    **숫자형 타입(Numeric Types)**

    | ClickHouse 타입 | V1과의 호환성 | JDBC 타입(V2) | Java 클래스(V2)         | JDBC 타입(V1) | Java 클래스(V1)                              |
    | ------------- | -------- | ----------- | -------------------- | ----------- | ----------------------------------------- |
    | Int8          | ✅        | TINYINT     | java.lang.Byte       | TINYINT     | java.lang.Byte                            |
    | Int16         | ✅        | SMALLINT    | java.lang.Short      | SMALLINT    | java.lang.Short                           |
    | Int32         | ✅        | INTEGER     | java.lang.Integer    | INTEGER     | java.lang.Integer                         |
    | Int64         | ✅        | BIGINT      | java.lang.Long       | BIGINT      | java.lang.Long                            |
    | Int128        | ✅        | OTHER       | java.math.BigInteger | OTHER       | java.math.BigInteger                      |
    | Int256        | ✅        | OTHER       | java.math.BigInteger | OTHER       | java.math.BigInteger                      |
    | UInt8         | ❌        | OTHER       | java.lang.Short      | OTHER       | com.clickhouse.data.value.UnsignedByte    |
    | UInt16        | ❌        | OTHER       | java.lang.Integer    | OTHER       | com.clickhouse.data.value.UnsignedShort   |
    | UInt32        | ❌        | OTHER       | java.lang.Long       | OTHER       | com.clickhouse.data.value.UnsignedInteger |
    | UInt64        | ❌        | OTHER       | java.math.BigInteger | OTHER       | com.clickhouse.data.value.UnsignedLong    |
    | UInt128       | ✅        | OTHER       | java.math.BigInteger | OTHER       | java.math.BigInteger                      |
    | UInt256       | ✅        | OTHER       | java.math.BigInteger | OTHER       | java.math.BigInteger                      |
    | Float32       | ✅        | REAL        | java.lang.Float      | REAL        | java.lang.Float                           |
    | Float64       | ✅        | DOUBLE      | java.lang.Double     | DOUBLE      | java.lang.Double                          |
    | Decimal32     | ✅        | DECIMAL     | java.math.BigDecimal | DECIMAL     | java.math.BigDecimal                      |
    | Decimal64     | ✅        | DECIMAL     | java.math.BigDecimal | DECIMAL     | java.math.BigDecimal                      |
    | Decimal128    | ✅        | DECIMAL     | java.math.BigDecimal | DECIMAL     | java.math.BigDecimal                      |
    | Decimal256    | ✅        | DECIMAL     | java.math.BigDecimal | DECIMAL     | java.math.BigDecimal                      |
    | Bool          | ✅        | BOOLEAN     | java.lang.Boolean    | BOOLEAN     | java.lang.Boolean                         |

    * 가장 큰 차이점은 더 나은 이식성을 위해 부호 없는 타입이 Java 타입으로 매핑된다는 점입니다.

    **문자열 타입(String Types)**

    | ClickHouse 타입 | V1과의 호환성 | JDBC 타입(V2) | Java 클래스(V2)     | JDBC 타입(V1) | Java 클래스(V1)     |
    | ------------- | -------- | ----------- | ---------------- | ----------- | ---------------- |
    | String        | ✅        | VARCHAR     | java.lang.String | VARCHAR     | java.lang.String |
    | FixedString   | ✅        | VARCHAR     | java.lang.String | VARCHAR     | java.lang.String |

    * `FixedString`은 두 버전 모두에서 값이 있는 그대로 읽힙니다. 예를 들어 `FixedString(10)` 컬럼에 `'John'`이 저장된 경우 `'John\0\0\0\0\0\0\0\0\0'`으로 읽힙니다.
    * `PreparedStatement#setBytes`를 사용하면 값이 `unhex('<hex_string>')`로 변환된 다음 `String`으로 읽힙니다.
    * 문자열은 UTF-8로 인코딩되어 저장됩니다.

    **날짜/시간 타입(Date/Time Types)**

    | ClickHouse 타입 | V1과의 호환 여부 | JDBC 타입 (V2) | Java 클래스 (V2)      | JDBC 타입 (V1)   | Java 클래스 (V1)            |
    | ------------- | ---------- | ------------ | ------------------ | -------------- | ------------------------ |
    | Date          | ❌          | DATE         | java.sql.Date      | DATE           | java.time.LocalDate      |
    | Date32        | ❌          | DATE         | java.sql.Date      | DATE           | java.time.LocalDate      |
    | DateTime      | ❌          | TIMESTAMP    | java.sql.Timestamp | TIMESTAMP      | java.time.OffsetDateTime |
    | DateTime64    | ❌          | TIMESTAMP    | java.sql.Timestamp | TIMESTAMP      | java.time.OffsetDateTime |
    | Time          | ✅          | TIME         | java.sql.Time      | 새 타입 / 지원되지 않음 | 새 타입 / 지원되지 않음           |
    | Time64        | ✅          | TIME         | java.sql.Time      | 새 타입 / 지원되지 않음 | 새 타입 / 지원되지 않음           |

    * `Time` 및 `Time64`는 V2에서 새 데이터 타입으로만 지원됩니다.
    * `DateTime` 및 `DateTime64`는 JDBC와의 호환성을 높이기 위해 `java.sql.Timestamp`에 매핑됩니다.

    **Enum 유형**

    | ClickHouse 타입 | V1과의 호환성 | JDBC 타입(V2) | Java 클래스(V2)     | JDBC 타입(V1) | Java 클래스(V1)     |
    | ------------- | -------- | ----------- | ---------------- | ----------- | ---------------- |
    | Enum          | ✅        | VARCHAR     | java.lang.String | OTHER       | java.lang.String |
    | Enum8         | ✅        | VARCHAR     | java.lang.String | OTHER       | java.lang.String |
    | Enum16        | ✅        | VARCHAR     | java.lang.String | OTHER       | java.lang.String |

    **중첩 타입(Nested Types)**

    | ClickHouse 타입 | V1과의 호환성 | JDBC 타입(V2)     | Java 클래스(V2)   | JDBC 타입(V1) | Java 클래스(V1)         |
    | ------------- | -------- | --------------- | -------------- | ----------- | -------------------- |
    | 배열            | ❌        | ARRAY           | java.sql.Array | ARRAY       | Object[] 또는 기본 타입 배열 |
    | 튜플            | ❌        | OTHER           | Object[]       | STRUCT      | java.sql.Struct      |
    | 맵             | ❌        | JAVA&#95;OBJECT | java.util.Map  | STRUCT      | java.util.Map        |
    | Nested        | ❌        | ARRAY           | java.sql.Array | STRUCT      | java.sql.Struct      |

    * V2에서는 JDBC와의 호환성을 위해 `Array`가 기본적으로 `java.sql.Array`에 매핑됩니다. 또한 이는 반환된 배열 값에 대한 정보를 더 풍부하게 제공하여 타입 추론에 도움이 됩니다.
    * V2에서는 `Array`가 `getResultSet()` 메서드를 구현하여 원래 배열과 동일한 내용을 담은 `java.sql.ResultSet`을 반환합니다.
    * V1은 `Map`에 `STRUCT`를 사용하지만 항상 `java.util.Map` 타입의 객체를 반환합니다. V2에서는 `Map`을 `JAVA_OBJECT`로 매핑하여 이 문제를 해결합니다.
    * V1은 `Tuple`에 대해 `STRUCT`를 사용하지만 항상 `List<Object>` 객체를 반환합니다. V2는 `Tuple`을 `OTHER`에 매핑하여 기본적으로 `Object[]`를 반환합니다.
    * V2에서는 튜플을 작성하기 위해 `com.clickhouse.data.Tuple#Tuple`을 도입합니다. 이를 통해 값이 튜플인지 배열인지 여부를 더 쉽게 판별할 수 있습니다.
    * `PreparedStatement#setBytes` 및 `ResultSet#getBytes`는 컬렉션 타입에는 사용할 수 없습니다. 이 메서드들은 바이너리 문자열을 처리하도록 설계된 메서드입니다.
    * 일반적으로 Array 타입을 쓰고 읽을 때는 `java.sql.Array`를 사용합니다. JDBC 드라이버에서 이를 완전히 지원합니다.
    * V2에서 `Nested`는 `Array`에 매핑되어 튜플 배열로 표현됩니다.
    * V2는 `java.sql.Struct`를 부분적으로만 지원합니다. `java.sql.Struct`는 Array 타입과 매우 유사하고 key-value 쌍을 지원하지 않기 때문입니다. `Struct`는 `Tuple` 값을 쓰는 데 사용할 수 있습니다.

    **지리 타입(Geo Types)**

    | ClickHouse 타입 | V1과 호환 | JDBC 타입(V2) | Java 클래스(V2)   | JDBC 타입(V1) | Java 클래스(V1)   |
    | ------------- | ------ | ----------- | -------------- | ----------- | -------------- |
    | Point         | ✅      | OTHER       | double[]       | OTHER       | double[]       |
    | Ring          | ✅      | OTHER       | double[][]     | OTHER       | double[][]     |
    | Polygon       | ✅      | OTHER       | double[][][]   | OTHER       | double[][][]   |
    | MultiPolygon  | ✅      | OTHER       | double[][][][] | OTHER       | double[][][][] |

    **널 허용 및 LowCardinality 타입**

    * `Nullable` 및 `LowCardinality`는 다른 데이터 타입을 감싸는 특수한 데이터 타입입니다.
    * V2에서는 이러한 타입이 변경되지 않았습니다.

    **특수 유형**

    | ClickHouse 타입           | V1과 호환됨 | JDBC 타입 (V2) | Java 클래스 (V2)         | JDBC 타입 (V1) | Java 클래스 (V1)         |
    | ----------------------- | ------- | ------------ | --------------------- | ------------ | --------------------- |
    | JSON                    | ❌       | OTHER        | java.lang.String      | 지원되지 않음      | 지원되지 않음               |
    | AggregateFunction       | ✅       | OTHER        | (이진 표현)               | OTHER        | (이진 표현)               |
    | SimpleAggregateFunction | ✅       | (래핑된 타입)     | (래핑된 클래스)             | (래핑된 타입)     | (래핑된 클래스)             |
    | UUID                    | ✅       | OTHER        | java.util.UUID        | VARCHAR      | java.util.UUID        |
    | IPv4                    | ✅       | OTHER        | java.net.Inet4Address | VARCHAR      | java.net.Inet4Address |
    | IPv6                    | ✅       | OTHER        | java.net.Inet6Address | VARCHAR      | java.net.Inet6Address |
    | Dynamic                 | ❌       | OTHER        | java.Object           | 지원되지 않음      | 지원되지 않음               |
    | Variant                 | ❌       | OTHER        | java.Object           | 지원되지 않음      | 지원되지 않음               |

    * V1은 `UUID`에 `VARCHAR`를 사용하지만, 항상 `java.util.UUID` 객체를 반환합니다. V2에서는 `UUID`를 `OTHER`로 매핑하여 이 문제를 해결하고 `java.util.UUID` 객체를 반환합니다.
    * V1은 `IPv4` 및 `IPv6`에 `VARCHAR`를 사용하지만, 항상 `java.net.Inet4Address` 및 `java.net.Inet6Address` 객체를 반환합니다. V2에서는 이를 수정하여 `IPv4` 및 `IPv6`를 `OTHER`로 매핑하고 `java.net.Inet4Address` 및 `java.net.Inet6Address` 객체를 반환합니다.
    * `Dynamic`과 `Variant`는 V2에서 새로 추가된 타입입니다. V1에서는 지원되지 않습니다.
    * `JSON`은 `Dynamic` 타입을 기반으로 합니다. 따라서 V2에서만 지원됩니다.
    * IPv4 및 IPv6 값은 `getBytes(columnIndex)` 메서드를 사용하여 `byte[]`로 읽을 수 있습니다. 하지만 이러한 타입에 대해서는 전용 클래스를 사용하는 것이 권장됩니다.
    * V2에서는 IP 주소를 숫자 값으로 읽는 기능을 지원하지 않습니다. IP 주소를 숫자 값으로 변환하는 작업은 InetAddress 클래스에서 처리하는 편이 더 바람직하기 때문입니다.

    ### 데이터베이스 메타데이터 변경 사항 \{#database-metadata-changes\}

    * V2에서는 데이터베이스 이름을 지정할 때 `Schema`라는 용어만 사용합니다. `Catalog`라는 용어는 향후 사용을 위해 예약되어 있습니다.
    * V2는 `DatabaseMetaData.supportsTransactions()` 및 `DatabaseMetaData.supportsSavepoints()`에 대해 `false`를 반환합니다. 이는 향후 개발에서 변경될 예정입니다.
  </Version>

  <Version>
    `clickhouse-jdbc`는 표준 JDBC 인터페이스를 구현합니다. [clickhouse-client](/integrations/sql-clients/sql-console) 기반으로 구축되어 사용자 정의 타입 매핑, 트랜잭션 지원, 표준 동기식 `UPDATE` 및 `DELETE` SQL 문 등의 추가 기능을 제공하므로 레거시 애플리케이션 및 도구에서 쉽게 사용할 수 있습니다.

    :::note
    최신 JDBC(0.7.2) 버전은 Client-V1을 사용합니다
    :::

    `clickhouse-jdbc` API는 동기식이며, 일반적으로 더 많은 오버헤드(예: SQL 파싱 및 타입 매핑/변환 등)가 발생합니다. 성능이 중요하거나 ClickHouse에 보다 직접적으로 접근하려는 경우 [clickhouse-client](/integrations/sql-clients/sql-console)를 고려하세요.

    ## 환경 요구 사항 \{#v07-environment-requirements\}

    * [OpenJDK](https://openjdk.java.net) 버전 8 이상

    ### 설정 \{#v07-setup\}

    <Tabs groupId="client-v1-compression-deps">
      <TabItem value="maven" label="Maven">
        ```xml
        <!-- https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc -->
        <dependency>
            <groupId>com.clickhouse</groupId>
            <artifactId>clickhouse-jdbc</artifactId>
            <version>0.7.2</version>
            <!-- 모든 의존성이 포함된 uber JAR를 사용하되, 더 작은 JAR가 필요하면 classifier를 http로 변경하십시오 -->
            <classifier>shaded-all</classifier>
        </dependency>
        ```
      </TabItem>

      <TabItem value="gradle-kt" label="Gradle (Kotlin)">
        ```kotlin
        // https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc
        // 모든 의존성이 포함된 uber JAR를 사용하되, 더 작은 JAR가 필요하면 classifier를 http로 변경하십시오
        implementation("com.clickhouse:clickhouse-jdbc:0.7.2:shaded-all")
        ```
      </TabItem>

      <TabItem value="gradle" label="Gradle">
        ```groovy
        // https://mvnrepository.com/artifact/com.clickhouse/clickhouse-jdbc
        // 모든 의존성이 포함된 uber JAR를 사용하되, 더 작은 JAR가 필요하면 classifier를 http로 변경하십시오
        implementation 'com.clickhouse:clickhouse-jdbc:0.7.2:shaded-all'
        ```
      </TabItem>
    </Tabs>

    버전 `0.5.0`부터 클라이언트에 포함된 Apache HTTP Client를 사용합니다. 패키지의 공유 버전이 없기 때문에 로거를 의존성으로 추가해야 합니다.

    <Tabs groupId="client-v1-compression-deps">
      <TabItem value="maven" label="Maven">
        ```xml
        <!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.16</version>
        </dependency>
        ```
      </TabItem>

      <TabItem value="gradle-kt" label="Gradle (Kotlin)">
        ```kotlin
        // https://mvnrepository.com/artifact/org.slf4j/slf4j-api
        implementation("org.slf4j:slf4j-api:2.0.16")
        ```
      </TabItem>

      <TabItem value="gradle" label="Gradle">
        ```groovy
        // https://mvnrepository.com/artifact/org.slf4j/slf4j-api
        implementation 'org.slf4j:slf4j-api:2.0.16'
        ```
      </TabItem>
    </Tabs>

    ## 구성 \{#v07-configuration\}

    **드라이버 클래스**: `com.clickhouse.jdbc.ClickHouseDriver`

    **URL 구문**: `jdbc:(ch|clickhouse)[:<protocol>]://endpoint1[,endpoint2,...][/<database>][?param1=value1&param2=value2][#tag1,tag2,...]`, 예를 들면:

    * `jdbc:ch://localhost`는 `jdbc:clickhouse:http://localhost:8123`와 같습니다.
    * `jdbc:ch:https://localhost`는 `jdbc:clickhouse:http://localhost:8443?ssl=true&sslmode=STRICT`과 동일합니다.
    * `jdbc:ch:grpc://localhost`는 `jdbc:clickhouse:grpc://localhost:9100`와 동일합니다.

    **연결 속성(Connection Properties)**:

    | 속성                         | 기본값     | 설명                                                                                                                                                                                                                                                                                                                                                                                                |
    | -------------------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `continueBatchOnError`     | `false` | 오류 발생 시 배치 처리를 계속할지 여부                                                                                                                                                                                                                                                                                                                                                                            |
    | `createDatabaseIfNotExist` | `false` | 데이터베이스가 존재하지 않으면 생성할지 여부                                                                                                                                                                                                                                                                                                                                                                          |
    | `custom_http_headers`      |         | 쉼표로 구분된 사용자 정의 HTTP 헤더. 예: `User-Agent=client1,X-Gateway-Id=123`                                                                                                                                                                                                                                                                                                                                  |
    | `custom_http_params`       |         | 쉼표로 구분된 사용자 정의 HTTP 쿼리 매개변수입니다. 예: `extremes=0,max_result_rows=100`                                                                                                                                                                                                                                                                                                                               |
    | `nullAsDefault`            | `0`     | `0` - null 값을 있는 그대로 처리하며, null을 널을 허용하지 않는 컬럼에 삽입할 경우 예외를 발생시킵니다; `1` - null 값을 있는 그대로 처리하고 삽입 시 null 체크를 비활성화합니다; `2` - 쿼리와 삽입 모두에서 null을 해당 데이터 타입의 기본값으로 대체합니다                                                                                                                                                                                                                                |
    | `jdbcCompliance`           | `true`  | 표준 동기식 UPDATE/DELETE SQL 문과 가상 트랜잭션(fake transaction)을 지원할지 여부                                                                                                                                                                                                                                                                                                                                    |
    | `typeMappings`             |         | ClickHouse 데이터 타입과 Java 클래스 간의 매핑을 사용자 지정할 수 있으며, 이는 [`getColumnType()`](https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSetMetaData.html#getColumnType-int-) 및 [`getObject(Class<>?>`)](https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html#getObject-java.lang.String-java.lang.Class-) 두 메서드의 반환 결과에 모두 영향을 줍니다. 예: `UInt128=java.lang.String,UInt256=java.lang.String` |
    | `wrapperObject`            | `false` | [`getObject()`](https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html#getObject-int-)가 Array / Tuple에 대해 java.sql.Array / java.sql.Struct를 반환하도록 할지 여부.                                                                                                                                                                                                                               |

    참고: 자세한 내용은 [JDBC 관련 설정](https://github.com/ClickHouse/clickhouse-java/blob/main/clickhouse-jdbc/src/main/java/com/clickhouse/jdbc/JdbcConfig.java)을 참조하세요.

    ## 지원되는 데이터 유형 \{#v07-supported-data-types\}

    JDBC 드라이버는 클라이언트 라이브러리가 지원하는 것과 동일한 데이터 형식을 지원합니다.

    :::note

    * AggregatedFunction - :warning: `SELECT * FROM table ...` 구문을 지원하지 않습니다
    * Decimal - 일관성을 위해 21.9+ 버전에서 `SET output_format_decimal_trailing_zeros=1`을(를) 설정합니다
    * Enum - 문자열과 정수형 둘 다로 취급될 수 있습니다
    * UInt64 - client-v1에서는 `long`으로 매핑됩니다
      :::

    ## 연결 생성하기 \{#v07-creating-connection\}

    ```java
    String url = "jdbc:ch://my-server/system"; // use http protocol and port 8123 by default

    Properties properties = new Properties();

    ClickHouseDataSource dataSource = new ClickHouseDataSource(url, properties);
    try (Connection conn = dataSource.getConnection("default", "password");
        Statement stmt = conn.createStatement()) {
    }
    ```

    ## 단순 문(Simple Statement) \{#v07-simple-statement\}

    ```java showLineNumbers

    try (Connection conn = dataSource.getConnection(...);
        Statement stmt = conn.createStatement()) {
        ResultSet rs = stmt.executeQuery("select * from numbers(50000)");
        while(rs.next()) {
            // ...
        }
    }
    ```

    ## 삽입 \{#v07-insert\}

    :::note

    * `Statement` 대신 `PreparedStatement`를 사용하십시오
      :::

    사용하기는 더 쉽지만 input 함수(아래 참조)보다 성능이 느립니다:

    ```java showLineNumbers
    try (PreparedStatement ps = conn.prepareStatement("insert into mytable(* except (description))")) {
        ps.setString(1, "test"); // id
        ps.setObject(2, LocalDateTime.now()); // timestamp
        ps.addBatch(); // parameters will be write into buffered stream immediately in binary format
        ...
        ps.executeBatch(); // stream everything on-hand into ClickHouse
    }
    ```

    ### input 테이블 함수 사용 \{#with-input-table-function\}

    우수한 성능 특성을 제공하는 옵션:

    ```java showLineNumbers
    try (PreparedStatement ps = conn.prepareStatement(
        "insert into mytable select col1, col2 from input('col1 String, col2 DateTime64(3), col3 Int32')")) {
        // The column definition will be parsed so the driver knows there are 3 parameters: col1, col2 and col3
        ps.setString(1, "test"); // col1
        ps.setObject(2, LocalDateTime.now()); // col2, setTimestamp is slow and not recommended
        ps.setInt(3, 123); // col3
        ps.addBatch(); // parameters will be write into buffered stream immediately in binary format
        ...
        ps.executeBatch(); // stream everything on-hand into ClickHouse
    }
    ```

    * [input 함수 문서](/sql-reference/table-functions/input/)를 가능한 한 참고하십시오

    ### 플레이스홀더를 사용한 삽입 \{#insert-with-placeholders\}

    이 옵션은 소규모 삽입 작업에만 권장됩니다. 긴 SQL 표현식이 필요하고, 클라이언트 측에서 파싱되어 CPU 및 메모리를 소비하기 때문입니다:

    ```java showLineNumbers
    try (PreparedStatement ps = conn.prepareStatement("insert into mytable values(trim(?),?,?)")) {
        ps.setString(1, "test"); // id
        ps.setObject(2, LocalDateTime.now()); // timestamp
        ps.setString(3, null); // description
        ps.addBatch(); // append parameters to the query
        ...
        ps.executeBatch(); // issue the composed query: insert into mytable values(...)(...)...(...)
    }
    ```

    ## DateTime 및 시간대 처리 \{#handling-datetime-and-time-zones\}

    `java.sql.Timestamp` 대신 `java.time.LocalDateTime` 또는 `java.time.OffsetDateTime`을 사용하고, `java.sql.Date` 대신 `java.time.LocalDate`를 사용하세요.

    ```java showLineNumbers
    try (PreparedStatement ps = conn.prepareStatement("select date_time from mytable where date_time > ?")) {
        ps.setObject(2, LocalDateTime.now());
        ResultSet rs = ps.executeQuery();
        while(rs.next()) {
            LocalDateTime dateTime = (LocalDateTime) rs.getObject(1);
        }
        ...
    }
    ```

    ## `AggregateFunction` 처리 \{#handling-aggregatefunction\}

    :::note
    현재 `groupBitmap`만 지원됩니다.
    :::

    ```java showLineNumbers
    // batch insert using input function
    try (ClickHouseConnection conn = newConnection(props);
            Statement s = conn.createStatement();
            PreparedStatement stmt = conn.prepareStatement(
                    "insert into test_batch_input select id, name, value from input('id Int32, name Nullable(String), desc Nullable(String), value AggregateFunction(groupBitmap, UInt32)')")) {
        s.execute("drop table if exists test_batch_input;"
                + "create table test_batch_input(id Int32, name Nullable(String), value AggregateFunction(groupBitmap, UInt32))engine=Memory");
        Object[][] objs = new Object[][] {
                new Object[] { 1, "a", "aaaaa", ClickHouseBitmap.wrap(1, 2, 3, 4, 5) },
                new Object[] { 2, "b", null, ClickHouseBitmap.wrap(6, 7, 8, 9, 10) },
                new Object[] { 3, null, "33333", ClickHouseBitmap.wrap(11, 12, 13) }
        };
        for (Object[] v : objs) {
            stmt.setInt(1, (int) v[0]);
            stmt.setString(2, (String) v[1]);
            stmt.setString(3, (String) v[2]);
            stmt.setObject(4, v[3]);
            stmt.addBatch();
        }
        int[] results = stmt.executeBatch();
        ...
    }

    // use bitmap as query parameter
    try (PreparedStatement stmt = conn.prepareStatement(
        "SELECT bitmapContains(my_bitmap, toUInt32(1)) as v1, bitmapContains(my_bitmap, toUInt32(2)) as v2 from {tt 'ext_table'}")) {
        stmt.setObject(1, ClickHouseExternalTable.builder().name("ext_table")
                .columns("my_bitmap AggregateFunction(groupBitmap,UInt32)").format(ClickHouseFormat.RowBinary)
                .content(new ByteArrayInputStream(ClickHouseBitmap.wrap(1, 3, 5).toBytes()))
                .asTempTable()
                .build());
        ResultSet rs = stmt.executeQuery();
        Assert.assertTrue(rs.next());
        Assert.assertEquals(rs.getInt(1), 1);
        Assert.assertEquals(rs.getInt(2), 0);
        Assert.assertFalse(rs.next());
    }
    ```

    <br />

    ## HTTP 라이브러리 구성하기 \{#v07-configuring-http-library\}

    ClickHouse JDBC 커넥터는 세 가지 HTTP 라이브러리를 지원합니다: [`HttpClient`](https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html), [`HttpURLConnection`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/HttpURLConnection.html), 그리고 [Apache `HttpClient`](https://hc.apache.org/httpcomponents-client-5.2.x/).

    :::note
    `HttpClient`는 JDK 11 이상에서만 지원됩니다.
    :::

    JDBC 드라이버는 기본적으로 `HttpClient`를 사용합니다. ClickHouse JDBC 커넥터에서 사용하는 HTTP 라이브러리를 변경하려면 다음 속성을 설정하세요:

    ```java
    properties.setProperty("http_connection_provider", "APACHE_HTTP_CLIENT");
    ```

    다음은 해당하는 값의 전체 목록입니다:

    | 속성 값                        | HTTP 라이브러리          |
    | --------------------------- | ------------------- |
    | HTTP&#95;CLIENT             | `HttpClient`        |
    | HTTP&#95;URL&#95;CONNECTION | `HttpURLConnection` |
    | APACHE&#95;HTTP&#95;CLIENT  | Apache `HttpClient` |

    <br />

    ## SSL을 사용하여 ClickHouse에 연결하기 \{#connect-to-clickhouse-with-ssl\}

    SSL을 사용하여 ClickHouse에 대한 보안 JDBC 연결을 설정하려면 JDBC 속성에 SSL 매개변수를 포함하도록 구성하십시오. 일반적으로 JDBC URL 또는 Properties 객체에 `sslmode` 및 `sslrootcert`와 같은 SSL 속성을 지정합니다.

    ## SSL 속성 \{#ssl-properties\}

    | 이름                   | 기본값    | 허용 가능한 값     | 설명                                                  |
    | -------------------- | ------ | ------------ | --------------------------------------------------- |
    | `ssl`                | false  | true, false  | 연결에 SSL/TLS를 사용할지 여부                                |
    | `sslmode`            | strict | strict, none | SSL/TLS 인증서를 검증할지 여부                                |
    | `sslrootcert`        |        |              | SSL/TLS 루트 인증서 파일 경로                                |
    | `sslcert`            |        |              | SSL/TLS 인증서 파일 경로                                   |
    | `sslkey`             |        |              | PKCS#8 형식의 RSA 개인 키                                 |
    | `key_store_type`     |        | JKS, PKCS12  | `KeyStore`/`TrustStore` 파일의 타입 또는 형식을 지정합니다.        |
    | `trust_store`        |        |              | `TrustStore` 파일 경로                                  |
    | `key_store_password` |        |              | `KeyStore` 구성에서 지정된 `KeyStore` 파일에 액세스하는 데 필요한 비밀번호 |

    이러한 속성을 사용하면 Java 애플리케이션이 암호화된 연결을 통해 ClickHouse 서버와 통신하여 전송 중 데이터 보안이 강화됩니다.

    ```java showLineNumbers
      String url = "jdbc:ch://your-server:8443/system";

      Properties properties = new Properties();
      properties.setProperty("ssl", "true");
      properties.setProperty("sslmode", "strict"); // NONE to trust all servers; STRICT for trusted only
      properties.setProperty("sslrootcert", "/mine.crt");
      try (Connection con = DriverManager
              .getConnection(url, properties)) {

          try (PreparedStatement stmt = con.prepareStatement(

              // place your code here

          }
      }
    ```

    ## 대용량 삽입 시 JDBC 타임아웃 해결하기 \{#v07-resolving-jdbc-timeout-on-large-inserts\}

    ClickHouse에서 실행 시간이 긴 대용량 삽입 작업을 수행하는 경우 다음과 같은 JDBC 타임아웃 오류가 발생할 수 있습니다:

    ```plaintext
    Caused by: java.sql.SQLException: Read timed out, server myHostname [uri=https://hostname.aws.clickhouse.cloud:8443]
    ```

    이러한 오류는 데이터 삽입 프로세스를 중단시키고 시스템 안정성에 영향을 줄 수 있습니다. 이 문제를 해결하려면 클라이언트 OS의 타임아웃 설정 몇 가지를 조정하십시오.

    ### Mac OS \{#v07-mac-os\}

    Mac OS에서 다음 설정을 조정하여 문제를 해결할 수 있습니다:

    * `net.inet.tcp.keepidle`: 60000
    * `net.inet.tcp.keepintvl`: 45000
    * `net.inet.tcp.keepinit`: 45000
    * `net.inet.tcp.keepcnt`: 8
    * `net.inet.tcp.always_keepalive`: 1

    ### Linux \{#v07-linux\}

    Linux에서는 동일한 설정만으로는 문제가 해결되지 않을 수 있습니다. Linux가 소켓 keep-alive 설정을 처리하는 방식의 차이로 인해 추가 단계가 필요합니다. 다음 단계를 수행하세요:

    1. `/etc/sysctl.conf` 또는 관련 구성 파일에서 다음 Linux 커널 매개변수를 조정하십시오:

    * `net.inet.tcp.keepidle`: 60000
    * `net.inet.tcp.keepintvl`: 45000
    * `net.inet.tcp.keepinit`: 45000
    * `net.inet.tcp.keepcnt`: 8
    * `net.inet.tcp.always_keepalive`: 1
    * `net.ipv4.tcp_keepalive_intvl`: 75
    * `net.ipv4.tcp_keepalive_probes`: 9
    * `net.ipv4.tcp_keepalive_time`: 60 (기본값(300초)보다 낮게 설정하는 것을 고려할 수 있습니다)

    2. 커널 매개변수를 수정한 후 다음 명령을 실행하여 변경 사항을 적용하십시오:

    ```shell
    sudo sysctl -p
    ```

    해당 설정을 완료한 후, 클라이언트가 소켓에서 Keep Alive 옵션을 활성화하는지 확인하십시오:

    ```java
    properties.setProperty("socket_keepalive", "true");
    ```

    :::note
    현재 소켓 keep-alive를 설정할 때는 Apache HTTP Client 라이브러리를 사용해야 합니다. `clickhouse-java`가 지원하는 다른 두 HTTP 클라이언트 라이브러리는 소켓 옵션 설정을 허용하지 않기 때문입니다. 자세한 가이드는 [HTTP 라이브러리 구성](#v07-configuring-http-library)을 참조하세요.
    :::

    또는 JDBC URL에 동일한 매개변수를 추가할 수 있습니다.

    JDBC 드라이버의 기본 소켓 및 연결 타임아웃은 30초입니다. 대용량 데이터 삽입 작업을 지원하려면 타임아웃을 늘릴 수 있습니다. `ClickHouseClientOption`에 정의된 `SOCKET_TIMEOUT` 및 `CONNECTION_TIMEOUT` 옵션과 함께 `ClickHouseClient`의 `options` 메서드를 사용하세요:

    ```java showLineNumbers
    final int MS_12H = 12 * 60 * 60 * 1000; // 12 h in ms
    final String sql = "insert into table_a (c1, c2, c3) select c1, c2, c3 from table_b;";

    try (ClickHouseClient client = ClickHouseClient.newInstance(ClickHouseProtocol.HTTP)) {
        client.read(servers).write()
            .option(ClickHouseClientOption.SOCKET_TIMEOUT, MS_12H)
            .option(ClickHouseClientOption.CONNECTION_TIMEOUT, MS_12H)
            .query(sql)
            .executeAndWait();
    }
    ```
  </Version>
</ClientVersionDropdown>
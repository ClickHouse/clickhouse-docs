---
'slug': '/best-practices/choosing-a-partitioning-key'
'sidebar_position': 10
'sidebar_label': '파티션 키 선택하기'
'title': '파티션 키 선택하기'
'description': '파티션 키를 선택하는 방법을 설명하는 페이지'
'keywords':
- 'partitioning key'
'doc_type': 'reference'
---

import Image from '@theme/IdealImage';
import partitions from '@site/static/images/bestpractices/partitions.png';
import merges_with_partitions from '@site/static/images/bestpractices/merges_with_partitions.png';


:::note A data management technique
파티셔닝은 주로 데이터 관리 기술이며 쿼리 최적화 도구가 아닙니다. 특정 작업 부하에서 성능을 향상시킬 수 있지만, 쿼리를 가속화하는 첫 번째 메커니즘으로 사용해서는 안 됩니다. 파티셔닝 키는 그 의미를 명확하게 이해한 상태에서 신중하게 선택해야 하며, 데이터 수명 주기 필요 또는 잘 이해된 접근 패턴과 일치할 때에만 적용해야 합니다.
:::

ClickHouse에서 파티셔닝은 지정된 키를 기반으로 데이터를 논리적 세그먼트로 조직합니다. 이는 테이블 생성 시 `PARTITION BY` 절을 사용하여 정의되며, 일반적으로 시간 간격, 카테고리 또는 기타 비즈니스 관련 차원에 따라 행을 그룹화하는 데 사용됩니다. 파티셔닝 표현의 각 고유 값은 디스크에 고유한 물리적 파티션을 형성하며, ClickHouse는 이러한 각 값에 대해 데이터를 별도의 파트로 저장합니다. 파티셔닝은 데이터 관리를 개선하고 보존 정책을 단순화하며 특정 쿼리 패턴에 도움이 될 수 있습니다.

예를 들어, `toStartOfMonth(date)`의 파티셔닝 키를 가진 다음과 같은 영국 지불 가격 데이터셋 테이블을 고려해 보십시오.

```sql
CREATE TABLE uk.uk_price_paid_simple_partitioned
(
  date Date,
  town LowCardinality(String),
  street LowCardinality(String),
  price UInt32
)
ENGINE = MergeTree
ORDER BY (town, street)
PARTITION BY toStartOfMonth(date)
```

테이블에 행 세트를 삽입할 때, ClickHouse는 모든 삽입된 행이 포함된 (적어도 하나의) 단일 데이터 파트를 생성하는 대신 (여기서 설명된 대로) 삽입된 행 중 고유한 각 파티션 키 값에 대해 새 데이터 파트를 생성합니다:

<Image img={partitions} size="lg" alt="Partitions" />

ClickHouse 서버는 먼저 위의 예시 삽입에서 4개의 행을 `toStartOfMonth(date)`의 파티션 키 값에 따라 분할합니다. 그런 다음 각 식별된 파티션에 대해, 행은 여러 순차적 단계를 수행하여 [일반적으로](/parts) 처리됩니다 (① 정렬, ② 컬럼으로 분할, ③ 압축, ④ 디스크에 기록).

파티셔닝에 대한 보다 자세한 설명은 [이 가이드](/partitions)를 권장합니다.

파티셔닝이 활성화되면, ClickHouse는 파티션의 내부에서만 [병합](/merges)을 수행하지만, 파티션 간의 병합은 수행하지 않습니다. 위의 예시 테이블에 대해 이를 설명합니다:

<Image img={merges_with_partitions} size="md" alt="Partitions" />

## Applications of partitioning {#applications-of-partitioning}

파티셔닝은 ClickHouse에서 대규모 데이터셋을 관리하는 강력한 도구로, 특히 관찰성과 분석 사용 사례에 유용합니다. 이는 전체 파티션을 단일 메타데이터 작업에서 삭제, 이동 또는 보관할 수 있게 하여 효율적인 데이터 수명 주기 작업을 가능하게 합니다. 이는 행 수준 삭제 또는 복사 작업보다 훨씬 빠르고 리소스 집약적이지 않습니다. 파티셔닝은 TTL 및 계층화된 스토리지와 같은 ClickHouse 기능과 원활하게 통합되어 사용자 정의 오케스트레이션 없이 보존 정책이나 핫/콜드 스토리지 전략을 구현할 수 있게 합니다. 예를 들어, 최근 데이터는 빠른 SSD 기반 스토리지에 유지되고, 오래된 파티션은 자동으로 저렴한 객체 스토리지로 이동됩니다.

파티셔닝이 일부 작업 부하에 대해 쿼리 성능을 개선할 수 있지만, 응답 시간에 부정적인 영향을 줄 수도 있습니다.

파티셔닝 키가 기본 키에 포함되어 있지 않고 필터링하고 있는 경우, 사용자들은 파티셔닝을 통해 쿼리 성능이 개선되는 것을 느낄 수 있습니다. [여기서](/partitions#query-optimization) 예제를 확인하십시오.

반대로, 쿼리가 파티션을 넘어 쿼리해야 하는 경우 총 파트 수 증가로 인해 성능이 부정적으로 영향을 받을 수 있습니다. 이러한 이유로 사용자들은 쿼리 최적화 기술로 고려하기 전에 접근 패턴을 이해해야 합니다.

요약하자면, 사용자는 파티셔닝을 주로 데이터 관리 기술로 생각해야 합니다. 데이터 관리에 대한 예시는 관찰성 사용 사례 가이드의 ["데이터 관리"](/observability/managing-data) 및 Core Concepts - 테이블 파티션의 ["테이블 파티션은 무엇을 위해 사용됩니까?"](/partitions#data-management)를 참조하십시오.

## Choose a low cardinality partitioning key {#choose-a-low-cardinality-partitioning-key}

중요하게도, 파트 수가 많아지면 쿼리 성능에 부정적인 영향을 미칠 것입니다. 따라서 ClickHouse는 [“너무 많은 파트”](/knowledgebase/exception-too-many-parts) 오류에 대해, 총 파트 수가 [총합](/operations/settings/merge-tree-settings#max_parts_in_total) 또는 [파티션당](/operations/settings/merge-tree-settings#parts_to_throw_insert) 지정된 제한을 초과할 경우 응답합니다.

파티셔닝 키에 적합한 **카디널리티**를 선택하는 것은 매우 중요합니다. 고카디널리티 파티셔닝 키 - 고유한 파티션 값의 수가 많은 경우 - 는 데이터 파트의 급증을 초래할 수 있습니다. ClickHouse는 파티션 간의 파트를 병합하지 않기 때문에, 너무 많은 파티션은 너무 많은 병합되지 않은 파트를 초래하고 결국 "너무 많은 파트" 오류를 발생시킵니다. [병합은 필수적입니다](/merges) 스토리지 단편화를 줄이고 쿼리 속도를 최적화하기 위해, 그러나 고카디널리티 파티션에서는 그 병합 가능성이 상실됩니다.

대조적으로, **저카디널리티 파티셔닝 키**—100 - 1,000개 미만의 고유 값—가 보통 최적입니다. 이는 효율적인 파트 병합을 가능하게 하고, 메타데이터 오버헤드를 낮게 유지하며, 저장소에서 과도한 객체 생성을 방지합니다. 또한 ClickHouse는 파티션 컬럼에 대해 MinMax 인덱스를 자동으로 생성하여 해당 컬럼에서 필터링할 때 쿼리 속도를 크게 향상시킬 수 있습니다. 예를 들어, 테이블이 `toStartOfMonth(date)`로 파티션되어 있을 때 월별로 필터링하면 엔진이 관련 없는 파티션과 그 파트를 완전히 건너뛸 수 있습니다.

파티셔닝이 일부 쿼리 패턴에서 성능을 향상시킬 수 있지만, 주로 데이터 관리 기능입니다. 많은 경우, 모든 파티션을 쿼리하는 것은 데이터 단편화 증가 및 스캔되는 파트 수 증가로 인해 비파티셔닝 테이블을 사용하는 것보다 느릴 수 있습니다. 파티셔닝을 신중하게 사용하고 항상 선택한 키가 저카디널리티이며 데이터 수명 주기 정책(예: TTL을 통한 보존)에 맞는지 확인하십시오. 파티셔닝이 필요한지 확실하지 않다면, 시작할 때 파티셔닝 없이 시작하고 관찰된 접근 패턴에 따라 나중에 최적화할 수 있습니다.

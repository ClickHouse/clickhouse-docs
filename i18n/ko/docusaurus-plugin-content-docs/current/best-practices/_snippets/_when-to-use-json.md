## `JSON` 타입을 사용해야 하는 경우 \{#when-to-use-json-type\}

`JSON` 타입은 동적이거나 예측하기 어려운 구조를 가진 JSON 객체 내의 특정 필드를 쿼리하고 필터링하며 집계하기 위해 설계되었습니다. 이 타입은 JSON 객체를 개별 하위 컬럼으로 분리함으로써, `Map` 또는 문자열 파싱과 같은 대안에 비해 선택된 필드에 대한 데이터 읽기량을 크게 줄이고 쿼리 속도를 높입니다.

**하지만 다음과 같은 중요한 트레이드오프가 있습니다.**

- 더 느린 `INSERT` - JSON을 하위 컬럼으로 분리하고 타입 추론을 수행하며 유연한 저장 구조를 관리해야 하므로, JSON을 단순한 `String` 컬럼으로 저장하는 경우보다 INSERT 작업이 더 느려집니다.
- 전체 객체를 읽을 때 더 느림 - 특정 필드가 아니라 완전한 JSON 문서를 조회해야 한다면, `JSON` 타입은 `String` 컬럼에서 읽는 것보다 느립니다. 개별 하위 컬럼에서 객체를 재구성하는 오버헤드는 필드 수준 쿼리를 수행하지 않을 때는 이점이 없습니다.
- 스토리지 오버헤드 - 별도의 하위 컬럼을 유지해야 하므로 JSON을 단일 문자열 값으로 저장하는 것과 비교했을 때 구조적 오버헤드가 추가됩니다.

### `JSON` 타입을 사용해야 하는 경우: \{#use-json-type\}

- 문서마다 키가 달라지는 등 데이터 구조가 동적이거나 예측하기 어려운 경우
- 필드 타입이나 스키마가 시간이 지나면서 변경되거나 레코드마다 달라지는 경우
- 사전에 구조를 예측할 수 없는 JSON 객체에서 특정 경로를 기준으로 쿼리, 필터링, 집계를 수행해야 하는 경우
- 스키마가 일관되지 않은 로그, 이벤트, 사용자 생성 콘텐츠와 같은 반정형 데이터(semi-structured data)를 다루는 경우

### `String` 컬럼(또는 구조화된 타입)을 사용해야 하는 경우: \{#use-string-type\}

- 데이터 구조가 이미 알려져 있고 일관된 경우 — 이때는 일반 컬럼, `Tuple`, `Array`, `Dynamic`, 또는 `Variant` 타입을 대신 사용합니다.
- `JSON` 문서를 필드 단위로 분석하지 않고 전체 단위로만 저장·조회하는 불투명한 blob으로 취급하는 경우
- 데이터베이스 내에서 개별 JSON 필드를 기준으로 쿼리하거나 필터링할 필요가 없는 경우
- `JSON`이 ClickHouse 내부에서 분석되지 않고 단순한 전송/저장 형식으로만 사용되는 경우

:::tip
`JSON`이 데이터베이스 내부에서 분석되지 않고, 단순히 저장했다가 다시 조회만 하는 불투명한 문서라면 `String` 필드로 저장해야 합니다. `JSON` 타입의 이점은 동적인 `JSON` 구조 안의 특정 필드를 효율적으로 쿼리, 필터링, 집계해야 할 때에만 나타납니다.

예측 가능한 최상위 필드에는 일반 컬럼을 사용하고, 페이로드의 동적 영역에는 `JSON` 컬럼을 사용하는 방식으로 접근법을 혼합해 사용할 수도 있습니다.
:::
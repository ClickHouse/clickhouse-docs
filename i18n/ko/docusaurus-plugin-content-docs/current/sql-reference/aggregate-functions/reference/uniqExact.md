---
description: '서로 다른 인수 값의 개수를 정확하게 계산합니다.'
slug: /sql-reference/aggregate-functions/reference/uniqexact
title: 'uniqExact'
doc_type: 'reference'
---

{/*AUTOGENERATED_START*/ }

## uniqExact \{#uniqExact\}

도입 버전: v1.1

서로 다른 인수 값의 정확한 개수를 계산합니다.

:::warning
`uniqExact` 함수는 상태 크기가 서로 다른 값의 개수 증가에 따라 제한 없이 증가하므로 `uniq` 함수보다 더 많은 메모리를 사용합니다.
정확한 결과가 반드시 필요할 때만 `uniqExact` 함수를 사용하십시오.
그 외의 경우에는 [`uniq`](https://clickhouse.com/docs/sql-reference/aggregate-functions/reference/uniq) 함수를 사용하십시오.
:::

**구문**

```sql
uniqExact(x[, ...])
```

**인자**

* `x` — 이 함수는 가변 개수의 매개변수를 받습니다. [`Tuple(T)`](/sql-reference/data-types/tuple) 또는 [`Array(T)`](/sql-reference/data-types/array) 또는 [`Date`](/sql-reference/data-types/date) 또는 [`DateTime`](/sql-reference/data-types/datetime) 또는 [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)

**반환값**

서로 다른 인자 값의 정확한 개수를 `UInt64`로 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**기본 사용법**

```sql title=Query
CREATE TABLE example_data
(
    id UInt32,
    category String
)
ENGINE = Memory;

INSERT INTO example_data VALUES
(1, 'A'), (2, 'B'), (3, 'A'), (4, 'C'), (5, 'B'), (6, 'A');

SELECT uniqExact(category) as exact_unique_categories
FROM example_data;
```

```response title=Response
┌─exact_unique_categories─┐
│                       3 │
└─────────────────────────┘
```

**여러 인자**

```sql title=Query
SELECT uniqExact(id, category) as exact_unique_combinations
FROM example_data;
```

```response title=Response
┌─exact_unique_combinations─┐
│                         6 │
└───────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

**함께 보기**

* [uniq](/sql-reference/aggregate-functions/reference/uniq)
* [uniqCombined](/sql-reference/aggregate-functions/reference/uniqcombined)
* [uniqHLL12](/sql-reference/aggregate-functions/reference/uniqhll12)
* [uniqTheta](/sql-reference/aggregate-functions/reference/uniqthetasketch)

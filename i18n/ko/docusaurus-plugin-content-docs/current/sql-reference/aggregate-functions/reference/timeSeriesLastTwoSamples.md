---
description: 'PromQL의 irate 및 idelta 계산과 유사한 방식으로 시계열 데이터를 다시 샘플링하는 집계 함수'
slug: /sql-reference/aggregate-functions/reference/timeSeriesLastTwoSamples
title: 'timeSeriesLastTwoSamples'
doc_type: 'reference'
---

{/*AUTOGENERATED_START*/ }

## timeSeriesLastTwoSamples \{#timeSeriesLastTwoSamples\}

도입 버전: v25.6

PromQL과 유사한 `irate` 및 `idelta` 계산을 위한 시계열 데이터 리샘플링 집계 함수입니다.

타임스탬프와 값 쌍으로 구성된 시계열 데이터를 입력으로 받아 최대 2개의 최신 샘플만 저장하는 집계 함수입니다. 이 집계 함수는 그리드에 정렬된 타임스탬프에 대한 리샘플링된 시계열 데이터를 저장하는 구체화된 뷰(Materialized View)와 집계 테이블과 함께 사용하도록 설계되었습니다.

집계 테이블은 각 정렬된 타임스탬프에 대해 마지막 2개의 값만 저장합니다. 이를 통해 원본 테이블에 저장된 전체 데이터보다 훨씬 적은 데이터만 읽고도 PromQL과 유사한 `irate` 및 `idelta`를 계산할 수 있습니다.

:::warning
이 함수는 실험적 기능이므로, `allow_experimental_ts_to_grid_aggregate_function=true` 설정을 통해 활성화해야 합니다.
:::

**구문**

```sql
timeSeriesLastTwoSamples(timestamp, value)
```

**인수**

* `timestamp` — 샘플의 타임스탬프입니다. [`DateTime`](/sql-reference/data-types/datetime) 또는 [`DateTime64`](/sql-reference/data-types/datetime64) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Int*`](/sql-reference/data-types/int-uint)
* `value` — 해당 타임스탬프에 대응하는 시계열 값입니다. [`Float32`](/sql-reference/data-types/float) 또는 [`Float64`](/sql-reference/data-types/float)

**반환 값**

길이가 0에서 2 사이이며 서로 동일한 두 개의 배열 쌍을 반환합니다. 첫 번째 배열에는 샘플링된 시계열의 타임스탬프가 포함되고, 두 번째 배열에는 시계열의 해당 값이 포함됩니다. [`Tuple(Array(DateTime), Array(Float64))`](/sql-reference/data-types/tuple)

**예시**

**원시 데이터를 위한 예제 테이블과 리샘플링된 데이터를 저장하기 위한 테이블**

```sql title=Query
-- Table for raw data
CREATE TABLE t_raw_timeseries
(
    metric_id UInt64,
    timestamp DateTime64(3, 'UTC') CODEC(DoubleDelta, ZSTD),
    value Float64 CODEC(DoubleDelta)
)
ENGINE = MergeTree()
ORDER BY (metric_id, timestamp);

-- Table with data re-sampled to bigger (15 sec) time steps
CREATE TABLE t_resampled_timeseries_15_sec
(
    metric_id UInt64,
    grid_timestamp DateTime('UTC') CODEC(DoubleDelta, ZSTD), -- Timestamp aligned to 15 sec
    samples AggregateFunction(timeSeriesLastTwoSamples, DateTime64(3, 'UTC'), Float64)
)
ENGINE = AggregatingMergeTree()
ORDER BY (metric_id, grid_timestamp);

-- MV for populating re-sampled table
CREATE MATERIALIZED VIEW mv_resampled_timeseries TO t_resampled_timeseries_15_sec
(
    metric_id UInt64,
    grid_timestamp DateTime('UTC') CODEC(DoubleDelta, ZSTD),
    samples AggregateFunction(timeSeriesLastTwoSamples, DateTime64(3, 'UTC'), Float64)
)
AS SELECT
    metric_id,
    ceil(toUnixTimestamp(timestamp + interval 999 millisecond) / 15, 0) * 15 AS grid_timestamp, -- Round timestamp up to the next grid point
    initializeAggregation('timeSeriesLastTwoSamplesState', timestamp, value) AS samples
FROM t_raw_timeseries
ORDER BY metric_id, grid_timestamp;

-- Insert some data
INSERT INTO t_raw_timeseries(metric_id, timestamp, value) SELECT number%10 AS metric_id, '2024-12-12 12:00:00'::DateTime64(3, 'UTC') + interval ((number/10)%100)*900 millisecond as timestamp, number%3+number%29 AS value FROM numbers(1000);

-- Check raw data
SELECT *
FROM t_raw_timeseries
WHERE metric_id = 3 AND timestamp BETWEEN '2024-12-12 12:00:12' AND '2024-12-12 12:00:31'
ORDER BY metric_id, timestamp;
```

```response title=Response
3    2024-12-12 12:00:12.870    29
3    2024-12-12 12:00:13.770    8
3    2024-12-12 12:00:14.670    19
3    2024-12-12 12:00:15.570    30
3    2024-12-12 12:00:16.470    9
3    2024-12-12 12:00:17.370    20
3    2024-12-12 12:00:18.270    2
3    2024-12-12 12:00:19.170    10
3    2024-12-12 12:00:20.070    21
3    2024-12-12 12:00:20.970    3
3    2024-12-12 12:00:21.870    11
3    2024-12-12 12:00:22.770    22
3    2024-12-12 12:00:23.670    4
3    2024-12-12 12:00:24.570    12
3    2024-12-12 12:00:25.470    23
3    2024-12-12 12:00:26.370    5
3    2024-12-12 12:00:27.270    13
3    2024-12-12 12:00:28.170    24
3    2024-12-12 12:00:29.069    6
3    2024-12-12 12:00:29.969    14
3    2024-12-12 12:00:30.869    25
```

**타임스탬프 &#39;2024-12-12 12:00:15&#39;와 &#39;2024-12-12 12:00:30&#39;에 해당하는 마지막 2개 샘플을 쿼리합니다**

```sql title=Query
-- Check re-sampled data
SELECT metric_id, grid_timestamp, (finalizeAggregation(samples).1 as timestamp, finalizeAggregation(samples).2 as value)
FROM t_resampled_timeseries_15_sec
WHERE metric_id = 3 AND grid_timestamp BETWEEN '2024-12-12 12:00:15' AND '2024-12-12 12:00:30'
ORDER BY metric_id, grid_timestamp;
```

```response title=Response
3    2024-12-12 12:00:15    (['2024-12-12 12:00:14.670','2024-12-12 12:00:13.770'],[19,8])
3    2024-12-12 12:00:30    (['2024-12-12 12:00:29.969','2024-12-12 12:00:29.069'],[14,6])
```

**원시 데이터에서 idelta와 irate 계산**

```sql title=Query
-- The aggregated table stores only last 2 values for each 15-second aligned timestamp.
-- This allows to calculate PromQL-like irate and idelta by reading much less data then is stored in the raw table.

WITH
    '2024-12-12 12:00:15'::DateTime64(3,'UTC') AS start_ts,       -- start of timestamp grid
    start_ts + INTERVAL 60 SECOND AS end_ts,   -- end of timestamp grid
    15 AS step_seconds,   -- step of timestamp grid
    45 AS window_seconds  -- "staleness" window
SELECT
    metric_id,
    timeSeriesInstantDeltaToGrid(start_ts, end_ts, step_seconds, window_seconds)(timestamp, value),
    timeSeriesInstantRateToGrid(start_ts, end_ts, step_seconds, window_seconds)(timestamp, value)
FROM t_raw_timeseries
WHERE metric_id = 3 AND timestamp BETWEEN start_ts - interval window_seconds seconds AND end_ts
GROUP BY metric_id;
```

```response title=Response
3    [11,8,-18,8,11]    [12.222222222222221,8.88888888888889,1.1111111111111112,8.88888888888889,12.222222222222221]
```

**재샘플링한 데이터에서 idelta 및 irate 계산**

```sql title=Query
WITH
    '2024-12-12 12:00:15'::DateTime64(3,'UTC') AS start_ts,       -- start of timestamp grid
    start_ts + INTERVAL 60 SECOND AS end_ts,   -- end of timestamp grid
    15 AS step_seconds,   -- step of timestamp grid
    45 AS window_seconds  -- "staleness" window
SELECT
    metric_id,
    timeSeriesInstantDeltaToGrid(start_ts, end_ts, step_seconds, window_seconds)(timestamps, values),
    timeSeriesInstantRateToGrid(start_ts, end_ts, step_seconds, window_seconds)(timestamps, values)
FROM (
    SELECT
        metric_id,
        finalizeAggregation(samples).1 AS timestamps,
        finalizeAggregation(samples).2 AS values
    FROM t_resampled_timeseries_15_sec
    WHERE metric_id = 3 AND grid_timestamp BETWEEN start_ts - interval window_seconds seconds AND end_ts
)
GROUP BY metric_id;
```

```response title=Response
3    [11,8,-18,8,11]    [12.222222222222221,8.88888888888889,1.1111111111111112,8.88888888888889,12.222222222222221]
```

{/*AUTOGENERATED_END*/ }

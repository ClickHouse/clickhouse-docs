---
description: '`key` 배열에 지정된 키에 따라 `value` 배열을 합산합니다. 정렬된 순서의 키 배열과 해당 키에 대해 합산된 값 배열로 이루어진 두 개의 배열 튜플을 반환합니다. sumMap 함수와의 차이점은 오버플로가 발생하도록 합산을 수행한다는 점입니다.'
slug: /sql-reference/aggregate-functions/reference/summapwithoverflow
title: 'sumMapWithOverflow'
doc_type: 'reference'
---

{/*AUTOGENERATED_START*/ }

## sumMapWithOverflow \{#sumMapWithOverflow\}

도입: v20.1

`key` 배열에 지정된 키에 따라 `value` 배열을 합산합니다. 정렬된 순서의 키 배열과, 해당 키에 대해 합산된 값 배열의 두 배열로 구성된 튜플을 반환합니다.
이 함수는 오버플로를 허용하는 방식으로 합산을 수행한다는 점에서 [`sumMap`](/sql-reference/aggregate-functions/reference/summap) 함수와 다릅니다. 즉, 합산 결과의 데이터 타입이 인수의 데이터 타입과 동일하게 반환됩니다.

:::note

* 키 배열과 값 배열로 이루어진 튜플을 전달하는 것은 키 배열과 값 배열을 각각 전달하는 것과 동일합니다.
* 합산되는 각 행에 대해 `key`와 `value`의 요소 개수는 같아야 합니다.
  :::

**구문**

```sql
sumMapWithOverflow(key, value)
sumMapWithOverflow(Tuple(key, value))
```

**인수**

* `key` — 키의 배열입니다. [`Array`](/sql-reference/data-types/array)
* `value` — 값의 배열입니다. [`Array`](/sql-reference/data-types/array)

**반환 값**

정렬된 순서의 키 배열과 해당 키별로 합산된 값 배열, 이렇게 두 개의 배열로 구성된 튜플을 반환합니다. [`Tuple(Array, Array)`](/sql-reference/data-types/tuple)

**예시**

**오버플로 동작을 보여주는 배열 문법 예시**

```sql title=Query
CREATE TABLE sum_map(
    date Date,
    timeslot DateTime,
    statusMap Nested(
        status UInt8,
        requests UInt8
    ),
    statusMapTuple Tuple(Array(Int8), Array(Int8))
) ENGINE = Memory;

INSERT INTO sum_map VALUES
    ('2000-01-01', '2000-01-01 00:00:00', [1, 2, 3], [10, 10, 10], ([1, 2, 3], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:00:00', [3, 4, 5], [10, 10, 10], ([3, 4, 5], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', [4, 5, 6], [10, 10, 10], ([4, 5, 6], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', [6, 7, 8], [10, 10, 10], ([6, 7, 8], [10, 10, 10]));

SELECT
    timeslot,
    toTypeName(sumMap(statusMap.status, statusMap.requests)),
    toTypeName(sumMapWithOverflow(statusMap.status, statusMap.requests))
FROM sum_map
GROUP BY timeslot;
```

```response title=Response
┌────────────timeslot─┬─toTypeName(sumMap⋯usMap.requests))─┬─toTypeName(sumMa⋯usMap.requests))─┐
│ 2000-01-01 00:01:00 │ Tuple(Array(UInt8), Array(UInt64)) │ Tuple(Array(UInt8), Array(UInt8)) │
│ 2000-01-01 00:00:00 │ Tuple(Array(UInt8), Array(UInt64)) │ Tuple(Array(UInt8), Array(UInt8)) │
└─────────────────────┴────────────────────────────────────┴───────────────────────────────────┘
```

**Tuple 구문을 사용한 동일한 결과**

```sql title=Query
SELECT
    timeslot,
    toTypeName(sumMap(statusMapTuple)),
    toTypeName(sumMapWithOverflow(statusMapTuple))
FROM sum_map
GROUP BY timeslot;
```

```response title=Response
┌────────────timeslot─┬─toTypeName(sumMap(statusMapTuple))─┬─toTypeName(sumM⋯tatusMapTuple))─┐
│ 2000-01-01 00:01:00 │ Tuple(Array(Int8), Array(Int64))   │ Tuple(Array(Int8), Array(Int8)) │
│ 2000-01-01 00:00:00 │ Tuple(Array(Int8), Array(Int64))   │ Tuple(Array(Int8), Array(Int8)) │
└─────────────────────┴────────────────────────────────────┴─────────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

**함께 보기**

* [sumMap](../reference/sumMappedArrays.md)

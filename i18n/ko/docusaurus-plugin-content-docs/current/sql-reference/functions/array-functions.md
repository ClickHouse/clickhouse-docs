---
'description': 'Array Functions에 대한 문서'
'sidebar_label': '배열'
'slug': '/sql-reference/functions/array-functions'
'title': '배열 함수'
'doc_type': 'reference'
---


# 배열 함수

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## array {#array}

Introduced in: v1.1


함수 인수로 배열을 생성합니다.

인수는 상수여야 하고 공통 슈퍼타입을 공유하는 형식을 가져야 합니다.
적어도 하나의 인수를 전달해야 하며, 그렇지 않으면 어떤 타입의 배열을 생성해야 할지 명확하지 않습니다.
이는 이 기능을 사용하여 빈 배열을 생성할 수 없음을 의미합니다. 빈 배열을 생성하려면 `emptyArray*` 함수를 사용하십시오.

동일한 기능을 위해 `[ ]` 연산자를 사용하십시오.
    

**구문**

```sql
array(x1 [, x2, ..., xN])
```

**인수**

- `x1` — 유형 T의 상수값. 이 인수만 제공되는 경우, 배열은 T 유형이 됩니다. - `[, x2, ..., xN]` — `x1`과 공통 슈퍼타입을 공유하는 N개의 추가 상수값 

**반환 값**

전달된 인수의 최소 공통 유형인 'T'를 갖는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**유효한 사용법**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**잘못된 사용법**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```
## arrayAUCPR {#arrayAUCPR}

Introduced in: v20.4


정밀도-재현율(Precision-Recall, PR) 곡선 아래의 면적을 계산합니다.
정밀도-재현율 곡선은 모든 임계값에 대해 y축에 정밀도를, x축에 재현율을 플로팅하여 생성됩니다.
결과값은 0에서 1 사이이며, 값이 높을수록 모델 성능이 더 좋습니다.
PR AUC는 불균형 데이터 세트에 특히 유용하며, 그런 경우에서 ROC AUC에 비해 성능 비교를 더 명확하게 합니다.
자세한 내용은 [여기](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [여기](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) 및 [여기](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)를 참조하십시오.


**구문**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**별칭**: `arrayPRAUC`

**인수**

- `cores` — 예측 모델이 제공하는 점수. [`Array((U)Int*)`](/sql-reference/data-types/array) 또는 [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — 샘플의 레이블로, 일반적으로 양성 샘플에는 1, 음성 샘플에는 0을 사용합니다. [`Array((U)Int*)`](/sql-reference/data-types/array) 또는 [`Array(Enum)`](/sql-reference/data-types/array)
- `partial_offsets` — 
- 선택 사항. PR 곡선의 부분 면적을 계산하기 위한 세 개의 음이 아닌 정수의 [`Array(T)`](/sql-reference/data-types/array)로, 전체 AUC 대신 PR 공간의 수직 밴드에 해당합니다. 이 옵션은 PR AUC의 분산 계산에 유용합니다. 배열에는 다음 요소가 포함되어야 합니다: [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`].
    - `higher_partitions_tp`: 높은 점수의 파티션에서 긍정적인 레이블의 수.
    - `higher_partitions_fp`: 높은 점수의 파티션에서 부정적인 레이블의 수.
    - `total_positives`: 전체 데이터 세트에서 긍정적인 샘플의 총 수.

:::note
`arr_partial_offsets`가 사용될 때, `arr_scores` 및 `arr_labels`는 전체 데이터 세트의 구간 점수만 포함하는 파티션의 일부여야 합니다.
데이터 세트는 연속적인 파티션으로 나뉘어야 하며, 각 파티션에는 특정 범위 내의 점수에 해당하는 데이터의 부분집합이 포함되어야 합니다.
예를 들어:
- 하나의 파티션은 [0, 0.5) 범위의 모든 점수를 포함할 수 있습니다.
- 또 다른 파티션은 [0.5, 1.0] 범위의 점수를 포함할 수 있습니다.
:::
 

**반환 값**

정밀도-재현율(PR) 곡선 아래의 면적을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```
## arrayAll {#arrayAll}

Introduced in: v1.1


람다 함수 `func(x [, y1, y2, ... yN])`이 모든 요소에 대해 true를 반환하면 `1`을 반환합니다. 그렇지 않으면 `0`을 반환합니다.


**구문**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

람다 함수가 모든 요소에 대해 true를 반환하면 `1`을, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**모든 요소가 일치**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**모든 요소가 일치하지 않음**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```
## arrayAvg {#arrayAvg}

Introduced in: v21.1


소스 배열의 요소 평균을 반환합니다.

람다 함수 `func`가 지정되면, 람다 결과의 평균을 반환합니다.
    

**구문**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x[, y1, ..., yN])` — 선택 사항. 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열의 요소 평균을 반환하거나, 지정된 경우 람다 결과의 평균을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**기본 예시**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**람다 함수 사용 예시**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```
## arrayCompact {#arrayCompact}

Introduced in: v20.1

연속된 중복 요소를 배열에서 제거합니다. `null` 값을 포함합니다. 결과 배열의 값 순서는 소스 배열의 순서에 따라 결정됩니다.

**구문**

```sql
arrayCompact(arr)
```

**인수**

- `arr` — 중복을 제거할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

중복 값이 없는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```
## arrayConcat {#arrayConcat}

Introduced in: v1.1

인수로 전달된 배열을 결합합니다.

**구문**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**인수**

- `arr1 [, arr2, ... , arrN]` — N개의 배열을 연결합니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

제공된 배열 인수에서 결합된 단일 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```
## arrayCount {#arrayCount}

Introduced in: v1.1


`func(arr1[i], ..., arrN[i])`가 true를 반환하는 요소의 수를 반환합니다.
`func`가 지정되지 않으면, 배열에서 비영(非零) 요소의 수를 반환합니다.

`arrayCount`는 [고차 함수](/sql-reference/functions/overview#higher-order-functions)입니다.
    

**구문**

```sql
arrayCount([func, ] arr1, ...)
```

**인수**

- `func` — 선택 사항. 배열 요소에 적용할 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1, ..., arrN` — N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

`func`가 true로 반환되는 요소의 수를 반환합니다. 그렇지 않으면, 배열의 비영(非零) 요소 수를 반환합니다. [`UInt32`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```
## arrayCumSum {#arrayCumSum}

Introduced in: v1.1

소스 배열의 부분(누적) 합의 배열을 반환합니다. 람다 함수가 지정되면, 각 위치의 배열 요소에 람다를 적용하여 합계가 계산됩니다.

**구문**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**인수**

- `func` — 선택 사항. 각 위치의 배열 요소에 적용할 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — 숫자 값의 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — 선택 사항. 지정된 경우 람다 함수에 전달되는 같은 크기의 추가 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열의 부분 합의 배열을 반환합니다. 결과 유형은 입력 배열의 숫자 유형과 일치합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**기본 사용법**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**람다 사용**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```
## arrayCumSumNonNegative {#arrayCumSumNonNegative}

Introduced in: v18.12

소스 배열의 부분(누적) 합의 배열을 반환하며, 음수 누적 합은 0으로 대체됩니다. 람다 함수가 지정되면, 각 위치의 배열 요소에 람다를 적용하여 합계가 계산됩니다.

**구문**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**인수**

- `func` — 선택 사항. 각 위치의 배열 요소에 적용할 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1` — 숫자 값의 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `[arr2, ..., arrN]` — 선택 사항. 지정된 경우 람다 함수에 전달되는 같은 크기의 추가 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열의 부분 합의 배열을 반환하며, 음수 누적 합은 0으로 대체됩니다. 결과 유형은 입력 배열의 숫자 유형과 일치합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**기본 사용법**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**람다 사용**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```
## arrayDifference {#arrayDifference}

Introduced in: v1.1


인접한 배열 요소 간의 차이를 계산하여 배열을 생성합니다.
결과 배열의 첫 번째 요소는 0이며, 두 번째 요소는 `arr[1] - arr[0]`, 세 번째 요소는 `arr[2] - arr[1]` 등입니다.
결과 배열의 요소 유형은 뺄셈에 대한 타입 추론 규칙에 따라 결정됩니다(예: `UInt8` - `UInt8` = `Int16`).
    

**구문**

```sql
arrayDifference(arr)
```

**인수**

- `arr` — 인접한 요소 간의 차이를 계산할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

인접한 배열 요소 간의 차이를 포함하는 배열을 반환합니다. [`UInt*`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**결과 유형 Int64로 인해 오버플로우되는 예시**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```
## arrayDistinct {#arrayDistinct}

Introduced in: v1.1

배열의 고유한 요소만 포함하는 배열을 반환합니다.

**구문**

```sql
arrayDistinct(arr)
```

**인수**

- `arr` — 고유 요소를 추출할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

고유한 요소를 포함하는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```
## arrayDotProduct {#arrayDotProduct}

Introduced in: v23.5


두 배열의 내적을 반환합니다.

:::note
두 벡터의 크기는 같아야 합니다. 배열과 튜플은 혼합 요소 유형을 포함할 수 있습니다.
:::


**구문**

```sql
arrayDotProduct(v1, v2)
```

**인수**

- `v1` — 첫 번째 벡터입니다. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) 또는 [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
- `v2` — 두 번째 벡터입니다. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) 또는 [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)


**반환 값**

두 벡터의 내적입니다.

:::note
반환 유형은 인수의 유형에 따라 결정됩니다. 배열이나 튜플에 혼합 요소 유형이 포함되어 있는 경우 결과 유형은 슈퍼타입입니다.
:::

 [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)

**예시**

**배열 예시**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**튜플 예시**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```
## arrayElement {#arrayElement}

Introduced in: v1.1


제공된 배열에서 인덱스 `n`의 요소를 가져옵니다. `n`은 모든 정수 유형일 수 있습니다.
인덱스가 배열의 경계를 벗어나면 기본값(숫자의 경우 0, 문자열의 경우 빈 문자열 등)을 반환합니다.
비상수 배열 인수와 상수 인덱스 0의 경우를 제외하고 오류가 발생합니다: `Array indices are 1-based`.

:::note
ClickHouse의 배열은 1 기반 인덱싱입니다.
:::

음수 인덱스도 지원됩니다. 이 경우, 해당 요소는 끝에서 번호가 매겨진 요소로 선택됩니다. 예를 들어, `arr[-1]`는 배열의 마지막 항목입니다.

연산자 `[n]`는 동일한 기능을 제공합니다.
    

**구문**

```sql
arrayElement(arr, n)
```

**인수**

- `arr` — 검색할 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `n` — 가져올 요소의 위치입니다. [`(U)Int*`](/sql-reference/data-types/int-uint). 

**반환 값**

제공된 배열 인수에서 단일 결합 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**음수 인덱싱**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**[n] 표기법 사용**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**배열 경계 초과 인덱스**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```
## arrayElementOrNull {#arrayElementOrNull}

Introduced in: v1.1


제공된 배열에서 인덱스 `n`의 요소를 가져옵니다. `n`은 모든 정수 유형일 수 있습니다.
인덱스가 배열의 경계를 벗어나면 기본값 대신 `NULL`을 반환합니다.

:::note
ClickHouse의 배열은 1 기반 인덱싱입니다.
:::

음수 인덱스도 지원됩니다. 이 경우, 끝에서 번호가 매겨진 해당 요소를 선택합니다. 예를 들어, `arr[-1]`는 배열의 마지막 항목입니다.


**구문**

```sql
arrayElementOrNull(arrays)
```

**인수**

- `arrays` — 임의 개수의 배열 인수입니다. [`Array`](/sql-reference/data-types/array)


**반환 값**

제공된 배열 인수에서 단일 결합 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**음수 인덱싱**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**배열 경계 초과 인덱스**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```
## arrayEnumerate {#arrayEnumerate}

Introduced in: v1.1


배열 `[1, 2, 3, ..., length (arr)]`를 반환합니다.

이 함수는 일반적으로 [`ARRAY JOIN`](/sql-reference/statements/select/array-join) 절과 함께 사용됩니다. `ARRAY JOIN`을 적용한 후 각 배열에 대해 무언가를 한 번만 계산할 수 있습니다.
이 함수는 고차 함수에서도 사용될 수 있습니다. 예를 들어 조건을 충족하는 요소에 대한 배열 인덱스를 얻기 위해 사용할 수 있습니다.


**구문**

```sql
arrayEnumerate(arr)
```

**인수**

- `arr` — 열거할 배열입니다. [`Array`](/sql-reference/data-types/array)


**반환 값**

배열 `[1, 2, 3, ..., length (arr)]`를 반환합니다. [`Array(UInt32)`](/sql-reference/data-types/array)

**예시**

**ARRAY JOIN을 사용하는 기본 예**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```
## arrayEnumerateDense {#arrayEnumerateDense}

Introduced in: v18.12

소스 배열에서 각 요소가 처음 나타나는 위치를 나타내는, 소스 배열과 같은 크기의 배열을 반환합니다.

**구문**

```sql
arrayEnumerateDense(arr)
```

**인수**

- `arr` — 열거할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열과 같은 크기의 배열을 반환하며, 소스 배열에서 각 요소가 처음 나타나는 위치를 나타냅니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```
## arrayEnumerateDenseRanked {#arrayEnumerateDenseRanked}

Introduced in: v20.1

소스 배열과 같은 크기의 배열을 반환하며, 소스 배열에서 각 요소가 처음 나타나는 위치를 나타냅니다. 다차원 배열을 열거할 수 있으며 배열 내부를 얼마나 깊이 탐색할지를 지정할 수 있습니다.

**구문**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**인수**

- `clear_depth` — 지정된 수준에서 요소를 별도로 열거합니다. `max_arr_depth`보다 작거나 같아야 합니다. [`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — N차원 배열을 열거합니다. [`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — 최대 유효 깊이입니다. `arr`의 깊이보다 작거나 같아야 합니다. [`UInt*`](/sql-reference/data-types/int-uint)


**반환 값**

소스 배열에서 각 요소가 처음 나타나는 위치를 나타내는 배열을 반환합니다. [`Array`](/sql-reference/data-types/array)

**예시**

**기본 사용법**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result is identical to what arrayEnumerateDense would give.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**다차원 배열 사용**

```sql title=Query
-- In this example, arrayEnumerateDenseRanked is used to obtain an array indicating, for each element of the
-- multidimensional array, what its position is among elements of the same value.
-- For the first row of the passed array, [10, 10, 30, 20], the corresponding first row of the result is [1, 1, 2, 3],
-- indicating that 10 is the first number encountered in position 1 and 2, 30 the second number encountered in position 3
-- and 20 is the third number encountered in position 4.
-- For the second row, [40, 50, 10, 30], the corresponding second row of the result is [4,5,1,2], indicating that 40
-- and 50 are the fourth and fifth numbers encountered in position 1 and 2 of that row, that another 10
-- (the first encountered number) is in position 3 and 30 (the second number encountered) is in the last position.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**clear_depth 증가 예시**

```sql title=Query
-- Changing clear_depth=2 results in the enumeration occurring separately for each row anew.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```
## arrayEnumerateUniq {#arrayEnumerateUniq}

Introduced in: v1.1


소스 배열과 같은 크기의 배열을 반환하며, 각 요소의 동일 값 요소 중에서의 위치를 나타냅니다.

이 함수는 `ARRAY JOIN` 및 배열 요소 집계와 함께 사용할 때 유용합니다.

이 함수는 동일한 크기의 여러 배열을 인수로 할 수 있습니다. 이 경우 모두 같은 위치의 요소 튜플에 대해 고유성이 고려됩니다.


**구문**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**인수**

- `arr1` — 처리할 첫 번째 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `arr2, ...` — 선택 사항. 튜플 고유성을 위한 동일한 크기의 추가 배열입니다. [`Array(UInt32)`](/sql-reference/data-types/array)


**반환 값**

동일한 값이나 튜플에서의 각 요소의 위치를 나타내는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**기본 사용법**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**여러 배열**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**ARRAY JOIN 집계**

```sql title=Query
-- Each goal ID has a calculation of the number of conversions (each element in the Goals nested data structure is a goal that was reached, which we refer to as a conversion)
-- and the number of sessions. Without ARRAY JOIN, we would have counted the number of sessions as sum(Sign). But in this particular case,
-- the rows were multiplied by the nested Goals structure, so in order to count each session one time after this, we apply a condition to the
-- value of the arrayEnumerateUniq(Goals.ID) function.

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```
## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

Introduced in: v20.1


소스 배열과 같은 크기의 배열(또는 다차원 배열)을 반환하며, 각 요소가 동일 값 요소 중에서의 위치를 나타냅니다.
다차원 배열을 열거할 수 있으며 배열 내부를 얼마나 깊이 탐색할지를 지정할 수 있습니다.


**구문**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**인수**

- `clear_depth` — 지정된 수준에서 요소를 별도로 열거합니다. 양의 정수여야 하며 `max_arr_depth`보다 작거나 같아야 합니다. [`UInt*`](/sql-reference/data-types/int-uint)
- `arr` — N차원 배열을 열거합니다. [`Array(T)`](/sql-reference/data-types/array)
- `max_array_depth` — 최대 유효 깊이입니다. 양의 정수여야 하며 `arr`의 깊이보다 작거나 같아야 합니다. [`UInt*`](/sql-reference/data-types/int-uint)


**반환 값**

동일한 값 요소에 대한 각 요소의 위치를 표시하는 `arr`와 동일한 크기의 N차원 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**예시 1**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniq would give for the same array.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**예시 2**

```sql title=Query
-- with clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniqwould give for the same array.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**예시 3**

```sql title=Query
-- In this example, arrayEnumerateUniqRanked is used to obtain an array indicating,
-- for each element of the multidimensional array, what its position is among elements
-- of the same value. For the first row of the passed array, [1, 2, 3], the corresponding
-- result is [1, 1, 1], indicating that this is the first time 1, 2 and 3 are encountered.
-- For the second row of the provided array, [2, 2, 1], the corresponding result is [2, 3, 3],
-- indicating that 2 is encountered for a second and third time, and 1 is encountered
-- for the second time. Likewise, for the third row of the provided array [3] the
-- corresponding result is [2] indicating that 3 is encountered for the second time.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**예시 4**

```sql title=Query
-- Changing clear_depth=2, results in elements being enumerated separately for each row.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```
## arrayExcept {#arrayExcept}

Introduced in: v25.9


`source`에서 `except`에 존재하지 않는 요소로 구성된 배열을 반환하며, 원본 순서는 보존됩니다.

이 함수는 두 배열 간의 집합 차집합 연산을 수행합니다. `source`의 각 요소에 대해 요소가 `except`에 존재하는지를 확인합니다(정확한 비교 사용). 존재하지 않으면 결과에 포함됩니다.

이 연산은 다음 속성을 유지합니다:
1. `source`에서 요소의 순서가 보존됩니다.
2. `source`의 중복이 `except`에 존재하지 않을 경우 보존됩니다.
3. NULL은 별도의 값으로 처리됩니다.
    

**구문**

```sql
arrayExcept(source, except)
```

**인수**

- `source` — 필터링할 요소를 포함하는 소스 배열입니다.  [`Array(T)`](/sql-reference/data-types/array)
- `except` — 결과에서 제외할 요소를 포함하는 배열입니다.  [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

`except`에서 찾을 수 없는 `source`의 요소를 포함하는 동일한 유형의 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**기본 예시**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with_nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with_nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**문자열**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```
## arrayExists {#arrayExists}

Introduced in: v1.1


소스 배열에 대해 `func(x[, y1, y2, ... yN])`가 true를 반환하는 요소가 하나라도 있으면 `1`을 반환합니다. 그렇지 않으면 `0`을 반환합니다.


**구문**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

람다 함수가 적어도 하나의 요소에 대해 true를 반환하면 `1`을, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```
## arrayFill {#arrayFill}

Introduced in: v20.1


`arrayFill` 함수는 첫 번째 요소에서 마지막 요소까지 소스 배열을 순차적으로 처리하면서, 소스 및 조건 배열의 요소를 사용하여 각 위치에서 람다 조건을 평가합니다. 람다 함수가 위치 i에서 false로 평가되면, 해당 요소는 배열의 현재 상태에서 위치 i-1의 요소로 대체됩니다. 첫 번째 요소는 항상 보존됩니다. 


**구문**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x [, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수 `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**단일 배열을 사용하는 예시**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**두 배열을 사용하는 예시**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```
## arrayFilter {#arrayFilter}

Introduced in: v1.1

람다 함수가 true를 반환하는 소스 배열의 요소만 포함하는 배열을 반환합니다.

**구문**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**인수**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열의 부분 집합을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**예시 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**예시 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```
## arrayFirst {#arrayFirst}

Introduced in: v1.1


`func(x[, y1, y2, ... yN])`가 true를 반환하는 소스 배열의 첫 번째 요소를 반환하며, 그렇지 않으면 기본값을 반환합니다.
    

**구문**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수입니다. [람다 함수](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array). 

**반환 값**

람다 함수가 true인 소스 배열의 첫 번째 요소를 반환하며, 그렇지 않으면 `T`의 기본값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**일치 없음**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```
## arrayFirstIndex {#arrayFirstIndex}

Introduced in: v1.1


`func(x[, y1, y2, ... yN])`가 true를 반환하는 소스 배열의 첫 번째 요소의 인덱스를 반환하며, 그렇지 않으면 '0'을 반환합니다.


**구문**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수입니다. [람다 함수](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array). 

**반환 값**

람다 함수가 true인 소스 배열의 첫 번째 요소의 인덱스를 반환하며, 그렇지 않으면 `0`을 반환합니다. [`UInt32`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**일치 없음**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```
## arrayFirstOrNull {#arrayFirstOrNull}

Introduced in: v1.1


`func(x[, y1, y2, ... yN])`가 true를 반환하는 소스 배열의 첫 번째 요소를 반환하며, 그렇지 않으면 `NULL`을 반환합니다.
    

**구문**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x[, y1, y2, ... yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

람다 함수가 true인 소스 배열의 첫 번째 요소를 반환하며, 그렇지 않으면 `NULL`을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**일치 없음**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```
## arrayFlatten {#arrayFlatten}

Introduced in: v20.1


배열의 배열을 평면 배열로 변환합니다.

기능:

- 중첩 배열의 모든 깊이에 적용됩니다.
- 이미 평면 배열인 배열은 변경되지 않습니다.

평면화된 배열에는 모든 소스 배열의 모든 요소가 포함됩니다.


**구문**

```sql
arrayFlatten(arr)
```

**별칭**: `flatten`

**인수**

- `arr` — 다차원 배열입니다. [`Array(Array(T))`](/sql-reference/data-types/array)


**반환 값**

다차원 배열에서 평면 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```
## arrayFold {#arrayFold}

Introduced in: v23.10

동등한 크기의 배열 하나 이상에 람다 함수를 적용하고 결과를 누산기에 모읍니다.

**구문**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**인수**

- `λ(x, x1 [, x2, x3, ... xN])` — 누산기와 배열 값에 적용되는 연산이며, 결과의 누산기를 재사용하여 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`의 형식을 갖는 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr1 [, arr2, arr3, ... arrN]` — 작동할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `acc` — 람다 함수의 반환 유형과 동일한 유형의 누산기 값입니다. 

**반환 값**

최종 `acc` 값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**피보나치 수열**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**여러 배열을 사용하는 예시**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```
## arrayIntersect {#arrayIntersect}

Introduced in: v1.1

여러 배열을 가져와 모든 소스 배열에 존재하는 요소로 구성된 배열을 반환합니다. 결과에는 고유한 값만 포함됩니다.

**구문**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**인수**

- `arrN` — 새로운 배열을 만들기 위한 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array). 

**반환 값**

모든 N 배열에 존재하는 고유한 요소를 포함하는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```
## arrayJaccardIndex {#arrayJaccardIndex}

Introduced in: v23.7

두 배열의 [Jaccard 지수](https://en.wikipedia.org/wiki/Jaccard_index)를 반환합니다.

**구문**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**인수**

- `arr_x` — 첫 번째 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — 두 번째 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

`arr_x`와 `arr_y`의 Jaccard 지수를 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```

## arrayJoin {#arrayJoin}

Introduced in: v1.1

`arrayJoin` 함수는 배열을 포함하는 행을 가져와서 이를 펼쳐서 배열의 각 요소에 대해 하나의 행으로 여러 개의 행을 생성합니다. 이는 입력 값을 동일한 행 내에서 출력 값으로 매핑하는 ClickHouse의 일반 함수 및 여러 개의 행을 취합하여 하나의 요약 행(또는 `GROUP BY`와 함께 사용할 경우 요약 행 내의 단일 값)으로 "압축"하거나 "축소"하는 집계 함수와 대조적입니다.

이 함수가 적용된 열의 값은 해당 배열 값으로 대체되고, 다른 열의 값은 단순히 복사됩니다.

**Syntax**

```sql
arrayJoin(arr)
```

**Arguments**

- `arr` — 펼칠 배열. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

`arr`에서 펼쳐진 행 집합을 반환합니다.

**Examples**

**Basic usage**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin affects all sections of the query**

```sql title=Query
-- The arrayJoin function affects all sections of the query, including the WHERE section. Notice the result 2, even though the subquery returned 1 row.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**Using multiple arrayJoin functions**

```sql title=Query
- A query can use multiple arrayJoin functions. In this case, the transformation is performed multiple times and the rows are multiplied.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**Unexpected results due to optimizations**

```sql title=Query
-- Using multiple arrayJoin with the same expression may not produce the expected result due to optimizations.
-- For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.
- e.g. arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set
    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```

```response title=Response
┌─first_throw─┬─second_throw─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**Using the ARRAY JOIN syntax**

```sql title=Query
-- Note the ARRAY JOIN syntax in the `SELECT` query below, which provides broader possibilities.
-- ARRAY JOIN allows you to convert multiple arrays with the same number of elements at a time.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Using Tuple**

```sql title=Query
-- You can also use Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```
## arrayLast {#arrayLast}

Introduced in: v1.1

소스 배열에서 람다 `func(x [, y1, y2, ... yN])`가 true를 반환하는 마지막 요소를 반환하며, 그렇지 않으면 기본 값을 반환합니다.

**Syntax**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). 
- `source` — 처리할 소스 배열. [`Array(T)`](/sql-reference/data-types/array). 
- `[, cond1, ... , condN]` — 선택적. 람다 함수에 추가 인수를 제공하는 N 개의 조건 배열. [`Array(T)`](/sql-reference/data-types/array). 

**Returned value**

`func`가 true인 소스 배열의 마지막 요소를 반환하고, 그렇지 않으면 `T`의 기본 값을 반환합니다.

**Examples**

**Usage example**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**No match**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```
## arrayLastIndex {#arrayLastIndex}

Introduced in: v1.1

`func(x[, y1, y2, ... yN])`가 true를 반환하는 소스 배열의 마지막 요소의 인덱스를 반환하며, 그렇지 않으면 '0'을 반환합니다.

**Syntax**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 선택적. N 개의 조건 배열로 람다 함수에 추가 인수를 제공. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

`func`가 true인 소스 배열의 마지막 요소의 인덱스를 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt32`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**No match**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```
## arrayLastOrNull {#arrayLastOrNull}

Introduced in: v1.1

소스 배열에서 람다 `func(x [, y1, y2, ... yN])`가 true를 반환하는 마지막 요소를 반환하거나 그렇지 않으면 `NULL`을 반환합니다.

**Syntax**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x [, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). 
- `source_arr` — 처리할 소스 배열. [`Array(T)`](/sql-reference/data-types/array). 
- `[, cond1_arr, ... , condN_arr]` — 선택적. N 개의 조건 배열로 람다 함수에 추가 인수를 제공. [`Array(T)`](/sql-reference/data-types/array). 

**Returned value**

`λ`가 true가 아닌 소스 배열의 마지막 요소를 반환하고, 그렇지 않으면 `NULL`을 반환합니다.

**Examples**

**Usage example**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**No match**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```
## arrayLevenshteinDistance {#arrayLevenshteinDistance}

Introduced in: v25.4

두 배열 사이의 Levenshtein 거리를 계산합니다.

**Syntax**

```sql
arrayLevenshteinDistance(from, to)
```

**Arguments**

- `from` — 첫 번째 배열. [`Array(T)`](/sql-reference/data-types/array). 
- `to` — 두 번째 배열. [`Array(T)`](/sql-reference/data-types/array). 

**Returned value**

첫 번째 배열과 두 번째 배열 사이의 Levenshtein 거리. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```
## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

Introduced in: v25.4

각 요소에 대한 사용자 지정 가중치로 두 배열 사이의 Levenshtein 거리를 계산합니다. 배열의 요소 수와 그 가중치는 일치해야 합니다.

**Syntax**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**Arguments**

- `from` — 첫 번째 배열. [`Array(T)`](/sql-reference/data-types/array). 
- `to` — 두 번째 배열. [`Array(T)`](/sql-reference/data-types/array). 
- `from_weights` — 첫 번째 배열의 가중치. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — 두 번째 배열의 가중치. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**Returned value**

각 요소에 대한 사용자 지정 가중치로 첫 번째 배열과 두 번째 배열 사이의 Levenshtein 거리 [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```
## arrayMap {#arrayMap}

Introduced in: v1.1

각 요소에 람다 함수를 적용하여 원본 배열에서 얻은 배열을 반환합니다.

**Syntax**

```sql
arrayMap(func, arr)
```

**Arguments**

- `func` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — 처리할 N 개의 배열. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

람다 결과로부터 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**Creating a tuple of elements from different arrays**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```
## arrayMax {#arrayMax}

Introduced in: v21.1

소스 배열에서 최대 요소를 반환합니다.

람다 함수 `func`가 지정된 경우, 람다 결과의 최대 요소를 반환합니다.

**Syntax**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — 선택적. 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 선택적. N 개의 조건 배열로 람다 함수에 추가 인수를 제공. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

소스 배열에서 최대 요소를 반환하거나, 제공된 경우 람다 결과의 최대 요소를 반환합니다.

**Examples**

**Basic example**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**Usage with lambda function**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```
## arrayMin {#arrayMin}

Introduced in: v21.1

소스 배열에서 최소 요소를 반환합니다.

람다 함수 `func`가 지정된 경우, 람다 결과의 최소 요소를 반환합니다.

**Syntax**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — 선택적. 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열. [`Array(T)`](/sql-reference/data-types/array)
- `cond1_arr, ...` — 선택적. N 개의 조건 배열로 람다 함수에 추가 인수를 제공. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

소스 배열에서 최소 요소를 반환하거나, 제공된 경우 람다 결과의 최소 요소를 반환합니다.

**Examples**

**Basic example**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**Usage with lambda function**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```
## arrayNormalizedGini {#arrayNormalizedGini}

Introduced in: v25.1

정규화된 Gini 계수를 계산합니다.

**Syntax**

```sql
arrayNormalizedGini(predicted, label)
```

**Arguments**

- `predicted` — 예측된 값. [`Array(T)`](/sql-reference/data-types/array)
- `label` — 실제 값. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

예측 값의 Gini 계수, 정규화 값의 Gini 계수, 그리고 정규화된 Gini 계수 (= 전자의 두 Gini 계수의 비율)를 포함하는 튜플 [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```
## arrayPartialReverseSort {#arrayPartialReverseSort}

Introduced in: v23.2

이 함수는 `arrayReverseSort`와 동일하지만 부분 정렬을 허용하는 추가 `limit` 인수를 가지고 있습니다.

:::tip
정렬된 요소만 유지하려면 `arrayResize`를 사용하세요.
:::

**Syntax**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Arguments**

- `f(arr[, arr1, ... ,arrN])` — 배열 `x`의 요소에 적용할 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — 정렬할 배열. [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — `f`가 여러 인수를 수용하는 경우 N 개의 추가 배열. [`Array(T)`](/sql-reference/data-types/array)
- `limit` — 정렬이 발생할 인덱스 값. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

원래 배열과 동일한 크기의 배열을 반환하며, `[1..limit]` 범위의 요소는 내림차순으로 정렬됩니다. 나머지 요소 `(limit..N]`는 불특정한 순서로 나옵니다.

**Examples**

**simple_int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple_string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain_sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda_simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda_complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```
## arrayPartialShuffle {#arrayPartialShuffle}

Introduced in: v23.2

원본 배열과 동일한 크기의 배열을 반환하며, `[1..limit]` 범위의 요소는 원본 배열의 무작위 하위 집합입니다. 나머지 `(limit..n]`은 `[1..limit]` 범위에 포함되지 않은 요소를 불명확한 순서로 포함합니다. `limit` 값은 `[1..n]` 범위 내에 있어야 합니다. 그 범위를 벗어난 값은 전체 `arrayShuffle`을 수행하는 것과 같습니다.

:::note
이 함수는 상수를 실체화하지 않습니다.

`limit` 값은 `[1..N]` 범위에 있어야 합니다. 그 범위를 벗어난 값은 전체 [`arrayShuffle`](#arrayShuffle)를 수행하는 것과 같습니다.
:::

**Syntax**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**Arguments**

- `arr` — 섞을 배열. [`Array(T)`](/sql-reference/data-types/array)
- `seed` — 선택적. 난수 생성에 사용할 시드. 제공되지 않으면 무작위 시드가 사용됩니다. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `limit` — 선택적. 요소 스왑을 제한할 숫자, `[1..N]` 범위 내. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

부분적으로 섞인 요소를 가진 배열. [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**no_limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no_limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random_seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit_seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```
## arrayPartialSort {#arrayPartialSort}

Introduced in: v23.2

이 함수는 `arraySort`와 동일하지만 추가적인 `limit` 인수를 가지고 있어 부분 정렬을 허용합니다.

:::tip
정렬된 요소만 유지하려면 `arrayResize`를 사용하세요.
:::

**Syntax**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**Arguments**

- `f(arr[, arr1, ... ,arrN])` — 배열 `x`의 요소에 적용할 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `arr` — 정렬할 배열. [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ... ,arrN` — `f`가 여러 인수를 수용하는 경우 N 개의 추가 배열. [`Array(T)`](/sql-reference/data-types/array)
- `limit` — 정렬이 발생할 인덱스 값. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

원래 배열과 동일한 크기의 배열을 반환하며, `[1..limit]` 범위의 요소는 오름차순으로 정렬됩니다. 나머지 요소 `(limit..N]`는 불특정한 순서로 나옵니다.

**Examples**

**simple_int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple_string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain_sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda_simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda_complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```
## arrayPopBack {#arrayPopBack}

Introduced in: v1.1

배열에서 마지막 요소를 제거합니다.

**Syntax**

```sql
arrayPopBack(arr)
```

**Arguments**

- `arr` — 마지막 요소를 제거할 배열. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

`arr`와 동일하지만 `arr`의 마지막 요소가 없는 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```
## arrayPopFront {#arrayPopFront}

Introduced in: v1.1

배열에서 첫 번째 항목을 제거합니다.

**Syntax**

```sql
arrayPopFront(arr)
```

**Arguments**

- `arr` — 첫 번째 요소를 제거할 배열. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

`arr`와 동일하지만 `arr`의 첫 번째 요소가 없는 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```
## arrayProduct {#arrayProduct}

Introduced in: v21.1

소스 배열의 요소의 곱을 반환합니다.

람다 함수 `func`가 지정된 경우, 람다 결과의 요소의 곱을 반환합니다.

**Syntax**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — 선택적. 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 선택적. N 개의 조건 배열로 람다 함수에 추가 인수를 제공. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

소스 배열의 요소의 곱을 반환하거나, 제공된 경우 람다 결과의 요소의 곱을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Basic example**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**Usage with lambda function**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```
## arrayPushBack {#arrayPushBack}

Introduced in: v1.1

배열의 끝에 하나의 항목을 추가합니다.

**Syntax**

```sql
arrayPushBack(arr, x)
```

**Arguments**

- `arr` — 배열의 끝에 값 `x`를 추가할 배열. [`Array(T)`](/sql-reference/data-types/array)
- `x` — 배열의 끝에 추가할 단일 값. [`Array(T)`](/sql-reference/data-types/array).

:::note
- 숫자 배열에는 숫자만 추가할 수 있으며, 문자열 배열에는 문자열만 추가할 수 있습니다.
- 숫자를 추가할 때 ClickHouse는 자동으로 `x`의 유형을 배열의 데이터 유형에 맞춥니다.
- `NULL`일 수 있습니다. 이 함수는 배열에 `NULL` 요소를 추가하며, 배열 요소의 유형이 `Nullable`로 변환됩니다.

ClickHouse에서 데이터 유형에 대한 자세한 정보는 [Data types](/sql-reference/data-types)를 참조하세요.
:::

**Returned value**

`arr`와 동일하지만 배열 끝에 추가 값 `x`가 있는 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```
## arrayPushFront {#arrayPushFront}

Introduced in: v1.1

배열의 시작에 하나의 요소를 추가합니다.

**Syntax**

```sql
arrayPushFront(arr, x)
```

**Arguments**

- `arr` — 배열의 끝에 값 `x`를 추가할 배열. [`Array(T)`](/sql-reference/data-types/array). 
- `x` — 배열의 시작에 추가할 단일 값. [`Array(T)`](/sql-reference/data-types/array).

:::note
- 숫자 배열에는 숫자만 추가할 수 있으며, 문자열 배열에는 문자열만 추가할 수 있습니다.
- 숫자를 추가할 때 ClickHouse는 자동으로 `x`의 유형을 배열의 데이터 유형에 맞춥니다.
- `NULL`일 수 있습니다. 이 함수는 배열에 `NULL` 요소를 추가하며, 배열 요소의 유형이 `Nullable`로 변환됩니다.

ClickHouse에서 데이터 유형에 대한 자세한 정보는 [Data types](/sql-reference/data-types)를 참조하세요.
:::

**Returned value**

`arr`와 동일하지만 배열 시작에 추가 값 `x`가 있는 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```
## arrayROCAUC {#arrayROCAUC}

Introduced in: v20.4

수신자 조작 특성(ROC) 곡선 아래의 면적을 계산합니다. ROC 곡선은 y축에 진정한 양성 비율(TPR)을, x축에 거짓 양성 비율(FPR)을 모든 임계값에 대해 그린 것입니다. 결과 값은 제로에서 일까지 범위이며, 높은 값일수록 더 나은 모델 성능을 의미합니다.

ROC AUC(간단히 AUC로도 알려짐)는 머신 러닝의 개념입니다. 자세한 내용은 [여기](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [여기](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1), [여기](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)를 참조하세요.

**Syntax**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**Aliases**: `arrayAUC`

**Arguments**

- `scores` — 모델이 제공하는 점수. [`Array((U)Int*)`](/sql-reference/data-types/array) 또는 [`Array(Float*)`](/sql-reference/data-types/array)
- `labels` — 샘플의 레이블, 일반적으로 양성 샘플에 대해 1, 음성 샘플에 대해 0. [`Array((U)Int*)`](/sql-reference/data-types/array) 또는 [`Enum`](/sql-reference/data-types/enum)
- `scale` — 선택적. 정규화된 면적을 반환할지 여부를 결정합니다. false인 경우 TP(진정한 양성) x FP(거짓 양성) 곡선 아래의 면적을 대신 반환합니다. 기본값: true. [`Bool`](/sql-reference/data-types/boolean)
- `partial_offsets` — ROC 곡선 아래의 부분 영역을 계산하기 위한 네 개의 비음수 정수 배열로, 전체 AUC 대신 ROC 공간의 수직 밴드를 생성합니다. 이 옵션은 ROC AUC의 분산 계산에 유용합니다. 배열에는 다음과 같은 요소가 포함되어야 합니다 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [수치][Array](/sql-reference/data-types/array) 비음수 [정수](../data-types/int-uint.md). 선택적.
    - `higher_partitions_tp`: 고득점 파티션에서 양성 레이블의 수.
    - `higher_partitions_fp`: 고득점 파티션에서 음성 레이블의 수.
    - `total_positives`: 전체 데이터 세트의 양성 샘플 총 수.
    - `total_negatives`: 전체 데이터 세트의 음성 샘플 총 수.

:::note
`arr_partial_offsets`가 사용될 때, `arr_scores`와 `arr_labels`는 전체 데이터 세트의 일부만 포함해야 하며, 점수가 특정 범위 내에 있는 데이터의 하위 집합을 포함해야 합니다. 데이터 세트는 연속적인 파르티션으로 나뉘어야 하며, 각 파르티션은 점수가 특정 범위 내에 있는 데이터의 하위 집합을 포함해야 합니다. 예를 들어:
- 하나의 파르티션은 [0, 0.5) 범위의 모든 점수를 포함할 수 있습니다.
- 다른 파르티션은 [0.5, 1.0] 범위의 점수를 포함할 수 있습니다.
:::

**Returned value**

수신자 조작 특성(ROC) 곡선 아래의 면적을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```
## arrayRandomSample {#arrayRandomSample}

Introduced in: v23.10

입력 배열의 `samples` 수 만큼의 무작위 요소로 하위 집합을 반환합니다. `samples`가 입력 배열의 크기를 초과하는 경우, 샘플 크기는 배열 크기로 제한되며, 즉 모든 배열 요소가 반환되지만 그 순서는 보장되지 않습니다. 이 함수는 평면 배열과 중첩 배열 모두를 처리할 수 있습니다.

**Syntax**

```sql
arrayRandomSample(arr, samples)
```

**Arguments**

- `arr` — 요소를 샘플링할 입력 배열 또는 다차원 배열. [`Array(T)`](/sql-reference/data-types/array)
- `samples` — 무작위 샘플에 포함할 요소의 수. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

입력 배열에서 무작위 샘플 요소를 포함하는 배열 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**Using a multidimensional array**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```
## arrayReduce {#arrayReduce}

Introduced in: v1.1

배열 요소에 집계 함수를 적용하고 그 결과를 반환합니다. 집계 함수의 이름은 작은따옴표로 감싸인 문자열로 제공됩니다 `'max'`, `'sum'`. 매개변수 집계 함수를 사용할 때 매개변수는 함수 이름 뒤의 괄호 안에 표시됩니다 `'uniqUpTo(6)'`.

**Syntax**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**Arguments**

- `agg_f` — 상수여야 할 집계 함수의 이름. [`String`](/sql-reference/data-types/string)
- `arr1 [, arr2, ... , arrN)]` — `agg_f`의 인수와 일치하는 N 개의 배열. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

집계 함수의 결과를 반환합니다.

**Examples**

**Usage example**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**Example with aggregate function using multiple arguments**

```sql title=Query
--If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**Example with a parametric aggregate function**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```
## arrayReduceInRanges {#arrayReduceInRanges}

Introduced in: v20.4

주어진 범위 내의 배열 요소에 집계 함수를 적용하고 각 범위에 해당하는 결과를 포함한 배열을 반환합니다. 이 함수는 여러 `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`와 동일한 결과를 반환합니다.

**Syntax**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**Arguments**

- `agg_f` — 사용할 집계 함수의 이름. [`String`](/sql-reference/data-types/string)
- `ranges` — 집계할 범위. 시작할 인덱스인 `i`와 집계할 범위 `r`을 포함하는 튜플 배열 `(i, r)`. [`Array(T)`](/sql-reference/data-types/array) 또는 [`Tuple(T)`](/sql-reference/data-types/tuple)
- `arr1 [, arr2, ... ,arrN)]` — 집계 함수에 대한 N 개의 배열. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

지정된 범위에 대한 집계 함수의 결과를 포함하는 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```
## arrayRemove {#arrayRemove}

Introduced in: v25.11

주어진 값과 같은 모든 요소를 배열에서 제거합니다. NULL은 동일한 것으로 간주됩니다.

**Syntax**

```sql
arrayRemove(arr, elem)
```

**Aliases**: `array_remove`

**Arguments**

- `arr` — Array(T) - `elem` — T 

**Returned value**

소스 배열의 하위 집합을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Example 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**Example 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```
## arrayResize {#arrayResize}

Introduced in: v1.1

배열의 길이를 변경합니다.

**Syntax**

```sql
arrayResize(arr, size[, extender])
```

**Arguments**

- `arr` — 크기를 조정할 배열. [`Array(T)`](/sql-reference/data-types/array)
- `size` — 
- 배열의 새 길이. 배열의 원래 크기보다 `size`가 작은 경우 배열은 오른쪽에서 절단됩니다. 배열의 초기 크기보다 `size`가 큰 경우 배열은 오른쪽으로 `extender` 값이나 배열 항목의 데이터 유형에 대한 기본 값으로 확장됩니다.
 - `extender` — 배열을 확장하는 데 사용할 값. `NULL`일 수 있습니다. 

**Returned value**

길이가 `size`인 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Example 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**Example 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```
## arrayReverse {#arrayReverse}

Introduced in: v1.1

주어진 배열의 요소 순서를 뒤집습니다.

:::note
함수 `reverse(arr)`는 동일한 기능을 수행하지만 배열 외에도 다른 데이터 유형에서 작동합니다.
:::

**Syntax**

```sql
arrayReverse(arr)
```

**Arguments**

- `arr` — 뒤집을 배열. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

역순으로 요소를 포함하는 원래 배열과 동일한 크기의 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```
## arrayReverseFill {#arrayReverseFill}

Introduced in: v20.1

`arrayReverseFill` 함수는 소스 배열을 마지막 요소부터 첫 번째 요소까지 순차적으로 처리하여, 각 위치에서 소스와 조건 배열의 요소를 사용하여 람다 조건을 평가합니다. i 위치에서 조건이 false로 평가되면 함수는 해당 요소를 현재 배열 상태에서 i+1 위치의 요소로 대체합니다. 마지막 요소는 어떤 조건과 관계없이 항상 유지됩니다.

**Syntax**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열. [`Array(T)`](/sql-reference/data-types/array)
- `[, cond1_arr, ... , condN_arr]` — 선택적. N 개의 조건 배열로 람다 함수에 추가 인수를 제공. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

람다 결과로 소스 배열의 요소가 대체된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Example with a single array**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**Example with two arrays**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```
## arrayReverseSort {#arrayReverseSort}

Introduced in: v1.1

배열의 요소를 내림차순으로 정렬합니다. 함수 `f`가 지정된 경우, 제공된 배열은 배열 요소에 적용된 함수의 결과에 따라 정렬되어 정렬된 배열이 뒤집힌 다음 정렬됩니다. `f`가 여러 인수를 수용하는 경우, `arrayReverseSort` 함수는 `func`의 인수에 해당하는 여러 배열을 전달받습니다.

정렬할 배열에 `-Inf`, `NULL`, `NaN`, 또는 `Inf`가 포함되어 있는 경우, 다음과 같은 순서로 정렬됩니다:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort`는 [고차 함수](/sql-reference/functions/overview#higher-order-functions)입니다.

**Syntax**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**Arguments**

- `f(y1[, y2 ... yN])` — 배열 `x`의 요소에 적용할 람다 함수. 
- `arr` — 정렬할 배열. [`Array(T)`](/sql-reference/data-types/array) 
- `arr1, ..., yN` — 선택적. `f`가 여러 인수를 수용하는 경우 N 개의 추가 배열. 

**Returned value**

람다 함수가 제공되지 않은 경우 내림차순으로 정렬된 배열 `x`를 반환하고, 그렇지 않으면 제공된 람다 함수의 논리에 따라 정렬된 배열을 반환한 후 뒤집습니다. [`Array(T)`](/sql-reference/data-types/array).

**Examples**

**Example 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**Example 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```
## arrayReverseSplit {#arrayReverseSplit}

Introduced in: v20.1

소스 배열을 여러 개의 배열로 분할합니다. `func(x[, y1, ..., yN])`가 0이 아닌 값을 반환하면 배열은 해당 요소의 오른쪽에서 분할됩니다. 배열은 마지막 요소 이후에는 분할되지 않습니다.

**Syntax**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**Arguments**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에서 작동하는 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `[, cond1_arr, ... , condN_arr]` — 선택적. N 개의 조건 배열로 람다 함수에 추가 인수를 제공. [`Array(T)`](/sql-reference/data-types/array)

**Returned value**

배열의 배열을 반환합니다. [`Array(Array(T))`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```
## arrayRotateLeft {#arrayRotateLeft}

Introduced in: v23.8

지정된 개수의 요소만큼 배열을 왼쪽으로 회전합니다. `n`의 음수 값은 회전 절대값으로 오른쪽으로 회전하는 것으로 처리됩니다.

**Syntax**

```sql
arrayRotateLeft(arr, n)
```

**Arguments**

- `arr` — 요소를 회전할 배열.[`Array(T)`](/sql-reference/data-types/array). 
- `n` — 회전할 요소의 수. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). 

**Returned value**

지정된 개수의 요소만큼 왼쪽으로 회전된 배열 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**Negative value of n**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```
## arrayRotateRight {#arrayRotateRight}

Introduced in: v23.8

지정된 개수의 요소만큼 배열을 오른쪽으로 회전합니다. `n`의 음수 값은 회전 절대값으로 왼쪽으로 회전하는 것으로 처리됩니다.

**Syntax**

```sql
arrayRotateRight(arr, n)
```

**Arguments**

- `arr` — 요소를 회전할 배열.[`Array(T)`](/sql-reference/data-types/array). 
- `n` — 회전할 요소의 수. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). 

**Returned value**

지정된 개수의 요소만큼 오른쪽으로 회전된 배열 [`Array(T)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**Negative value of n**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

## arrayShiftLeft {#arrayShiftLeft}

Introduced in: v23.8


지정된 수의 요소만큼 배열을 왼쪽으로 이동시킵니다.
새로운 요소는 제공된 인수나 배열 요소 유형의 기본값으로 채워집니다.
요소 수가 음수인 경우, 배열은 오른쪽으로 이동합니다.
    

**구문**

```sql
arrayShiftLeft(arr, n[, default])
```

**인수**

- `arr` — 요소를 이동할 배열입니다. [`Array(T)`](/sql-reference/data-types/array). 
- `n` — 이동할 요소의 수입니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). 
- `default` — 선택 사항입니다. 새로운 요소의 기본값입니다. 

**반환 값**

지정된 수만큼 왼쪽으로 이동한 배열 [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**n의 음수 값**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**기본값 사용하기**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```
## arrayShiftRight {#arrayShiftRight}

Introduced in: v23.8


지정된 수의 요소만큼 배열을 오른쪽으로 이동시킵니다.
새로운 요소는 제공된 인수나 배열 요소 유형의 기본값으로 채워집니다.
요소 수가 음수인 경우, 배열은 왼쪽으로 이동합니다.
    

**구문**

```sql
arrayShiftRight(arr, n[, default])
```

**인수**

- `arr` — 요소를 이동할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `n` — 이동할 요소의 수입니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
- `default` — 선택 사항입니다. 새로운 요소의 기본값입니다. 

**반환 값**

지정된 수만큼 오른쪽으로 이동한 배열 [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**n의 음수 값**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**기본값 사용하기**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```
## arrayShingles {#arrayShingles}

Introduced in: v24.1

샤글의 배열을 생성합니다 (문자열의 n그램과 유사), 즉 입력 배열의 지정된 길이의 연속된 하위 배열입니다.

**구문**

```sql
arrayShingles(arr, l)
```

**인수**

- `arr` — 샤글 배열을 생성할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `l` — 각 샤글의 길이입니다. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

생성된 샤글의 배열 [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```
## arrayShuffle {#arrayShuffle}

Introduced in: v23.2


원래 배열과 동일한 크기의 배열을 반환하고 요소는 무작위로 섞입니다.
요소가 재배치되는 방식은 가능한 모든 조합이 동일한 발생 확률을 갖도록 합니다.

:::note
이 함수는 상수를 물리화하지 않습니다.
:::
    

**구문**

```sql
arrayShuffle(arr [, seed])
```

**인수**

- `arr` — 섞을 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `seed (optional)` — 선택 사항입니다. 랜덤 숫자 생성을 위해 사용할 시드입니다. 제공하지 않으면 무작위로 선택됩니다. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

요소가 섞인 배열 [`Array(T)`](/sql-reference/data-types/array)

**예제**

**시드 없이 예제 (불안정한 결과)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**시드 없이 예제 (안정적인 결과)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```
## arraySimilarity {#arraySimilarity}

Introduced in: v25.4


가중치를 부여한 레벤슈타인 거리 기반으로 두 배열의 유사성을 0에서 1까지 계산합니다.


**구문**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**인수**

- `from` — 첫 번째 배열 [`Array(T)`](/sql-reference/data-types/array)
- `to` — 두 번째 배열 [`Array(T)`](/sql-reference/data-types/array)
- `from_weights` — 첫 번째 배열의 가중치입니다. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
- `to_weights` — 두 번째 배열의 가중치입니다. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)


**반환 값**

가중치를 부여한 레벤슈타인 거리 기반으로 두 배열의 유사성이 0과 1 사이로 반환됩니다 [`Float64`](/sql-reference/data-types/float)

**예제**

**사용 예제**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```
## arraySlice {#arraySlice}

Introduced in: v1.1

`NULL` 요소가 포함된 배열의 슬라이스를 반환합니다.

**구문**

```sql
arraySlice(arr, offset [, length])
```

**인수**

- `arr` — 슬라이스할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `offset` — 배열의 가장자리에서 인덴트입니다. 양수 값은 왼쪽에서의 오프셋을 나타내고 음수 값은 오른쪽에서의 인덴트를 나타냅니다. 배열 항목의 숫자는 `1`부터 시작합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `length` — 필요한 슬라이스의 길이입니다. 음수 값을 지정하면 함수는 열린 슬라이스 `[offset, array_length - length]`를 반환합니다. 값을 생략하면 함수는 슬라이스 `[offset, the_end_of_array]`를 반환합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

지정된 `offset`에서 `length` 요소로 배열의 슬라이스를 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```
## arraySort {#arraySort}

Introduced in: v1.1


제공된 배열의 요소를 오름차순으로 정렬합니다.
람다 함수 `f`가 지정된 경우 정렬 순서는 배열 각 요소에 적용된 람다의 결과에 의해 결정됩니다.
람다가 여러 인수를 받는 경우 `arraySort` 함수는 `f`의 인수에 해당하는 여러 배열을 받습니다.

정렬할 배열이 `-Inf`, `NULL`, `NaN` 또는 `Inf`를 포함하는 경우 다음과 같이 정렬됩니다:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort`는 [고차 함수](/sql-reference/functions/overview#higher-order-functions)입니다.


**구문**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**인수**

- `f(y1[, y2 ... yN])` — 배열 `x`의 요소에 적용할 람다 함수입니다. 
- `arr` — 정렬할 배열입니다. [`Array(T)`](/sql-reference/data-types/array) 
- `arr1, ..., yN` — 선택 사항입니다. `f`가 여러 인수를 수용하는 경우 N개의 추가 배열입니다. 

**반환 값**

람다 함수가 제공되지 않은 경우 오름차순으로 정렬된 배열 `arr`를 반환합니다. 그렇지 않으면 제공된 람다 함수의 논리에 따라 정렬된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array).

**예제**

**예제 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**예제 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**예제 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```
## arraySplit {#arraySplit}

Introduced in: v20.1

소스 배열을 여러 개의 배열로 나눕니다. `func(x [, y1, ..., yN])`이 0이 아닌 값을 반환할 때 배열은 해당 요소의 왼쪽에서 나누어집니다. 배열은 첫 번째 요소 전에는 나누어지지 않습니다.

**구문**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x[, y1, ..., yN])` — 소스 배열(`x`) 및 조건 배열(`y`)의 요소에 작용하는 람다 함수입니다. [람다 함수](/sql-reference/functions/overview#arrow-operator-and-lambda). 
- `source_arr` — 나눌 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array). 
- `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array). 

**반환 값**

배열의 배열을 반환합니다 [`Array(Array(T))`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```
## arraySum {#arraySum}

Introduced in: v21.1


소스 배열의 요소 합계를 반환합니다.

람다 함수 `func`가 지정된 경우 람다 결과의 요소 합계를 반환합니다.
    

**구문**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

- `func(x[, y1, ..., yN])` — 선택 사항입니다. 소스 배열(`x`) 및 조건 배열(`y`)의 요소에 작용하는 람다 함수입니다. [`람다 함수`](/sql-reference/functions/overview#arrow-operator-and-lambda)
- `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열의 요소 합계를 반환하거나 제공된 경우 람다 결과의 합계를 반환합니다.

**예제**

**기본 예제**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**람다 함수 사용 예제**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```
## arraySymmetricDifference {#arraySymmetricDifference}

Introduced in: v25.4

여러 배열을 가져와서 모든 소스 배열에 존재하지 않는 요소가 들어 있는 배열을 반환합니다. 결과는 오직 고유한 값만 포함됩니다.

:::note
두 개 이상의 집합의 대칭 차는 [수학적으로 정의](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)된 바와 같이 홀수 개수의 입력 집합에 존재하는 모든 입력 요소의 집합입니다.
대비적으로, `arraySymmetricDifference` 함수는 입력 집합에 존재하지 않는 입력 요소 세트를 반환합니다.
:::


**구문**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**인수**

- `arrN` — 새로운 배열을 만들기 위한 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array). 

**반환 값**

모든 소스 배열에 존재하지 않는 고유 요소의 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```
## arrayUnion {#arrayUnion}

Introduced in: v24.10

여러 배열을 가져와서 소스 배열 중 하나에 존재하는 모든 요소가 포함된 배열을 반환합니다. 결과는 오직 고유한 값만 포함됩니다.

**구문**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**인수**

- `arrN` — 새로운 배열을 만들기 위한 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열에서 독특한 요소가 포함된 배열을 반환합니다 [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```
## arrayUniq {#arrayUniq}

Introduced in: v1.1


단일 인수가 전달되면 배열에서 서로 다른 요소의 수를 계산합니다.
여러 인수가 전달되면 여러 배열의 일치하는 위치에 있는 요소로 구성된 서로 다른 **튜플** 수를 계산합니다.

예를 들어 `SELECT arrayUniq([1,2], [3,4], [5,6])`는 다음 튜플을 형성합니다:
* 위치 1: (1,3,5)
* 위치 2: (2,4,6)

그런 다음 고유 튜플 수를 계산합니다. 이 경우 `2`가 됩니다.

전달된 모든 배열은 동일한 길이를 가져야 합니다.

:::tip
배열에서 고유 항목 목록을 얻으려면 `arrayReduce('groupUniqArray', arr)`를 사용할 수 있습니다.
:::


**구문**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**인수**

- `arr1` — 고유한 요소 수를 계산할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `[, arr2, ..., arrN]` — 선택 사항입니다. 여러 배열에서 일치하는 위치에 있는 요소의 고유 튜플 수를 계산하는 데 사용되는 추가 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

단일 인수에 대해 고유한
요소의 수를 반환합니다. 여러 인수에 대해 배열 간의 일치하는 위치를 기반으로 만든 고유 튜플 수를 반환합니다.
 [`UInt32`](/sql-reference/data-types/int-uint)

**예제**

**단일 인수**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**여러 인수**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```
## arrayWithConstant {#arrayWithConstant}

Introduced in: v20.1


`length` 길이의 배열을 만들어 상수 `x`로 채웁니다.
    

**구문**

```sql
arrayWithConstant(N, x)
```

**인수**

- `length` — 배열의 요소 수입니다. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `x` — 배열의 `N` 요소 값, 모든 유형입니다. 

**반환 값**

값 `x`가 포함된 `N` 요소의 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```
## arrayZip {#arrayZip}

Introduced in: v20.1

여러 배열을 결합하여 단일 배열로 만듭니다. 결과 배열은 제공된 인수의 나열된 순서에 따라 소스 배열의 해당 요소를 묶어 튜플로 갖습니다.

**구문**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**인수**

- `arr1, arr2, ... , arrN` — 단일 배열로 결합할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열의 요소가 튜플로 묶여 있는 배열을 반환합니다. 튜플의 데이터 유형은 입력 배열의 유형과 동일하며 배열이 전달된 순서와 같습니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```
## arrayZipUnaligned {#arrayZipUnaligned}

Introduced in: v20.1

여러 배열을 결합하여 단일 배열로 만듭니다. 길이가 다른 배열(비정렬 배열)을 허용합니다. 결과 배열은 제공된 인수의 나열된 순서에 따라 소스 배열의 해당 요소를 묶어 튜플로 갖습니다.

**구문**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**인수**

- `arr1, arr2, ..., arrN` — 단일 배열로 결합할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

소스 배열의 요소가 튜플로 묶여 있는 배열을 반환합니다. 튜플의 데이터 유형은 입력 배열의 유형과 동일하며 배열이 전달된 순서와 같습니다. [`Array(T)`](/sql-reference/data-types/array) 또는 [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**예제**

**사용 예제**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```
## countEqual {#countEqual}

Introduced in: v1.1


주어진 배열에서 `x`와 같은 요소의 수를 반환합니다. `arrayCount(elem -> elem = x, arr)`와 동일합니다.

`NULL` 요소는 별도의 값으로 처리됩니다.


**구문**

```sql
countEqual(arr, x)
```

**인수**

- `arr` — 검색할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `x` — 배열에서 세는 값입니다. 모든 유형. 

**반환 값**

배열에서 `x`와 같은 요소의 수를 반환합니다 [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예제**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```
## empty {#empty}

Introduced in: v1.1


입력 배열이 비어 있는지를 확인합니다.

배열은 요소가 전혀 포함되어 있지 않으면 비어 있는 것으로 간주됩니다.

:::note
[`optimize_functions_to_subcolumns` 설정](/operations/settings/settings#optimize_functions_to_subcolumns)을 활성화하여 최적화할 수 있습니다. `optimize_functions_to_subcolumns = 1`이면 이 함수는 전체 배열 열을 읽고 처리하는 대신에 [size0](/sql-reference/data-types/array#array-size) 하위 열만 읽습니다. 쿼리 `SELECT empty(arr) FROM TABLE;`는 `SELECT arr.size0 = 0 FROM TABLE;`로 변환됩니다.
:::

이 함수는 문자열 또는 UUID에도 작동합니다.
    

**구문**

```sql
empty(arr)
```

**인수**

- `arr` — 입력 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

비어 있는 배열의 경우 `1`, 비어 있지 않은 배열의 경우 `0`을 반환합니다 [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예제**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```
## emptyArrayDate {#emptyArrayDate}

Introduced in: v1.1

빈 날짜 배열을 반환합니다.

**구문**

```sql
emptyArrayDate()
```

**인수**

- 없음.

**반환 값**

빈 날짜 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```
## emptyArrayDateTime {#emptyArrayDateTime}

Introduced in: v1.1

빈 날짜와 시간 배열을 반환합니다.

**구문**

```sql
emptyArrayDateTime()
```

**인수**

- 없음.

**반환 값**

빈 날짜와 시간 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```
## emptyArrayFloat32 {#emptyArrayFloat32}

Introduced in: v1.1

빈 Float32 배열을 반환합니다.

**구문**

```sql
emptyArrayFloat32()
```

**인수**

- 없음.

**반환 값**

빈 Float32 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```
## emptyArrayFloat64 {#emptyArrayFloat64}

Introduced in: v1.1

빈 Float64 배열을 반환합니다.

**구문**

```sql
emptyArrayFloat64()
```

**인수**

- 없음.

**반환 값**

빈 Float64 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```
## emptyArrayInt16 {#emptyArrayInt16}

Introduced in: v1.1

빈 Int16 배열을 반환합니다.

**구문**

```sql
emptyArrayInt16()
```

**인수**

- 없음.

**반환 값**

빈 Int16 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```
## emptyArrayInt32 {#emptyArrayInt32}

Introduced in: v1.1

빈 Int32 배열을 반환합니다.

**구문**

```sql
emptyArrayInt32()
```

**인수**

- 없음.

**반환 값**

빈 Int32 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```
## emptyArrayInt64 {#emptyArrayInt64}

Introduced in: v1.1

빈 Int64 배열을 반환합니다.

**구문**

```sql
emptyArrayInt64()
```

**인수**

- 없음.

**반환 값**

빈 Int64 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```
## emptyArrayInt8 {#emptyArrayInt8}

Introduced in: v1.1

빈 Int8 배열을 반환합니다.

**구문**

```sql
emptyArrayInt8()
```

**인수**

- 없음.

**반환 값**

빈 Int8 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```
## emptyArrayString {#emptyArrayString}

Introduced in: v1.1

빈 문자열 배열을 반환합니다.

**구문**

```sql
emptyArrayString()
```

**인수**

- 없음.

**반환 값**

빈 문자열 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```
## emptyArrayToSingle {#emptyArrayToSingle}

Introduced in: v1.1


빈 배열을 수용하고 기본값과 같은 하나의 요소 배열을 반환합니다.
    

**구문**

```sql
emptyArrayToSingle(arr)
```

**인수**

- `arr` — 빈 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

배열의 기본 유형의 단일 값이 포함된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**기본 예제**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```
## emptyArrayUInt16 {#emptyArrayUInt16}

Introduced in: v1.1

빈 UInt16 배열을 반환합니다.

**구문**

```sql
emptyArrayUInt16()
```

**인수**

- 없음.

**반환 값**

빈 UInt16 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```
## emptyArrayUInt32 {#emptyArrayUInt32}

Introduced in: v1.1

빈 UInt32 배열을 반환합니다.

**구문**

```sql
emptyArrayUInt32()
```

**인수**

- 없음.

**반환 값**

빈 UInt32 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```
## emptyArrayUInt64 {#emptyArrayUInt64}

Introduced in: v1.1

빈 UInt64 배열을 반환합니다.

**구문**

```sql
emptyArrayUInt64()
```

**인수**

- 없음.

**반환 값**

빈 UInt64 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```
## emptyArrayUInt8 {#emptyArrayUInt8}

Introduced in: v1.1

빈 UInt8 배열을 반환합니다.

**구문**

```sql
emptyArrayUInt8()
```

**인수**

- 없음.

**반환 값**

빈 UInt8 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```
## has {#has}

Introduced in: v1.1

지정된 요소가 배열에 포함되어 있는지를 반환합니다.

**구문**

```sql
has(arr, x)
```

**인수**

- `arr` — 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `x` — 배열에서 검색할 값입니다. 

**반환 값**

지정된 요소가 배열에 포함되어 있으면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**기본 사용법**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**찾을 수 없음**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```
## hasAll {#hasAll}

Introduced in: v1.1


한 배열이 다른 배열의 부분집합인지 확인합니다.

- 빈 배열은 어떤 배열의 부분집합입니다.
- `Null`은 값으로 처리됩니다.
- 두 배열의 값 순서는 중요하지 않습니다.


**구문**

```sql
hasAll(set, subset)
```

**인수**

- `set` — 요소 집합을 가진 임의의 유형의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `subset` — `set`과 공통 슈퍼타입을 공유하는 임의의 유형의 배열로, `set`의 부분집합인지 테스트할 요소를 포함합니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

- `1`, 만약 `set`이 `subset`의 모든 요소를 포함하는 경우.
- `0`, 그렇지 않은 경우.

셋과 서브셋 요소가 공통 슈퍼타입을 공유하지 않을 경우 `NO_COMMON_TYPE` 예외가 발생합니다.

**예제**

**빈 배열**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**NULL 값을 포함하는 배열**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**다른 유형의 값을 포함하는 배열**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**문자열 값을 포함하는 배열**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**공통 유형이 없는 배열**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Raises a NO_COMMON_TYPE exception
```

**배열의 배열**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```
## hasAny {#hasAny}

Introduced in: v1.1


두 배열이 어떤 요소에 의해 교차하는지 확인합니다.

- `Null`은 값으로 처리됩니다.
- 두 배열의 값 순서는 중요하지 않습니다.


**구문**

```sql
hasAny(arr_x, arr_y)
```

**인수**

- `arr_x` — 요소 집합을 가진 임의의 유형의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `arr_y` — 배열 `arr_x`와 공통 슈퍼타입을 공유하는 임의의 유형의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

- `1`, 만약 `arr_x`와 `arr_y`가 적어도 하나의 공통 요소가 있는 경우.
- `0`, 그렇지 않은 경우.

두 배열의 어떤 요소가 공통 슈퍼타입을 공유하지 않을 경우 `NO_COMMON_TYPE` 예외가 발생합니다.

**예제**

**하나의 배열이 비어 있음**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**NULL 값을 포함하는 배열**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**다른 유형의 값을 포함하는 배열**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**공통 유형이 없는 배열**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

**배열의 배열**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```
## hasSubstr {#hasSubstr}

Introduced in: v20.6


모든 `array2`의 요소가 정확히 같은 순서로 `array1`에 나타나는지를 확인합니다.
따라서 함수는 `array1 = prefix + array2 + suffix`인 경우에만 `1`을 반환합니다.

다시 말해, 함수는 모든 `array2`의 요소가 `hasAll` 함수와 같이 `array1`에 포함되는지를 확인합니다.
추가로 두 배열 모두에서 순서가 일치하는지를 확인합니다.

- 만약 `array2`가 비어 있으면 함수는 `1`을 반환합니다.
- `Null`은 값으로 처리됩니다. 즉, `hasSubstr([1, 2, NULL, 3, 4], [2,3])`는 `0`을 반환하지만, `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])`는 `1`을 반환합니다.
- 두 배열의 값 순서는 중요합니다.

어떤 요소가 공통 슈퍼타입을 공유하지 않을 경우 `NO_COMMON_TYPE` 예외가 발생합니다.


**구문**

```sql
hasSubstr(arr1, arr2)
```

**인수**

- `arr1` — 요소 집합을 가진 임의의 유형의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `arr2` — 요소 집합을 가진 임의의 유형의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

배열 `arr1`이 `arr2`를 포함하면 `1`을 반환합니다. 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**두 배열이 모두 비어 있음**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**NULL 값을 포함하는 배열**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**다른 유형의 값을 포함하는 배열**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**문자열을 포함하는 배열**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**유효한 순서의 배열**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**유효하지 않은 순서의 배열**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**배열의 배열**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**공통 유형이 없는 배열**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```
## indexOf {#indexOf}

Introduced in: v1.1


값 'x'가 배열에 있을 경우 (1부터 시작) 해당 요소의 인덱스를 반환합니다.
배열에 검색된 값이 포함되어 있지 않으면 함수는 `0`을 반환합니다.

`NULL`로 설정된 요소는 일반 값처럼 처리됩니다.
    

**구문**

```sql
indexOf(arr, x)
```

**인수**

- `arr` — `x`를 찾기 위해 검색할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `x` — 인덱스를 반환할 `arr`에서 첫 번째 일치하는 요소의 값입니다. [`UInt64`](/sql-reference/data-types/int-uint)


**반환 값**

배열 `arr`에 첫 번째 `x`의 인덱스(1부터 시작)를 반환합니다. 존재하지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**기본 예제**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**NULL이 있는 배열**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```
## indexOfAssumeSorted {#indexOfAssumeSorted}

Introduced in: v24.12


값 'x'가 배열에 있을 경우 (1부터 시작) 해당 요소의 인덱스를 반환합니다.
배열에 검색된 값이 포함되어 있지 않으면 함수는 `0`을 반환합니다.

:::note
`indexOf` 함수와 달리, 이 함수는 배열이 오름차순으로 정렬되어 있다고 가정합니다. 배열이 정렬되지 않은 경우 결과는 정의되어 있지 않습니다.
:::
    

**구문**

```sql
indexOfAssumeSorted(arr, x)
```

**인수**

- `arr` — 검색할 정렬된 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
- `x` — 정렬된 `arr`에서 인덱스를 반환할 첫 번째 일치하는 요소의 값입니다. [`UInt64`](/sql-reference/data-types/int-uint)


**반환 값**

배열 `arr`에 첫 번째 `x`의 인덱스(1부터 시작)를 반환합니다. 존재하지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**기본 예제**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```
## length {#length}

Introduced in: v1.1


문자열 또는 배열의 길이를 계산합니다.

- 문자열 또는 FixedString 인수에 대해: 문자열의 바이트 수를 계산합니다.
- 배열 인수에 대해: 배열의 요소 수를 계산합니다.
- FixedString 인수에 적용되는 경우 함수는 상수 표현식입니다.

문자열의 바이트 수는 유니코드 "코드 포인트" 수와 같지 않으며, 유니코드 "그래픽 클러스터" 수 (일반적으로 "문자"라고 부르는)와 같지 않습니다. 또한 가시적인 문자열 너비와도 같지 않습니다.

문자열에 ASCII NULL 바이트를 포함하는 것은 허용되며, 이 역시 계산됩니다.
    

**구문**

```sql
length(x)
```

**별칭**: `OCTET_LENGTH`

**인수**

- `x` — 바이트 수(문자열/FixedString에 대해) 또는 요소 수(배열에 대해)를 계산할 값입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring) 또는 [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

문자열/FixedString `x`의 바이트 수 / 배열 `x`의 요소 수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**문자열 예제**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**배열 예제**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**constexpr 예제**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**unicode 예제**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ascii_vs_utf8 예제**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```
## notEmpty {#notEmpty}

Introduced in: v1.1


입력 배열이 비어 있지 않은지를 확인합니다.

배열은 최소한 하나의 요소가 포함된 경우 비어 있지 않은 것으로 간주됩니다.

:::note
[`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns) 설정을 활성화하여 최적화할 수 있습니다. `optimize_functions_to_subcolumns = 1`이면 이 함수는 전체 배열 열을 읽고 처리하는 대신에 [size0](/sql-reference/data-types/array#array-size) 하위 열만 읽습니다. 쿼리 `SELECT notEmpty(arr) FROM table`는 `SELECT arr.size0 != 0 FROM TABLE`로 변환됩니다.
:::

이 함수는 문자열이나 UUID에도 작동합니다.
    

**구문**

```sql
notEmpty(arr)
```

**인수**

- `arr` — 입력 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

비어 있지 않은 배열의 경우 `1`, 비어 있는 배열의 경우 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예제**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```
## range {#range}

Introduced in: v1.1


`start`에서 `end - 1`까지의 숫자 배열을 `step`에 따라 반환합니다.

지원되는 유형은 다음과 같습니다:
- `UInt8/16/32/64`
- `Int8/16/32/64`

- 모든 인수 `start`, `end`, `step`은 위의 지원되는 유형 중 하나여야 합니다. 반환되는 배열의 요소는 인수의 슈퍼타입이 됩니다.
- 설정 [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block)에서 지정된 요소 수를 초과하는 길이의 배열을 반환하면 예외가 발생합니다.
- Nullable(nothing) 유형의 인수가 있으면 `NULL`이 반환됩니다. 인수가 `NULL` 값(Nullable(T) 유형)을 가지면 예외가 발생합니다.
    

**구문**

```sql
range([start, ] end [, step])
```

**인수**

- `start` — 선택 사항입니다. 배열의 첫 번째 요소입니다. `step`을 사용하는 경우 필수입니다. 기본값: `0`. 
- `end` — 필수입니다. 배열이 구성되는 숫자입니다. 
- `step` — 선택 사항입니다. 배열의 각 요소 간의 증가 단계를 결정합니다. 기본값: `1`. 

**반환 값**

`start`에서 `end - 1`까지의 숫자 배열을 `step`에 따라 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```
## replicate {#replicate}

Introduced in: v1.1


단일 값을 가진 배열을 만듭니다.


**구문**

```sql
replicate(x, arr)
```

**인수**

- `x` — 결과 배열을 채우기 위한 값입니다. [`Any`](/sql-reference/data-types)
- `arr` — 배열입니다. [`Array(T)`](/sql-reference/data-types/array)


**반환 값**

값 `x`로 채워진 `arr`와 동일한 길이의 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```
## reverse {#reverse}

Introduced in: v1.1

입력 배열의 요소 또는 입력 문자열의 문자의 순서를 반전시킵니다.

**Syntax**

```sql
reverse(arr | str)
```

**Arguments**

- `arr | str` — 소스 배열 또는 문자열. [`Array(T)`](/sql-reference/data-types/array) 또는 [`String`](/sql-reference/data-types/string)


**Returned value**

요소 또는 문자의 순서가 반전된 배열 또는 문자열을 반환합니다.

**Examples**

**Reverse array**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**Reverse string**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```



<!--AUTOGENERATED_END-->
## Distance functions {#distance-functions}

모든 지원되는 함수는 [distance functions documentation](../../sql-reference/functions/distance-functions.md)에 설명되어 있습니다.

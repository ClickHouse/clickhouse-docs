---
description: '배열 함수(Array Functions) 관련 문서'
sidebar_label: '배열'
slug: /sql-reference/functions/array-functions
title: '배열 함수'
doc_type: 'reference'
---

# 배열 함수 \{#array-functions\}

{/* 
  아래 태그 안의 내용은 문서 프레임워크가 빌드될 때 
  system.functions에서 생성된 문서로 대체됩니다. 태그를 수정하거나 제거하지 마십시오.
  자세한 내용은 https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md 를 참조하십시오.
  */ }

{/*AUTOGENERATED_START*/ }


## array \{#array\}

도입: v1.1

함수 인수를 사용해 배열을 생성합니다.

인수는 상수여야 하며, 공통 상위 타입을 공유해야 합니다.
어떤 타입의 배열을 생성할지 알 수 있도록 최소 하나의 인수를 전달해야 합니다.
따라서 이 함수를 사용해 빈 배열을 생성할 수 없습니다. 빈 배열을 생성하려면 `emptyArray*` 함수를 사용하십시오.

동일한 기능을 사용하려면 `[ ]` 연산자를 사용할 수 있습니다.

**구문**

```sql
array(x1 [, x2, ..., xN])
```

**인수**

* `x1` — 임의의 타입 T의 상수 값입니다. 이 인수만 제공되면 배열의 타입은 T가 됩니다. - `[, x2, ..., xN]` — `x1`과 공통 상위 타입을 공유하는 추가 상수 값 N개입니다.

**반환 값**

전달된 인수들의 가장 작은 공통 타입 T를 요소 타입으로 갖는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**올바른 사용 예**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**잘못된 사용법**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```


## arrayAUCPR \{#arrayAUCPR\}

도입 버전: v20.4

precision-recall(PR) 곡선 아래의 면적을 계산합니다.
precision-recall 곡선은 모든 임계값에서 y축에 precision, x축에 recall을 표시하여 그립니다.
결과 값은 0에서 1 사이이며, 값이 클수록 더 나은 모델 성능을 의미합니다.
PR AUC는 불균형 데이터셋에서 특히 유용하며, 이러한 경우 ROC AUC와 비교했을 때 성능을 더 명확하게 비교할 수 있습니다.
자세한 내용은 [여기](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [여기](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1), [여기](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)를 참고하십시오.

**구문**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**별칭(Aliases)**: `arrayPRAUC`

**인수(Arguments)**

* `cores` — 예측 모델이 제공하는 점수입니다. [`Array((U)Int*)`](/sql-reference/data-types/array) 또는 [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — 샘플의 레이블입니다. 일반적으로 양성 샘플은 1, 음성 샘플은 0입니다. [`Array((U)Int*)`](/sql-reference/data-types/array) 또는 [`Array(Enum)`](/sql-reference/data-types/array)
* `partial_offsets` —
* 선택 사항입니다. 전체 AUC 대신 PR 곡선 아래의 일부 영역(PR 공간의 수직 밴드에 해당)을 계산하기 위한, 세 개의 음이 아닌 정수로 구성된 [`Array(T)`](/sql-reference/data-types/array)입니다. 이 옵션은 PR AUC를 분산 방식으로 계산할 때 유용합니다. 배열에는 다음 요소들이 포함되어야 합니다. [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`].
  * `higher_partitions_tp`: 더 높은 점수를 가진 파티션에서의 양성 레이블 개수입니다.
  * `higher_partitions_fp`: 더 높은 점수를 가진 파티션에서의 음성 레이블 개수입니다.
  * `total_positives`: 전체 데이터셋에서의 양성 샘플 총 개수입니다.

:::note
`arr_partial_offsets`를 사용하는 경우 `arr_scores`와 `arr_labels`는 전체 데이터셋 중 점수 구간 하나에 해당하는 부분만을 포함하는 파티션이어야 합니다.
데이터셋은 인접한 파티션들로 나누어져야 하며, 각 파티션은 점수가 특정 구간에 속하는 데이터의 부분집합을 포함해야 합니다.
예를 들면 다음과 같습니다.

* 하나의 파티션은 [0, 0.5) 구간의 모든 점수를 포함할 수 있습니다.
* 다른 파티션은 [0.5, 1.0] 구간의 점수를 포함할 수 있습니다.
  :::

**반환 값**

정밀도-재현율(PR) 곡선 아래의 면적을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```


## arrayAll \{#arrayAll\}

도입된 버전: v1.1

람다 `func(x [, y1, y2, ... yN])`가 모든 요소에 대해 `true`를 반환하면 `1`을 반환합니다. 그렇지 않으면 `0`을 반환합니다.

**구문**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소에 적용되는 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — 선택 사항입니다. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

람다 함수가 모든 요소에 대해 true를 반환하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**모든 요소가 일치하는 경우**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**모든 요소가 일치하는 것은 아닙니다**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```


## arrayAvg \{#arrayAvg\}

도입 버전: v21.1

소스 배열 요소들의 평균을 반환합니다.

람다 FUNCTION `func`를 지정하면, 해당 람다 결과 요소들의 평균을 반환합니다.

**구문**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 선택 사항입니다. 소스 배열(`x`)과 조건 배열들(`y`)의 요소에 적용되는 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

소스 배열 요소의 평균 또는 람다 함수를 사용하는 경우 람다 결과 요소의 평균을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예제**

**기본 예제**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**lambda 함수와 함께 사용하는 방법**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```


## arrayCompact \{#arrayCompact\}

도입된 버전: v20.1

`null` 값을 포함하여 배열에서 연속된 중복 요소를 제거합니다. 결과 배열의 값 순서는 원본 배열에서의 순서를 유지합니다.

**구문**

```sql
arrayCompact(arr)
```

**인수**

* `arr` — 중복을 제거할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

중복된 값이 제거된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```


## arrayConcat \{#arrayConcat\}

도입 버전: v1.1

인수로 전달된 배열을 결합합니다.

**구문**

```sql
arrayConcat(arr1 [, arr2, ... , arrN])
```

**인자**

* `arr1 [, arr2, ... , arrN]` — 연결할 N개의 배열. [`Array(T)`](/sql-reference/data-types/array)

**반환값**

제공된 배열 인자들을 하나로 결합한 단일 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```response title=Response
[1, 2, 3, 4, 5, 6]
```


## arrayCount \{#arrayCount\}

도입 버전: v1.1

`func(arr1[i], ..., arrN[i])`가 true를 반환하는 요소의 개수를 반환합니다.
`func`가 지정되지 않으면 배열에서 0이 아닌 요소의 개수를 반환합니다.

`arrayCount`는 [고차 함수](/sql-reference/functions/overview#higher-order-functions)입니다.

**구문**

```sql
arrayCount([func, ] arr1, ...)
```

**인자**

* `func` — 선택적입니다. 배열의 각 요소에 적용할 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1, ..., arrN` — N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

`func`이 true를 반환하는 요소의 개수를 반환합니다. `func`을(를) 지정하지 않으면 배열에서 0이 아닌 요소의 개수를 반환합니다. [`UInt32`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayCount(x -> (x % 2), groupArray(number)) FROM numbers(10)
```

```response title=Response
5
```


## arrayCumSum \{#arrayCumSum\}

도입된 버전: v1.1

소스 배열의 각 요소에 대한 부분 합(누적 합)을 앞에서부터 계산한 결과를 배열로 반환합니다. lambda FUNCTION이 지정되면, 각 위치의 배열 요소에 이 lambda를 적용한 결과를 사용하여 합을 계산합니다.

**구문**

```sql
arrayCumSum([func,] arr1[, arr2, ... , arrN])
```

**인수**

* `func` — 선택 사항입니다. 각 위치의 배열 요소에 적용할 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — 숫자 값으로 이루어진 원본 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — 선택 사항입니다. 지정된 경우 람다 함수의 인수로 전달되는, 동일한 크기의 추가 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

원본 배열 각 요소의 부분합으로 이루어진 배열을 반환합니다. 결과 타입은 입력 배열의 숫자 타입과 일치합니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**기본 사용법**

```sql title=Query
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```response title=Response
[1, 2, 3, 4]
```

**람다와 함께**

```sql title=Query
SELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res
```

```response title=Response
[2, 6, 12]
```


## arrayCumSumNonNegative \{#arrayCumSumNonNegative\}

도입된 버전: v18.12

소스 배열의 요소들에 대한 부분합(누적합)으로 구성된 배열을 반환하며, 누적합이 음수가 되는 경우에는 0으로 대체합니다. 람다 FUNCTION이 지정된 경우, 각 위치의 배열 요소에 람다를 적용한 결과를 사용하여 합을 계산합니다.

**구문**

```sql
arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])
```

**인수**

* `func` — 선택 사항입니다. 각 위치에 있는 배열 요소에 적용할 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1` — 숫자 값을 담고 있는 원본 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[arr2, ..., arrN]` — 선택 사항입니다. 지정된 경우, 람다 함수의 인수로 전달되는 동일한 크기의 추가 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

원본 배열의 요소에 대한 부분합으로 구성된 배열을 반환하며, 누적합이 음수가 되는 경우 해당 값은 0으로 대체됩니다. 결과 타입은 입력 배열의 숫자 타입과 동일합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**기본 사용법**

```sql title=Query
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```response title=Response
[1, 2, 0, 1]
```

**람다 사용 시**

```sql title=Query
SELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res
```

```response title=Response
[2, 0, 6]
```


## arrayDifference \{#arrayDifference\}

도입된 버전: v1.1

배열에서 인접한 요소들 사이의 차이를 계산합니다.
결과 배열의 첫 번째 요소는 0이고, 두 번째는 `arr[1] - arr[0]`, 세 번째는 `arr[2] - arr[1]`와 같이 계산됩니다.
결과 배열의 요소 타입은 뺄셈 연산에 대한 타입 추론 규칙에 따라 결정됩니다(예: `UInt8` - `UInt8` = `Int16`).

**구문**

```sql
arrayDifference(arr)
```

**인수**

* `arr` — 인접한 요소 간의 차이를 계산할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환값**

인접한 배열 요소 간의 차이로 이루어진 배열을 반환합니다. [`UInt*`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayDifference([1, 2, 3, 4]);
```

```response title=Response
[0,1,1,1]
```

**결과 타입이 Int64일 때 발생하는 오버플로우 예시**

```sql title=Query
SELECT arrayDifference([0, 10000000000000000000]);
```

```response title=Response
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```


## arrayDistinct \{#arrayDistinct\}

도입 버전: v1.1

배열에서 서로 다른 요소만을 포함하는 배열을 반환합니다.

**구문**

```sql
arrayDistinct(arr)
```

**인수**

* `arr` — 서로 다른 요소를 추출할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

서로 다른 요소만 포함하는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```


## arrayDotProduct \{#arrayDotProduct\}

도입 버전: v23.5

두 배열의 내적(dot product)을 반환합니다.

:::note
두 벡터의 크기는 같아야 합니다. Array와 Tuple에는 서로 다른 타입의 요소가 함께 포함될 수도 있습니다.
:::

**구문**

```sql
arrayDotProduct(v1, v2)
```

**인수**

* `v1` — 첫 번째 벡터. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) 또는 [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)
* `v2` — 두 번째 벡터. [`Array((U)Int* | Float* | Decimal)`](/sql-reference/data-types/array) 또는 [`Tuple((U)Int* | Float* | Decimal)`](/sql-reference/data-types/tuple)

**반환값**

두 벡터의 내적(dot product)입니다.

:::note
반환 타입은 인수의 타입에 따라 결정됩니다. Array 또는 Tuple에 서로 다른 타입의 요소가 섞여 있는 경우 결과 타입은 상위 타입(supertype)이 됩니다.
:::

[`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)

**예제**

**Array 예제**

```sql title=Query
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

```response title=Response
32    UInt16
```

**튜플 예제**

```sql title=Query
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

```response title=Response
32    Float64
```


## arrayElement \{#arrayElement\}

도입 버전: v1.1

`n`이 임의의 정수 타입일 수 있을 때, 주어진 배열에서 인덱스 `n`에 해당하는 요소를 가져옵니다. 인덱스가 배열의 범위를 벗어나면 기본값(숫자의 경우 0, 문자열의 경우 빈 문자열 등)을 반환합니다. 단, 상수가 아닌 배열 인자와 상수 인덱스 0이 함께 사용되는 경우는 예외이며, 이때는 `Array indices are 1-based` 오류가 발생합니다.

:::note
ClickHouse의 배열은 1부터 시작하는 인덱스를 사용합니다.
:::

음수 인덱스도 지원합니다. 이 경우 배열의 끝에서부터 센 인덱스를 사용하여 해당 요소를 선택합니다. 예를 들어 `arr[-1]`은 배열의 마지막 요소입니다.

연산자 `[n]`은 동일한 기능을 제공합니다.

**구문**

```sql
arrayElement(arr, n)
```

**매개변수**

* `arr` — 검색할 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `n` — 가져올 요소의 위치입니다. [`(U)Int*`](/sql-reference/data-types/int-uint).

**반환 값**

제공된 배열 매개변수로부터 하나로 결합된 단일 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**음수 인덱스**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**[n] 표기법 사용**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**배열 범위를 벗어난 인덱스**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```


## arrayElementOrNull \{#arrayElementOrNull\}

도입 버전: v1.1

`n`이 어떤 정수형 타입이든 될 수 있는 인덱스일 때, 지정된 배열에서 인덱스 `n`에 있는 요소를 가져옵니다.
인덱스가 배열의 범위를 벗어나는 경우에는 기본값 대신 `NULL`을 반환합니다.

:::note
ClickHouse에서 배열 인덱스는 1부터 시작합니다.
:::

음수 인덱스도 지원합니다. 이 경우 끝에서부터 번호를 매겨 해당 요소를 선택합니다. 예를 들어, `arr[-1]`은 배열의 마지막 요소입니다.

**구문**

```sql
arrayElementOrNull(arrays)
```

**인자**

* `arrays` — 임의 개수의 배열 인자입니다. [`Array`](/sql-reference/data-types/array)

**반환 값**

제공된 배열 인자들을 하나로 결합한 단일 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**음수 인덱스**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**배열 범위를 벗어난 인덱스**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```


## arrayEnumerate \{#arrayEnumerate\}

도입 버전: v1.1

배열 `[1, 2, 3, ..., length (arr)]`을 반환합니다.

이 함수는 일반적으로 [`ARRAY JOIN`](/sql-reference/statements/select/array-join) 절과 함께 사용됩니다. `ARRAY JOIN`을 적용한 후 각 배열마다 한 번만 어떤 값을 계산할 수 있도록 해 줍니다.
이 함수는 고차 함수에서도 사용할 수 있습니다. 예를 들어, 조건을 만족하는 요소의 배열 인덱스를 구하는 데 사용할 수 있습니다.

**구문**

```sql
arrayEnumerate(arr)
```

**매개변수**

* `arr` — 열거할 배열입니다. [`Array`](/sql-reference/data-types/array)

**반환 값**

배열 `[1, 2, 3, ..., length (arr)]`를 반환합니다. [`Array(UInt32)`](/sql-reference/data-types/array)

**예제**

**ARRAY JOIN을 사용한 기본 예제**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```


## arrayEnumerateDense \{#arrayEnumerateDense\}

도입 버전: v18.12

원본 배열과 동일한 크기의 배열을 반환하며, 각 요소가 원본 배열에서 처음 나타나는 위치를 표시합니다.

**구문**

```sql
arrayEnumerateDense(arr)
```

**인수**

* `arr` — 열거할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

원본 배열 [`Array(T)`](/sql-reference/data-types/array)에서 각 요소가 처음 등장하는 위치를 나타내는, `arr`와 동일한 크기의 배열을 반환합니다.

**예제**

**사용 예제**

```sql title=Query
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

```response title=Response
[1,2,1,3]
```


## arrayEnumerateDenseRanked \{#arrayEnumerateDenseRanked\}

도입된 버전: v20.1

원본 배열과 동일한 크기의 배열을 반환하며, 각 요소가 원본 배열에서 처음 나타나는 위치를 표시합니다. 배열 내부를 얼마나 깊이 탐색할지 지정할 수 있어, 다차원 배열을 열거할 수 있습니다.

**구문**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**인수**

* `clear_depth` — 지정한 수준의 요소를 개별적으로 번호를 매깁니다. `max_arr_depth` 이하이어야 합니다. [`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — 열거할 N차원 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — 유효한 최대 깊이입니다. `arr`의 깊이 이하여야 합니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값**

원본 배열에서 각 요소가 처음 나타나는 위치를 나타내는 배열을 반환합니다. [`Array`](/sql-reference/data-types/array)

**예시**

**기본 사용 방법**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result is identical to what arrayEnumerateDense would give.

SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

```response title=Response
[1,2,1,3]
```

**다차원 배열과 함께 사용하기**

```sql title=Query
-- In this example, arrayEnumerateDenseRanked is used to obtain an array indicating, for each element of the
-- multidimensional array, what its position is among elements of the same value.
-- For the first row of the passed array, [10, 10, 30, 20], the corresponding first row of the result is [1, 1, 2, 3],
-- indicating that 10 is the first number encountered in position 1 and 2, 30 the second number encountered in position 3
-- and 20 is the third number encountered in position 4.
-- For the second row, [40, 50, 10, 30], the corresponding second row of the result is [4,5,1,2], indicating that 40
-- and 50 are the fourth and fifth numbers encountered in position 1 and 2 of that row, that another 10
-- (the first encountered number) is in position 3 and 30 (the second number encountered) is in the last position.

SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1,1,2,3],[4,5,1,2]]
```

**clear&#95;depth를 증가시킨 예시**

```sql title=Query
-- Changing clear_depth=2 results in the enumeration occurring separately for each row anew.

SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```

```response title=Response
[[1, 1, 2, 3], [1, 2, 3, 4]]
```


## arrayEnumerateUniq \{#arrayEnumerateUniq\}

도입된 버전: v1.1

원본 배열과 동일한 크기의 배열을 반환하며, 각 요소에 대해 동일한 값을 가진 요소들 중에서 해당 요소의 위치를 나타냅니다.

이 함수는 `ARRAY JOIN` 및 배열 요소 집계를 사용할 때 유용합니다.

이 함수는 동일한 크기의 여러 배열을 인수로 받을 수 있습니다. 이 경우, 모든 배열에서 같은 위치에 있는 요소들로 이루어진 튜플을 기준으로 고유성이 판단됩니다.

**구문**

```sql
arrayEnumerateUniq(arr1[, arr2, ... , arrN])
```

**인자**

* `arr1` — 처리할 첫 번째 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `arr2, ...` — 선택 사항입니다. 튜플의 고유성을 위해 동일한 크기의 추가 배열입니다. [`Array(UInt32)`](/sql-reference/data-types/array)

**반환 값**

각 요소가 동일한 값 또는 튜플을 가진 요소들 중에서의 위치(순번)를 나타내는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**기본 사용법**

```sql title=Query
SELECT arrayEnumerateUniq([10, 20, 10, 30]);
```

```response title=Response
[1, 1, 2, 1]
```

**여러 개의 배열**

```sql title=Query
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);
```

```response title=Response
[1,2,1,1,2,1]
```

**ARRAY JOIN을 이용한 집계**

```sql title=Query
-- Each goal ID has a calculation of the number of conversions (each element in the Goals nested data structure is a goal that was reached, which we refer to as a conversion)
-- and the number of sessions. Without ARRAY JOIN, we would have counted the number of sessions as sum(Sign). But in this particular case,
-- the rows were multiplied by the nested Goals structure, so in order to count each session one time after this, we apply a condition to the
-- value of the arrayEnumerateUniq(Goals.ID) function.

SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```response title=Response
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```


## arrayEnumerateUniqRanked \{#arrayEnumerateUniqRanked\}

도입된 버전: v20.1

원본 배열과 동일한 차원의 배열(또는 다차원 배열)을 반환하며,
각 요소에 대해 동일한 값을 가진 요소들 사이에서 해당 요소의 위치(순서)를 나타냅니다.
배열 내부를 얼마나 깊이까지 탐색할지 지정하여 다차원 배열을 열거할 수 있도록 합니다.

**구문**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**인자**

* `clear_depth` — 지정된 레벨의 요소를 별도로 구분하여 나열합니다. `max_arr_depth` 이하의 양의 정수입니다. [`UInt*`](/sql-reference/data-types/int-uint)
* `arr` — 나열할 N차원 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `max_array_depth` — 최대 유효 깊이입니다. `arr`의 깊이 이하의 양의 정수입니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값**

`arr`와 동일한 크기의 N차원 배열을 반환하며, 각 요소는 동일한 값을 가진 요소들 사이에서 해당 요소의 위치를 나타냅니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**예시 1**

```sql title=Query
-- With clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniq would give for the same array.

SELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);
```

```response title=Response
[1, 1, 2]
```

**예제 2**

```sql title=Query
-- with clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked
-- is identical to that which arrayEnumerateUniqwould give for the same array.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);", "[[1, 1, 1], [2, 3, 2], [2]]
```

```response title=Response
[1, 1, 2]
```

**예제 3**

```sql title=Query
-- In this example, arrayEnumerateUniqRanked is used to obtain an array indicating,
-- for each element of the multidimensional array, what its position is among elements
-- of the same value. For the first row of the passed array, [1, 2, 3], the corresponding
-- result is [1, 1, 1], indicating that this is the first time 1, 2 and 3 are encountered.
-- For the second row of the provided array, [2, 2, 1], the corresponding result is [2, 3, 3],
-- indicating that 2 is encountered for a second and third time, and 1 is encountered
-- for the second time. Likewise, for the third row of the provided array [3] the
-- corresponding result is [2] indicating that 3 is encountered for the second time.

SELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);
```

```response title=Response
[[1, 1, 1], [2, 3, 2], [2]]
```

**예제 4**

```sql title=Query
-- Changing clear_depth=2, results in elements being enumerated separately for each row.
SELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);
```

```response title=Response
[[1, 1, 1], [1, 2, 1], [1]]
```


## arrayExcept \{#arrayExcept\}

도입된 버전: v25.9

`source`에는 존재하지만 `except`에는 존재하지 않는 요소만을 포함하는 배열을 반환하며, 원래 순서를 유지합니다.

이 함수는 두 배열 간의 차집합 연산을 수행합니다. `source`의 각 요소에 대해, 해당 요소가 `except`에 존재하는지(정확한 비교 사용) 확인합니다. 존재하지 않으면 그 요소를 결과에 포함합니다.

이 연산에는 다음과 같은 특성이 있습니다:

1. `source`의 요소 순서는 유지됩니다.
2. `except`에 존재하지 않는 경우 `source`의 중복 요소는 그대로 유지됩니다.
3. NULL은 별도의 값으로 처리됩니다.

**구문**

```sql
arrayExcept(source, except)
```

**인수**

* `source` — 필터링할 요소를 포함하는 원본 배열입니다.  [`Array(T)`](/sql-reference/data-types/array)
* `except` — 결과에서 제외할 요소를 포함하는 배열입니다.  [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

입력 배열과 동일한 타입의 배열을 반환하며, `source` 중 `except` 에서 찾을 수 없는 요소만 포함합니다.  [`Array(T)`](/sql-reference/data-types/array)

**예시**

**기본**

```sql title=Query
SELECT arrayExcept([1, 2, 3, 2, 4], [3, 5])
```

```response title=Response
[1, 2, 2, 4]
```

**with&#95;nulls1**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [2])
```

```response title=Response
[1, NULL, NULL]
```

**with&#95;nulls2**

```sql title=Query
SELECT arrayExcept([1, NULL, 2, NULL], [NULL, 2, NULL])
```

```response title=Response
[1]
```

**문자열**

```sql title=Query
SELECT arrayExcept(['apple', 'banana', 'cherry'], ['banana', 'date'])
```

```response title=Response
['apple', 'cherry']
```


## arrayExists \{#arrayExists\}

도입 버전: v1.1

소스 배열에서 `func(x[, y1, y2, ... yN])`이 true 값을 반환하는 요소가 하나 이상 있으면 `1`을 반환합니다. 그렇지 않으면 `0`을 반환합니다.

**구문**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 원본 배열(`x`)과 조건 배열(`y`)의 요소에 대해 동작하는 Lambda 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 원본 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항. Lambda 함수에 추가 인수로 제공되는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

Lambda 함수가 하나 이상의 요소에 대해 true를 반환하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```


## arrayFill \{#arrayFill\}

도입 버전: v20.1

`arrayFill` 함수는 소스 배열을 첫 번째 요소부터 마지막 요소까지 순차적으로 처리하면서,
소스 배열과 조건 배열의 요소를 사용해 각 위치에서 람다 조건식을 평가합니다.
람다 함수가 i번째 위치에서 false로 평가되면, 현재 배열 상태에서
i-1번째 위치의 요소로 해당 요소를 대체합니다. 첫 번째 요소는 어떤 조건과 관계없이 항상 유지됩니다.

**문법**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x [, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소를 대상으로 동작하는 람다 함수 `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열. [`Array(T)`](/sql-reference/data-types/array)

**반환값**

배열 [`Array(T)`](/sql-reference/data-types/array)를 반환합니다.

**예시**

**단일 배열 예제**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 1, 2, 2]
```

**배열 두 개를 사용하는 예제**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5, 5, 6, 6]
```


## arrayFilter \{#arrayFilter\}

도입 버전: v1.1

람다 함수가 true를 반환하는 원본 배열의 요소만을 포함하는 배열을 반환합니다.

**구문**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**인수**

* `func(x[, y1, ..., yN])` — 원본 배열(`x`)과 조건 배열(`y`)의 요소를 대상으로 동작하는 lambda 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 원본 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. lambda 함수에 전달할 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

원본 배열의 부분집합을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**예시 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**예시 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```


## arrayFirst \{#arrayFirst\}

도입 버전: v1.1

`func(x[, y1, y2, ... yN])`이 참을 반환하는 소스 배열의 첫 번째 요소를 반환하며, 그런 요소가 없으면 기본값을 반환합니다.

**문법**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소에 적용되는 람다 함수입니다. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 전달되는 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array).

**반환 값**

`λ`가 참이 되는 소스 배열의 첫 번째 요소를 반환하며, 그러한 요소가 없으면 `T`의 기본값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**일치하는 항목 없음**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayFirstIndex \{#arrayFirstIndex\}

도입 버전: v1.1

`func(x[, y1, y2, ... yN])`가 true를 반환하는 소스 배열의 첫 번째 요소의 인덱스를 반환하며, 해당하는 요소가 없으면 0을 반환합니다.

**구문**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소에 적용되는 람다 함수입니다. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array).

**반환값**

`func`가 참이 되는 소스 배열의 첫 번째 요소의 인덱스를 반환하며, 그런 요소가 없으면 `0`을 반환합니다. [`UInt32`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**일치하는 항목 없음**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```


## arrayFirstOrNull \{#arrayFirstOrNull\}

도입 버전: v1.1

`func(x[, y1, y2, ... yN])`에 대해 true를 반환하는 첫 번째 요소를 소스 배열에서 반환하며, 그런 요소가 없으면 `NULL`을 반환합니다.

**구문**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소에 대해 동작하는 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

`func`가 true인 소스 배열의 첫 번째 요소를 반환하며, 그런 요소가 없으면 `NULL`을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**일치 항목 없음**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayFlatten \{#arrayFlatten\}

도입 버전: v20.1

중첩 배열을 평탄화(flat)된 배열로 변환합니다.

기능:

* 중첩 배열의 깊이에 관계없이 적용됩니다.
* 이미 평탄화된 배열은 변경하지 않습니다.

평탄화된 배열에는 모든 원본 배열의 모든 요소가 포함됩니다.

**구문**

```sql
arrayFlatten(arr)
```

**별칭**: `flatten`

**인수**

* `arr` — 다차원 배열입니다. [`Array(Array(T))`](/sql-reference/data-types/array)

**반환 값**

다차원 배열을 평탄화한 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1, 2, 3]
```


## arrayFold \{#arrayFold\}

도입 버전: v23.10

크기가 같은 하나 이상의 배열에 람다 함수(lambda function)를 적용하고, 결과를 누산기(accumulator)에 누적합니다.

**구문**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**인수**

* `λ(x, x1 [, x2, x3, ... xN])` — 람다 함수 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`. 이때 `F`는 `acc`와 `x`의 배열 값에 적용되는 연산이며, 연산 결과로 얻은 `acc` 값이 반복해서 사용됩니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr1 [, arr2, arr3, ... arrN]` — 연산을 수행할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `acc` — Lambda 함수의 반환 타입과 동일한 타입의 누산기(accumulator) 값입니다.

**반환 값**

최종 `acc` 값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**피보나치 수열**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**여러 배열을 사용하는 예**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```


## arrayIntersect \{#arrayIntersect\}

도입 버전: v1.1

여러 배열을 입력으로 받아 모든 원본 배열에 공통으로 존재하는 요소들로 이루어진 배열을 반환합니다. 결과에는 중복되지 않는 값만 포함됩니다.

**구문**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**인수**

* `arrN` — 새 배열을 생성할 때 사용하는 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array).

**반환 값**

N개의 모든 배열에 공통적으로 존재하는 서로 다른 요소로 구성된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```


## arrayJaccardIndex \{#arrayJaccardIndex\}

도입: v23.7

두 배열의 [자카드 인덱스(Jaccard index)](https://en.wikipedia.org/wiki/Jaccard_index)를 반환합니다.

**구문**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**인수**

* `arr_x` — 첫 번째 배열. [`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — 두 번째 배열. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

`arr_x`와 `arr_y`의 Jaccard 지수를 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```


## arrayJoin \{#arrayJoin\}

도입 버전: v1.1

`arrayJoin` 함수는 배열을 포함하는 행을 받아 이를 펼쳐서, 배열의 각 요소마다 하나씩 여러 행을 생성합니다.
이는 ClickHouse의 일반 함수(Regular Functions)가 동일한 행 안에서 입력 값을 출력 값으로 매핑하는 것과,
집계 함수(Aggregate Functions)가 여러 행의 그룹을 받아 하나의 요약 행(또는 `GROUP BY`와 함께 사용되는 경우 요약 행 안의 단일 값)으로 &quot;압축&quot; 또는 &quot;축소&quot;하는 것과 대조됩니다.

이 함수가 적용된 컬럼을 제외한 나머지 컬럼의 값은 모두 그대로 복사됩니다.
함수가 적용되는 컬럼의 값만 해당하는 배열 값으로 대체됩니다.

**구문**

```sql
arrayJoin(arr)
```

**인수**

* `arr` — 전개할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

`arr`에서 전개된 행 집합을 반환합니다.

**예시**

**기본 사용법**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin은 쿼리의 모든 부분에 영향을 미칩니다**

```sql title=Query
-- The arrayJoin function affects all sections of the query, including the WHERE section. Notice the result 2, even though the subquery returned 1 row.

SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**여러 arrayJoin 함수 사용하기**

```sql title=Query
- A query can use multiple arrayJoin functions. In this case, the transformation is performed multiple times and the rows are multiplied.

SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**최적화로 인해 발생하는 예기치 않은 결과**

```sql title=Query
-- Using multiple arrayJoin with the same expression may not produce the expected result due to optimizations.
-- For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.
- e.g. arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))

SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set
    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```


```response title=Response
┌─first_throw─┬─second_throw─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**ARRAY JOIN 구문 사용**

```sql title=Query
-- Note the ARRAY JOIN syntax in the `SELECT` query below, which provides broader possibilities.
-- ARRAY JOIN allows you to convert multiple arrays with the same number of elements at a time.

SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**Tuple 사용하기**

```sql title=Query
-- You can also use Tuple

SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```


## arrayLast \{#arrayLast\}

도입 버전: v1.1

람다 `func(x [, y1, y2, ... yN])`의 결과가 true인 소스 배열의 마지막 요소를 반환하며, 그러한 요소가 없으면 기본값을 반환합니다.

**구문**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소에 적용되는 람다 함수입니다. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1, ... , condN]` — 선택 사항입니다. 람다 함수에 전달할 추가 인자를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array).

**반환 값**

`func`이 true인 소스 배열 요소 중 마지막 요소를 반환하며, 그러한 요소가 없으면 `T` 타입의 기본값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**일치하는 항목 없음**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```


## arrayLastIndex \{#arrayLastIndex\}

도입: v1.1

`func(x[, y1, y2, ... yN])`이 true를 반환하는 소스 배열에서 마지막 요소의 인덱스를 반환하며, 그렇지 않으면 &#39;0&#39;을 반환합니다.

**구문**

```sql
arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 소스 배열(`x`)의 요소와 조건 배열(`y`) 요소에 적용되는 lambda 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. lambda 함수에 추가 인수로 전달되는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

`func`이 참이 되는 소스 배열의 마지막 요소의 인덱스를 반환하며, 그런 요소가 없으면 `0`을 반환합니다. [`UInt32`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);
```

```response title=Response
3
```

**일치하는 항목 없음**

```sql title=Query
SELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);
```

```response title=Response
0
```


## arrayLastOrNull \{#arrayLastOrNull\}

도입: v1.1

람다 `func(x [, y1, y2, ... yN])`가 true를 반환하는 원본 배열의 마지막 요소를 반환하며, 그런 요소가 없으면 `NULL`을 반환합니다.

**문법**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인자**

* `func(x [, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소에 대해 동작하는 람다 함수입니다. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda). - `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 추가 인자를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array).

**반환 값**

`λ`가 참이 아닌 소스 배열의 마지막 요소를 반환하고, 그렇지 않으면 `NULL`을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**일치하는 항목 없음**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```


## arrayLevenshteinDistance \{#arrayLevenshteinDistance\}

도입 버전: v25.4

두 배열 간 Levenshtein 거리를 계산합니다.

**구문**

```sql
arrayLevenshteinDistance(from, to)
```

**인수**

* `from` — 첫 번째 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `to` — 두 번째 배열입니다. [`Array(T)`](/sql-reference/data-types/array).

**반환 값**

첫 번째 배열과 두 번째 배열 사이의 Levenshtein 거리입니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```


## arrayLevenshteinDistanceWeighted \{#arrayLevenshteinDistanceWeighted\}

도입 버전: v25.4

각 요소에 대해 사용자 지정 가중치를 사용하여 두 배열 사이의 Levenshtein 거리(Levenshtein distance)를 계산합니다.
배열의 요소 수와 해당 가중치의 수는 일치해야 합니다.

**구문**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**인수**

* `from` — 첫 번째 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `to` — 두 번째 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `from_weights` — 첫 번째 배열의 가중치입니다. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — 두 번째 배열의 가중치입니다. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**반환 값**

각 요소에 대한 사용자 지정 가중치를 사용하여 첫 번째 배열과 두 번째 배열 사이의 Levenshtein 거리를 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```


## arrayMap \{#arrayMap\}

도입 버전: v1.1

람다 함수를 각 요소에 적용하여 원본 배열에서 생성된 배열을 반환합니다.

**구문**

```sql
arrayMap(func, arr)
```

**인자**

* `func` — 소스 배열(`x`)과 조건 배열(`y`)의 요소를 대상으로 동작하는 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — 처리할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

람다 함수의 결과로 구성된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3, 4, 5]
```

**서로 다른 배열의 요소로 튜플 생성하기**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1, 4),(2, 5),(3, 6)]
```


## arrayMax \{#arrayMax\}

도입된 버전: v21.1

원본 배열에서 최댓값 요소를 반환합니다.

람다 함수 `func`가 지정된 경우, 람다 결과 중 최댓값 요소를 반환합니다.

**구문**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**인자**

* `func(x[, y1, ..., yN])` — 선택 사항입니다. 소스 배열(`x`) 및 조건 배열(`y`)의 요소를 대상으로 동작하는 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 추가 인자를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

소스 배열에서 최대 요소를 반환하거나, 람다 함수가 지정된 경우 람다 결과의 최대 요소를 반환합니다.

**예시**

**기본 예시**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**람다 함수와 함께 사용하는 방법**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```


## arrayMin \{#arrayMin\}

도입 버전: v21.1

원본 배열의 최소 요소를 반환합니다.

람다 함수 `func`가 지정되면, 람다 결과 중 최소 요소를 반환합니다.

**구문**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**인수(Arguments)**

* `func(x[, y1, ..., yN])` — 선택 사항입니다. 소스 배열(`x`)과 조건 배열들(`y`)의 요소에 대해 동작하는 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `cond1_arr, ...` — 선택 사항입니다. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

소스 배열에서 최소 요소를 반환하거나, 람다 함수가 지정된 경우 람다 결과에서 최소 요소를 반환합니다.

**예제**

**기본 예제**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**람다 함수와 함께 사용하기**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```


## arrayNormalizedGini \{#arrayNormalizedGini\}

도입된 버전: v25.1

정규화된 지니 계수(Gini coefficient)를 계산합니다.

**구문**

```sql
arrayNormalizedGini(predicted, label)
```

**인수(Arguments)**

* `predicted` — 예측값입니다. [`Array(T)`](/sql-reference/data-types/array)
* `label` — 실제 값입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값(Returned value)**

예측값의 Gini 계수, 정규화된 값의 Gini 계수, 그리고 정규화된 Gini 계수(= 앞의 두 Gini 계수의 비율)로 구성된 튜플입니다. [`Tuple(Float64, Float64, Float64)`](/sql-reference/data-types/tuple)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558, 0.2638888888888889, 0.6842105263157896)
```


## arrayPartialReverseSort \{#arrayPartialReverseSort\}

도입 버전: v23.2

이 FUNCTION은 `arrayReverseSort`와 동일하지만, 정렬을 부분적으로 수행할 수 있도록 추가 인자 `limit`을 받습니다.

:::tip
정렬된 원소만 유지하려면 `arrayResize`를 사용하십시오.
:::

**구문**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**인수**

* `f(arr[, arr1, ... ,arrN])` — 배열 `x`의 요소에 적용할 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — 정렬할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — `f`가 여러 인수를 받는 경우의 추가 배열 N개입니다. [`Array(T)`](/sql-reference/data-types/array)
* `limit` — 정렬이 수행되는 상한을 나타내는 인덱스 값입니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

원본 배열과 크기가 동일한 배열을 반환하며, 구간 `[1..limit]` 내의 요소는 내림차순으로 정렬되고 나머지 요소 `(limit..N]`의 순서는 정의되지 않습니다.

**예시**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9, 5]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0, 1, 2]
```


## arrayPartialShuffle \{#arrayPartialShuffle\}

도입 버전: v23.2

원본 배열과 동일한 크기의 배열을 반환하며, 구간 `[1..limit]` 내의 요소들은 원본 배열에서 무작위로 선택된 부분 집합입니다.
나머지 `(limit..n]` 구간에는 `[1..limit]` 구간에 포함되지 않은 요소들이 정의되지 않은 순서로 포함됩니다.
`limit` 값은 `[1..n]` 범위 내에 있어야 합니다. 이 범위를 벗어나는 값은 전체 `arrayShuffle`를 수행하는 것과 동일하게 처리됩니다:

:::note
이 함수는 상수를 materialize(실체화)하지 않습니다.

`limit` 값은 `[1..N]` 범위 내에 있어야 합니다. 이 범위를 벗어나는 값은 전체 [`arrayShuffle`](#arrayShuffle)를 수행하는 것과 동일합니다.
:::

**구문**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**인수(Arguments)**

* `arr` — 셔플할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `seed` — 선택 사항입니다. 난수 생성에 사용할 시드입니다. 제공되지 않으면 임의의 값이 사용됩니다. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `limit` — 선택 사항입니다. 요소 교환 횟수를 `[1..N]` 범위 내에서 제한하는 값입니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

요소가 부분적으로 셔플된 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**no&#95;limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2, 4, 3, 1]
```

**no&#95;limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4, 1, 3, 2]
```

**random&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3, 4, 1, 2]
```

**explicit&#95;seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3, 2, 1, 4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```


## arrayPartialSort \{#arrayPartialSort\}

도입 버전: v23.2

이 함수는 `arraySort`와 동일하지만, 추가 `limit` 인자를 통해 배열을 부분적으로 정렬할 수 있습니다.

:::tip
정렬된 요소만 유지하려면 `arrayResize`를 사용하십시오.
:::

**구문**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**인수**

* `f(arr[, arr1, ... ,arrN])` — 배열 `x`의 요소에 적용할 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `arr` — 정렬할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `arr1, ... ,arrN` — `f`가 여러 인수를 받는 경우의 추가 배열 N개입니다. [`Array(T)`](/sql-reference/data-types/array)
* `limit` — 정렬이 수행되는 인덱스의 상한값입니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

원본 배열과 동일한 크기의 배열을 반환하며, 구간 `[1..limit]`의 요소는 오름차순으로 정렬됩니다.
나머지 요소 `(limit..N]`의 순서는 정해져 있지 않습니다.

**예시**

**simple&#95;int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1, 3, 5, 9]
```

**simple&#95;string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses', 'lasso', 'embolism', 'gladly'])
```

```response title=Response
['embolism', 'expenses', 'gladly', 'lasso']
```

**retain&#95;sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1, 3]
```

**lambda&#95;simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9, 5, 1, 3]
```

**lambda&#95;complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2, 1, 0]
```


## arrayPopBack \{#arrayPopBack\}

도입: v1.1

배열에서 마지막 요소를 제거합니다.

**구문**

```sql
arrayPopBack(arr)
```

**인수**

* `arr` — 마지막 요소를 제거할 대상 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

`arr`와 동일하지만 `arr`의 마지막 요소가 제거된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1, 2]
```


## arrayPopFront \{#arrayPopFront\}

도입 버전: v1.1

배열에서 첫 번째 요소를 제거합니다.

**구문**

```sql
arrayPopFront(arr)
```

**인자**

* `arr` — 첫 번째 요소를 제거할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

`arr`와 동일하지만 `arr`의 첫 번째 요소가 제거된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2, 3]
```


## arrayProduct \{#arrayProduct\}

도입 버전: v21.1

원본 배열의 요소들을 모두 곱한 값을 반환합니다.

람다 함수 `func`를 지정하면, 람다 함수 결과 요소들의 곱을 반환합니다.

**구문**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 선택 사항입니다. 소스 배열(`x`)과 조건 배열(`y`)의 요소에 대해 동작하는 lambda 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. lambda 함수에 전달할 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

소스 배열 요소들의 곱을 반환하거나, lambda 함수가 제공된 경우 lambda 결과 요소들의 곱을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예제**

**기본 예제**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**lambda 함수와 함께 사용하기**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```


## arrayPushBack \{#arrayPushBack\}

도입 버전: v1.1

배열 끝에 요소 하나를 추가합니다.

**구문**

```sql
arrayPushBack(arr, x)
```

**인자**

* `arr` — 배열의 끝에 값 `x`를 추가할 대상 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `x` —
* 배열 끝에 추가할 단일 값입니다. [`Array(T)`](/sql-reference/data-types/array).

:::note

* 숫자로 이루어진 배열에는 숫자만, 문자열 배열에는 문자열만 추가할 수 있습니다.
* 숫자를 추가할 때 ClickHouse는 배열의 데이터 타입에 맞게 `x`의 타입을 자동으로 설정합니다.
* `NULL`일 수 있습니다. 이 함수는 배열에 `NULL` 요소를 추가하며, 배열 요소의 타입은 널 허용(Nullable)으로 변환됩니다.

ClickHouse의 데이터 타입에 대한 자세한 내용은 [데이터 타입](/sql-reference/data-types)을 참조하십시오.
:::

**반환 값**

`arr`와 동일하지만 배열의 끝에 값 `x`가 하나 더 추가된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```


## arrayPushFront \{#arrayPushFront\}

도입 버전: v1.1

배열의 맨 앞에 요소 하나를 추가합니다.

**구문**

```sql
arrayPushFront(arr, x)
```

**인수**

* `arr` — 값 `x`를 끝에 추가할 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `x` —
* 배열의 시작 부분에 추가할 단일 값입니다. [`Array(T)`](/sql-reference/data-types/array).

:::note

* 숫자 배열에는 숫자만, 문자열 배열에는 문자열만 추가할 수 있습니다.
* 숫자를 추가할 때 ClickHouse는 배열의 데이터 타입에 맞게 `x`의 타입을 자동으로 설정합니다.
* `NULL`일 수 있습니다. 이 함수는 배열에 `NULL` 요소를 추가하며, 배열 요소의 타입은 널 허용(`Nullable`)으로 변환됩니다.

ClickHouse의 데이터 타입에 대한 자세한 내용은 [Data types](/sql-reference/data-types)를 참조하십시오.
:::

**반환 값**

`arr`와 동일하지만 배열의 시작 부분에 값 `x`가 하나 더 추가된 배열 [`Array(T)`](/sql-reference/data-types/array)을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```


## arrayROCAUC \{#arrayROCAUC\}

도입 버전: v20.4

수신자 조작 특성 곡선(ROC, Receiver Operating Characteristic) 아래 면적(AUC, Area Under the Curve)을 계산합니다.
ROC 곡선은 모든 임곗값에 대해 참양성률(TPR, True Positive Rate)을 y축에, 거짓양성률(FPR, False Positive Rate)을 x축에 나타내어 생성합니다.
결과값은 0에서 1 사이의 범위를 가지며, 값이 클수록 모델 성능이 더 우수함을 의미합니다.

ROC AUC(일반적으로 AUC라고도 함)는 머신러닝에서 사용되는 개념입니다.
자세한 내용은 [여기](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [여기](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1), 그리고 [여기](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve)를 참조하십시오.

**구문**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**별칭**: `arrayAUC`

**인수**

* `scores` — 예측 모델이 산출한 점수입니다. [`Array((U)Int*)`](/sql-reference/data-types/array) 또는 [`Array(Float*)`](/sql-reference/data-types/array)
* `labels` — 샘플의 레이블입니다. 일반적으로 양성 샘플은 1, 음성 샘플은 0입니다. [`Array((U)Int*)`](/sql-reference/data-types/array) 또는 [`Enum`](/sql-reference/data-types/enum)
* `scale` — 선택 사항입니다. 정규화된 면적을 반환할지 여부를 결정합니다. false이면, 대신 TP (true positives)와 FP (false positives)를 축으로 하는 곡선 아래의 면적을 반환합니다. 기본값: true. [`Bool`](/sql-reference/data-types/boolean)
* `partial_offsets` —
* 전체 AUC 대신 ROC 곡선 아래의 부분 면적(ROC 공간에서 수직 구간에 해당)을 계산하기 위한, 음이 아닌 정수 네 개로 이루어진 배열입니다. 이 옵션은 ROC AUC의 분산 계산에 유용합니다. 배열은 다음 요소들을 포함해야 합니다: [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. 음이 아닌 [Integers](../data-types/int-uint.md)의 [Array](/sql-reference/data-types/array)입니다. 선택 사항입니다.
  * `higher_partitions_tp`: 더 높은 점수를 가진 파티션에서의 양성 레이블 개수입니다.
  * `higher_partitions_fp`: 더 높은 점수를 가진 파티션에서의 음성 레이블 개수입니다.
  * `total_positives`: 전체 데이터셋에서 양성 샘플의 총 개수입니다.
  * `total_negatives`: 전체 데이터셋에서 음성 샘플의 총 개수입니다.

:::note
`arr_partial_offsets`를 사용할 때 `arr_scores`와 `arr_labels`에는 전체 데이터셋 중 점수 구간 하나에 해당하는 파티션만 포함되어야 합니다.
데이터셋은 인접한 파티션으로 나누어야 하며, 각 파티션에는 특정 점수 범위에 속하는 데이터 부분집합이 포함되어야 합니다.
예를 들면 다음과 같습니다.

* 하나의 파티션에는 [0, 0.5) 구간의 모든 점수가 포함될 수 있습니다.
* 다른 파티션에는 [0.5, 1.0] 구간의 점수가 포함될 수 있습니다.
  :::

**반환 값**

수신기 조작 특성(receiver operating characteristic, ROC) 곡선 아래의 면적을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```


## arrayRandomSample \{#arrayRandomSample\}

도입 버전: v23.10

입력 배열에서 `samples` 개수만큼 무작위 요소를 포함하는 부분집합을 반환합니다. `samples` 값이 입력 배열의 크기를 초과하는 경우 샘플 크기는 배열의 크기로 제한됩니다. 이때 모든 배열 요소가 반환되지만, 순서는 보장되지 않습니다. 이 함수는 플랫(flat) 배열과 중첩 배열 모두를 처리할 수 있습니다.

**구문**

```sql
arrayRandomSample(arr, samples)
```

**인수**

* `arr` — 샘플링할 요소가 포함된 입력 배열 또는 다차원 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `samples` — 무작위 샘플에 포함할 요소의 개수입니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환값**

입력 배열에서 무작위로 선택한 요소들로 구성된 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**다차원 배열 활용하기**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```


## arrayReduce \{#arrayReduce\}

도입 버전: v1.1

배열 요소에 집계 함수(aggregate function)를 적용하고 그 결과를 반환합니다.
집계 함수 이름은 작은따옴표로 둘러싼 문자열로 전달됩니다(예: `'max'`, `'sum'`).
매개변수형(파라메트릭) 집계 함수를 사용할 때는 함수 이름 뒤에 괄호 안에 매개변수를 지정합니다(예: `'uniqUpTo(6)'`).

**구문**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)])
```

**인수**

* `agg_f` — 상수여야 하는 집계 함수 이름입니다. [`String`](/sql-reference/data-types/string)
* `arr1 [, arr2, ... , arrN)]` — `agg_f`의 인수에 해당하는 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환값**

집계 함수의 결과를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**여러 인수를 사용하는 집계 함수의 예**

```sql title=Query
--If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.

SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**매개변수화 집계 함수 예시**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```


## arrayReduceInRanges \{#arrayReduceInRanges\}

도입 버전: v20.4

지정된 범위의 배열 요소에 집계 함수(aggregate function)를 적용하고, 각 범위에 해당하는 결과를 담은 배열을 반환합니다.
이 함수는 `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`를 여러 번 호출한 것과 동일한 결과를 반환합니다.

**구문**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)])
```

**인수**

* `agg_f` — 사용할 집계 함수의 이름입니다. [`String`](/sql-reference/data-types/string)
* `ranges` — 집계를 수행할 구간입니다. `(i, r)` 튜플의 배열로, 집계를 시작할 인덱스 `i`와 집계를 수행할 구간 `r`을 포함합니다. [`Array(T)`](/sql-reference/data-types/array) 또는 [`Tuple(T)`](/sql-reference/data-types/tuple)
* `arr1 [, arr2, ... ,arrN)]` — 집계 함수의 인수로 전달되는 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

지정된 범위에 대해 집계 함수를 적용한 결과를 포함하는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```


## arrayRemove \{#arrayRemove\}

도입 버전: v25.11

배열에서 지정한 값과 같은 모든 요소를 제거합니다.
NULL 값은 서로 동일한 값으로 간주됩니다.

**구문**

```sql
arrayRemove(arr, elem)
```

**별칭(Aliases)**: `array_remove`

**인수(Arguments)**

* `arr` — Array(T), `elem` — T

**반환 값(Returned value)**

원본 배열 [`Array(T)`](/sql-reference/data-types/array)의 부분 배열을 반환합니다.

**예제(Examples)**

**예제 1**

```sql title=Query
SELECT arrayRemove([1, 2, 2, 3], 2)
```

```response title=Response
[1, 3]
```

**예제 2**

```sql title=Query
SELECT arrayRemove(['a', NULL, 'b', NULL], NULL)
```

```response title=Response
['a', 'b']
```


## arrayResize \{#arrayResize\}

도입된 버전: v1.1

배열의 길이를 변경합니다.

**문법**

```sql
arrayResize(arr, size[, extender])
```

**인수**

* `arr` — 크기를 조정할 배열. [`Array(T)`](/sql-reference/data-types/array)
* `size` —
  * 배열의 새로운 길이입니다.
    `size`가 배열의 원래 길이보다 작으면 배열은 오른쪽부터 잘립니다.
    `size`가 배열의 원래 길이보다 크면 배열은 오른쪽으로 `extender` 값 또는 배열 요소 데이터 타입의 기본값으로 확장됩니다.
* `extender` — 배열을 확장할 때 사용할 값입니다. `NULL`일 수 있습니다.

**반환 값**

길이가 `size`인 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**예시 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**예시 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```


## arrayReverse \{#arrayReverse\}

도입: v1.1

주어진 배열의 요소 순서를 역순으로 변경합니다.

:::note
함수 `reverse(arr)`는 동일한 기능을 수행하지만, 배열 이외의 다른 데이터 타입에서도 동작합니다.
:::

**구문**

```sql
arrayReverse(arr)
```

**인수**

* `arr` — 역순으로 뒤집을 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

원본 배열과 동일한 크기이며 요소가 역순으로 배치된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```


## arrayReverseFill \{#arrayReverseFill\}

도입 버전: v20.1

`arrayReverseFill` FUNCTION은 소스 배열을 마지막 요소에서 첫 번째 요소까지 순차적으로 처리하면서, 소스 배열과 조건 배열의 요소를 사용해 각 위치에서 lambda 조건을 평가합니다. 인덱스 i 위치에서 조건이 false로 평가되면, 함수는 해당 요소를 현재 배열 상태에서 인덱스 i+1 위치의 요소로 대체합니다. 마지막 요소는 어떤 조건과 관계없이 항상 유지됩니다.

**문법**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소를 대상으로 동작하는 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항. 람다 함수에 전달할 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

람다 함수의 결과로 소스 배열의 요소가 대체된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**단일 배열 예제**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1, 2, 2, NULL]
```

**두 개의 배열을 사용하는 예시**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5, 6, 6, 2]
```


## arrayReverseSort \{#arrayReverseSort\}

도입된 버전: v1.1

배열의 요소를 내림차순으로 정렬합니다.
함수 `f`가 지정되면, 입력 배열의 각 요소에 함수를 적용한 결과를 기준으로 정렬한 뒤, 이렇게 정렬된 배열을 뒤집습니다.
`f`가 여러 인수를 받는 경우, `arrayReverseSort` 함수에는 여러 배열이 전달되며,
`func`의 인수는 이 배열들에 각각 대응합니다.

정렬할 배열에 `-Inf`, `NULL`, `NaN`, `Inf`가 포함된 경우 다음 순서로 정렬됩니다:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arrayReverseSort`는 [고차 함수](/sql-reference/functions/overview#higher-order-functions)입니다.

**구문**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**인수**

* `f(y1[, y2 ... yN])` — 배열 `x`의 요소에 적용할 람다 함수입니다. - `arr` — 정렬할 배열입니다. [`Array(T)`](/sql-reference/data-types/array) - `arr1, ..., yN` — 선택 사항입니다. `f`가 여러 인수를 받는 경우 사용하는 N개의 추가 배열입니다.

**반환 값**

람다 함수가 제공되지 않으면 배열 `x`를 내림차순으로 정렬한 배열을 반환합니다. 람다 함수가 제공되면, 제공된 람다 함수의 로직에 따라 배열을 정렬한 뒤 그 순서를 반전한 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array).

**예시**

**예시 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**예제 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```


## arrayReverseSplit \{#arrayReverseSplit\}

도입된 버전: v20.1

원본 배열을 여러 개의 배열로 분할합니다. `func(x[, y1, ..., yN])`이 0이 아닌 값을 반환하면, 해당 요소의 오른쪽에서 배열이 분할됩니다. 마지막 요소 뒤에서는 배열이 분할되지 않습니다.

**Syntax**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 소스 배열(`x`)과 조건 배열(`y`)의 요소를 대상으로 동작하는 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 추가 인수를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

배열의 배열을 반환합니다. [`Array(Array(T))`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```


## arrayRotateLeft \{#arrayRotateLeft\}

도입된 버전: v23.8

지정한 요소 개수만큼 배열을 왼쪽으로 회전합니다. `n`의 값이 음수인 경우, 그 절댓값만큼 오른쪽으로 회전하는 것으로 처리됩니다.

**구문**

```sql
arrayRotateLeft(arr, n)
```

**인수**

* `arr` — 요소를 회전할 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `n` — 회전할 요소의 개수입니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**반환 값**

지정된 개수만큼 왼쪽으로 회전된 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**n이 음수인 경우**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```


## arrayRotateRight \{#arrayRotateRight\}

도입 버전: v23.8

지정된 개수만큼 배열을 오른쪽으로 회전합니다. `n`의 값이 음수이면 회전 크기의 절댓값만큼 왼쪽으로 회전한 것으로 처리합니다.

**구문**

```sql
arrayRotateRight(arr, n)
```

**인수**

* `arr` — 요소를 회전할 배열. [`Array(T)`](/sql-reference/data-types/array).
* `n` — 회전할 요소의 개수. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**반환 값**

지정된 개수만큼 오른쪽으로 회전된 배열. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**음수 n 값**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```


## arrayShiftLeft \{#arrayShiftLeft\}

도입 버전: v23.8

지정된 개수만큼 배열을 왼쪽으로 시프트합니다.
새 요소는 제공된 인자 또는 배열 요소 타입의 기본값으로 채워집니다.
요소 개수 인자가 음수이면 배열을 오른쪽으로 시프트합니다.

**구문**

```sql
arrayShiftLeft(arr, n[, default])
```

**인자**

* `arr` — 요소를 이동할 배열입니다. [`Array(T)`](/sql-reference/data-types/array). - `n` — 이동할 요소의 개수입니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint). - `default` — 선택 사항입니다. 새로 생성되는 요소의 기본값입니다.

**반환 값**

지정된 요소 개수만큼 요소를 왼쪽으로 이동한 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**n이 음수인 경우**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**기본값 사용**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```


## arrayShiftRight \{#arrayShiftRight\}

도입 버전: v23.8

배열을 지정된 개수만큼 오른쪽으로 이동합니다.
새로 채워지는 요소는 제공된 인자 또는 배열 요소 타입의 기본값으로 채워집니다.
요소 수가 음수이면 배열은 왼쪽으로 이동합니다.

**구문**

```sql
arrayShiftRight(arr, n[, default])
```

**인수**

* `arr` — 요소를 이동할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `n` — 오른쪽으로 이동시킬 요소의 개수입니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `default` — 선택 사항입니다. 새로 생기는 요소의 기본값입니다.

**반환 값**

지정된 개수만큼 오른쪽으로 이동된 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2) as res;
```

```response title=Response
[0, 0, 1, 2, 3, 4]
```

**n이 음수인 경우**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], -2) as res;
```

```response title=Response
[3, 4, 5, 6, 0, 0]
```

**기본값 사용하기**

```sql title=Query
SELECT arrayShiftRight([1, 2, 3, 4, 5, 6], 2, 42) as res;
```

```response title=Response
[42, 42, 1, 2, 3, 4]
```


## arrayShingles \{#arrayShingles\}

도입 버전: v24.1

shingle(문자열에서의 n-그램과 유사)들로 구성된 배열을 생성합니다. 즉, 입력 배열에서 지정한 길이의 연속된 부분 배열(sub-array)을 연속적으로 생성합니다.

**구문**

```sql
arrayShingles(arr, l)
```

**인자**

* `arr` — shingle 배열을 생성할 대상 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `l` — 각 shingle의 길이입니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

생성된 shingle 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayShingles([1, 2, 3, 4], 3) as res;
```

```response title=Response
[[1, 2, 3], [2, 3, 4]]
```


## arrayShuffle \{#arrayShuffle\}

도입 버전: v23.2

원본 배열과 동일한 크기의 배열을 반환하며, 요소들은 무작위로 섞인 순서로 포함됩니다.
요소들은 가능한 모든 순열이 동일한 확률로 나타나도록 재배열됩니다.

:::note
이 함수는 상수를 실체화(materialize)하지 않습니다.
:::

**구문**

```sql
arrayShuffle(arr [, seed])
```

**인수**

* `arr` — 섞을 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `seed (optional)` — 선택 사항입니다. 난수 생성에 사용할 시드입니다. 제공하지 않으면 임의의 시드가 사용됩니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

요소가 섞인 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**시드를 사용하지 않는 예시(결과가 매번 달라짐)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**시드를 사용하지 않는 예시 (안정적인 결과)**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```


## arraySimilarity \{#arraySimilarity\}

도입 버전: v25.4

가중치가 적용된 레벤슈타인 거리(Levenshtein distance)를 기준으로 두 배열의 유사도를 `0`에서 `1` 사이 값으로 계산합니다.

**구문**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**인수**

* `from` — 첫 번째 배열 [`Array(T)`](/sql-reference/data-types/array)
* `to` — 두 번째 배열 [`Array(T)`](/sql-reference/data-types/array)
* `from_weights` — 첫 번째 배열에 대한 가중치. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)
* `to_weights` — 두 번째 배열에 대한 가중치. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array)

**반환 값**

가중 레벤슈타인 거리(Levenshtein distance)를 기반으로 두 배열의 유사도를 `0` 이상 `1` 이하의 값으로 반환합니다. 반환 타입은 [`Float64`](/sql-reference/data-types/float)입니다.

**예시**

**사용 예시**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```


## arraySlice \{#arraySlice\}

도입된 버전: v1.1

`NULL` 요소를 포함하여 배열의 일부 구간을 반환합니다.

**구문**

```sql
arraySlice(arr, offset [, length])
```

**인자**

* `arr` — 슬라이스할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `offset` — 배열의 양 끝을 기준으로 한 오프셋(offset)입니다. 양수 값은 왼쪽(처음)에서의 오프셋을, 음수 값은 오른쪽(끝)에서의 오프셋을 나타냅니다. 배열 항목의 번호는 `1`부터 시작합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `length` — 필요한 슬라이스의 길이입니다. 음수 값을 지정하면 함수는 열린 구간 슬라이스 `[offset, array_length - length]`를 반환합니다. 값을 생략하면 함수는 슬라이스 `[offset, 배열의 끝]`을 반환합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

지정된 `offset`부터 `length`개의 요소를 포함하는 배열 슬라이스를 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2, NULL, 4]
```


## arraySort \{#arraySort\}

도입 버전: v1.1

지정된 배열의 요소를 오름차순으로 정렬합니다.
람다 함수 `f`가 지정된 경우, 배열의 각 요소에 람다를 적용한 결과에 따라 정렬 순서가 결정됩니다.
람다가 여러 인수를 받는 경우, `arraySort` 함수는 `f`의 각 인수에 대응하는 여러 배열을 전달합니다.

정렬할 배열에 `-Inf`, `NULL`, `NaN`, `Inf`가 포함되어 있으면 다음 순서로 정렬됩니다:

1. `-Inf`
2. `Inf`
3. `NaN`
4. `NULL`

`arraySort`는 [고차 함수](/sql-reference/functions/overview#higher-order-functions)입니다.

**구문**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**인수**

* `f(y1[, y2 ... yN])` — 배열 `x`의 요소에 적용할 람다 함수입니다. - `arr` — 정렬할 배열입니다. [`Array(T)`](/sql-reference/data-types/array) - `arr1, ..., yN` — 선택 사항입니다. `f`가 여러 인수를 받는 경우 사용할 N개의 추가 배열입니다.

**반환 값**

람다 함수가 제공되지 않으면 배열 `arr`을 오름차순으로 정렬한 결과를 반환하고, 람다 함수가 제공되면 해당 람다 함수의 로직에 따라 정렬된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array).

**예시**

**예시 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**예제 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**예제 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```


## arraySplit \{#arraySplit\}

도입 버전: v20.1

소스 배열을 여러 개의 배열로 분할합니다. `func(x [, y1, ..., yN])`이 0이 아닌 값을 반환하면 해당 요소의 왼쪽에서 배열이 분할됩니다. 첫 번째 요소 앞에서는 배열이 분할되지 않습니다.

**구문**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**인수**

* `func(x[, y1, ..., yN])` — 원본 배열(`x`)과 조건 배열(`y`)의 요소에 적용되는 람다 함수입니다. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).

- `source_arr` — 분할할 원본 배열입니다. [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — 선택 사항입니다. 람다 함수에 전달할 추가 인자를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array).

**반환 값**

배열을 요소로 갖는 배열을 반환합니다. [`Array(Array(T))`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```


## arraySum \{#arraySum\}

도입 버전: v21.1

소스 배열 요소들의 합을 반환합니다.

람다 FUNCTION `func`이 지정된 경우, 해당 람다 결과 요소들의 합을 반환합니다.

**구문**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**인자**

* `func(x[, y1, ..., yN])` — 선택 사항입니다. 소스 배열(`x`)과 조건 배열(`y`)의 요소를 대상으로 동작하는 lambda 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `source_arr` — 처리할 소스 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `, cond1_arr, ... , condN_arr]` — 선택 사항입니다. lambda 함수에 추가 인자를 제공하는 N개의 조건 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

소스 배열의 요소 합계를 반환하거나, lambda 함수가 제공된 경우 lambda 결과 요소의 합계를 반환합니다.

**예제**

**기본 예제**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**람다 FUNCTION 사용 방법**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```


## arraySymmetricDifference \{#arraySymmetricDifference\}

도입 버전: v25.4

여러 배열을 입력으로 받아 모든 원본 배열에 모두 존재하지 않는 요소들로만 구성된 배열을 반환합니다. 결과에는 고유한 값만 포함됩니다.

:::note
*2개를 초과하는 집합*의 대칭 차집합은 [수학적으로](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)
입력 집합들 가운데 홀수 번 등장하는 모든 입력 요소들의 집합으로 정의됩니다.
반면, `arraySymmetricDifference` 함수는 단순히 모든 입력 집합에 공통으로 존재하지 않는 입력 요소들의 집합만을 반환합니다.
:::

**구문**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**인수(Arguments)**

* `arrN` — 새로운 배열을 생성할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array).

**반환 값(Returned value)**

모든 소스 배열에 모두 존재하는 것은 아닌 서로 다른 요소들로 구성된 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```


## arrayUnion \{#arrayUnion\}

도입 버전: v24.10

여러 배열을 인수로 받아, 원본 배열들 중 하나에 존재하는 모든 요소를 포함하는 배열을 반환합니다. 결과 배열에는 중복되지 않는 고유한 값만 포함됩니다.

**구문**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**인수**

* `arrN` — 새로운 배열을 생성할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

원본 배열들에서 서로 다른 요소만 포함하는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```


## arrayUniq \{#arrayUniq\}

도입된 버전: v1.1

인수가 하나만 전달되면 배열에서 서로 다른 요소의 개수를 셉니다.
여러 인수가 전달되면 여러 배열에서 동일한 위치의 요소들로 이루어진 **튜플(tuple)** 중 서로 다른 튜플의 개수를 셉니다.

예를 들어 `SELECT arrayUniq([1,2], [3,4], [5,6])`은 다음과 같은 튜플을 만듭니다:

* 위치 1: (1,3,5)
* 위치 2: (2,4,6)

그 다음 고유한 튜플의 개수를 셉니다. 이 경우 `2`입니다.

전달되는 모든 배열의 길이는 동일해야 합니다.

:::tip
배열에서 고유한 요소 목록을 얻으려면 `arrayReduce('groupUniqArray', arr)`를 사용할 수 있습니다.
:::

**구문**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**인수**

* `arr1` — 고유한 요소의 개수를 계산할 배열. [`Array(T)`](/sql-reference/data-types/array)
* `[, arr2, ..., arrN]` — 선택 사항. 여러 배열에서 동일한 인덱스 위치에 있는 요소들로 이루어진 고유 튜플의 개수를 계산하기 위해 사용하는 추가 배열들. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

인수가 하나일 때는 고유한 요소의 개수를 반환합니다. 인수가 여러 개일 때는 여러 배열에서 동일한 인덱스 위치의 요소들로 구성된 고유 튜플의 개수를 반환합니다.
[`UInt32`](/sql-reference/data-types/int-uint)

**예시**

**단일 인수**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**다중 인자**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```


## arrayWithConstant \{#arrayWithConstant\}

도입된 버전: v20.1

상수 `x`로 채워진 길이 `length`의 배열을 생성합니다.

**구문**

```sql
arrayWithConstant(N, x)
```

**인자**

* `length` — 배열 요소의 개수. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `x` — 배열의 `N`개 요소에 사용할 값으로, 임의의 타입일 수 있습니다.

**반환 값**

값이 `x`인 `N`개 요소로 구성된 Array를 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1, 1, 1]
```


## arrayZip \{#arrayZip\}

도입된 버전: v20.1

여러 배열을 하나의 배열로 결합합니다. 결과 배열에는 인수에 지정된 순서대로, 각 원본 배열에서 동일한 위치(인덱스)의 요소들을 튜플로 묶은 값들이 포함됩니다.

**구문**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**인자**

* `arr1, arr2, ... , arrN` — 하나의 배열로 결합할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

원본 배열의 요소들을 튜플로 묶어서 구성한 배열을 반환합니다. 튜플의 데이터 타입은 입력 배열의 타입과 동일하며, 배열이 전달된 순서를 그대로 따릅니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```


## arrayZipUnaligned \{#arrayZipUnaligned\}

도입 버전: v20.1

여러 배열을 하나의 배열로 결합하며, 길이가 서로 다른 배열도 허용합니다. 결과 배열에는 인수로 전달된 순서에 따라 각 원본 배열에서 같은 인덱스의 요소들이 튜플로 묶여 포함됩니다.

**구문**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**인수**

* `arr1, arr2, ..., arrN` — 하나의 배열로 결합할 N개의 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

원본 배열의 요소를 튜플 단위로 그룹화한 배열을 반환합니다. 튜플의 데이터 타입은 입력 배열의 타입과 동일하며, 배열이 전달된 순서를 그대로 따릅니다. [`Array(T)`](/sql-reference/data-types/array) 또는 [`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)

**예시**

**사용 예시**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```


## countEqual \{#countEqual\}

도입된 버전: v1.1

배열에서 값이 `x`인 요소의 개수를 반환합니다. `arrayCount(elem -> elem = x, arr)`와 동일합니다.

`NULL` 요소는 별도의 값으로 처리됩니다.

**문법**

```sql
countEqual(arr, x)
```

**인수**

* `arr` — 검색할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `x` — 배열에서 개수를 계산할 값입니다. 임의의 타입입니다.

**반환 값**

배열에서 `x`와 같은 요소의 개수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```


## empty \{#empty\}

도입된 버전: v1.1

입력 배열이 비어 있는지 확인합니다.

배열에 요소가 하나도 포함되어 있지 않으면 비어 있는 것으로 간주합니다.

:::note
[`optimize_functions_to_subcolumns` 설정](/operations/settings/settings#optimize_functions_to_subcolumns)을 활성화하여 최적화할 수 있습니다. `optimize_functions_to_subcolumns = 1`인 경우 함수는 전체 배열 컬럼을 읽고 처리하는 대신 [size0](/sql-reference/data-types/array#array-size) 서브컬럼만 읽습니다. 쿼리 `SELECT empty(arr) FROM TABLE;`는 `SELECT arr.size0 = 0 FROM TABLE;`로 변환됩니다.
:::

이 함수는 String 또는 UUID에 대해서도 동작합니다.

**구문**

```sql
empty(arr)
```

**인수**

* `arr` — 입력 배열. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

빈 배열이면 `1`, 비어 있지 않은 배열이면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```


## emptyArrayDate \{#emptyArrayDate\}

도입 버전: v1.1

비어 있는 Date 형식 배열을 반환합니다.

**구문**

```sql
emptyArrayDate()
```

**인수**

* 없음.

**반환값**

빈 Date 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예**

**사용 예**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```


## emptyArrayDateTime \{#emptyArrayDateTime\}

도입 버전: v1.1

빈 DateTime 배열을 반환합니다.

**구문**

```sql
emptyArrayDateTime()
```

**인수**

* 없음.

**반환값**

빈 DateTime 배열. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```


## emptyArrayFloat32 \{#emptyArrayFloat32\}

도입 버전: v1.1

빈 Float32 배열을 반환합니다.

**구문**

```sql
emptyArrayFloat32()
```

**인수**

* 없음

**반환값**

비어 있는 Float32 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```


## emptyArrayFloat64 \{#emptyArrayFloat64\}

도입: v1.1

빈 Float64 타입 배열을 반환합니다.

**구문**

```sql
emptyArrayFloat64()
```

**인수**

* 없음.

**반환 값**

빈 Float64 배열. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```


## emptyArrayInt16 \{#emptyArrayInt16\}

v1.1에서 도입됨

빈 Int16 배열을 반환합니다.

**구문**

```sql
emptyArrayInt16()
```

**인수**

* 없음.

**반환값**

빈 Int16 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```


## emptyArrayInt32 \{#emptyArrayInt32\}

도입된 버전: v1.1

빈 Int32 배열을 반환합니다.

**구문**

```sql
emptyArrayInt32()
```

**인수**

* 없음.

**반환값**

비어 있는 Int32 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```


## emptyArrayInt64 \{#emptyArrayInt64\}

도입 버전: v1.1

빈 Int64 배열을 반환합니다.

**구문**

```sql
emptyArrayInt64()
```

**인수**

* 없음.

**반환 값**

빈 Int64 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```


## emptyArrayInt8 \{#emptyArrayInt8\}

도입 버전: v1.1

빈 Int8 배열을 반환합니다.

**구문**

```sql
emptyArrayInt8()
```

**인수**

* 없음.

**반환값**

비어 있는 Int8 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```


## emptyArrayString \{#emptyArrayString\}

도입된 버전: v1.1

빈 String 배열을 반환합니다.

**구문**

```sql
emptyArrayString()
```

**인수**

* 없음.

**반환값**

빈 String 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```


## emptyArrayToSingle \{#emptyArrayToSingle\}

도입된 버전: v1.1

빈 배열을 인수로 받아 기본값과 동일한 단일 요소 배열을 반환합니다.

**구문**

```sql
emptyArrayToSingle(arr)
```

**인수**

* `arr` — 빈 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

배열의 기본 타입 값 하나를 포함하는 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**기본 예제**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```


## emptyArrayUInt16 \{#emptyArrayUInt16\}

도입 버전: v1.1

비어 있는 UInt16 배열을 반환합니다.

**구문**

```sql
emptyArrayUInt16()
```

**인수(Arguments)**

* 없음.

**반환 값(Returned value)**

빈 UInt16 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```


## emptyArrayUInt32 \{#emptyArrayUInt32\}

도입된 버전: v1.1

빈 UInt32 배열을 반환합니다.

**구문**

```sql
emptyArrayUInt32()
```

**인수**

* 없음.

**반환 값**

비어 있는 UInt32 배열. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```


## emptyArrayUInt64 \{#emptyArrayUInt64\}

도입 버전: v1.1

빈 UInt64 타입 배열을 반환합니다.

**구문**

```sql
emptyArrayUInt64()
```

**인수(Arguments)**

* 없습니다.

**반환 값(Returned value)**

빈 UInt64 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```


## emptyArrayUInt8 \{#emptyArrayUInt8\}

도입: v1.1

빈 UInt8 배열을 반환합니다.

**구문**

```sql
emptyArrayUInt8()
```

**인수**

* 없음.

**반환 값**

비어 있는 UInt8 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```


## has \{#has\}

도입 버전: v1.1

배열에 지정한 요소가 포함되어 있는지 여부를 반환합니다.

첫 번째 인수가 상수 배열이고 두 번째 인수가 컬럼 또는 표현식인 경우 `has(constant_array, column)`는 `column IN (constant_array)`처럼 동작하며, 최적화를 위해 기본 키 및 데이터 스키핑 인덱스를 사용할 수 있습니다. 예를 들어 `has([1, 10, 100], id)`는 `id`가 `PRIMARY KEY`의 일부인 경우 기본 키 인덱스를 활용할 수 있습니다.

이 최적화는 컬럼이 단조(monotonic) 함수로 감싸져 있는 경우에도 적용됩니다(예: `has([...], toDate(ts))`).

**구문**

```sql
has(arr, x)
```

**인수**

* `arr` — 소스 배열. [`Array(T)`](/sql-reference/data-types/array)
* `x` — 배열에서 검색할 값.

**반환 값**

배열에 지정한 요소가 포함되어 있으면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**기본 사용법**

```sql title=Query
SELECT has([1, 2, 3], 2)
```

```response title=Response
1
```

**찾을 수 없습니다**

```sql title=Query
SELECT has([1, 2, 3], 4)
```

```response title=Response
0
```


## hasAll \{#hasAll\}

도입 버전: v1.1

한 배열이 다른 배열의 부분집합인지 확인합니다.

* 빈 배열은 모든 배열의 부분집합으로 간주됩니다.
* `Null`은 하나의 값으로 처리됩니다.
* 두 배열에서 값의 순서는 중요하지 않습니다.

**구문**

```sql
hasAll(set, subset)
```

**인수**

* `set` — 임의의 타입 요소들로 이루어진 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `subset` — `set`과 공통 상위 타입을 공유하며, `set`의 부분집합인지 테스트할 요소들을 포함하는 임의의 타입 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

* `set`이 `subset`의 모든 요소를 포함하면 `1`.
* 그렇지 않으면 `0`.

`set`과 `subset` 요소가 공통 상위 타입을 공유하지 않으면 `NO_COMMON_TYPE` 예외를 발생시킵니다.

**예시**

**빈 배열**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**NULL 값을 포함한 배열**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**서로 다른 타입의 값이 포함된 배열**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**String 값을 포함한 배열**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**공통 타입이 없는 배열**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Raises a NO_COMMON_TYPE exception
```

**중첩 배열**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```


## hasAny \{#hasAny\}

도입 버전: v1.1

두 배열에 하나 이상의 공통 요소가 있는지 확인합니다.

* `Null`은 하나의 값으로 취급됩니다.
* 두 배열에서 값의 순서는 중요하지 않습니다.

**구문**

```sql
hasAny(arr_x, arr_y)
```

**인수**

* `arr_x` — 요소들로 구성된 임의의 타입 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `arr_y` — 배열 `arr_x`와 공통 상위 타입을 공유하는 임의의 타입 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

* `arr_x`와 `arr_y`에 적어도 하나의 동일한 요소가 있으면 `1`.
* 그렇지 않으면 `0`.

두 배열의 요소 중 공통 상위 타입을 공유하지 않는 요소가 하나라도 있으면 `NO_COMMON_TYPE` 예외가 발생합니다.

**예시**

**한 배열이 비어 있는 경우**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
0
```

**NULL 값이 포함된 배열**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**서로 다른 타입의 값을 담은 배열**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**공통 타입이 없는 배열**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

**중첩 배열**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```


## hasSubstr \{#hasSubstr\}

도입된 버전: v20.6

`array2`의 모든 요소가 `array1` 안에 정확히 같은 순서로 나타나는지 확인합니다.
따라서 `array1 = prefix + array2 + suffix`인 경우에만, 그리고 그 경우에 한해 함수는 `1`을 반환합니다.

다시 말해, 이 함수는 `hasAll` 함수와 같이 `array2`의 모든 요소가 `array1`에 포함되어 있는지 확인합니다.
여기에 더해, `array1`과 `array2` 모두에서 요소들이 동일한 순서로 나타나는지도 확인합니다.

* `array2`가 비어 있으면 함수는 `1`을 반환합니다.
* `Null`은 하나의 값으로 처리됩니다. 즉, `hasSubstr([1, 2, NULL, 3, 4], [2,3])`은 `0`을 반환합니다. 그러나 `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])`은 `1`을 반환합니다.
* 두 배열 모두에서 값의 순서가 중요합니다.

두 배열의 요소 중 공통 상위 타입을 공유하지 않는 것이 하나라도 있으면 `NO_COMMON_TYPE` 예외를 발생시킵니다.

**구문**

```sql
hasSubstr(arr1, arr2)
```

**인수**

* `arr1` — 임의의 타입의 요소 집합을 가진 배열. [`Array(T)`](/sql-reference/data-types/array)
* `arr2` — 임의의 타입의 요소 집합을 가진 배열. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

배열 `arr1`이 배열 `arr2`를 포함하면 `1`을 반환합니다. 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**두 배열이 모두 비어 있는 경우**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**NULL 값을 포함한 배열**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**서로 다른 타입의 값이 섞인 배열**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**문자열 배열**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**유효한 순서가 있는 배열**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**순서가 올바르지 않은 배열**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**중첩 배열**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**공통 타입이 없는 배열**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```


## indexOf \{#indexOf\}

도입된 버전: v1.1

배열에 값 &#39;x&#39;인 첫 번째 요소가 존재하는 경우, 해당 요소의 인덱스를 반환합니다(1부터 시작).
배열에 찾는 값이 없으면 함수는 `0`을 반환합니다.

`NULL`로 설정된 요소는 일반 값처럼 처리됩니다.

**구문**

```sql
indexOf(arr, x)
```

**인수**

* `arr` — `x`를 검색할 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `x` — `arr`에서 첫 번째로 일치하는 요소의 값으로, 해당 요소의 인덱스를 반환하는 기준 값입니다. [`UInt64`](/sql-reference/data-types/int-uint)

**반환 값**

`arr`에 `x`가 존재하면 첫 번째 `x`의 인덱스(1부터 시작)를 반환합니다. 존재하지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**기본 예제**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**NULL 값을 포함한 배열**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```


## indexOfAssumeSorted \{#indexOfAssumeSorted\}

도입 버전: v24.12

배열에 값 &#39;x&#39;가 포함되어 있으면, 해당 값과 같은 첫 번째 요소의 인덱스를 반환합니다(`1`부터 시작합니다).
배열에 찾는 값이 없으면 함수는 `0`을 반환합니다.

:::note
`indexOf` 함수와 달리, 이 함수는 배열이 오름차순으로 정렬되어 있다고 가정합니다.
배열이 정렬되어 있지 않으면 결과는 정의되지 않습니다.
:::

**구문**

```sql
indexOfAssumeSorted(arr, x)
```

**인수**

* `arr` — 검색할 정렬된 배열. [`Array(T)`](/sql-reference/data-types/array)
* `x` — 정렬된 `arr`에서 처음으로 일치하는 요소의 값으로, 해당 요소의 인덱스를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**반환 값**

`arr`에 `x`가 존재하면 처음 나타나는 `x`의 인덱스(1부터 시작)를 반환합니다. 존재하지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**기본 예시**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```


## length \{#length\}

도입된 버전: v1.1

문자열 또는 배열의 길이를 계산합니다.

* String 또는 FixedString 인수: 문자열의 바이트 수를 계산합니다.
* Array 인수: 배열의 요소 개수를 계산합니다.
* FixedString 인수에 적용되는 경우, 이 함수는 상수 식입니다.

문자열의 바이트 수는 Unicode &quot;code points&quot;의 개수와 같지 않으며,
Unicode &quot;grapheme clusters&quot;(일반적으로 &quot;문자&quot;라고 부르는 것)의 개수와도 같지 않고,
화면에 표시되는 문자열 너비와도 같지 않습니다.

문자열에 ASCII NULL 바이트가 포함되어 있어도 허용되며, 이들도 길이에 포함되어 계산됩니다.

**Syntax**

```sql
length(x)
```

**별칭(Aliases)**: `OCTET_LENGTH`

**인자(Arguments)**

* `x` — `String`/`FixedString`인 경우 바이트 수를, `Array`인 경우 요소 수를 계산할 값입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring) 또는 [`Array(T)`](/sql-reference/data-types/array)

**반환 값(Returned value)**

String/FixedString `x`의 바이트 수 또는 배열 `x`의 요소 수를 [`UInt64`](/sql-reference/data-types/int-uint) 형으로 반환합니다.

**예시(Examples)**

**String 예시**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**배열 예제**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**constexpr 예제**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**유니코드 예제**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ascii&#95;vs&#95;utf8 예시**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```


## notEmpty \{#notEmpty\}

도입 버전: v1.1

입력 배열이 비어 있지 않은지 확인합니다.

배열에 최소 하나의 요소가 포함되어 있으면 비어 있지 않은 것으로 간주합니다.

:::note
[`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns) 설정을 활성화하여 최적화할 수 있습니다. `optimize_functions_to_subcolumns = 1`인 경우, 함수는 전체 배열 컬럼을 읽고 처리하는 대신 [size0](/sql-reference/data-types/array#array-size) 서브컬럼만 읽습니다. 쿼리 `SELECT notEmpty(arr) FROM table`는 `SELECT arr.size0 != 0 FROM TABLE`로 변환됩니다.
:::

이 함수는 String 또는 UUID 타입에도 사용할 수 있습니다.

**구문**

```sql
notEmpty(arr)
```

**인수**

* `arr` — 입력 배열. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

비어 있지 않은 배열이면 `1`, 비어 있는 배열이면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예제**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```


## range \{#range\}

도입된 버전: v1.1

`start`부터 `end - 1`까지 `step` 간격으로 숫자 배열을 반환합니다.

지원되는 타입은 다음과 같습니다.

* `UInt8/16/32/64`

* `Int8/16/32/64`

* 모든 인수 `start`, `end`, `step`은 위에서 지원되는 타입 중 하나여야 합니다. 반환되는 배열 요소의 타입은 인수들의 상위(super) 타입이 됩니다.

* 함수가 반환하는 배열의 전체 길이가 설정 [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block)에 지정된 요소 개수보다 많으면 예외가 발생합니다.

* 어느 인수든 `Nullable(nothing)` 타입이면 `NULL`을 반환합니다. 어느 인수든 `NULL` 값(`Nullable(T)` 타입)을 가지면 예외가 발생합니다.

**구문**

```sql
range([start, ] end [, step])
```

**인수**

* `start` — 선택입니다. 배열의 첫 번째 요소입니다. `step`을 사용하는 경우 필수입니다. 기본값: `0`. - `end` — 필수입니다. 배열을 생성할 때 사용하는 상한 값이며, 이 값은 포함되지 않습니다. - `step` — 선택입니다. 배열의 각 요소 사이의 증가 간격을 결정합니다. 기본값: `1`.

**반환 값**

`start`부터 `end - 1`까지 `step` 간격으로 증가하는 숫자 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예제**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```


## replicate \{#replicate\}

도입 버전: v1.1

단일 값만 포함하는 배열을 생성합니다.

**구문**

```sql
replicate(x, arr)
```

**인수**

* `x` — 결과 배열을 채울 값입니다. [`Any`](/sql-reference/data-types)
* `arr` — 배열입니다. [`Array(T)`](/sql-reference/data-types/array)

**반환 값**

배열 `arr`와 길이가 같고 값 `x`로 채워진 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT replicate(1, ['a', 'b', 'c']);
```

```response title=Response
┌─replicate(1, ['a', 'b', 'c'])───┐
│ [1, 1, 1]                       │
└─────────────────────────────────┘
```


## reverse \{#reverse\}

도입된 버전: v1.1

입력 배열의 요소 순서 또는 입력 문자열의 문자 순서를 역순으로 반환합니다.

**구문**

```sql
reverse(arr | str)
```

**인수**

* `arr | str` — 원본 배열 또는 문자열입니다. [`Array(T)`](/sql-reference/data-types/array) 또는 [`String`](/sql-reference/data-types/string)

**반환 값**

요소 또는 문자의 순서를 뒤집은 배열 또는 문자열을 반환합니다.

**예시**

**배열 순서 뒤집기**

```sql title=Query
SELECT reverse([1, 2, 3, 4]);
```

```response title=Response
[4, 3, 2, 1]
```

**문자열 뒤집기**

```sql title=Query
SELECT reverse('abcd');
```

```response title=Response
'dcba'
```

{/*AUTOGENERATED_END*/ }


## 거리 함수 \{#distance-functions\}

모든 지원 거리 함수는 [거리 함수 문서](../../sql-reference/functions/distance-functions.md)에서 설명되어 있습니다.
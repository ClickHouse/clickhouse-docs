---
'description': 'Documentation for logical functions'
'sidebar_label': 'Logical'
'slug': '/sql-reference/functions/logical-functions'
'title': '논리 함수'
'doc_type': 'reference'
---


# 논리 함수

아래의 함수들은 임의의 숫자형 타입의 인자에 대한 논리 연산을 수행합니다. 
이들은 `0` 또는 `1`을 [ `UInt8`](../data-types/int-uint.md)로 반환하며, 경우에 따라 `NULL`을 반환하기도 합니다.

인자로서의 제로는 `false`로 간주되며, 비제로 값은 `true`로 간주됩니다.

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## and {#and}

도입된 버전: v1.1


두 개 이상의 값의 논리 곱을 계산합니다.

[`short_circuit_function_evaluation`](/operations/settings/settings#short_circuit_function_evaluation) 설정은 단락 평가가 사용되는지를 제어합니다. 
활성화된 경우, `val_i`는 `(val_1 AND val_2 AND ... AND val_{i-1})`가 `true`인 경우에만 평가됩니다.

예를 들어, 단락 평가로 `SELECT and(number = 2, intDiv(1, number)) FROM numbers(5)` 쿼리를 실행할 때 0으로 나누기 예외가 발생하지 않습니다.
인자로서의 제로는 `false`로 간주되며, 비제로 값은 `true`로 간주됩니다.


**문법**

```sql
and(val1, val2[, ...])
```

**인자**

- `val1, val2[, ...]` — 최소 두 개의 값 목록입니다. [`Nullable((U)Int*)`](/sql-reference/data-types/nullable) 또는 [`Nullable(Float*)`](/sql-reference/data-types/nullable)


**반환 값**

다음 값을 반환합니다:
- `0`, 만약 적어도 하나의 인자가 `false`로 평가됩니다.
- `NULL`, 만약 어떤 인자도 `false`로 평가되지 않으며 적어도 하나의 인자가 `NULL`인 경우
- `1`, 그렇지 않으면
         [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**예시**

**기본 사용법**

```sql title=Query
SELECT and(0, 1, -2);
```

```response title=Response
0
```

**NULL과 함께**

```sql title=Query
SELECT and(NULL, 1, 10, -2);
```

```response title=Response
ᴺᵁᴸᴸ
```



## not {#not}

도입된 버전: v1.1


값의 논리 부정을 계산합니다.
인자로서의 제로는 `false`로 간주되며, 비제로 값은 `true`로 간주됩니다.


**문법**

```sql
not(val)
```

**인자**

- `val` — 값입니다. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)


**반환 값**

다음 값을 반환합니다:
- `1`, 만약 `val`이 `false`로 평가될 경우
- `0`, 만약 `val`이 `true`로 평가될 경우
- `NULL`, 만약 `val`이 `NULL일 경우`.
         [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**예시**

**기본 사용법**

```sql title=Query
SELECT NOT(1);
```

```response title=Response
0
```



## or {#or}

도입된 버전: v1.1


두 개 이상의 값의 논리 합을 계산합니다.

[`short_circuit_function_evaluation`](https://clickhouse.com/docs/operations/settings/settings#short_circuit_function_evaluation) 설정은 단락 평가가 사용되는지를 제어합니다. 
활성화된 경우, `val_i`는 `((NOT val_1) AND (NOT val_2) AND ... AND (NOT val_{i-1}))`가 `true`인 경우에만 평가됩니다.

예를 들어, 단락 평가로 `SELECT or(number = 0, intDiv(1, number) != 0) FROM numbers(5)` 쿼리를 실행할 때 0으로 나누기 예외가 발생하지 않습니다.
인자로서의 제로는 `false`로 간주되며, 비제로 값은 `true`로 간주됩니다.


**문법**

```sql
or(val1, val2[, ...])
```

**인자**

- `val1, val2[, ...]` — 최소 두 개의 값 목록입니다. [`Nullable((U)Int*)`](/sql-reference/data-types/nullable) 또는 [`Nullable(Float*)`](/sql-reference/data-types/nullable)


**반환 값**

다음 값을 반환합니다:
- `1`, 만약 적어도 하나의 인자가 `true`로 평가됩니다.
- `0`, 만약 모든 인자가 `false`로 평가됩니다.
- `NULL`, 만약 모든 인자가 `false`로 평가되고 적어도 하나의 인자가 `NULL`인 경우
         [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**예시**

**기본 사용법**

```sql title=Query
SELECT or(1, 0, 0, 2, NULL);
```

```response title=Response
1
```

**NULL과 함께**

```sql title=Query
SELECT or(0, NULL);
```

```response title=Response
ᴺᵁᴸᴸ
```



## xor {#xor}

도입된 버전: v1.1


두 개 이상의 값의 논리 배타적 합을 계산합니다.
두 개 이상의 입력 값에 대해 함수는 먼저 두 값을 xor 연산한 후, 그 결과와 세 번째 값으로 xor 연산을 수행하는 식입니다.
인자로서의 제로는 `false`로 간주되며, 비제로 값은 `true`로 간주됩니다.


**문법**

```sql
xor(val1, val2[, ...])
```

**인자**

- `val1, val2[, ...]` — 최소 두 개의 값 목록입니다. [`Nullable((U)Int*)`](/sql-reference/data-types/nullable) 또는 [`Nullable(Float*)`](/sql-reference/data-types/nullable)


**반환 값**

다음 값을 반환합니다:
- `1`, 두 값의 경우: 하나의 값이 `false`로 평가되고 다른 값은 평가되지 않는 경우
- `0`, 두 값의 경우: 두 값 모두 `false`로 평가되거나 두 값 모두 `true`로 평가되는 경우
- `NULL`, 입력 값 중 하나가 `NULL`인 경우.
         [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**예시**

**기본 사용법**

```sql title=Query
SELECT xor(0, 1, 1);
```

```response title=Response
0
```



<!--AUTOGENERATED_END-->

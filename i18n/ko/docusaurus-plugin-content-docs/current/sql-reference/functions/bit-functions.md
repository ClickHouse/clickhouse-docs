---
description: '비트 함수 문서'
sidebar_label: '비트'
slug: /sql-reference/functions/bit-functions
title: '비트 함수'
doc_type: 'reference'
---

# 비트 함수 \{#bit-functions\}

비트 함수는 `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, `Float32`, `Float64` 중 임의의 두 타입 조합에 대해 동작합니다. 일부 함수는 `String` 및 `FixedString` 타입도 지원합니다.

결과 타입은 인수들 중 최대 비트 수에 해당하는 비트를 갖는 정수입니다. 인수 중 하나라도 부호가 있는 타입이면 결과는 부호 있는 정수가 됩니다. 인수가 부동 소수점 숫자인 경우 `Int64`로 캐스팅됩니다.

{/* 
  아래 태그 안의 내용은 문서 프레임워크를 빌드할 때 
  system.functions에서 생성된 문서로 대체됩니다. 태그를 수정하거나 삭제하지 마십시오.
  참고: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## bitAnd \{#bitAnd\}

도입된 버전: v1.1

두 값에 대해 비트 단위 AND 연산을 수행합니다.

**구문**

```sql
bitAnd(a, b)
```

**인수**

* `a` — 첫 번째 값. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
* `b` — 두 번째 값. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

`a AND b` 비트 단위 연산의 결과를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitAnd(a, b)
FROM bits
```

```response title=Response
┌─a─┬─b─┬─bitAnd(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            0 │
│ 1 │ 0 │            0 │
│ 1 │ 1 │            1 │
└───┴───┴──────────────┘
```

## bitCount \{#bitCount\}

도입 버전: v20.3

숫자를 이진수로 표현했을 때 1로 설정된 비트 수를 계산합니다.

**구문**

```sql
bitCount(x)
```

**인수**

* `x` — 정수 또는 부동 소수점 값. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

`x`에서 값이 1인 비트의 개수를 반환합니다. 반환 타입은 [`UInt8`](../data-types/int-uint.md)입니다.

:::note
이 함수는 입력 값을 더 큰 타입으로 변환하지 않습니다([부호 확장](https://en.wikipedia.org/wiki/Sign_extension)).
예를 들어, `bitCount(toUInt8(-1)) = 8`입니다.
:::

**예시**

**사용 예시**

```sql title=Query
SELECT bin(333), bitCount(333);
```

```response title=Response
┌─bin(333)─────────┬─bitCount(333)─┐
│ 0000000101001101 │             5 │
└──────────────────┴───────────────┘
```

## bitHammingDistance \{#bitHammingDistance\}

도입 버전: v21.1

두 숫자의 비트 표현 간 [해밍 거리](https://en.wikipedia.org/wiki/Hamming_distance)를 반환합니다.
부분적으로 중복된 문자열을 탐지하기 위해 [`SimHash`](../../sql-reference/functions/hash-functions.md#ngramSimHash) 함수와 함께 사용할 수 있습니다.
거리가 작을수록 문자열이 더 유사합니다.

**구문**

```sql
bitHammingDistance(x, y)
```

**인수**

* `x` — 해밍(Hamming) 거리 계산을 위한 첫 번째 숫자. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
* `y` — 해밍(Hamming) 거리 계산을 위한 두 번째 숫자. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

`x`와 `y` 사이의 해밍(Hamming) 거리를 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitHammingDistance(111, 121);
```

```response title=Response
┌─bitHammingDistance(111, 121)─┐
│                            3 │
└──────────────────────────────┘
```

## bitNot \{#bitNot\}

도입: v1.1

비트 단위 NOT 연산을 수행합니다.

**구문**

```sql
bitNot(a)
```

**인수**

* `a` — 비트 NOT 연산을 적용할 값입니다. [`(U)Int*`](/sql-reference/data-types/int-uint), [`Float*`](/sql-reference/data-types/float) 또는 [`String`](/sql-reference/data-types/string)

**반환 값**

`~a`, 즉 각 비트가 반전된 `a`의 결과를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT
    CAST('5', 'UInt8') AS original,
    bin(original) AS original_binary,
    bitNot(original) AS result,
    bin(bitNot(original)) AS result_binary;
```

```response title=Response
┌─original─┬─original_binary─┬─result─┬─result_binary─┐
│        5 │ 00000101        │    250 │ 11111010      │
└──────────┴─────────────────┴────────┴───────────────┘
```

## bitOr \{#bitOr\}

도입 버전: v1.1

두 값에 대해 비트 단위 OR 연산을 수행합니다.

**구문**

```sql
bitOr(a, b)
```

**인수**

* `a` — 첫 번째 값. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
* `b` — 두 번째 값. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

비트 단위 OR 연산 `a OR b`의 결과를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitOr(a, b)
FROM bits;
```

```response title=Response
┌─a─┬─b─┬─bitOr(a, b)─┐
│ 0 │ 0 │           0 │
│ 0 │ 1 │           1 │
│ 1 │ 0 │           1 │
│ 1 │ 1 │           1 │
└───┴───┴─────────────┘
```

## bitRotateLeft \{#bitRotateLeft\}

도입된 버전: v1.1

비트를 지정한 개수만큼 왼쪽으로 회전합니다. 왼쪽에서 밀려나간 비트는 오른쪽 끝으로 되돌아옵니다.

**구문**

```sql
bitRotateLeft(a, N)
```

**인자**

* `a` — 회전할 값입니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `N` — 왼쪽으로 회전할 비트 수입니다. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

`a`와 동일한 타입의 회전된 값을 반환합니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT 99 AS a, bin(a), bitRotateLeft(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=Response
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       141 │ 10001101       │
└────┴──────────┴───────────┴────────────────┘
```

## bitRotateRight \{#bitRotateRight\}

도입된 버전: v1.1

비트를 지정한 개수만큼 오른쪽으로 회전합니다. 밀려나간 비트는 왼쪽 끝으로 되돌아옵니다.

**구문**

```sql
bitRotateRight(a, N)
```

**인수**

* `a` — 회전할 값. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `N` — 오른쪽으로 회전할 비트 수. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

`a`와 동일한 타입의 회전된 값을 반환합니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT 99 AS a, bin(a), bitRotateRight(a, 2) AS a_rotated, bin(a_rotated);
```

```response title=Response
┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐
│ 99 │ 01100011 │       216 │ 11011000       │
└────┴──────────┴───────────┴────────────────┘
```

## bitShiftLeft \{#bitShiftLeft\}

도입 버전: v1.1

값의 이진 표현을 지정된 비트 수만큼 왼쪽으로 시프트합니다.

`FixedString` 또는 `String`은 하나의 멀티바이트 값으로 취급됩니다.

`FixedString` 값의 비트는 시프트되어 범위를 벗어나면 손실됩니다.
반대로 `String` 값은 추가 바이트로 확장되므로 비트가 손실되지 않습니다.

**구문**

```sql
bitShiftLeft(a, N)
```

**인수**

* `a` — 시프트할 값입니다. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `N` — 시프트할 위치 수입니다. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

`a`와 동일한 타입의 시프트된 값을 반환합니다.

**예시**

**바이너리 인코딩을 사용한 예**

```sql title=Query
SELECT 99 AS a, bin(a), bitShiftLeft(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=Response
┌──a─┬─bin(99)──┬─a_shifted─┬─bin(bitShiftLeft(99, 2))─┐
│ 99 │ 01100011 │       140 │ 10001100                 │
└────┴──────────┴───────────┴──────────────────────────┘
```

**16진수 인코딩을 사용한 예**

```sql title=Query
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftLeft('abc', 4))─┐
│ abc │ 616263     │ &0        │ 06162630                    │
└─────┴────────────┴───────────┴─────────────────────────────┘
```

**Fixed String 인코딩 사용 예제**

```sql title=Query
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftLeft(toFixedString('abc', 3), 4))─┐
│ abc │ 616263                       │ &0        │ 162630                                        │
└─────┴──────────────────────────────┴───────────┴───────────────────────────────────────────────┘
```

## bitShiftRight \{#bitShiftRight\}

도입된 버전: v1.1

값의 이진 표현을 지정된 비트 수만큼 오른쪽으로 시프트합니다.

`FixedString` 또는 `String`은 하나의 멀티바이트 값으로 취급됩니다.

`FixedString` 값의 비트는 시프트되면서 버려집니다.
반면 `String` 값은 추가 바이트로 확장되므로 비트가 손실되지 않습니다.

**구문**

```sql
bitShiftRight(a, N)
```

**인수**

* `a` — 시프트할 값입니다. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `N` — 시프트할 위치 수입니다. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

`a`와 동일한 타입의 시프트된 값을 반환합니다.

**예시**

**이진 인코딩을 사용한 예제**

```sql title=Query
SELECT 101 AS a, bin(a), bitShiftRight(a, 2) AS a_shifted, bin(a_shifted);
```

```response title=Response
┌───a─┬─bin(101)─┬─a_shifted─┬─bin(bitShiftRight(101, 2))─┐
│ 101 │ 01100101 │        25 │ 00011001                   │
└─────┴──────────┴───────────┴────────────────────────────┘
```

**16진수 인코딩 사용 예**

```sql title=Query
SELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftRight('abc', 12))─┐
│ abc │ 616263     │           │ 0616                          │
└─────┴────────────┴───────────┴───────────────────────────────┘
```

**FixedString 인코딩 사용 예**

```sql title=Query
SELECT toFixedString('abc', 3) AS a, hex(a), bitShiftRight(a, 12) AS a_shifted, hex(a_shifted);
```

```response title=Response
┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftRight(toFixedString('abc', 3), 12))─┐
│ abc │ 616263                       │           │ 000616                                          │
└─────┴──────────────────────────────┴───────────┴─────────────────────────────────────────────────┘
```

## bitSlice \{#bitSlice\}

도입 버전: v22.2

&#39;offset&#39; 인덱스에 해당하는 비트부터 시작하여 &#39;length&#39; 비트 길이의 부분 비트열을 반환합니다.

**문법**

```sql
bitSlice(s, offset[, length])
```

**인수**

* `s` — 슬라이스할 `String` 또는 `FixedString`입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `offset` —
  시작 비트 위치(1부터 시작하는 인덱스)를 나타냅니다.
* 양수 값: 문자열의 시작부터 셉니다.
* 음수 값: 문자열의 끝에서부터 셉니다.

  [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
* `length` —
  선택 사항입니다. 추출할 비트 수입니다.
* 양수 값: `length` 비트를 추출합니다.
* 음수 값: offset부터 `(string_length - |length|)`까지 추출합니다.
* 생략 시: offset부터 문자열 끝까지 추출합니다.
* length가 8의 배수가 아니면, 결과는 오른쪽에 0으로 패딩됩니다.
  [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

추출된 비트를 이진 시퀀스로 표현한 문자열을 반환합니다. 결과는 항상 바이트 경계(8비트의 배수)에 맞춰 패딩됩니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 8));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 2));
SELECT bin('Hello'), bin(bitSlice('Hello', 1, 9));
SELECT bin('Hello'), bin(bitSlice('Hello', -4, 8));
```

```response title=Response
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 8))─┐
│ 0100100001100101011011000110110001101111 │ 01001000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 2))─┐
│ 0100100001100101011011000110110001101111 │ 01000000                     │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 9))─┐
│ 0100100001100101011011000110110001101111 │ 0100100000000000             │
└──────────────────────────────────────────┴──────────────────────────────┘
┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', -4, 8))─┐
│ 0100100001100101011011000110110001101111 │ 11110000                      │
└──────────────────────────────────────────┴───────────────────────────────┘
```

## bitTest \{#bitTest\}

도입된 버전: v1.1

임의의 수를 받아 [이진수 형식](https://en.wikipedia.org/wiki/Binary_number)으로 변환한 다음, 지정된 위치에 있는 비트의 값을 반환합니다. 비트 위치는 오른쪽에서 왼쪽으로 0부터 번호를 매깁니다.

**구문**

```sql
bitTest(a, i)
```

**인수**

* `a` — 변환할 수. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
* `i` — 반환할 비트의 위치. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

`a`의 이진 표현에서 위치 `i`에 있는 비트 값을 반환합니다. 반환 타입: [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bin(2), bitTest(2, 1);
```

```response title=Response
┌─bin(2)───┬─bitTest(2, 1)─┐
│ 00000010 │             1 │
└──────────┴───────────────┘
```

## bitTestAll \{#bitTestAll\}

도입: v1.1

지정된 위치의 모든 비트에 대한 [논리곱](https://en.wikipedia.org/wiki/Logical_conjunction) (AND 연산자) 결과를 반환합니다.
오른쪽에서 왼쪽으로, 0부터 번호를 매겨 셉니다.

두 비트 사이의 논리 AND는 두 입력 비트가 모두 참일 때에만 참이 됩니다.

**구문**

```sql
bitTestAll(a, index1[, index2, ... , indexN])
```

**인수**

* `a` — 정수 값. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `index1, ...` — 하나 이상의 비트 위치. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

논리곱(AND) 연산의 결과를 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예제 1**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(43, 0, 1, 3, 5)─┐
│ 00101011 │                          1 │
└──────────┴────────────────────────────┘
```

**사용 예 2**

```sql title=Query
SELECT bitTestAll(43, 0, 1, 3, 5, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAll(4⋯1, 3, 5, 2)─┐
│ 00101011 │                        0 │
└──────────┴──────────────────────────┘
```

## bitTestAny \{#bitTestAny\}

도입 버전: v1.1

숫자에서 지정된 위치에 있는 모든 비트에 대한 [논리합](https://en.wikipedia.org/wiki/Logical_disjunction) (OR 연산자) 결과를 반환합니다.
비트 위치는 오른쪽에서 왼쪽으로, 0부터 매겨집니다.

두 비트 사이의 논리 OR 연산은 입력 비트 중 하나 이상이 참이면 참이 됩니다.

**구문**

```sql
bitTestAny(a, index1[, index2, ... , indexN])
```

**인수**

* `a` — 정수 값. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)
* `index1, ...` — 하나 또는 여러 개의 비트 위치. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

논리합 결과를 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예제 1**

```sql title=Query
SELECT bitTestAny(43, 0, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAny(43, 0, 2)─┐
│ 00101011 │                    1 │
└──────────┴──────────────────────┘
```

**사용 예 2**

```sql title=Query
SELECT bitTestAny(43, 4, 2);
```

```response title=Response
┌─bin(43)──┬─bitTestAny(43, 4, 2)─┐
│ 00101011 │                    0 │
└──────────┴──────────────────────┘
```

## bitXor \{#bitXor\}

도입 버전: v1.1

두 값에 대해 비트 단위 배타적 논리합(XOR) 연산을 수행합니다.

**구문**

```sql
bitXor(a, b)
```

**인수**

* `a` — 첫 번째 값. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
* `b` — 두 번째 값. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

비트 단위 연산인 `a XOR b`의 결과를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE bits
(
    `a` UInt8,
    `b` UInt8
)
ENGINE = Memory;

INSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);

SELECT
    a,
    b,
    bitXor(a, b)
FROM bits;
```

```response title=Response
┌─a─┬─b─┬─bitXor(a, b)─┐
│ 0 │ 0 │            0 │
│ 0 │ 1 │            1 │
│ 1 │ 0 │            1 │
│ 1 │ 1 │            0 │
└───┴───┴──────────────┘
```

{/*AUTOGENERATED_END*/ }

---
'description': '인코딩 함수에 대한 Documentation'
'sidebar_label': '인코딩'
'slug': '/sql-reference/functions/encoding-functions'
'title': '인코딩 함수'
'keywords':
- 'encoding'
- 'regular functions'
- 'encode'
- 'decode'
'doc_type': 'reference'
---



# 인코딩 함수

<!-- 
아래 태그의 내부 콘텐츠는 doc 프레임워크 빌드 시간에 system.functions에서 생성된 문서로 대체됩니다. 
태그를 수정하거나 제거하지 마십시오.
자세한 내용: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## bech32Decode {#bech32Decode}

도입됨: v25.6


bech32 또는 bech32m 알고리즘으로 생성된 Bech32 주소 문자열을 디코드합니다.

:::note
encode 함수와 달리, `Bech32Decode`는 자동으로 패딩된 FixedStrings를 처리합니다.
:::
    

**구문**

```sql
bech32Decode(address)
```

**인수**

- `address` — 디코드할 Bech32 문자열. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)


**반환 값**

문자열을 인코딩하는 데 사용된 `(hrp, data)`로 구성된 튜플을 반환합니다. 데이터는 이진 형식입니다. [`Tuple(String, String)`](/sql-reference/data-types/tuple)

**예제**

**주소 디코드**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z') AS tup)
```

```response title=Response
bc   751E76E8199196D454941C45D1B3A323F1433BD6
```

**테스트넷 주소**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('tb1w508d6qejxtdg4y5r3zarvary0c5xw7kzp034v') AS tup)
```

```response title=Response
tb   751E76E8199196D454941C45D1B3A323F1433BD6
```



## bech32Encode {#bech32Encode}

도입됨: v25.6


이진 데이터 문자열과 사람에게 읽을 수 있는 부분(HRP)을 인코딩합니다. [Bech32 또는 Bech32m](https://en.bitcoin.it/wiki/Bech32) 알고리즘을 사용합니다.

:::note
[`FixedString`](../data-types/fixedstring.md) 데이터 유형을 사용할 때, 값이 행을 완전히 채우지 않으면 null 문자로 패딩됩니다.
`bech32Encode` 함수는 hrp 인수에 대해 이를 자동으로 처리하지만, data 인수의 값은 패딩되지 않아야 합니다.
이 때문에 데이터 값에 대해 [`FixedString`](../data-types/fixedstring.md) 데이터 유형을 사용하는 것은 권장되지 않습니다. 모든 값이 동일한 길이라는 것을 확신할 수 있고, `FixedString` 컬럼도 그러한 길이로 설정되어 있어야 합니다.
:::
    

**구문**

```sql
bech32Encode(hrp, data[, witver])
```

**인수**

- `hrp` — 코드의 "사람이 읽을 수 있는 부분"을 지정하는 `1 - 83`개의 소문자 문자로 구성된 문자열. 일반적으로 'bc' 또는 'tb'입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
- `data` — 인코딩할 이진 데이터의 문자열. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
- `witver` — 선택 사항. 증인 버전(기본값 = 1). 실행할 알고리즘의 버전을 지정하는 `UInt*`. `0`은 Bech32, `1` 이상은 Bech32m을 의미합니다. [`UInt*`](/sql-reference/data-types/int-uint)


**반환 값**

사람이 읽을 수 있는 부분, 항상 '1'인 구분 기호 및 데이터 부분으로 구성된 Bech32 주소 문자열을 반환합니다. 문자열의 길이는 90자를 초과하지 않습니다. 알고리즘이 입력으로부터 유효한 주소를 생성할 수 없는 경우 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 Bech32m**

```sql title=Query
-- When no witness version is supplied, the default is 1, the updated Bech32m algorithm.
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'))
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7k8zcwmq
```

**Bech32 알고리즘**

```sql title=Query
-- A witness version of 0 will result in a different address string.
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 0)
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z
```

**사용자 정의 HRP**

```sql title=Query
-- While 'bc' (Mainnet) and 'tb' (Testnet) are the only allowed hrp values for the
-- SegWit address format, Bech32 allows any hrp that satisfies the above requirements.
SELECT bech32Encode('abcdefg', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 10)
```

```response title=Response
abcdefg1w508d6qejxtdg4y5r3zarvary0c5xw7k9rp8r4
```



## bin {#bin}

도입됨: v21.8


다음 논리에 따라 인수의 이진 표현을 포함하는 문자열을 반환합니다:

| 유형                       | 설명                                                                                                                                                                                                                                                           |
|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `(U)Int*`                  | 가장 중요한 비트에서 가장 덜 중요한 비트까지(bin 숫자)를 출력합니다(빅 엔디안 또는 "사람이 읽을 수 있는" 순서). 가장 중요한 비트가 0이 아닌 첫 번째 바이트부터 시작하지만, 가장 중요한 비트가 0일 경우 모든 바이트는 항상 8 비트씩 출력됩니다.|
| `Date` 및 `DateTime`      | 해당 정수로 포맷됩니다(날짜의 경우 에포크 이후의 일 수, 날짜 및 시간의 경우 유닉스 타임스탬프 값).                                                                                                                                           |
| `String` 및 `FixedString` | 모든 바이트는 단순히 8개의 이진 숫자로 인코딩됩니다. 제로 바이트는 생략되지 않습니다.                                                                                                                                                                                     |
| `Float*` 및 `Decimal`     | 메모리에서의 표현으로 인코딩됩니다. 우리는 리틀 엔디안 아키텍처를 지원하기 때문에 리틀 엔디안으로 인코딩됩니다. 제로 선행/후행 바이트는 생략되지 않습니다.                                                                                                  |
| `UUID`                     | 빅 엔디안 순서 문자열로 인코딩됩니다.                                                                                                                                                                                                                                   |
    

**구문**

```sql
bin(arg)
```

**인수**

- `arg` — 이진으로 변환할 값. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal) 또는 [`Date`](/sql-reference/data-types/date) 또는 [`DateTime`](/sql-reference/data-types/datetime)


**반환 값**

인수의 이진 표현과 함께 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**간단한 정수**

```sql title=Query
SELECT bin(14)
```

```response title=Response
┌─bin(14)──┐
│ 00001110 │
└──────────┘
```

**Float32 숫자**

```sql title=Query
SELECT bin(toFloat32(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────┐
│ 00000000000000000111000001000001 │
│ 00000000000000001000000001000001 │
└──────────────────────────────────┘
```

**Float64 숫자**

```sql title=Query
SELECT bin(toFloat64(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────────────────────────────────────┐
│ 0000000000000000000000000000000000000000000000000010111001000000 │
│ 0000000000000000000000000000000000000000000000000011000001000000 │
└──────────────────────────────────────────────────────────────────┘
```

**UUID 변환**

```sql title=Query
SELECT bin(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')) AS bin_uuid
```

```response title=Response
┌─bin_uuid─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ 01100001111100001100010000000100010111001011001100010001111001111001000001111011101001100000000001101010110100111101101110100000 │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```



## bitPositionsToArray {#bitPositionsToArray}

도입됨: v21.7


이 함수는 부호 없는 정수의 이진 표현에서 1 비트의 위치(오름차순)를 반환합니다.
부호 있는 입력 정수는 먼저 부호 없는 정수로 형변환됩니다.
    

**구문**

```sql
bitPositionsToArray(arg)
```

**인수**

- `arg` — 정수 값. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

입력의 이진 표현에서 1 비트의 오름차순으로 정렬된 위치가 포함된 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예제**

**단일 비트 설정**

```sql title=Query
SELECT bitPositionsToArray(toInt8(1)) AS bit_positions
```

```response title=Response
┌─bit_positions─┐
│ [0]           │
└───────────────┘
```

**모든 비트 설정**

```sql title=Query
SELECT bitPositionsToArray(toInt8(-1)) AS bit_positions
```

```response title=Response
┌─bit_positions─────────────┐
│ [0, 1, 2, 3, 4, 5, 6, 7]  │
└───────────────────────────┘
```



## bitmaskToArray {#bitmaskToArray}

도입됨: v1.1


이 함수는 정수를 2의 거듭제곱의 합으로 분해합니다.
2의 거듭제곱은 오름차순 배열로 반환됩니다.
    

**구문**

```sql
bitmaskToArray(num)
```

**인수**

- `num` — 정수 값. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

입력 숫자로 합해지는 2의 거듭제곱으로 오름차순으로 정렬된 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예제**

**기본 예제**

```sql title=Query
SELECT bitmaskToArray(50) AS powers_of_two
```

```response title=Response
┌─powers_of_two───┐
│ [2, 16, 32]     │
└─────────────────┘
```

**단일 2의 거듭제곱**

```sql title=Query
SELECT bitmaskToArray(8) AS powers_of_two
```

```response title=Response
┌─powers_of_two─┐
│ [8]           │
└───────────────┘
```



## bitmaskToList {#bitmaskToList}

도입됨: v1.1


bitmaskToArray와 유사하지만 2의 거듭제곱을 쉼표로 구분된 문자열로 반환합니다.
    

**구문**

```sql
bitmaskToList(num)
```

**인수**

- `num` — 정수 값. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

쉼표로 구분된 2의 거듭제곱이 포함된 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 예제**

```sql title=Query
SELECT bitmaskToList(50) AS powers_list
```

```response title=Response
┌─powers_list───┐
│ 2, 16, 32     │
└───────────────┘
```



## char {#char}

도입됨: v20.1


전달된 인수의 수만큼 길이가 같은 문자열을 반환하며, 각 바이트는 해당 인수의 값을 가집니다. 숫자 유형의 여러 인수를 허용합니다.

만약 인수의 값이 `UInt8` 데이터 유형의 범위를 벗어나는 경우, 가능성 있는 반올림 및 오버플로우와 함께 `UInt8`로 변환됩니다.
        

**구문**

```sql
char(num1[, num2[, ...]])
```

**인수**

- `num1[, num2[, num3 ...]]` — 정수로 해석되는 숫자 인수. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)


**반환 값**

주어진 바이트의 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 예제**

```sql title=Query
SELECT char(104.1, 101, 108.9, 108.9, 111) AS hello;
```

```response title=Response
┌─hello─┐
│ hello │
└───────┘
```

**임의 인코딩 구성**

```sql title=Query
-- You can construct a string of arbitrary encoding by passing the corresponding bytes.
-- for example UTF8
SELECT char(0xD0, 0xBF, 0xD1, 0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1, 0x82) AS hello;
```

```response title=Response
┌─hello──┐
│ привет │
└────────┘
```



## hex {#hex}

도입됨: v1.1


다음 논리에 따라 인수의 16진수 표현을 포함하는 문자열을 반환합니다:

| 유형                       | 설명                                                                                                                                                                                                                                                                            |
|----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `(U)Int*`                  | 가장 중요한 비트에서 가장 덜 중요한 비트까지(빅 엔디안 또는 "사람이 읽을 수 있는" 순서)로 16진수 숫자("니블")를 출력합니다. 가장 중요한 비트가 0이 아닌 첫 번째 바이트부터 시작하지만 가장 중요한 비트가 0일 경우에도 항상 두 자리 숫자를 출력합니다. |
| `Date` 및 `DateTime`      | 해당 정수로 포맷됩니다(날짜의 경우 에포크 이후의 일 수, 날짜 및 시간의 경우 유닉스 타임스탬프 값).                                                                                                                                                            |
| `String` 및 `FixedString` | 모든 바이트는 단순히 두 개의 16진수 숫자로 인코딩됩니다. 제로 바이트는 생략되지 않습니다.                                                                                                                                                                                                   |
| `Float*` 및 `Decimal`     | 메모리에서의 표현으로 인코딩됩니다. ClickHouse는 이러한 값을 내부적으로 항상 리틀 엔디안으로 표현하므로, 따라서 그렇게 인코딩됩니다. 제로 선행/후행 바이트는 생략되지 않습니다.                                                                                                                   |
| `UUID`                     | 빅 엔디안 순서 문자열로 인코딩됩니다.                                                                                                                                                                                                                                                    |

이 함수는 대문자 `A-F`를 사용하며 접두사(예: `0x`)나 접미사(예: `h`)를 사용하지 않습니다.
    

**구문**

```sql
hex(arg)
```

**인수**

- `arg` — 16진수로 변환할 값. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal) 또는 [`Date`](/sql-reference/data-types/date) 또는 [`DateTime`](/sql-reference/data-types/datetime)


**반환 값**

인수의 16진수 표현과 함께 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**간단한 정수**

```sql title=Query
SELECT hex(1)
```

```response title=Response
01
```

**Float32 숫자**

```sql title=Query
SELECT hex(toFloat32(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 00007041         │
│ 00008041         │
└──────────────────┘
```

**Float64 숫자**

```sql title=Query
SELECT hex(toFloat64(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 0000000000002E40 │
│ 0000000000003040 │
└──────────────────┘
```

**UUID 변환**

```sql title=Query
SELECT lower(hex(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'))) AS uuid_hex
```

```response title=Response
┌─uuid_hex─────────────────────────┐
│ 61f0c4045cb311e7907ba6006ad3dba0 │
└──────────────────────────────────┘
```



## hilbertDecode {#hilbertDecode}

도입됨: v24.6


Hilbert 곡선 인덱스를 결합하여 다차원 공간의 좌표를 나타내는 부호 없는 정수의 튜플로 되돌립니다.

`hilbertEncode` 함수와 마찬가지로 이 함수는 두 가지 작동 모드를 가지고 있습니다:
- **간단 모드**
- **확장 모드**

**간단 모드**

최대 2개의 부호 없는 정수를 인수로 받아 `UInt64` 코드를 생성합니다.

**확장 모드**

범위 마스크(튜플)를 첫 번째 인수로 받아 최대 2개의 부호 없는 정수를 다른 인수로 받습니다. 마스크의 각 숫자는 해당 인수를 왼쪽으로 이동시키는 비트 수를 설정하여, 효과적으로 해당 인수를 범위 내에서 스케일링합니다.

범위 확장은 대칭 분포에 많은 차이가 있는 인수들 간의 유사한 분포가 필요할 때 유익할 수 있습니다. 예를 들어: 'IP 주소' `(0...FFFFFFFF)` 및 '국가 코드' `(0...FF)`. 인코딩 함수와 마찬가지로 가장 많은 숫자는 8개로 제한됩니다.
    

**구문**

```sql
hilbertDecode(tuple_size, code)
```

**인수**

- `tuple_size` — 최대 `2`인 정수 값. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — `UInt64` 코드. [`UInt64`](/sql-reference/data-types/int-uint)


**반환 값**

지정된 크기의 튜플을 반환합니다. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**예제**

**간단 모드**

```sql title=Query
SELECT hilbertDecode(2, 31)
```

```response title=Response
["3", "4"]
```

**단일 인수**

```sql title=Query
-- Hilbert code for one argument is always the argument itself (as a tuple).
SELECT hilbertDecode(1, 1)
```

```response title=Response
["1"]
```

**확장 모드**

```sql title=Query
-- A single argument with a tuple specifying bit shifts will be right-shifted accordingly.
SELECT hilbertDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**컬럼 사용**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';
insert into hilbert_numbers (*) values(1,2);

-- Use column names instead of constants as function arguments
SELECT untuple(hilbertDecode(2, hilbertEncode(n1, n2))) FROM hilbert_numbers;
```

```response title=Response
1    2
```



## hilbertEncode {#hilbertEncode}

도입됨: v24.6


부호 없는 정수 목록의 Hilbert Curve 코드 값을 계산합니다.

이 함수는 두 가지 작동 모드를 가지고 있습니다:
- **간단 모드**
- **확장 모드**

**간단 모드**

최대 2개의 부호 없는 정수를 인수로 받아 UInt64 코드를 생성합니다.

**확장 모드**

범위 마스크([Tuple](../../sql-reference/data-types/tuple.md))를 첫 번째 인수로 받아 최대 2개의 [부호 없는 정수](../../sql-reference/data-types/int-uint.md)로 다른 인수를 받습니다.

마스크의 각 숫자는 해당 인수를 왼쪽으로 이동시키는 비트 수를 설정하여, 효과적으로 해당 인수를 범위 내에서 스케일링합니다.
    

**구문**

```sql
-- Simplified mode
hilbertEncode(args)

-- Expanded mode
hilbertEncode(range_mask, args)
```

**인수**

- `args` — 최대 두 개의 `UInt` 값 또는 `UInt` 유형의 컬럼. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 확장 모드를 위한 최대 두 개의 `UInt` 값 또는 `UInt` 유형의 컬럼. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**반환 값**

`UInt64` 코드를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**간단 모드**

```sql title=Query
SELECT hilbertEncode(3, 4)
```

```response title=Response
31
```

**확장 모드**

```sql title=Query
-- Range expansion can be beneficial when you need a similar distribution for
-- arguments with wildly different ranges (or cardinality).
-- For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF).
-- Note: tuple size must be equal to the number of the other arguments.
SELECT hilbertEncode((10, 6), 1024, 16)
```

```response title=Response
4031541586602
```

**단일 인수**

```sql title=Query
-- For a single argument without a tuple, the function returns the argument
-- itself as the Hilbert index, since no dimensional mapping is needed.
SELECT hilbertEncode(1)
```

```response title=Response
1
```

**확장 단일 인수**

```sql title=Query
-- If a single argument is provided with a tuple specifying bit shifts, the function
-- shifts the argument left by the specified number of bits.
SELECT hilbertEncode(tuple(2), 128)
```

```response title=Response
512
```

**컬럼 사용**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1;
insert into hilbert_numbers (*) values(1, 2);

-- Use column names instead of constants as function arguments
SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;
```

```response title=Response
13
```



## mortonDecode {#mortonDecode}

도입됨: v24.6


Morton 인코딩(ZCurve)을 해당 부호 없는 정수 튜플로 디코드합니다.

`mortonEncode` 함수와 마찬가지로 이 함수는 두 가지 작동 모드를 가지고 있습니다:
- **간단 모드**
- **확장 모드**

**간단 모드**

결과 튜플 크기를 첫 번째 인수로 받고 코드 값을 두 번째 인수로 받습니다.

**확장 모드**

범위 마스크(튜플)를 첫 번째 인수로 받고 코드 값을 두 번째 인수로 받습니다.
마스크의 각 숫자는 범위 축소의 양을 설정합니다:

* `1` - 축소 없음
* `2` - 2배 축소
* `3` - 3배 축소
⋮
* 최대 8배 축소.

범위 확장은 대칭 분포에 많은 차이가 있는 인수들 간의 유사한 분포가 필요할 때 유익할 수 있습니다. 예를 들어: 'IP 주소' `(0...FFFFFFFF)` 및 '국가 코드' `(0...FF)`. 인코딩 함수와 마찬가지로 이를 위해서는 최대 8개 숫자로 제한됩니다.
    

**구문**

```sql
-- Simple mode
mortonDecode(tuple_size, code)

-- Expanded mode
mortonDecode(range_mask, code)
```

**인수**

- `tuple_size` — 8을 초과하지 않는 정수 값. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 확장 모드에서 각 인수를 위한 마스크. 마스크는 부호 없는 정수의 튜플입니다. 마스크의 각 숫자는 축소의 양을 설정합니다. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
- `code` — UInt64 코드. [`UInt64`](/sql-reference/data-types/int-uint)


**반환 값**

지정된 크기의 튜플을 반환합니다. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**예제**

**간단 모드**

```sql title=Query
SELECT mortonDecode(3, 53)
```

```response title=Response
["1", "2", "3"]
```

**단일 인수**

```sql title=Query
SELECT mortonDecode(1, 1)
```

```response title=Response
["1"]
```

**확장 모드, 하나의 인수 축소**

```sql title=Query
SELECT mortonDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**컬럼 사용**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- Use column names instead of constants as function arguments
SELECT untuple(mortonDecode(8, mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8))) FROM morton_numbers;
```

```response title=Response
1 2 3 4 5 6 7 8
```



## mortonEncode {#mortonEncode}

도입됨: v24.6


부호 없는 정수 목록에 대한 Morton 인코딩(ZCurve)을 계산합니다.

이 함수는 두 가지 작동 모드를 가지고 있습니다:
- **간단 모드**
- **확장 모드**

**간단 모드**

최대 8개의 부호 없는 정수를 인수로 받아 `UInt64` 코드를 생성합니다.

**확장 모드**

범위 마스크([Tuple](../data-types/tuple.md))를 첫 번째 인수로 받고 최대 8개의 [부호 없는 정수](../data-types/int-uint.md)로 다른 인수를 받습니다.

마스크의 각 숫자는 범위 확장의 양을 설정합니다:
* 1 - 확장 없음
* 2 - 2배 확장
* 3 - 3배 확장
⋮
* 최대 8배 확장.
    

**구문**

```sql
-- Simplified mode
mortonEncode(args)

-- Expanded mode
mortonEncode(range_mask, args)
```

**인수**

- `args` — 최대 8개의 부호 없는 정수 또는 위에서 설명한 유형의 컬럼. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
- `range_mask` — 확장 모드를 위한 각 인수에 대한 마스크. 마스크는 `1` - `8` 범위의 부호 없는 정수 튜플입니다. 각 숫자는 축소의 양을 설정합니다. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)


**반환 값**

`UInt64` 코드를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**간단 모드**

```sql title=Query
SELECT mortonEncode(1, 2, 3)
```

```response title=Response
53
```

**확장 모드**

```sql title=Query
-- Range expansion can be beneficial when you need a similar distribution for
-- arguments with wildly different ranges (or cardinality)
-- For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF).
-- Note: the Tuple size must be equal to the number of the other arguments.
SELECT mortonEncode((1,2), 1024, 16)
```

```response title=Response
1572864
```

**단일 인수**

```sql title=Query
-- Morton encoding for one argument is always the argument itself
SELECT mortonEncode(1)
```

```response title=Response
1
```

**확장 단일 인수**

```sql title=Query
SELECT mortonEncode(tuple(2), 128)
```

```response title=Response
32768
```

**컬럼 사용**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- Use column names instead of constants as function arguments
SELECT mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8) FROM morton_numbers;
```

```response title=Response
2155374165
```



## sqidDecode {#sqidDecode}

도입됨: v24.1


[sqid](https://sqids.org/)를 숫자 배열로 변환합니다.
    

**구문**

```sql
sqidDecode(sqid)
```

**인수**

- `sqid` — 디코드할 sqid. [`String`](/sql-reference/data-types/string)


**반환 값**

`sqid`에서 숫자 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT sqidDecode('gXHfJ1C6dN');
```

```response title=Response
┌─sqidDecode('gXHfJ1C6dN')─────┐
│ [1, 2, 3, 4, 5]              │
└──────────────────────────────┘
```



## sqidEncode {#sqidEncode}

도입됨: v24.1


숫자를 [sqid](https://sqids.org/)로 변환합니다. 유튜브와 유사한 ID 문자열입니다.
    

**구문**

```sql
sqidEncode(n1[, n2, ...])
```

**별칭**: `sqid`

**인수**

- `n1[, n2, ...]` — 임의의 숫자. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)


**반환 값**

해시 ID를 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**사용 예제**

```sql title=Query
SELECT sqidEncode(1, 2, 3, 4, 5);
```

```response title=Response
┌─sqidEncode(1, 2, 3, 4, 5)─┐
│ gXHfJ1C6dN                │
└───────────────────────────┘
```



## unbin {#unbin}

도입됨: v21.8


각 이진 숫자 쌍(인수에서)을 숫자로 해석하고 해당 숫자가 나타내는 바이트로 변환합니다. 이 함수는 bin의 반대 작업을 수행합니다.

숫자 인수에 대해 `unbin()`은 `bin()`의 역을 반환하지 않습니다. 결과를 숫자로 변환하려면 역으로 그리고 `reinterpretAs<Type>` 함수를 사용할 수 있습니다.

:::note
`unbin`이 `clickhouse-client` 내에서 호출되면 이진 문자열은 UTF-8로 표시됩니다.
:::

이진 숫자 `0` 및 `1`을 지원합니다. 이진 숫자의 수는 8의 배수가 아닐 필요가 없습니다. 인수 문자열에 이진 숫자가 아닌 다른 것이 포함되어 있으면 결과는 정의되지 않습니다(예외가 발생하지 않습니다).
    

**구문**

```sql
unbin(arg)
```

**인수**

- `arg` — 이진 숫자를 포함하는 문자열. [`String`](/sql-reference/data-types/string)


**반환 값**

이진 문자열(BLOB)을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 사용법**

```sql title=Query
SELECT UNBIN('001100000011000100110010'), UNBIN('0100110101111001010100110101000101001100')
```

```response title=Response
┌─unbin('001100000011000100110010')─┬─unbin('0100110101111001010100110101000101001100')─┐
│ 012                               │ MySQL                                             │
└───────────────────────────────────┴───────────────────────────────────────────────────┘
```

**숫자로 변환**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unbin('1110'))) AS num
```

```response title=Response
┌─num─┐
│  14 │
└─────┘
```



## unhex {#unhex}

도입됨: v1.1


[`hex`](#hex)의 반대 작업을 수행합니다. 인수에서 각 쌍의 16진수 숫자를 해석하여 해당 숫자가 나타내는 바이트로 변환합니다. 반환 값은 이진 문자열(BLOB)입니다.

결과를 숫자로 변환하고 싶다면 `reverse` 및 `reinterpretAs<Type>` 함수를 사용할 수 있습니다.

:::note
`clickhouse-client`는 문자열을 UTF-8로 해석합니다.
이로 인해 `hex`가 반환한 값이 예상치 않게 표시될 수 있습니다.
:::

대문자 및 소문자 `A-F` 모두 지원합니다.
16진수 숫자의 수는 반드시 짝수일 필요는 없습니다.
홀수인 경우 마지막 숫자는 `00-0F` 바이트의 가장 덜 중요한 절반으로 해석됩니다.
인수 문자열에 16진수 숫자가 아닌 다른 것이 포함된 경우 일부 구현 정의된 결과가 반환됩니다(예외가 발생하지 않습니다).
숫자 인수의 경우 hex(N)의 역 연산은 unhex()에서 수행되지 않습니다.


**구문**

```sql
unhex(arg)
```

**인수**

- `arg` — 16진수 숫자를 포함하는 문자열. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)


**반환 값**

이진 문자열(BLOB)을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 사용법**

```sql title=Query
SELECT unhex('303132'), UNHEX('4D7953514C')
```

```response title=Response
┌─unhex('303132')─┬─unhex('4D7953514C')─┐
│ 012             │ MySQL               │
└─────────────────┴─────────────────────┘
```

**숫자로 변환**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unhex('FFF'))) AS num
```

```response title=Response
┌──num─┐
│ 4095 │
└──────┘
```



<!--AUTOGENERATED_END-->

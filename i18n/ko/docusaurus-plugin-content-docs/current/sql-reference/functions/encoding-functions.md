---
description: '인코딩 함수 문서'
sidebar_label: '인코딩'
slug: /sql-reference/functions/encoding-functions
title: '인코딩 함수'
keywords: ['인코딩', '일반 함수', '인코드', '디코드']
doc_type: 'reference'
---

# 인코딩 함수 \{#encoding-functions\}

{/* 
  아래 태그 안의 내용은 문서 프레임워크를 빌드할 때
  system.functions에서 생성된 문서로 대체됩니다. 태그를 수정하거나 제거하지 마십시오.
  자세한 내용은 https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md 를 참조하십시오.
  */ }

{/*AUTOGENERATED_START*/ }

## bech32Decode \{#bech32Decode\}

도입 버전: v25.6

bech32 또는 bech32m 알고리즘으로 생성된 Bech32 주소 문자열을 디코딩합니다.

:::note
인코딩 함수와 달리 `Bech32Decode`는 패딩된 FixedString 값을 자동으로 처리합니다.
:::

**구문**

```sql
bech32Decode(address)
```

**인수**

* `address` — 디코딩할 Bech32 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)

**반환 값**

문자열을 인코딩하는 데 사용된 `(hrp, data)`로 구성된 튜플을 반환합니다. 여기서 `data`는 바이너리 형식입니다. [`Tuple(String, String)`](/sql-reference/data-types/tuple)

**예시**

**주소 디코딩**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z') AS tup)
```

```response title=Response
bc   751E76E8199196D454941C45D1B3A323F1433BD6
```

**테스트넷 주소**

```sql title=Query
SELECT tup.1 AS hrp, hex(tup.2) AS data FROM (SELECT bech32Decode('tb1w508d6qejxtdg4y5r3zarvary0c5xw7kzp034v') AS tup)
```

```response title=Response
tb   751E76E8199196D454941C45D1B3A323F1433BD6
```

## bech32Encode \{#bech32Encode\}

도입 버전: v25.6

[Bech32 또는 Bech32m](https://en.bitcoin.it/wiki/Bech32) 알고리즘을 사용하여 이진 데이터 문자열과 사람이 읽을 수 있는 부분(HRP)을 함께 인코딩합니다.

:::note
[`FixedString`](../data-types/fixedstring.md) 데이터 타입을 사용할 때 값이 행을 완전히 채우지 않으면 NULL 문자로 패딩됩니다.
`bech32Encode` 함수는 `hrp` 인수에 대해서는 이를 자동으로 처리하지만, `data` 인수에 대해서는 값이 패딩되어 있으면 안 됩니다.
이러한 이유로, 모든 데이터 값의 길이가 동일하며 `FixedString` 컬럼의 길이도 그에 맞게 설정되었음을 확신하지 않는 한
데이터 값에 [`FixedString`](../data-types/fixedstring.md) 데이터 타입을 사용하는 것은 권장되지 않습니다.
:::

**구문**

```sql
bech32Encode(hrp, data[, witver])
```

**인수**

* `hrp` — 코드의 「human-readable part」를 지정하는, `1 - 83`개의 소문자 문자로 이루어진 String입니다. 일반적으로 &#39;bc&#39; 또는 &#39;tb&#39;입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `data` — 인코딩할 이진 데이터를 담는 String입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `witver` — 선택 사항입니다. witness 버전(기본값 = 1)입니다. 실행할 알고리즘의 버전을 지정하는 `UInt*`입니다. Bech32에는 `0`, Bech32m에는 `1` 이상을 사용합니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값**

human-readable part, 항상 &#39;1&#39;인 구분 문자, 데이터 부분으로 구성된 Bech32 주소 문자열을 반환합니다. 문자열 길이는 90자를 초과하지 않습니다. 알고리즘이 입력값으로부터 유효한 주소를 생성하지 못하면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**기본 Bech32m**

```sql title=Query
-- When no witness version is supplied, the default is 1, the updated Bech32m algorithm.
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'))
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7k8zcwmq
```

**Bech32 알고리즘**

```sql title=Query
-- A witness version of 0 will result in a different address string.
SELECT bech32Encode('bc', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 0)
```

```response title=Response
bc1w508d6qejxtdg4y5r3zarvary0c5xw7kj7gz7z
```

**사용자 정의 HRP**

```sql title=Query
-- While 'bc' (Mainnet) and 'tb' (Testnet) are the only allowed hrp values for the
-- SegWit address format, Bech32 allows any hrp that satisfies the above requirements.
SELECT bech32Encode('abcdefg', unhex('751e76e8199196d454941c45d1b3a323f1433bd6'), 10)
```

```response title=Response
abcdefg1w508d6qejxtdg4y5r3zarvary0c5xw7k9rp8r4
```

## bin \{#bin\}

도입 버전: v21.8

인수의 이진 표현을 포함하는 문자열을 다음의 타입별 규칙에 따라 반환합니다:

| Type                       | Description                                                                                                                                |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `(U)Int*`                  | 최상위 비트에서 최하위 비트 순서(빅엔디언 또는 「사람이 읽기 쉬운」 순서)로 이진수를 출력합니다. 가장 의미 있는 0이 아닌 바이트부터 시작하며(앞쪽의 0 바이트는 생략됨), 선행 비트가 0이더라도 각 바이트마다 항상 8자리 2진수를 출력합니다. |
| `Date` and `DateTime`      | 해당 정수 값으로 표현됩니다(`Date`는 epoch 이후 일 수, `DateTime`은 Unix 타임스탬프 값).                                                                           |
| `String` and `FixedString` | 모든 바이트를 단순히 8비트 이진수로 인코딩합니다. 0 바이트도 생략하지 않습니다.                                                                                             |
| `Float*` and `Decimal`     | 메모리상의 표현 그대로 인코딩합니다. 지원 아키텍처가 리틀엔디언이므로 리틀엔디언으로 인코딩합니다. 앞/뒤의 0 바이트도 생략하지 않습니다.                                                              |
| `UUID`                     | 빅엔디언 순서의 문자열로 인코딩됩니다.                                                                                                                      |

**구문**

```sql
bin(arg)
```

**인수**

* `arg` — 2진수로 변환할 값입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal) 또는 [`Date`](/sql-reference/data-types/date) 또는 [`DateTime`](/sql-reference/data-types/datetime)

**반환 값**

인수의 2진 표현을 나타내는 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**단순 정수값**

```sql title=Query
SELECT bin(14)
```

```response title=Response
┌─bin(14)──┐
│ 00001110 │
└──────────┘
```

**Float32 수**

```sql title=Query
SELECT bin(toFloat32(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────┐
│ 00000000000000000111000001000001 │
│ 00000000000000001000000001000001 │
└──────────────────────────────────┘
```

**Float64 수**

```sql title=Query
SELECT bin(toFloat64(number)) AS bin_presentation FROM numbers(15, 2)
```

```response title=Response
┌─bin_presentation─────────────────────────────────────────────────┐
│ 0000000000000000000000000000000000000000000000000010111001000000 │
│ 0000000000000000000000000000000000000000000000000011000001000000 │
└──────────────────────────────────────────────────────────────────┘
```

**UUID 변환**

```sql title=Query
SELECT bin(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')) AS bin_uuid
```

```response title=Response
┌─bin_uuid─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ 01100001111100001100010000000100010111001011001100010001111001111001000001111011101001100000000001101010110100111101101110100000 │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

## bitPositionsToArray \{#bitPositionsToArray\}

도입 버전: v21.7

이 함수는 부호 없는 정수의 이진 표현에서 값이 1인 비트의 위치를 (오름차순으로) 반환합니다.
부호 있는 정수 입력은 먼저 부호 없는 정수로 캐스팅됩니다.

**구문**

```sql
bitPositionsToArray(arg)
```

**인수**

* `arg` — 정수형 값. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

입력 값의 이진 표현에서 1로 설정된 비트의 위치들을 오름차순으로 정렬한 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예시**

**단일 비트만 설정된 경우**

```sql title=Query
SELECT bitPositionsToArray(toInt8(1)) AS bit_positions
```

```response title=Response
┌─bit_positions─┐
│ [0]           │
└───────────────┘
```

**모든 비트가 1로 설정됨**

```sql title=Query
SELECT bitPositionsToArray(toInt8(-1)) AS bit_positions
```

```response title=Response
┌─bit_positions─────────────┐
│ [0, 1, 2, 3, 4, 5, 6, 7]  │
└───────────────────────────┘
```

## bitmaskToArray \{#bitmaskToArray\}

도입 버전: v1.1

이 FUNCTION은 정수를 2의 거듭제곱의 합으로 분해합니다.
2의 거듭제곱은 오름차순으로 정렬된 배열로 반환됩니다.

**구문**

```sql
bitmaskToArray(num)
```

**인수**

* `num` — 정수 값. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

입력 숫자의 합이 되는 2의 거듭제곱들을 오름차순으로 정렬한 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예제**

**기본 예제**

```sql title=Query
SELECT bitmaskToArray(50) AS powers_of_two
```

```response title=Response
┌─powers_of_two───┐
│ [2, 16, 32]     │
└─────────────────┘
```

**단일 2의 거듭제곱수**

```sql title=Query
SELECT bitmaskToArray(8) AS powers_of_two
```

```response title=Response
┌─powers_of_two─┐
│ [8]           │
└───────────────┘
```

## bitmaskToList \{#bitmaskToList\}

도입 버전: v1.1

`bitmaskToArray`와 유사하지만, 2의 거듭제곱 값을 쉼표로 구분된 문자열로 반환합니다.

**구문**

```sql
bitmaskToList(num)
```

**인수**

* `num` — 정수 값. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

2의 거듭제곱을 콤마로 구분한 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 예제**

```sql title=Query
SELECT bitmaskToList(50) AS powers_list
```

```response title=Response
┌─powers_list───┐
│ 2, 16, 32     │
└───────────────┘
```

## char \{#char\}

도입 버전: v20.1

각 바이트의 값이 해당 인자의 값과 같고, 길이가 전달된 인자 개수와 동일한 문자열을 반환합니다. 숫자형 인자를 여러 개 전달할 수 있습니다.

인자 값이 `UInt8` 데이터 타입의 범위를 벗어나면, 잠재적인 반올림 및 오버플로와 함께 `UInt8`로 변환됩니다.

**구문**

```sql
char(num1[, num2[, ...]])
```

**인자**

* `num1[, num2[, num3 ...]]` — 정수로 해석되는 숫자형 인자입니다. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

지정된 바이트를 표현하는 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 예제**

```sql title=Query
SELECT char(104.1, 101, 108.9, 108.9, 111) AS hello;
```

```response title=Response
┌─hello─┐
│ hello │
└───────┘
```

**임의 인코딩 생성**

```sql title=Query
-- You can construct a string of arbitrary encoding by passing the corresponding bytes.
-- for example UTF8
SELECT char(0xD0, 0xBF, 0xD1, 0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1, 0x82) AS hello;
```

```response title=Response
┌─hello──┐
│ привет │
└────────┘
```

## hex \{#hex\}

도입 시점: v1.1

다음과 같은 타입별 로직에 따라 인수의 16진수 표현을 포함하는 문자열을 반환합니다:

| Type                       | Description                                                                                                                                           |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `(U)Int*`                  | 가장 상위 비트부터 하위 비트까지의 16진수 숫자(「nibbles」)를 출력합니다(빅 엔디언, 즉 사람이 읽기 쉬운 순서). 가장 상위의 0이 아닌 바이트부터 시작하며(선행 0 바이트는 생략), 각 바이트는 선행 숫자가 0이더라도 항상 두 자리 16진수로 출력합니다. |
| `Date` and `DateTime`      | 각각 정수 값으로 포맷됩니다(Date는 epoch 이후 일 수, DateTime은 유닉스 타임스탬프 값).                                                                                           |
| `String` and `FixedString` | 모든 바이트를 단순히 두 자리 16진수 숫자로 인코딩합니다. 0 바이트도 생략되지 않습니다.                                                                                                   |
| `Float*` and `Decimal`     | 메모리 상의 표현 그대로 인코딩됩니다. ClickHouse는 값을 내부적으로 항상 리틀 엔디언으로 표현하므로, 해당 순서대로 인코딩됩니다. 앞이나 뒤에 오는 0 바이트도 생략되지 않습니다.                                             |
| `UUID`                     | 빅 엔디언 순서의 문자열로 인코딩됩니다.                                                                                                                                |

이 함수는 대문자 `A-F`를 사용하며, 접두사(예: `0x`)나 접미사(예: `h`)는 사용하지 않습니다.

**Syntax**

```sql
hex(arg)
```

**인수**

* `arg` — 16진수 문자열로 변환할 값입니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal) 또는 [`Date`](/sql-reference/data-types/date) 또는 [`DateTime`](/sql-reference/data-types/datetime)

**반환 값**

인수의 16진수 표현으로 된 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**단순 정수**

```sql title=Query
SELECT hex(1)
```

```response title=Response
01
```

**Float32 부동소수점 수**

```sql title=Query
SELECT hex(toFloat32(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 00007041         │
│ 00008041         │
└──────────────────┘
```

**Float64 부동소수점 수**

```sql title=Query
SELECT hex(toFloat64(number)) AS hex_presentation FROM numbers(15, 2)
```

```response title=Response
┌─hex_presentation─┐
│ 0000000000002E40 │
│ 0000000000003040 │
└──────────────────┘
```

**UUID 변환**

```sql title=Query
SELECT lower(hex(toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'))) AS uuid_hex
```

```response title=Response
┌─uuid_hex─────────────────────────┐
│ 61f0c4045cb311e7907ba6006ad3dba0 │
└──────────────────────────────────┘
```

## hilbertDecode \{#hilbertDecode\}

도입된 버전: v24.6

Hilbert 곡선 인덱스를 다시 부호 없는 정수 튜플로 디코딩하여, 다차원 공간에서의 좌표를 나타냅니다.

`hilbertEncode` 함수와 마찬가지로, 이 함수도 두 가지 동작 모드를 제공합니다.

* **Simple**
* **Expanded**

**Simple 모드**

최대 2개의 부호 없는 정수를 인자로 받아 `UInt64` 코드를 생성합니다.

**Expanded 모드**

첫 번째 인자로 범위 마스크(튜플)를, 그 외 인자로는 최대 2개의 부호 없는 정수를 받습니다. 마스크에 있는 각 숫자는 해당 인자가 왼쪽으로 시프트될 비트 수를 설정하여, 사실상 인자를 해당 범위 내에서 스케일링합니다.

범위 확장은 범위(또는 카디널리티)가 크게 다른 인자들에 대해 비슷한 분포가 필요할 때 유용할 수 있습니다. 예를 들어: &#39;IP Address&#39; `(0...FFFFFFFF)`와 &#39;Country code&#39; `(0...FF)`와 같은 경우입니다. `hilbertEncode` 함수와 마찬가지로, 최대 8개의 숫자로 제한됩니다.

**Syntax**

```sql
hilbertDecode(tuple_size, code)
```

**인수**

* `tuple_size` — `2` 이하의 정수형 값. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
* `code` — `UInt64` 코드. [`UInt64`](/sql-reference/data-types/int-uint)

**반환 값**

지정된 크기의 튜플을 반환합니다. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**예제**

**단순 모드**

```sql title=Query
SELECT hilbertDecode(2, 31)
```

```response title=Response
["3", "4"]
```

**단일 인수**

```sql title=Query
-- Hilbert code for one argument is always the argument itself (as a tuple).
SELECT hilbertDecode(1, 1)
```

```response title=Response
["1"]
```

**확장 모드**

```sql title=Query
-- A single argument with a tuple specifying bit shifts will be right-shifted accordingly.
SELECT hilbertDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**컬럼 사용법**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1 SETTINGS index_granularity_bytes = '10Mi';
insert into hilbert_numbers (*) values(1,2);

-- Use column names instead of constants as function arguments
SELECT untuple(hilbertDecode(2, hilbertEncode(n1, n2))) FROM hilbert_numbers;
```

```response title=Response
1    2
```

## hilbertEncode \{#hilbertEncode\}

도입된 버전: v24.6

부호 없는 정수 목록에 대해 Hilbert 곡선(Hilbert Curve)의 코드를 계산합니다.

이 FUNCTION은 두 가지 동작 모드를 가집니다.

* **단순 모드(Simple)**
* **확장 모드(Expanded)**

**단순 모드(Simple mode)**

최대 2개의 부호 없는 정수를 인수로 받아 `UInt64` 코드를 생성합니다.

**확장 모드(Expanded mode)**

범위 마스크([Tuple](../../sql-reference/data-types/tuple.md))를 첫 번째 인수로,
그리고 최대 2개의 [부호 없는 정수](../../sql-reference/data-types/int-uint.md)를
다른 인수로 받습니다.

마스크의 각 숫자는 해당 인수를 왼쪽으로 시프트할 비트 수를 지정하여,
결과적으로 인수를 해당 범위에 맞게 스케일링합니다.

**구문**

```sql
-- Simplified mode
hilbertEncode(args)

-- Expanded mode
hilbertEncode(range_mask, args)
```

**인수(Arguments)**

* `args` — 최대 2개의 `UInt` 값 또는 `UInt` 타입의 컬럼입니다. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
* `range_mask` — 확장 모드에서, 최대 2개의 `UInt` 값 또는 `UInt` 타입의 컬럼입니다. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

`UInt64` 코드를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**단순 모드**

```sql title=Query
SELECT hilbertEncode(3, 4)
```

```response title=Response
31
```

**확장 모드**

```sql title=Query
-- Range expansion can be beneficial when you need a similar distribution for
-- arguments with wildly different ranges (or cardinality).
-- For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF).
-- Note: tuple size must be equal to the number of the other arguments.
SELECT hilbertEncode((10, 6), 1024, 16)
```

```response title=Response
4031541586602
```

**단일 인자**

```sql title=Query
-- For a single argument without a tuple, the function returns the argument
-- itself as the Hilbert index, since no dimensional mapping is needed.
SELECT hilbertEncode(1)
```

```response title=Response
1
```

**단일 인수 확장형**

```sql title=Query
-- If a single argument is provided with a tuple specifying bit shifts, the function
-- shifts the argument left by the specified number of bits.
SELECT hilbertEncode(tuple(2), 128)
```

```response title=Response
512
```

**컬럼 사용 방법**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE hilbert_numbers(
    n1 UInt32,
    n2 UInt32
)
ENGINE=MergeTree()
ORDER BY n1;
insert into hilbert_numbers (*) values(1, 2);

-- Use column names instead of constants as function arguments
SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;
```

```response title=Response
13
```

## mortonDecode \{#mortonDecode\}

도입 버전: v24.6

Morton 인코딩(ZCurve)을 해당 부호 없는 정수 튜플로 디코딩합니다.

`mortonEncode` 함수와 마찬가지로, 이 함수에는 두 가지 동작 모드가 있습니다:

* **Simple**
* **Expanded**

**Simple 모드**

첫 번째 인수로 결과 튜플의 크기를, 두 번째 인수로 코드를 받습니다.

**Expanded 모드**

첫 번째 인수로 범위 마스크(튜플)를, 두 번째 인수로 코드를 받습니다.
마스크의 각 숫자는 범위 축소 정도를 설정합니다:

* `1` - 축소 없음
* `2` - 2배 축소
* `3` - 3배 축소
  ⋮
* 최대 8배 축소.

범위 확장은 범위(또는 카디널리티)가 크게 다른 인수들에 대해 유사한 분포가 필요할 때 유용합니다.
예: 「IP Address」 `(0...FFFFFFFF)`와 「Country code」 `(0...FF)`. 인코딩 함수와 마찬가지로,
최대 8개의 숫자까지만 허용됩니다.

**Syntax**

```sql
-- Simple mode
mortonDecode(tuple_size, code)

-- Expanded mode
mortonDecode(range_mask, code)
```

**인수**

* `tuple_size` — 8을 넘지 않는 정수 값입니다. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
* `range_mask` — 확장 모드에서 각 인수에 대한 마스크입니다. 마스크는 부호 없는 정수의 튜플입니다. 마스크의 각 숫자는 범위 축소 수준을 설정합니다. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)
* `code` — UInt64 코드입니다. [`UInt64`](/sql-reference/data-types/int-uint)

**반환 값**

지정된 크기의 튜플을 반환합니다. [`Tuple(UInt64)`](/sql-reference/data-types/tuple)

**예시**

**단순 모드**

```sql title=Query
SELECT mortonDecode(3, 53)
```

```response title=Response
["1", "2", "3"]
```

**단일 인자**

```sql title=Query
SELECT mortonDecode(1, 1)
```

```response title=Response
["1"]
```

**확장 모드: 하나의 인자 축소**

```sql title=Query
SELECT mortonDecode(tuple(2), 32768)
```

```response title=Response
["128"]
```

**컬럼 사용법**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- Use column names instead of constants as function arguments
SELECT untuple(mortonDecode(8, mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8))) FROM morton_numbers;
```

```response title=Response
1 2 3 4 5 6 7 8
```

## mortonEncode \{#mortonEncode\}

도입된 버전: v24.6

부호 없는 정수 목록에 대해 Morton 인코딩(ZCurve)을 계산합니다.

이 FUNCTION은 두 가지 동작 모드를 지원합니다.

* **Simple**
* *Expanded**

**Simple mode**

최대 8개의 부호 없는 정수를 인수로 받아 `UInt64` 코드를 생성합니다.

**Expanded mode**

범위 마스크([Tuple](../data-types/tuple.md))를 첫 번째 인수로, 최대 8개의 [부호 없는 정수](../data-types/int-uint.md)를 나머지 인수로 받습니다.

마스크에 있는 각 숫자는 범위 확장 정도를 설정합니다.

* 1 - 확장 없음
* 2 - 2배 확장
* 3 - 3배 확장
  ⋮
* 최대 8배까지 확장.

**구문**

```sql
-- Simplified mode
mortonEncode(args)

-- Expanded mode
mortonEncode(range_mask, args)
```

**인자**

* `args` — 최대 8개의 부호 없는 정수 또는 앞에서 언급한 타입의 컬럼입니다. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)
* `range_mask` — 확장 모드에서 각 인자에 대한 마스크입니다. 마스크는 `1` - `8` 범위의 부호 없는 정수로 구성된 튜플입니다. 마스크의 각 숫자는 범위 축소 정도를 설정합니다. [`Tuple(UInt8/16/32/64)`](/sql-reference/data-types/tuple)

**반환 값**

`UInt64` 코드를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**단순 모드**

```sql title=Query
SELECT mortonEncode(1, 2, 3)
```

```response title=Response
53
```

**확장 모드**

```sql title=Query
-- Range expansion can be beneficial when you need a similar distribution for
-- arguments with wildly different ranges (or cardinality)
-- For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF).
-- Note: the Tuple size must be equal to the number of the other arguments.
SELECT mortonEncode((1,2), 1024, 16)
```

```response title=Response
1572864
```

**단일 인자**

```sql title=Query
-- Morton encoding for one argument is always the argument itself
SELECT mortonEncode(1)
```

```response title=Response
1
```

**단일 인수 확장**

```sql title=Query
SELECT mortonEncode(tuple(2), 128)
```

```response title=Response
32768
```

**컬럼 사용법**

```sql title=Query
-- First create the table and insert some data
CREATE TABLE morton_numbers(
    n1 UInt32,
    n2 UInt32,
    n3 UInt16,
    n4 UInt16,
    n5 UInt8,
    n6 UInt8,
    n7 UInt8,
    n8 UInt8
)
ENGINE=MergeTree()
ORDER BY n1;
INSERT INTO morton_numbers (*) values(1, 2, 3, 4, 5, 6, 7, 8);

-- Use column names instead of constants as function arguments
SELECT mortonEncode(n1, n2, n3, n4, n5, n6, n7, n8) FROM morton_numbers;
```

```response title=Response
2155374165
```

## sqidDecode \{#sqidDecode\}

도입된 버전: v24.1

[sqid](https://sqids.org/)를 다시 숫자 배열로 변환합니다.

**구문**

```sql
sqidDecode(sqid)
```

**인수**

* `sqid` — 디코딩할 sqid입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

`sqid`에서 디코딩한 숫자 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT sqidDecode('gXHfJ1C6dN');
```

```response title=Response
┌─sqidDecode('gXHfJ1C6dN')─────┐
│ [1, 2, 3, 4, 5]              │
└──────────────────────────────┘
```

## sqidEncode \{#sqidEncode\}

도입된 버전: v24.1

숫자를 [sqid](https://sqids.org/) 형식의, YouTube와 유사한 ID 문자열로 변환합니다.

**구문**

```sql
sqidEncode(n1[, n2, ...])
```

**별칭**: `sqid`

**인수**

* `n1[, n2, ...]` — 임의 개수의 숫자. [`UInt8/16/32/64`](/sql-reference/data-types/int-uint)

**반환값**

해시 ID를 나타내는 [`String`](/sql-reference/data-types/string) 값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT sqidEncode(1, 2, 3, 4, 5);
```

```response title=Response
┌─sqidEncode(1, 2, 3, 4, 5)─┐
│ gXHfJ1C6dN                │
└───────────────────────────┘
```

## unbin \{#unbin\}

도입된 버전: v21.8

인수의 이진 숫자를 두 자리씩 묶어 각각을 하나의 숫자로 해석하고, 이 숫자가 나타내는 바이트로 변환합니다. 이 함수는 `bin`과 반대되는 작업을 수행합니다.

숫자형 인수의 경우 `unbin()`은 `bin()`의 역을 반환하지 않습니다. 결과를 숫자로 변환해야 하는 경우 `reverse` 및 `reinterpretAs<Type>` 함수를 사용할 수 있습니다.

:::note
`clickhouse-client` 내에서 `unbin`이 호출되는 경우, 이진 문자열은 UTF-8을 사용하여 표시됩니다.
:::

이진 숫자 `0`과 `1`을 지원합니다. 이진 숫자의 개수는 8의 배수일 필요가 없습니다. 인수 문자열에 이진 숫자 이외의 문자가 포함되어 있으면,
결과는 정의되지 않습니다(예외는 발생하지 않습니다).

**구문**

```sql
unbin(arg)
```

**인수**

* `arg` — 임의 개수의 2진 숫자를 포함하는 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환값**

바이너리 문자열(BLOB)을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 사용법**

```sql title=Query
SELECT UNBIN('001100000011000100110010'), UNBIN('0100110101111001010100110101000101001100')
```

```response title=Response
┌─unbin('001100000011000100110010')─┬─unbin('0100110101111001010100110101000101001100')─┐
│ 012                               │ MySQL                                             │
└───────────────────────────────────┴───────────────────────────────────────────────────┘
```

**숫자형으로 변환**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unbin('1110'))) AS num
```

```response title=Response
┌─num─┐
│  14 │
└─────┘
```

## unhex \{#unhex\}

도입 버전: v1.1

[`hex`](#hex)의 반대 연산을 수행합니다. 인수에 있는 16진수 숫자 쌍 각각을 숫자로 해석한 다음, 그 숫자가 나타내는 바이트로 변환합니다. 반환 값은 바이너리 문자열(BLOB)입니다.

결과를 숫자로 변환하려면 `reverse` 및 `reinterpretAs<Type>` 함수를 사용할 수 있습니다.

:::note
`clickhouse-client`는 문자열을 UTF-8로 해석합니다.
이로 인해 `hex`가 반환하는 값이 예상과 다르게 표시될 수 있습니다.
:::

대문자와 소문자 `A-F` 모두를 지원합니다.
16진수 숫자의 개수는 짝수일 필요가 없습니다.
개수가 홀수인 경우 마지막 숫자는 `00-0F` 바이트의 하위 절반(4비트)으로 해석됩니다.
인수 문자열에 16진수 숫자가 아닌 다른 문자가 포함된 경우, 구현에 따라 정의된 결과가 반환됩니다(예외는 발생하지 않습니다).
숫자 인수에 대해서는 `hex(N)`의 역연산이 `unhex()`에 의해 수행되지 않습니다.

**문법**

```sql
unhex(arg)
```

**인수**

* `arg` — 임의 개수의 16진수 숫자를 포함하는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)

**반환 값**

이진 문자열(BLOB)을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**기본 사용법**

```sql title=Query
SELECT unhex('303132'), UNHEX('4D7953514C')
```

```response title=Response
┌─unhex('303132')─┬─unhex('4D7953514C')─┐
│ 012             │ MySQL               │
└─────────────────┴─────────────────────┘
```

**숫자로 변환**

```sql title=Query
SELECT reinterpretAsUInt64(reverse(unhex('FFF'))) AS num
```

```response title=Response
┌──num─┐
│ 4095 │
└──────┘
```

{/*AUTOGENERATED_END*/ }

---
'description': 'Introspection Functions에 대한 문서'
'sidebar_label': '인트로스펙션'
'slug': '/sql-reference/functions/introspection'
'title': '인트로스펙션 함수'
'doc_type': 'reference'
---


# 탐색 함수

이 장에 설명된 함수를 사용하여 쿼리 프로파일링을 위한 [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) 및 [DWARF](https://en.wikipedia.org/wiki/DWARF)를 탐색할 수 있습니다.

:::note
이 함수들은 느리고 보안 고려 사항이 있을 수 있습니다.
:::

탐색 함수의 적절한 작동을 위해:

- `clickhouse-common-static-dbg` 패키지를 설치합니다.

- [allow_introspection_functions](../../operations/settings/settings.md#allow_introspection_functions) 설정을 1로 설정합니다.

        보안상의 이유로 탐색 함수는 기본적으로 비활성화되어 있습니다.

ClickHouse는 프로파일러 보고서를 [trace_log](/operations/system-tables/trace_log) 시스템 테이블에 저장합니다. 테이블과 프로파일러가 적절하게 구성되어 있는지 확인하세요.

<!--
The inner content of the tags below are replaced at doc framework build time with
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## demangle {#demangle}

도입 버전: v20.1


기호를 C++ 함수 이름으로 변환합니다.
기호는 일반적으로 `addressToSymbol` 함수에 의해 반환됩니다.
    

**구문**

```sql
demangle(symbol)
```

**인수**

- `symbol` — 오브젝트 파일의 기호. [`String`](/sql-reference/data-types/string)


**반환 값**

유효한 기호가 아닐 경우 C++ 함수의 이름을 반환하거나 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**`trace_log` 시스템 테이블에서 첫 번째 문자열 선택하기**

```sql title=Query
SELECT * FROM system.trace_log LIMIT 1 \G;
```

```response title=Response
-- The `trace` field contains the stack trace at the moment of sampling.
Row 1:
──────
event_date:    2019-11-20
event_time:    2019-11-20 16:57:59
revision:      54429
timer_type:    Real
thread_number: 48
query_id:      724028bf-f550-45aa-910d-2af6212b94ac
trace:         [94138803686098,94138815010911,94138815096522,94138815101224,94138815102091,94138814222988,94138806823642,94138814457211,94138806823642,94138814457211,94138806823642,94138806795179,94138806796144,94138753770094,94138753771646,94138753760572,94138852407232,140399185266395,140399178045583]
```

**단일 주소에 대한 함수 이름 가져오기**

```sql title=Query
SET allow_introspection_functions=1;
SELECT demangle(addressToSymbol(94138803686098)) \G;
```

```response title=Response
Row 1:
──────
demangle(addressToSymbol(94138803686098)): DB::IAggregateFunctionHelper<DB::AggregateFunctionSum<unsigned long, unsigned long, DB::AggregateFunctionSumData<unsigned long> > >::addBatchSinglePlace(unsigned long, char*, DB::IColumn const**, DB::Arena*) const
```

**전체 스택 추적에 함수 적용하기**

```sql title=Query
SET allow_introspection_functions=1;

-- The arrayMap function allows to process each individual element of the trace array by the demangle function.
-- The result of this processing is shown in the trace_functions column of output.

SELECT
    arrayStringConcat(arrayMap(x -> demangle(addressToSymbol(x)), trace), '\n') AS trace_functions
FROM system.trace_log
LIMIT 1
\G
```

```response title=Response
Row 1:
──────
trace_functions: DB::IAggregateFunctionHelper<DB::AggregateFunctionSum<unsigned long, unsigned long, DB::AggregateFunctionSumData<unsigned long> > >::addBatchSinglePlace(unsigned long, char*, DB::IColumn const**, DB::Arena*) const
DB::Aggregator::executeWithoutKeyImpl(char*&, unsigned long, DB::Aggregator::AggregateFunctionInstruction*, DB::Arena*) const
DB::Aggregator::executeOnBlock(std::vector<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::allocator<COW<DB::IColumn>::immutable_ptr<DB::IColumn> > >, unsigned long, DB::AggregatedDataVariants&, std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> >&, std::vector<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> >, std::allocator<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> > > >&, bool&)
DB::Aggregator::executeOnBlock(DB::Block const&, DB::AggregatedDataVariants&, std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> >&, std::vector<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> >, std::allocator<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*> > > >&, bool&)
DB::Aggregator::execute(std::shared_ptr<DB::IBlockInputStream> const&, DB::AggregatedDataVariants&)
DB::AggregatingBlockInputStream::readImpl()
DB::IBlockInputStream::read()
DB::ExpressionBlockInputStream::readImpl()
DB::IBlockInputStream::read()
DB::ExpressionBlockInputStream::readImpl()
DB::IBlockInputStream::read()
DB::AsynchronousBlockInputStream::calculate()
std::_Function_handler<void (), DB::AsynchronousBlockInputStream::next()::{lambda()#1}>::_M_invoke(std::_Any_data const&)
ThreadPoolImpl<ThreadFromGlobalPool>::worker(std::_List_iterator<ThreadFromGlobalPool>)
ThreadFromGlobalPool::ThreadFromGlobalPool<ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::function<void ()>, int, std::optional<unsigned long>)::{lambda()#3}>(ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::function<void ()>, int, std::optional<unsigned long>)::{lambda()#3}&&)::{lambda()#1}::operator()() const
ThreadPoolImpl<std::thread>::worker(std::_List_iterator<std::thread>)
execute_native_thread_routine
start_thread
clone
```



## isMergeTreePartCoveredBy {#isMergeTreePartCoveredBy}

도입 버전: v25.6


첫 번째 인수의 일부가 두 번째 인수의 부분에 의해 덮여 있는지 확인하는 함수입니다.
    

**구문**

```sql
isMergeTreePartCoveredBy(nested_part, covering_part)
```

**인수**

- `nested_part` — 예상되는 중첩 부분의 이름. [`String`](/sql-reference/data-types/string)
- `covering_part` — 예상되는 커버링 부분의 이름. [`String`](/sql-reference/data-types/string)


**반환 값**

덮여 있을 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**기본 예제**

```sql title=Query
WITH 'all_12_25_7_4' AS lhs, 'all_7_100_10_20' AS rhs
SELECT isMergeTreePartCoveredBy(rhs, lhs), isMergeTreePartCoveredBy(lhs, rhs);
```

```response title=Response
┌─isMergeTreePartCoveredBy(rhs, lhs)─┬─isMergeTreePartCoveredBy(lhs, rhs)─┐
│                                  0 │                                  1 │
└────────────────────────────────────┴────────────────────────────────────┘
```



## logTrace {#logTrace}

도입 버전: v20.12


각 [Block](/development/architecture/#block)에 대한 추적 로그 메시지를 서버 로그에 출력합니다.
    

**구문**

```sql
logTrace(message)
```

**인수**

- `message` — 서버 로그에 출력되는 메시지. [`const String`](/sql-reference/data-types/string)


**반환 값**

항상 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**기본 예제**

```sql title=Query
SELECT logTrace('logTrace message');
```

```response title=Response
┌─logTrace('logTrace message')─┐
│                            0 │
└──────────────────────────────┘
```



## mergeTreePartInfo {#mergeTreePartInfo}

도입 버전: v25.6


`MergeTree` 부분 이름에서 유용한 값을 추출하는 데 도움이 되는 함수입니다.
    

**구문**

```sql
mergeTreePartInfo(part_name)
```

**인수**

- `part_name` — unpack할 부분의 이름. [`String`](/sql-reference/data-types/string)


**반환 값**

`partition_id`, `min_block`, `max_block`, `level`, `mutation` 서브컬럼을 가진 튜플을 반환합니다. [`Tuple`](/sql-reference/data-types/tuple)

**예제**

**기본 예제**

```sql title=Query
WITH mergeTreePartInfo('all_12_25_7_4') AS info
SELECT info.partition_id, info.min_block, info.max_block, info.level, info.mutation;
```

```response title=Response
┌─info.partition_id─┬─info.min_block─┬─info.max_block─┬─info.level─┬─info.mutation─┐
│ all               │             12 │             25 │          7 │             4 │
└───────────────────┴────────────────┴────────────────┴────────────┴───────────────┘
```



## tid {#tid}

도입 버전: v20.12


현재 [Block](/development/architecture/#block)이 처리되고 있는 스레드의 id를 반환합니다.
    

**구문**

```sql
tid()
```

**인수**

- 없음.

**반환 값**

현재 스레드 id를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예시**

```sql title=Query
SELECT tid();
```

```response title=Response
┌─tid()─┐
│  3878 │
└───────┘
```



<!--AUTOGENERATED_END-->

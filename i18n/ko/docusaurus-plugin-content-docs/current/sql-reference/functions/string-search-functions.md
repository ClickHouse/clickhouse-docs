---
'description': 'Functions for Searching in Strings에 대한 문서'
'sidebar_label': '문자열 검색'
'slug': '/sql-reference/functions/string-search-functions'
'title': '문자열에서 검색하는 함수'
'doc_type': 'reference'
---


# 문자열 검색을 위한 함수들

이 섹션의 모든 함수는 기본적으로 대소문자를 구분하여 검색합니다. 대소문자를 무시한 검색은 일반적으로 별도의 함수 변형으로 제공됩니다.

:::note
대소문자를 무시한 검색은 영어의 소문자-대문자 규칙을 따릅니다. 예를 들어 영어에서 대문자 `i`는 `I`인 반면, 터키어에서는 `İ`입니다. 영어 이외의 언어에서는 결과가 예상과 다를 수 있습니다.
:::

이 섹션의 함수들은 검색할 문자열(이 섹션에서 `haystack`이라고 언급됨)과 검색 문자열(이 섹션에서 `needle`이라고 언급됨)이 단일 바이트로 인코딩된 텍스트라는 가정을 합니다. 이 가정이 위배되면 예외가 발생하지 않으며 결과는 정의되지 않습니다. UTF-8로 인코딩된 문자열로 검색은 일반적으로 별도의 함수 변형으로 제공됩니다. 마찬가지로 UTF-8 함수 변형이 사용되며 입력 문자열이 UTF-8로 인코딩된 텍스트가 아닐 경우에도 예외가 발생하지 않고 결과는 정의되지 않습니다. 자동 유니코드 정규화는 수행되지 않지만, [normalizeUTF8*()](https://clickhouse.com../functions/string-functions/) 함수를 사용할 수 있습니다.

[일반 문자열 함수](string-functions.md)와 [문자열에서 대체하는 함수](string-replace-functions.md)는 별도로 설명됩니다.

:::note
아래 문서는 `system.functions` 시스템 테이블에서 생성됩니다.
:::

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## countMatches {#countMatches}

Introduced in: v21.1


정규 표현식이 문자열에서 일치하는 개수를 반환합니다.

:::note 버전 의존적 동작
이 함수의 동작은 ClickHouse 버전에 따라 다릅니다:

- v25.6 이전 버전에서는 패턴이 수용되더라도 첫 번째 빈 일치에서 카운트가 중지됩니다.
- v25.6 이상에서는 빈 일치가 발생할 때 함수가 실행을 계속합니다. 이전 동작은 설정 `count_matches_stop_at_empty_match = true`를 사용하여 복원할 수 있습니다.
:::

**문법**

```sql
countMatches(haystack, pattern)
```

**인수**

- `haystack` — 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
- `pattern` — 정규 표현식 패턴입니다. [`String`](/sql-reference/data-types/string)


**반환 값**

찾은 일치의 개수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**숫자 시퀀스 개수**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```
## countMatchesCaseInsensitive {#countMatchesCaseInsensitive}

Introduced in: v21.1


[`countMatches`](#countMatches)와 유사하지만 대소문자를 구분하지 않고 일치하는 작업을 수행합니다.
    

**문법**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**인수**

- `haystack` — 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
- `pattern` — 정규 표현식 패턴입니다. [`const String`](/sql-reference/data-types/string)


**반환 값**

찾은 일치의 개수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**대소문자를 구분하지 않는 개수**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```
## countSubstrings {#countSubstrings}

Introduced in: v21.1

문자열 `haystack`에서 부분 문자열 `needle`이 얼마나 자주 발생하는지 반환합니다.

**문법**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [String](../../sql-reference/data-types/string.md) 또는 [Enum](../../sql-reference/data-types/enum.md).
- `needle` — 검색할 부분 문자열입니다. [String](../../sql-reference/data-types/string.md).
- `start_pos` — 검색이 시작되는 `haystack`의 위치(1기반)입니다. [UInt](../../sql-reference/data-types/int-uint.md). 선택 사항입니다.

**반환 값**

발생 횟수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**start_pos 인수와 함께**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```
## countSubstringsCaseInsensitive {#countSubstringsCaseInsensitive}

Introduced in: v21.1

[`countSubstrings`](#countSubstrings)와 유사하지만 대소문자를 구분하지 않고 계산합니다.

**문법**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
- `start_pos` — 선택 사항. 검색이 시작되는 `haystack`의 위치(1기반)입니다. [`UInt*`](/sql-reference/data-types/int-uint)


**반환 값**

여전히 `haystack`에서 `needle`의 발생 횟수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**start_pos 인수와 함께**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```
## countSubstringsCaseInsensitiveUTF8 {#countSubstringsCaseInsensitiveUTF8}

Introduced in: v21.1


[`countSubstrings`](#countSubstrings)와 유사하지만 대소문자를 구분하지 않고 세며 haystack이 UTF-8 문자열이라고 가정합니다.
    

**문법**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**인수**

- `haystack` — 검색이 수행되는 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
- `start_pos` — 선택 사항. 검색이 시작되는 `haystack`의 위치(1기반)입니다. [`UInt*`](/sql-reference/data-types/int-uint)


**반환 값**

`haystack`에서 `needle`의 발생 횟수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**start_pos 인수와 함께**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```
## extract {#extract}

Introduced in: v1.1


문자열에서 정규 표현식의 첫 번째 일치를 추출합니다.
'haystack'이 'pattern'과 일치하지 않으면 빈 문자열이 반환됩니다.

이 함수는 RE2 정규 표현식 라이브러리를 사용합니다. 지원되는 문법에 대해서는 [re2](https://github.com/google/re2/wiki/Syntax)를 참조하십시오.

정규 표현식에 캡처 그룹(하위 패턴)이 있는 경우 함수는 입력 문자열을 첫 번째 캡처 그룹에 대해 일치시킵니다.
    

**문법**

```sql
extract(haystack, pattern)
```

**인수**

- `haystack` — 추출할 문자열입니다. [`String`](/sql-reference/data-types/string)
- `pattern` — 일반적으로 캡처 그룹을 포함하는 정규 표현식입니다. [`const String`](/sql-reference/data-types/string)


**반환 값**

추출된 조각을 문자열로 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**이메일에서 도메인 추출**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**일치 없음: 빈 문자열 반환**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```
## extractAll {#extractAll}

Introduced in: v1.1


[`extract`](#extract)와 유사하지만 문자열의 모든 정규 표현식 일치 배열을 반환합니다.
'haystack'이 'pattern' 정규 표현식과 일치하지 않으면 빈 배열이 반환됩니다.

정규 표현식에 캡처 그룹(하위 패턴)이 있는 경우 함수는 입력 문자열을 첫 번째 캡처 그룹에 대해 일치시킵니다.
    

**문법**

```sql
extractAll(haystack, pattern)
```

**인수**

- `haystack` — 조각을 추출할 문자열입니다. [`String`](/sql-reference/data-types/string)
- `pattern` — 선택적으로 캡처 그룹을 포함하는 정규 표현식입니다. [`const String`](/sql-reference/data-types/string)


**반환 값**

추출된 조각 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**모든 숫자 추출**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**캡처 그룹을 사용하여 추출**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```
## extractAllGroupsHorizontal {#extractAllGroupsHorizontal}

Introduced in: v20.5


제공된 정규 표현식을 사용하여 문자열의 모든 그룹을 일치시키고, 각 배열에는 동일한 캡처 그룹에서의 모든 캡처가 그룹 번호에 따라 정리된 배열의 배열을 반환합니다.


**문법**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**인수**

- `s` — 추출할 입력 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — 일치시킬 정규 표현식입니다. [`const String`](/sql-reference/data-types/string) 또는 [`const FixedString`](/sql-reference/data-types/fixedstring)


**반환 값**

각 내부 배열이 모든 일치에서 하나의 캡처 그룹의 모든 캡처를 포함하는 배열의 배열을 반환합니다. 첫 번째 내부 배열은 그룹 1의 모든 캡처를 포함하고, 두 번째는 그룹 2에서, 등등. 일치하는 항목이 없으면 빈 배열을 반환합니다. [`Array(Array(String))`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```
## extractGroups {#extractGroups}

Introduced in: v20.5


정규 표현식에 의해 일치하는 비오버랩 하위 문자열에서 모든 그룹을 추출합니다.
    

**문법**

```sql
extractAllGroups(s, regexp)
```

**인수**

- `s` — 추출할 입력 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
- `regexp` — 정규 표현식. 상수입니다. [`const String`](/sql-reference/data-types/string) 또는 [`const FixedString`](/sql-reference/data-types/fixedstring)


**반환 값**

함수가 적어도 하나의 일치하는 그룹을 찾으면 `group_id`에 의해 클러스터링된 Array(Array(String)) 열을 반환합니다(`1`에서 `N`까지, 여기서 `N`은 regexp의 캡처 그룹 수입니다). 일치하는 그룹이 없으면 빈 배열을 반환합니다. [`Array(Array(String))`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```
## hasAllTokens {#hasAllTokens}

Introduced in: v25.10


[`hasAnyTokens`](#hasAnyTokens)와 유사하지만, `needle` 문자열이나 배열의 모든 토큰이 `input` 문자열과 일치하면 1을 반환하고, 그렇지 않으면 0을 반환합니다. `input`이 열인 경우 조건을 만족하는 모든 행을 반환합니다.

:::note
열 `input`에는 최적의 성능을 위해 [텍스트 인덱스](../../engines/table-engines/mergetree-family/invertedindexes)가 정의되어 있어야 합니다.
텍스트 인덱스가 정의되어 있지 않으면 함수는 브루트 포스 열 스캔을 수행하게 되며, 이는 인덱스 조회보다 몇 배 느립니다.
:::

검색 전에 이 함수는 토큰화합니다.
- `input` 인수(항상) 및
- `needle` 인수(만약 [String](../../sql-reference/data-types/string.md)로 제공되면), 텍스트 인덱스에 지정된 토큰화기를 사용합니다.
열에 텍스트 인덱스가 정의되어 있지 않으면 대신 `splitByNonAlpha` 토큰화기가 사용됩니다.
`needle` 인수가 [Array(String)](../../sql-reference/data-types/array.md) 유형인 경우 각 배열 요소가 토큰으로 간주됩니다 — 추가적인 토큰화는 발생하지 않습니다.

중복 토큰은 무시됩니다.
예를 들어, needles = ['ClickHouse', 'ClickHouse']는 ['ClickHouse']와 동일하게 처리됩니다.
    

**문법**

```sql
hasAllTokens(input, needles)
```

**별칭**: `hasAllToken`

**인수**

- `input` — 입력 열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring) 또는 [`Array(String)`](/sql-reference/data-types/array) 또는 [`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — 검색할 토큰입니다. 최대 64개의 토큰을 지원합니다. [`String`](/sql-reference/data-types/string) 또는 [`Array(String)`](/sql-reference/data-types/array)


**반환 값**

모든 `needle`이 일치하면 1을 반환하고, 그렇지 않으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**문자열 열에 대한 사용 예**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**토큰화 없이 AS-IS로 검색할 필요가 있는 needles 지정**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**`tokens` 함수를 사용하여 needles 생성**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**배열 및 맵 열에 대한 사용 예**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response

```

**배열 열 예**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys로 예제**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapValues로 예제**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```
## hasAnyTokens {#hasAnyTokens}

Introduced in: v25.10


`needle` 문자열이나 배열의 최소한 하나의 토큰이 `input` 문자열과 일치하면 1을 반환하고, 그렇지 않으면 0을 반환합니다. `input`이 열인 경우 조건을 만족하는 모든 행을 반환합니다.

:::note
열 `input`에는 최적의 성능을 위해 [텍스트 인덱스](../../engines/table-engines/mergetree-family/invertedindexes)가 정의되어 있어야 합니다.
텍스트 인덱스가 정의되어 있지 않으면 함수는 브루트 포스 열 스캔을 수행하게 되며, 이는 인덱스 조회보다 몇 배 느립니다.
:::

검색 전에 이 함수는 토큰화합니다.
- `input` 인수(항상) 및
- `needle` 인수(만약 [String](../../sql-reference/data-types/string.md)로 제공되면), 텍스트 인덱스에 지정된 토큰화기를 사용합니다.
열에 텍스트 인덱스가 정의되어 있지 않으면 대신 `splitByNonAlpha` 토큰화기가 사용됩니다.
`needle` 인수가 [Array(String)](../../sql-reference/data-types/array.md) 유형인 경우 각 배열 요소가 토큰으로 간주됩니다 — 추가적인 토큰화는 발생하지 않습니다.

중복 토큰은 무시됩니다.
예를 들어, ['ClickHouse', 'ClickHouse']는 ['ClickHouse']와 동일하게 처리됩니다.
    

**문법**

```sql
hasAnyTokens(input, needles)
```

**별칭**: `hasAnyToken`

**인수**

- `input` — 입력 열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring) 또는 [`Array(String)`](/sql-reference/data-types/array) 또는 [`Array(FixedString)`](/sql-reference/data-types/array)
- `needles` — 검색할 토큰입니다. 최대 64개의 토큰을 지원합니다. [`String`](/sql-reference/data-types/string) 또는 [`Array(String)`](/sql-reference/data-types/array)


**반환 값**

최소한 하나의 일치가 있을 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**문자열 열에 대한 사용 예**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**토큰화 없이 AS-IS로 검색할 필요가 있는 needles 지정**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**`tokens` 함수를 사용하여 needles 생성**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**배열 및 맵 열에 대한 사용 예**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response

```

**배열 열 예**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys로 예제**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**mapValues로 예제**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```
## hasSubsequence {#hasSubsequence}

Introduced in: v23.7


`needle`이 `haystack`의 부분 수열인지 확인합니다.
문자열의 부분 수열은 일부 또는 모든 문자를 삭제하여 다른 문자열에서 유래된 시퀀스로, 남아 있는 문자의 순서는 변경하지 않는 것입니다.
    

**문법**

```sql
hasSubsequence(haystack, needle)
```

**인수**

- `haystack` — 부분 수열을 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 부분 수열입니다. [`String`](/sql-reference/data-types/string)


**반환 값**

`needle`이 `haystack`의 부분 수열이면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**기본 수열 확인**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**수열을 찾을 수 없음**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```
## hasSubsequenceCaseInsensitive {#hasSubsequenceCaseInsensitive}

Introduced in: v23.7

[`hasSubsequence`](#hasSubsequence)와 유사하지만 대소문자를 구분하지 않고 검색합니다.

**문법**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 부분 수열입니다. [`String`](/sql-reference/data-types/string)


**반환 값**

`needle`이 `haystack`의 부분 수열이면 1을 반환하고, 그렇지 않으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```
## hasSubsequenceCaseInsensitiveUTF8 {#hasSubsequenceCaseInsensitiveUTF8}

Introduced in: v23.7

[`hasSubsequenceUTF8`](#hasSubsequenceUTF8)와 유사하지만 대소문자를 구분하지 않고 검색합니다.

**문법**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**인수**

- `haystack` — 검색이 수행되는 UTF8로 인코딩된 문자열입니다. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 UTF8로 인코딩된 부분 수열 문자열입니다. [`String`](/sql-reference/data-types/string)


**반환 값**

`needle`이 `haystack`의 부분 수열이면 1을 반환하고, 그렇지 않으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```
## hasSubsequenceUTF8 {#hasSubsequenceUTF8}

Introduced in: v23.7


[`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence)와 유사하지만 `haystack`과 `needle`이 UTF-8_encoded 문자열이라고 가정합니다.
    

**문법**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**인수**

- `haystack` — 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 부분 수열입니다. [`String`](/sql-reference/data-types/string)


**반환 값**

`needle`이 `haystack`의 부분 수열이면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**일치하지 않는 부분 수열**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```
## hasToken {#hasToken}

Introduced in: v20.1


주어진 토큰이 `haystack`에 존재하는지 확인합니다.

토큰은 `[0-9A-Za-z_]`의 연속적 문자의 가장 긴 가능한 하위 시퀀스입니다. 즉, 숫자, ASCII 문자 및 언더스코어입니다.
    

**문법**

```sql
hasToken(haystack, token)
```

**인수**

- `haystack` — 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
- `token` — 검색할 토큰입니다. [`const String`](/sql-reference/data-types/string)


**반환 값**

토큰이 발견되면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**토큰 검색**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```
## hasTokenCaseInsensitive {#hasTokenCaseInsensitive}

Introduced in: v

주어진 토큰을 대소문자를 구분하지 않고 검색합니다.

**문법**

```sql

```

**인수**

- 없음.

**반환 값**



**예시**
## hasTokenCaseInsensitiveOrNull {#hasTokenCaseInsensitiveOrNull}

Introduced in: v

주어진 토큰을 대소문자를 구분하지 않고 검색합니다. 잘못된 형식의 토큰은 null을 반환합니다.

**문법**

```sql

```

**인수**

- 없음.

**반환 값**



**예시**
## hasTokenOrNull {#hasTokenOrNull}

Introduced in: v20.1


[`hasToken`](#hasToken)과 유사하지만 잘못된 형식의 토큰은 null을 반환합니다.
    

**문법**

```sql
hasTokenOrNull(haystack, token)
```

**인수**

- `haystack` — 검색할 문자열입니다. 상수여야 합니다. [`String`](/sql-reference/data-types/string)
- `token` — 검색할 토큰입니다. [`const String`](/sql-reference/data-types/string)


**반환 값**

토큰이 발견되면 `1`을 반환하고, 그렇지 않으면 `0`을 반환하며, 잘못된 형식의 토큰은 null을 반환합니다. [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**예시**

**사용 예**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```
## ilike {#ilike}

Introduced in: v20.6

[`like`](#like)와 유사하지만 대소문자를 구분하지 않고 검색합니다.

**문법**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — 일치시킬 LIKE 패턴입니다. [`String`](/sql-reference/data-types/string)


**반환 값**

문자열이 LIKE 패턴과 일치하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```
## like {#like}

Introduced in: v1.1


문자열 `haystack`이 `LIKE` 표현식 `pattern`과 일치하는지 여부를 반환합니다.

`LIKE` 표현식은 일반 문자와 다음 메타 기호를 포함할 수 있습니다:

- `%`는 임의의 수의 임의의 문자를 나타냅니다(0개의 문자를 포함하여).
- `_`는 하나의 임의의 문자를 나타냅니다.
- `\`는 리터럴 `%`, `_` 및 `\`를 이스케이프하는 데 사용됩니다.

일치는 UTF-8을 기반으로 하며, 예를 들어 `_`는 UTF-8에서 두 바이트로 표현되는 유니코드 코드 포인트 `¥`와 일치합니다.

haystack이나 `LIKE` 표현식이 유효한 UTF-8이 아닐 경우, 동작은 정의되지 않습니다.

자동 유니코드 정규화는 수행되지 않지만, `normalizeUTF8*` 함수를 사용할 수 있습니다.

리터럴 `%`, `_` 및 `\`와 일치시키려면 이스케이프를 위해 백슬래시를 추가합니다: `\%`, `\_` 및 `\\`.
백슬래시는 `%`, `_`, 또는 `\`와 다른 문자를 추가로 Prepends할 경우 특별한 의미를 잃고 (즉, 문자 그대로 해석됨) 적용됩니다.

:::note
ClickHouse는 문자열에서 백슬래시 또한 인용되도록 요구하므로, 실제로는 `\\%`, `\\_` 및 `\\\\`을 작성해야 합니다.
:::

형태가 `%needle%`인 `LIKE` 표현식에 대해서 함수는 `position` 함수만큼 빠릅니다.
모든 다른 LIKE 표현식은 내부적으로 정규 표현식으로 변환되어 `match` 함수와 비슷한 성능으로 실행됩니다.
   

**문법**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — 일치시킬 `LIKE` 패턴입니다. `%`는 (임의의 수의 문자와 일치), `_`는 (단일 문자와 일치), `\`는 이스케이프에 사용될 수 있습니다. [`String`](/sql-reference/data-types/string)


**반환 값**

문자열이 `LIKE` 패턴과 일치하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**단일 문자 와일드카드**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**불일치 패턴**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```
## locate {#locate}

Introduced in: v18.16


[`position`](#position)과 비슷하지만 인수 `haystack`과 `locate`의 순서를 바꿉니다.

:::note 버전 의존적 동작
이 함수의 동작은 ClickHouse 버전에 따라 다릅니다:
- v24.3 이전 버전에서 `locate`는 `position` 함수의 별칭이며 인수 `(haystack, needle[, start_pos])`를 수용했습니다.
- v24.3 이상에서는 `locate`가 독립적인 함수이며( MySQL과의 호환성을 위해) 인수 `(needle, haystack[, start_pos])`를 수용합니다.
이전 동작은 설정 `function_locate_has_mysql_compatible_argument_order = false`를 사용하여 복원할 수 있습니다.
:::
    

**문법**

```sql
locate(needle, haystack[, start_pos])
```

**인수**

- `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
- `start_pos` — 선택 사항. 검색이 시작되는 `haystack`의 위치(1기반)입니다. [`UInt`](/sql-reference/data-types/int-uint)


**반환 값**

부분 문자열이 발견되면 1에서 시작하여 바이트 위치를 반환하고, 부분 문자열이 발견되지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**기본 사용법**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```
## match {#match}

Introduced in: v1.1


제공된 문자열이 제공된 정규 표현식 패턴과 일치하는지 여부를 확인합니다.

이 함수는 RE2 정규 표현식 라이브러리를 사용합니다. 지원되는 문법에 대해서는 [re2](https://github.com/google/re2/wiki/Syntax)를 참조하십시오.

일치는 UTF-8 가정을 기반으로 하며, 예를 들어 `¥`는 내부적으로 두 바이트를 사용하지만, 일치는 단일 코드 포인트로 취급합니다.
정규 표현식에는 NULL 바이트가 포함되면 안 됩니다.
`haystack` 또는 패턴이 유효한 UTF-8이 아닐 경우 동작은 정의되지 않습니다.

re2의 기본 동작과 달리 `.`는 줄 바꿈과도 일치합니다. 이를 비활성화하려면 패턴의 앞에 `(?-s)`를 추가합니다.

패턴은 양쪽 끝에 자동으로 고정됩니다(패턴이 '^'로 시작하고 '$'로 끝나듯이).

부분 문자열을 찾고 싶다면 [`like`](#like) 또는 [`position`](#position) 함수를 대신 사용할 수 있습니다 - 이 함수들은 이 함수보다 훨씬 빠릅니다.

대안 연산자 구문: `haystack REGEXP pattern`.
    

**문법**

```sql
match(haystack, pattern)
```

**별칭**: `REGEXP_MATCHES`

**인수**

- `haystack` — 패턴이 검색되는 문자열입니다. [`String`](/sql-reference/data-types/string)
- `pattern` — 정규 표현식 패턴입니다. [`const String`](/sql-reference/data-types/string)


**반환 값**

패턴이 일치하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**기본 패턴 일치**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**일치하지 않는 패턴**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```
## multiFuzzyMatchAllIndices {#multiFuzzyMatchAllIndices}

Introduced in: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny)와 유사하지만 `haystack` 내의 일치하는 모든 인덱스를 임의의 순서로 반환합니다. 고정된 [편집 거리](https://en.wikipedia.org/wiki/Edit_distance) 내에서 일치해야 합니다.

**문법**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
- `distance` — 퍼지 매칭을 위한 최대 편집 거리입니다. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — 일치할 패턴 배열입니다. [`Array(String)`](/sql-reference/data-types/array)


**반환 값**

지정된 편집 거리 내에서 일치하는 모든 인덱스의 배열(1부터 시작함)을 반환합니다. 일치하는 항목이 없으면 빈 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```
## multiFuzzyMatchAny {#multiFuzzyMatchAny}

Introduced in: v20.1


[`multiMatchAny`](#multiMatchAny)와 유사하지만 지정된 고정된 [편집 거리](https://en.wikipedia.org/wiki/Edit_distance) 내에서 임의의 패턴이 `haystack`과 일치하면 1을 반환합니다.
이 함수는 [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) 라이브러리의 실험적 기능에 의존하며, 일부 엣지 케이스에서는 느릴 수 있습니다.
성능은 편집 거리 값과 패턴에 따라 다르지만, 항상 퍼지 변형보다 비쌉니다.

:::note
`multiFuzzyMatch*()` 함수 가족은 UTF-8 정규 표현식을 지원하지 않습니다(바이트 시퀀스로 처리됨) hyperscan의 제한으로 인해.
:::
    

**문법**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
- `distance` — 퍼지 매칭을 위한 최대 편집 거리입니다. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — 선택 사항. 일치시킬 패턴의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)


**반환 값**

지정된 편집 거리 내에서 어떤 패턴이 `haystack`과 일치하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```
## multiFuzzyMatchAnyIndex {#multiFuzzyMatchAnyIndex}

Introduced in: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny)와 유사하지만 지정된 고정된 [편집 거리](https://en.wikipedia.org/wiki/Edit_distance) 내에서 `haystack`과 일치하는 패턴의 어떤 인덱스를 반환합니다.

**문법**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
- `distance` — 퍼지 매칭을 위한 최대 편집 거리입니다. [`UInt8`](/sql-reference/data-types/int-uint)
- `pattern` — 일치할 패턴 배열입니다. [`Array(String)`](/sql-reference/data-types/array)


**반환 값**

지정된 편집 거리 내에서 `haystack`과 일치하는 패턴의 인덱스(1부터 시작)를 반환하며, 일치가 없으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```
## multiMatchAllIndices {#multiMatchAllIndices}

Introduced in: v20.1

[`multiMatchAny`](#multiMatchAny)와 유사하지만 일치하는 모든 인덱스의 배열을 반환합니다. 임의의 순서로 반환됩니다.

**문법**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
- `pattern` — 일치할 정규 표현식입니다. [`String`](/sql-reference/data-types/string)


**반환 값**

일치하는 모든 인덱스의 배열(1부터 시작)을 반환합니다. 일치 항목이 없으면 빈 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```
## multiMatchAny {#multiMatchAny}

Introduced in: v20.1


여러 개의 정규 표현식 패턴 중 하나가 `haystack`과 일치하는지 확인합니다.

문자열에서 여러 부분 문자열을 검색하려면 대신 [`multiSearchAny`](#multiSearchAny) 함수를 사용할 수 있습니다 - 이 함수는 이 함수보다 훨씬 빠릅니다.
    

**문법**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**인수**

- `haystack` — 패턴이 검색되는 문자열입니다. [`String`](/sql-reference/data-types/string)
- `pattern1[, pattern2, ...]` — 하나 이상의 정규 표현식 패턴의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)


**반환 값**

어떤 패턴이 일치하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**여러 패턴 일치**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**일치하는 패턴 없음**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```
## multiMatchAnyIndex {#multiMatchAnyIndex}

Introduced in: v20.1

[`multiMatchAny`](#multiMatchAny)와 유사하지만 일치하는 인덱스를 반환합니다.

**문법**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**인수**

- `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
- `pattern` — 일치할 정규 표현식입니다. [`Array(String)`](/sql-reference/data-types/array)


**반환 값**

일치하는 첫 번째 패턴의 인덱스(1부터 시작)를 반환하며, 일치하지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```

## multiSearchAllPositions {#multiSearchAllPositions}

Introduced in: v20.1

[`position`](#position)와 유사하지만 `haystack` 문자열 내의 여러 `needle` 서브스트링에 대한 위치(바이트 단위, 1부터 시작)의 배열을 반환합니다.

모든 `multiSearch*()` 함수는 최대 2^8개의 needle만 지원합니다.

**Syntax**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 검색할 하나 이상의 서브스트링의 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

서브스트링이 발견되면 1부터 시작하는 바이트 위치의 배열을 반환하고, 서브스트링이 발견되지 않으면 `0`을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Multiple needle search**

```sql title=Query
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```
## multiSearchAllPositionsCaseInsensitive {#multiSearchAllPositionsCaseInsensitive}

Introduced in: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions)와 유사하지만 대소문자를 무시합니다.

**Syntax**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 검색할 하나 이상의 서브스트링의 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

서브스트링이 발견되면 1부터 시작하는 바이트 위치의 배열을 반환하고, 서브스트링이 발견되지 않으면 `0`을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**Examples**

**Case insensitive multi-search**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```
## multiSearchAllPositionsCaseInsensitiveUTF8 {#multiSearchAllPositionsCaseInsensitiveUTF8}

Introduced in: v20.1

[`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8)와 유사하지만 대소문자를 무시합니다.

**Syntax**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색이 수행되는 UTF-8 인코딩 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 UTF-8 인코딩 서브스트링. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

서브스트링이 발견되면 1부터 시작하는 바이트 위치의 배열을 반환하고, 서브스트링이 발견되지 않으면 `0`을 반환합니다. [`Array`](/sql-reference/data-types/array)

**Examples**

**Case-insensitive UTF-8 search**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```
## multiSearchAllPositionsUTF8 {#multiSearchAllPositionsUTF8}

Introduced in: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions)와 유사하지만 `haystack` 및 `needle` 서브스트링이 UTF-8 인코딩 문자열이라고 가정합니다.

**Syntax**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**Arguments**

- `haystack` — 검색이 수행되는 UTF-8 인코딩 문자열. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 검색할 UTF-8 인코딩 서브스트링의 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

서브스트링이 발견되면 1부터 시작하는 바이트 위치의 배열을 반환하고, 서브스트링이 발견되지 않으면 `0`을 반환합니다. [`Array`](/sql-reference/data-types/array)

**Examples**

**UTF-8 multi-search**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```
## multiSearchAny {#multiSearchAny}

Introduced in: v20.1

여러 needle 문자열 중 하나라도 haystack 문자열과 일치하는지 확인합니다.

함수 [`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive), [`multiSearchAnyUTF8`](#multiSearchAnyUTF8) 및 [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8)는 이 함수의 대소문자를 무시하거나 UTF-8 변형을 제공합니다.

**Syntax**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 검색할 서브스트링의 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

하나라도 일치하는 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Any match search**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```
## multiSearchAnyCaseInsensitive {#multiSearchAnyCaseInsensitive}

Introduced in: v20.1

[`multiSearchAny`](#multiSearchAny)와 유사하지만 대소문자를 무시합니다.

**Syntax**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 서브스트링. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

대소문자를 무시한 일치가 하나라도 있는 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive search**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```
## multiSearchAnyCaseInsensitiveUTF8 {#multiSearchAnyCaseInsensitiveUTF8}

Introduced in: v20.1

[`multiSearchAnyUTF8`](#multiSearchAnyUTF8)와 유사하지만 대소문자를 무시합니다.

**Syntax**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색이 수행되는 UTF-8 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 UTF-8 서브스트링. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

대소문자를 무시한 일치가 하나라도 있는 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**UTF-8 문자열 'Здравствуйте'에서 문자 'з' (소문자)가 존재하는지 확인**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```
## multiSearchAnyUTF8 {#multiSearchAnyUTF8}

Introduced in: v20.1

[`multiSearchAny`](#multiSearchAny)와 유사하지만 `haystack` 및 `needle` 서브스트링이 UTF-8 인코딩 문자열이라고 가정합니다.

**Syntax**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색이 수행되는 UTF-8 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 UTF-8 서브스트링. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

하나라도 일치하는 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**'你好，世界' ('Hello, world')라는 UTF-8 문자열에서 你 또는 界 문자가 string에 있는지 확인**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```
## multiSearchFirstIndex {#multiSearchFirstIndex}

Introduced in: v20.1

haystack 문자열 내에서 여러 needle 문자열을 검색하고(대소문자 구분) 첫 번째 발견된 needle의 1 기반 인덱스를 반환합니다.

**Syntax**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색할 문자열. [`String`](/sql-reference/data-types/string)
- `needles` — 검색할 문자열 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

haystack에서 발견된 첫 번째 needle의 1 기반 인덱스를 반환합니다. needle이 발견되지 않으면 0을 반환합니다. 검색은 대소문자를 구분합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**Case-sensitive behavior**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**No match found**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```
## multiSearchFirstIndexCaseInsensitive {#multiSearchFirstIndexCaseInsensitive}

Introduced in: v20.1

문자열 `haystack`에서 발견된 왼쪽의 첫 번째 needle_i의 인덱스 `i`(1부터 시작)를 반환하며, 그렇지 않으면 0을 반환합니다.
대소문자를 무시합니다.

**Syntax**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 서브스트링. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

왼쪽에서 발견된 첫 번째 needle의 인덱스(1부터 시작)를 반환합니다. 그렇지 않으면 일치가 없는 경우 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```
## multiSearchFirstIndexCaseInsensitiveUTF8 {#multiSearchFirstIndexCaseInsensitiveUTF8}

Introduced in: v20.1

haystack 문자열 내에서 여러 needle 문자열을 대소문자를 무시하고 UTF-8 인코딩 지원으로 검색하고, 첫 번째 발견된 needle의 1 기반 인덱스를 반환합니다.

**Syntax**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색할 문자열. [`String`](/sql-reference/data-types/string)
- `needles` — 검색할 문자열 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

haystack에서 발견된 첫 번째 needle의 1 기반 인덱스를 반환합니다. needle이 발견되지 않으면 0을 반환합니다. 검색은 대소문자를 무시하며 UTF-8 문자 인코딩을 준수합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8 case handling**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**No match found**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```
## multiSearchFirstIndexUTF8 {#multiSearchFirstIndexUTF8}

Introduced in: v20.1

왼쪽에서 발견된 첫 번째 needle_i의 인덱스 `i`(1부터 시작)를 반환합니다.
haystack 및 needle가 UTF-8 인코딩 문자열이라고 가정합니다.

**Syntax**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색이 수행되는 UTF-8 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 UTF-8 서브스트링 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

왼쪽에서 발견된 첫 번째 needle의 인덱스(1부터 시작)를 반환합니다. 그렇지 않으면 일치가 없는 경우 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```
## multiSearchFirstPosition {#multiSearchFirstPosition}

Introduced in: v20.1

[`position`](#position)와 유사하지만 haystack 문자열에서 여러 needle 문자열 중 관련된 왼쪽 오프셋을 반환합니다.

함수 [`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive), [`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8) 및 [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8)는 이 함수의 대소문자를 무시하거나 UTF-8 변형을 제공합니다.

**Syntax**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string)
- `needle1[, needle2, ...]` — 검색할 하나 이상의 서브스트링의 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

여러 needle 문자열 중 관련된 haystack 문자열 내의 왼쪽 오프셋을 반환하고, 그렇지 않으면 일치가 없는 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**First position search**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```
## multiSearchFirstPositionCaseInsensitive {#multiSearchFirstPositionCaseInsensitive}

Introduced in: v20.1

[`multiSearchFirstPosition`](#multiSearchFirstPosition)와 유사하지만 대소문자를 무시합니다.

**Syntax**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 서브스트링 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

여러 needle 문자열 중 관련된 haystack 문자열 내의 왼쪽 오프셋을 반환합니다. 일치가 없는 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive first position**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```
## multiSearchFirstPositionCaseInsensitiveUTF8 {#multiSearchFirstPositionCaseInsensitiveUTF8}

Introduced in: v20.1

[`multiSearchFirstPosition`](#multiSearchFirstPosition)와 유사하지만 haystack 및 needle이 UTF-8 문자열이라고 가정하며 대소문자를 무시합니다.

**Syntax**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색이 수행되는 UTF-8 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 UTF-8 서브스트링 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

여러 needle 문자열 중 관련된 haystack 문자열 내의 왼쪽 오프셋을 반환하며, 대소문자를 무시합니다. 일치가 없는 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**UTF-8 문자열 'Здравствуй, мир' ('Hello, world')에서 주어진 needles 중 하나와 일치하는 가장 왼쪽 오프셋 찾기**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```
## multiSearchFirstPositionUTF8 {#multiSearchFirstPositionUTF8}

Introduced in: v20.1

[`multiSearchFirstPosition`](#multiSearchFirstPosition)와 유사하지만 haystack 및 needle이 UTF-8 문자열이라고 가정합니다.

**Syntax**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**Arguments**

- `haystack` — 검색이 수행되는 UTF-8 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 검색할 UTF-8 서브스트링 배열. [`Array(String)`](/sql-reference/data-types/array)

**Returned value**

여러 needle 문자열 중 관련된 haystack 문자열 내의 가장 왼쪽 오프셋을 반환합니다. 일치가 없는 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**UTF-8 문자열 'Здравствуй, мир' ('Hello, world')에서 주어진 needles 중 하나와 일치하는 가장 왼쪽 오프셋 찾기**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```
## ngramDistance {#ngramDistance}

Introduced in: v20.1

두 문자열 간의 4-그램 거리를 계산합니다.
이를 위해 두 멀티셋의 4-그램 간의 대칭 차이를 계산하고, 이를 원래의 기수로 정규화합니다.
반환되는 값이 작을수록 문자열이 더 유사합니다.

대소문자를 무시한 검색이나 UTF8 형식을 사용하려면 [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive), [`ngramDistanceUTF8`](#ngramDistanceUTF8), [`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8) 함수를 사용하세요.

**Syntax**

```sql
ngramDistance(haystack, needle)
```

**Arguments**

- `haystack` — 비교할 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 비교할 문자열. [`String`](/sql-reference/data-types/string)

**Returned value**

`0`과 `1` 사이의 Float32 숫자를 반환합니다. 반환되는 값이 작을수록 문자열이 더 유사합니다. [`Float32`](/sql-reference/data-types/float)

**Examples**

**Calculate 4-gram distance**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```
## ngramDistanceCaseInsensitive {#ngramDistanceCaseInsensitive}

Introduced in: v20.1

[`ngramDistance`](#ngramDistance)의 대소문자 무시 변형을 제공합니다.
대소문자를 무시하고 두 문자열 간의 4-그램 거리를 계산합니다.
반환되는 값이 작을수록 문자열이 더 유사합니다.

**Syntax**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**Arguments**

- `haystack` — 첫 번째 비교 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 두 번째 비교 문자열. [`String`](/sql-reference/data-types/string)

**Returned value**

`0`과 `1` 사이의 Float32 숫자를 반환합니다. [`Float32`](/sql-reference/data-types/float)

**Examples**

**Case-insensitive 4-gram distance**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```
## ngramDistanceCaseInsensitiveUTF8 {#ngramDistanceCaseInsensitiveUTF8}

Introduced in: v20.1

[`ngramDistance`](#ngramDistance)의 대소문자 무시 UTF-8 변형을 제공합니다.
`needle`과 `haystack` 문자열이 UTF-8 인코딩 문자열이라고 가정하고 대소문자를 무시합니다.
두 UTF-8 문자열 간의 3-그램 거리를 계산합니다. 반환되는 값이 작을수록 문자열이 더 유사합니다.

**Syntax**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**Arguments**

- `haystack` — 첫 번째 UTF-8 인코딩 비교 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 두 번째 UTF-8 인코딩 비교 문자열. [`String`](/sql-reference/data-types/string)

**Returned value**

`0`과 `1` 사이의 Float32 숫자를 반환합니다. [`Float32`](/sql-reference/data-types/float)

**Examples**

**Case-insensitive UTF-8 3-gram distance**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```
## ngramDistanceUTF8 {#ngramDistanceUTF8}

Introduced in: v20.1

[`ngramDistance`](#ngramDistance)의 UTF-8 변형을 제공합니다.
`needle`과 `haystack` 문자열이 UTF-8 인코딩 문자열이라고 가정합니다.
두 UTF-8 문자열 간의 3-그램 거리를 계산합니다. 반환되는 값이 작을수록 문자열이 더 유사합니다.

**Syntax**

```sql
ngramDistanceUTF8(haystack, needle)
```

**Arguments**

- `haystack` — 첫 번째 UTF-8 인코딩 비교 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 두 번째 UTF-8 인코딩 비교 문자열. [`String`](/sql-reference/data-types/string)

**Returned value**

`0`과 `1` 사이의 Float32 숫자를 반환합니다. [`Float32`](/sql-reference/data-types/float)

**Examples**

**UTF-8 3-gram distance**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```
## ngramSearch {#ngramSearch}

Introduced in: v20.1

두 문자열 간의 4-그램 거리가 주어진 임계값 이하인지 확인합니다.

대소문자를 무시한 검색이나 UTF8 형식을 사용하려면 `ngramSearchCaseInsensitive`, `ngramSearchUTF8`, `ngramSearchCaseInsensitiveUTF8` 함수를 사용하세요.

**Syntax**

```sql
ngramSearch(haystack, needle)
```

**Arguments**

- `haystack` — 비교할 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 비교할 문자열. [`String`](/sql-reference/data-types/string)

**Returned value**

두 문자열 간의 4-그램 거리가 주어진 임계값(기본값은 `1.0`) 이하인 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Search using 4-grams**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```
## ngramSearchCaseInsensitive {#ngramSearchCaseInsensitive}

Introduced in: v20.1

[`ngramSearch`](#ngramSearch)의 대소문자 무시 변형을 제공합니다.
needle 문자열과 haystack 문자열 간의 비대칭 차이를 계산합니다. 즉, needle의 n-그램 수에서 공통 n-그램 수를 뺀 값을 needle의 n-그램 수로 정규화합니다.
두 문자열 간의 4-그램 거리가 주어진 임계값 이하인 경우 확인하며, 대소문자를 무시합니다.

**Syntax**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**Arguments**

- `haystack` — 비교할 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 비교할 문자열. [`String`](/sql-reference/data-types/string)

**Returned value**

두 문자열 간의 4-그램 거리가 주어진 임계값(기본값은 `1.0`) 이하인 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Case-insensitive search using 4-grams**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```
## ngramSearchCaseInsensitiveUTF8 {#ngramSearchCaseInsensitiveUTF8}

Introduced in: v20.1

[`ngramSearch`](#ngramSearch)의 대소문자 무시 UTF-8 변형을 제공합니다.
haystack와 needle을 UTF-8 문자열이라고 가정하고 대소문자를 무시합니다.
두 UTF-8 문자열 간의 3-그램 거리가 주어진 임계값 이하인지 확인합니다.

**Syntax**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**Arguments**

- `haystack` — 비교할 UTF-8 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 비교할 UTF-8 문자열. [`String`](/sql-reference/data-types/string)

**Returned value**

두 UTF-8 문자열 간의 3-그램 거리가 주어진 임계값(기본값은 `1.0`) 이하인 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**조합하여 대소문자를 무시한 UTF-8 검색 사용**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```
## ngramSearchUTF8 {#ngramSearchUTF8}

Introduced in: v20.1

`ngramSearch`의 UTF-8 변형을 제공합니다.
haystack와 needle이 UTF-8 문자열이라고 가정합니다.
두 UTF-8 문자열 간의 3-그램 거리가 주어진 임계값 이하인지 확인합니다.

**Syntax**

```sql
ngramSearchUTF8(haystack, needle)
```

**Arguments**

- `haystack` — 비교할 UTF-8 문자열. [`String`](/sql-reference/data-types/string)
- `needle` — 비교할 UTF-8 문자열. [`String`](/sql-reference/data-types/string)

**Returned value**

두 UTF-8 문자열 간의 3-그램 거리가 주어진 임계값(기본값은 `1.0`) 이하인 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**UTF-8 검색을 위한 3-그램 사용**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```
## notILike {#notILike}

Introduced in: v20.6

문자열이 패턴과 일치하지 않는지 확인합니다. 대소문자를 무시합니다. 패턴은 SQL LIKE 일치를 위해 `%` 및 `_`와 같은 특수 문자를 포함할 수 있습니다.

**Syntax**

```sql
notILike(haystack, pattern)
```

**Arguments**

- `haystack` — 검색할 입력 문자열. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — 일치할 SQL LIKE 패턴. `%`는 0개 이상의 문자와 일치하고, `_`는 정확히 1개의 문자와 일치합니다. [`String`](/sql-reference/data-types/string)

**Returned value**

문자열이 패턴과 일치하지 않는 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```
## notLike {#notLike}

Introduced in: v1.1

[`like`](#like)와 유사하지만 결과를 부정합니다.

**Syntax**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
- `pattern` — 일치할 LIKE 패턴. [`String`](/sql-reference/data-types/string)

**Returned value**

문자열이 `LIKE` 패턴과 일치하지 않는 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**Non-matching pattern**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```
## position {#position}

Introduced in: v1.1

문자열 `haystack`에서 서브스트링 `needle`의 위치(바이트 단위, 1부터 시작)를 반환합니다.

서브스트링 `needle`이 비어있는 경우, 다음 규칙이 적용됩니다:
- `start_pos`가 지정되지 않은 경우: `1` 반환
- `start_pos = 0`인 경우: `1` 반환
- `start_pos >= 1`이고 `start_pos <= length(haystack) + 1`인 경우: `start_pos` 반환
- 그렇지 않으면: `0` 반환

동일한 규칙이 [`locate`](#locate), [`positionCaseInsensitive`](#positionCaseInsensitive), [`positionUTF8`](#positionUTF8) 및 [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8) 함수에도 적용됩니다.

**Syntax**

```sql
position(haystack, needle[, start_pos])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 검색할 서브스트링. [`String`](/sql-reference/data-types/string)
- `start_pos` — 검색이 시작되는 `haystack` 내의 위치(1 기반). 선택적입니다. [`UInt`](/sql-reference/data-types/int-uint)

**Returned value**

서브스트링이 발견되면 1부터 시작하는 바이트 위치를 반환하고, 그렇지 않으면 서브스트링이 발견되지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Basic usage**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**With start_pos argument**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Needle IN haystack syntax**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**Empty needle substring**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```
## positionCaseInsensitive {#positionCaseInsensitive}

Introduced in: v1.1

[`position`](#position)와 유사하지만 대소문자를 무시합니다.

**Syntax**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**Aliases**: `instr`

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 검색할 서브스트링. [`String`](/sql-reference/data-types/string)
- `start_pos` — 선택적. `haystack` 내에서 검색이 시작되는 위치(1 기반). [`UInt*`](/sql-reference/data-types/int-uint)

**Returned value**

서브스트링이 발견되면 1부터 시작하는 바이트 위치를 반환하고, 그렇지 않으면 서브스트링이 발견되지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive search**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```
## positionCaseInsensitiveUTF8 {#positionCaseInsensitiveUTF8}

Introduced in: v1.1

[`positionUTF8`](#positionUTF8)와 유사하지만 대소문자를 무시하며 검색합니다.

**Syntax**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 검색할 서브스트링. [`String`](/sql-reference/data-types/string)
- `start_pos` — 선택적. `haystack` 내에서 검색이 시작되는 위치(1 기반). [`UInt*`](/sql-reference/data-types/int-uint)

**Returned value**

서브스트링이 발견되면 1부터 시작하는 바이트 위치를 반환하고, 그렇지 않으면 서브스트링이 발견되지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Case insensitive UTF-8 search**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```
## positionUTF8 {#positionUTF8}

Introduced in: v1.1

[`position`](#position)와 유사하지만 `haystack`과 `needle`이 UTF-8 인코딩 문자열이라고 가정합니다.

**Syntax**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**Arguments**

- `haystack` — 검색이 수행되는 문자열. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
- `needle` — 검색할 서브스트링. [`String`](/sql-reference/data-types/string)
- `start_pos` — 선택적. `haystack` 내에서 검색이 시작되는 위치(1 기반). [`UInt*`](/sql-reference/data-types/int-uint)

**Returned value**

서브스트링이 발견되면 1부터 시작하는 바이트 위치를 반환하고, 그렇지 않으면 서브스트링이 발견되지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**UTF-8 character counting**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```
## regexpExtract {#regexpExtract}

Introduced in: v

haystack 내에서 regexp 패턴과 일치하고 regex 그룹 인덱스에 해당하는 첫 번째 문자열을 추출합니다.

**Syntax**

```sql

```

**Aliases**: `REGEXP_EXTRACT`

**Arguments**

- 없음.

**Returned value**

**Examples**

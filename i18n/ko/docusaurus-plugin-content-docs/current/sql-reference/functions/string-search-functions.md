---
description: '문자열 검색 함수 문서'
sidebar_label: '문자열 검색'
slug: /sql-reference/functions/string-search-functions
title: '문자열 검색 함수'
doc_type: 'reference'
---

# 문자열 검색을 위한 함수 \{#functions-for-searching-in-strings\}

이 섹션의 모든 함수는 기본적으로 대소문자를 구분하여 검색합니다. 대소문자를 구분하지 않는 검색은 일반적으로 별도의 함수 버전으로 제공됩니다.

:::note
대소문자를 구분하지 않는 검색은 영어의 소문자-대문자 규칙을 따릅니다. 예를 들어 영어에서 소문자 `i`의 대문자는
`I`이지만, 터키어에서는 `İ`입니다. 따라서 영어가 아닌 언어에서는 예상하지 못한 결과가 나올 수 있습니다.
:::

이 섹션의 함수들은 검색 대상 문자열(이 섹션에서 `haystack`이라고 함)과 검색 문자열(이 섹션에서 `needle`이라고 함)이 단일 바이트로 인코딩된 텍스트라고 가정합니다. 이 가정이
충족되지 않더라도 예외는 발생하지 않으며 결과는 정의되지 않습니다. UTF-8로 인코딩된 문자열 검색은 일반적으로 별도의 함수
버전으로 제공됩니다. 마찬가지로 UTF-8 함수 버전을 사용했는데 입력 문자열이 UTF-8로 인코딩된 텍스트가 아니라면, 예외는 발생하지 않으며
결과는 정의되지 않습니다. 자동 Unicode 정규화는 수행되지 않지만,
이를 위해 [normalizeUTF8*()](/sql-reference/functions/string-functions#normalizeUTF8NFC) 함수를 사용할 수 있습니다.

[일반 문자열 함수](string-functions.md) 및 [문자열 치환 함수](string-replace-functions.md)는 별도로 설명합니다.

:::note
아래 문서는 `system.functions` 시스템 테이블에서 생성되었습니다.
:::

{/* 
  아래 태그 안의 내용은 문서 프레임워크를 빌드할 때 
  system.functions에서 생성된 문서로 대체됩니다. 태그를 수정하거나 삭제하지 마십시오.
  자세한 내용은 https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md 를 참고하십시오.
  */ }

{/*AUTOGENERATED_START*/ }

## countMatches \{#countMatches\}

도입 버전: v21.1

문자열에서 정규 표현식이 일치하는 횟수를 반환합니다.

:::note Version dependent behavior
이 함수의 동작은 ClickHouse 버전에 따라 달라집니다:

* v25.6 미만 버전에서는, 패턴이 빈 문자열과도 일치 가능하더라도 첫 번째 빈 일치가 발생하면 개수를 세는 것을 중단합니다.
* v25.6 이상 버전에서는, 빈 일치가 발생하더라도 함수 실행이 계속됩니다. 기존 동작은 `count_matches_stop_at_empty_match = true` 설정을 통해 복원할 수 있습니다.
  :::

**구문**

```sql
countMatches(haystack, pattern)
```

**인수**

* `haystack` — 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `pattern` — 정규 표현식 패턴입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

찾은 일치하는 항목의 개수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**숫자 시퀀스 개수 세기**

```sql title=Query
SELECT countMatches('hello 123 world 456 test', '[0-9]+')
```

```response title=Response
┌─countMatches('hello 123 world 456 test', '[0-9]+')─┐
│                                                   2 │
└─────────────────────────────────────────────────────┘
```

## countMatchesCaseInsensitive \{#countMatchesCaseInsensitive\}

도입 버전: v21.1

[`countMatches`](#countMatches)와 동일하지만, 대소문자를 구분하지 않고(case-insensitive) 일치 여부를 검사합니다.

**구문**

```sql
countMatchesCaseInsensitive(haystack, pattern)
```

**인수**

* `haystack` — 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `pattern` — 정규식 패턴입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

일치하는 항목의 개수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**대소문자를 구분하지 않는 개수 세기**

```sql title=Query
SELECT countMatchesCaseInsensitive('Hello HELLO world', 'hello')
```

```response title=Response
┌─countMatchesCaseInsensitive('Hello HELLO world', 'hello')─┐
│                                                         2 │
└───────────────────────────────────────────────────────────┘
```

## countSubstrings \{#countSubstrings\}

도입된 버전: v21.1

부분 문자열 `needle`이 문자열 `haystack` 내에서 등장하는 횟수를 반환합니다.

**구문**

```sql
countSubstrings(haystack, needle[, start_pos])
```

**인수**

* `haystack` — 검색이 수행되는 문자열. [String](../../sql-reference/data-types/string.md) 또는 [Enum](../../sql-reference/data-types/enum.md). - `needle` — 검색할 부분 문자열. [String](../../sql-reference/data-types/string.md). - `start_pos` — 검색을 시작하는 `haystack` 내 위치(1부터 시작). [UInt](../../sql-reference/data-types/int-uint.md). 선택적 인수입니다.

**반환 값**

등장 횟수입니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT countSubstrings('aaaa', 'aa');
```

```response title=Response
┌─countSubstrings('aaaa', 'aa')─┐
│                             2 │
└───────────────────────────────┘
```

**start&#95;pos 인수를 사용하는 경우**

```sql title=Query
SELECT countSubstrings('abc___abc', 'abc', 4);
```

```response title=Response
┌─countSubstrings('abc___abc', 'abc', 4)─┐
│                                      1 │
└────────────────────────────────────────┘
```

## countSubstringsCaseInsensitive \{#countSubstringsCaseInsensitive\}

도입 버전: v21.1

[`countSubstrings`](#countSubstrings)와 같지만, 대소문자를 구분하지 않고 부분 문자열의 개수를 셉니다.

**구문**

```sql
countSubstringsCaseInsensitive(haystack, needle[, start_pos])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
* `start_pos` — 선택적 인수입니다. 검색을 시작하는 `haystack` 내 위치(1부터 시작)입니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값**

`haystack` 내에서 `needle`이 나타나는 횟수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT countSubstringsCaseInsensitive('AAAA', 'aa');
```

```response title=Response
┌─countSubstri⋯AAA', 'aa')─┐
│                        2 │
└──────────────────────────┘
```

**start&#95;pos 인수 사용 시**

```sql title=Query
SELECT countSubstringsCaseInsensitive('abc___ABC___abc', 'abc', 4);
```

```response title=Response
┌─countSubstri⋯, 'abc', 4)─┐
│                        2 │
└──────────────────────────┘
```

## countSubstringsCaseInsensitiveUTF8 \{#countSubstringsCaseInsensitiveUTF8\}

도입된 버전: v21.1

[`countSubstrings`](#countSubstrings)와 같지만, 대소문자를 구분하지 않고 개수를 세며 haystack이 UTF-8 문자열이라고 가정합니다.

**구문**

```sql
countSubstringsCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**인자**

* `haystack` — 검색을 수행할 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
* `start_pos` — 선택 사항입니다. 검색을 시작할 `haystack` 내 위치(1부터 시작)입니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값**

`haystack`에서 `needle`이 나타나는 횟수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА');
```

```response title=Response
┌─countSubstri⋯шка', 'КА')─┐
│                        4 │
└──────────────────────────┘
```

**start&#95;pos 인수를 사용하는 경우**

```sql title=Query
SELECT countSubstringsCaseInsensitiveUTF8('ложка, кошка, картошка', 'КА', 13);
```

```response title=Response
┌─countSubstri⋯, 'КА', 13)─┐
│                        2 │
└──────────────────────────┘
```

## extract \{#extract\}

도입 버전: v1.1

문자열에서 정규 표현식에 일치하는 첫 번째 항목을 추출합니다.
&#39;haystack&#39;이(가) &#39;pattern&#39;과(와) 일치하지 않으면 빈 문자열을 반환합니다.

이 함수는 RE2 정규 표현식 라이브러리를 사용합니다. 지원되는 문법은 [re2](https://github.com/google/re2/wiki/Syntax)를 참고하십시오.

정규 표현식에 캡처 그룹(하위 패턴)이 있는 경우, 입력 문자열을 정규 표현식과 매칭한 뒤 첫 번째 캡처 그룹에 해당하는 부분 문자열을 반환합니다.

**구문**

```sql
extract(haystack, pattern)
```

**인수**

* `haystack` — 추출할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `pattern` — 일반적으로 캡처 그룹을 포함하는 정규 표현식입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

추출된 부분을 문자열로 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**이메일에서 도메인 추출**

```sql title=Query
SELECT extract('test@clickhouse.com', '.*@(.*)$')
```

```response title=Response
┌─extract('test@clickhouse.com', '.*@(.*)$')─┐
│ clickhouse.com                            │
└───────────────────────────────────────────┘
```

**일치 항목이 없으면 빈 문자열을 반환합니다**

```sql title=Query
SELECT extract('test@clickhouse.com', 'no_match')
```

```response title=Response
┌─extract('test@clickhouse.com', 'no_match')─┐
│                                            │
└────────────────────────────────────────────┘
```

## extractAll \{#extractAll\}

도입 버전: v1.1

[`extract`](#extract)와 비슷하지만, 문자열에서 지정한 정규 표현식과 일치하는 모든 항목의 배열을 반환합니다.
&#39;haystack&#39;이 &#39;pattern&#39; 정규 표현식과 일치하지 않으면 빈 배열을 반환합니다.

정규 표현식에 캡처 그룹(서브 패턴)이 포함된 경우, FUNCTION은 첫 번째 캡처 그룹을 기준으로 입력 문자열을 매칭합니다.

**문법**

```sql
extractAll(haystack, pattern)
```

**인수**

* `haystack` — 부분 문자열을 추출할 원본 문자열입니다. [`String`](/sql-reference/data-types/string)
* `pattern` — 캡처 그룹을 포함할 수 있는 정규 표현식입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

추출된 부분 문자열의 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**모든 숫자 추출**

```sql title=Query
SELECT extractAll('hello 123 world 456', '[0-9]+')
```

```response title=Response
┌─extractAll('hello 123 world 456', '[0-9]+')─┐
│ ['123','456']                               │
└─────────────────────────────────────────────┘
```

**캡처 그룹을 사용한 추출**

```sql title=Query
SELECT extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')
```

```response title=Response
┌─extractAll('test@example.com, user@domain.org', '([a-zA-Z0-9]+)@')─┐
│ ['test','user']                                                    │
└────────────────────────────────────────────────────────────────────┘
```

## extractAllGroupsHorizontal \{#extractAllGroupsHorizontal\}

도입 버전: v20.5

제공된 정규식을 사용하여 문자열의 모든 그룹을 매칭한 다음, 각 캡처 그룹별로 그룹 번호 순서에 따라 해당 그룹에서 캡처된 모든 값을 담은 배열을 요소로 가지는 배열을 반환합니다.

**구문**

```sql
extractAllGroupsHorizontal(s, regexp)
```

**인자**

* `s` — 값을 추출할 입력 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 일치 여부를 확인할 정규식입니다. [`const String`](/sql-reference/data-types/string) 또는 [`const FixedString`](/sql-reference/data-types/fixedstring)

**반환 값**

각 내부 배열이, 모든 일치 결과에 대해 하나의 캡처 그룹에서 얻은 모든 캡처를 포함하는 배열의 배열을 반환합니다. 첫 번째 내부 배열에는 그룹 1의 모든 캡처가, 두 번째 내부 배열에는 그룹 2의 모든 캡처가 포함되는 식입니다. 일치하는 결과가 없으면 빈 배열을 반환합니다. [`Array(Array(String))`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroupsHorizontal(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','Date','Content-Type','Connection'],['nginx','Tue, 22 Jan 2019 00:26:14 GMT','text/html; charset=UTF-8','keep-alive']]
```

## extractGroups \{#extractGroups\}

도입: v20.5

정규 표현식과 일치하는 서로 겹치지 않는 부분 문자열들에서 모든 그룹을 추출합니다.

**구문**

```sql
extractAllGroups(s, regexp)
```

**인자**

* `s` — 추출할 입력 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `regexp` — 정규식 상수입니다. [`const String`](/sql-reference/data-types/string) 또는 [`const FixedString`](/sql-reference/data-types/fixedstring)

**반환 값**

함수가 하나 이상의 일치하는 그룹을 찾으면, group&#95;id(`1`에서 `N`까지, 여기서 `N`은 regexp에서 캡처링 그룹의 수)를 기준으로 클러스터링된 Array(Array(String)) 컬럼을 반환합니다. 일치하는 그룹이 없으면 빈 배열을 반환합니다. [`Array(Array(String))`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
WITH '< Server: nginx
< Date: Tue, 22 Jan 2019 00:26:14 GMT
< Content-Type: text/html; charset=UTF-8
< Connection: keep-alive
' AS s
SELECT extractAllGroups(s, '< ([\\w\\-]+): ([^\\r\\n]+)');
```

```response title=Response
[['Server','nginx'],['Date','Tue, 22 Jan 2019 00:26:14 GMT'],['Content-Type','text/html; charset=UTF-8'],['Connection','keep-alive']]
```

## hasAllTokens \{#hasAllTokens\}

도입 버전: v25.10

[`hasAnyTokens`](#hasAnyTokens)와 유사하지만, `needle` 문자열 또는 배열의 모든 토큰이 `input` 문자열과 일치하면 1을 반환하고, 그렇지 않으면 0을 반환합니다. `input`이 컬럼인 경우, 해당 조건을 만족하는 모든 행을 반환합니다.

:::note
최적의 성능을 위해 `input` 컬럼에 [텍스트 인덱스](../../engines/table-engines/mergetree-family/textindexes)가 정의되어 있어야 합니다.
텍스트 인덱스가 정의되지 않은 경우, 함수는 무차별 대입 방식으로 컬럼을 스캔하게 되며 이는 인덱스 조회보다 수 배에서 수십 배 이상 느립니다.
:::

검색 전에 함수가 토큰화를 수행합니다

* `input` 인자(항상 사용), 그리고
* `needle` 인수가 ([String](../../sql-reference/data-types/string.md)로 전달된 경우)
  텍스트 인덱스(text index)에 지정된 토크나이저를 사용하여 처리됩니다.
  컬럼에 텍스트 인덱스가 정의되어 있지 않으면 `splitByNonAlpha` 토크나이저가 대신 사용됩니다.
  `needle` 인수가 [Array(String)](../../sql-reference/data-types/array.md) 타입인 경우 각 배열 요소는 하나의 토큰으로 간주되며, 추가 토큰화는 수행되지 않습니다.

중복된 토큰은 무시됩니다.
예를 들어, needles = [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;]는 [&#39;ClickHouse&#39;]와 동일하게 처리됩니다.

**구문**

```sql
hasAllTokens(input, needles)
```

**별칭**: `hasAllToken`

**인수**

* `input` — 입력 컬럼입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring) 또는 [`Array(String)`](/sql-reference/data-types/array) 또는 [`Array(FixedString)`](/sql-reference/data-types/array) 중 하나일 수 있습니다.
* `needles` — 검색 대상 토큰입니다. [`String`](/sql-reference/data-types/string) 또는 [`Array(String)`](/sql-reference/data-types/array)
* `tokenizer` — 사용할 tokenizer를 지정합니다. 사용할 수 있는 인수는 `splitByNonAlpha`, `ngrams`, `splitByString`, `array`, `sparseGrams`입니다. 선택 사항으로, 명시적으로 설정하지 않으면 기본값은 `splitByNonAlpha`입니다. 형식은 [`const String`](/sql-reference/data-types/string)입니다.

**반환 값**

모든 needle이 일치하면 1을 반환합니다. 그렇지 않으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**문자열 needle 사용 기본 예제**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAllTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**배열에서 검색할 needle을 토큰화 없이 그대로(AS-IS) 지정합니다**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**`tokens` 함수를 사용하여 니들(needle) 생성**

```sql title=Query
SELECT count() FROM table WHERE hasAllTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**세 번째 인수를 통해 사용자 정의 토크나이저를 사용합니다**

```sql title=Query
SELECT hasAllTokens('abcdef', 'abc', 'ngrams(3)');
```

```response title=Response
┌─hasAllTokens('abcdef', 'abc', 'ngrams(3)')─┐
│                                            1 │
└──────────────────────────────────────────────┘
```

**배열 및 맵 컬럼의 사용 예제**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**배열 컬럼이 있는 예시**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys 사용 예**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapValues 사용 예시**

```sql title=Query
SELECT count() FROM log WHERE hasAllTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       0 │
└─────────┘
```

## hasAnyTokens \{#hasAnyTokens\}

도입 버전: v25.10

`needle` 문자열 또는 배열의 토큰 중 하나 이상이 `input` 문자열과 일치하면 1을 반환하고, 그렇지 않으면 0을 반환합니다. `input`이 컬럼인 경우, 해당 조건을 만족하는 모든 행을 반환합니다.

:::note
최적의 성능을 위해 `input` 컬럼에 [텍스트 인덱스](../../engines/table-engines/mergetree-family/textindexes)를 정의해야 합니다.
텍스트 인덱스가 정의되지 않은 경우, 함수는 전체 컬럼 스캔을 수행하게 되며 이는 인덱스 조회보다 수 배에서 수십 배 느립니다.
:::

검색 전에 함수가 토큰화를 수행합니다

* `input` 인자(항상 필요), 그리고
* `needle` 인자가 [String](../../sql-reference/data-types/string.md) 타입으로 주어지면,
  텍스트 인덱스에 대해 지정된 토크나이저(tokenizer)를 사용합니다.
  컬럼에 텍스트 인덱스가 정의되어 있지 않으면 `splitByNonAlpha` 토크나이저가 대신 사용됩니다.
  `needle` 인자가 [Array(String)](../../sql-reference/data-types/array.md) 타입이면, 배열의 각 요소는 토큰으로 취급되며 추가적인 토크나이징은 수행되지 않습니다.

중복된 토큰은 무시됩니다.
예를 들어, [&#39;ClickHouse&#39;, &#39;ClickHouse&#39;]는 [&#39;ClickHouse&#39;]와 동일하게 처리됩니다.

**구문**

```sql
hasAnyTokens(input, needles)
```

**별칭**: `hasAnyToken`

**인수**

* `input` — 입력 컬럼입니다. [`String`](/sql-reference/data-types/string), [`FixedString`](/sql-reference/data-types/fixedstring), [`Array(String)`](/sql-reference/data-types/array), [`Array(FixedString)`](/sql-reference/data-types/array) 형식일 수 있습니다.
* `needles` — 검색 대상 토큰입니다. [`String`](/sql-reference/data-types/string) 또는 [`Array(String)`](/sql-reference/data-types/array)
* `tokenizer` — 사용할 tokenizer입니다. 허용되는 값은 `splitByNonAlpha`, `ngrams`, `splitByString`, `array`, `sparseGrams`입니다. 선택 사항이며, 명시적으로 설정하지 않으면 기본값은 `splitByNonAlpha`입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

최소 하나 이상의 일치 항목이 있으면 `1`을 반환합니다. 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**문자열 needle을 사용한 기본 사용법**

```sql title=Query
CREATE TABLE table (
    id UInt32,
    msg String,
    INDEX idx(msg) TYPE text(tokenizer = splitByString(['()', '\\']))
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO table VALUES (1, '()a,\\bc()d'), (2, '()\\a()bc\\d'), (3, ',()a\\,bc,(),d,');

SELECT count() FROM table WHERE hasAnyTokens(msg, 'a\\d()');
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**배열에서 검색할 needle을 토큰화 없이 그대로(AS-IS) 지정합니다**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, ['a', 'd']);
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**`tokens` 함수를 사용하여 needle 생성**

```sql title=Query
SELECT count() FROM table WHERE hasAnyTokens(msg, tokens('a()d', 'splitByString', ['()', '\\']));
```

```response title=Response
┌─count()─┐
│       3 │
└─────────┘
```

**배열 및 맵 컬럼의 사용 예제**

```sql title=Query
CREATE TABLE log (
    id UInt32,
    tags Array(String),
    attributes Map(String, String),
    INDEX idx_tags (tags) TYPE text(tokenizer = splitByNonAlpha),
    INDEX idx_attributes_keys mapKeys(attributes) TYPE text(tokenizer = array),
    INDEX idx_attributes_vals mapValues(attributes) TYPE text(tokenizer = array)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO log VALUES
    (1, ['clickhouse', 'clickhouse cloud'], {'address': '192.0.0.1', 'log_level': 'INFO'}),
    (2, ['chdb'], {'embedded': 'true', 'log_level': 'DEBUG'});
```

```response title=Response
```

**배열 컬럼 예제**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(tags, 'clickhouse');
```

```response title=Response
┌─count()─┐
│       1 │
└─────────┘
```

**mapKeys 사용 예제**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapKeys(attributes), ['address', 'log_level']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

**mapValues 예제**

```sql title=Query
SELECT count() FROM log WHERE hasAnyTokens(mapValues(attributes), ['192.0.0.1', 'DEBUG']);
```

```response title=Response
┌─count()─┐
│       2 │
└─────────┘
```

## hasSubsequence \{#hasSubsequence\}

도입 버전: v23.7

`haystack` 안에 `needle`이 부분 수열(subsequence)인지 확인합니다.
문자열의 부분 수열(subsequence)이란, 남아 있는 문자들의 순서는 바꾸지 않은 채 일부 문자를 삭제하거나 아무 문자도 삭제하지 않고 다른 문자열로부터 얻을 수 있는 문자 시퀀스를 의미합니다.

**구문**

```sql
hasSubsequence(haystack, needle)
```

**인수**

* `haystack` — 부분 시퀀스를 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 부분 시퀀스입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

`needle`이 `haystack`의 부분 시퀀스이면 `1`을, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**기본 부분 시퀀스 검사**

```sql title=Query
SELECT hasSubsequence('Hello World', 'HlWrd')
```

```response title=Response
┌─hasSubsequence('Hello World', 'HlWrd')─┐
│                                      1 │
└────────────────────────────────────────┘
```

**부분 문자열을 찾을 수 없습니다**

```sql title=Query
SELECT hasSubsequence('Hello World', 'xyz')
```

```response title=Response
┌─hasSubsequence('Hello World', 'xyz')─┐
│                                    0 │
└──────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitive \{#hasSubsequenceCaseInsensitive\}

도입된 버전: v23.7

[`hasSubsequence`](#hasSubsequence)와 동일하지만, 대소문자를 구분하지 않고 검색합니다.

**구문**

```sql
hasSubsequenceCaseInsensitive(haystack, needle)
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 부분 수열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

`needle`이 `haystack`의 부분 수열이면 1을, 그렇지 않으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT hasSubsequenceCaseInsensitive('garbage', 'ARG');
```

```response title=Response
┌─hasSubsequenceCaseInsensitive('garbage', 'ARG')─┐
│                                               1 │
└─────────────────────────────────────────────────┘
```

## hasSubsequenceCaseInsensitiveUTF8 \{#hasSubsequenceCaseInsensitiveUTF8\}

도입된 버전: v23.7

[`hasSubsequenceUTF8`](#hasSubsequenceUTF8)와 유사하지만, 대소문자를 구분하지 않고 검색합니다.

**구문**

```sql
hasSubsequenceCaseInsensitiveUTF8(haystack, needle)
```

**인수**

* `haystack` — 검색이 수행되는 UTF-8로 인코딩된 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 UTF-8로 인코딩된 부분 수열(subsequence) 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

`needle`이 `haystack`의 부분 수열이면 1을, 그렇지 않으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT hasSubsequenceCaseInsensitiveUTF8('ClickHouse - столбцовая система управления базами данных', 'СИСТЕМА');
```

```response title=Response
┌─hasSubsequen⋯ 'СИСТЕМА')─┐
│                        1 │
└──────────────────────────┘
```

## hasSubsequenceUTF8 \{#hasSubsequenceUTF8\}

도입된 버전: v23.7

[`hasSubsequence`](/sql-reference/functions/string-search-functions#hasSubsequence)와 유사하지만, `haystack`과 `needle`이 UTF-8로 인코딩된 문자열이라고 가정합니다.

**구문**

```sql
hasSubsequenceUTF8(haystack, needle)
```

**인수**

* `haystack` — 검색 대상 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 부분 시퀀스입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

`needle`이 `haystack`의 부분 시퀀스이면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'кошка');
```

```response title=Response
┌─hasSubsequen⋯', 'кошка')─┐
│                        1 │
└──────────────────────────┘
```

**일치하지 않는 부분수열**

```sql title=Query
SELECT hasSubsequenceUTF8('картошка', 'апельсин');
```

```response title=Response
┌─hasSubsequen⋯'апельсин')─┐
│                        0 │
└──────────────────────────┘
```

## hasToken \{#hasToken\}

도입 버전: v20.1

지정한 토큰이 `haystack` 안에 존재하는지 확인합니다.

토크나이저로 [splitByNonAlpha](/sql-reference/functions/splitting-merging-functions.md/#splitByNonAlpha)를 사용합니다. 즉, 토큰은 연속된 문자 `[0-9A-Za-z_]`(숫자, ASCII 문자, 밑줄)로 이루어진 가능한 한 가장 긴 부분 문자열로 정의됩니다.

**구문**

```sql
hasToken(haystack, token)
```

**인자**

* `haystack` — 검색 대상 문자열입니다. [`String`](/sql-reference/data-types/string)
* `token` — 검색할 토큰입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

토큰을 찾은 경우 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**토큰 검색**

```sql title=Query
SELECT hasToken('clickhouse test', 'test')
```

```response title=Response
┌─hasToken('clickhouse test', 'test')─┐
│                                   1 │
└─────────────────────────────────────┘
```

## hasTokenCaseInsensitive \{#hasTokenCaseInsensitive\}

도입 버전: v20.1

`tokenbf_v1` 인덱스를 사용하여 `haystack` 내에서 `needle`을 대소문자를 구분하지 않고 검색합니다.

**구문**

```sql
```

**인수**

* 없음

**반환 값**

**예제**

## hasTokenCaseInsensitiveOrNull \{#hasTokenCaseInsensitiveOrNull\}

도입된 버전: v23.1

`tokenbf_v1` 인덱스를 사용하여 `haystack`에서 `needle`을 대소문자를 구분하지 않고 검색합니다. `needle`의 형식이 올바르지 않은 경우 null을 반환합니다.

**구문**

```sql
```

**인수**

* 없음.

**반환값**

**예시**

## hasTokenOrNull \{#hasTokenOrNull\}

도입된 버전: v20.1

[`hasToken`](#hasToken)과 같지만 토큰 형식이 유효하지 않은 경우 null을 반환합니다.

**구문**

```sql
hasTokenOrNull(haystack, token)
```

**인수**

* `haystack` — 검색할 문자열입니다. 상수여야 합니다. [`String`](/sql-reference/data-types/string)
* `token` — 검색할 토큰입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

토큰을 찾으면 `1`, 찾지 못하면 `0`, 토큰 형식이 잘못된 경우에는 null을 반환합니다. [`Nullable(UInt8)`](/sql-reference/data-types/nullable)

**예시**

**사용 예시**

```sql title=Query
SELECT hasTokenOrNull('apple banana cherry', 'ban ana');
```

```response title=Response
┌─hasTokenOrNu⋯ 'ban ana')─┐
│                     ᴺᵁᴸᴸ │
└──────────────────────────┘
```

## ilike \{#ilike\}

도입 버전: v20.6

[`like`](#like)와 유사하지만, 대소문자를 구분하지 않고 검색합니다.

**구문**

```sql
ilike(haystack, pattern)
-- haystack ILIKE pattern
```

**인수**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 비교에 사용할 LIKE 패턴입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

문자열이 LIKE 패턴과 대소문자 구분 없이 일치하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT ilike('ClickHouse', '%house%');
```

```response title=Response
┌─ilike('ClickHouse', '%house%')─┐
│                              1 │
└────────────────────────────────┘
```

## like \{#like\}

도입 버전: v1.1

문자열 `haystack`이 `LIKE` 표현식 `pattern`과 일치하는지 여부를 반환합니다.

`LIKE` 표현식에는 일반 문자와 다음 메타 문자를 포함할 수 있습니다.

* `%`는 임의 개수(0개 포함)의 임의 문자를 나타냅니다.
* `_`는 임의의 단일 문자를 나타냅니다.
* `\`는 리터럴 `%`, `_`, `\`를 이스케이프하는 데 사용됩니다.

비교는 UTF-8을 기준으로 수행됩니다. 예를 들어 `_`는 UTF-8에서 2바이트로 표현되는 유니코드 코드 포인트 `¥`와 일치합니다.

`haystack` 또는 `LIKE` 표현식이 유효한 UTF-8이 아니면 동작이 정의되지 않습니다.

자동으로 Unicode 정규화를 수행하지 않습니다. 이를 위해서는 `normalizeUTF8*` 함수들을 사용할 수 있습니다.

리터럴 `%`, `_`, `\`(`LIKE` 메타 문자)와 일치시키려면 백슬래시를 앞에 붙입니다: `\%`, `\_`, `\\`.
백슬래시는 `%`, `_`, `\`가 아닌 다른 문자를 앞에 둘 경우 특별한 의미를 잃고(즉, 리터럴로 해석되어) 처리됩니다.

:::note
ClickHouse에서는 문자열 안의 백슬래시도 [따로 이스케이프해야](../syntax.md#string) 하므로 실제로는 `\\%`, `\\_`, `\\\\`처럼 작성해야 합니다.
:::

`%needle%` 형태의 `LIKE` 표현식의 경우, 이 함수는 `position` 함수와 동일한 수준으로 빠르게 동작합니다.
그 외의 모든 LIKE 표현식은 내부적으로 정규 표현식으로 변환되어 `match` 함수와 유사한 성능으로 실행됩니다.

**구문**

```sql
like(haystack, pattern)
-- haystack LIKE pattern
```

**인자**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 매칭에 사용할 `LIKE` 패턴입니다. `%`(임의 개수의 문자와 일치), `_`(단일 문자와 일치), 이스케이프용 `\`를 포함할 수 있습니다. [`String`](/sql-reference/data-types/string)

**반환 값**

문자열이 `LIKE` 패턴과 일치하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT like('ClickHouse', '%House');
```

```response title=Response
┌─like('ClickHouse', '%House')─┐
│                            1 │
└──────────────────────────────┘
```

**단일 문자 와일드카드**

```sql title=Query
SELECT like('ClickHouse', 'Click_ouse');
```

```response title=Response
┌─like('ClickH⋯lick_ouse')─┐
│                        1 │
└──────────────────────────┘
```

**일치하지 않는 패턴**

```sql title=Query
SELECT like('ClickHouse', '%SQL%');
```

```response title=Response
┌─like('ClickHouse', '%SQL%')─┐
│                           0 │
└─────────────────────────────┘
```

## locate \{#locate\}

도입 버전: v18.16

[`position`](#position)과 동일하지만, 인수 `haystack`과 `needle`의 순서가 반대입니다.

:::note Version dependent behavior
이 함수의 동작은 ClickHouse 버전에 따라 달라집니다.

* v24.3 미만 버전에서는 `locate`가 함수 `position`의 별칭이었으며 `(haystack, needle[, start_pos])` 인수를 받습니다.
* v24.3 이상 버전에서는 `locate`가 별도의 함수(MySQL과의 호환성을 높이기 위함)이며 `(needle, haystack[, start_pos])` 인수를 받습니다.
  이전 동작은 설정 `function_locate_has_mysql_compatible_argument_order = false`를 사용하여 복원할 수 있습니다.
  :::

**구문**

```sql
locate(needle, haystack[, start_pos])
```

**인수(Arguments)**

* `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
* `start_pos` — 선택 사항입니다. `haystack` 내에서 검색을 시작할 위치(1부터 시작)입니다. [`UInt`](/sql-reference/data-types/int-uint)

**반환 값(Returned value)**

부분 문자열을 찾은 경우 시작 위치를 바이트 단위로 1부터 계산하여 반환하고, 찾지 못한 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시(Examples)**

**기본 사용법(Basic usage)**

```sql title=Query
SELECT locate('ca', 'abcabc')
```

```response title=Response
┌─locate('ca', 'abcabc')─┐
│                      3 │
└────────────────────────┘
```

## match \{#match\}

도입 버전: v1.1

제공된 문자열이 제공된 정규 표현식 패턴과 일치하는지 확인합니다.

이 함수는 RE2 정규 표현식 라이브러리를 사용합니다. 지원되는 문법은 [re2](https://github.com/google/re2/wiki/Syntax)를 참고하십시오.

매칭은 UTF-8을 전제로 동작합니다. 예를 들어 `¥` 문자는 내부적으로 2바이트를 사용하지만, 매칭 시에는 하나의 코드포인트로 취급합니다.
정규 표현식에는 NULL 바이트가 포함되면 안 됩니다.
대상 문자열(haystack)이나 패턴이 올바른 UTF-8이 아니면 동작은 정의되지 않습니다.

re2의 기본 동작과 달리 `.` 은 줄 바꿈 문자도 매칭합니다. 이를 비활성화하려면 패턴 앞에 `(?-s)` 를 붙이십시오.

패턴은 양 끝이 자동으로 앵커 처리됩니다(패턴이 `^` 로 시작하고 `$` 로 끝나는 것과 동일하게 동작합니다).

부분 문자열만 찾으려는 경우 [`like`](#like) 또는 [`position`](#position) 함수를 대신 사용할 수 있습니다. 이 함수들은 이 함수보다 훨씬 빠르게 동작합니다.

대체 연산자 문법: `haystack REGEXP pattern`.

**Syntax**

```sql
match(haystack, pattern)
```

**별칭**: `REGEXP_MATCHES`

**인수**

* `haystack` — 패턴을 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `pattern` — 정규식 패턴입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

패턴이 일치하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**기본 패턴 매칭**

```sql title=Query
SELECT match('Hello World', 'Hello.*')
```

```response title=Response
┌─match('Hello World', 'Hello.*')─┐
│                               1 │
└─────────────────────────────────┘
```

**일치하는 패턴 없음**

```sql title=Query
SELECT match('Hello World', 'goodbye.*')
```

```response title=Response
┌─match('Hello World', 'goodbye.*')─┐
│                                 0 │
└───────────────────────────────────┘
```

## multiFuzzyMatchAllIndices \{#multiFuzzyMatchAllIndices\}

도입 버전: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny)와 유사하지만, 고정된 [편집 거리](https://en.wikipedia.org/wiki/Edit_distance) 이내에서 대상 문자열(haystack)과 일치하는 모든 인덱스의 배열을 임의의 순서로 반환합니다.

**구문**

```sql
multiFuzzyMatchAllIndices(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**인수**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `distance` — 퍼지(fuzzy) 매칭을 위한 최대 편집 거리입니다. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 매칭에 사용할 패턴들의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

지정된 편집 거리 내에서 `haystack`과 일치하는 모든 인덱스(1부터 시작)를 임의의 순서로 반환합니다. 일치 항목이 없으면 빈 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT multiFuzzyMatchAllIndices('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose', 'House']);
```

```response title=Response
┌─multiFuzzyMa⋯, 'House'])─┐
│ [3,1,4,2]                │
└──────────────────────────┘
```

## multiFuzzyMatchAny \{#multiFuzzyMatchAny\}

도입 버전: v20.1

[`multiMatchAny`](#multiMatchAny)와 비슷하지만, 일정한 [편집 거리](https://en.wikipedia.org/wiki/Edit_distance) 내에서 패턴 중 하나라도 검색 대상 문자열(haystack)과 일치하면 1을 반환합니다.
이 함수는 [hyperscan](https://intel.github.io/hyperscan/dev-reference/compilation.html#approximate-matching) 라이브러리의 실험적 기능에 의존하며, 일부 특정 경우에는 느릴 수 있습니다.
성능은 편집 거리 값과 사용된 패턴에 따라 달라지지만, 항상 비 퍼지(fuzzy) 버전에 비해 비용이 더 많이 듭니다.

:::note
`multiFuzzyMatch*()` 함수 계열은 hyperscan의 제약으로 인해 UTF-8 정규식을 지원하지 않습니다(바이트 시퀀스로 처리합니다).
:::

**구문**

```sql
multiFuzzyMatchAny(haystack, distance, [pattern1, pattern2, ..., patternN])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `distance` — 퍼지 매칭(fuzzy matching)을 위한 최대 편집 거리입니다. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 옵션입니다. 매칭에 사용할 패턴 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

지정된 편집 거리 이내에서 하나라도 패턴이 `haystack`과 일치하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT multiFuzzyMatchAny('ClickHouse', 2, ['ClickHouse', 'ClckHouse', 'ClickHose']);
```

```response title=Response
┌─multiFuzzyMa⋯lickHose'])─┐
│                        1 │
└──────────────────────────┘
```

## multiFuzzyMatchAnyIndex \{#multiFuzzyMatchAnyIndex\}

도입된 버전: v20.1

[`multiFuzzyMatchAny`](#multiFuzzyMatchAny)와 같지만, 고정된 [편집 거리](https://en.wikipedia.org/wiki/Edit_distance) 내에서 검색 대상 문자열(haystack)과 일치하는 인덱스 중 하나를 반환합니다.

**구문**

```sql
multiFuzzyMatchAnyIndex(haystack, distance, [pattern1, pattern2, ..., patternn])
```

**인수**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `distance` — 퍼지(fuzzy) 매칭을 위한 최대 편집 거리입니다. [`UInt8`](/sql-reference/data-types/int-uint)
* `pattern` — 매칭할 패턴 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

지정된 편집 거리 이내에서 `haystack`과 일치하는 임의의 패턴의 인덱스(1부터 시작)를 반환하며, 일치하는 패턴이 없으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT multiFuzzyMatchAnyIndex('ClickHouse', 2, ['ClckHouse', 'ClickHose', 'ClickHouse']);
```

```response title=Response
┌─multiFuzzyMa⋯ickHouse'])─┐
│                        2 │
└──────────────────────────┘
```

## multiMatchAllIndices \{#multiMatchAllIndices\}

도입 버전: v20.1

[`multiMatchAny`](#multiMatchAny)와 유사하지만, 대상 문자열(haystack)에서 일치하는 모든 인덱스를 순서와 무관하게 배열로 반환합니다.

**구문**

```sql
multiMatchAllIndices(haystack, [pattern1, pattern2, ..., patternn])
```

**인수**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `pattern` — 매칭에 사용할 정규 표현식입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

haystack에서 일치하는 모든 인덱스(1부터 시작)를 임의의 순서로 포함하는 배열입니다. 일치하는 값이 없으면 빈 배열을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT multiMatchAllIndices('ClickHouse', ['[0-9]', 'House', 'Click', 'ouse']);
```

```response title=Response
┌─multiMatchAl⋯', 'ouse'])─┐
│ [3, 2, 4]                │
└──────────────────────────┘
```

## multiMatchAny \{#multiMatchAny\}

도입 버전: v20.1

여러 개의 정규식 패턴 중 하나 이상이 대상 문자열과 일치하는지 확인합니다.

문자열에서 여러 부분 문자열만 검색하려는 경우에는, 이 함수보다 훨씬 더 빠르게 동작하는 함수 [`multiSearchAny`](#multiSearchAny)를 대신 사용할 수 있습니다.

**문법**

```sql
multiMatchAny(haystack, pattern1[, pattern2, ...])
```

**인수**

* `haystack` — 패턴을 검색할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `pattern1[, pattern2, ...]` — 하나 이상의 정규 표현식 패턴으로 이루어진 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

패턴 중 하나라도 일치하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**다중 패턴 매칭**

```sql title=Query
SELECT multiMatchAny('Hello World', ['Hello.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['Hello.*', 'foo.*'])─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

**일치하는 패턴이 없습니다**

```sql title=Query
SELECT multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])
```

```response title=Response
┌─multiMatchAny('Hello World', ['goodbye.*', 'foo.*'])─┐
│                                                    0 │
└──────────────────────────────────────────────────────┘
```

## multiMatchAnyIndex \{#multiMatchAnyIndex\}

도입 버전: v20.1

[`multiMatchAny`](#multiMatchAny)와 유사하지만, 대상 문자열(haystack)에 일치하는 패턴의 인덱스를 반환합니다.

**구문**

```sql
multiMatchAnyIndex(haystack, [pattern1, pattern2, ..., patternn])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `pattern` — 일치 여부를 검사할 정규 표현식입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

처음으로 일치하는 패턴의 번호(1부터 시작)를 반환하며, 일치하는 것이 없으면 0을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT multiMatchAnyIndex('ClickHouse', ['[0-9]', 'House', 'Click']);
```

```response title=Response
┌─multiMatchAn⋯, 'Click'])─┐
│                        3 │
└──────────────────────────┘
```

## multiSearchAllPositions \{#multiSearchAllPositions\}

도입된 버전: v20.1

[`position`](#position)과 비슷하지만, `haystack` 문자열에서 여러 `needle` 부분 문자열의 위치(바이트 단위, 1부터 시작)를 배열로 반환합니다.

모든 `multiSearch*()` 함수는 최대 2^8개의 `needle`만 지원합니다.

**구문**

```sql
multiSearchAllPositions(haystack, needle1[, needle2, ...])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 검색할 하나 이상의 부분 문자열의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

부분 문자열이 발견되면 1부터 시작하여 바이트 단위로 계산한 시작 위치들의 배열을 반환하고, 부분 문자열을 찾지 못하면 `0`을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예시**

**여러 needle 검색**

```sql title=Query
SELECT multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])
```

```response title=Response
┌─multiSearchAllPositions('Hello, World!', ['hello', '!', 'world'])─┐
│ [0,13,0]                                                          │
└───────────────────────────────────────────────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitive \{#multiSearchAllPositionsCaseInsensitive\}

도입된 버전: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions)와 유사하지만 대소문자를 구분하지 않습니다.

**구문**

```sql
multiSearchAllPositionsCaseInsensitive(haystack, needle1[, needle2, ...])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 검색할 하나 이상의 부분 문자열로 이루어진 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

부분 문자열이 발견된 경우 1부터 시작하는 바이트 단위 시작 위치들의 배열을 반환하고, 부분 문자열이 발견되지 않은 경우 `0`을 반환합니다. [`Array(UInt64)`](/sql-reference/data-types/array)

**예시**

**대소문자를 구분하지 않는 다중 검색**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchA⋯['c', 'h'])─┐
│ [1,6]                    │
└──────────────────────────┘
```

## multiSearchAllPositionsCaseInsensitiveUTF8 \{#multiSearchAllPositionsCaseInsensitiveUTF8\}

도입: v20.1

[`multiSearchAllPositionsUTF8`](#multiSearchAllPositionsUTF8)와 동일하지만 대소문자를 구분하지 않습니다.

**구문**

```sql
multiSearchAllPositionsCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색을 수행할 UTF-8 인코딩 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 UTF-8 인코딩 부분 문자열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

부분 문자열이 발견된 경우, 1부터 시작하는 바이트 단위 시작 위치들의 배열을 반환합니다. 부분 문자열을 찾지 못한 경우 0을 반환합니다. [`Array`](/sql-reference/data-types/array)

**예제**

**대소문자를 구분하지 않는 UTF-8 검색**

```sql title=Query
SELECT multiSearchAllPositionsCaseInsensitiveUTF8('Здравствуй, мир!', ['здравствуй', 'МИР']);
```

```response title=Response
┌─multiSearchA⋯й', 'МИР'])─┐
│ [1, 13]                  │
└──────────────────────────┘
```

## multiSearchAllPositionsUTF8 \{#multiSearchAllPositionsUTF8\}

도입 버전: v20.1

[`multiSearchAllPositions`](#multiSearchAllPositions)와 유사하지만, `haystack`과 `needle` 부분 문자열이 UTF-8로 인코딩된 문자열이라고 가정합니다.

**구문**

```sql
multiSearchAllPositionsUTF8(haystack, needle1[, needle2, ...])
```

**인수**

* `haystack` — 검색을 수행하는 UTF-8로 인코딩된 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 검색할 UTF-8로 인코딩된 부분 문자열들의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

부분 문자열이 발견된 경우 바이트 단위의 시작 위치(1부터 시작)를 요소로 하는 배열을 반환하며, 부분 문자열을 찾지 못한 경우에는 `0`을 반환합니다. [`Array`](/sql-reference/data-types/array)

**예시**

**UTF-8 다중 검색**

```sql title=Query
SELECT multiSearchAllPositionsUTF8('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAllPositionsUTF8('ClickHouse', ['C', 'H'])─┐
│ [1,6]                                                 │
└───────────────────────────────────────────────────────┘
```

## multiSearchAny \{#multiSearchAny\}

도입된 버전: v20.1

여러 개의 needle 문자열 중 하나 이상이 haystack 문자열과 일치하는지 확인합니다.

[`multiSearchAnyCaseInsensitive`](#multiSearchAnyCaseInsensitive), [`multiSearchAnyUTF8`](#multiSearchAnyUTF8), [`multiSearchAnyCaseInsensitiveUTF8`](#multiSearchAnyCaseInsensitiveUTF8) 함수는 이 함수의 대소문자 구분 없음 및/또는 UTF-8 변형을 제공합니다.

**구문**

```sql
multiSearchAny(haystack, needle1[, needle2, ...])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 검색할 부분 문자열의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

적어도 하나의 일치하는 항목이 있으면 `1`을, 그렇지 않으면(일치 항목이 하나도 없으면) `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**하나라도 일치하는지 검색**

```sql title=Query
SELECT multiSearchAny('ClickHouse',['C','H'])
```

```response title=Response
┌─multiSearchAny('ClickHouse', ['C', 'H'])─┐
│                                        1 │
└──────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitive \{#multiSearchAnyCaseInsensitive\}

도입 버전: v20.1

[multiSearchAny](#multiSearchAny)와 같지만, 대소문자를 구분하지 않습니다.

**구문**

```sql
multiSearchAnyCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 부분 문자열들의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

대소문자를 구분하지 않고 하나 이상의 항목이 일치하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**대소문자 구분 없는 검색**

```sql title=Query
SELECT multiSearchAnyCaseInsensitive('ClickHouse',['c','h'])
```

```response title=Response
┌─multiSearchAnyCaseInsensitive('ClickHouse', ['c', 'h'])─┐
│                                                       1 │
└─────────────────────────────────────────────────────────┘
```

## multiSearchAnyCaseInsensitiveUTF8 \{#multiSearchAnyCaseInsensitiveUTF8\}

도입 버전: v20.1

[multiSearchAnyUTF8](#multiSearchAnyUTF8)와 동일하지만, 대소문자를 구분하지 않습니다.

**구문**

```sql
multiSearchAnyCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색을 수행할 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 UTF-8 부분 문자열들의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환값**

대소문자를 구분하지 않는 검색에서 일치 항목이 하나 이상 있으면 `1`을, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**UTF-8 문자열 &#39;Здравствуйте&#39;가 주어졌을 때, 문자 &#39;з&#39;(소문자)가 포함되어 있는지 확인합니다.**

```sql title=Query
SELECT multiSearchAnyCaseInsensitiveUTF8('Здравствуйте',['з'])
```

```response title=Response
┌─multiSearchA⋯те', ['з'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchAnyUTF8 \{#multiSearchAnyUTF8\}

도입 버전: v20.1

[multiSearchAny](#multiSearchAny)와 유사하지만, `haystack`과 `needle` 부분 문자열이 UTF-8로 인코딩된 문자열이라고 가정합니다.

**구문**

```sql
multiSearchAnyUTF8(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색이 수행되는 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 UTF-8 부분 문자열의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

하나 이상의 일치 항목이 있으면 `1`을, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**UTF-8 문자열 &#39;你好，世界&#39; (&#39;Hello, world&#39;)가 주어졌을 때, 문자열에 你 또는 界 문자가 하나라도 있는지 확인합니다.**

```sql title=Query
SELECT multiSearchAnyUTF8('你好，世界', ['你', '界'])
```

```response title=Response
┌─multiSearchA⋯你', '界'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndex \{#multiSearchFirstIndex\}

도입된 버전: v20.1

여러 needle 문자열을 haystack 문자열에서 대소문자를 구분하여 검색하고, 가장 먼저 발견된 needle의 1부터 시작하는 인덱스를 반환합니다.

**구문**

```sql
multiSearchFirstIndex(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색할 대상 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needles` — 검색할 문자열들의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

`haystack`에서 `needles` 배열에 있는 문자열들 중 처음으로 발견된 문자열의 1부터 시작하는 인덱스(`needles` 배열에서의 위치)를 반환합니다. 어떤 문자열도 발견되지 않으면 0을 반환합니다. 검색은 대소문자를 구분합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['Click', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        1 │
└──────────────────────────┘
```

**대소문자 구분 시 동작**

```sql title=Query
SELECT multiSearchFirstIndex('ClickHouse Database', ['CLICK', 'Database', 'Server']);
```

```response title=Response
┌─multiSearchF⋯ 'Server'])─┐
│                        2 │
└──────────────────────────┘
```

**일치하는 항목이 없습니다**

```sql title=Query
SELECT multiSearchFirstIndex('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitive \{#multiSearchFirstIndexCaseInsensitive\}

도입 버전: v20.1

문자열 `haystack`에서 가장 왼쪽에 있는 needle&#95;i의 인덱스 `i`(1부터 시작)를 반환하며, 없으면 0을 반환합니다.
대소문자를 무시합니다.

**구문**

```sql
multiSearchFirstIndexCaseInsensitive(haystack, [needle1, needle2, ..., needleN]
```

**인자**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 부분 문자열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

가장 왼쪽에서 처음으로 발견된 `needle`의 인덱스(1부터 시작)를 반환합니다. 일치하는 항목이 없으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitive('hElLo WoRlD', ['World', 'Hello']);
```

```response title=Response
┌─multiSearchF⋯, 'Hello'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstIndexCaseInsensitiveUTF8 \{#multiSearchFirstIndexCaseInsensitiveUTF8\}

도입 버전: v20.1

UTF-8 인코딩을 지원하는 대소문자 구분 없는 방식으로 haystack 문자열에서 여러 needle 문자열을 검색하고, 처음으로 발견된 needle의 1부터 시작하는 인덱스를 반환합니다.

**구문**

```sql
multiSearchFirstIndexCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색 대상 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needles` — 검색할 문자열의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

`haystack`에서 `needles` 배열에 있는 문자열 중 처음으로 발견된 요소의 1부터 시작하는 인덱스(`needles` 배열 내 위치)를 반환합니다. 어떤 요소도 발견되지 않으면 0을 반환합니다. 검색은 대소문자를 구분하지 않으며 UTF-8 문자 인코딩을 기준으로 동작합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('ClickHouse Database', ['CLICK', 'data', 'server']);
```

```response title=Response
┌─multiSearchF⋯ 'server'])─┐
│                        1 │
└──────────────────────────┘
```

**UTF-8 대소문자 처리 방식**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Привет Мир', ['мир', 'ПРИВЕТ']);
```

```response title=Response
┌─multiSearchF⋯ 'ПРИВЕТ'])─┐
│                        1 │
└──────────────────────────┘
```

**일치하는 결과가 없습니다**

```sql title=Query
SELECT multiSearchFirstIndexCaseInsensitiveUTF8('Hello World', ['goodbye', 'test']);
```

```response title=Response
┌─multiSearchF⋯', 'test'])─┐
│                        0 │
└──────────────────────────┘
```

## multiSearchFirstIndexUTF8 \{#multiSearchFirstIndexUTF8\}

도입된 버전: v20.1

문자열 `haystack`에서 가장 왼쪽에서 발견된 `needle_i`의 인덱스 `i`(1부터 시작)를 반환하고, 그렇지 않으면 0을 반환합니다.
`haystack`과 `needle`은 UTF-8로 인코딩된 문자열이라고 가정합니다.

**구문**

```sql
multiSearchFirstIndexUTF8(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색을 수행하는 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 UTF-8 하위 문자열의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

가장 왼쪽에 있는 needle의 인덱스(1부터 시작)를 반환합니다. 일치하는 값이 없으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT multiSearchFirstIndexUTF8('Здравствуйте мир', ['мир', 'здравствуйте']);
```

```response title=Response
┌─multiSearchF⋯вствуйте'])─┐
│                        1 │
└──────────────────────────┘
```

## multiSearchFirstPosition \{#multiSearchFirstPosition\}

도입 버전: v20.1

[`position`](#position)과 비슷하지만, 여러 개의 `needle` 문자열 중 하나와 일치하는 부분이 있는 `haystack` 문자열에서 그중 가장 왼쪽(앞쪽)의 오프셋을 반환합니다.

[`multiSearchFirstPositionCaseInsensitive`](#multiSearchFirstPositionCaseInsensitive), [`multiSearchFirstPositionUTF8`](#multiSearchFirstPositionUTF8), [`multiSearchFirstPositionCaseInsensitiveUTF8`](#multiSearchFirstPositionCaseInsensitiveUTF8) 함수는 이 함수의 대소문자를 구분하지 않는(case-insensitive) 및/또는 UTF-8 버전을 제공합니다.

**구문**

```sql
multiSearchFirstPosition(haystack, needle1[, needle2, ...])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle1[, needle2, ...]` — 검색할 하나 이상의 부분 문자열로 이루어진 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

`haystack` 문자열에서 여러 `needle` 문자열 중 하나와 일치하는 가장 왼쪽 오프셋을 반환하며, 일치하는 값이 없으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**첫 번째 위치 찾기**

```sql title=Query
SELECT multiSearchFirstPosition('Hello World',['llo', 'Wor', 'ld'])
```

```response title=Response
┌─multiSearchFirstPosition('Hello World', ['llo', 'Wor', 'ld'])─┐
│                                                             3 │
└───────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitive \{#multiSearchFirstPositionCaseInsensitive\}

도입 버전: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition)과 동일하지만 대소문자를 구분하지 않습니다.

**구문**

```sql
multiSearchFirstPositionCaseInsensitive(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 부분 문자열의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

여러 `needle` 문자열 중 하나와 일치하는 `haystack` 문자열에서 가장 왼쪽에 있는 위치(오프셋)를 반환합니다. 일치하는 값이 없으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**대소문자 구분 없이 첫 번째 위치**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitive('HELLO WORLD',['wor', 'ld', 'ello'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitive('HELLO WORLD', ['wor', 'ld', 'ello'])─┐
│                                                                             2 │
└───────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionCaseInsensitiveUTF8 \{#multiSearchFirstPositionCaseInsensitiveUTF8\}

도입 버전: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition)와 유사하지만, `haystack`과 `needle`이 UTF-8 문자열이라고 가정하고 대소문자를 무시합니다.

**구문**

```sql
multiSearchFirstPositionCaseInsensitiveUTF8(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색을 수행할 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 UTF-8 부분 문자열들의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

여러 개의 `needle` 문자열 중 어느 하나와 대소문자를 구분하지 않고 일치하는 `haystack` 문자열에서 가장 왼쪽 오프셋(offset)을 반환합니다. 일치하는 항목이 없으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**주어진 `needle` 문자열들 중 어느 하나와 일치하는 UTF-8 문자열 &#39;Здравствуй, мир&#39; (&#39;Hello, world&#39;)에서 가장 왼쪽 오프셋 찾기**

```sql title=Query
SELECT multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['МИР', 'вст', 'Здра'])
```

```response title=Response
┌─multiSearchFirstPositionCaseInsensitiveUTF8('Здравствуй, мир', ['мир', 'вст', 'Здра'])─┐
│                                                                                      3 │
└────────────────────────────────────────────────────────────────────────────────────────┘
```

## multiSearchFirstPositionUTF8 \{#multiSearchFirstPositionUTF8\}

도입된 버전: v20.1

[multiSearchFirstPosition](#multiSearchFirstPosition)와 동일하지만, `haystack`과 `needle`이 UTF-8 문자열이라고 가정합니다.

**구문**

```sql
multiSearchFirstPositionUTF8(haystack, [needle1, needle2, ..., needleN])
```

**인수**

* `haystack` — 검색이 수행되는 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 검색할 UTF-8 부분 문자열의 배열입니다. [`Array(String)`](/sql-reference/data-types/array)

**반환 값**

여러 `needle` 문자열 중 하나와 일치하는 `haystack` 문자열에서 가장 왼쪽에 있는 오프셋입니다. 일치하는 값이 없으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**주어진 `needle`들 중 어느 하나와 일치하는 UTF-8 문자열 &#39;Здравствуй, мир&#39; (&#39;Hello, world&#39;)에서 가장 왼쪽 오프셋을 찾습니다.**

```sql title=Query
SELECT multiSearchFirstPositionUTF8('Здравствуй, мир',['мир', 'вст', 'авст'])
```

```response title=Response
┌─multiSearchFirstPositionUTF8('Здравствуй, мир', ['мир', 'вст', 'авст'])─┐
│                                                                       3 │
└─────────────────────────────────────────────────────────────────────────┘
```

## ngramDistance \{#ngramDistance\}

도입 버전: v20.1

두 문자열 간의 4-그램 거리(4-gram distance)를 계산합니다.
이를 위해 두 4-그램 멀티셋(multiset) 사이의 대칭 차이(symmetric difference)를 계산한 뒤, 두 멀티셋의 크기(기수, cardinality)를 합한 값으로 나누어 정규화합니다.
반환되는 값이 작을수록 두 문자열이 더 유사합니다.

대소문자를 구분하지 않는 검색이나 UTF-8 형식의 문자열에 대해서는 [`ngramDistanceCaseInsensitive`](#ngramDistanceCaseInsensitive), [`ngramDistanceUTF8`](#ngramDistanceUTF8), [`ngramDistanceCaseInsensitiveUTF8`](#ngramDistanceCaseInsensitiveUTF8) 함수를 사용합니다.

**문법**

```sql
ngramDistance(haystack, needle)
```

**인수**

* `haystack` — 비교할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 비교할 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

`0`과 `1` 사이의 Float32 값을 반환합니다. 반환 값이 작을수록 문자열이 더 유사합니다. [`Float32`](/sql-reference/data-types/float)

**예시**

**4-그램 거리 계산**

```sql title=Query
SELECT ngramDistance('ClickHouse', 'ClickHouses')
```

```response title=Response
┌─ngramDistance('ClickHouse', 'ClickHouses')─┐
│                                        0.1 │
└────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitive \{#ngramDistanceCaseInsensitive\}

도입된 버전: v20.1

[`ngramDistance`](#ngramDistance)의 대소문자를 구분하지 않는 버전을 제공합니다.
두 문자열 사이의 4-그램 거리를, 대소문자를 무시하고 계산합니다.
반환되는 값이 작을수록 두 문자열이 더 유사합니다.

**구문**

```sql
ngramDistanceCaseInsensitive(haystack, needle)
```

**매개변수**

* `haystack` — 첫 번째 비교 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 두 번째 비교 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환값**

`0`과 `1` 사이의 Float32 타입 값을 반환합니다. [`Float32`](/sql-reference/data-types/float)

**예시**

**대소문자를 구분하지 않는 4그램 거리**

```sql title=Query
SELECT ngramDistanceCaseInsensitive('ClickHouse','clickhouse')
```

```response title=Response
┌─ngramDistanceCaseInsensitive('ClickHouse','clickhouse')─┐
│                                                       0 │
└─────────────────────────────────────────────────────────┘
```

## ngramDistanceCaseInsensitiveUTF8 \{#ngramDistanceCaseInsensitiveUTF8\}

도입된 버전: v20.1

[`ngramDistance`](#ngramDistance)의 대소문자를 구분하지 않는 UTF-8 버전을 제공합니다.
`needle`과 `haystack` 문자열이 UTF-8로 인코딩된 문자열이라고 가정하며, 대소문자를 무시합니다.
두 개의 UTF-8 문자열 사이의 3-그램 거리를 대소문자를 무시하고 계산합니다.
반환되는 값이 작을수록 문자열이 더 유사합니다.

**구문**

```sql
ngramDistanceCaseInsensitiveUTF8(haystack, needle)
```

**인수**

* `haystack` — UTF-8로 인코딩된 첫 번째 비교 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — UTF-8로 인코딩된 두 번째 비교 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

`0`과 `1` 사이의 `Float32` 실수를 반환합니다. [`Float32`](/sql-reference/data-types/float)

**예시**

**대소문자를 구분하지 않는 UTF-8 3-그램 거리**

```sql title=Query
SELECT ngramDistanceCaseInsensitiveUTF8('abcde','CDE')
```

```response title=Response
┌─ngramDistanceCaseInsensitiveUTF8('abcde','CDE')─┐
│                                             0.5 │
└─────────────────────────────────────────────────┘
```

## ngramDistanceUTF8 \{#ngramDistanceUTF8\}

도입된 버전: v20.1

[`ngramDistance`](#ngramDistance)의 UTF-8 변형을 제공합니다.
`needle` 및 `haystack` 문자열이 UTF-8로 인코딩된 문자열이라고 가정합니다.
두 UTF-8 문자열 간의 3-그램 거리를 계산합니다.
반환되는 값이 작을수록 두 문자열이 더 유사합니다.

**구문**

```sql
ngramDistanceUTF8(haystack, needle)
```

**인수(Arguments)**

* `haystack` — UTF-8로 인코딩된 첫 번째 비교 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — UTF-8로 인코딩된 두 번째 비교 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값(Returned value)**

`0`과 `1` 사이의 Float32 타입 숫자를 반환합니다. [`Float32`](/sql-reference/data-types/float)

**예시(Examples)**

**UTF-8 3-그램 거리(3-gram distance)**

```sql title=Query
SELECT ngramDistanceUTF8('abcde','cde')
```

```response title=Response
┌─ngramDistanceUTF8('abcde','cde')─┐
│                               0.5 │
└───────────────────────────────────┘
```

## ngramSearch \{#ngramSearch\}

도입 버전: v20.1

두 문자열 사이의 4-그램 거리가 지정된 임계값보다 작거나 같은지 확인합니다.

대소문자를 구분하지 않는 검색 또는 UTF-8 형식에서는 `ngramSearchCaseInsensitive`, `ngramSearchUTF8`, `ngramSearchCaseInsensitiveUTF8` FUNCTION을 사용합니다.

**구문**

```sql
ngramSearch(haystack, needle)
```

**인수**

* `haystack` — 비교 대상 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 비교 대상 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

두 문자열 간 4-그램 거리(4-gram distance)가 임계값(기본값 `1.0`) 이하이면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**4-그램을 사용한 검색**

```sql title=Query
SELECT ngramSearch('ClickHouse', 'Click')
```

```response title=Response
┌─ngramSearch('ClickHouse', 'Click')─┐
│                                  1 │
└────────────────────────────────────┘
```

## ngramSearchCaseInsensitive \{#ngramSearchCaseInsensitive\}

도입 버전: v20.1

[`ngramSearch`](#ngramSearch)의 대소문자를 구분하지 않는(case-insensitive) 변형을 제공합니다.
needle 문자열과 haystack 문자열 사이의 비대칭 차이를 계산합니다. 즉, needle에서 나온 n-그램 개수에서 공통 n-그램 개수를 뺀 값을 needle n-그램 개수로 나누어 정규화한 값입니다.
두 문자열의 4-그램 거리가, 대소문자를 무시했을 때 주어진 임계값 이하인지 검사합니다.

**구문**

```sql
ngramSearchCaseInsensitive(haystack, needle)
```

**인자**

* `haystack` — 비교할 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 비교할 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

문자열 간 4-그램 거리(4-gram distance)가 임계값(기본값 `1.0`) 이하이면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**4-그램을 사용한 대소문자 구분 없는 검색**

```sql title=Query
SELECT ngramSearchCaseInsensitive('Hello World','hello')
```

```response title=Response
┌─ngramSearchCaseInsensitive('Hello World','hello')─┐
│                                                  1 │
└────────────────────────────────────────────────────┘
```

## ngramSearchCaseInsensitiveUTF8 \{#ngramSearchCaseInsensitiveUTF8\}

도입 버전: v20.1

[`ngramSearch`](#ngramSearch)의 대소문자를 구분하지 않는 UTF-8 변형을 제공합니다.
`haystack`과 `needle`이 UTF-8 인코딩 문자열이라고 가정하며, 대소문자를 구분하지 않습니다.
대소문자를 무시했을 때 두 UTF-8 문자열 사이의 3그램(3-gram) 거리가 지정된 임계값 이하인지 확인합니다.

**구문**

```sql
ngramSearchCaseInsensitiveUTF8(haystack, needle)
```

**인수**

* `haystack` — 비교에 사용할 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 비교에 사용할 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

두 문자열 간의 3-그램 거리가 임계값(기본값은 `1.0`) 이하이면 `1`을, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**3-그램을 사용한 대소문자 구분 없는 UTF-8 검색**

```sql title=Query
SELECT ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')
```

```response title=Response
┌─ngramSearchCaseInsensitiveUTF8('абвГДЕёжз', 'АбвгдЕЁжз')─┐
│                                                        1 │
└──────────────────────────────────────────────────────────┘
```

## ngramSearchUTF8 \{#ngramSearchUTF8\}

도입 버전: v20.1

`ngramSearch`의 UTF-8 버전입니다.
`haystack`과 `needle`이 UTF-8 문자열이라고 가정합니다.
두 UTF-8 문자열 사이의 3-그램 거리(3-gram distance)가 지정된 임계값 이하인지 확인합니다.

**구문**

```sql
ngramSearchUTF8(haystack, needle)
```

**인수**

* `haystack` — 비교에 사용할 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)
* `needle` — 비교에 사용할 UTF-8 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

두 문자열의 3그램 거리가 임계값(기본값은 `1.0`) 이하이면 `1`을, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**3그램을 사용한 UTF-8 검색**

```sql title=Query
SELECT ngramSearchUTF8('абвгдеёжз', 'гдеёзд')
```

```response title=Response
┌─ngramSearchUTF8('абвгдеёжз', 'гдеёзд')─┐
│                                      1 │
└────────────────────────────────────────┘
```

## notILike \{#notILike\}

도입 버전: v20.6

대소문자를 구분하지 않고 문자열이 패턴과 일치하지 않는지 확인합니다. 패턴에는 SQL LIKE 매칭을 위한 특수 문자 `%` 및 `_`를 포함할 수 있습니다.

**구문**

```sql
notILike(haystack, pattern)
```

**인수**

* `haystack` — 검색할 입력 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 매칭에 사용할 SQL LIKE 패턴입니다. `%`는 임의 개수(0개 포함)의 문자를, `_`는 정확히 1개의 문자를 매칭합니다. [`String`](/sql-reference/data-types/string)

**반환 값**

문자열이 패턴과 일치하지 않으면(대소문자 구분 없음) `1`을, 일치하면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT notILike('ClickHouse', '%house%');
```

```response title=Response
┌─notILike('Cl⋯ '%house%')─┐
│                        0 │
└──────────────────────────┘
```

## notLike \{#notLike\}

도입 버전: v1.1

[`like`](#like)와 유사하지만 반대 결과를 반환합니다.

**구문**

```sql
notLike(haystack, pattern)
-- haystack NOT LIKE pattern
```

**인수**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`FixedString`](/sql-reference/data-types/fixedstring)
* `pattern` — 비교에 사용할 LIKE 패턴입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

문자열이 `LIKE` 패턴과 일치하지 않으면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT notLike('ClickHouse', '%House%');
```

```response title=Response
┌─notLike('Cli⋯ '%House%')─┐
│                        0 │
└──────────────────────────┘
```

**일치하지 않는 패턴**

```sql title=Query
SELECT notLike('ClickHouse', '%SQL%');
```

```response title=Response
┌─notLike('Cli⋯', '%SQL%')─┐
│                        1 │
└──────────────────────────┘
```

## position \{#position\}

도입 버전: v1.1

문자열 `haystack` 안에서 부분 문자열 `needle`의 위치(바이트 단위, 1부터 시작)를 반환합니다.

부분 문자열 `needle`이 빈 문자열인 경우 다음 규칙이 적용됩니다.

* `start_pos`가 지정되지 않은 경우: `1`을 반환합니다.
* `start_pos = 0`인 경우: `1`을 반환합니다.
* `start_pos >= 1`이고 `start_pos <= length(haystack) + 1`인 경우: `start_pos`를 반환합니다.
* 그 외의 경우: `0`을 반환합니다.

동일한 규칙이 함수 [`locate`](#locate), [`positionCaseInsensitive`](#positionCaseInsensitive), [`positionUTF8`](#positionUTF8), [`positionCaseInsensitiveUTF8`](#positionCaseInsensitiveUTF8)에도 적용됩니다.

**구문**

```sql
position(haystack, needle[, start_pos])
```

**인수**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
* `start_pos` — 검색을 시작하는 `haystack` 내 위치(1부터 시작)입니다. 선택적 인수입니다. [`UInt`](/sql-reference/data-types/int-uint)

**반환 값**

부분 문자열을 찾은 경우 시작 위치를 바이트 단위로, 1부터 계산하여 반환하고, 찾지 못한 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**기본 사용법**

```sql title=Query
SELECT position('Hello, world!', '!')
```

```response title=Response
┌─position('Hello, world!', '!')─┐
│                             13 │
└────────────────────────────────┘
```

**start&#95;pos 인수를 사용하는 경우**

```sql title=Query
SELECT position('Hello, world!', 'o', 1), position('Hello, world!', 'o', 7)
```

```response title=Response
┌─position('Hello, world!', 'o', 1)─┬─position('Hello, world!', 'o', 7)─┐
│                                 5 │                                 9 │
└───────────────────────────────────┴───────────────────────────────────┘
```

**Needle IN haystack 구문**

```sql title=Query
SELECT 6 = position('/' IN s) FROM (SELECT 'Hello/World' AS s)
```

```response title=Response
┌─equals(6, position(s, '/'))─┐
│                           1 │
└─────────────────────────────┘
```

**빈 검색 대상 부분 문자열**

```sql title=Query
SELECT position('abc', ''), position('abc', '', 0), position('abc', '', 1), position('abc', '', 2), position('abc', '', 3), position('abc', '', 4), position('abc', '', 5)
```

```response title=Response
┌─position('abc', '')─┬─position('abc', '', 0)─┬─position('abc', '', 1)─┬─position('abc', '', 2)─┬─position('abc', '', 3)─┬─position('abc', '', 4)─┬─position('abc', '', 5)─┐
│                   1 │                      1 │                      1 │                      2 │                      3 │                      4 │                      0 │
└─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
```

## positionCaseInsensitive \{#positionCaseInsensitive\}

도입된 버전: v1.1

[`position`](#position) 함수와 동일하지만, 대소문자를 구분하지 않습니다.

**구문**

```sql
positionCaseInsensitive(haystack, needle[, start_pos])
```

**별칭(Aliases)**: `instr`

**인수(Arguments)**

* `haystack` — 검색이 수행되는 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
* `start_pos` — 선택적 인수입니다. 검색을 시작할 `haystack` 내 위치(1부터 시작)입니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값(Returned value)**

부분 문자열을 찾은 경우 바이트 기준으로 1부터 시작하는 위치를 반환하고, 찾지 못한 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시(Examples)**

**대소문자를 구분하지 않는 검색(Case insensitive search)**

```sql title=Query
SELECT positionCaseInsensitive('Hello, world!', 'hello')
```

```response title=Response
┌─positionCaseInsensitive('Hello, world!', 'hello')─┐
│                                                 1 │
└───────────────────────────────────────────────────┘
```

## positionCaseInsensitiveUTF8 \{#positionCaseInsensitiveUTF8\}

도입 버전: v1.1

[`positionUTF8`](#positionUTF8)와 동일하지만 대소문자를 구분하지 않고 검색합니다.

**구문**

```sql
positionCaseInsensitiveUTF8(haystack, needle[, start_pos])
```

**인수**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
* `start_pos` — 선택적 인수입니다. 검색을 시작할 `haystack` 내 위치(1부터 시작)입니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값**

부분 문자열을 찾은 경우 시작 위치(바이트 단위, 1부터 카운트)를 반환하고, 찾지 못한 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**대소문자를 구분하지 않는 UTF-8 검색**

```sql title=Query
SELECT positionCaseInsensitiveUTF8('Привет мир', 'МИР')
```

```response title=Response
┌─positionCaseInsensitiveUTF8('Привет мир', 'МИР')─┐
│                                                8 │
└──────────────────────────────────────────────────┘
```

## positionUTF8 \{#positionUTF8\}

도입 버전: v1.1

[`position`](#position)과 동일하지만 `haystack`과 `needle`이 UTF-8로 인코딩된 문자열이라고 가정합니다.

**구문**

```sql
positionUTF8(haystack, needle[, start_pos])
```

**인수**

* `haystack` — 검색을 수행할 문자열입니다. [`String`](/sql-reference/data-types/string) 또는 [`Enum`](/sql-reference/data-types/enum)
* `needle` — 검색할 부분 문자열입니다. [`String`](/sql-reference/data-types/string)
* `start_pos` — 선택적 인수입니다. 검색을 시작하는 `haystack` 내 위치(1부터 시작)입니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값**

부분 문자열을 찾은 경우, 부분 문자열의 시작 위치를 바이트 단위로 1부터 계산하여 반환하고, 찾지 못한 경우에는 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**UTF-8 문자 수 세기**

```sql title=Query
SELECT positionUTF8('Motörhead', 'r')
```

```response title=Response
┌─position('Motörhead', 'r')─┐
│                          5 │
└────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

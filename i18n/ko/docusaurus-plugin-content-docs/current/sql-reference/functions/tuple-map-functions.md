---
description: '튜플 맵 함수 문서'
sidebar_label: '맵'
slug: /sql-reference/functions/tuple-map-functions
title: '맵 함수'
doc_type: 'reference'
---

{/* 
  아래 태그 안의 내용은 문서 프레임워크를 빌드할 때
  system.functions에서 생성된 문서로 대체됩니다. 태그를 변경하거나 삭제하지 마십시오.
  참고: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }

## extractKeyValuePairs \{#extractKeyValuePairs\}

도입 버전: v23.4

임의의 문자열에서 key-value 쌍을 추출합니다. 문자열이 key-value 쌍 형식으로 100% 구조화되어 있을 필요는 없습니다.

노이즈(예: 로그 파일)를 포함할 수 있습니다. 해석할 key-value 쌍 형식은 함수 인수를 통해 지정해야 합니다.

key-value 쌍은 키, 그 뒤에 오는 `key_value_delimiter`, 그리고 값으로 구성됩니다. 따옴표로 둘러싸인 키와 값도 지원합니다. key-value 쌍은 pair delimiter(쌍 구분자)로 서로 구분되어야 합니다.

**구문**

```sql
            extractKeyValuePairs(data, [key_value_delimiter], [pair_delimiter], [quoting_character])
```

**인수**

* `data` - key-value 쌍을 추출할 문자열입니다. [String](../../sql-reference/data-types/string.md) 또는 [FixedString](../../sql-reference/data-types/fixedstring.md).
  * `key_value_delimiter` - key와 value 사이의 구분자로 사용할 문자입니다. 기본값은 `:`입니다. [String](../../sql-reference/data-types/string.md) 또는 [FixedString](../../sql-reference/data-types/fixedstring.md).
  * `pair_delimiters` - 쌍들 사이의 구분자로 사용할 문자들의 집합입니다. 기본값은 `\space`, `,`, `;`입니다. [String](../../sql-reference/data-types/string.md) 또는 [FixedString](../../sql-reference/data-types/fixedstring.md).
  * `quoting_character` - 인용 문자로 사용할 문자입니다. 기본값은 `"`입니다. [String](../../sql-reference/data-types/string.md) 또는 [FixedString](../../sql-reference/data-types/fixedstring.md).
  * `unexpected_quoting_character_strategy` - `read_key` 및 `read_value` 단계에서 예상치 못한 위치에 나타나는 인용 문자를 처리하는 전략입니다. 가능한 값은 `invalid`, `accept`, `promote`입니다. `invalid`는 key/value를 버리고 `WAITING_KEY` 상태로 되돌립니다. `accept`는 이를 일반 문자로 처리합니다. `promote`는 `READ_QUOTED_{KEY/VALUE}` 상태로 전이한 후 다음 문자부터 다시 시작합니다. 기본값은 `INVALID`입니다.

**반환 값**

* Map(String, String)에서 추출된 key-value 쌍입니다.

**예시**

쿼리:

**단순 예시**

```sql
            arthur :) select extractKeyValuePairs('name:neymar, age:31 team:psg,nationality:brazil') as kv

            SELECT extractKeyValuePairs('name:neymar, age:31 team:psg,nationality:brazil') as kv

            Query id: f9e0ca6f-3178-4ee2-aa2c-a5517abb9cee

            ┌─kv──────────────────────────────────────────────────────────────────────┐
            │ {'name':'neymar','age':'31','team':'psg','nationality':'brazil'}        │
            └─────────────────────────────────────────────────────────────────────────┘
```

**인용 문자로 작은따옴표 사용**

```sql
            arthur :) select extractKeyValuePairs('name:\'neymar\';\'age\':31;team:psg;nationality:brazil,last_key:last_value', ':', ';,', '\'') as kv

            SELECT extractKeyValuePairs('name:\'neymar\';\'age\':31;team:psg;nationality:brazil,last_key:last_value', ':', ';,', '\'') as kv

            Query id: 0e22bf6b-9844-414a-99dc-32bf647abd5e

            ┌─kv───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
            │ {'name':'neymar','age':'31','team':'psg','nationality':'brazil','last_key':'last_value'}                                 │
            └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

unexpected&#95;quoting&#95;character&#95;strategy 사용 예:

unexpected&#95;quoting&#95;character&#95;strategy=invalid

```sql
            SELECT extractKeyValuePairs('name"abc:5', ':', ' ,;', '\"', 'INVALID') as kv;
```

```text
            ┌─kv────────────────┐
            │ {'abc':'5'}  │
            └───────────────────┘
```

```sql
            SELECT extractKeyValuePairs('name"abc":5', ':', ' ,;', '\"', 'INVALID') as kv;
```

```text
            ┌─kv──┐
            │ {}  │
            └─────┘
```

unexpected&#95;quoting&#95;character&#95;strategy=accept

```sql
            SELECT extractKeyValuePairs('name"abc:5', ':', ' ,;', '\"', 'ACCEPT') as kv;
```

```text
            ┌─kv────────────────┐
            │ {'name"abc':'5'}  │
            └───────────────────┘
```

```sql
            SELECT extractKeyValuePairs('name"abc":5', ':', ' ,;', '\"', 'ACCEPT') as kv;
```

```text
            ┌─kv─────────────────┐
            │ {'name"abc"':'5'}  │
            └────────────────────┘
```

unexpected&#95;quoting&#95;character&#95;strategy=promote

```sql
            SELECT extractKeyValuePairs('name"abc:5', ':', ' ,;', '\"', 'PROMOTE') as kv;
```

```text
            ┌─kv──┐
            │ {}  │
            └─────┘
```

```sql
            SELECT extractKeyValuePairs('name"abc":5', ':', ' ,;', '\"', 'PROMOTE') as kv;
```

```text
            ┌─kv───────────┐
            │ {'abc':'5'}  │
            └──────────────┘
```

**이스케이프 시퀀스 미지원 시 이스케이프 처리**

```sql
            arthur :) select extractKeyValuePairs('age:a\\x0A\\n\\0') as kv

            SELECT extractKeyValuePairs('age:a\\x0A\\n\\0') AS kv

            Query id: e9fd26ee-b41f-4a11-b17f-25af6fd5d356

            ┌─kv────────────────────┐
            │ {'age':'a\\x0A\\n\\0'} │
            └───────────────────────┘
```

**구문**

```sql
```

**별칭(Aliases)**: `str_to_map`, `mapFromString`

**인수(Arguments)**

* 없음

**반환값(Returned value)**

**예시(Examples)**

## extractKeyValuePairsWithEscaping \{#extractKeyValuePairsWithEscaping\}

도입 버전: v23.4

`extractKeyValuePairs`와 동일하지만 이스케이프를 지원합니다.

지원되는 이스케이프 시퀀스: `\x`, `\N`, `\a`, `\b`, `\e`, `\f`, `\n`, `\r`, `\t`, `\v`, `\0`.
비표준 이스케이프 시퀀스는 아래 나열된 경우가 아닌 한(역슬래시를 포함하여) 그대로 반환됩니다:
`\\`, `'`, `"`, `backtick`, `/`, `=` 또는 ASCII 제어 문자(`c <= 31`).

이 함수는 pre-escaping 및 post-escaping이 적절하지 않은 사용 사례에 적합합니다. 예를 들어, 다음과 같은
입력 문자열을 살펴봅니다: `a: "aaaa\"bbb"`. 기대되는 출력은 `a: aaaa\"bbbb`입니다.

* Pre-escaping: pre-escaping을 수행하면 출력은 `a: "aaaa"bbb"`가 되고, 이후 `extractKeyValuePairs`는 `a: aaaa`를 출력합니다.
  * Post-escaping: `extractKeyValuePairs`는 `a: aaaa\`를 출력하고, post-escaping은 이를 그대로 유지합니다.

선행 이스케이프 시퀀스는 키에서는 건너뛰며, 값에서는 잘못된 것으로 간주됩니다.

**이스케이프 시퀀스 지원이 활성화된 상태에서의 이스케이프 시퀀스**

```sql
            arthur :) select extractKeyValuePairsWithEscaping('age:a\\x0A\\n\\0') as kv

            SELECT extractKeyValuePairsWithEscaping('age:a\\x0A\\n\\0') AS kv

            Query id: 44c114f0-5658-4c75-ab87-4574de3a1645

            ┌─kv───────────────┐
            │ {'age':'a\n\n\0'} │
            └──────────────────┘
```

**구문**

```sql
```

**인수**

* 없음.

**반환값**

**예제**

## map \{#map\}

도입 버전: v21.1

key-value 쌍에서 `Map(key, value)` 타입의 값을 생성합니다.

**구문**

```sql
map(key1, value1[, key2, value2, ...])
```

**인수**

* `key_n` — 맵 항목의 키입니다. [`Any`](/sql-reference/data-types)
* `value_n` — 맵 항목의 값입니다. [`Any`](/sql-reference/data-types)

**반환 값**

key:value 쌍을 포함하는 맵을 반환합니다. [`Map(Any, Any)`](/sql-reference/data-types/map)

**예제**

**사용 예제**

```sql title=Query
SELECT map('key1', number, 'key2', number * 2) FROM numbers(3)
```

```response title=Response
{'key1':0,'key2':0}
{'key1':1,'key2':2}
{'key1':2,'key2':4}
```

## mapAdd \{#mapAdd\}

도입 버전: v20.7

모든 키를 모으고 해당 값들을 합산합니다.

**구문**

```sql
mapAdd(arg1[, arg2, ...])
```

**인수**

* `arg1[, arg2, ...]` — 첫 번째 배열의 항목이 키를 나타내고 두 번째 배열이 각 키에 대한 값을 포함하는 맵(Map) 또는 두 개의 배열로 구성된 튜플입니다. [`Map(K, V)`](/sql-reference/data-types/map) 또는 [`Tuple(Array(T), Array(T))`](/sql-reference/data-types/tuple)

**반환 값**

맵(Map)을 반환하거나, 첫 번째 배열에 정렬된 키가 포함되고 두 번째 배열에 해당 값이 포함된 튜플을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map) 또는 [`Tuple(Array(T), Array(T))`](/sql-reference/data-types/tuple)

**예시**

**Map 타입 예시**

```sql title=Query
SELECT mapAdd(map(1, 1), map(1, 1))
```

```response title=Response
{1:2}
```

**튜플을 사용하는 경우**

```sql title=Query
SELECT mapAdd(([toUInt8(1), 2], [1, 1]), ([toUInt8(1), 2], [1, 1]))
```

```response title=Response
([1, 2], [2, 2])
```

## mapAll \{#mapAll\}

도입된 버전: v23.4

맵에 있는 모든 key-value 쌍에 대해 조건이 성립하는지 테스트합니다.
`mapAll`은 고차 함수입니다.
첫 번째 인수로 람다 함수를 전달할 수 있습니다.

**구문**

```sql
mapAll([func,] map)
```

**인수**

* `func` — 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `map` — 검사할 맵. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

모든 key-value 쌍이 조건을 만족하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT mapAll((k, v) -> v = 1, map('k1', 1, 'k2', 2))
```

```response title=Response
0
```

## mapApply \{#mapApply\}

도입된 버전: v22.3

맵의 각 요소에 FUNCTION을 적용합니다.

**구문**

```sql
mapApply(func, map)
```

**인수**

* `func` — 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `map` — 함수를 적용할 맵. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

원래 맵의 각 요소에 `func`를 적용하여 생성된 새로운 맵을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
SELECT mapApply((k, v) -> (k, v * 2), map('k1', 1, 'k2', 2))
```

```response title=Response
{'k1':2,'k2':4}
```

## mapConcat \{#mapConcat\}

도입 버전: v23.4

키의 동일 여부를 기준으로 여러 맵을 연결합니다.
같은 키를 가진 요소가 둘 이상의 입력 맵에 존재하는 경우, 모든 요소가 결과 맵에 추가되지만 `[]` 연산자를 통해 접근할 수 있는 요소는 첫 번째 요소 하나뿐입니다.

**구문**

```sql
mapConcat(maps)
```

**인수**

* `maps` — 임의 개수의 맵. [`Map`](/sql-reference/data-types/map)

**반환 값**

인수로 전달된 맵들을 병합하여 하나로 합친 맵을 반환합니다. [`Map`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
SELECT mapConcat(map('k1', 'v1'), map('k2', 'v2'))
```

```response title=Response
{'k1':'v1','k2':'v2'}
```

## mapContainsKey \{#mapContainsKey\}

도입 버전: v21.2

키가 맵에 포함되어 있는지 확인합니다.

**구문**

```sql
mapContains(map, key)
```

**별칭**: `mapContains`

**인수**

* `map` — 검색 대상 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)
* `key` — 검색할 키입니다. 타입은 맵의 키 타입과 일치해야 합니다. [`Any`](/sql-reference/data-types)

**반환 값**

맵에 키가 포함되어 있으면 1을, 포함되어 있지 않으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT mapContainsKey(map('k1', 'v1', 'k2', 'v2'), 'k1')
```

```response title=Response
1
```

## mapContainsKeyLike \{#mapContainsKeyLike\}

도입 버전: v23.4

맵에 `LIKE` 패턴과 일치하는 키가 포함되어 있는지 확인합니다.

**구문**

```sql
mapContainsKeyLike(map, pattern)
```

**인수**

* `map` — 검색할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)
* `pattern` — 키와 일치 여부를 검사할 패턴입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

`map`에 `pattern`과 일치하는 키가 있으면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE tab (a Map(String, String))
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO tab VALUES ({'abc':'abc','def':'def'}), ({'hij':'hij','klm':'klm'});

SELECT mapContainsKeyLike(a, 'a%') FROM tab;
```

```response title=Response
┌─mapContainsKeyLike(a, 'a%')─┐
│                           1 │
│                           0 │
└─────────────────────────────┘
```

## mapContainsValue \{#mapContainsValue\}

도입 버전: v25.6

값이 맵에 포함되어 있는지 확인합니다.

**구문**

```sql
mapContainsValue(map, value)
```

**인수**

* `map` — 검색할 맵. [`Map(K, V)`](/sql-reference/data-types/map)
* `value` — 검색할 값. 타입은 맵의 값 타입과 일치해야 합니다. [`Any`](/sql-reference/data-types)

**반환 값**

맵에 해당 값이 포함되어 있으면 `1`, 포함되어 있지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT mapContainsValue(map('k1', 'v1', 'k2', 'v2'), 'v1')
```

```response title=Response
1
```

## mapContainsValueLike \{#mapContainsValueLike\}

도입 버전: v25.5

맵에 `LIKE` 연산자를 사용해 지정한 패턴과 일치하는 값이 포함되어 있는지 확인합니다.

**문법**

```sql
mapContainsValueLike(map, pattern)
```

**인수**

* `map` — 검색할 맵. [`Map(K, V)`](/sql-reference/data-types/map)
* `pattern` — 값과 매칭할 패턴. [`const String`](/sql-reference/data-types/string)

**반환 값**

`map`에 `pattern`과 일치하는 값이 포함되어 있으면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE tab (a Map(String, String))
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO tab VALUES ({'abc':'abc','def':'def'}), ({'hij':'hij','klm':'klm'});

SELECT mapContainsValueLike(a, 'a%') FROM tab;
```

```response title=Response
┌─mapContainsV⋯ke(a, 'a%')─┐
│                        1 │
│                        0 │
└──────────────────────────┘
```

## mapExists \{#mapExists\}

도입된 버전: v23.4

맵에서 최소 하나의 키-값 쌍에 대해 조건이 성립하는지 검사합니다.
`mapExists`는 고차 함수입니다.
첫 번째 인수로 람다 함수를 전달할 수 있습니다.

**구문**

```sql
mapExists([func,] map)
```

**인수**

* `func` — 선택적인 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `map` — 검사할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

하나 이상의 키-값 쌍이 조건을 만족하면 `1`을, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT mapExists((k, v) -> v = 1, map('k1', 1, 'k2', 2))
```

```response title=Response
1
```

## mapExtractKeyLike \{#mapExtractKeyLike\}

도입 버전: v23.4

문자열 키를 가진 맵과 `LIKE` 패턴을 인수로 받아, 키가 해당 패턴과 일치하는 요소만 포함하는 맵을 반환합니다.

**구문**

```sql
mapExtractKeyLike(map, pattern)
```

**인자**

* `map` — 값을 추출할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)
* `pattern` — 키를 비교할 패턴입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

지정된 패턴과 키가 일치하는 요소만 포함된 맵을 반환합니다. 어떤 요소도 패턴과 일치하지 않으면 빈 맵을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE tab (a Map(String, String))
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO tab VALUES ({'abc':'abc','def':'def'}), ({'hij':'hij','klm':'klm'});

SELECT mapExtractKeyLike(a, 'a%') FROM tab;
```

```response title=Response
┌─mapExtractKeyLike(a, 'a%')─┐
│ {'abc':'abc'}              │
│ {}                         │
└────────────────────────────┘
```

## mapExtractValueLike \{#mapExtractValueLike\}

도입 버전: v25.5

문자열 값을 가지는 맵과 `LIKE` 패턴이 주어지면, 이 함수는 값이 해당 패턴과 일치하는 요소만 포함하는 맵을 반환합니다.

**구문**

```sql
mapExtractValueLike(map, pattern)
```

**인수**

* `map` — 추출할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)
* `pattern` — 값과 대조할 패턴입니다. [`const String`](/sql-reference/data-types/string)

**반환 값**

지정한 패턴과 일치하는 값을 가진 요소만 포함하는 맵을 반환합니다. 어떤 요소도 패턴과 일치하지 않으면 빈 맵을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE tab (a Map(String, String))
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO tab VALUES ({'abc':'abc','def':'def'}), ({'hij':'hij','klm':'klm'});

SELECT mapExtractValueLike(a, 'a%') FROM tab;
```

```response title=Response
┌─mapExtractValueLike(a, 'a%')─┐
│ {'abc':'abc'}                │
│ {}                           │
└──────────────────────────────┘
```

## mapFilter \{#mapFilter\}

v22.3에서 도입되었습니다.

맵의 각 요소에 함수를 적용하여 맵을 필터링합니다.

**구문**

```sql
mapFilter(func, map)
```

**인수**

* `func` — 람다 함수. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `map` — 필터링할 맵. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

`func`가 `0`이 아닌 값을 반환하는 요소만 포함하는 맵을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예제**

**사용 예제**

```sql title=Query
SELECT mapFilter((k, v) -> v > 1, map('k1', 1, 'k2', 2))
```

```response title=Response
{'k2':2}
```

## mapFromArrays \{#mapFromArrays\}

도입된 버전: v23.3

키 배열(또는 맵)과 값 배열(또는 맵)으로부터 맵을 생성합니다.
이 함수는 구문 `CAST([...], 'Map(key_type, value_type)')`의 편리한 대안입니다.

**문법**

```sql
mapFromArrays(keys, values)
```

**별칭**: `MAP_FROM_ARRAYS`

**인수**

* `keys` — 맵을 생성하는 데 사용할 키의 배열 또는 맵입니다. [`Array`](/sql-reference/data-types/array) 또는 [`Map`](/sql-reference/data-types/map)
* `values` — 맵을 생성하는 데 사용할 값의 배열 또는 맵입니다. [`Array`](/sql-reference/data-types/array) 또는 [`Map`](/sql-reference/data-types/map)

**반환값**

키 배열과 값 배열/맵을 사용해 구성한 키-값 쌍을 가진 맵을 반환합니다. [`Map`](/sql-reference/data-types/map)

**예시**

**기본 사용법**

```sql title=Query
SELECT mapFromArrays(['a', 'b', 'c'], [1, 2, 3])
```

```response title=Response
{'a':1,'b':2,'c':3}
```

**맵 입력을 사용하는 경우**

```sql title=Query
SELECT mapFromArrays([1, 2, 3], map('a', 1, 'b', 2, 'c', 3))
```

```response title=Response
{1:('a', 1), 2:('b', 2), 3:('c', 3)}
```

## mapKeys \{#mapKeys\}

도입된 버전: v21.2

지정된 맵의 키를 반환합니다.
이 함수는 [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns) 설정을 활성화하여 최적화할 수 있습니다.
해당 설정이 활성화되면, 함수는 전체 맵 대신 `keys` 서브컬럼만 읽습니다.
쿼리 `SELECT mapKeys(m) FROM table`는 `SELECT m.keys FROM table`로 변환됩니다.

**문법**

```sql
mapKeys(map)
```

**인수**

* `map` — 키를 추출할 맵. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

맵의 모든 키를 포함하는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예**

```sql title=Query
SELECT mapKeys(map('k1', 'v1', 'k2', 'v2'))
```

```response title=Response
['k1','k2']
```

## mapPartialReverseSort \{#mapPartialReverseSort\}

도입된 버전: v23.4

맵의 요소를 내림차순으로 정렬하며, 추가 limit 인수를 통해 일부만 정렬할 수 있습니다.
`func` 함수를 지정하면, 맵의 키와 값에 `func` 함수를 적용한 결과에 따라 정렬 순서가 결정됩니다.

**구문**

```sql
mapPartialReverseSort([func,] limit, map)
```

**인수**

* `func` — 선택 사항입니다. 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `limit` — `[1..limit]` 범위의 요소가 정렬됩니다. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `map` — 정렬할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

내림차순으로 부분적으로 정렬된 맵을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
SELECT mapPartialReverseSort((k, v) -> v, 2, map('k1', 3, 'k2', 1, 'k3', 2))
```

```response title=Response
{'k1':3,'k3':2,'k2':1}
```

## mapPartialSort \{#mapPartialSort\}

도입된 버전: v23.4

맵의 요소를 오름차순으로 정렬하며, 추가적인 limit 인수를 사용해 부분 정렬을 수행합니다.
`func` 함수를 지정하면, 맵의 키와 값에 `func` 함수를 적용한 결과에 따라 정렬 순서가 결정됩니다.

**구문**

```sql
mapPartialSort([func,] limit, map)
```

**인수**

* `func` — 선택적입니다. 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `limit` — 범위 `[1..limit]` 내의 요소만 정렬합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `map` — 정렬할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

부분적으로 정렬된 맵을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
SELECT mapPartialSort((k, v) -> v, 2, map('k1', 3, 'k2', 1, 'k3', 2))
```

```response title=Response
{'k2':1,'k3':2,'k1':3}
```

## mapPopulateSeries \{#mapPopulateSeries\}

도입 버전: v20.10

정수 키를 가진 맵에서 누락된 key-value 쌍을 채웁니다.
가장 큰 값보다 더 큰 키까지 확장할 수 있도록, 최대 키를 지정할 수 있습니다.
좀 더 구체적으로, 이 함수는 키가 가장 작은 키부터 가장 큰 키(또는 지정된 경우 max 인수)까지 1씩 증가하는 수열을 이루고, 그에 대응하는 값들을 가지는 맵을 반환합니다.
특정 키에 대한 값이 지정되지 않은 경우, 기본값이 사용됩니다.
키가 반복되는 경우, 해당 키에는 (등장 순서 기준으로) 첫 번째 값만 매핑됩니다.

**구문**

```sql
mapPopulateSeries(map[, max]) | mapPopulateSeries(keys, values[, max])
```

**인수(Arguments)**

* `map` — 정수 키를 가진 맵입니다. [`Map((U)Int*, V)`](/sql-reference/data-types/map)
* `keys` — 키 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `values` — 값 배열입니다. [`Array(T)`](/sql-reference/data-types/array)
* `max` — 선택적 인수입니다. 최대 키 값입니다. [`Int8`](/sql-reference/data-types/int-uint) 또는 [`Int16`](/sql-reference/data-types/int-uint) 또는 [`Int32`](/sql-reference/data-types/int-uint) 또는 [`Int64`](/sql-reference/data-types/int-uint) 또는 [`Int128`](/sql-reference/data-types/int-uint) 또는 [`Int256`](/sql-reference/data-types/int-uint)

**반환 값(Returned value)**

키가 정렬된 순서로 포함된 맵 또는 두 개의 배열로 이루어진 튜플을 반환합니다. 첫 번째 배열에는 키가 정렬된 순서로, 두 번째 배열에는 해당 키에 대한 값이 포함됩니다. [`Map(K, V)`](/sql-reference/data-types/map) 또는 [`Tuple(Array(UInt*), Array(Any))`](/sql-reference/data-types/tuple)

**예시(Examples)**

**Map 타입 사용 예시(With Map type)**

```sql title=Query
SELECT mapPopulateSeries(map(1, 10, 5, 20), 6)
```

```response title=Response
{1:10, 2:0, 3:0, 4:0, 5:20, 6:0}
```

**맵이 적용된 배열과 함께 사용하기**

```sql title=Query
SELECT mapPopulateSeries([1, 2, 4], [11, 22, 44], 5)
```

```response title=Response
([1, 2, 3, 4, 5], [11, 22, 0, 44, 0])
```

## mapReverseSort \{#mapReverseSort\}

도입 버전: v23.4

맵의 요소를 내림차순으로 정렬합니다.
`func` 함수를 지정하면 맵의 키와 값에 `func` 함수를 적용한 결과에 따라 정렬 순서가 결정됩니다.

**구문**

```sql
mapReverseSort([func,] map)
```

**인수**

* `func` — 선택적인 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `map` — 정렬할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

내림차순으로 정렬된 맵을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
SELECT mapReverseSort((k, v) -> v, map('k1', 3, 'k2', 1, 'k3', 2))
```

```response title=Response
{'k1':3,'k3':2,'k2':1}
```

## mapSort \{#mapSort\}

도입 버전: v23.4

맵의 요소를 오름차순으로 정렬합니다.
`func` 함수가 지정된 경우, 맵의 키와 값에 `func` 함수를 적용한 결과에 따라 정렬 순서가 결정됩니다.

**구문**

```sql
mapSort([func,] map)
```

**인자**

* `func` — 선택적입니다. 람다 함수입니다. [`Lambda function`](/sql-reference/functions/overview#arrow-operator-and-lambda)
* `map` — 정렬할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

오름차순으로 정렬된 맵을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
SELECT mapSort((k, v) -> v, map('k1', 3, 'k2', 1, 'k3', 2))
```

```response title=Response
{'k2':1,'k3':2,'k1':3}
```

## mapSubtract \{#mapSubtract\}

v20.7에서 도입되었습니다.

모든 키를 모은 후, 동일한 키에 해당하는 값들을 서로 뺍니다.

**구문**

```sql
mapSubtract(arg1[, arg2, ...])
```

**인수**

* `arg1[, arg2, ...]` — 첫 번째 배열의 요소가 키를 나타내고 두 번째 배열에 각 키에 대한 값이 들어 있는 맵 또는 두 배열로 이루어진 튜플입니다. [`Map(K, V)`](/sql-reference/data-types/map) 또는 [`Tuple(Array(T), Array(T))`](/sql-reference/data-types/tuple)

**반환 값**

첫 번째 배열에 정렬된 키가, 두 번째 배열에 해당 값이 포함된 하나의 맵 또는 튜플을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map) 또는 [`Tuple(Array(T), Array(T))`](/sql-reference/data-types/tuple)

**예시**

**Map 타입 사용 예시**

```sql title=Query
SELECT mapSubtract(map(1, 1), map(1, 1))
```

```response title=Response
{1:0}
```

**튜플 맵 사용**

```sql title=Query
SELECT mapSubtract(([toUInt8(1), 2], [toInt32(1), 1]), ([toUInt8(1), 2], [toInt32(2), 1]))
```

```response title=Response
([1, 2], [-1, 0])
```

## mapUpdate \{#mapUpdate\}

도입된 버전: v22.3

두 개의 맵에 대해, 두 번째 맵의 해당 키 값으로 첫 번째 맵의 값을 업데이트한 결과를 반환합니다.

**구문**

```sql
mapUpdate(map1, map2)
```

**인수**

* `map1` — 업데이트할 대상 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)
* `map2` — 업데이트에 사용할 맵입니다. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

`map2`에서 동일한 키에 대한 값을 사용해 값을 업데이트한 `map1`을 반환합니다. [`Map(K, V)`](/sql-reference/data-types/map)

**예제**

**기본 사용법**

```sql title=Query
SELECT mapUpdate(map('key1', 0, 'key3', 0), map('key1', 10, 'key2', 10))
```

```response title=Response
{'key3':0,'key1':10,'key2':10}
```

## mapValues \{#mapValues\}

도입된 버전: v21.2

지정된 맵의 값을 반환합니다.
이 함수는 설정 [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns)을 활성화하여 최적화할 수 있습니다.
설정을 활성화하면 이 함수는 전체 맵 대신 `values` 서브컬럼만 읽습니다.
쿼리 `SELECT mapValues(m) FROM table`는 `SELECT m.values FROM table`로 변환됩니다.

**구문**

```sql
mapValues(map)
```

**인수**

* `map` — 값을 추출할 대상 맵. [`Map(K, V)`](/sql-reference/data-types/map)

**반환 값**

맵에 있는 모든 값을 포함하는 배열을 반환합니다. [`Array(T)`](/sql-reference/data-types/array)

**예제**

**사용 예제**

```sql title=Query
SELECT mapValues(map('k1', 'v1', 'k2', 'v2'))
```

```response title=Response
['v1','v2']
```

{/*AUTOGENERATED_END*/ }

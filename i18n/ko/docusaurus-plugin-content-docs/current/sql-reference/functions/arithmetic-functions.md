---
description: '산술 함수 문서'
sidebar_label: '산술'
slug: /sql-reference/functions/arithmetic-functions
title: '산술 함수'
doc_type: 'reference'
---

# 산술 함수 \{#arithmetic-functions\}

## 개요 \{#overview\}

산술 함수는 `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, `Float32`, `Float64` 타입의 두 피연산자에 대해 동작합니다.

연산을 수행하기 전에 두 피연산자는 결과 타입으로 캐스팅됩니다. 결과 타입은 (아래 함수 문서에서 달리 명시되지 않는 한) 다음과 같이 결정됩니다.

* 두 피연산자 모두 32비트 이하인 경우, 결과 타입의 크기는 두 피연산자 중 더 큰 타입보다 한 단계 더 큰 타입의 크기가 됩니다(정수 크기 승격). 예: `UInt8 + UInt16 = UInt32`, `Float32 * Float32 = Float64`.
* 피연산자 중 하나가 64비트 이상인 경우, 결과 타입의 크기는 두 피연산자 중 더 큰 타입의 크기와 동일합니다. 예: `UInt32 + UInt128 = UInt128`, `Float32 * Float64 = Float64`.
* 피연산자 중 하나가 부호 있는(signed) 타입이면 결과 타입도 부호 있는(signed) 타입이 되며, 그렇지 않으면 부호 없는(unsigned) 타입이 됩니다. 예: `UInt32 * Int32 = Int64`, `UInt32 * UInt32 = UInt64`.

이 규칙들은 결과 타입이 모든 가능한 결과를 표현할 수 있는 가장 작은 타입이 되도록 보장합니다. 이는 값 범위 경계 주변에서 오버플로 위험을 일으킬 수 있지만, 64비트라는 최대 네이티브 정수 폭을 사용하여 계산이 빠르게 수행되도록 합니다. 또한 이 동작은 가장 큰 정수 타입으로 64비트 정수(BIGINT)를 제공하는 많은 다른 데이터베이스와의 호환성을 보장합니다.

예시:

```sql
SELECT toTypeName(0), toTypeName(0 + 0), toTypeName(0 + 0 + 0), toTypeName(0 + 0 + 0 + 0)
```

```text
┌─toTypeName(0)─┬─toTypeName(plus(0, 0))─┬─toTypeName(plus(plus(0, 0), 0))─┬─toTypeName(plus(plus(plus(0, 0), 0), 0))─┐
│ UInt8         │ UInt16                 │ UInt32                          │ UInt64                                   │
└───────────────┴────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┘
```

오버플로 동작은 C++과 동일합니다.

{/* 
  아래 태그 안의 내용은 문서 프레임워크를 빌드할 때 
  system.functions에서 생성된 문서로 대체됩니다. 태그를 수정하거나 제거하지 마십시오.
  자세한 내용은 https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md 를 참조하십시오.
  */ }

{/*AUTOGENERATED_START*/ }

## abs \{#abs\}

도입 버전: v1.1

`x`의 절댓값을 계산합니다. `x`가 부호 없는 타입이면 결과는 변경되지 않습니다. `x`가 부호 있는 타입이면 부호 없는 수를 반환합니다.

**구문**

```sql
abs(x)
```

**인수**

* `x` — 절대값을 구할 값

**반환값**

`x`의 절대값

**예시**

**사용 예시**

```sql title=Query
SELECT abs(-0.5)
```

```response title=Response
0.5
```

## avg2 \{#avg2\}

도입된 버전: v25.11

제공된 인수의 평균값을 계산하여 반환합니다.
숫자형 및 시간 관련 타입을 지원합니다.

**구문**

```sql
avg2(x1, x2])
```

**인수**

* `x1, x2]` — 평균을 계산하기 위해 두 개의 값을 입력으로 받습니다.

**반환 값**

제공된 인수들의 평균 값을 계산한 뒤, 호환 가능한 가장 큰 데이터 타입으로 승격하여 반환합니다.

**예시**

**숫자 타입**

```sql title=Query
SELECT avg2(toUInt8(3), 1.0) AS result, toTypeName(result) AS type;
-- The type returned is a Float64 as the UInt8 must be promoted to 64 bit for the comparison.
```

```response title=Response
┌─result─┬─type────┐
│      2 │ Float64 │
└────────┴─────────┘
```

**Decimal 데이터 타입**

```sql title=Query
SELECT avg2(toDecimal32(1, 2), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Date 데이터 타입**

```sql title=Query
SELECT avg2(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**DateTime 데이터 타입**

```sql title=Query
SELECT avg2(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Time64 데이터 타입**

```sql title=Query
SELECT avg2(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```

## byteSwap \{#byteSwap\}

도입 버전: v23.10

정수의 바이트 순서를 반전합니다. 즉, [endianness](https://en.wikipedia.org/wiki/Endianness)를 변경합니다.

아래 예시는 다음과 같은 방식으로 이해할 수 있습니다.

1. 10진수 정수를 big-endian 형식의 16진수로 변환합니다. 예: 3351772109 -&gt; C7 C7 FB CD (4바이트)
2. 바이트 순서를 반전합니다. 예: C7 C7 FB CD -&gt; CD FB C7 C7
3. 결과를 big-endian으로 가정하고 다시 정수로 변환합니다. 예: CD FB C7 C7 -&gt; 3455829959
   이 FUNCTION의 한 가지 사용 사례는 IPv4 주소의 바이트 순서를 반전하는 것입니다.

```result
┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
│ 199.199.251.205                                       │
└───────────────────────────────────────────────────────┘
```

**문법**

```sql
byteSwap(x)
```

**인수**

* `x` — 정수 값입니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

바이트 순서를 반대로 한 `x`를 반환합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**8비트**

```sql title=Query
SELECT byteSwap(54)
```

```response title=Response
54
```

**16비트**

```sql title=Query
SELECT byteSwap(4135)
```

```response title=Response
10000
```

**32비트**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**64비트**

```sql title=Query
SELECT byteSwap(123294967295)
```

```response title=Response
18439412204227788800
```

## divide \{#divide\}

도입 버전: v1.1

두 값 `a`와 `b`의 몫을 계산합니다. 결과 타입은 항상 [Float64](/sql-reference/data-types/float)입니다. 정수 나눗셈은 `intDiv` FUNCTION으로 수행됩니다.

:::note
`0`으로 나누는 경우 `inf`, `-inf`, 또는 `nan`을 반환합니다.
:::

**구문**

```sql
divide(x, y)
```

**인수**

* `x` — 피제수, `y` — 제수

**반환값**

x를 y로 나눈 몫

**예시**

**두 수 나누기**

```sql title=Query
SELECT divide(25,5) AS quotient, toTypeName(quotient)
```

```response title=Response
5 Float64
```

**0으로 나누는 경우**

```sql title=Query
SELECT divide(25,0)
```

```response title=Response
inf
```

## divideDecimal \{#divideDecimal\}

도입: v22.12

두 개의 decimal 값에 대해 나눗셈을 수행합니다. 결과값의 타입은 [Decimal256](/sql-reference/data-types/decimal)입니다.
결과 스케일(scale)은 `result_scale` 인자(범위 `[0, 76]`의 const Integer)로 명시적으로 지정할 수 있습니다. 지정하지 않으면 결과 스케일은 전달된 인자들의 스케일 중 최대값이 됩니다.

:::note
이 함수는 일반 `divide`보다 상당히 느리게 동작합니다.
정밀도를 엄격히 제어할 필요가 없거나 빠른 계산이 더 중요하다면 [divide](#divide)를 사용하는 것을 고려하십시오.
:::

**구문**

```sql
divideDecimal(x, y[, result_scale])
```

**인수(Arguments)**

* `x` — 첫 번째 값: [Decimal](/sql-reference/data-types/decimal). - `y` — 두 번째 값: [Decimal](/sql-reference/data-types/decimal). - `result_scale` — 결과의 스케일(scale). 타입 [Int/UInt](/sql-reference/data-types/int-uint).

**반환값**

지정된 스케일로 수행한 나누기 연산의 결과. [`Decimal256`](/sql-reference/data-types/decimal)

**예시(Examples)**

**예시 1**

```sql title=Query
divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)
```

```response title=Response
┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐
│                                                -5.7142857142 │
└──────────────────────────────────────────────────────────────┘
```

**예제 2**

```sql title=Query
SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);
SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);
```

```response title=Response
┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐
│                                             -5.7 │
└──────────────────────────────────────────────────┘
┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐
│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
```

## divideOrNull \{#divideOrNull\}

도입 버전: v25.5

`divide`와 동일하지만, 0으로 나눌 때 NULL을 반환합니다.

**구문**

```sql
divideOrNull(x, y)
```

**인수**

* `x` — 피제수, `y` — 제수

**반환 값**

x를 y로 나눈 몫, 또는 NULL입니다.

**예시**

**0으로 나누기**

```sql title=Query
SELECT divideOrNull(25, 0)
```

```response title=Response
\N
```

## gcd \{#gcd\}

도입 버전: v1.1

두 값 a와 b의 최대공약수를 반환합니다.

0으로 나누거나, 최소 음수 값(최솟값인 음수)을 -1로 나누는 경우 예외가 발생합니다.

**구문**

```sql
gcd(x, y)
```

**인수**

* `x` — 첫 번째 정수, `y` — 두 번째 정수

**반환 값**

`x`와 `y`의 최대공약수입니다.

**예시**

**사용 예시**

```sql title=Query
SELECT gcd(12, 18)
```

```response title=Response
6
```

## ifNotFinite \{#ifNotFinite\}

도입된 버전: v20.3

부동소수점 값이 유한한지 확인합니다.

[삼항 연산자](/sql-reference/functions/conditional-functions#if)를 사용하여 비슷한 결과를 얻을 수 있습니다: `isFinite(x) ? x : y`.

**구문**

```sql
ifNotFinite(x,y)
```

**인수**

* `x` — 무한대 여부를 확인할 값. [`Float*`](/sql-reference/data-types/float)
* `y` — 대체 값. [`Float*`](/sql-reference/data-types/float)

**반환 값**

* `x`가 유한하면 `x`.
* `x`가 유한하지 않으면 `y`.

**예시**

**사용 예시**

```sql title=Query
SELECT 1/0 AS infimum, ifNotFinite(infimum,42)
```

```response title=Response
inf  42
```

## intDiv \{#intDiv\}

도입 버전: v1.1

값 `x`를 `y`로 정수 나눗셈합니다. 다시 말해,
몫을 가장 가까운 더 작은 정수로 내림하여 계산합니다.

결과의 비트 너비는 피제수(첫 번째 매개변수)와 동일합니다.

0으로 나누는 경우, 몫이 피제수의 범위를 벗어나는 경우, 또는 표현 가능한 최소 음수 값을 -1로 나누는 경우에는 예외가 발생합니다.

**문법**

```sql
intDiv(x, y)
```

**인수**

* `x` — 왼쪽 피연산자입니다. - `y` — 오른쪽 피연산자입니다.

**반환 값**

`x`와 `y`의 정수 나눗셈 결과입니다.

**예시**

**두 개의 부동소수점 수에 대한 정수 나눗셈**

```sql title=Query
SELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)
```

```response title=Response
┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐
│ 1000 │ Int64                                   │
└──────┴─────────────────────────────────────────┘
```

**몫이 피제수의 범위를 벗어납니다**

```sql title=Query
SELECT
intDiv(1, 0.001) AS res,
toTypeName(res)
```

```response title=Response
Received exception from server (version 23.2.1):
Code: 153. DB::Exception: Received from localhost:9000. DB::Exception:
Cannot perform integer division, because it will produce infinite or too
large number: While processing intDiv(1, 0.001) AS res, toTypeName(res).
(ILLEGAL_DIVISION)
```

## intDivOrNull \{#intDivOrNull\}

도입된 버전: v25.5

`intDiv`와 동일하지만, 0으로 나누거나 최소 음수를 -1로 나눌 때 NULL을 반환합니다.

**구문**

```sql
intDivOrNull(x, y)
```

**인자**

* `x` — 왼쪽 피연산자. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `y` — 오른쪽 피연산자. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

`x`와 `y`의 정수 나눗셈의 결과 또는 NULL입니다.

**예제**

**0으로 나누는 정수 나눗셈**

```sql title=Query
SELECT intDivOrNull(1, 0)
```

```response title=Response
\N
```

**최소 음수 값을 -1로 나누기**

```sql title=Query
SELECT intDivOrNull(-9223372036854775808, -1)
```

```response title=Response
\N
```

## intDivOrZero \{#intDivOrZero\}

도입 버전: v1.1

`intDiv`와 동일하지만 0으로 나누는 경우나, 최소 음수 값을 -1로 나누는 경우 0을 반환합니다.

**구문**

```sql
intDivOrZero(a, b)
```

**인수**

* `a` — 왼쪽 피연산자. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `b` — 오른쪽 피연산자. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

a와 b에 대한 정수 나눗셈 결과 또는 0입니다.

**예제**

**0으로 나누는 정수 나눗셈**

```sql title=Query
SELECT intDivOrZero(1, 0)
```

```response title=Response
0
```

**가장 작은 음수 값을 -1로 나누기**

```sql title=Query
SELECT intDivOrZero(0.05, -1)
```

```response title=Response
0
```

## isFinite \{#isFinite\}

도입 버전: v1.1

Float32 또는 Float64 타입 인자가 무한대가 아니고 `NaN`도 아니면 `1`을 반환하고,
그 외의 경우 `0`을 반환합니다.

**구문**

```sql
isFinite(x)
```

**인자**

* `x` — 유한한 값인지 확인할 숫자. [`Float*`](/sql-reference/data-types/float)

**반환 값**

`x`가 무한대가 아니고 `NaN`도 아니면 `1`, 그렇지 않으면 `0`.

**예시**

**숫자가 유한한지 확인**

```sql title=Query
SELECT isFinite(inf)
```

```response title=Response
0
```

## isInfinite \{#isInfinite\}

도입: v1.1

Float32 또는 Float64 형식의 인자가 무한대일 경우 `1`을 반환하고, 그렇지 않은 경우 `0`을 반환합니다.
`NaN`인 경우에도 `0`을 반환합니다.

**구문**

```sql
isInfinite(x)
```

**인수**

* `x` — 무한대인지 확인할 숫자. [`Float*`](/sql-reference/data-types/float)

**반환 값**

`x`가 무한대이면 `1`, 그렇지 않으면 `0`입니다 (`NaN` 포함).

**예시**

**숫자가 무한대인지 확인**

```sql title=Query
SELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))
```

```response title=Response
1 0 0
```

## isNaN \{#isNaN\}

도입 버전: v1.1

Float32 및 Float64 형 인자가 `NaN`이면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다.

**구문**

```sql
isNaN(x)
```

**인수**

* `x` — `NaN`인지 평가할 인수. [`Float*`](/sql-reference/data-types/float)

**반환 값**

`NaN`이면 `1`, 그렇지 않으면 `0`을 반환합니다.

**예제**

**사용 예제**

```sql title=Query
SELECT isNaN(NaN)
```

```response title=Response
1
```

## lcm \{#lcm\}

도입 버전: v1.1

두 값 `x`와 `y`의 최소 공배수를 반환합니다.

0으로 나누거나, 가장 작은 음수를 -1로 나누면 예외가 발생합니다.

**구문**

```sql
lcm(x, y)
```

**인수**

* `x` — 첫 번째 정수. [`(U)Int*`](/sql-reference/data-types/int-uint)
* `y` — 두 번째 정수. [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환값**

`x`와 `y`의 최소공배수를 반환합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT lcm(6, 8)
```

```response title=Response
24
```

## max2 \{#max2\}

도입된 버전: v21.11

두 개의 숫자형 값 `x`와 `y` 중 더 큰 값을 반환합니다.

**구문**

```sql
max2(x, y)
```

**인수**

* `x` — 첫 번째 값 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)
* `y` — 두 번째 값 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)

**반환 값**

`x`와 `y` 중 더 큰 값을 반환합니다. 반환 타입은 [`Float64`](/sql-reference/data-types/float)입니다.

**예제**

**사용 예제**

```sql title=Query
SELECT max2(-1, 2)
```

```response title=Response
2
```

## midpoint \{#midpoint\}

도입 버전: v25.11

제공된 인수들의 평균값을 계산하여 반환합니다.
수치형 및 시간 타입을 지원합니다.

**구문**

```sql
midpoint(x1[, x2, ...])
```

**인수**

* `x1[, x2, ...]` — 단일 값 또는 여러 값을 받아 평균을 계산합니다.

**반환 값**

제공된 인수의 평균값을 반환하며, 호환 가능한 가장 큰 타입으로 승격됩니다.

**예시**

**숫자형 타입**

```sql title=Query
SELECT midpoint(1, toUInt8(3), 0.5) AS result, toTypeName(result) AS type;
-- The type returned is a Float64 as the UInt8 must be promoted to 64 bit for the comparison.
```

```response title=Response
┌─result─┬─type────┐
│    1.5 │ Float64 │
└────────┴─────────┘
```

**Decimal 타입**

```sql title=Query
SELECT midpoint(toDecimal32(1.5, 2), toDecimal32(1, 1), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Date 타입**

```sql title=Query
SELECT midpoint(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**DateTime 데이터 타입**

```sql title=Query
SELECT midpoint(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Time64 타입**

```sql title=Query
SELECT midpoint(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```

## min2 \{#min2\}

도입된 버전: v21.11

두 개의 숫자 값 `x`와 `y` 중 더 작은 값을 반환합니다.

**구문**

```sql
min2(x, y)
```

**인수**

* `x` — 첫 번째 값 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)
* `y` — 두 번째 값 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)

**반환값**

반환되는 값은 `x`와 `y` 중 더 작은 값입니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT min2(-1, 2)
```

```response title=Response
-1
```

## minus \{#minus\}

도입 버전: v1.1

두 값 `a`와 `b`의 차이를 계산합니다. 결과는 항상 부호 있는 값입니다.
plus와 마찬가지로, 날짜 또는 날짜·시간 값에서 정수를 뺄 수 있습니다.
또한 두 날짜·시간 값 사이의 뺄셈도 지원하며, 이 경우 두 값 사이의 시간 차이를 반환합니다.

**구문**

```sql
minus(x, y)
```

**인수**

* `x` — 피감수(minuend). - `y` — 감수(subtrahend).

**반환 값**

x에서 y를 뺀 값

**예제**

**두 숫자 뺄셈**

```sql title=Query
SELECT minus(10, 5)
```

```response title=Response
5
```

**정수와 날짜의 뺄셈**

```sql title=Query
SELECT minus(toDate('2025-01-01'),5)
```

```response title=Response
2024-12-27
```

## modulo \{#modulo\}

도입된 버전: v1.1

두 값 a와 b에 대해, a를 b로 나눈 나머지를 계산합니다.

두 입력이 모두 정수이면 결과 타입은 정수입니다. 입력 중 하나가 부동 소수점 수이면 결과 타입은 Float64입니다.

나머지는 C++과 동일한 방식으로 계산됩니다. 음수에 대해서는 절사 나눗셈이 사용됩니다.

0으로 나누거나, 표현 가능한 최소 음수 값을 -1로 나눌 때 예외가 발생합니다.

**구문**

```sql
modulo(a, b)
```

**별칭(Aliases)**: `mod`

**인수(Arguments)**

* `a` — 피제수(나누어지는 수) — `b` — 제수(나누는 수, 모듈러스 값)

**반환 값(Returned value)**

a % b의 나머지입니다.

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT modulo(5, 2)
```

```response title=Response
1
```

## moduloOrNull \{#moduloOrNull\}

도입 버전: v25.5

`a`를 `b`로 나눈 나머지를 계산합니다. 함수 `modulo`와 유사하지만, 오른쪽 인자가 0이면 `moduloOrNull`은 NULL을 반환합니다.

**문법**

```sql
moduloOrNull(x, y)
```

**별칭(Aliases)**: `modOrNull`

**인수(Arguments)**

* `x` — 피제수. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
* `y` — 제수(나눗수). [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환값(Returned value)**

`x`를 `y`로 나눈 나머지를 반환하며, 제수가 0인 경우 null을 반환합니다.

**예시(Examples)**

**제수가 0인 경우의 moduloOrNull**

```sql title=Query
SELECT moduloOrNull(5, 0)
```

```response title=Response
\N
```

## moduloOrZero \{#moduloOrZero\}

도입된 버전: v20.3

나머지 연산 함수(modulo)와 유사하지만, 나누는 수(제수)가 0일 때 예외를 발생시키는 modulo 함수와 달리 0을 반환합니다.

**구문**

```sql
moduloOrZero(a, b)
```

**인수**

* `a` — 피제수. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
* `b` — 제수(modulus). [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)

**반환 값**

a % b의 나머지를 반환하며, 제수가 `0`이면 `0`을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT moduloOrZero(5, 0)
```

```response title=Response
0
```

## multiply \{#multiply\}

도입된 버전: v1.1

두 값 `x`와 `y`의 곱을 계산합니다.

**구문**

```sql
multiply(x, y)
```

**인수**

* `x` — 인자. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)
* `y` — 인자. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)

**반환 값**

x와 y의 곱을 반환합니다.

**예시**

**두 숫자 곱하기**

```sql title=Query
SELECT multiply(5,5)
```

```response title=Response
25
```

## multiplyDecimal \{#multiplyDecimal\}

도입: v22.12

Decimal 값 두 개에 대한 곱셈을 수행합니다. 결과값의 타입은 [Decimal256](/sql-reference/data-types/decimal)입니다.
결과 스케일은 `result_scale` 인자(범위가 `[0, 76]`인 상수 Integer)로 명시적으로 지정할 수 있습니다. 지정하지 않으면 결과 스케일은 전달된 인자들 중 최대 스케일이 됩니다.

:::note
이 함수들은 일반 `multiply`보다 상당히 느리게 동작합니다.
정밀도를 엄격하게 제어할 필요가 없거나 빠른 계산이 더 중요한 경우 [multiply](#multiply) 사용을 고려하십시오.
:::

**구문**

```sql
multiplyDecimal(a, b[, result_scale])
```

**인수**

* `a` — 첫 번째 값. [`Decimal`](/sql-reference/data-types/decimal)
* `b` — 두 번째 값. [`Decimal`](/sql-reference/data-types/decimal)
* `result_scale` — 결과 스케일(scale). [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

주어진 스케일로 수행한 곱셈 결과입니다. 타입: [`Decimal256`](/sql-reference/data-types/decimal)

**예시**

**사용 예시**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
25.2
```

**일반 곱셈과의 차이**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                               -26.8609633 │
└───────────────────────────────────────────────────────────┘
┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                                         -26.8609 │
└──────────────────────────────────────────────────────────────────┘
```

**십진수 오버플로**

```sql title=Query
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    multiplyDecimal(a, b);
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    a * b;
```

```response title=Response
┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐
│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │
└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘
Received exception from server (version 22.11.1):
Code: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow:
While processing toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)
```

## negate \{#negate\}

도입: v1.1

인수 `x`의 부호를 반전합니다. 결과는 항상 부호 있는 값입니다.

**구문**

```sql
negate(x)
```

**인수**

* `x` — 부호를 반전할 값입니다.

**반환 값**

x의 음수인 -x를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT negate(10)
```

```response title=Response
-10
```

## plus \{#plus\}

도입된 버전: v1.1

두 값 `x`와 `y`의 합을 계산합니다. 별칭: `x + y` (연산자).
정수와 날짜를 더하거나, 정수와 날짜-시간 값을 더할 수도 있습니다. 전자의
연산은 날짜의 일(day) 수를 증가시키고, 후자의 연산은 날짜-시간 값의 초(second) 수를 증가시킵니다.

**구문**

```sql
plus(x, y)
```

**인수**

* `x` — 왼쪽 피연산자입니다. - `y` — 오른쪽 피연산자입니다.

**반환 값**

x와 y의 합을 반환합니다.

**예시**

**두 숫자 더하기**

```sql title=Query
SELECT plus(5,5)
```

```response title=Response
10
```

**정수와 날짜의 덧셈**

```sql title=Query
SELECT plus(toDate('2025-01-01'),5)
```

```response title=Response
2025-01-06
```

## positiveModulo \{#positiveModulo\}

도입: v22.11

`x`를 `y`로 나눌 때의 나머지를 계산합니다. FUNCTION `modulo`와 비슷하지만
`positiveModulo`는 항상 음이 아닌 숫자를 반환합니다.

**구문**

```sql
positiveModulo(x, y)
```

**별칭**: `positive_modulo`, `pmod`

**인자**

* `x` — 피제수. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)
* `y` — 제수(모듈러스). [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)

**반환 값**

`x` 이하이면서 `y`로 나누어떨어지는 가장 가까운 정수와 `x`의 차이를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT positiveModulo(-1, 10)
```

```response title=Response
9
```

## positiveModuloOrNull \{#positiveModuloOrNull\}

도입 버전: v25.5

`a`를 `b`로 나눌 때의 나머지를 계산합니다. 함수 `positiveModulo`와 유사하지만, 오른쪽 인자가 0이면 `positiveModuloOrNull`은 NULL을 반환합니다.

**구문**

```sql
positiveModuloOrNull(x, y)
```

**별칭(Aliases)**: `positive_modulo_or_null`, `pmodOrNull`

**인수(Arguments)**

* `x` — 피제수(dividend). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float). - `y` — 제수(모듈로, divisor). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).

**반환 값(Returned value)**

`x`에서 `y`로 나누어떨어지는 값 가운데 `x`보다 크지 않은 가장 가까운 정수를 뺀 값을 반환하며, 제수가 0일 때는 `null`을 반환합니다.

**예시(Examples)**

**positiveModuloOrNull**

```sql title=Query
SELECT positiveModuloOrNull(5, 0)
```

```response title=Response
\N
```

{/*AUTOGENERATED_END*/ }

---
'description': '산술 함수에 대한 Documentation'
'sidebar_label': '산술'
'slug': '/sql-reference/functions/arithmetic-functions'
'title': '산술 함수'
'doc_type': 'reference'
---


# 산술 함수

## 개요 {#overview}

산술 함수는 `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, `Float32`, 또는 `Float64` 형식의 두 피연산자에 대해 작동합니다.

연산을 수행하기 전에, 두 피연산자는 결과 형식으로 캐스팅됩니다. 결과 형식은 다음과 같이 결정됩니다 (아래의 함수 문서에서 다르게 지정되지 않은 경우):
- 두 피연산자가 32비트 이하인 경우, 결과 형식의 크기는 더 큰 피연산자보다 다음으로 큰 형식의 크기가 됩니다 (정수 크기 승격). 예를 들어, `UInt8 + UInt16 = UInt32` 또는 `Float32 * Float32 = Float64`.
- 피연산자 중 하나라도 64비트 이상인 경우, 결과 형식의 크기는 두 피연산자 중 더 큰 피연산자의 크기와 같습니다. 예를 들어, `UInt32 + UInt128 = UInt128` 또는 `Float32 * Float64 = Float64`.
- 피연산자 중 하나가 부호가 있는 경우, 결과 형식도 부호가 있습니다. 그렇지 않으면 부호가 없습니다. 예를 들어, `UInt32 * Int32 = Int64`.

이러한 규칙은 결과 형식이 모든 가능한 결과를 표현할 수 있는 가장 작은 형식임을 보장합니다. 이는 값 범위 경계 근처에서 오버플로우의 위험을 초래하지만, 64비트의 최대 네이티브 정수 너비를 사용하여 계산이 빠르게 수행되도록 보장합니다. 이 동작은 또한 64비트 정수(BIGINT)를 가장 큰 정수 형식으로 제공하는 많은 다른 데이터베이스와의 호환성을 보장합니다.

예시:

```sql
SELECT toTypeName(0), toTypeName(0 + 0), toTypeName(0 + 0 + 0), toTypeName(0 + 0 + 0 + 0)
```

```text
┌─toTypeName(0)─┬─toTypeName(plus(0, 0))─┬─toTypeName(plus(plus(0, 0), 0))─┬─toTypeName(plus(plus(plus(0, 0), 0), 0))─┐
│ UInt8         │ UInt16                 │ UInt32                          │ UInt64                                   │
└───────────────┴────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┘
```

오버플로우는 C++와 동일한 방식으로 발생합니다.

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## abs {#abs}

도입된 버전: v1.1

`x`의 절대 값을 계산합니다. `x`가 부호 없는 형식인 경우에는 영향을 미치지 않습니다. `x`가 부호 있는 형식인 경우, 부호 없는 숫자를 반환합니다.

**구문**

```sql
abs(x)
```

**인수**

- `x` — 절대 값을 구할 값 

**반환 값**

`x`의 절대 값

**예시**

**사용 예시**

```sql title=Query
SELECT abs(-0.5)
```

```response title=Response
0.5
```



## avg2 {#avg2}

도입된 버전: v25.11


제공된 인수의 평균 값을 계산하고 반환합니다.
수치형 및 시간형을 지원합니다.
    

**구문**

```sql
avg2(x1, x2])
```

**인수**

- `x1, x2` — 평균을 구할 두 값. 

**반환 값**

제공된 인수의 평균 값을 가장 호환되는 형식으로 승격하여 반환합니다.

**예시**

**수치형**

```sql title=Query
SELECT avg2(toUInt8(3), 1.0) AS result, toTypeName(result) AS type;
-- The type returned is a Float64 as the UInt8 must be promoted to 64 bit for the comparison.
```

```response title=Response
┌─result─┬─type────┐
│      2 │ Float64 │
└────────┴─────────┘
```

**소수형**

```sql title=Query
SELECT avg2(toDecimal32(1, 2), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**날짜형**

```sql title=Query
SELECT avg2(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**날짜시간형**

```sql title=Query
SELECT avg2(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Time64형**

```sql title=Query
SELECT avg2(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```



## byteSwap {#byteSwap}

도입된 버전: v23.10


정수의 바이트를 반전시키며, 즉 [endianness](https://en.wikipedia.org/wiki/Endianness)를 변경합니다.

아래 예시는 다음과 같은 방식으로 작업할 수 있습니다:

1. 10진 정수를 해당하는 큰 엔디안 형식의 16진수로 변환합니다. 예: 3351772109 -> C7 C7 FB CD (4 바이트)
2. 바이트를 반전시킵니다. 예: C7 C7 FB CD -> CD FB C7 C7
3. 결과를 다시 큰 엔디안으로 정수로 변환합니다. 예: CD FB C7 C7 -> 3455829959
이 함수의 용도 중 하나는 IPv4를 반전시키는 것입니다:

```result
┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
│ 199.199.251.205                                       │
└───────────────────────────────────────────────────────┘
```
    

**구문**

```sql
byteSwap(x)
```

**인수**

- `x` — 정수 값. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

바이트가 반전된 `x`를 반환합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**8비트**

```sql title=Query
SELECT byteSwap(54)
```

```response title=Response
54
```

**16비트**

```sql title=Query
SELECT byteSwap(4135)
```

```response title=Response
10000
```

**32비트**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**64비트**

```sql title=Query
SELECT byteSwap(123294967295)
```

```response title=Response
18439412204227788800
```



## divide {#divide}

도입된 버전: v1.1


두 값 `a`와 `b`의 몫을 계산합니다. 결과 형식은 항상 [Float64](/sql-reference/data-types/float)입니다.
정수 나눗셈은 `intDiv` 함수에 의해 제공됩니다.

:::note
`0`으로 나누면 `inf`, `-inf`, 또는 `nan`을 반환합니다.
:::
    

**구문**

```sql
divide(x, y)
```

**인수**

- `x` — 피제수 - `y` — 제수 

**반환 값**

`x`와 `y`의 몫

**예시**

**두 숫자 나누기**

```sql title=Query
SELECT divide(25,5) AS quotient, toTypeName(quotient)
```

```response title=Response
5 Float64
```

**제로 나누기**

```sql title=Query
SELECT divide(25,0)
```

```response title=Response
inf
```



## divideDecimal {#divideDecimal}

도입된 버전: v22.12


두 소수에 대해 나눗셈을 수행합니다. 결과 값은 [Decimal256](/sql-reference/data-types/decimal) 형식이 됩니다.
결과 자리수는 `result_scale` 인수 (범위 `[0, 76]`의 상수 정수)로 명시적으로 지정할 수 있습니다. 지정하지 않으면, 결과 자리수는 주어진 인수의 최대 자리수가 됩니다.

:::note
이 함수들은 일반 `divide`보다 상당히 느리게 작동합니다.
정확한 정밀도가 정말 필요 없거나 빠른 계산이 필요한 경우 [divide](#divide)를 사용하는 것을 고려하십시오.
:::
    

**구문**

```sql
divideDecimal(x, y[, result_scale])
```

**인수**

- `x` — 첫 번째 값: [Decimal](/sql-reference/data-types/decimal).
- `y` — 두 번째 값: [Decimal](/sql-reference/data-types/decimal).
- `result_scale` — 결과의 스케일. 형식 [Int/UInt](/sql-reference/data-types/int-uint). 

**반환 값**

지정된 스케일로 나눗셈의 결과. [`Decimal256`](/sql-reference/data-types/decimal)

**예시**

**예시 1**

```sql title=Query
divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)
```

```response title=Response
┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐
│                                                -5.7142857142 │
└──────────────────────────────────────────────────────────────┘
```

**예시 2**

```sql title=Query
SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);
SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);
```

```response title=Response
┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐
│                                             -5.7 │
└──────────────────────────────────────────────────┘
┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐
│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
```



## divideOrNull {#divideOrNull}

도입된 버전: v25.5


`divide`와 같지만, 제수가 0일 때 NULL을 반환합니다.
    

**구문**

```sql
divideOrNull(x, y)
```

**인수**

- `x` — 피제수 - `y` — 제수 

**반환 값**

`x`와 `y`의 몫, 또는 NULL.

**예시**

**제로 나누기**

```sql title=Query
SELECT divideOrNull(25, 0)
```

```response title=Response
\N
```



## gcd {#gcd}

도입된 버전: v1.1


    두 값 `a`와 `b`의 최대 공약수를 반환합니다.

    제수가 0일 때나 최소 부정 숫자를 -1로 나눌 때 예외가 발생합니다.
    

**구문**

```sql
gcd(x, y)
```

**인수**

- `x` — 첫 번째 정수 - `y` — 두 번째 정수 

**반환 값**

`x`와 `y`의 최대 공약수.

**예시**

**사용 예시**

```sql title=Query
SELECT gcd(12, 18)
```

```response title=Response
6
```



## ifNotFinite {#ifNotFinite}

도입된 버전: v20.3


부동 소수점 값이 유한한지 확인합니다.

[삼항 연산자](/sql-reference/functions/conditional-functions#if)를 사용하여 유사한 결과를 얻을 수 있습니다: `isFinite(x) ? x : y`.
    

**구문**

```sql
ifNotFinite(x,y)
```

**인수**

- `x` — 무한인지를 확인할 값. [`Float*`](/sql-reference/data-types/float)
- `y` — 기본값. [`Float*`](/sql-reference/data-types/float)


**반환 값**

- `x`가 유한한 경우 `x`를 반환합니다.
- `x`가 유한하지 않은 경우 `y`를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT 1/0 AS infimum, ifNotFinite(infimum,42)
```

```response title=Response
inf  42
```



## intDiv {#intDiv}

도입된 버전: v1.1


두 값 `x`를 `y`로 나누는 정수 나눗셈을 수행합니다. 다시 말해 몫을 다음 가장 작은 정수로 내림해서 계산합니다.

결과는 피제수(첫 번째 매개변수)와 같은 너비를 가집니다.

제수가 0인 경우, 몫이 피제수의 범위에 맞지 않는 경우, 또는 최소 부정 숫자를 -1로 나눌 때 예외가 발생합니다.
    

**구문**

```sql
intDiv(x, y)
```

**인수**

- `x` — 왼쪽 피연산자. - `y` — 오른쪽 피연산자. 

**반환 값**

`x`와 `y`의 정수 나눗셈 결과

**예시**

**두 부동 소수점의 정수 나눗셈**

```sql title=Query
SELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)
```

```response title=Response
┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐
│ 1000 │ Int64                                   │
└──────┴─────────────────────────────────────────┘
```

**몫이 피제수의 범위에 맞지 않음**

```sql title=Query
SELECT
intDiv(1, 0.001) AS res,
toTypeName(res)
```

```response title=Response
Received exception from server (version 23.2.1):
Code: 153. DB::Exception: Received from localhost:9000. DB::Exception:
Cannot perform integer division, because it will produce infinite or too
large number: While processing intDiv(1, 0.001) AS res, toTypeName(res).
(ILLEGAL_DIVISION)
```



## intDivOrNull {#intDivOrNull}

도입된 버전: v25.5


`intDiv`와 같지만, 제수가 0일 때 또는 최소 부정 숫자를 -1로 나눌 때 NULL을 반환합니다.
    

**구문**

```sql
intDivOrNull(x, y)
```

**인수**

- `x` — 왼쪽 피연산자. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — 오른쪽 피연산자. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

`x`와 `y`의 정수 나눗셈 결과, 또는 NULL.

**예시**

**제로 나눗셈**

```sql title=Query
SELECT intDivOrNull(1, 0)
```

```response title=Response
\N
```

**최소 부정 숫자를 -1로 나누기**

```sql title=Query
SELECT intDivOrNull(-9223372036854775808, -1)
```

```response title=Response
\N
```



## intDivOrZero {#intDivOrZero}

도입된 버전: v1.1


`intDiv`와 같지만, 제수가 0일 때 또는 최소 부정 숫자를 -1로 나눌 때 0을 반환합니다.
    

**구문**

```sql
intDivOrZero(a, b)
```

**인수**

- `a` — 왼쪽 피연산자. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `b` — 오른쪽 피연산자. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

`a`와 `b`의 정수 나눗셈 결과, 또는 0.

**예시**

**제로 나눗셈**

```sql title=Query
SELECT intDivOrZero(1, 0)
```

```response title=Response
0
```

**최소 부정 숫자를 -1로 나누기**

```sql title=Query
SELECT intDivOrZero(0.05, -1)
```

```response title=Response
0
```



## isFinite {#isFinite}

도입된 버전: v1.1


Float32 또는 Float64 인수가 유한하지 않거나 `NaN`이 아닐 경우 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다.
    

**구문**

```sql
isFinite(x)
```

**인수**

- `x` — 유한성을 확인할 숫자. [`Float*`](/sql-reference/data-types/float)


**반환 값**

`x`가 유한하지 않거나 `NaN`이 아닌 경우 `1`, 그렇지 않으면 `0`.

**예시**

**숫자가 유한한지 테스트**

```sql title=Query
SELECT isFinite(inf)
```

```response title=Response
0
```



## isInfinite {#isInfinite}

도입된 버전: v1.1


    Float32 또는 Float64 인수가 무한하면 `1`을 반환하고, 그렇지 않으면 이 함수는 `0`을 반환합니다.
    `NaN`의 경우에는 `0`이 반환됩니다.
    

**구문**

```sql
isInfinite(x)
```

**인수**

- `x` — 무한성을 확인할 숫자. [`Float*`](/sql-reference/data-types/float)


**반환 값**

`x`가 무한하면 `1`, 그렇지 않으면 `0`(여기에는 `NaN` 포함).

**예시**

**숫자가 무한한지 테스트**

```sql title=Query
SELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))
```

```response title=Response
1 0 0
```



## isNaN {#isNaN}

도입된 버전: v1.1

Float32 및 Float64 인수가 `NaN`이면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다.

**구문**

```sql
isNaN(x)
```

**인수**

- `x` — `NaN`인지 평가할 인수. [`Float*`](/sql-reference/data-types/float)


**반환 값**

`NaN`이면 `1`, 그렇지 않으면 `0`

**예시**

**사용 예시**

```sql title=Query
SELECT isNaN(NaN)
```

```response title=Response
1
```



## lcm {#lcm}

도입된 버전: v1.1


두 값 `x`와 `y`의 최소 공배수를 반환합니다.

제수가 0일 때나 최소 부정 숫자를 -1로 나눌 때 예외가 발생합니다.
    

**구문**

```sql
lcm(x, y)
```

**인수**

- `x` — 첫 번째 정수. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — 두 번째 정수. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

`x`와 `y`의 최소 공배수를 반환합니다. [`(U)Int*`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT lcm(6, 8)
```

```response title=Response
24
```



## max2 {#max2}

도입된 버전: v21.11


    두 수치 값 `x`와 `y` 중 더 큰 값을 반환합니다.
    

**구문**

```sql
max2(x, y)
```

**인수**

- `x` — 첫 번째 값 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 두 번째 값 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)


**반환 값**

`x`와 `y`의 더 큰 값을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT max2(-1, 2)
```

```response title=Response
2
```



## midpoint {#midpoint}

도입된 버전: v25.11


제공된 인수의 평균 값을 계산하고 반환합니다.
수치형 및 시간형을 지원합니다.
    

**구문**

```sql
midpoint(x1[, x2, ...])
```

**인수**

- `x1[, x2, ...]` — 평균을 구할 단일 값 또는 여러 값. 

**반환 값**

제공된 인수의 평균 값을 가장 호환되는 형식으로 승격하여 반환합니다.

**예시**

**수치형**

```sql title=Query
SELECT midpoint(1, toUInt8(3), 0.5) AS result, toTypeName(result) AS type;
-- The type returned is a Float64 as the UInt8 must be promoted to 64 bit for the comparison.
```

```response title=Response
┌─result─┬─type────┐
│    1.5 │ Float64 │
└────────┴─────────┘
```

**소수형**

```sql title=Query
SELECT midpoint(toDecimal32(1.5, 2), toDecimal32(1, 1), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**날짜형**

```sql title=Query
SELECT midpoint(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**날짜시간형**

```sql title=Query
SELECT midpoint(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Time64형**

```sql title=Query
SELECT midpoint(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```



## min2 {#min2}

도입된 버전: v21.11


    두 수치 값 `x`와 `y` 중 더 작은 값을 반환합니다.
    

**구문**

```sql
min2(x, y)
```

**인수**

- `x` — 첫 번째 값 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 두 번째 값 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)


**반환 값**

`x`와 `y`의 더 작은 값을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT min2(-1, 2)
```

```response title=Response
-1
```



## minus {#minus}

도입된 버전: v1.1


두 값 `a`와 `b`의 차이를 계산합니다. 결과는 항상 부호가 있습니다.
더하기와 유사하게, 날짜 또는 날짜와 시간을 정수에서 뺄 수 있습니다.
추가로 날짜와 시간 간의 뺄셈도 지원되며, 이 경우 두 날짜의 시간 차이가 계산됩니다.
    

**구문**

```sql
minus(x, y)
```

**인수**

- `x` — 피감수. - `y` — 감수. 

**반환 값**

`x`에서 `y`를 뺀 값을 반환합니다.

**예시**

**두 숫자 빼기**

```sql title=Query
SELECT minus(10, 5)
```

```response title=Response
5
```

**정수와 날짜 빼기**

```sql title=Query
SELECT minus(toDate('2025-01-01'),5)
```

```response title=Response
2024-12-27
```



## modulo {#modulo}

도입된 버전: v1.1


    두 값 `a`를 `b`로 나눈 나머지를 계산합니다.

    두 입력 모두 정수인 경우 결과 형식은 정수입니다. 입력 중 하나라도 부동 소수점 수인 경우 결과 형식은 Float64입니다.

    나머지는 C++ 방식으로 계산됩니다. 음수에 대해서는 잘린 나눗셈이 사용됩니다.

    제수가 0일 때나 최소 부정 숫자를 -1로 나눌 때 예외가 발생합니다.
    

**구문**

```sql
modulo(a, b)
```

**별칭**: `mod`

**인수**

- `a` — 피제수 - `b` — 제수 (모듈러스) 

**반환 값**

`a % b`의 나머지를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT modulo(5, 2)
```

```response title=Response
1
```



## moduloOrNull {#moduloOrNull}

도입된 버전: v25.5


`a`를 `b`로 나눈 나머지를 계산합니다. `modulo` 함수와 유사하지만 `moduloOrNull`은 오른쪽 인수가 0일 때 NULL을 반환합니다.
    

**구문**

```sql
moduloOrNull(x, y)
```

**별칭**: `modOrNull`

**인수**

- `x` — 피제수. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
- `y` — 제수 (모듈러스). [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)


**반환 값**

`x`를 `y`로 나눈 나머지를 반환하거나, 제수가 0일 때는 null을 반환합니다.

**예시**

**제로로 나눈 나머지**

```sql title=Query
SELECT moduloOrNull(5, 0)
```

```response title=Response
\N
```



## moduloOrZero {#moduloOrZero}

도입된 버전: v20.3


`modulo`와 유사하지만 제수가 0일 때는 예외가 발생하는 것이 아니라 제수가 0일 때 0을 반환합니다.
    

**구문**

```sql
moduloOrZero(a, b)
```

**인수**

- `a` — 피제수. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)
- `b` — 제수 (모듈러스). [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float)


**반환 값**

`a % b`의 나머지를 반환하거나 `0`을 반환합니다 제수가 `0`인 경우.

**예시**

**사용 예시**

```sql title=Query
SELECT moduloOrZero(5, 0)
```

```response title=Response
0
```



## multiply {#multiply}

도입된 버전: v1.1

두 값 `x`와 `y`의 곱을 계산합니다.

**구문**

```sql
multiply(x, y)
```

**인수**

- `x` — 인수. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 인수. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)


**반환 값**

`x`와 `y`의 곱을 반환합니다.

**예시**

**두 숫자 곱하기**

```sql title=Query
SELECT multiply(5,5)
```

```response title=Response
25
```



## multiplyDecimal {#multiplyDecimal}

도입된 버전: v22.12


두 소수에 대해 곱셈을 수행합니다. 결과 값은 [Decimal256](/sql-reference/data-types/decimal) 형식이 됩니다.
결과 자리수는 `result_scale` 인수 (범위 `[0, 76]`의 상수 정수)로 명시적으로 지정할 수 있습니다. 지정하지 않으면, 결과 자리수는 주어진 인수의 최대 자리수가 됩니다.

:::note
이 함수들은 일반 `multiply`보다 상당히 느리게 작동합니다.
정확한 정밀도가 정말 필요 없거나 빠른 계산이 필요한 경우 [multiply](#multiply)를 사용하는 것을 고려하십시오.
:::
    

**구문**

```sql
multiplyDecimal(a, b[, result_scale])
```

**인수**

- `a` — 첫 번째 값. [`Decimal`](/sql-reference/data-types/decimal)
- `b` — 두 번째 값. [`Decimal`](/sql-reference/data-types/decimal)
- `result_scale` — 결과의 스케일. [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환 값**

지정된 스케일로 곱셈의 결과. 형식: [`Decimal256`](/sql-reference/data-types/decimal)

**예시**

**사용 예시**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
25.2
```

**일반 곱셈과의 차이**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                               -26.8609633 │
└───────────────────────────────────────────────────────────┘
┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                                         -26.8609 │
└──────────────────────────────────────────────────────────────────┘
```

**소수 오버플로우**

```sql title=Query
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    multiplyDecimal(a, b);
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    a * b;
```

```response title=Response
┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐
│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │
└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘
Received exception from server (version 22.11.1):
Code: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow:
While processing toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)
```



## negate {#negate}

도입된 버전: v1.1

인수 `x`를 부정합니다. 결과는 항상 부호가 있습니다.

**구문**

```sql
negate(x)
```

**인수**

- `x` — 부정할 값. 

**반환 값**

`x`에서 -x를 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT negate(10)
```

```response title=Response
-10
```



## plus {#plus}

도입된 버전: v1.1


두 값 `x`와 `y`의 합을 계산합니다. 별칭: `x + y` (연산자).
정수와 날짜 또는 날짜와 시간을 더할 수 있습니다. 전자는 날짜의 일을 증가시키고, 후자는 날짜와 시간에서 초를 증가시킵니다.
    

**구문**

```sql
plus(x, y)
```

**인수**

- `x` — 왼쪽 피연산자. - `y` — 오른쪽 피연산자. 

**반환 값**

`x`와 `y`의 합을 반환합니다.

**예시**

**두 숫자 더하기**

```sql title=Query
SELECT plus(5,5)
```

```response title=Response
10
```

**정수와 날짜 더하기**

```sql title=Query
SELECT plus(toDate('2025-01-01'),5)
```

```response title=Response
2025-01-06
```



## positiveModulo {#positiveModulo}

도입된 버전: v22.11


`x`를 `y`로 나누었을 때 나머지를 계산합니다. `modulo` 함수와 유사하지만 `positiveModulo`는 항상 음수가 아닌 숫자를 반환합니다.
    

**구문**

```sql
positiveModulo(x, y)
```

**별칭**: `positive_modulo`, `pmod`

**인수**

- `x` — 피제수. [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)
- `y` — 제수 (모듈러스). [`(U)Int*`](/sql-reference/data-types/int-uint) 또는 [`Float*`](/sql-reference/data-types/float) 또는 [`Decimal`](/sql-reference/data-types/decimal)


**반환 값**

`x`에서 `y`로 나누어 떨어지는 가장 가까운 정수보다 작은 값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT positiveModulo(-1, 10)
```

```response title=Response
9
```



## positiveModuloOrNull {#positiveModuloOrNull}

도입된 버전: v25.5


`a`를 `b`로 나누었을 때 나머지를 계산합니다. `positiveModulo` 함수와 유사하지만 `positiveModuloOrNull`은 오른쪽 인수가 0일 때 NULL을 반환합니다.
    

**구문**

```sql
positiveModuloOrNull(x, y)
```

**별칭**: `positive_modulo_or_null`, `pmodOrNull`

**인수**

- `x` — 피제수. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).
- `y` — 제수 (모듈러스). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float). 

**반환 값**

`x`를 `y`로 나누어 떨어지는 가장 가까운 정수보다 작은 값을 , 제수가 0일 경우 `null`을 반환합니다.

**예시**

**positiveModuloOrNull**

```sql title=Query
SELECT positiveModuloOrNull(5, 0)
```

```response title=Response
\N
```



<!--AUTOGENERATED_END-->

---
description: 'Bitmap 함수 문서'
sidebar_label: 'Bitmap'
slug: /sql-reference/functions/bitmap-functions
title: 'Bitmap 함수'
doc_type: 'reference'
---

# 비트맵 함수 \{#bitmap-functions\}

비트맵은 두 가지 방식으로 생성할 수 있습니다. 첫 번째 방식은 집계 함수 `groupBitmap`의 `-State` 변형을 사용해 비트맵을 생성하는 것이고, 다른 방식은 Array 객체로부터 비트맵을 생성하는 것입니다.

{/* 
  아래 태그 안의 내용은 문서 프레임워크를 빌드할 때 
  system.functions에서 생성된 문서로 대체됩니다. 태그를 수정하거나 제거하지 마십시오.
  자세한 내용은 https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md 를 참조하십시오.
  */ }

{/*AUTOGENERATED_START*/ }

## bitmapAnd \{#bitmapAnd\}

도입 버전: v20.1

두 비트맵의 논리곱(AND)을 계산합니다.

**구문**

```sql
bitmapAnd(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환값**

두 입력 비트맵 모두에 존재하는 비트를 포함하는 비트맵을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예제**

```sql title=Query
SELECT bitmapToArray(bitmapAnd(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─┐
│ [3] │
└─────┘
```

## bitmapAndCardinality \{#bitmapAndCardinality\}

도입된 버전: v20.1

두 비트맵에 대한 논리곱(AND)의 카디널리티(cardinality)를 반환합니다.

**구문**

```sql
bitmapAndCardinality(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

두 비트맵의 교집합에 포함된 1로 설정된 비트 개수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapAndCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```

## bitmapAndnot \{#bitmapAndnot\}

도입된 버전: v20.1

두 비트맵 A, B에 대해 집합 차이 A AND-NOT B를 계산합니다.

**구문**

```sql
bitmapAndnot(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

첫 번째 비트맵에는 존재하지만 두 번째 비트맵에는 존재하지 않는 설정된 비트를 포함하는 비트맵을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapToArray(bitmapAndnot(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res────┐
│ [1, 2] │
└────────┘
```

## bitmapAndnotCardinality \{#bitmapAndnotCardinality\}

도입 버전: v20.1

두 비트맵에 대해 AND-NOT 연산을 수행한 결과의 카디널리티를 반환합니다.

**구문**

```sql
bitmapAndnotCardinality(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

`bitmap1 AND-NOT bitmap2` 연산 결과에서 1로 설정된 비트 수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapAndnotCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```

## bitmapBuild \{#bitmapBuild\}

도입: v20.1

비부호 정수 배열에서 비트맵을 생성합니다. 함수 [`bitmapToArray`](/sql-reference/functions/bitmap-functions#bitmapToArray)와 반대 동작을 수행합니다.

**구문**

```sql
bitmapBuild(array)
```

**인수**

* `array` — 부호 없는 정수형 배열입니다. [`Array(UInt*)`](/sql-reference/data-types/array)

**반환 값**

제공된 배열로부터 비트맵을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예제**

```sql title=Query
SELECT bitmapBuild([1, 2, 3, 4, 5]) AS res, toTypeName(res);
```

```response title=Response
┌─res─┬─toTypeName(bitmapBuild([1, 2, 3, 4, 5]))─────┐
│     │ AggregateFunction(groupBitmap, UInt8)        │
└─────┴──────────────────────────────────────────────┘
```

## bitmapCardinality \{#bitmapCardinality\}

도입 버전: v20.1

비트맵에서 설정된 비트 수(카디널리티)를 반환합니다.

**구문**

```sql
bitmapCardinality(bitmap)
```

**인수**

* `bitmap` — Bitmap 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

bitmap에서 설정된 비트의 개수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapCardinality(bitmapBuild([1, 3, 3, 5, 7, 7])) AS res
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```

## bitmapContains \{#bitmapContains\}

도입된 버전: v20.1

비트맵에 특정 요소가 포함되어 있는지 검사합니다.

**구문**

```sql
bitmapContains(bitmap, value)
```

**인수**

* `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `value` — 확인할 값. [(U)Int8/16/32/64](/sql-reference/data-types/int-uint/)

**반환값**

비트맵에 지정된 값이 포함되어 있으면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예제**

```sql title=Query
SELECT bitmapContains(bitmapBuild([1, 2, 3]), 2) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```

## bitmapHasAll \{#bitmapHasAll\}

도입 버전: v20.1

첫 번째 비트맵에 두 번째 비트맵의 모든 설정 비트가 포함되어 있는지 확인합니다.

**구문**

```sql
bitmapHasAll(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

두 번째 비트맵에서 설정된 모든 비트가 첫 번째 비트맵에도 모두 존재하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapHasAll(bitmapBuild([1, 2, 3]), bitmapBuild([2, 3])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```

## bitmapHasAny \{#bitmapHasAny\}

도입 버전: v20.1

첫 번째 비트맵이 두 번째 비트맵에서 1로 설정된 비트(켜진 비트) 중 하나라도 포함하는지 확인합니다.

**구문**

```sql
bitmapHasAny(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환값**

두 번째 비트맵의 비트가 하나라도 첫 번째 비트맵에 존재하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapHasAny(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```

## bitmapMax \{#bitmapMax\}

도입된 버전: v20.1

비트맵에서 가장 큰 비트가 설정된 위치를 반환하며, 비트맵이 비어 있으면 `0`을 반환합니다.

**구문**

```sql
bitmapMax(bitmap)
```

**인수**

* `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

비트맵에서 가장 높은 위치의 설정된 비트의 위치를 반환하며, 없으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapMax(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```

## bitmapMin \{#bitmapMin\}

도입 버전: v20.1

비트맵에서 설정된 비트 중 가장 작은 위치의 비트 인덱스를 반환합니다. 모든 비트가 설정되지(unset) 않은 상태이면 `UINT32_MAX`를 반환합니다 (`2^64`개보다 많은 비트를 포함하는 비트맵인 경우에는 `UINT64_MAX`를 반환합니다).

**구문**

```sql
bitmapMin(bitmap)
```

**인수**

* `bitmap` — 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

비트맵에서 값이 설정된(1인) 비트 중 가장 작은 비트의 위치를 반환하며, 그러한 비트가 없으면 `UINT32_MAX`/`UINT64_MAX` [`UInt64`](/sql-reference/data-types/int-uint)을(를) 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapMin(bitmapBuild([3, 5, 2, 6])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```

## bitmapOr \{#bitmapOr\}

도입 버전: v20.1

두 비트맵에 대한 논리합(OR)을 계산합니다.

**구문**

```sql
bitmapOr(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

두 입력 비트맵 중 어느 한쪽에 존재하는 1로 설정된 비트들을 포함하는 비트맵을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapToArray(bitmapOr(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```

## bitmapOrCardinality \{#bitmapOrCardinality\}

도입된 버전: v20.1

두 비트맵의 논리합(OR)에 대한 기수(cardinality)를 반환합니다.

**구문**

```sql
bitmapOrCardinality(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

두 비트맵의 합집합에서 설정된 비트 수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapOrCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```

## bitmapSubsetInRange \{#bitmapSubsetInRange\}

도입 버전: v20.1

지정된 범위 [start, end) 내에서 1로 설정된 비트만 포함하는 비트맵 부분집합을 반환합니다. 인덱스는 1부터 시작합니다.

**구문**

```sql
bitmapSubsetInRange(bitmap, start, end)
```

**인자**

* `bitmap` — 부분 집합을 추출할 비트맵입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `start` — 범위의 시작(포함)입니다. [`UInt*`](/sql-reference/data-types/int-uint) - `end` — 범위의 끝(제외)입니다. [`UInt*`](/sql-reference/data-types/int-uint)

**반환 값**

지정된 범위에서 비트가 설정된 부분만 포함하는 비트맵을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild([1, 2, 3, 4, 5]), 2, 5)) AS res;
```

```response title=Response
┌─res───────┐
│ [2, 3, 4] │
└───────────┘
```

## bitmapSubsetLimit \{#bitmapSubsetLimit\}

도입된 버전: v20.1

비트맵에서 위치 `range_start`부터 시작하여 최대 `cardinality_limit`개의 set된 비트를 포함하는 부분 비트맵을 반환합니다. 인덱싱은 1부터 시작합니다.

**구문**

```sql
bitmapSubsetLimit(bitmap, range_start, cardinality_limit)
```

**인자**

* `bitmap` — Bitmap 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `range_start` — 구간의 시작 값(포함). [`UInt32`](/sql-reference/data-types/int-uint) - `cardinality_limit` — 부분집합의 최대 카디널리티(cardinality). [`UInt32`](/sql-reference/data-types/int-uint)

**반환 값**

`range_start`부터 시작하여 최대 `cardinality_limit`개의 설정된 비트를 포함하는 비트맵을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild([1, 5, 3, 2, 8]), 3, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [5, 3] │
└────────┘
```

## bitmapToArray \{#bitmapToArray\}

도입 버전: v20.1

비트맵을 부호 없는 정수 배열로 변환합니다. 함수 [`bitmapBuild`](/sql-reference/functions/bitmap-functions#bitmapBuild)의 역연산입니다.

**구문**

```sql
bitmapToArray(bitmap)
```

**인수**

* `bitmap` — 변환할 비트맵입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환값**

비트맵에 포함된 부호 없는 정수(UInt)로 구성된 배열을 반환합니다. [`Array(UInt*)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapToArray(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```

## bitmapTransform \{#bitmapTransform\}

도입 버전: v20.1

`from_array`의 특정 비트 값을 `to_array`의 대응 값으로 치환하여 비트맵에서 최대 N개의 비트를 변경합니다.

**구문**

```sql
bitmapTransform(bitmap, from_array, to_array)
```

**인자**

* `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `from_array` — 대체할 기존 설정 비트 값들의 배열. [`Array(T)`](/sql-reference/data-types/array). - `to_array` — 새로 설정할 비트 값들의 배열. [`Array(T)`](/sql-reference/data-types/array).

**반환 값**

지정된 매핑에 따라 요소가 변환된 비트맵을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapToArray(bitmapTransform(bitmapBuild([1, 2, 3, 4, 5]), [2, 4], [20, 40])) AS res;
```

```response title=Response
┌─res───────────────┐
│ [1, 3, 5, 20, 40] │
└───────────────────┘
```

## bitmapXor \{#bitmapXor\}

도입 버전: v20.1

두 비트맵 간의 대칭 차집합(XOR)을 계산합니다.

**구문**

```sql
bitmapXor(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

두 입력 비트맵 중 하나에만 존재하고 둘 다에는 존재하지 않는 비트가 설정되어 있는 비트맵을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예제**

```sql title=Query
SELECT bitmapToArray(bitmapXor(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res──────────┐
│ [1, 2, 4, 5] │
└──────────────┘
```

## bitmapXorCardinality \{#bitmapXorCardinality\}

도입 버전: v20.1

두 비트맵에 대한 XOR(대칭 차집합)의 카디널리티(원소 개수)를 반환합니다.

**구문**

```sql
bitmapXorCardinality(bitmap1, bitmap2)
```

**인수**

* `bitmap1` — 첫 번째 bitmap 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 bitmap 객체입니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).

**반환 값**

두 bitmap의 대칭 차집합에 있는 1로 설정된 비트 개수를 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapXorCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```

## subBitmap \{#subBitmap\}

도입된 버전: v21.9

비트맵에서 `offset` 위치부터 시작하는 부분 비트맵을 반환합니다. 반환되는 비트맵의 최대 카디널리티는 `cardinality_limit`입니다.

**구문**

```sql
subBitmap(bitmap, offset, cardinality_limit)
```

**인수**

* `bitmap` — Bitmap 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `offset` — 처음부터(0 기준) 건너뛸 set 비트의 개수. [`UInt32`](/sql-reference/data-types/int-uint) - `cardinality_limit` — 부분집합에 포함할 set 비트의 최대 개수. [`UInt32`](/sql-reference/data-types/int-uint)

**반환 값**

`offset` 개수만큼 set 비트를 오름차순으로 건너뛴 뒤, 최대 `limit`개의 set 비트를 포함하는 bitmap을 반환합니다. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예시**

**사용 예시**

```sql title=Query
SELECT bitmapToArray(subBitmap(bitmapBuild([1, 2, 3, 4, 5]), 2, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [3, 4] │
└────────┘
```

{/*AUTOGENERATED_END*/ }

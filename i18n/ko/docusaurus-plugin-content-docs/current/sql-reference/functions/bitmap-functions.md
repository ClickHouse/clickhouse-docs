---
'description': 'Bitmap Functions에 대한 문서'
'sidebar_label': 'Bitmap'
'slug': '/sql-reference/functions/bitmap-functions'
'title': '비트맵 함수'
'doc_type': 'reference'
---


# 비트맵 함수

비트맵은 두 가지 방법으로 구성될 수 있습니다. 첫 번째 방법은 집계 함수 groupBitmap과 함께 `-State`를 사용하는 것이고, 두 번째 방법은 배열 객체에서 비트맵을 구성하는 것입니다.

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## bitmapAnd {#bitmapAnd}

도입: v20.1

두 비트맵의 논리적 곱(AND)을 계산합니다.

**구문**

```sql
bitmapAnd(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

두 입력 비트맵 모두에 존재하는 비트를 포함하는 비트맵을 반환합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(bitmapAnd(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─┐
│ [3] │
└─────┘
```



## bitmapAndCardinality {#bitmapAndCardinality}

도입: v20.1

두 비트맵의 논리적 곱(AND)의 기수를 반환합니다.

**구문**

```sql
bitmapAndCardinality(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

두 비트맵의 교차점에서 설정된 비트의 수를 반환합니다 [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapAndCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```



## bitmapAndnot {#bitmapAndnot}

도입: v20.1

두 비트맵의 차집합 A AND-NOT B를 계산합니다.

**구문**

```sql
bitmapAndnot(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

첫 번째 비트맵에는 존재하나 두 번째 비트맵에는 존재하지 않는 비트를 포함하는 비트맵을 반환합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(bitmapAndnot(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res────┐
│ [1, 2] │
└────────┘
```



## bitmapAndnotCardinality {#bitmapAndnotCardinality}

도입: v20.1

두 비트맵의 AND-NOT 연산의 기수를 반환합니다.

**구문**

```sql
bitmapAndnotCardinality(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

`bitmap1 AND-NOT bitmap2`의 결과에서 설정된 비트의 수를 반환합니다 [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapAndnotCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```



## bitmapBuild {#bitmapBuild}

도입: v20.1

부호 없는 정수 배열에서 비트맵을 생성합니다. 이는 [`bitmapToArray`](/sql-reference/functions/bitmap-functions#bitmapToArray) 함수의 반대입니다.

**구문**

```sql
bitmapBuild(array)
```

**인자**

- `array` — 부호 없는 정수 배열. [`Array(UInt*)`](/sql-reference/data-types/array)


**반환 값**

제공된 배열에서 비트맵을 반환합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapBuild([1, 2, 3, 4, 5]) AS res, toTypeName(res);
```

```response title=Response
┌─res─┬─toTypeName(bitmapBuild([1, 2, 3, 4, 5]))─────┐
│     │ AggregateFunction(groupBitmap, UInt8)        │
└─────┴──────────────────────────────────────────────┘
```



## bitmapCardinality {#bitmapCardinality}

도입: v20.1

비트맵에서 설정된 비트의 수(기수)를 반환합니다.

**구문**

```sql
bitmapCardinality(bitmap)
```

**인자**

- `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

비트맵에서 설정된 비트의 수를 반환합니다 [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapCardinality(bitmapBuild([1, 3, 3, 5, 7, 7])) AS res
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```



## bitmapContains {#bitmapContains}

도입: v20.1

비트맵이 특정 요소를 포함하는지 확인합니다.

**구문**

```sql
bitmapContains(bitmap, value)
```

**인자**

- `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `value` — 확인할 요소. [(U)Int8/16/32/64](/sql-reference/data-types/int-uint/) 

**반환 값**

비트맵이 지정된 값을 포함하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다 [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapContains(bitmapBuild([1, 2, 3]), 2) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapHasAll {#bitmapHasAll}

도입: v20.1

첫 번째 비트맵이 두 번째 비트맵의 모든 설정 비트를 포함하는지 확인합니다.

**구문**

```sql
bitmapHasAll(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

두 번째 비트맵의 모든 설정 비트가 첫 번째 비트맵에 존재하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다 [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapHasAll(bitmapBuild([1, 2, 3]), bitmapBuild([2, 3])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapHasAny {#bitmapHasAny}

도입: v20.1

첫 번째 비트맵이 두 번째 비트맵의 설정 비트를 포함하는지 확인합니다.

**구문**

```sql
bitmapHasAny(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

두 번째 비트맵의 어떤 비트가 첫 번째 비트맵에 존재하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다 [`UInt8`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapHasAny(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│  1  │
└─────┘
```



## bitmapMax {#bitmapMax}

도입: v20.1

비트맵에서 설정된 가장 큰 비트의 위치를 반환하며, 비트맵이 비어 있으면 `0`을 반환합니다.

**구문**

```sql
bitmapMax(bitmap)
```

**인자**

- `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

비트맵에서 설정된 가장 큰 비트의 위치를 반환하며, 그렇지 않으면 `0`을 반환합니다 [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapMax(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```



## bitmapMin {#bitmapMin}

도입: v20.1

비트맵에서 설정된 가장 작은 비트의 위치를 반환합니다. 모든 비트가 해제된 경우, 또는 `UINT32_MAX` (`2^64` 비트 이상을 포함하는 경우 `UINT64_MAX`)입니다.

**구문**

```sql
bitmapMin(bitmap)
```

**인자**

- `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

비트맵에서 설정된 가장 작은 비트의 위치를 반환하며, 또는 `UINT32_MAX`/`UINT64_MAX`를 반환합니다 [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapMin(bitmapBuild([3, 5, 2, 6])) AS res;
```

```response title=Response
┌─res─┐
│   2 │
└─────┘
```



## bitmapOr {#bitmapOr}

도입: v20.1

두 비트맵의 논리적 합(OR)을 계산합니다.

**구문**

```sql
bitmapOr(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

어느 입력 비트맵에나 존재하는 설정 비트를 포함하는 비트맵을 반환합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(bitmapOr(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```



## bitmapOrCardinality {#bitmapOrCardinality}

도입: v20.1

두 비트맵의 논리적 합(OR)의 기수를 반환합니다.

**구문**

```sql
bitmapOrCardinality(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

두 비트맵의 합집합에서 설정된 비트의 수를 반환합니다 [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapOrCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   5 │
└─────┘
```



## bitmapSubsetInRange {#bitmapSubsetInRange}

도입: v20.1

비트맵의 하위 집합을 반환하며, 지정된 범위 [start, end) 내의 설정된 비트만 포함합니다. 1 기반 인덱싱을 사용합니다.

**구문**

```sql
bitmapSubsetInRange(bitmap, start, end)
```

**인자**

- `bitmap` — 하위 집합을 추출할 비트맵. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `start` — 범위의 시작 (포함). [`UInt*`](/sql-reference/data-types/int-uint) - `end` — 범위의 끝 (제외). [`UInt*`](/sql-reference/data-types/int-uint) 

**반환 값**

지정된 범위 내의 설정된 비트만 포함하는 비트맵을 반환합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild([1, 2, 3, 4, 5]), 2, 5)) AS res;
```

```response title=Response
┌─res───────┐
│ [2, 3, 4] │
└───────────┘
```



## bitmapSubsetLimit {#bitmapSubsetLimit}

도입: v20.1

`range_start` 위치부터 최대 `cardinality_limit` 설정 비트를 포함하는 비트맵의 하위 집합을 반환합니다. 1 기반 인덱싱을 사용합니다.

**구문**

```sql
bitmapSubsetLimit(bitmap, range_start, cardinality_limit)
```

**인자**

- `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `range_start` — 범위의 시작 (포함). [`UInt32`](/sql-reference/data-types/int-uint) - `cardinality_limit` — 하위 집합의 최대 기수. [`UInt32`](/sql-reference/data-types/int-uint) 

**반환 값**

최대 `cardinality_limit` 설정 비트를 포함하는 비트맵을 반환하며, `range_start`부터 시작합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild([1, 5, 3, 2, 8]), 3, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [5, 3] │
└────────┘
```



## bitmapToArray {#bitmapToArray}

도입: v20.1

비트맵을 부호 없는 정수 배열로 변환합니다. 이는 [`bitmapBuild`](/sql-reference/functions/bitmap-functions#bitmapBuild) 함수의 반대입니다.

**구문**

```sql
bitmapToArray(bitmap)
```

**인자**

- `bitmap` — 변환할 비트맵. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

비트맵에 포함된 부호 없는 정수 배열을 반환합니다 [`Array(UInt*)`](/sql-reference/data-types/array)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(bitmapBuild([1, 2, 3, 4, 5])) AS res;
```

```response title=Response
┌─res─────────────┐
│ [1, 2, 3, 4, 5] │
└─────────────────┘
```



## bitmapTransform {#bitmapTransform}

도입: v20.1


비트맵에서 최대 N 비트를 변경하여 `from_array`의 특정 비트 값을 `to_array`의 해당 값과 스왑합니다.
    

**구문**

```sql
bitmapTransform(bitmap, from_array, to_array)
```

**인자**

- `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `from_array` — 교체할 원래의 설정 비트 배열. [`Array(T)`](/sql-reference/data-types/array). - `to_array` — 교체할 새로운 설정 비트 배열. [`Array(T)`](/sql-reference/data-types/array). 

**반환 값**

주어진 매핑에 따라 변환된 요소가 포함된 비트맵을 반환합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(bitmapTransform(bitmapBuild([1, 2, 3, 4, 5]), [2, 4], [20, 40])) AS res;
```

```response title=Response
┌─res───────────────┐
│ [1, 3, 5, 20, 40] │
└───────────────────┘
```



## bitmapXor {#bitmapXor}

도입: v20.1

두 비트맵의 대칭 차집합(XOR)을 계산합니다.

**구문**

```sql
bitmapXor(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

어느 입력 비트맵에 존재하는 설정 비트를 포함하지만 둘 다에는 존재하지 않는 비트맵을 반환합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(bitmapXor(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;
```

```response title=Response
┌─res──────────┐
│ [1, 2, 4, 5] │
└──────────────┘
```



## bitmapXorCardinality {#bitmapXorCardinality}

도입: v20.1

두 비트맵의 XOR(대칭 차집합)의 기수를 반환합니다.

**구문**

```sql
bitmapXorCardinality(bitmap1, bitmap2)
```

**인자**

- `bitmap1` — 첫 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `bitmap2` — 두 번째 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). 

**반환 값**

두 비트맵의 대칭 차집합에서 설정된 비트의 수를 반환합니다 [`UInt64`](/sql-reference/data-types/int-uint)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapXorCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;
```

```response title=Response
┌─res─┐
│   4 │
└─────┘
```



## subBitmap {#subBitmap}

도입: v21.9

비트맵의 하위 집합을 반환하며, `offset` 위치부터 시작합니다. 반환된 비트맵의 최대 기수는 `cardinality_limit`입니다.

**구문**

```sql
subBitmap(bitmap, offset, cardinality_limit)
```

**인자**

- `bitmap` — 비트맵 객체. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction). - `offset` — 시작에서 건너뛸 설정 비트의 수 (0 기반). [`UInt32`](/sql-reference/data-types/int-uint) - `cardinality_limit` — 하위 집합에 포함할 설정 비트의 최대 수. [`UInt32`](/sql-reference/data-types/int-uint) 

**반환 값**

오름차순으로 `offset` 설정 비트를 건너뛴 후 최대 `limit` 설정 비트를 포함하는 비트맵을 반환합니다 [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)

**예제**

**사용 예**

```sql title=Query
SELECT bitmapToArray(subBitmap(bitmapBuild([1, 2, 3, 4, 5]), 2, 2)) AS res;
```

```response title=Response
┌─res────┐
│ [3, 4] │
└────────┘
```



<!--AUTOGENERATED_END-->

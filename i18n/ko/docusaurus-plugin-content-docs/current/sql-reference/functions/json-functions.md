---
'description': 'Json Functions에 대한 문서'
'sidebar_label': 'JSON'
'slug': '/sql-reference/functions/json-functions'
'title': 'JSON 함수'
'doc_type': 'reference'
---

## JSON 함수의 유형 {#types-of-functions}

JSON을 파싱하기 위한 두 가지 성격의 함수 집합이 있습니다:
- [`simpleJSON*` (`visitParam*`)](#simplejson-visitparam-functions)는 제한된 하위 집합의 JSON을 매우 빠르게 파싱하기 위해 만들어졌습니다.
- [`JSONExtract*`](#jsonextract-functions)는 일반적인 JSON을 파싱하기 위해 만들어졌습니다.
### simpleJSON (visitParam) 함수들 {#simplejson-visitparam-functions}

ClickHouse는 단순화된 JSON 작업을 위해 특별한 함수를 가지고 있습니다. 모든 이 JSON 함수들은 JSON이 가질 수 있는 것에 대한 강력한 가정을 바탕으로 하고 있습니다. 가능한 한 적은 작업만을 수행하여 작업을 빠르게 완료하려고 합니다.

다음과 같은 가정이 이루어집니다:

1.  필드 이름(함수 인자)은 상수여야 합니다.
2.  필드 이름은 JSON에 진정으로 인코딩됩니다. 예를 들어, `simpleJSONHas('{"abc":"def"}', 'abc') = 1`, 그러나 `simpleJSONHas('{"\\u0061\\u0062\\u0063":"def"}', 'abc') = 0`
3.  필드는 어떤 중첩 수준에서든 무차별적으로 검색됩니다. 여러 개의 일치하는 필드가 있을 경우, 첫 번째 발생이 사용됩니다.
4.  JSON은 문자열 리터럴 외부에 공백 문자가 없어야 합니다.
### JSONExtract 함수들 {#jsonextract-functions}

이 함수들은 [simdjson](https://github.com/lemire/simdjson)을 기반으로 하며, 더 복잡한 JSON 파싱 요구 사항을 위해 설계되었습니다.
### 대소문자 구분 없는 JSONExtract 함수들 {#case-insensitive-jsonextract-functions}

이 함수들은 JSON 객체에서 값을 추출할 때 ASCII 대소문자 구분이 없는 키 매칭을 수행합니다.
그들은 대소문자 구분이 있는 대응물과 동일하게 작동하지만, 객체 키는 대소문자와 관계없이 매칭됩니다.
여러 키가 서로 다른 대소문기로 일치할 경우, 첫 번째 일치가 반환됩니다.

:::note
이 함수들은 대소문자 구분이 있는 대응물보다 성능이 떨어질 수 있으므로, 가능하다면 일반 JSONExtract 함수를 사용하십시오.
:::

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## JSONAllPaths {#JSONAllPaths}

도입 버전: v24.8


JSON 컬럼의 각 행에 저장된 모든 경로의 목록을 반환합니다.
        

**구문**

```sql
JSONAllPaths(json)
```

**인자**

- `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)


**반환값**

JSON 컬럼의 모든 경로의 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPaths(json)─┐
│ {"a":"42"}                           │ ['a']              │
│ {"b":"Hello"}                        │ ['b']              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a','c']          │
└──────────────────────────────────────┴────────────────────┘
```
## JSONAllPathsWithTypes {#JSONAllPathsWithTypes}

도입 버전: v24.8


JSON 컬럼의 각 행에 저장된 모든 경로와 해당 데이터 유형의 목록을 반환합니다.
        

**구문**

```sql
JSONAllPathsWithTypes(json)
```

**인자**

- `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)


**반환값**

JSON 컬럼의 모든 경로와 그 데이터 유형을 담은 맵을 반환합니다. [`Map(String, String)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPathsWithTypes(json)───────────────┐
│ {"a":"42"}                           │ {'a':'Int64'}                             │
│ {"b":"Hello"}                        │ {'b':'String'}                            │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))','c':'Date'} │
└──────────────────────────────────────┴───────────────────────────────────────────┘
```
## JSONArrayLength {#JSONArrayLength}

도입 버전: v23.2


가장 바깥쪽 JSON 배열의 요소 수를 반환합니다.
입력 JSON 문자열이 유효하지 않은 경우 함수는 `NULL`을 반환합니다.
    

**구문**

```sql
JSONArrayLength(json)
```

**별칭**: `JSON_ARRAY_LENGTH`

**인자**

- `json` — 유효한 JSON을 가진 문자열. [`String`](/sql-reference/data-types/string)


**반환값**

`json`이 유효한 JSON 배열 문자열일 경우 배열 요소의 수를 반환하고, 그렇지 않으면 `NULL`을 반환합니다. [`Nullable(UInt64)`](/sql-reference/data-types/nullable)

**예시**

**사용 예시**

```sql title=Query
SELECT
    JSONArrayLength(''),
    JSONArrayLength('[1,2,3]');
```

```response title=Response
┌─JSONArrayLength('')─┬─JSONArrayLength('[1,2,3]')─┐
│                ᴺᵁᴸᴸ │                          3 │
└─────────────────────┴────────────────────────────┘
```
## JSONDynamicPaths {#JSONDynamicPaths}

도입 버전: v24.8


JSON 컬럼에 저장된 별도의 하위 컬럼으로 저장된 동적 경로의 목록을 반환합니다.
        

**구문**

```sql
JSONDynamicPaths(json)
```

**인자**

- `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)


**반환값**

JSON 컬럼의 동적 경로의 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPaths(json)─┐
│ {"a":"42"}                           │ ['a']                  │
│ {"b":"Hello"}                        │ []                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a']                  │
└──────────────────────────────────────┴────────────────────────┘
```
## JSONDynamicPathsWithTypes {#JSONDynamicPathsWithTypes}

도입 버전: v24.8


JSON 컬럼의 각 행에 저장된 별도의 하위 컬럼으로 저장된 동적 경로 및 해당 유형의 목록을 반환합니다.
        

**구문**

```sql
JSONDynamicPathsWithTypes(json)
```

**인자**

- `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)


**반환값**

JSON 컬럼의 동적 경로 및 그 데이터 유형을 담은 맵을 반환합니다. [`Map(String, String)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {'a':'Int64'}                   │
│ {"b":"Hello"}                        │ {}                              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))'}  │
└──────────────────────────────────────┴─────────────────────────────────┘
```
## JSONExtract {#JSONExtract}

도입 버전: v19.14


JSON을 파싱하고 주어진 ClickHouse 데이터 유형의 값을 추출합니다.
        

**구문**

```sql
JSONExtract(json, return_type[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `return_type` — 반환할 ClickHouse 데이터 유형. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

가능한 경우 지정된 ClickHouse 데이터 유형의 값을 반환하고, 그렇지 않으면 해당 유형의 기본값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtract('{"a": "hello", "b": [-100, 200.0, 300]}', 'Tuple(String, Array(Float64))') AS res;
```

```response title=Response
┌─res──────────────────────────────┐
│ ('hello',[-100,200,300])         │
└──────────────────────────────────┘
```
## JSONExtractArrayRaw {#JSONExtractArrayRaw}

도입 버전: v20.1


JSON 배열의 요소를 반환하며, 각 요소는 파싱되지 않은 문자열로 표현됩니다.
        

**구문**

```sql
JSONExtractArrayRaw(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

JSON 배열 요소를 가진 문자열 배열을 반환합니다. 그 부분이 배열이 아니거나 존재하지 않으면 빈 배열이 반환됩니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractArrayRaw('{"a": "hello", "b": [-100, 200.0, "hello"]}', 'b') AS res;
```

```response title=Response
┌─res──────────────────────────┐
│ ['-100','200.0','"hello"']   │
└──────────────────────────────┘
```
## JSONExtractArrayRawCaseInsensitive {#JSONExtractArrayRawCaseInsensitive}

도입 버전: v25.8


JSON 배열의 요소를 반환하며, 각 요소는 파싱되지 않은 문자열로 표현되며, 대소문자 구분 없는 키 매칭을 사용합니다. 이 함수는 [`JSONExtractArrayRaw`](#JSONExtractArrayRaw)와 유사합니다.
        

**구문**

```sql
JSONExtractArrayRawCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 배열로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

원시 JSON 문자열의 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractArrayRawCaseInsensitive('{"Items": [1, 2, 3]}', 'ITEMS')
```

```response title=Response
['1','2','3']
```
## JSONExtractBool {#JSONExtractBool}

도입 버전: v20.1


JSON을 파싱하고 Bool 유형의 값을 추출합니다.
        

**구문**

```sql
JSONExtractBool(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

존재할 경우 Bool 값을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`Bool`](/sql-reference/data-types/boolean)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractBool('{"passed": true}', 'passed') AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```
## JSONExtractBoolCaseInsensitive {#JSONExtractBoolCaseInsensitive}

도입 버전: v25.8


JSON을 파싱하고 대소문자 구분 없는 키 매칭을 사용하여 부울 값을 추출합니다. 이 함수는 [`JSONExtractBool`](#JSONExtractBool)과 유사합니다.
        

**구문**

```sql
JSONExtractBoolCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 필드로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

추출된 불리언 값(1은 참, 0은 거짓)을 반환하며, 찾을 수 없으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractBoolCaseInsensitive('{"IsActive": true}', 'isactive')
```

```response title=Response
1
```
## JSONExtractCaseInsensitive {#JSONExtractCaseInsensitive}

도입 버전: v25.8


JSON을 파싱하고 대소문자 구분 없는 키 매칭을 사용하여 주어진 ClickHouse 데이터 유형의 값을 추출합니다. 이 함수는 [`JSONExtract`](#JSONExtract)와 유사합니다.
        

**구문**

```sql
JSONExtractCaseInsensitive(json [, indices_or_keys...], return_type)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 필드로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)
- `return_type` — 추출할 ClickHouse 데이터 유형 [`String`](/sql-reference/data-types/string)


**반환값**

지정된 데이터 유형으로 추출된 값을 반환합니다. [`Any`](/sql-reference/data-types)

**예시**

**int_type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"Number": 123}', 'number', 'Int32')
```

```response title=Response
123
```

**array_type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"List": [1, 2, 3]}', 'list', 'Array(Int32)')
```

```response title=Response
[1,2,3]
```
## JSONExtractFloat {#JSONExtractFloat}

도입 버전: v20.1


JSON을 파싱하고 Float 유형의 값을 추출합니다.
        

**구문**

```sql
JSONExtractFloat(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

존재할 경우 Float 값을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractFloat('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 2) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```
## JSONExtractFloatCaseInsensitive {#JSONExtractFloatCaseInsensitive}

도입 버전: v25.8


JSON을 파싱하고 대소문자 구분 없는 키 매칭을 사용하여 Float 유형의 값을 추출합니다. 이 함수는 [`JSONExtractFloat`](#JSONExtractFloat)와 유사합니다.
        

**구문**

```sql
JSONExtractFloatCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 필드로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

추출된 Float 값을 반환하고, 찾을 수 없거나 변환할 수 없는 경우 0을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractFloatCaseInsensitive('{"Price": 12.34}', 'PRICE')
```

```response title=Response
12.34
```
## JSONExtractInt {#JSONExtractInt}

도입 버전: v20.1


JSON을 파싱하고 Int 유형의 값을 추출합니다.
        

**구문**

```sql
JSONExtractInt(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

존재할 경우 Int 값을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`Int64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 1) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```
## JSONExtractIntCaseInsensitive {#JSONExtractIntCaseInsensitive}

도입 버전: v25.8


JSON을 파싱하고 대소문자 구분 없는 키 매칭을 사용하여 Int 유형의 값을 추출합니다. 이 함수는 [`JSONExtractInt`](#JSONExtractInt)와 유사합니다.
        

**구문**

```sql
JSONExtractIntCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 필드로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

추출된 Int 값을 반환하고, 찾을 수 없거나 변환할 수 없는 경우 0을 반환합니다. [`Int64`](/sql-reference/data-types/int-uint)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"Value": 123}', 'value')
```

```response title=Response
123
```

**중첩**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"DATA": {"COUNT": 42}}', 'data', 'Count')
```

```response title=Response
42
```
## JSONExtractKeys {#JSONExtractKeys}

도입 버전: v21.11


JSON 문자열을 파싱하고 키를 추출합니다.
        

**구문**

```sql
JSONExtractKeys(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

JSON 객체의 키 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractKeys('{"a": "hello", "b": [-100, 200.0, 300]}') AS res;
```

```response title=Response
┌─res─────────┐
│ ['a','b']   │
└─────────────┘
```
## JSONExtractKeysAndValues {#JSONExtractKeysAndValues}

도입 버전: v20.1


주어진 ClickHouse 데이터 유형의 값을 가진 키-값 쌍을 JSON에서 추출합니다.
        

**구문**

```sql
JSONExtractKeysAndValues(json, value_type[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `value_type` — 값의 ClickHouse 데이터 유형. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

파싱된 키-값 쌍 튜플의 배열을 반환합니다. [`Array(Tuple(String, value_type))`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractKeysAndValues('{"x": {"a": 5, "b": 7, "c": 11}}', 'Int8', 'x') AS res;
```

```response title=Response
┌─res────────────────────┐
│ [('a',5),('b',7),('c',11)] │
└────────────────────────┘
```
## JSONExtractKeysAndValuesCaseInsensitive {#JSONExtractKeysAndValuesCaseInsensitive}

도입 버전: v25.8


대소문자 구분 없는 키 매칭을 사용하여 JSON에서 키-값 쌍을 추출합니다. 이 함수는 [`JSONExtractKeysAndValues`](#JSONExtractKeysAndValues)와 유사합니다.
        

**구문**

```sql
JSONExtractKeysAndValuesCaseInsensitive(json [, indices_or_keys...], value_type)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 객체로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)
- `value_type` — 값의 ClickHouse 데이터 유형 [`String`](/sql-reference/data-types/string)


**반환값**

키-값 쌍을 포함하는 튜플 배열을 반환합니다. [`Array(Tuple(String, T))`](/sql-reference/data-types/array)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractKeysAndValuesCaseInsensitive('{"Name": "Alice", "AGE": 30}', 'String')
```

```response title=Response
[('Name','Alice'),('AGE','30')]
```
## JSONExtractKeysAndValuesRaw {#JSONExtractKeysAndValuesRaw}

도입 버전: v20.4


JSON 객체에서 키와 값으로된 튜플의 배열을 반환하며, 모든 값은 파싱되지 않은 문자열로 표현됩니다.
        

**구문**

```sql
JSONExtractKeysAndValuesRaw(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

파싱된 키-값 쌍에 대한 배열을 반환하며, 값은 파싱되지 않은 문자열입니다. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractKeysAndValuesRaw('{"a": [-100, 200.0], "b": "hello"}') AS res;
```

```response title=Response
┌─res──────────────────────────────────┐
│ [('a','[-100,200.0]'),('b','"hello"')] │
└──────────────────────────────────────┘
```
## JSONExtractKeysAndValuesRawCaseInsensitive {#JSONExtractKeysAndValuesRawCaseInsensitive}

도입 버전: v25.8


대소문자 구분 없는 키 매칭을 사용하여 JSON에서 원시 키-값 쌍을 추출합니다. 이 함수는 [`JSONExtractKeysAndValuesRaw`](#JSONExtractKeysAndValuesRaw)와 유사합니다.
        

**구문**

```sql
JSONExtractKeysAndValuesRawCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 객체로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

원시 문자열로 된 키-값 쌍을 포함하는 튜플의 배열을 반환합니다. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractKeysAndValuesRawCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
[('Name','"Alice"'),('AGE','30')]
```
## JSONExtractKeysCaseInsensitive {#JSONExtractKeysCaseInsensitive}

도입 버전: v25.8


대소문자 구분 없는 키 매칭을 사용하여 JSON 문자열을 파싱하고 키를 추출합니다. 이 함수는 [`JSONExtractKeys`](#JSONExtractKeys)와 유사합니다.
        

**구문**

```sql
JSONExtractKeysCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 객체로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

JSON 객체의 키 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
['Name','AGE']
```

**중첩**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"User": {"name": "John", "AGE": 25}}', 'user')
```

```response title=Response
['name','AGE']
```
## JSONExtractRaw {#JSONExtractRaw}

도입 버전: v20.1


JSON의 일부를 파싱되지 않은 문자열로 반환합니다.
        

**구문**

```sql
JSONExtractRaw(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

JSON의 일부를 파싱되지 않은 문자열로 반환합니다. 해당 부분이 존재하지 않거나 잘못된 유형인 경우 빈 문자열이 반환됩니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractRaw('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') AS res;
```

```response title=Response
┌─res──────────────┐
│ [-100,200.0,300] │
└──────────────────┘
```
## JSONExtractRawCaseInsensitive {#JSONExtractRawCaseInsensitive}

도입 버전: v25.8


대소문자 구분 없는 키 매칭을 사용하여 JSON의 일부를 파싱되지 않은 문자열로 반환합니다. 이 함수는 [`JSONExtractRaw`](#JSONExtractRaw)와 유사합니다.
        

**구문**

```sql
JSONExtractRawCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 필드로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

추출된 요소의 원시 JSON 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**객체**

```sql title=Query
SELECT JSONExtractRawCaseInsensitive('{"Object": {"key": "value"}}', 'OBJECT')
```

```response title=Response
{"key":"value"}
```
## JSONExtractString {#JSONExtractString}

도입 버전: v20.1


JSON을 파싱하고 String 유형의 값을 추출합니다.
        

**구문**

```sql
JSONExtractString(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

존재할 경우 String 값을 반환하고, 그렇지 않으면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractString('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') AS res;
```

```response title=Response
┌─res───┐
│ hello │
└───────┘
```
## JSONExtractStringCaseInsensitive {#JSONExtractStringCaseInsensitive}

도입 버전: v25.8


JSON을 파싱하고 대소문자 구분 없는 키 매칭을 사용하여 문자열을 추출합니다. 이 함수는 [`JSONExtractString`](#JSONExtractString)와 유사합니다.
        

**구문**

```sql
JSONExtractStringCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 필드로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

추출된 문자열 값을 반환하며, 찾을 수 없을 경우 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"ABC": "def"}', 'abc')
```

```response title=Response
def
```

**중첩**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"User": {"Name": "John"}}', 'user', 'name')
```

```response title=Response
John
```
## JSONExtractUInt {#JSONExtractUInt}

도입 버전: v20.1


JSON을 파싱하고 UInt 유형의 값을 추출합니다.
        

**구문**

```sql
JSONExtractUInt(json [, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 문자열 또는 정수의 형태일 수 있는 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

존재할 경우 UInt 값을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractUInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', -1) AS res;
```

```response title=Response
┌─res─┐
│ 300 │
└─────┘
```
## JSONExtractUIntCaseInsensitive {#JSONExtractUIntCaseInsensitive}

도입 버전: v25.8


JSON을 파싱하고 대소문자 구분 없는 키 매칭을 사용하여 UInt 유형의 값을 추출합니다. 이 함수는 [`JSONExtractUInt`](#JSONExtractUInt)와 유사합니다.
        

**구문**

```sql
JSONExtractUIntCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — 선택적. 필드로 탐색하기 위한 인덱스 또는 키. 키는 대소문자 구분 없는 매칭을 사용합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

추출된 UInt 값을 반환하고, 찾을 수 없거나 변환할 수 없는 경우 0을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractUIntCaseInsensitive('{"COUNT": 789}', 'count')
```

```response title=Response
789
```
## JSONHas {#JSONHas}

도입 버전: v20.1


JSON 문서에서 제공된 값의 존재 여부를 확인합니다.
        

**구문**

```sql
JSONHas(json[ ,indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `[ ,indices_or_keys, ...]` — 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)


**반환값**

`json`에서 값이 존재하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 1;
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 4) = 0;
```

```response title=Response
1
0
```
## JSONLength {#JSONLength}

도입 버전: v20.1


JSON 배열 또는 JSON 객체의 길이를 반환합니다.
값이 존재하지 않거나 잘못된 유형이 있는 경우 `0`이 반환됩니다.
        

**구문**

```sql
JSONLength(json [, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `[, indices_or_keys, ...]` — 선택적. 제로 개 이상의 인자 목록. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)


**반환값**

JSON 배열 또는 JSON 객체의 길이를 반환하고, 값이 존재하지 않거나 잘못된 유형이 있을 경우 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 3;
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}') = 2;
```

```response title=Response
1
1
```
## JSONMergePatch {#JSONMergePatch}

도입 버전: v23.10


여러 JSON 객체를 병합하여 형성된 병합된 JSON 객체 문자열을 반환합니다.
    

**구문**

```sql
jsonMergePatch(json1[, json2, ...])
```

**별칭**: `jsonMergePatch`

**인자**

- `json1[, json2, ...]` — 유효한 JSON을 가진 하나 이상의 문자열. [`String`](/sql-reference/data-types/string)


**반환값**

JSON 객체 문자열이 유효할 경우 병합된 JSON 객체 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT jsonMergePatch('{"a":1}', '{"name": "joey"}', '{"name": "tom"}', '{"name": "zoey"}') AS res;
```

```response title=Response
┌─res───────────────────┐
│ {"a":1,"name":"zoey"} │
└───────────────────────┘
```
## JSONSharedDataPaths {#JSONSharedDataPaths}

도입 버전: v24.8


JSON 컬럼의 공유 데이터 구조에 저장된 경로의 목록을 반환합니다.
        

**구문**

```sql
JSONSharedDataPaths(json)
```

**인자**

- `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)


**반환값**

JSON 컬럼의 공유 데이터 구조에 저장된 경로의 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPaths(json)─┐
│ {"a":"42"}                           │ []                        │
│ {"b":"Hello"}                        │ ['b']                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['c']                     │
└──────────────────────────────────────┴───────────────────────────┘
```
## JSONSharedDataPathsWithTypes {#JSONSharedDataPathsWithTypes}

도입 버전: v24.8


JSON 컬럼의 각 행에 저장된 공유 데이터 구조와 그 유형의 경로 목록을 반환합니다.
        

**구문**

```sql
JSONSharedDataPathsWithTypes(json)
```

**인자**

- `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)


**반환값**

JSON 컬럼의 공유 데이터 구조에 저장된 경로 및 데이터 유형을 담은 맵을 반환합니다. [`Map(String, String)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {}                                  │
│ {"b":"Hello"}                        │ {'b':'String'}                      │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'c':'Date'}                        │
└──────────────────────────────────────┴─────────────────────────────────────┘
```
## JSONType {#JSONType}

도입 버전: v20.1


JSON 값의 유형을 반환합니다. 값이 존재하지 않으면, `Null=0`이 반환됩니다.
        

**구문**

```sql
JSONType(json[, indices_or_keys, ...])
```

**인자**

- `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
- `json[, indices_or_keys, ...]` — 제로 개 이상의 인자 목록으로, 각 인자는 문자열 또는 정수일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)


**반환값**

JSON 값의 유형을 문자열로 반환하고, 값이 존재하지 않으면 `Null=0`을 반환합니다. [`Enum`](/sql-reference/data-types/enum)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}') = 'Object';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') = 'String';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 'Array';
```

```response title=Response
1
1
1
```
## JSON_EXISTS {#JSON_EXISTS}

도입 버전: v21.8


JSON 문서에서 값이 존재하면 `1`을 반환합니다.
값이 존재하지 않으면 `0`을 반환합니다.
        

**구문**

```sql
JSON_EXISTS(json, path)
```

**인자**

- `json` — 유효한 JSON을 가진 문자열. [`String`](/sql-reference/data-types/string)
- `path` — 경로를 나타내는 문자열. [`String`](/sql-reference/data-types/string)


**반환값**

JSON 문서에서 값이 존재한다면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT JSON_EXISTS('{"hello":1}', '$.hello');
SELECT JSON_EXISTS('{"hello":{"world":1}}', '$.hello.world');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[*]');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[0]');
```

```response title=Response
┌─JSON_EXISTS(⋯ '$.hello')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯llo.world')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[*]')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[0]')─┐
│                        1 │
└──────────────────────────┘
```
## JSON_QUERY {#JSON_QUERY}

도입 버전: v21.8


JSON을 파싱하고 JSON 배열 또는 JSON 객체로서 값을 추출합니다.
값이 존재하지 않으면 빈 문자열이 반환됩니다.
        

**구문**

```sql
JSON_QUERY(json, path)
```

**인자**

- `json` — 유효한 JSON을 가진 문자열. [`String`](/sql-reference/data-types/string)
- `path` — 경로를 나타내는 문자열. [`String`](/sql-reference/data-types/string)


**반환값**

추출된 JSON 배열 또는 JSON 객체를 문자열로 반환하며, 값이 존재하지 않으면 빈 문자열이 반환됩니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT JSON_QUERY('{"hello":"world"}', '$.hello');
SELECT JSON_QUERY('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_QUERY('{"hello":2}', '$.hello');
SELECT toTypeName(JSON_QUERY('{"hello":2}', '$.hello'));
```

```response title=Response
["world"]
[0, 1, 4, 0, -1, -4]
[2]
String
```
## JSON_VALUE {#JSON_VALUE}

도입 버전: v21.11


JSON을 파싱하고 JSON 스칼라로서 값을 추출합니다. 값이 존재하지 않으면 기본적으로 빈 문자열이 반환됩니다.

이 함수는 다음 설정에 의해 제어됩니다:
- SET `function_json_value_return_type_allow_nullable` = `true`이면, `NULL`이 반환됩니다. 값이 복합 유형(예: struct, array, map)일 경우 기본적으로 빈 문자열이 반환됩니다.
- SET `function_json_value_return_type_allow_complex` = `true`이면, 복합 값이 반환됩니다.
        

**구문**

```sql
JSON_VALUE(json, path)
```

**인자**

- `json` — 유효한 JSON을 가진 문자열. [`String`](/sql-reference/data-types/string)
- `path` — 경로를 나타내는 문자열. [`String`](/sql-reference/data-types/string)


**반환값**

추출된 JSON 스칼라를 문자열로 반환하며, 값이 존재하지 않으면 빈 문자열이 반환됩니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT JSON_VALUE('{"hello":"world"}', '$.hello');
SELECT JSON_VALUE('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_VALUE('{"hello":2}', '$.hello');
SELECT JSON_VALUE('{"hello":"world"}', '$.b') settings function_json_value_return_type_allow_nullable=true;
```

```response title=Response
world
0
2
ᴺᵁᴸᴸ
```
## dynamicElement {#dynamicElement}

도입 버전: v24.1


`Dynamic` 열에서 지정된 유형의 컬럼을 추출합니다.

이 함수는 동적 열에서 특정 유형의 값을 추출하는 것을 허용합니다. 행이 요청된 유형의 값을 포함하는 경우 해당 값을 반환합니다. 행이 다른 유형의 값을 포함하거나 NULL인 경우 스칼라 유형에는 NULL을 반환하고 배열 유형에는 빈 배열을 반환합니다.
    

**구문**

```sql
dynamicElement(dynamic, type_name)
```

**인자**

- `dynamic` — 추출할 Dynamic 열. [`Dynamic`](/sql-reference/data-types/dynamic)
- `type_name` — 추출할 변형 유형의 이름(예: 'String', 'Int64', 'Array(Int64)'). 

**반환값**

Dynamic 열로부터 지정된 유형의 값을 반환합니다. 일치하지 않는 유형에는 NULL을 반환합니다(또는 배열 유형에는 빈 배열을 반환합니다). [`Any`](/sql-reference/data-types)

**예시**

**Dynamic 열에서 다양한 유형 추출하기**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d), dynamicElement(d, 'String'), dynamicElement(d, 'Int64'), dynamicElement(d, 'Array(Int64)'), dynamicElement(d, 'Date'), dynamicElement(d, 'Array(String)') FROM test
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┬─dynamicElement(d, 'String')─┬─dynamicElement(d, 'Int64')─┬─dynamicElement(d, 'Array(Int64)')─┬─dynamicElement(d, 'Date')─┬─dynamicElement(d, 'Array(String)')─┐
│ ᴺᵁᴸᴸ          │ None           │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ 42            │ Int64          │ ᴺᵁᴸᴸ                        │                         42 │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ Hello, World! │ String         │ Hello, World!               │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ [1,2,3]       │ Array(Int64)   │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ [1,2,3]                           │                      ᴺᵁᴸᴸ │ []                                 │
└───────────────┴────────────────┴─────────────────────────────┴────────────────────────────┴───────────────────────────────────┴───────────────────────────┴────────────────────────────────────┘
```
## dynamicType {#dynamicType}

도입 버전: v24.1


`Dynamic` 열의 각 행에 대한 변형 유형 이름을 반환합니다.

NULL이 포함된 행의 경우 'None'을 반환합니다. 모든 다른 행에 대해서는 해당 Dynamic 열의 행에 저장된 실제 데이터 유형(예: 'Int64', 'String', 'Array(Int64)')을 반환합니다.


**구문**

```sql
dynamicType(dynamic)
```

**인자**

- `dynamic` — 검토할 Dynamic 열. [`Dynamic`](/sql-reference/data-types/dynamic)


**반환값**

각 행에 저장된 값의 유형 이름을 반환하거나 NULL 값에 대해서는 'None'을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**Dynamic 열의 유형 점검하기**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d) FROM test;
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┐
│ ᴺᵁᴸᴸ          │ None           │
│ 42            │ Int64          │
│ Hello, World! │ String         │
│ [1,2,3]       │ Array(Int64)   │
└───────────────┴────────────────┘
```
## isDynamicElementInSharedData {#isDynamicElementInSharedData}

도입 버전: v24.1


공유 변형 형식으로 저장된 Dynamic 열의 행에 대해 true를 반환합니다.

Dynamic 열이 `max_types` 제한이 있는 경우, 이 제한을 초과하는 값들은 개별적으로 유형별 하위 열로 분리되지 않고 공유 이진 형식으로 저장됩니다. 이 함수는 이러한 행이 공유 형식으로 저장된 것인지를 식별합니다.
    

**구문**

```sql
isDynamicElementInSharedData(dynamic)
```

**인자**

- `dynamic` — 검토할 Dynamic 열. [`Dynamic`](/sql-reference/data-types/dynamic)


**반환값**

공유 변형 형식으로 저장된 경우 true를 반환하고, 개별 하위 열로 저장된 경우 또는 NULL일 경우 false를 반환합니다. [`Bool`](/sql-reference/data-types/boolean)

**예시**

**max_types 제한이 있는 Dynamic 열의 저장 형식 점검하기**

```sql title=Query
CREATE TABLE test (d Dynamic(max_types=2)) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, isDynamicElementInSharedData(d) FROM test;
```

```response title=Response
┌─d─────────────┬─isDynamicElementInSharedData(d)─┐
│ ᴺᵁᴸᴸ          │ false                           │
│ 42            │ false                           │
│ Hello, World! │ true                            │
│ [1,2,3]       │ true                            │
└───────────────┴─────────────────────────────────┘
```
## isValidJSON {#isValidJSON}

Introduced in: v20.1


전달된 문자열이 유효한 JSON인지 확인합니다.
        

**구문**

```sql
isValidJSON(json)
```

**인수**

- `json` — 유효성을 검사할 JSON 문자열 [`String`](/sql-reference/data-types/string)


**반환 값**

문자열이 유효한 JSON이면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT isValidJSON('{"a": "hello", "b": [-100, 200.0, 300]}') = 1;
SELECT isValidJSON('not JSON') = 0;
```

```response title=Response
1
0
```

**정수 사용하여 JSON 배열 및 JSON 객체 접근하기**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 0);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 3);
```

```response title=Response
0
1
1
1
1
1
0
```

## simpleJSONExtractBool {#simpleJSONExtractBool}

Introduced in: v21.4


`field_name`라는 이름의 필드에서 true/false 값을 파싱합니다.
결과는 `UInt8`입니다.


**구문**

```sql
simpleJSONExtractBool(json, field_name)
```

**별칭**: `visitParamExtractBool`

**인수**

- `json` — 필드를 찾을 JSON. [`String`](/sql-reference/data-types/string)
- `field_name` — 검색할 필드의 이름. [`const String`](/sql-reference/data-types/string)


**반환 값**

필드의 값이 `true`이면 `1`을, 그렇지 않으면 `0`을 반환합니다. 이는 다음 경우를 포함하여(그리고 이에 국한되지 않음) 이 함수가 `0`을 반환한다는 것을 의미합니다:
- 필드가 존재하지 않는 경우.
- 필드가 `true`라는 문자열을 포함하는 경우, 예: `{"field":"true"}`.
- 필드가 `1`이라는 숫자 값을 포함하는 경우. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":false,"bar":true}');
INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONExtractBool(json, 'bar') FROM jsons ORDER BY json;
SELECT simpleJSONExtractBool(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
1
0
0
```

## simpleJSONExtractFloat {#simpleJSONExtractFloat}

Introduced in: v21.4


`field_name`라는 이름의 필드에서 `Float64`를 파싱합니다.
`field_name`이 문자열 필드인 경우, 문자열의 시작에서 숫자를 파싱하려고 시도합니다.
필드가 존재하지 않거나 존재하지만 숫자를 포함하지 않으면 `0`을 반환합니다.


**구문**

```sql
simpleJSONExtractFloat(json, field_name)
```

**별칭**: `visitParamExtractFloat`

**인수**

- `json` — 필드를 찾을 JSON. [`String`](/sql-reference/data-types/string)
- `field_name` — 검색할 필드의 이름. [`const String`](/sql-reference/data-types/string)


**반환 값**

필드가 존재하고 숫자를 포함하면 필드에서 파싱한 숫자를 반환하고, 그렇지 않으면 `0`을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractFloat(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4000
0
-3.4
5
```

## simpleJSONExtractInt {#simpleJSONExtractInt}

Introduced in: v21.4


`field_name`라는 이름의 필드에서 `Int64`를 파싱합니다.
`field_name`이 문자열 필드인 경우, 문자열의 시작에서 숫자를 파싱하려고 시도합니다.
필드가 존재하지 않거나 존재하지만 숫자를 포함하지 않으면 `0`을 반환합니다.


**구문**

```sql
simpleJSONExtractInt(json, field_name)
```

**별칭**: `visitParamExtractInt`

**인수**

- `json` — 필드를 찾을 JSON. [`String`](/sql-reference/data-types/string)
- `field_name` — 검색할 필드의 이름. [`const String`](/sql-reference/data-types/string)


**반환 값**

필드가 존재하고 숫자를 포함하면 필드에서 파싱한 숫자를 반환하고, 그렇지 않으면 `0`을 반환합니다. [`Int64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4
0
-3
5
```

## simpleJSONExtractRaw {#simpleJSONExtractRaw}

Introduced in: v21.4


`field_name`라는 이름의 필드의 값을 문자열로, 구분자를 포함하여 반환합니다.


**구문**

```sql
simpleJSONExtractRaw(json, field_name)
```

**별칭**: `visitParamExtractRaw`

**인수**

- `json` — 필드를 찾을 JSON. [`String`](/sql-reference/data-types/string)
- `field_name` — 검색할 필드의 이름. [`const String`](/sql-reference/data-types/string)


**반환 값**

필드가 존재하면 구분자를 포함하여 필드의 값을 문자열로 반환하고, 그렇지 않으면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":{"def":[1,2,3]}}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractRaw(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
"-4e3"
-3.4
5
{"def":[1,2,3]}
```

## simpleJSONExtractString {#simpleJSONExtractString}

Introduced in: v21.4


`field_name`라는 이름의 필드에서 따옴표로 묶인 `String`을 파싱합니다.

**구현 세부사항**

현재 기본 다국어 평면에 없는 `\uXXXX\uYYYY` 형식의 코드 포인트에 대한 지원이 없습니다 (이들은 UTF-8 대신 CESU-8로 변환됩니다).


**구문**

```sql
simpleJSONExtractString(json, field_name)
```

**별칭**: `visitParamExtractString`

**인수**

- `json` — 필드를 찾을 JSON. [`String`](/sql-reference/data-types/string)
- `field_name` — 검색할 필드의 이름. [`const String`](/sql-reference/data-types/string)


**반환 값**

필드의 이스케이프 해제된 값을 문자열로 반환하고, 구분자를 포함합니다. 필드가 따옴표로 묶인 문자열을 포함하지 않거나, 이스케이프 해제에 실패하거나, 필드가 존재하지 않으면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"\\n\\u0000"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263a"}');
INSERT INTO jsons VALUES ('{"foo":"hello}');

SELECT simpleJSONExtractString(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
\n\0

☺
```

## simpleJSONExtractUInt {#simpleJSONExtractUInt}

Introduced in: v21.4


`field_name`라는 이름의 필드에서 `UInt64`를 파싱합니다.
`field_name`이 문자열 필드인 경우, 문자열의 시작에서 숫자를 파싱하려고 시도합니다.
필드가 존재하지 않거나 존재하지만 숫자를 포함하지 않으면 `0`을 반환합니다.


**구문**

```sql
simpleJSONExtractUInt(json, field_name)
```

**별칭**: `visitParamExtractUInt`

**인수**

- `json` — 필드를 찾을 JSON. [`String`](/sql-reference/data-types/string)
- `field_name` — 검색할 필드의 이름. [`const String`](/sql-reference/data-types/string)


**반환 값**

필드가 존재하고 숫자를 포함하면 필드에서 파싱한 숫자를 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"4e3"}');
INSERT INTO jsons VALUES ('{"foo":3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractUInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
4
0
3
5
```

## simpleJSONHas {#simpleJSONHas}

Introduced in: v21.4


`field_name`라는 이름의 필드가 있는지 확인합니다.


**구문**

```sql
simpleJSONHas(json, field_name)
```

**별칭**: `visitParamHas`

**인수**

- `json` — 필드를 찾을 JSON. [`String`](/sql-reference/data-types/string)
- `field_name` — 검색할 필드의 이름. [`const String`](/sql-reference/data-types/string)


**반환 값**

필드가 존재하면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONHas(json, 'foo') FROM jsons;
SELECT simpleJSONHas(json, 'bar') FROM jsons;
```

```response title=Response
1
0
```

## toJSONString {#toJSONString}

Introduced in: v21.7


값을 JSON 표현으로 직렬화합니다. 다양한 데이터 형식과 중첩 구조를 지원합니다.
64비트 [정수](../data-types/int-uint.md) 또는 더 큰 수(예: `UInt64` 또는 `Int128`)는 기본적으로 따옴표로 묶입니다. [output_format_json_quote_64bit_integers](/operations/settings/formats#output_format_json_quote_64bit_integers)가 이 동작을 제어합니다.
특별 값 `NaN` 및 `inf`는 `null`로 대체됩니다. 이들을 표시하려면 [output_format_json_quote_denormals](/operations/settings/formats#output_format_json_quote_denormals) 설정을 활성화하십시오.
[Enum](../data-types/enum.md) 값을 직렬화할 때, 함수는 그 이름을 출력합니다.

참고:
- [output_format_json_quote_64bit_integers](/operations/settings/formats#output_format_json_quote_64bit_integers)
- [output_format_json_quote_denormals](/operations/settings/formats#output_format_json_quote_denormals)
    

**구문**

```sql
toJSONString(value)
```

**인수**

- `value` — 직렬화할 값. 값은 어떤 데이터 형식일 수 있습니다. [`Any`](/sql-reference/data-types)


**반환 값**

값의 JSON 표현을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**맵 직렬화**

```sql title=Query
SELECT toJSONString(map('key1', 1, 'key2', 2));
```

```response title=Response
┌─toJSONString(map('key1', 1, 'key2', 2))─┐
│ {"key1":1,"key2":2}                     │
└─────────────────────────────────────────┘
```

**특별 값**

```sql title=Query
SELECT toJSONString(tuple(1.25, NULL, NaN, +inf, -inf, [])) SETTINGS output_format_json_quote_denormals = 1;
```

```response title=Response
┌─toJSONString(tuple(1.25, NULL, NaN, plus(inf), minus(inf), []))─┐
│ [1.25,null,"nan","inf","-inf",[]]                               │
└─────────────────────────────────────────────────────────────────┘
```



<!--AUTOGENERATED_END-->

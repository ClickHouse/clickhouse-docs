---
description: 'JSON 함수 문서'
sidebar_label: 'JSON'
slug: /sql-reference/functions/json-functions
title: 'JSON 함수'
doc_type: 'reference'
---

## JSON 함수 유형 \{#types-of-functions\}

JSON을 파싱하기 위한 함수 집합은 두 가지가 있습니다.

- [`simpleJSON*` (`visitParam*`)](#simplejson-visitparam-functions)는 제한된 JSON 부분 집합을 매우 빠르게 파싱하도록 설계되었습니다.
- [`JSONExtract*`](#jsonextract-functions)는 일반적인 JSON을 파싱하도록 설계되었습니다.

### simpleJSON (visitParam) functions \{#simplejson-visitparam-functions\}

ClickHouse에는 단순화된 JSON을 처리하기 위한 특수 함수가 있습니다. 이러한 JSON 함수들은 JSON이 어떤 구조를 갖는지에 대해 강한 가정을 기반으로 합니다. 가능한 한 최소한의 작업만 수행하여 최대한 빠르게 작업을 완료하도록 설계되었습니다.

다음과 같은 가정을 전제로 합니다:

1.  필드 이름(함수 인수)은 상수여야 합니다.
2.  필드 이름은 JSON 안에서 어떤 방식으로든 표준 형태로 인코딩되어 있어야 합니다. 예: `simpleJSONHas('{"abc":"def"}', 'abc') = 1`, 하지만 `simpleJSONHas('{"\\u0061\\u0062\\u0063":"def"}', 'abc') = 0`
3.  필드는 중첩 수준에 상관없이 모든 수준에서 검색됩니다. 여러 개의 일치하는 필드가 있는 경우, 첫 번째로 발견된 필드가 사용됩니다.
4.  JSON에서는 문자열 리터럴 바깥에 공백 문자가 없어야 합니다.

### JSONExtract 함수 \{#jsonextract-functions\}

이 함수들은 [simdjson](https://github.com/lemire/simdjson)을 기반으로 하며, 보다 복잡한 JSON 파싱 요구사항을 다루도록 설계되었습니다.

### 대소문자를 구분하지 않는 JSONExtract 함수 \{#case-insensitive-jsonextract-functions\}

이 함수들은 JSON 객체에서 값을 추출할 때 ASCII 기준으로 대소문자를 구분하지 않고 키를 매칭합니다.
대소문자를 구분하는 JSONExtract 함수들과 동작 방식은 동일하지만, 객체 키 비교 시 대소문자를 고려하지 않습니다.
서로 다른 대소문자 조합으로 인해 여러 키가 일치하는 경우, 가장 먼저 일치한 키의 값이 반환됩니다.

:::note
이 함수들은 대소문자를 구분하는 함수보다 성능이 떨어질 수 있으므로, 가능하다면 일반 JSONExtract 함수를 사용하는 것이 좋습니다.
:::

{/* 
  아래 태그 안의 내용은 문서 프레임워크를 빌드할 때
  system.functions에서 생성된 문서로 대체됩니다. 태그를 수정하거나 삭제하지 마십시오.
  자세한 내용은 다음을 참조하십시오: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
  */ }

{/*AUTOGENERATED_START*/ }


## JSONAllPaths \{#JSONAllPaths\}

도입된 버전: v24.8

JSON 컬럼의 각 행에 대해 저장된 모든 경로의 목록을 반환합니다.

**구문**

```sql
JSONAllPaths(json)
```

**인수**

* `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)

**반환 값**

JSON 컬럼의 모든 경로로 구성된 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPaths(json)─┐
│ {"a":"42"}                           │ ['a']              │
│ {"b":"Hello"}                        │ ['b']              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a','c']          │
└──────────────────────────────────────┴────────────────────┘
```


## JSONAllPathsWithTypes \{#JSONAllPathsWithTypes\}

도입된 버전: v24.8

JSON 컬럼에서 각 행마다 저장된 모든 경로와 해당 데이터 타입의 목록을 반환합니다.

**구문**

```sql
JSONAllPathsWithTypes(json)
```

**인수**

* `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)

**반환값**

JSON 컬럼의 모든 경로와 해당 경로의 데이터 타입을 나타내는 맵을 반환합니다. [`Map(String, String)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPathsWithTypes(json)───────────────┐
│ {"a":"42"}                           │ {'a':'Int64'}                             │
│ {"b":"Hello"}                        │ {'b':'String'}                            │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))','c':'Date'} │
└──────────────────────────────────────┴───────────────────────────────────────────┘
```


## JSONArrayLength \{#JSONArrayLength\}

도입 버전: v23.2

가장 바깥쪽 JSON 배열에 있는 요소 개수를 반환합니다.
입력 JSON 문자열이 유효하지 않으면 함수는 `NULL`을 반환합니다.

**구문**

```sql
JSONArrayLength(json)
```

**별칭**: `JSON_ARRAY_LENGTH`

**인수**

* `json` — 유효한 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

`json`이 유효한 JSON 배열 문자열이면 배열 요소 개수를 반환하고, 그렇지 않으면 `NULL`을 반환합니다. [`Nullable(UInt64)`](/sql-reference/data-types/nullable)

**예시**

**사용 예시**

```sql title=Query
SELECT
    JSONArrayLength(''),
    JSONArrayLength('[1,2,3]');
```

```response title=Response
┌─JSONArrayLength('')─┬─JSONArrayLength('[1,2,3]')─┐
│                ᴺᵁᴸᴸ │                          3 │
└─────────────────────┴────────────────────────────┘
```


## JSONDynamicPaths \{#JSONDynamicPaths\}

도입된 버전: v24.8

JSON 컬럼 내에서 별도 서브컬럼으로 저장된 동적 경로의 목록을 반환합니다.

**구문**

```sql
JSONDynamicPaths(json)
```

**인수**

* `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)

**반환 값**

JSON 컬럼 내 동적 경로들의 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPaths(json)─┐
│ {"a":"42"}                           │ ['a']                  │
│ {"b":"Hello"}                        │ []                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a']                  │
└──────────────────────────────────────┴────────────────────────┘
```


## JSONDynamicPathsWithTypes \{#JSONDynamicPathsWithTypes\}

도입된 버전: v24.8

JSON 컬럼의 각 행에서 별도의 서브컬럼으로 저장된 동적 경로 목록과 해당 타입을 반환합니다.

**구문**

```sql
JSONDynamicPathsWithTypes(json)
```

**인자**

* `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)

**반환 값**

JSON 컬럼에서 동적 경로와 그에 해당하는 데이터 타입으로 구성된 맵을 반환합니다. [`Map(String, String)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {'a':'Int64'}                   │
│ {"b":"Hello"}                        │ {}                              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))'}  │
└──────────────────────────────────────┴─────────────────────────────────┘
```


## JSONExtract \{#JSONExtract\}

도입 버전: v19.14

JSON을 파싱하여 지정된 ClickHouse 데이터 타입의 값을 추출합니다.

**구문**

```sql
JSONExtract(json[, indices_or_keys, ...], return_type)
```

**인자**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 각 요소가 문자열 또는 정수인, 0개 이상의 인자로 이루어진 목록입니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `return_type` — 반환할 ClickHouse 데이터 타입입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

가능한 경우 지정된 ClickHouse 데이터 타입의 값을 반환하고, 그렇지 않으면 해당 타입의 기본값을 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtract('{"a": "hello", "b": [-100, 200.0, 300]}', 'Tuple(String, Array(Float64))') AS res;
```

```response title=Response
┌─res──────────────────────────────┐
│ ('hello',[-100,200,300])         │
└──────────────────────────────────┘
```


## JSONExtractArrayRaw \{#JSONExtractArrayRaw\}

도입 버전: v20.1

JSON 배열의 각 요소를 파싱되지 않은 문자열 형태로 포함하는 배열을 반환합니다.

**구문**

```sql
JSONExtractArrayRaw(json[, indices_or_keys, ...])
```

**인자**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 0개 이상의 인수로 구성된 목록으로, 각 인수는 문자열 또는 정수일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

JSON 배열 요소로 구성된 문자열 배열을 반환합니다. 지정된 부분이 배열이 아니거나 존재하지 않으면 빈 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractArrayRaw('{"a": "hello", "b": [-100, 200.0, "hello"]}', 'b') AS res;
```

```response title=Response
┌─res──────────────────────────┐
│ ['-100','200.0','"hello"']   │
└──────────────────────────────┘
```


## JSONExtractArrayRawCaseInsensitive \{#JSONExtractArrayRawCaseInsensitive\}

도입 버전: v25.8

대소문자를 구분하지 않는 키 일치를 사용하여 JSON 배열의 각 요소를 파싱되지 않은 문자열로 표현한 배열을 반환합니다. 이 FUNCTION은 [`JSONExtractArrayRaw`](#JSONExtractArrayRaw)와 유사합니다.

**구문**

```sql
JSONExtractArrayRawCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택적입니다. 배열 위치로 이동하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 매칭됩니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

원시 JSON 문자열의 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractArrayRawCaseInsensitive('{"Items": [1, 2, 3]}', 'ITEMS')
```

```response title=Response
['1','2','3']
```


## JSONExtractBool \{#JSONExtractBool\}

도입된 버전: v20.1

JSON을 파싱하여 Bool 유형의 값을 추출합니다.

**구문**

```sql
JSONExtractBool(json[, indices_or_keys, ...])
```

**인수(Arguments)**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 각 항목이 문자열 또는 정수일 수 있는 인수를 0개 이상 담는 목록입니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값(Returned value)**

값이 존재하면 Bool 값을 반환하고, 존재하지 않으면 `0`을 반환합니다. [`Bool`](/sql-reference/data-types/boolean)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT JSONExtractBool('{"passed": true}', 'passed') AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```


## JSONExtractBoolCaseInsensitive \{#JSONExtractBoolCaseInsensitive\}

도입된 버전: v25.8

JSON을 파싱하고 대소문자를 구분하지 않는 키 매칭을 사용하여 boolean 값을 추출합니다. 이 FUNCTION은 [`JSONExtractBool`](#JSONExtractBool)과 유사합니다.

**구문**

```sql
JSONExtractBoolCaseInsensitive(json [, indices_or_keys]...)
```

**인자**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택 사항. 필드에 접근하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 매칭합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

추출된 boolean 값(true이면 1, false이면 0)이며, 값을 찾을 수 없으면 0을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractBoolCaseInsensitive('{"IsActive": true}', 'isactive')
```

```response title=Response
1
```


## JSONExtractCaseInsensitive \{#JSONExtractCaseInsensitive\}

도입된 버전: v25.8

JSON을 파싱하여 대소문자를 구분하지 않는 키 매칭을 사용해 지정된 ClickHouse 데이터 타입(data type)의 값을 추출합니다. 이 FUNCTION은 [`JSONExtract`](#JSONExtract)와 유사합니다.

**문법**

```sql
JSONExtractCaseInsensitive(json [, indices_or_keys...], return_type)
```

**인수**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택적 인수입니다. 필드로 이동하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 일치합니다 [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `return_type` — 추출할 ClickHouse 데이터 타입 [`String`](/sql-reference/data-types/string)

**반환 값**

지정된 데이터 타입으로 추출된 값을 반환합니다. [`Any`](/sql-reference/data-types)

**예시**

**int&#95;type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"Number": 123}', 'number', 'Int32')
```

```response title=Response
123
```

**array&#95;type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"List": [1, 2, 3]}', 'list', 'Array(Int32)')
```

```response title=Response
[1,2,3]
```


## JSONExtractFloat \{#JSONExtractFloat\}

도입된 버전: v20.1

JSON을 파싱하여 Float 타입의 값을 추출합니다.

**문법**

```sql
JSONExtractFloat(json[, indices_or_keys, ...])
```

**인수**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 0개 이상의 인수로 구성된 목록이며, 각 인수는 문자열 또는 정수일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

값이 존재하면 부동 소수점(Float) 값을 반환하고, 그렇지 않으면 `0`을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractFloat('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 2) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```


## JSONExtractFloatCaseInsensitive \{#JSONExtractFloatCaseInsensitive\}

도입된 버전: v25.8

JSON을 파싱한 다음 대소문자를 구분하지 않는 키 매칭을 사용하여 Float 타입 값을 추출합니다. 이 FUNCTION은 [`JSONExtractFloat`](#JSONExtractFloat)과 유사합니다.

**구문**

```sql
JSONExtractFloatCaseInsensitive(json [, indices_or_keys]...)
```

**인수**

* `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택적입니다. 필드에 접근하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 매칭합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

추출된 Float 값을 반환하며, 값을 찾을 수 없거나 변환할 수 없으면 0을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractFloatCaseInsensitive('{"Price": 12.34}', 'PRICE')
```

```response title=Response
12.34
```


## JSONExtractInt \{#JSONExtractInt\}

도입 버전: v20.1

JSON을 파싱하여 Int 타입의 값을 추출합니다.

**구문**

```sql
JSONExtractInt(json[, indices_or_keys, ...])
```

**인수(Arguments)**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 0개 이상의 인자로 이루어진 목록으로, 각 인자는 문자열 또는 정수일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값(Returned value)**

값이 존재하면 Int 값을 반환하고, 존재하지 않으면 `0`을 반환합니다. [`Int64`](/sql-reference/data-types/int-uint)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT JSONExtractInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 1) AS res;
```

```response title=Response
┌──res─┐
│ -100 │
└──────┘
```


## JSONExtractIntCaseInsensitive \{#JSONExtractIntCaseInsensitive\}

도입 버전: v25.8

JSON을 파싱하여 대소문자를 구분하지 않고 키를 매칭해 Int 타입의 값을 추출합니다. 이 FUNCTION은 [`JSONExtractInt`](#JSONExtractInt)와 유사합니다.

**문법**

```sql
JSONExtractIntCaseInsensitive(json [, indices_or_keys]...)
```

**인수**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택적입니다. 필드까지 이동하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 일치시킵니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

추출된 Int 값을 반환합니다. 값을 찾을 수 없거나 변환할 수 없으면 0을 반환합니다. [`Int64`](/sql-reference/data-types/int-uint)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"Value": 123}', 'value')
```

```response title=Response
123
```

**중첩 구조**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"DATA": {"COUNT": 42}}', 'data', 'Count')
```

```response title=Response
42
```


## JSONExtractKeys \{#JSONExtractKeys\}

도입된 버전: v21.11

JSON 문자열을 파싱하여 키를 추출합니다.

**구문**

```sql
JSONExtractKeys(json[, indices_or_keys, ...])
```

**인수**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 0개 이상의 인수 목록이며, 각 인수는 문자열 또는 정수입니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

JSON 객체의 키를 담은 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractKeys('{"a": "hello", "b": [-100, 200.0, 300]}') AS res;
```

```response title=Response
┌─res─────────┐
│ ['a','b']   │
└─────────────┘
```


## JSONExtractKeysAndValues \{#JSONExtractKeysAndValues\}

도입 버전: v20.1

값이 지정된 ClickHouse 데이터 타입을 가지는 JSON에서 key-value 쌍을 파싱합니다.

**구문**

```sql
JSONExtractKeysAndValues(json[, indices_or_keys, ...], value_type)
```

**인자**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 0개 이상의 인수로 구성된 목록으로, 각 인수는 문자열 또는 정수일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `value_type` — 값의 ClickHouse 데이터 타입입니다. [`String`](/sql-reference/data-types/string)

**반환값**

파싱된 key-value 쌍이 들어 있는 튜플 배열을 반환합니다. [`Array(Tuple(String, value_type))`](/sql-reference/data-types/array)

**예시**

**사용 예**

```sql title=Query
SELECT JSONExtractKeysAndValues('{"x": {"a": 5, "b": 7, "c": 11}}', 'Int8', 'x') AS res;
```

```response title=Response
┌─res────────────────────┐
│ [('a',5),('b',7),('c',11)] │
└────────────────────────┘
```


## JSONExtractKeysAndValuesCaseInsensitive \{#JSONExtractKeysAndValuesCaseInsensitive\}

도입 버전: v25.8

대소문자를 구분하지 않는 키 매칭으로 JSON에서 key-value 쌍을 파싱합니다. 이 FUNCTION은 [`JSONExtractKeysAndValues`](#JSONExtractKeysAndValues)와 유사합니다.

**구문**

```sql
JSONExtractKeysAndValuesCaseInsensitive(json [, indices_or_keys...], value_type)
```

**인자**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택 사항. 객체로 이동하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 매칭됩니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)
* `value_type` — 값의 ClickHouse 데이터 타입 [`String`](/sql-reference/data-types/string)

**반환 값**

key-value 쌍으로 구성된 튜플 배열을 반환합니다. [`Array(Tuple(String, T))`](/sql-reference/data-types/array)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractKeysAndValuesCaseInsensitive('{"Name": "Alice", "AGE": 30}', 'String')
```

```response title=Response
[('Name','Alice'),('AGE','30')]
```


## JSONExtractKeysAndValuesRaw \{#JSONExtractKeysAndValuesRaw\}

도입된 버전: v20.4

JSON 객체의 키와 값을 포함하는 튜플의 배열을 반환합니다. 모든 값은 파싱되지 않은 문자열로 표현됩니다.

**구문**

```sql
JSONExtractKeysAndValuesRaw(json[, indices_or_keys, ...])
```

**인수**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 각 요소가 문자열 또는 정수일 수 있는 0개 이상의 인수 목록입니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

파싱된 key-value 쌍의 배열을 반환하며, 각 값은 파싱되지 않은 문자열입니다. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractKeysAndValuesRaw('{"a": [-100, 200.0], "b": "hello"}') AS res;
```

```response title=Response
┌─res──────────────────────────────────┐
│ [('a','[-100,200.0]'),('b','"hello"')] │
└──────────────────────────────────────┘
```


## JSONExtractKeysAndValuesRawCaseInsensitive \{#JSONExtractKeysAndValuesRawCaseInsensitive\}

도입 버전: v25.8

대소문자를 구분하지 않는 키 일치를 사용하여 JSON에서 raw key-value 쌍을 추출합니다. 이 FUNCTION은 [`JSONExtractKeysAndValuesRaw`](#JSONExtractKeysAndValuesRaw)와 유사합니다.

**구문**

```sql
JSONExtractKeysAndValuesRawCaseInsensitive(json [, indices_or_keys]...)
```

**인자(Arguments)**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택적 인자입니다. 객체까지 이동하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 비교합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값(Returned value)**

key-value 쌍을 원시 문자열 형태로 포함하는 튜플의 배열을 반환합니다. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**예시(Examples)**

**기본 예제(basic)**

```sql title=Query
SELECT JSONExtractKeysAndValuesRawCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
[('Name','"Alice"'),('AGE','30')]
```


## JSONExtractKeysCaseInsensitive \{#JSONExtractKeysCaseInsensitive\}

도입된 버전: v25.8

JSON 문자열을 파싱하고, 대소문자를 구분하지 않는 키 매칭을 사용하여 중첩 객체를 탐색하면서 키를 추출합니다. 이 FUNCTION은 [`JSONExtractKeys`](#JSONExtractKeys)와 유사합니다.

**구문**

```sql
JSONExtractKeysCaseInsensitive(json [, indices_or_keys]...)
```

**인자(Arguments)**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택적입니다. 객체로 이동하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 매칭됩니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

JSON 객체의 키 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시(Examples)**

**기본(basic)**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
['Name','AGE']
```

**중첩**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"User": {"name": "John", "AGE": 25}}', 'user')
```

```response title=Response
['name','AGE']
```


## JSONExtractRaw \{#JSONExtractRaw\}

도입된 버전: v20.1

JSON의 일부를 파싱되지 않은 문자열 그대로 반환합니다.

**구문**

```sql
JSONExtractRaw(json[, indices_or_keys, ...])
```

**인수(Arguments)**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 각 인수가 문자열 또는 정수일 수 있는 0개 이상의 인수 목록입니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값(Returned value)**

JSON의 일부를 파싱하지 않은 문자열 형태로 반환합니다. 해당 부분이 존재하지 않거나 타입이 잘못된 경우 빈 문자열이 반환됩니다. [`String`](/sql-reference/data-types/string)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT JSONExtractRaw('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') AS res;
```

```response title=Response
┌─res──────────────┐
│ [-100,200.0,300] │
└──────────────────┘
```


## JSONExtractRawCaseInsensitive \{#JSONExtractRawCaseInsensitive\}

도입 버전: v25.8

대소문자를 구분하지 않는 키 일치 방식을 사용하여 JSON의 일부를 파싱되지 않은 문자열로 반환합니다. 이 함수는 [`JSONExtractRaw`](#JSONExtractRaw)와 유사합니다.

**구문**

```sql
JSONExtractRawCaseInsensitive(json [, indices_or_keys]...)
```

**인수**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택 사항. 필드에 접근하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 매칭합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환값**

추출된 요소의 원시 JSON 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**object**

```sql title=Query
SELECT JSONExtractRawCaseInsensitive('{"Object": {"key": "value"}}', 'OBJECT')
```

```response title=Response
{"key":"value"}
```


## JSONExtractString \{#JSONExtractString\}

도입 버전: v20.1

JSON을 파싱하여 String 타입(문자열) 값을 추출합니다.

**구문**

```sql
JSONExtractString(json[, indices_or_keys, ...])
```

**인수**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 0개 이상의 인수로 이루어진 목록이며, 각 인수는 문자열 또는 정수일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환값**

값이 존재하면 문자열(String)을 반환하고, 존재하지 않으면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractString('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') AS res;
```

```response title=Response
┌─res───┐
│ hello │
└───────┘
```


## JSONExtractStringCaseInsensitive \{#JSONExtractStringCaseInsensitive\}

도입 버전: v25.8

JSON을 파싱한 후 키를 대소문자 구분 없이 매칭하여 문자열을 추출합니다. 이 FUNCTION은 [`JSONExtractString`](#JSONExtractString)과 유사합니다.

**구문**

```sql
JSONExtractStringCaseInsensitive(json [, indices_or_keys]...)
```

**인수**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택 사항. 필드를 가리키기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 매칭됩니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

추출된 문자열 값을 반환하며, 찾을 수 없는 경우 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**기본**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"ABC": "def"}', 'abc')
```

```response title=Response
def
```

**중첩**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"User": {"Name": "John"}}', 'user', 'name')
```

```response title=Response
John
```


## JSONExtractUInt \{#JSONExtractUInt\}

도입 버전: v20.1

JSON을 파싱하여 UInt 타입 값을 추출합니다.

**구문**

```sql
JSONExtractUInt(json [, indices_or_keys, ...])
```

**인자**

* `json` — 파싱할 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 0개 이상의 인수로 구성된 목록으로, 각 인수는 문자열 또는 정수일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값**

해당 값이 존재하면 UInt 값을, 존재하지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONExtractUInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', -1) AS res;
```

```response title=Response
┌─res─┐
│ 300 │
└─────┘
```


## JSONExtractUIntCaseInsensitive \{#JSONExtractUIntCaseInsensitive\}

도입된 버전: v25.8

JSON을 파싱하고 키 이름의 대소문자를 구분하지 않는 매칭을 사용하여 `UInt` 타입의 값을 추출합니다. 이 함수는 [`JSONExtractUInt`](#JSONExtractUInt)와 유사합니다.

**구문**

```sql
JSONExtractUIntCaseInsensitive(json [, indices_or_keys]...)
```

**인수(Arguments)**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 선택 사항입니다. 필드까지 탐색하기 위한 인덱스 또는 키입니다. 키는 대소문자를 구분하지 않고 매칭합니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)

**반환 값(Returned value)**

추출된 부호 없는 정수(UInt) 값을 반환하며, 값을 찾을 수 없거나 변환할 수 없으면 0을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시(Examples)**

**기본 예제(basic)**

```sql title=Query
SELECT JSONExtractUIntCaseInsensitive('{"COUNT": 789}', 'count')
```

```response title=Response
789
```


## JSONHas \{#JSONHas\}

도입: v20.1

JSON 문서에서 지정한 값의 존재 여부를 확인합니다.

**구문**

```sql
JSONHas(json[ ,indices_or_keys, ...])
```

**인수**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `[ ,indices_or_keys, ...]` — 0개 이상의 인수 목록입니다. 각 인수는 [`String`](/sql-reference/data-types/string) 또는 [`(U)Int*`](/sql-reference/data-types/int-uint)입니다.

**반환 값**

`json` 안에 값이 존재하면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 1;
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 4) = 0;
```

```response title=Response
1
0
```


## JSONKey \{#JSONKey\}

도입 버전: v20.1

JSON 객체 필드의 키를 인덱스(1부터 시작) 기준으로 반환합니다. JSON이 문자열로 전달되는 경우 먼저 파싱합니다. 두 번째 인수는 중첩 객체 내부로 이동하기 위한 JSON 경로입니다. 함수는 지정된 위치의 키 이름을 반환합니다.

**구문**

```sql
JSONKey(json[, indices_or_keys, ...])
```

**인수**

* `json` — 파싱할 JSON 문자열. [`String`](/sql-reference/data-types/string)
* `indices_or_keys` — 중첩 요소의 경로를 지정하는 선택적 인덱스 또는 키 목록입니다. 각 인수는 문자열(키로 접근) 또는 정수(1부터 시작하는 인덱스로 접근)일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`Int*`](/sql-reference/data-types/int-uint)

**반환 값**

JSON 객체에서 지정한 위치의 키 이름을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONKey('{"a": "hello", "b": [-100, 200.0, 300]}', 1);
```

```response title=Response
a
```


## JSONLength \{#JSONLength\}

도입 버전: v20.1

JSON 배열 또는 JSON 객체의 길이를 반환합니다.
값이 존재하지 않거나 형식이 올바르지 않으면 `0`을 반환합니다.

**구문**

```sql
JSONLength(json [, indices_or_keys, ...])
```

**인수**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `[, indices_or_keys, ...]` — 선택 사항입니다. 0개 이상의 인수 목록입니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

JSON 배열 또는 JSON 객체의 길이를 반환하며, 값이 존재하지 않거나 타입이 올바르지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 3;
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}') = 2;
```

```response title=Response
1
1
```


## JSONMergePatch \{#JSONMergePatch\}

도입된 버전: v23.10

여러 JSON 객체를 병합하여 생성된 JSON 객체 문자열을 반환합니다.

**구문**

```sql
jsonMergePatch(json1[, json2, ...])
```

**별칭(Aliases)**: `jsonMergePatch`

**인수(Arguments)**

* `json1[, json2, ...]` — 하나 이상의 유효한 JSON 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값(Returned value)**

JSON 객체 문자열이 유효하면 병합된 JSON 객체 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
SELECT jsonMergePatch('{"a":1}', '{"name": "joey"}', '{"name": "tom"}', '{"name": "zoey"}') AS res;
```

```response title=Response
┌─res───────────────────┐
│ {"a":1,"name":"zoey"} │
└───────────────────────┘
```


## JSONSharedDataPaths \{#JSONSharedDataPaths\}

도입: v24.8

JSON 컬럼의 공유 데이터 구조에 저장된 경로 목록을 반환합니다.

**구문**

```sql
JSONSharedDataPaths(json)
```

**인수**

* `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)

**반환 값**

JSON 컬럼에서 공유 데이터 구조에 저장된 경로 배열을 반환합니다. [`Array(String)`](/sql-reference/data-types/array)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPaths(json)─┐
│ {"a":"42"}                           │ []                        │
│ {"b":"Hello"}                        │ ['b']                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['c']                     │
└──────────────────────────────────────┴───────────────────────────┘
```


## JSONSharedDataPathsWithTypes \{#JSONSharedDataPathsWithTypes\}

도입 버전: v24.8

공유 데이터 구조에 저장된 경로 목록과 JSON 컬럼 각 행에서의 해당 경로 타입을 반환합니다.

**구문**

```sql
JSONSharedDataPathsWithTypes(json)
```

**인수**

* `json` — JSON 컬럼. [`JSON`](/sql-reference/data-types/newjson)

**반환 값**

공유 데이터 구조에 저장된 경로와 JSON 컬럼의 해당 데이터 타입을 나타내는 맵을 반환합니다. [`Map(String, String)`](/sql-reference/data-types/map)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {}                                  │
│ {"b":"Hello"}                        │ {'b':'String'}                      │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'c':'Date'}                        │
└──────────────────────────────────────┴─────────────────────────────────────┘
```


## JSONType \{#JSONType\}

도입 버전: v20.1

JSON 값의 타입을 반환합니다. 값이 존재하지 않으면 `Null=0`이 반환됩니다.

**문법**

```sql
JSONType(json[, indices_or_keys, ...])
```

**인수**

* `json` — 파싱할 JSON 문자열 [`String`](/sql-reference/data-types/string)
* `json[, indices_or_keys, ...]` — 0개 이상의 인수로 구성된 목록이며, 각 인수는 문자열 또는 정수일 수 있습니다. [`String`](/sql-reference/data-types/string) 또는 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)

**반환 값**

JSON 값의 타입을 나타내는 문자열을 반환하며, 값이 존재하지 않으면 `Null=0` [`Enum`](/sql-reference/data-types/enum)을(를) 반환합니다.

**예시**

**사용 예시**

```sql title=Query
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}') = 'Object';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') = 'String';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 'Array';
```

```response title=Response
1
1
1
```


## JSON_EXISTS \{#JSON_EXISTS\}

도입된 버전: v21.8

값이 JSON 문서에 존재하면 `1`이 반환됩니다.
값이 JSON 문서에 존재하지 않으면 `0`이 반환됩니다.

**구문**

```sql
JSON_EXISTS(json, path)
```

**인수(Arguments)**

* `json` — 유효한 JSON 형식의 문자열입니다. [`String`](/sql-reference/data-types/string)
* `path` — 경로를 나타내는 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값(Returned value)**

JSON 문서에 해당 값이 존재하면 `1`, 존재하지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예제(Examples)**

**사용 예제(Usage example)**

```sql title=Query
SELECT JSON_EXISTS('{"hello":1}', '$.hello');
SELECT JSON_EXISTS('{"hello":{"world":1}}', '$.hello.world');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[*]');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[0]');
```

```response title=Response
┌─JSON_EXISTS(⋯ '$.hello')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯llo.world')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[*]')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[0]')─┐
│                        1 │
└──────────────────────────┘
```


## JSON_QUERY \{#JSON_QUERY\}

도입된 버전: v21.8

JSON을 파싱하고 값을 JSON 배열 또는 JSON 객체로 추출합니다.
값이 존재하지 않으면 빈 문자열을 반환합니다.

**구문**

```sql
JSON_QUERY(json, path)
```

**인수**

* `json` — 유효한 JSON이 포함된 문자열입니다. [`String`](/sql-reference/data-types/string)
* `path` — 경로를 나타내는 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

JSON 배열 또는 JSON 객체를 추출하여 문자열로 반환하며, 값이 존재하지 않으면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT JSON_QUERY('{"hello":"world"}', '$.hello');
SELECT JSON_QUERY('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_QUERY('{"hello":2}', '$.hello');
SELECT toTypeName(JSON_QUERY('{"hello":2}', '$.hello'));
```

```response title=Response
["world"]
[0, 1, 4, 0, -1, -4]
[2]
String
```


## JSON_VALUE \{#JSON_VALUE\}

도입 버전: v21.11

JSON을 파싱하여 값을 JSON 스칼라 값으로 추출합니다. 값이 존재하지 않으면 기본적으로 빈 문자열을 반환합니다.

이 함수의 동작은 다음 설정으로 제어됩니다:

* SET `function_json_value_return_type_allow_nullable` = `true` 인 경우 `NULL`이 반환됩니다. 값이 복합 타입(예: struct, array, map)인 경우 기본적으로 빈 문자열을 반환합니다.
* SET `function_json_value_return_type_allow_complex` = `true` 인 경우 복합 타입 값이 그대로 반환됩니다.

**구문**

```sql
JSON_VALUE(json, path)
```

**인수**

* `json` — 유효한 JSON 형식의 문자열입니다. [`String`](/sql-reference/data-types/string)
* `path` — 경로를 나타내는 문자열입니다. [`String`](/sql-reference/data-types/string)

**반환 값**

추출된 JSON 스칼라 값을 문자열로 반환하며, 값이 존재하지 않으면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**사용 예시**

```sql title=Query
SELECT JSON_VALUE('{"hello":"world"}', '$.hello');
SELECT JSON_VALUE('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_VALUE('{"hello":2}', '$.hello');
SELECT JSON_VALUE('{"hello":"world"}', '$.b') settings function_json_value_return_type_allow_nullable=true;
```

```response title=Response
world
0
2
ᴺᵁᴸᴸ
```


## dynamicElement \{#dynamicElement\}

도입 버전: v24.1

`Dynamic` 컬럼에서 지정된 타입의 값을 추출합니다.

이 함수는 Dynamic 컬럼에서 특정 타입의 값을 추출합니다. 행에 요청된 타입의 값이 포함되어 있으면 해당 값을 반환합니다. 행에 다른 타입의 값이 있거나 NULL인 경우, 스칼라 타입에는 NULL을, 배열 타입에는 빈 배열을 반환합니다.

**구문**

```sql
dynamicElement(dynamic, type_name)
```

**인수**

* `dynamic` — 값을 추출할 Dynamic 컬럼입니다. [`Dynamic`](/sql-reference/data-types/dynamic)
* `type_name` — 추출할 variant 타입의 이름입니다(예: &#39;String&#39;, &#39;Int64&#39;, &#39;Array(Int64)&#39;).

**반환 값**

Dynamic 컬럼에서 지정된 타입의 값을 반환합니다. 일치하지 않는 타입인 경우에는 NULL(배열 타입의 경우 빈 배열)을 반환합니다. [`Any`](/sql-reference/data-types)

**예시**

**Dynamic 컬럼에서 다양한 타입 추출하기**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d), dynamicElement(d, 'String'), dynamicElement(d, 'Int64'), dynamicElement(d, 'Array(Int64)'), dynamicElement(d, 'Date'), dynamicElement(d, 'Array(String)') FROM test
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┬─dynamicElement(d, 'String')─┬─dynamicElement(d, 'Int64')─┬─dynamicElement(d, 'Array(Int64)')─┬─dynamicElement(d, 'Date')─┬─dynamicElement(d, 'Array(String)')─┐
│ ᴺᵁᴸᴸ          │ None           │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ 42            │ Int64          │ ᴺᵁᴸᴸ                        │                         42 │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ Hello, World! │ String         │ Hello, World!               │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ [1,2,3]       │ Array(Int64)   │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ [1,2,3]                           │                      ᴺᵁᴸᴸ │ []                                 │
└───────────────┴────────────────┴─────────────────────────────┴────────────────────────────┴───────────────────────────────────┴───────────────────────────┴────────────────────────────────────┘
```


## dynamicType \{#dynamicType\}

도입된 버전: v24.1

`Dynamic` 컬럼의 각 행에 대해 variant 타입 이름을 반환합니다.

NULL을 포함하는 행에서는 함수가 &#39;None&#39;을 반환합니다. 그 외 모든 행에서는 Dynamic 컬럼의 해당 행에 저장된 실제 데이터 타입(예: &#39;Int64&#39;, &#39;String&#39;, &#39;Array(Int64)&#39;)을 반환합니다.

**구문**

```sql
dynamicType(dynamic)
```

**인수**

* `dynamic` — 검사할 Dynamic 컬럼입니다. [`Dynamic`](/sql-reference/data-types/dynamic)

**반환값**

각 행에 저장된 값의 타입 이름을 반환하며, NULL 값인 경우에는 &#39;None&#39;을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시**

**Dynamic 컬럼의 타입 검사**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d) FROM test;
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┐
│ ᴺᵁᴸᴸ          │ None           │
│ 42            │ Int64          │
│ Hello, World! │ String         │
│ [1,2,3]       │ Array(Int64)   │
└───────────────┴────────────────┘
```


## isDynamicElementInSharedData \{#isDynamicElementInSharedData\}

도입 버전: v24.1

별도의 서브컬럼으로 분리되지 않고 공유 variant 포맷으로 저장된 Dynamic 컬럼의 행에 대해 true를 반환합니다.

Dynamic 컬럼에 `max_types` 제한이 있는 경우, 이 제한을 초과하는 값은 개별 타입별 서브컬럼으로 분리하는 대신 공유 바이너리 포맷으로 저장됩니다. 이 함수는 어떤 행이 이러한 공유 포맷으로 저장되어 있는지를 식별합니다.

**구문**

```sql
isDynamicElementInSharedData(dynamic)
```

**인수**

* `dynamic` — 검사할 Dynamic 컬럼입니다. [`Dynamic`](/sql-reference/data-types/dynamic)

**반환 값**

값이 shared variant 형식으로 저장된 경우에는 true, 별도의 하위 컬럼으로 저장되었거나 NULL인 경우에는 false를 반환합니다. [`Bool`](/sql-reference/data-types/boolean)

**예시**

**max&#95;types 제한이 있는 Dynamic 컬럼에서 저장 형식 확인**

```sql title=Query
CREATE TABLE test (d Dynamic(max_types=2)) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, isDynamicElementInSharedData(d) FROM test;
```

```response title=Response
┌─d─────────────┬─isDynamicElementInSharedData(d)─┐
│ ᴺᵁᴸᴸ          │ false                           │
│ 42            │ false                           │
│ Hello, World! │ true                            │
│ [1,2,3]       │ true                            │
└───────────────┴─────────────────────────────────┘
```


## isValidJSON \{#isValidJSON\}

도입된 버전: v20.1

입력된 문자열이 유효한 JSON인지 확인합니다.

**구문**

```sql
isValidJSON(json)
```

**인수**

* `json` — 유효성을 검사할 JSON 문자열 [`String`](/sql-reference/data-types/string)

**반환 값**

문자열이 유효한 JSON이면 `1`, 그렇지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시**

**사용 예시**

```sql title=Query
SELECT isValidJSON('{"a": "hello", "b": [-100, 200.0, 300]}') = 1;
SELECT isValidJSON('not JSON') = 0;
```

```response title=Response
1
0
```

**정수를 사용하여 JSON 배열과 객체에 모두 접근하기**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 0);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 3);
```

```response title=Response
0
1
1
1
1
1
0
```


## simpleJSONExtractBool \{#simpleJSONExtractBool\}

도입 버전: v21.4

이름이 `field_name`인 필드의 값에서 true/false 값을 파싱합니다.
결과 타입은 `UInt8`입니다.

**구문**

```sql
simpleJSONExtractBool(json, field_name)
```

**별칭(Aliases)**: `visitParamExtractBool`

**인수(Arguments)**

* `json` — 필드를 검색할 JSON입니다. [`String`](/sql-reference/data-types/string)
* `field_name` — 검색할 필드 이름입니다. [`const String`](/sql-reference/data-types/string)

**반환 값(Returned value)**

필드 값이 `true`이면 `1`을, 그렇지 않으면 `0`을 반환합니다. 이는 다음과 같은 경우를 포함하여 이 함수가 `0`을 반환함을 의미합니다.

* 필드가 존재하지 않는 경우
* 필드가 문자열로 `true`를 포함하는 경우, 예: `{"field":"true"}`
* 필드가 숫자 값 `1`을 포함하는 경우. [`UInt8`](/sql-reference/data-types/int-uint)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":false,"bar":true}');
INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONExtractBool(json, 'bar') FROM jsons ORDER BY json;
SELECT simpleJSONExtractBool(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
1
0
0
```


## simpleJSONExtractFloat \{#simpleJSONExtractFloat\}

도입된 버전: v21.4

`field_name`이라는 이름의 필드 값에서 `Float64` 값을 파싱합니다.
`field_name`이 문자열 필드이면, 문자열의 시작 부분에서 숫자를 파싱하려고 시도합니다.
필드가 존재하지 않거나, 존재하더라도 숫자가 포함되어 있지 않으면 `0`을 반환합니다.

**구문**

```sql
simpleJSONExtractFloat(json, field_name)
```

**별칭**: `visitParamExtractFloat`

**인수**

* `json` — 필드를 검색할 JSON입니다. [`String`](/sql-reference/data-types/string)
* `field_name` — 검색할 필드 이름입니다. [`const String`](/sql-reference/data-types/string)

**반환값**

필드가 존재하고 해당 필드에 숫자가 포함되어 있으면 필드에서 파싱된 숫자를 반환하고, 그렇지 않으면 `0`을 반환합니다. [`Float64`](/sql-reference/data-types/float)

**예시**

**사용 예시**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractFloat(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4000
0
-3.4
5
```


## simpleJSONExtractInt \{#simpleJSONExtractInt\}

도입 버전: v21.4

`field_name`이라는 이름의 필드 값에서 `Int64`를 파싱합니다.
`field_name`이 문자열 필드인 경우 문자열의 시작 부분에서 숫자를 파싱하려고 시도합니다.
필드가 존재하지 않거나 존재하지만 숫자를 포함하지 않으면 `0`을 반환합니다.

**구문**

```sql
simpleJSONExtractInt(json, field_name)
```

**별칭(Aliases)**: `visitParamExtractInt`

**인수(Arguments)**

* `json` — 필드를 검색할 JSON입니다. [`String`](/sql-reference/data-types/string)
* `field_name` — 검색할 필드 이름입니다. [`const String`](/sql-reference/data-types/string)

**반환 값(Returned value)**

필드가 존재하고 해당 필드에 숫자가 포함되어 있으면, 그 숫자를 파싱하여 반환하며 그렇지 않으면 `0`을 반환합니다. [`Int64`](/sql-reference/data-types/int-uint)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4
0
-3
5
```


## simpleJSONExtractRaw \{#simpleJSONExtractRaw\}

도입된 버전: v21.4

구분자를 포함하여 이름이 `field_name`인 필드의 값을 `String`으로 반환합니다.

**구문**

```sql
simpleJSONExtractRaw(json, field_name)
```

**별칭(Aliases)**: `visitParamExtractRaw`

**인수(Arguments)**

* `json` — 필드를 검색할 JSON입니다. [`String`](/sql-reference/data-types/string)
* `field_name` — 검색할 필드의 이름입니다. [`const String`](/sql-reference/data-types/string)

**반환 값(Returned value)**

필드가 존재하면 구분자를 포함한 해당 필드의 값을 문자열로 반환하고, 존재하지 않으면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":{"def":[1,2,3]}}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractRaw(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
"-4e3"
-3.4
5
{"def":[1,2,3]}
```


## simpleJSONExtractString \{#simpleJSONExtractString\}

도입 버전: v21.4

`field_name`이라는 이름의 필드 값에서 큰따옴표로 둘러싸인 `String`을 파싱합니다.

**구현 세부 정보**

현재 기본 다국어 평면(BMP)에 속하지 않는 `\uXXXX\uYYYY` 형식의 코드 포인트는 지원되지 않습니다. 이러한 코드 포인트는 UTF-8이 아니라 CESU-8로 변환됩니다.

**구문**

```sql
simpleJSONExtractString(json, field_name)
```

**별칭(Aliases)**: `visitParamExtractString`

**인자(Arguments)**

* `json` — 필드를 검색할 JSON. [`String`](/sql-reference/data-types/string)
* `field_name` — 검색할 필드 이름. [`const String`](/sql-reference/data-types/string)

**반환값(Returned value)**

구분 기호를 포함하여 필드의 이스케이프 해제된 값을 문자열로 반환합니다. 필드에 큰따옴표로 둘러싸인 문자열이 없거나, 이스케이프 해제에 실패하거나, 필드가 존재하지 않으면 빈 문자열을 반환합니다. [`String`](/sql-reference/data-types/string)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"\\n\\u0000"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263a"}');
INSERT INTO jsons VALUES ('{"foo":"hello}');

SELECT simpleJSONExtractString(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
\n\0

☺
```


## simpleJSONExtractUInt \{#simpleJSONExtractUInt\}

도입된 버전: v21.4

`field_name`이라는 이름의 필드 값에서 `UInt64`를 파싱합니다.
`field_name`이 문자열 필드인 경우, 문자열의 시작 부분에서 숫자 값을 파싱하려고 시도합니다.
필드가 존재하지 않거나, 존재하지만 숫자를 포함하지 않으면 `0`을 반환합니다.

**구문**

```sql
simpleJSONExtractUInt(json, field_name)
```

**별칭(Aliases)**: `visitParamExtractUInt`

**인수(Arguments)**

* `json` — 필드를 검색할 JSON입니다. [`String`](/sql-reference/data-types/string)
* `field_name` — 검색할 필드 이름입니다. [`const String`](/sql-reference/data-types/string)

**반환 값(Returned value)**

필드가 존재하고 숫자를 포함하는 경우 해당 필드에서 파싱된 숫자를 반환하고, 그렇지 않으면 `0`을 반환합니다. [`UInt64`](/sql-reference/data-types/int-uint)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"4e3"}');
INSERT INTO jsons VALUES ('{"foo":3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractUInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
4
0
3
5
```


## simpleJSONHas \{#simpleJSONHas\}

도입: v21.4

`field_name`이라는 필드가 존재하는지 확인합니다.

**구문**

```sql
simpleJSONHas(json, field_name)
```

**별칭(Aliases)**: `visitParamHas`

**인수(Arguments)**

* `json` — 필드를 검색할 JSON입니다. [`String`](/sql-reference/data-types/string)
* `field_name` — 검색할 필드의 이름입니다. [`const String`](/sql-reference/data-types/string)

**반환 값(Returned value)**

필드가 존재하면 `1`, 존재하지 않으면 `0`을 반환합니다. [`UInt8`](/sql-reference/data-types/int-uint)

**예시(Examples)**

**사용 예시(Usage example)**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONHas(json, 'foo') FROM jsons;
SELECT simpleJSONHas(json, 'bar') FROM jsons;
```

```response title=Response
1
0
```


## toJSONString \{#toJSONString\}

도입 버전: v21.7

값을 JSON 표현으로 직렬화합니다. 다양한 데이터 타입과 중첩 구조를 지원합니다.
64비트 [정수](../data-types/int-uint.md) 또는 그보다 큰 정수(예: `UInt64`, `Int128`)는 기본적으로 따옴표로 둘러싸입니다. 이 동작은 [output&#95;format&#95;json&#95;quote&#95;64bit&#95;integers](/operations/settings/formats#output_format_json_quote_64bit_integers) 설정으로 제어됩니다.
특수 값 `NaN` 및 `inf`는 `null`로 대체됩니다. 이를 그대로 표시하려면 [output&#95;format&#95;json&#95;quote&#95;denormals](/operations/settings/formats#output_format_json_quote_denormals) 설정을 활성화합니다.
[Enum](../data-types/enum.md) 값을 직렬화할 때 이 함수는 해당 이름을 출력합니다.

관련 항목:

* [output&#95;format&#95;json&#95;quote&#95;64bit&#95;integers](/operations/settings/formats#output_format_json_quote_64bit_integers)
* [output&#95;format&#95;json&#95;quote&#95;denormals](/operations/settings/formats#output_format_json_quote_denormals)

**구문**

```sql
toJSONString(value)
```

**인수**

* `value` — 직렬화할 값입니다. 값은 임의의 데이터 타입일 수 있습니다. [`Any`](/sql-reference/data-types)

**반환 값**

값의 JSON 표현을 반환합니다. [`String`](/sql-reference/data-types/string)

**예제**

**맵 직렬화**

```sql title=Query
SELECT toJSONString(map('key1', 1, 'key2', 2));
```

```response title=Response
┌─toJSONString(map('key1', 1, 'key2', 2))─┐
│ {"key1":1,"key2":2}                     │
└─────────────────────────────────────────┘
```

**특수값**

```sql title=Query
SELECT toJSONString(tuple(1.25, NULL, NaN, +inf, -inf, [])) SETTINGS output_format_json_quote_denormals = 1;
```

```response title=Response
┌─toJSONString(tuple(1.25, NULL, NaN, plus(inf), minus(inf), []))─┐
│ [1.25,null,"nan","inf","-inf",[]]                               │
└─────────────────────────────────────────────────────────────────┘
```

{/*AUTOGENERATED_END*/ }

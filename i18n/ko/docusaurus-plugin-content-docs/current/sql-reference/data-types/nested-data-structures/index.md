---
'description': 'ClickHouse에서 중첩 데이터 구조에 대한 개요'
'sidebar_label': 'Nested(Name1 Type1, Name2 Type2, ...)'
'sidebar_position': 57
'slug': '/sql-reference/data-types/nested-data-structures/nested'
'title': '중첩'
'doc_type': 'guide'
---


# Nested

## Nested(name1 Type1, Name2 Type2, ...) {#nestedname1-type1-name2-type2-}

중첩 데이터 구조는 셀 안의 테이블과 같습니다. 중첩 데이터 구조의 매개변수 – 컬럼 이름과 유형 – 는 [CREATE TABLE](../../../sql-reference/statements/create/table.md) 쿼리에서 지정하는 방식과 동일합니다. 각 테이블 행은 중첩 데이터 구조의 행 수에 해당할 수 있습니다.

예시:

```sql
CREATE TABLE test.visits
(
    CounterID UInt32,
    StartDate Date,
    Sign Int8,
    IsNew UInt8,
    VisitID UInt64,
    UserID UInt64,
    ...
    Goals Nested
    (
        ID UInt32,
        Serial UInt32,
        EventTime DateTime,
        Price Int64,
        OrderID String,
        CurrencyID UInt32
    ),
    ...
) ENGINE = CollapsingMergeTree(StartDate, intHash32(UserID), (CounterID, StartDate, intHash32(UserID), VisitID), 8192, Sign)
```

이 예시는 변환(목표 도달)에 대한 데이터를 포함하는 `Goals` 중첩 데이터 구조를 선언합니다. 'visits' 테이블의 각 행은 0개 또는 그 이상의 변환에 해당할 수 있습니다.

[flatten_nested](/operations/settings/settings#flatten_nested)가 `0`으로 설정되어 있을 때(기본값은 아님), 임의의 중첩 수준을 지원합니다.

대부분의 경우 중첩 데이터 구조로 작업할 때, 해당 컬럼은 점으로 구분된 컬럼 이름으로 지정됩니다. 이러한 컬럼은 일치하는 유형의 배열을 구성합니다. 단일 중첩 데이터 구조의 모든 컬럼 배열은 동일한 길이를 가집니다.

예시:

```sql
SELECT
    Goals.ID,
    Goals.EventTime
FROM test.visits
WHERE CounterID = 101500 AND length(Goals.ID) < 5
LIMIT 10
```

```text
┌─Goals.ID───────────────────────┬─Goals.EventTime───────────────────────────────────────────────────────────────────────────┐
│ [1073752,591325,591325]        │ ['2014-03-17 16:38:10','2014-03-17 16:38:48','2014-03-17 16:42:27']                       │
│ [1073752]                      │ ['2014-03-17 00:28:25']                                                                   │
│ [1073752]                      │ ['2014-03-17 10:46:20']                                                                   │
│ [1073752,591325,591325,591325] │ ['2014-03-17 13:59:20','2014-03-17 22:17:55','2014-03-17 22:18:07','2014-03-17 22:18:51'] │
│ []                             │ []                                                                                        │
│ [1073752,591325,591325]        │ ['2014-03-17 11:37:06','2014-03-17 14:07:47','2014-03-17 14:36:21']                       │
│ []                             │ []                                                                                        │
│ []                             │ []                                                                                        │
│ [591325,1073752]               │ ['2014-03-17 00:46:05','2014-03-17 00:46:05']                                             │
│ [1073752,591325,591325,591325] │ ['2014-03-17 13:28:33','2014-03-17 13:30:26','2014-03-17 18:51:21','2014-03-17 18:51:45'] │
└────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────┘
```

중첩 데이터 구조를 동일한 길이의 여러 컬럼 배열 집합으로 생각하는 것이 가장 쉽습니다.

SELECT 쿼리가 개별 컬럼 대신 전체 중첩 데이터 구조의 이름을 지정할 수 있는 유일한 곳은 ARRAY JOIN 절입니다. 자세한 내용은 "ARRAY JOIN 절"을 참조하십시오. 예시:

```sql
SELECT
    Goal.ID,
    Goal.EventTime
FROM test.visits
ARRAY JOIN Goals AS Goal
WHERE CounterID = 101500 AND length(Goals.ID) < 5
LIMIT 10
```

```text
┌─Goal.ID─┬──────Goal.EventTime─┐
│ 1073752 │ 2014-03-17 16:38:10 │
│  591325 │ 2014-03-17 16:38:48 │
│  591325 │ 2014-03-17 16:42:27 │
│ 1073752 │ 2014-03-17 00:28:25 │
│ 1073752 │ 2014-03-17 10:46:20 │
│ 1073752 │ 2014-03-17 13:59:20 │
│  591325 │ 2014-03-17 22:17:55 │
│  591325 │ 2014-03-17 22:18:07 │
│  591325 │ 2014-03-17 22:18:51 │
│ 1073752 │ 2014-03-17 11:37:06 │
└─────────┴─────────────────────┘
```

전체 중첩 데이터 구조에 대해 SELECT를 수행할 수 없습니다. 그 일부인 개별 컬럼만 명시적으로 나열할 수 있습니다.

INSERT 쿼리의 경우, 중첩 데이터 구조의 모든 구성 컬럼 배열을 별도로 전달해야 합니다(각각 개별 컬럼 배열인 것처럼). 삽입하는 동안 시스템은 이들의 길이가 동일한지 확인합니다.

DESCRIBE 쿼리에서는 중첩 데이터 구조의 컬럼이 동일한 방식으로 별도로 나열됩니다.

중첩 데이터 구조의 요소에 대한 ALTER 쿼리는 제한 사항이 있습니다.

---
'slug': '/optimize/skipping-indexes'
'sidebar_label': '데이터 스킵 인덱스'
'sidebar_position': 2
'description': '스킵 인덱스는 ClickHouse가 일치하는 값이 없다는 것이 보장된 데이터의 중요한 청크를 읽는 것을 건너뛰도록 합니다.'
'title': 'Understanding ClickHouse 데이터 스킵 인덱스'
'doc_type': 'guide'
'keywords':
- 'skipping indexes'
- 'data skipping'
- 'performance'
- 'indexing'
- 'best practices'
---

import simple_skip from '@site/static/images/guides/best-practices/simple_skip.png';
import bad_skip from '@site/static/images/guides/best-practices/bad_skip.png';
import Image from '@theme/IdealImage';



# ClickHouse 데이터 스킵 인덱스 이해하기

## 소개 {#introduction}

여러 요인이 ClickHouse 쿼리 성능에 영향을 미칩니다. 대부분의 시나리오에서 중요한 요소는 ClickHouse가 쿼리 WHERE 절 조건을 평가할 때 기본 키를 사용할 수 있는지 여부입니다. 따라서 가장 일반적인 쿼리 패턴에 적용되는 기본 키를 선택하는 것은 효과적인 테이블 설계를 위해 필수적입니다.

그럼에도 불구하고 기본 키가 얼마나 세심하게 조정되었든, 효율적으로 사용할 수 없는 쿼리 사용 사례가 불가피하게 발생합니다. 사용자는 일반적으로 ClickHouse를 시계열 데이터에 의존하지만 종종 고객 ID, 웹사이트 URL 또는 제품 번호와 같은 다른 비즈니스 차원에 따라 동일한 데이터를 분석하기를 원합니다. 이 경우 WHERE 절 조건을 적용하기 위해 각 컬럼 값을 전체 스캔해야 할 수 있기 때문에 쿼리 성능이 상당히 저하될 수 있습니다. ClickHouse는 이러한 상황에서도 여전히 상대적으로 빠르지만, 수백만 또는 수십억 개의 개별 값을 평가하면 "비인덱스" 쿼리가 기본 키를 기반으로 한 쿼리보다 훨씬 느리게 실행됩니다.

전통적인 관계형 데이터베이스에서는 이 문제를 해결하기 위해 테이블에 하나 이상의 "보조" 인덱스를 추가하는 접근 방식이 있습니다. 이것은 데이터베이스가 O(n) 시간(테이블 스캔) 대신 O(log(n)) 시간에 디스크에서 모든 일치하는 행을 찾을 수 있도록 허용하는 b-tree 구조입니다. 그러나 이러한 유형의 보조 인덱스는 ClickHouse(또는 다른 컬럼 지향 데이터베이스)에서 작동하지 않습니다. 그 이유는 디스크에 인덱스에 추가할 개별 행이 없기 때문입니다.

대신 ClickHouse는 특정 상황에서 쿼리 속도를 크게 향상시킬 수 있는 다른 유형의 인덱스를 제공합니다. 이러한 구조는 ClickHouse가 일치하는 값이 없음을 보장하는 데이터의 중요한 덩어리를 읽는 것을 건너뛸 수 있게 해주기 때문에 "스킵" 인덱스라고 불립니다.

## 기본 작동 방식 {#basic-operation}

사용자는 MergeTree 계열 테이블에 대해서만 데이터 스킵 인덱스를 사용할 수 있습니다. 각 데이터 스킵 인덱스는 네 가지 주요 인수를 가집니다:

- 인덱스 이름. 인덱스 이름은 각 파티션에 인덱스 파일을 만드는 데 사용됩니다. 또한, 인덱스를 삭제하거나 물리화할 때 매개변수로 필요합니다.
- 인덱스 표현식. 인덱스 표현식은 인덱스에 저장되는 값 집합을 계산하는 데 사용됩니다. 이는 컬럼, 간단한 연산자 및/또는 인덱스 유형에 따라 결정된 함수의 조합이 될 수 있습니다.
- TYPE. 인덱스 유형은 각 인덱스 블록을 읽고 평가하는 것을 건너뛰는 것이 가능한지를 결정하는 계산을 제어합니다.
- GRANULARITY. 각 인덱스 블록은 GRANULARITY 개의 과립으로 구성됩니다. 예를 들어, 기본 테이블 인덱스의 과립성이 8192 행이 되고 인덱스 과립성이 4이면 각 인덱스 "블록"은 32768 행이 됩니다.

사용자가 데이터 스킵 인덱스를 생성할 때, 테이블의 각 데이터 파트 디렉토리에는 두 개의 추가 파일이 생성됩니다.

- `skp_idx_{index_name}.idx`, 이 파일에는 정렬된 표현식 값이 포함됩니다.
- `skp_idx_{index_name}.mrk2`, 이 파일에는 관련 데이터 컬럼 파일에 대한 오프셋이 포함됩니다.

쿼리 실행 시 WHERE 절 필터링 조건의 일부가 스킵 인덱스 표현식과 일치하고 관련 컬럼 파일을 읽을 때 ClickHouse는 인덱스 파일 데이터를 사용하여 처리해야 할 각 관련 데이터 블록이 있는지 여부를 결정합니다. 예를 들어, 다음과 같이 예를 들어 설명할 수 있습니다.

```sql
CREATE TABLE skip_table
(
  my_key UInt64,
  my_value UInt64
)
ENGINE MergeTree primary key my_key
SETTINGS index_granularity=8192;

INSERT INTO skip_table SELECT number, intDiv(number,4096) FROM numbers(100000000);
```

기본 키를 사용하지 않는 간단한 쿼리를 실행할 때, `my_value` 컬럼의 1억 개 항목이 모두 스캔됩니다:

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.079 sec. Processed 100.00 million rows, 800.10 MB (1.26 billion rows/s., 10.10 GB/s.
```

이제 매우 기본적인 스킵 인덱스를 추가하세요:

```sql
ALTER TABLE skip_table ADD INDEX vix my_value TYPE set(100) GRANULARITY 2;
```

일반적으로 스킵 인덱스는 새로 삽입된 데이터에만 적용되므로, 인덱스를 추가하는 것만으로는 위의 쿼리에 영향을 주지 않습니다.

기존 데이터에 인덱스를 추가하려면 다음 문장을 사용하세요:

```sql
ALTER TABLE skip_table MATERIALIZE INDEX vix;
```

새로 생성된 인덱스로 쿼리를 다시 실행하세요:

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.051 sec. Processed 32.77 thousand rows, 360.45 KB (643.75 thousand rows/s., 7.08 MB/s.)
```

800 메가바이트의 1억 행을 처리하는 대신, ClickHouse는 360킬로바이트의 32768 행만 읽고 분석했습니다 -- 각 8192 행으로 구성된 4개의 과립입니다.

보다 시각적으로, 다음은 `my_value` 값이 125인 4096 행이 읽히고 선택된 방법과, 어떻게 없음 읽지 않고 다음 행이 스킵되었는지입니다:

<Image img={simple_skip} size="md" alt="Simple Skip"/>

사용자는 쿼리 실행 시 추적을 활성화하여 스킵 인덱스 사용에 대한 자세한 정보를 확인할 수 있습니다. clickhouse-client에서 `send_logs_level`을 설정하세요:

```sql
SET send_logs_level='trace';
```
이것은 쿼리 SQL 및 테이블 인덱스를 조정할 때 유용한 디버깅 정보를 제공합니다. 위의 예에서 디버그 로그는 스킵 인덱스가 두 개의 과립을 제외했다는 것을 보여줍니다:

```sql
<Debug> default.skip_table (933d4b2c-8cea-4bf9-8c93-c56e900eefd1) (SelectExecutor): Index `vix` has dropped 6102/6104 granules.
```
## 스킵 인덱스 유형 {#skip-index-types}

<!-- vale off -->
### minmax {#minmax}
<!-- vale on -->

이 경량 인덱스 유형은 매개변수가 필요 없습니다. 각 블록에 대한 인덱스 표현식의 최소값과 최대값을 저장합니다(표현식이 튜플인 경우, 각 튜플 요소의 값을 별도로 저장합니다). 이 유형은 값에 따라 느슨하게 정렬되는 경향이 있는 컬럼에 이상적입니다. 이 인덱스 유형은 쿼리 처리 중 적용 비용이 가장 낮은 경우가 많습니다.

이 유형의 인덱스는 스칼라 또는 튜플 표현식에서만 올바르게 작동합니다 -- 인덱스는 배열이나 맵 데이터 유형을 반환하는 표현식에는 절대로 적용되지 않습니다.

<!-- vale off -->
### set {#set}
<!-- vale on -->

이 경량 인덱스 유형은 블록당 값 집합의 max_size라는 단일 매개변수를 허용합니다(0은 무제한 수의 이산 값을 허용합니다). 이 집합은 블록의 모든 값을 포함합니다(값의 수가 max_size를 초과하면 비어 있습니다). 이 인덱스 유형은 각 과립 집합 내에서 낮은 카디널리티를 가진 컬럼(본질적으로 "뭉쳐져 있다")에 잘 작동하지만 전반적으로 높은 카디널리티를 갖습니다.

이 인덱스의 비용, 성능 및 효과는 블록 내의 카드inality에 따라 달라집니다. 각 블록에 많은 고유 값이 포함될 경우, 쿼리 조건을 대규모 인덱스 집합에 대해 평가하는 것은 매우 비싸거나, 인덱스가 max_size를 초과하여 비어 있어 적용되지 않을 수 있습니다.

### 블룸 필터 유형 {#bloom-filter-types}

*블룸 필터*는 약간의 거짓 긍정 가능성 비용으로 집합 멤버십 테스트를 공간 효율적으로 허용하는 데이터 구조입니다. 스킵 인덱스의 경우 거짓 긍정이 심각한 문제는 아닙니다. 왜냐하면 유일한 단점이 몇 개의 불필요한 블록을 읽는 것이기 때문입니다. 그러나 거짓 긍정의 가능성 때문에 인덱스 표현식이 참으로 예상되어야 하며, 그렇지 않으면 유효한 데이터가 스킵될 수 있습니다.

블룸 필터는 많은 이산 값을 테스트하는 데 더 효율적으로 처리할 수 있으므로, 더 많은 값을 생성하는 조건부 표현식에 적합할 수 있습니다. 특히, 블룸 필터 인덱스는 배열에 적용할 수 있으며, 배열의 모든 값이 테스트되고 맵의 경우 mapKeys 또는 mapValues 함수를 사용하여 키나 값을 배열로 변환합니다.

블룸 필터에 기반한 세 가지 데이터 스킵 인덱스 유형이 있습니다:

* 기본 **bloom_filter**는 허용된 "거짓 긍정" 비율을 정수형 매개변수로 받습니다. 이 비율은 0과 1 사이일 수 있으며(명시되지 않으면 .025가 사용됩니다).

* 전문화된 **tokenbf_v1**. 이 인덱스는 세 가지 매개변수를 가지며 모두 블룸 필터 조정과 관련됩니다: (1) 필터 크기(바이트), (2) 적용되는 해시 함수의 수, (3) 블룸 필터 해시 함수의 시드. 이 매개변수가 블룸 필터 기능에 미치는 영향에 대한 자세한 내용은 [여기](https://hur.st/bloomfilter/)를 참조하십시오. 이 인덱스는 String, FixedString 및 Map 데이터 유형에 대해서만 작동합니다. 입력 표현식은 비알파벳 문자로 구분된 문자 시퀀스로 분리됩니다. 예를 들어, `This is a candidate for a "full text" search`라는 컬럼 값은 `This` `is` `a` `candidate` `for` `full` `text` `search`와 같은 토큰을 포함합니다. 이 인덱스는 LIKE, EQUALS, IN, hasToken() 및 긴 문자열 내의 단어 및 다른 값을 검색하는 유사한 검색에 사용됩니다. 예를 들어, 특정 클래스 이름이나 행 번호를 검색하는 것일 수 있습니다.

* 전문화된 **ngrambf_v1**. 이 인덱스는 토큰 인덱스와 동일하게 작동합니다. 블룸 필터 설정 이전에 인덱스할 ngram의 크기라는 추가 매개변수를 하나 받습니다. ngram은 길이 `n`의 문자 문자열로, 예를 들어 ngram 크기가 4인 경우 `A short string`은 다음과 같이 인덱스됩니다:
```text
'A sh', ' sho', 'shor', 'hort', 'ort ', 'rt s', 't st', ' str', 'stri', 'trin', 'ring'
```
이 인덱스는 특히 단어 경계가 없는 언어(예: 중국어) 텍스트 검색에도 유용할 수 있습니다.

## 스킵 인덱스 기능 {#skip-index-functions}

데이터 스킵 인덱스의 핵심 목적은 인기 있는 쿼리에 의해 분석되는 데이터의 양을 제한하는 것입니다. ClickHouse 데이터의 분석적 성격을 고려할 때, 이러한 쿼리의 패턴은 대부분 경우 함수 표현식을 포함합니다. 따라서 스킵 인덱스는 효율적이기 위해 일반적인 함수와 올바르게 상호 작용해야 합니다. 이는 다음과 같이 발생할 수 있습니다:
* 데이터가 삽입되고 인덱스가 함수 표현식으로 정의될 때(표현식의 결과가 인덱스 파일에 저장됨), 또는
* 쿼리가 처리되고 표현식이 저장된 인덱스 값에 적용되어 블록을 제외할지를 결정합니다.

각 유형의 스킵 인덱스는 인덱스 구현에 적합한 ClickHouse 함수의 하위 집합에서 작동합니다. 일반적으로 셋 인덱스 및 블룸 필터 기반 인덱스(다른 유형의 셋 인덱스)는 모두 비순서형이므로 범위와 함께 작동하지 않습니다. 반면에 minmax 인덱스는 범위에 특히 잘 작동합니다. 왜냐하면 범위가 교차하는지 여부를 결정하는 것이 매우 빠르기 때문입니다. 부분 일치 함수 LIKE, startsWith, endsWith 및 hasToken의 유효성은 사용된 인덱스 유형, 인덱스 표현식 및 데이터의 특정 형태에 따라 달라집니다.

## 스킵 인덱스 설정 {#skip-index-settings}

스킵 인덱스에 적용할 수 있는 두 가지 설정이 있습니다.

* **use_skip_indexes** (0 또는 1, 기본값 1). 모든 쿼리가 스킵 인덱스를 효율적으로 사용할 수는 없습니다. 특정 필터링 조건이 대부분의 과립을 포함할 가능성이 높은 경우 데이터 스킵 인덱스를 적용하면 불필요하고 때로는 상당한 비용이 발생합니다. 스킵 인덱스로부터 이익을 얻기 어려운 쿼리에 대해서는 값을 0으로 설정하세요.
* **force_data_skipping_indices** (쉼표로 구분된 인덱스 이름 목록). 이 설정은 비효율적인 쿼리의 특정 종류를 방지하는 데 사용될 수 있습니다. 스킵 인덱스를 사용하지 않으면 테이블을 쿼리하는 것이 너무 비쌀 경우 이 설정을 하나 이상의 인덱스 이름과 함께 사용하면 지정된 인덱스를 사용하지 않는 모든 쿼리에 대해 예외가 반환됩니다. 이는 잘못 작성된 쿼리가 서버 리소스를 소모하는 것을 방지합니다.

## 스킵 인덱스 최선의 실천 {#skip-best-practices}

스킵 인덱스는 직관적이지 않으며, 특히 RDMS 영역의 보조 행 기반 인덱스나 문서 저장소의 역 인덱스에 익숙한 사용자에게는 더욱 그렇습니다. 어떤 이점을 얻으려면 ClickHouse 데이터 스킵 인덱스를 적용할 때 인덱스 계산 비용을 상쇄하기 위해 충분한 과립 읽기를 회피해야 합니다. 특히 인덱스가 있는 블록에서 값이 한 번이라도 나타나면 전체 블록을 메모리로 읽고 평가해야 하므로 인덱스 비용이 불필요하게 발생합니다.

다음 데이터 분포를 고려해보세요:

<Image img={bad_skip} size="md" alt="Bad Skip"/>

기본/정렬 키가 `timestamp`이고 `visitor_id`에 대한 인덱스가 있다고 가정합니다. 다음 쿼리를 고려해 보세요:

```sql
SELECT timestamp, url FROM table WHERE visitor_id = 1001`
```

전통적인 보조 인덱스는 이러한 데이터 분포에서 매우 유리할 것입니다. 요청된 visitor_id를 가진 5개의 행을 찾기 위해 32768개의 모든 행을 읽는 대신, 보조 인덱스는 단지 5개의 행 위치만 포함되며, 오직 그 5개 행만 디스크에서 읽혀질 것입니다. ClickHouse 데이터 스킵 인덱스에서는 그와 정반대의 일이 발생합니다. `visitor_id` 컬럼의 32768개의 모든 값이 스킵 인덱스의 유형에 관계없이 테스트됩니다.

따라서 ClickHouse 쿼리를 단순히 중요한 컬럼에 인덱스를 추가하여 빠르게 하려는 자연스러운 충동은 종종 잘못됩니다. 이 고급 기능은 [기본 키 선택 방법](../best-practices/sparse-primary-indexes.md)을 수정하는 것과 같은 다른 대안을 조사한 후에만 사용해야 합니다. 프로젝션 또는 물리화된 뷰를 사용하는 것 등도 마찬가지입니다. 데이터 스킵 인덱스가 적합한 경우에도 인덱스와 테이블 모두를 신중하게 조정하는 것이 종종 필요합니다.

대부분의 경우 유용한 스킵 인덱스는 기본 키와 대상 비기본 컬럼/표현식 간에 강한 상관 관계가 필요합니다. 상관 관계가 없을 경우(위 도표와 같이), 수천 개의 값 블록에서 필터링 조건을 충족하는 행이 있을 가능성이 높고 많은 블록이 스킵됩니다. 반면에 기본 키에 대한 값의 범위(예: 하루의 시간)가 잠재적 인덱스 컬럼의 값(예: TV 시청자 연령)과 강하게 연관되어 있다면, minmax 유형의 인덱스가 유익할 가능성이 높습니다. 데이터를 삽입할 때 서행/ORDER BY 키에 추가 컬럼을 포함하거나 삽입 시 기본 키와 관련된 값이 그룹화되도록 배치하여 이 상관 관계를 높이는 것이 가능할 수 있습니다. 예를 들어, 특정 site_id에 대한 모든 이벤트가 삽입 프로세스로 함께 그룹화 및 삽입될 수 있으며, 기본 키가 여러 사이트에서 수집한 이벤트를 포함하는 타임스탬프라고 할지라도 스킵 인덱스 검색 시 많은 블록이 스킵될 수 있습니다.

스킵 인덱스의 또 다른 좋은 후보는 데이터에서 어떤 값이 상대적으로 희소한 고카디널리티 표현식입니다. 한 예로는 API 요청에서 오류 코드를 추적하는 관찰 플랫폼이 있을 수 있습니다. 특정 오류 코드는 데이터에서 드물지만 검색에 특히 중요할 수 있습니다. error_code 컬럼에 대한 스킵 인덱스는 오류가 없는 대부분의 블록을 건너뛰게 하여 오류 중심 쿼리를 상당히 개선할 수 있습니다.

마지막으로, 핵심 최선의 실천은 테스트, 테스트, 테스트입니다. 다시 말해, b-tree 보조 인덱스나 문서 검색을 위한 역 인덱스와 달리 데이터 스킵 인덱스의 동작은 쉽게 예측할 수 없습니다. 테이블에 추가하는 것은 데이터 수집 및 인덱스의 혜택을 받지 못하는 쿼리에 상당한 비용을 발생시킵니다. 항상 실제 데이터 유형에서 테스트해야 하며, 테스트에는 유형, 과립 크기 및 기타 매개변수의 변형이 포함되어야 합니다. 테스트는 종종 생각 실험만으로는 명백하지 않은 패턴과 함정을 드러냅니다.

## 관련 문서 {#related-docs}
- [최선의 실천 가이드](/best-practices/use-data-skipping-indices-where-appropriate)
- [데이터 스킵 인덱스 예제](/optimize/skipping-indexes/examples)
- [데이터 스킵 인덱스 조작하기](/sql-reference/statements/alter/skipping-index)
- [시스템 테이블 정보](/operations/system-tables/data_skipping_indices)

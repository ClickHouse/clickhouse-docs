---
'slug': '/managing-data/materialized-views-versus-projections'
'sidebar_label': '물리화된 뷰 대 프로젝션'
'title': '물리화된 뷰 대 프로젝션'
'hide_title': false
'description': 'ClickHouse에서 물리화된 뷰와 프로젝션을 비교하는 기사로, 사용 사례, 성능 및 제한 사항을 포함합니다.'
'doc_type': 'reference'
'keywords':
- 'materialized views'
- 'projections'
- 'differences'
---

> 사용자로부터 자주 받는 질문은 물리화된 뷰와 프로젝션을 언제 사용해야 하는가입니다. 이 기사에서는 두 가지의 주요 차이점과 특정 시나리오에서 하나를 선택하고자 하는 이유를 탐구합니다.

## 주요 차이점 요약 {#key-differences}

아래 표는 물리화된 뷰와 프로젝션 간의 주요 차이점을 여러 고려 사항에 대해 요약하고 있습니다.

| Aspect                                                                           | Materialized views                                                                                                                                                                                                                                                                                                                                                       | Projections                                                                                                                                                                                                                                                                                            |
|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 데이터 저장 및 위치                                                            | 결과를 **별도의 명시적 대상 테이블**에 저장하며, 소스 테이블에 삽입할 때 삽입 트리거 역할을 합니다.                                                                                                                                                                                                                                                                 | 프로젝션은 최적화된 데이터 레이아웃을 생성하며, 물리적으로 **주 테이블 데이터와 나란히 저장**되고 사용자에게는 보이지 않습니다.                                                                                                                                                                  |
| 업데이트 메커니즘                                                                | 소스 테이블에 대한 `INSERT`에 대해 **동기식**으로 작동합니다(증분 물리화된 뷰의 경우). 참고: 새로 고칠 수 있는 물리화된 뷰를 사용하여 **일정화**할 수도 있습니다.                                                                                                                                                                                               | 주요 테이블에 대한 `INSERT` 시 백그라운드에서 **비동기식**으로 업데이트됩니다.                                                                                                                                                                                                                            |
| 쿼리 상호작용                                                                  | 물리화된 뷰와 작업하려면 **대상 테이블을 직접 쿼리**해야 하며, 사용자는 쿼리를 작성할 때 물리화된 뷰의 존재를 인식해야 합니다.                                                                                                                                                                                        | 프로젝션은 ClickHouse의 쿼리 최적화기가 **자동으로 선택**하며, 사용자가 물리화된 데이터가 포함된 테이블의 쿼리를 수정할 필요가 없도록 투명합니다. 버전 25.6부터는 두 개 이상의 프로젝션으로 필터링하는 것도 가능해졌습니다. |
| `UPDATE` / `DELETE` 처리                                                        | **소스 테이블에 대한 `UPDATE` 또는 `DELETE` 작업**에 자동으로 반응하지 않으며, 물리화된 뷰는 소스 테이블에 대한 지식이 없고 오직 소스 테이블에 대한 삽입 트리거 역할만 합니다. 이로 인해 소스 테이블과 대상 테이블 간의 데이터 노후화가 발생할 수 있으며, 해결 방법이나 주기적 전체 새로 고침이 필요합니다(새로 고칠 수 있는 물리화된 뷰를 통해). | 기본적으로 `DELETED` 행과 **호환되지 않습니다**(특히 경량 삭제). `lightweight_mutation_projection_mode` (v24.7+)를 사용하면 호환성을 활성화할 수 있습니다.                                                                                                                                       |
| `JOIN` 지원                                                                    | 예. 새로 고칠 수 있는 물리화된 뷰는 복잡한 비정규화를 위해 사용할 수 있습니다. 증분 물리화된 뷰는 가장 왼쪽 테이블 삽입에서만 트리거됩니다.                                                                                                                                                                                                                     | 아니요. 물리화된 데이터를 필터링하기 위한 프로젝션 정의 내에서 `JOIN` 작업은 지원되지 않습니다.                                                                                                                                                                                             |
| 정의에서의 `WHERE` 절                                                        | 예. 물리화 전에 데이터를 필터링하기 위해 `WHERE` 절을 포함할 수 있습니다.                                                                                                                                                                                                                                                                                              | 아니요. 물리화된 데이터를 필터링하기 위한 프로젝션 정의 내에서 `WHERE` 절은 지원되지 않습니다.                                                                                                                                                                                               |
| 체인 가능성                                                                   | 예, 하나의 물리화된 뷰의 대상 테이블은 다른 물리화된 뷰를 위한 소스가 될 수 있어 다단계 파이프라인을 가능하게 합니다.                                                                                                                                                                                                                                          | 아니요. 프로젝션은 체인할 수 없습니다.                                                                                                                                                                                                                                                                     |
| 적용 가능한 테이블 엔진                                                       | 다양한 소스 테이블 엔진과 함께 사용할 수 있지만, 대상 테이블은 대부분 `MergeTree` 계열입니다.                                                                                                                                                                                                                                                                  | **오직 `MergeTree` 계열 테이블 엔진**에서만 사용 가능합니다.                                                                                                                                                                                                                                               |
| 오류 처리                                                                     | 데이터 삽입 중 오류가 발생하면 대상 테이블의 데이터가 손실되어 일관성 문제로 이어질 수 있습니다.                                                                                                                                                                                                                                                           | 오류는 백그라운드에서 **조용하게** 처리됩니다. 쿼리는 물리화된 부분과 비물리화된 부분을 원활하게 혼합할 수 있습니다.                                                                                                                                                                                 |
| 운영 오버헤드                                                                   | 명시적 대상 테이블 생성을 요구하며 종종 수동으로 다시 채워야 합니다. `UPDATE`/`DELETE`와의 일관성을 관리하는 것은 복잡성을 증가시킵니다.                                                                                                                                                                                                                                  | 프로젝션은 자동으로 유지되고 동기화되며 일반적으로 더 낮은 운영 부담을 가집니다.                                                                                                                                                                                               |
| `FINAL` 쿼리 호환성                                                          | 일반적으로 호환되지만 대상 테이블에서 `GROUP BY`가 자주 필요합니다.                                                                                                                                                                                                                                                                                                  | **`FINAL` 쿼리**와는 작동하지 않습니다.                                                                                                                                                                                                                                                                  |
| 지연 물리화                                                                   | 예.                                                                                                                                                                                                                                                                                                                                                                     | 물리화 기능을 사용할 때 프로젝션 호환성 문제를 모니터링하세요. `query_plan_optimize_lazy_materialization = false`로 설정해야 할 수도 있습니다.                                                                                                                                                |
| 병렬 복제본                                                                   | 예.                                                                                                                                                                                                                                                                                                                                                                     | 아니요.                                                                                                                                                                                                                                                                                                    |
| [`optimize_read_in_order`](/operations/settings/settings#optimize_read_in_order) | 예.                                                                                                                                                                                                                                                                                                                                                                     | 예.                                                                                                                                                                                                                                                                                                   |
| 경량 업데이트 및 삭제                                                         | 예.                                                                                                                                                                                                                                                                                                                                                                     | 아니요.                                                                                                                                                                                                                                                                                                    |

## 물리화된 뷰와 프로젝션 비교 {#choose-between}

### 물리화된 뷰 선택 시기 {#choosing-materialized-views}

다음과 같은 경우 물리화된 뷰 사용을 고려해야 합니다:

- **실시간 ETL 및 다단계 데이터 파이프라인** 작업 시: 복잡한 변환, 집계 또는 데이터 도착 시 라우팅을 수행해야 하며, 여러 단계에 걸쳐 뷰를 체인할 가능성이 있습니다.
- **복잡한 비정규화**가 필요한 경우: 여러 소스(테이블, 서브쿼리 또는 딕셔너리)의 데이터를 사전 조인하여 단일 쿼리 최적화 테이블을 생성해야 하며, 특히 새로 고칠 수 있는 물리화된 뷰를 사용하여 주기적으로 전체 새로 고침이 허용되는 경우.
- **명시적 스키마 제어**를 원할 경우: 사전 계산된 결과에 대한 별도의 고유한 대상 테이블이 필요하며, 더 큰 유연성을 제공하는 스키마와 엔진을 원할 경우.
- **수집 시 필터링**을 원할 경우: 데이터를 물리화되기 _전에_ 필터링해야 하며, 대상 테이블에 기록되는 데이터 양을 줄여야 합니다.

### 물리화된 뷰 사용을 피해야 할 때 {#avoid-materialized-views}

다음과 같은 경우 물리화된 뷰 사용을 피해야 합니다:

- **소스 데이터가 자주 업데이트되거나 삭제되는 경우**: 소스 테이블과 대상 테이블 간의 일관성을 처리하기 위한 추가 전략 없이 증분 물리화된 뷰가 노후화되고 불일치해질 수 있습니다.
- **단순성과 자동 최적화가 선호되는 경우**: 별도의 대상 테이블 관리를 피하고자 한다면.

### 프로젝션 선택 시기 {#choosing-projections}

다음과 같은 경우 프로젝션 사용을 고려해야 합니다:

- **단일 테이블의 쿼리 최적화**: 기본 목표는 단일 기본 테이블에 대한 쿼리를 가속화하는 것으로, 대체 정렬 순서를 제공하거나 기본 키의 일부가 아닌 컬럼에 대한 필터를 최적화하거나 단일 테이블에 대한 집계를 사전 계산합니다.
- **쿼리 투명성**을 원할 경우: 쿼리가 수정 없이 원본 테이블을 대상으로 하며, ClickHouse가 주어진 쿼리에 대한 최상의 데이터 레이아웃을 선택하도록 합니다.

### 프로젝션 사용을 피해야 할 때 {#avoid-projections}

다음과 같은 경우 프로젝션 사용을 피해야 합니다:

- **복잡한 데이터 변환 또는 다단계 ETL이 필요한 경우**: 프로젝션은 정의 내에서 `JOIN` 작업을 지원하지 않으며, 다단계 파이프라인을 구축하거나 윈도우 함수 또는 복잡한 `CASE` 문과 같은 일부 SQL 기능을 처리할 수 없습니다. 따라서 복잡한 데이터 변환에는 적합하지 않습니다.
- **물리화된 데이터의 명시적 필터링이 필요한 경우**: 프로젝션 정의 내에서 데이터가 물리화되는 것을 필터링하기 위한 `WHERE` 절을 지원하지 않으므로.
- **비-MergeTree 테이블 엔진을 사용하는 경우**: 프로젝션은 오직 `MergeTree` 계열 엔진에서만 사용할 수 있습니다.
- `FINAL` 쿼리가 필수인 경우: 프로젝션은 때때로 중복 제거에 사용되는 `FINAL` 쿼리와 작동하지 않습니다.
- [병렬 복제본](/deployment-guides/parallel-replicas)이 필요한 경우: 이는 프로젝션과 호환되지 않습니다.

## 요약 {#summary}

물리화된 뷰와 프로젝션은 쿼리를 최적화하고 데이터를 변환하는 강력한 도구이며, 일반적으로 두 가지 중 하나를 사용하는 것을 고려하지 않는 것이 좋습니다. 대신, 쿼리를 최대한 활용하기 위해 상호 보완적으로 사용할 수 있습니다. 따라서 ClickHouse에서 물리화된 뷰와 프로젝션 중 어떤 것을 선택할지는 귀하의 특정 사용 사례와 접근 패턴에 달려 있습니다.

일반적인 경험칙으로, 소스 테이블 하나 이상에서 데이터를 집계하거나 대규모로 복잡한 변환을 수행할 필요가 있을 때 물리화된 뷰를 사용하는 것을 고려해야 합니다. 물리화된 뷰는 비싼 집계 작업을 쿼리 시간에서 삽입 시간으로 이동하는 데 탁월합니다. 일일 또는 월간 롤업, 실시간 대시보드 또는 데이터 요약에 훌륭한 선택입니다. 

반면, 테이블의 기본 키와 다르게 필터링하는 쿼리를 최적화해야 할 때는 프로젝션을 사용해야 합니다. 이 키는 디스크에서 데이터의 물리적 정렬을 결정합니다. 기본 키를 변경할 수 없거나 접근 패턴이 기본 키가 수용할 수 있는 것보다 더 다양할 때 특히 유용합니다.

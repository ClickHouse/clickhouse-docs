---
sidebar_label: '용어집'
description: '이 페이지에는 ClickHouse와 관련해 일반적으로 사용되는 용어와 표현 및 그 정의가 정리되어 있습니다.'
title: '용어집'
slug: /concepts/glossary
keywords: ['용어집', '정의', '용어']
doc_type: 'reference'
---

{/* no-glossary */ }


# 용어집 \{#glossary\}

## 원자성 \{#atomicity\}

원자성은 트랜잭션(일련의 데이터베이스 연산)을 하나의 더 이상 나눌 수 없는 단위로 취급하도록 보장합니다. 이는 트랜잭션 내의 모든 연산이 모두 수행되거나, 아니면 전혀 수행되지 않는다는 의미입니다. 원자성을 가진 트랜잭션의 예로는 한 은행 계좌에서 다른 은행 계좌로 돈을 이체하는 작업을 들 수 있습니다. 이체 과정의 어느 한 단계라도 실패하면 트랜잭션이 실패하고, 돈은 최초 계좌에 그대로 남습니다. 원자성은 돈이 유실되거나 새로 생성되지 않도록 보장합니다.

## Block \{#block\}

Block은 데이터 처리와 저장을 조직하기 위한 논리적 단위입니다. 각 Block에는 쿼리 실행 시 성능을 향상하기 위해 함께 처리되는 열 지향 데이터가 포함됩니다. 데이터를 Block 단위로 처리하면 ClickHouse는 캐시 미스를 최소화하고 벡터화된 실행을 통해 CPU 코어를 효율적으로 활용합니다. ClickHouse는 LZ4, ZSTD, Delta와 같은 다양한 압축 알고리즘을 사용하여 Block 단위로 데이터를 압축합니다.

## 클러스터 \{#cluster\}

데이터를 저장하고 처리하기 위해 함께 동작하는 노드(서버)로 구성된 집합입니다.

## CMEK \{#cmek\}

고객이 관리하는 암호화 키(CMEK)를 사용하면 고객의 키 관리 서비스(KMS) 키로 ClickHouse 디스크 데이터 키를 암호화하여 디스크에 저장된 데이터를 보호할 수 있습니다.

## Dictionary \{#dictionary\}

딕셔너리는 여러 종류의 참조 목록에 유용한 key-value 쌍의 매핑 구조입니다. 쿼리에서 딕셔너리를 효율적으로 사용할 수 있게 해 주는 강력한 기능으로, 참조 테이블에 대한 `JOIN`을 사용하는 것보다 더 효율적인 경우가 많습니다.

## Distributed table \{#distributed-table\}

ClickHouse의 분산 테이블은 자체적으로 데이터를 저장하지 않고, 클러스터의 여러 서버에서 분산 쿼리 처리를 위해 통합된 뷰를 제공하는 특수한 유형의 테이블입니다.

## 그래뉼 \{#granule\}

그래뉼은 압축되지 않은 블록에서의 행 배치(행들의 묶음)입니다. 데이터를 읽을 때 ClickHouse는 개별 행이 아니라 그래뉼 단위로 접근하므로, 분석 워크로드에서 더 빠른 데이터 처리가 가능합니다. 기본적으로 하나의 그래뉼에는 8192개의 행이 포함됩니다. 프라이머리 인덱스(primary index)는 그래뉼마다 하나의 항목을 가집니다.

## Incremental materialized view \{#incremental-materialized-view\}

ClickHouse에서 증분형 materialized view는 데이터가 삽입되는 시점에 데이터를 처리하고 집계하는 materialized view의 한 종류입니다. 소스 테이블에 새 데이터가 삽입되면 이 materialized view는 미리 정의된 SQL 집계 쿼리를 새로 삽입된 블록에만 실행하고 집계된 결과를 대상 테이블에 기록합니다.

## 경량 업데이트 \{#lightweight-update\}

ClickHouse의 경량 업데이트는 실험적 기능으로, 표준 SQL의 UPDATE 구문을 사용하여 테이블의 행을 업데이트할 수 있도록 해줍니다. 다만 기존 뮤테이션에서처럼 전체 컬럼이나 데이터 파트를 다시 쓰는 대신, 업데이트된 컬럼과 행만을 포함하는 「패치 파트(patch parts)」를 생성합니다. 이러한 업데이트는 패치 적용을 통해 SELECT 쿼리에서 즉시 반영되지만, 물리적인 데이터는 이후 머지 작업 과정에서만 실제로 업데이트됩니다.

## Mark file \{#mark-file\}

ClickHouse의 마크 파일은 「마크(marks)」, 즉 ClickHouse가 특정 데이터 범위가 데이터 파일의 어느 위치에 저장되어 있는지 빠르게 찾을 수 있도록 도와주는 인덱스 항목을 저장하는 파일입니다.

## materialized view \{#materialized-view\}

ClickHouse의 materialized view는 소스 테이블에 데이터가 삽입될 때마다 해당 데이터에 대해 자동으로 쿼리를 실행하고, 변환되거나 집계된 결과를 별도의 대상 테이블에 저장하여 더 빠르게 쿼리할 수 있도록 하는 메커니즘입니다.

## MergeTree \{#mergetree\}

ClickHouse의 MergeTree는 높은 데이터 수집 속도와 대용량 데이터 처리를 위해 설계된 테이블 엔진입니다. ClickHouse의 핵심 스토리지 엔진으로서 열 지향 저장, 사용자 정의 파티션, 희소 기본 인덱스, 백그라운드에서의 데이터 병합 지원과 같은 기능을 제공합니다.

## Mutation \{#mutation\}

ClickHouse에서 뮤테이션(Mutation)은 일반적으로 `ALTER TABLE ... UPDATE` 또는 `ALTER TABLE ... DELETE`와 같은 명령을 사용하여 테이블의 기존 데이터를 수정하거나 삭제하는 작업을 의미합니다. 뮤테이션은 변경의 영향을 받는 전체 데이터 파트(part)를 다시 쓰는 비동기 백그라운드 프로세스로 구현되며, 개별 행(row)을 원본 위치에서 직접 수정하지 않습니다.

## 즉시 뮤테이션 \{#on-the-fly-mutation\}

ClickHouse의 즉시 뮤테이션은 뮤테이션이 제출된 직후, 백그라운드 뮤테이션 프로세스가 완료될 때까지 기다리지 않고도 이후의 SELECT 쿼리에서 업데이트나 삭제가 즉시 반영되도록 하는 메커니즘입니다.

## Parts \{#parts\}

테이블 데이터의 일부를 저장하는 디스크 상의 물리적 파일입니다. 이는 파티션 키를 사용하여 생성되는, 테이블 데이터의 논리적 구분인 파티션과는 다릅니다.

## Partitioning key \{#partitioning-key\}

ClickHouse에서 파티셔닝 키는 테이블을 생성할 때 `PARTITION BY` 절에 정의하는 SQL 표현식입니다. 이 키는 디스크에서 데이터가 파티션 단위로 논리적으로 어떻게 묶일지를 결정합니다. 파티셔닝 키의 각 고유 값은 별도의 물리적 파티션을 이루며, 이를 통해 전체 파티션을 삭제, 이동, 보관하는 등의 데이터 관리 작업을 효율적으로 수행할 수 있습니다.

## Primary key \{#primary-key\}

ClickHouse에서 기본 키는 디스크에 데이터가 저장되는 순서를 결정하며, 쿼리 필터링을 빠르게 하는 희소 인덱스를 만드는 데 사용됩니다. 기존 데이터베이스와 달리 ClickHouse의 기본 키는 고유성을 보장하지 않으므로, 여러 행이 동일한 기본 키 값을 가질 수 있습니다.

## Projection \{#projection\}

ClickHouse에서 projection은 쿼리 속도를 높이기 위해 데이터를 다른 순서로 저장하거나 미리 계산된 집계 결과를 저장하는, 숨겨져 있고 자동으로 관리되는 테이블입니다. 특히 기본 키에 포함되지 않은 컬럼을 기준으로 필터링하는 쿼리의 성능을 크게 향상합니다.

## 갱신 가능 구체화 뷰(refreshable materialized view) \{#refreshable-materialized-view\}

갱신 가능 구체화 뷰는 전체 데이터셋에 대해 쿼리를 주기적으로 다시 실행하여 그 결과를 대상 테이블에 저장하는 materialized view의 한 종류입니다. 증분형 materialized view와 달리, 갱신 가능 구체화 뷰는 스케줄에 따라 업데이트되며, 제한 없이 JOIN과 UNION을 포함한 복잡한 쿼리를 지원합니다.

## Replica \{#replica\}

ClickHouse 데이터베이스에 저장된 데이터의 복사본입니다. 동일한 데이터에 대해 원하는 개수만큼 레플리카를 두어 내결함성과 신뢰성을 확보할 수 있습니다. 레플리카는 ReplicatedMergeTree 테이블 엔진과 함께 사용되며, 이를 통해 ClickHouse는 서로 다른 서버에 분산된 여러 데이터 복사본을 동기화된 상태로 유지합니다.

## 세그먼트 \{#shard\}

데이터의 부분 집합입니다. ClickHouse에서는 항상 데이터에 대해 최소 1개의 세그먼트가 존재합니다. 데이터를 여러 서버에 분산하지 않으면 데이터는 하나의 세그먼트에 저장됩니다. 데이터를 여러 서버의 여러 세그먼트로 분산하면 단일 서버의 용량을 초과하는 경우 부하를 분산하는 데 활용할 수 있습니다.

## Skipping index \{#skipping-index\}

Skipping 인덱스는 연속된 여러 그래뉼 단위에서 소량의 메타데이터를 저장하여 ClickHouse가 불필요한 행을 스캔하지 않도록 합니다. Skipping 인덱스는 프로젝션에 대한 경량 대안을 제공합니다.

## 정렬 키 \{#sorting-key\}

ClickHouse에서 정렬 키는 디스크에 저장되는 행의 물리적 순서를 정의합니다. 기본 키를 지정하지 않으면 ClickHouse는 정렬 키를 기본 키로 사용합니다. 둘 다 지정하는 경우 기본 키는 정렬 키의 접두사여야 합니다.

## 희소 인덱스 \{#sparse-index\}

기본 인덱스가 하나의 행이 아니라 여러 행으로 이루어진 그룹마다 하나의 엔트리를 가지는 인덱싱 방식입니다. 행 그룹에 해당하는 엔트리를 「마크(mark)」라고 합니다. 희소 인덱스를 사용하면 ClickHouse는 먼저 쿼리에 일치할 가능성이 있는 행 그룹을 식별한 다음, 각 그룹을 개별적으로 처리하여 일치 항목을 찾습니다. 따라서 기본 인덱스는 메모리에 적재할 수 있을 만큼 충분히 작게 유지됩니다.

## 테이블 엔진 \{#table-engine\}

ClickHouse의 테이블 엔진은 데이터가 어떻게 쓰이고, 저장되고, 조회되는지를 결정합니다. MergeTree는 가장 많이 사용되는 테이블 엔진으로, 백그라운드에서 처리되는 대량의 데이터를 빠르게 삽입할 수 있도록 합니다.

## TTL \{#ttl\}

Time To Live (TTL)은(는) 일정 기간이 지난 후 컬럼이나 행을 자동으로 이동, 삭제 또는 롤업(rollup)하는 ClickHouse 기능입니다. 이를 통해 더 이상 자주 조회할 필요가 없는 데이터를 삭제, 이동 또는 아카이브하여 스토리지를 보다 효율적으로 관리할 수 있습니다.
---
slug: /deletes/overview
title: '삭제 개요'
description: 'ClickHouse에서 데이터를 삭제하는 방법'
keywords: ['delete', 'truncate', 'drop', '경량한 삭제']
doc_type: 'guide'
---

ClickHouse에서 데이터를 삭제하는 방법은 여러 가지가 있으며, 각 방법마다 장점과 성능 특성이 다릅니다. 데이터 모델과 삭제하려는 데이터의 규모에 따라 적절한 방법을 선택해야 합니다.

| Method | Syntax | When to use |
| --- | --- | --- |
| [경량한 삭제](/guides/developer/lightweight-delete) | `DELETE FROM [table]` | 적은 양의 데이터를 삭제할 때 사용합니다. 이후의 모든 SELECT 쿼리에서 해당 행은 즉시 필터링되지만, 처음에는 디스크에서 제거되지 않고 내부적으로만 삭제된 것으로 표시됩니다. |
| [삭제 mutation](/sql-reference/statements/alter/delete) | `ALTER TABLE [table] DELETE` | 데이터가 디스크에서 즉시 삭제되어야 할 때(예: 규정 준수를 위해) 사용합니다. SELECT 성능에 부정적인 영향을 줍니다. |
| [TRUNCATE 테이블](/sql-reference/statements/truncate) | `TRUNCATE TABLE [db.table]` | 테이블의 모든 데이터를 효율적으로 제거합니다. |
| [파티션 삭제(DROP)](/sql-reference/statements/alter/partition#drop-partitionpart) | `DROP PARTITION` | 파티션의 모든 데이터를 효율적으로 제거합니다. |

다음은 ClickHouse에서 데이터를 삭제하는 다양한 방법을 요약한 것입니다.

## 경량한 삭제 \{#lightweight-deletes\}

경량한 삭제는 행을 즉시 삭제된 것으로 표시하여 이후의 모든 `SELECT` 쿼리에서 자동으로 필터링되도록 합니다. 이렇게 표시된 행의 실제 제거는 자연스러운 머지 주기 동안의 머지 작업 과정에서 이루어지므로 I/O가 더 적게 발생합니다. 이로 인해 일정 기간 동안은 데이터가 스토리지에서 실제로 삭제되지 않고 삭제된 것으로만 표시되어 있을 수 있습니다. 데이터가 실제로 삭제되었음을 보장해야 하는 경우 위에서 설명한 mutation 명령을 사용하는 방안을 고려하십시오.

```sql
-- delete all data from 2018 with a lightweight delete. Not recommended.
DELETE FROM posts WHERE toYear(CreationDate) = 2018
```

경량한 `DELETE` 문을 사용하여 대량의 데이터를 삭제하면 `SELECT` 쿼리 성능에 부정적인 영향을 줄 수 있습니다. 이 명령은 또한 프로젝션이 있는 테이블에서는 사용할 수 없습니다.

삭제된 행을 [표시하는 작업](/sql-reference/statements/delete#how-lightweight-deletes-work-internally-in-clickhouse)에서 뮤테이션이 사용되며(`_row_exists` 컬럼을 추가), 이로 인해 일부 I/O가 발생합니다.

일반적으로 디스크에 삭제된 데이터가 계속 존재해도 문제가 없는 경우(예: 규정 준수가 요구되지 않는 경우)에는 경량한 삭제를 뮤테이션보다 우선해서 사용하는 것이 좋습니다. 그러나 모든 데이터를 완전히 삭제해야 하는 경우에는 이 방식은 피해야 합니다.

[경량한 삭제](/guides/developer/lightweight-delete)에 대해 더 자세히 알아보십시오.

## 삭제 뮤테이션 \{#delete-mutations\}

삭제 뮤테이션은 `ALTER TABLE ... DELETE` 명령을 통해 실행할 수 있습니다. 예를 들면 다음과 같습니다.

```sql
-- delete all data from 2018 with a mutation. Not recommended.
ALTER TABLE posts DELETE WHERE toYear(CreationDate) = 2018
```

해당 작업은 동기식(비복제 테이블인 경우 기본값) 또는 비동기식([mutations&#95;sync](/operations/settings/settings#mutations_sync) 설정에 따라)으로 실행될 수 있습니다. 이러한 작업은 해당 `WHERE` 표현식과 일치하는 모든 파트를 다시 쓰는, I/O 부하가 매우 큰 작업입니다. 이 과정에는 원자성이 없으며, 각 파트의 뮤테이션이 완료되는 즉시 해당 파트는 뮤테이션된 파트로 대체됩니다. 따라서 뮤테이션 실행 중에 시작되는 `SELECT` 쿼리는 이미 뮤테이션된 파트의 데이터와 아직 뮤테이션되지 않은 파트의 데이터를 함께 보게 됩니다. 사용자는 [system.mutations](/operations/system-tables/mutations#monitoring-mutations) 테이블을 통해 진행 상황을 추적할 수 있습니다. 이러한 작업은 I/O 집약적인 연산이므로 클러스터 `SELECT` 성능에 영향을 줄 수 있어, 가능한 한 드물게 사용하는 것이 좋습니다.

[삭제 뮤테이션](/sql-reference/statements/alter/delete)에 대해 더 알아보십시오.

## 테이블 비우기 \{#truncate-table\}

테이블의 모든 데이터를 삭제해야 하는 경우 아래의 `TRUNCATE TABLE` 명령을 사용하십시오. 이 작업은 비용이 적게 드는 연산입니다.

```sql
TRUNCATE TABLE posts
```

자세한 내용은 [TRUNCATE TABLE](/sql-reference/statements/truncate)을 참조하십시오.

## 파티션 삭제 \{#drop-partition\}

데이터에 사용자 지정 파티셔닝 키를 설정한 경우 파티션을 효율적으로 삭제할 수 있습니다. 카디널리티가 높은 파티셔닝 방식은 피하십시오.

```sql
ALTER TABLE posts (DROP PARTITION '2008')
```

자세한 내용은 [DROP PARTITION](/sql-reference/statements/alter/partition)을(를) 참고하십시오.

## 추가 자료 \{#more-resources\}

* [ClickHouse에서 업데이트 및 삭제 처리](https://clickhouse.com/blog/handling-updates-and-deletes-in-clickhouse)
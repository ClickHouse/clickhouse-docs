---
'slug': '/updating-data/overview'
'title': '개요'
'description': 'ClickHouse에서 데이터를 업데이트하는 방법'
'keywords':
- 'update'
- 'updating data'
'doc_type': 'guide'
---

## ClickHouse와 OLTP 데이터베이스에서 데이터 업데이트의 차이점 {#differences-between-updating-data-in-clickhouse-and-oltp-databases}

업데이트 처리에 관해서는 ClickHouse와 OLTP 데이터베이스가 근본적인 설계 철학과 목표 사용 사례로 인해 크게 다릅니다. 예를 들어, PostgreSQL은 레코드 지향적이고 ACID를 준수하는 관계형 데이터베이스로, 데이터 일관성과 무결성을 보장하는 다중 버전 동시성 제어(MVCC)와 같은 메커니즘을 통해 강력하고 트랜잭셔널한 업데이트 및 삭제 작업을 지원합니다. 이는 높은 동시성 환경에서도 안전하고 신뢰할 수 있는 수정을 허용합니다.

반면에 ClickHouse는 읽기 중심의 분석 및 고속 추가 전용 작업을 최적화한 컬럼형 데이터베이스입니다. ClickHouse는 인플레이스 업데이트와 삭제를 기본적으로 지원하지만, 높은 I/O를 피하기 위해 주의 깊게 사용해야 합니다. 대신, 테이블 구조를 재구성하여 삭제 및 업데이트를 비동기적으로 처리되는 추가 작업으로 변환할 수 있으며, 이는 높은 처리량의 데이터 수집과 효율적인 쿼리 성능을 실시간 데이터 조작보다 중시하는 방식입니다.

## ClickHouse에서 데이터 업데이트 방법 {#methods-to-update-data-in-clickhouse}

ClickHouse에서 데이터를 업데이트하는 방법은 여러 가지가 있으며, 각각 고유한 장점과 성능 특성이 있습니다. 데이터 모델과 업데이트할 데이터 양에 따라 적절한 방법을 선택해야 합니다.

두 작업 모두, 제출된 변이의 수가 일정 기간 동안 배경에서 처리되는 변이 수를 지속적으로 초과하면 적용해야 할 비물질화된 변이의 대기열이 계속 증가합니다. 이로 인해 최종적으로 `SELECT` 쿼리 성능이 저하됩니다.

요약하자면, 업데이트 작업은 신중하게 수행해야 하며, `system.mutations` 테이블을 사용하여 변이 대기열을 면밀히 추적해야 합니다. OLTP 데이터베이스에서처럼 잦은 업데이트를 발행하지 마십시오. 잦은 업데이트가 필요한 경우, [ReplacingMergeTree](/engines/table-engines/mergetree-family/replacingmergetree)를 참조하세요.

| 방법                                                                                  | 구문                                     | 사용 시기                                                                                                                                                                                                                              |
|---------------------------------------------------------------------------------------|------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [업데이트 변이]( /sql-reference/statements/alter/update)                          | `ALTER TABLE [table] UPDATE`             | 데이터가 즉시 디스크에 업데이트되어야 할 때 사용합니다(예: 규정 준수). `SELECT` 성능에 부정적인 영향을 미칩니다.                                                                                                                                          |
| [경량 업데이트]( /sql-reference/statements/update)                            | `UPDATE [table] SET ... WHERE`           | 소량의 데이터(약 10% 이하)를 업데이트할 때 사용합니다. 전체 컬럼을 다시 쓰지 않고 즉시 가시성이 있는 패치 파트를 생성합니다. `SELECT` 쿼리에 추가 오버헤드를 발생시키지만 예측 가능한 대기 시간이 있습니다. 현재 실험적입니다.      |
| [온더플라이 업데이트]( /guides/developer/on-the-fly-mutations)                         | `ALTER TABLE [table] UPDATE`             | `SET apply_mutations_on_fly = 1;`를 사용해 활성화합니다. 소량의 데이터를 업데이트할 때 사용합니다. 행은 모든 이후 `SELECT` 쿼리에서 업데이트된 데이터와 함께 즉시 반환되지만, 초기에는 디스크에서 업데이트된 것으로 내부적으로만 마크됩니다. |
| [ReplacingMergeTree]( /engines/table-engines/mergetree-family/replacingmergetree)   | `ENGINE = ReplacingMergeTree`            | 대량의 데이터를 업데이트할 때 사용합니다. 이 테이블 엔진은 병합 시 데이터 중복 제거에 최적화되어 있습니다.                                                                                                                                      |
| [CollapsingMergeTree]( /engines/table-engines/mergetree-family/collapsingmergetree) | `ENGINE = CollapsingMergeTree(Sign)`    | 개별 행을 자주 업데이트하거나 시간이 지남에 따라 변화하는 객체의 최신 상태를 유지해야 하는 시나리오에 사용합니다. 예를 들어, 사용자 활동 또는 기사 통계를 추적하는 경우에 해당합니다.                                      |

## 업데이트 변이 {#update-mutations}

업데이트 변이는 `ALTER TABLE ... UPDATE` 명령을 통해 발행할 수 있습니다. 예를 들면:

```sql
ALTER TABLE posts_temp
        (UPDATE AnswerCount = AnswerCount + 1 WHERE AnswerCount = 0)
```
이는 `WHERE` 표현식에 일치하는 모든 파트를 다시 쓰기 때문에 매우 I/O 집약적입니다. 이 과정은 원자성이 없습니다. 파트는 변이가 준비되는 즉시 변이된 파트로 대체되며, 변이가 진행 중인 동안 실행되는 `SELECT` 쿼리는 이미 변이된 파트의 데이터와 아직 변이되지 않은 파트의 데이터를 함께 가져옵니다. 사용자는 [systems.mutations](/operations/system-tables/mutations) 테이블을 통해 진행 상태를 추적할 수 있습니다. 이는 I/O 집약적인 작업이며, 클러스터의 `SELECT` 성능에 영향을 미칠 수 있으므로 자주 사용하지 않아야 합니다.

[업데이트 변이](/sql-reference/statements/alter/update)에 대해 더 읽어보세요.

## 경량 업데이트 {#lightweight-updates}

경량 업데이트는 "패치 파트"를 사용하여 행을 업데이트하는 ClickHouse 기능입니다. 패치 파트는 업데이트된 컬럼과 행만 포함된 특별한 데이터 파트로, 전통적인 변이처럼 전체 컬럼을 다시 쓰지 않습니다. 경량 업데이트의 주요 특성:

- 표준 `UPDATE` 구문을 사용하며 병합을 기다리지 않고 즉시 패치 파트를 생성합니다.
- 업데이트된 값은 패치 적용을 통해 `SELECT` 쿼리에서 즉시 가시화되지만, 물리적으로는 이후 병합 시에야 실현됩니다.
- 예측 가능한 대기 시간을 갖는 소량 업데이트(약 10% 이하)에 최적화되어 있습니다.
- 패치를 적용해야 하는 `SELECT` 쿼리에 추가 오버헤드를 발생시키지만 전체 컬럼을 다시 쓰지 않습니다.

더 자세한 내용은 ["경량 UPDATE 문"](/sql-reference/statements/update)를 참조하세요.

## 온더플라이 업데이트 {#on-the-fly-updates}

온더플라이 업데이트는 행이 즉시 업데이트되고 이후의 `SELECT` 쿼리가 변경된 값을 자동으로 반환하는 메커니즘을 제공합니다(이는 오버헤드를 발생시키고 쿼리를 느리게 합니다). 이는 일반 변이의 원자성 한계를 효과적으로 해결합니다. 아래에 예시를 보여드립니다:

```sql
SET apply_mutations_on_fly = 1;

SELECT ViewCount
FROM posts
WHERE Id = 404346

┌─ViewCount─┐
│   26762   │
└───────────┘

1 row in set. Elapsed: 0.115 sec. Processed 59.55 million rows, 238.25 MB (517.83 million rows/s., 2.07 GB/s.)
Peak memory usage: 113.65 MiB.

-increment count
ALTER TABLE posts
        (UPDATE ViewCount = ViewCount + 1 WHERE Id = 404346)

SELECT ViewCount
FROM posts
WHERE Id = 404346

┌─ViewCount─┐
│       26763   │
└───────────┘

1 row in set. Elapsed: 0.149 sec. Processed 59.55 million rows, 259.91 MB (399.99 million rows/s., 1.75 GB/s.)
```

온더플라이 업데이트의 경우 데이터 업데이트에는 여전히 변이가 사용됩니다. 데이터가 즉시 물질화되지 않고 `SELECT` 쿼리 중에 적용될 뿐입니다. 이는 여전히 비동기 프로세스로서 백그라운드에서 적용되며, 변이와 동일한 중대한 오버헤드를 발생시킵니다. 따라서 이는 자주 사용하지 않아야 하는 I/O 집약적인 작업입니다. 이 작업에 사용할 수 있는 표현식도 한정되어 있습니다(자세한 내용은 [여기]( /guides/developer/on-the-fly-mutations#support-for-subqueries-and-non-deterministic-functions)를 참조하세요).

[온더플라이 업데이트](/guides/developer/on-the-fly-mutations)에 대해 더 읽어보세요.

## `CollapsingMergeTree` {#collapsing-merge-tree}

업데이트가 비싸지만 삽입을 통해 업데이트를 수행할 수 있다는 아이디어에서 출발하여, [`CollapsingMergeTree`](/engines/table-engines/mergetree-family/collapsingmergetree) 테이블 엔진은 특정 행을 업데이트하기 위해 `sign` 컬럼과 함께 사용할 수 있습니다. 이것은 `1`과 `-1`의 쌍으로 행을 삭제하여 업데이트합니다. 
`sign` 컬럼에 `-1`이 삽입되면 전체 행이 삭제됩니다.
`sign` 컬럼에 `1`이 삽입되면 ClickHouse는 행을 유지합니다.
업데이트할 행은 테이블 생성 시 사용된 `ORDER BY ()` 문에서 정렬 키를 기반으로 식별됩니다.

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8 -- A special column used with the CollapsingMergeTree table engine
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID

INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1)
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1) -- sign = -1 signals to update the state of this row
INSERT INTO UAct VALUES (4324182021466249494, 6, 185, 1) -- the row is replaced with the new state

SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration
FROM UAct
GROUP BY UserID
HAVING sum(Sign) > 0

┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

:::note
위의 업데이트 접근법은 사용자가 클라이언트 측에서 상태를 유지해야 합니다. ClickHouse의 관점에서 가장 효율적이지만 대규모로 작업하기에는 복잡할 수 있습니다.

보다 포괄적인 개요를 원하신다면 [`CollapsingMergeTree`](/engines/table-engines/mergetree-family/collapsingmergetree) 문서를 읽을 것을 추천합니다.
:::

## 추가 자료 {#more-resources}

- [ClickHouse에서 업데이트 및 삭제 처리하기](https://clickhouse.com/blog/handling-updates-and-deletes-in-clickhouse)

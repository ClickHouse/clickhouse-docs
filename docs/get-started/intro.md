---
title: "什么是ClickHouse?"
description: "ClickHouse® 是一个面向列的 SQL 数据库管理系统 (DBMS)，用于在线分析处理 (OLAP)。 它既可以作为开源软件也可以作为云产品提供。"
sidebar_position: 10
---

ClickHouse® 是一种用于在线分析处理 (OLAP) 的高性能、面向列的 SQL 数据库管理系统 (DBMS)。 它既可以作为[开源软件](https://github.com/ClickHouse/ClickHouse)也可以作为[云产品](https://clickhouse.com/cloud)使用。

## 什么是 OLAP？

OLAP 场景需要在大型数据集之上实时响应复杂的分析查询，具有以下特征：
- 数据集可能非常庞大 - 数十亿或数万亿行
- 数据组织在包含许多列的表中
- 仅选择几列来回答任何特定查询
- 结果必须以毫秒或秒为单位返回

## 列式数据库与行式数据库

在面向行的 DBMS 中，数据存储在行中，与行相关的所有值物理上彼此相邻存储。

在面向列的 DBMS 中，数据存储在列中，同一列中的值存储在一起。

## 为什么列式数据库在OLAP场景下效果更好

面向列的数据库更适合 OLAP 场景：它们处理大多数查询的速度至少快 100 倍。 下面详细解释了原因，但事实更容易直观地展示：

**面向行的 DBMS**

![Row-oriented](@site/docs/_snippets/images/row-oriented.gif#)

**面向列的数据库管理系统**

![Row-oriented](@site/docs/_snippets/images/column-oriented.gif#)

看到不同？

本文的其余部分解释了为什么面向列的数据库非常适合这些场景，以及为什么 ClickHouse 尤其 [优于](/docs/en/concepts/why-clickhouse-is-so-fast#performance-when-inserting-data) 此类别中的其他人。

## 为什么 ClickHouse 这么快?

ClickHouse 充分利用所有可用的系统资源来尽快处理每个分析查询。 这之所以成为可能，是因为分析功能和对实现最快 OLAP 数据库所需的低级细节的关注的独特组合。

深入探讨该主题的有用文章包括：
- [ClickHouse 性能](/docs/en/concepts/why-clickhouse-is-so-fast)
- [ClickHouse的特色](/docs/en/about-us/distinctive-features.md)
- [常见问题：为什么 ClickHouse 这么快？](/knowledgebase/why-clickhouse-is-so-fast)

## 实时处理分析查询

在面向行的 DBMS 中，数据按以下顺序存储：

| 行| 手表ID | Java 启用 | 标题 | 好活动 | 活动时间 |
|-----|-------------|------------------------|---------------- ----|-----------|---------------------|
| #0 | 89354350662 | 1 | 投资者关系 | 1 | 2016-05-18 05:19:20 |
| #1 | 90329509958 | 0 | 联系我们 | 1 | 2016-05-18 08:10:20 |
| #2 | 89953706054 | 1 | 使命 | 1 | 2016-05-18 07:38:00 |
| #N | …… | …… | …… | …… | …… |

换句话说，与一行相关的所有值在物理上都是相邻存储的。

面向行的 DBMS 的示例包括 MySQL、Postgres 和 MS SQL Server。

在面向列的 DBMS 中，数据的存储方式如下：

| 行：| #0 | #1 | #2 | #N |
|----------|----------|-------------- --------|---------------------|-----|
| 手表ID: | 89354350662 | 90329509958 | 89953706054 | …… |
| Java 启用： | 1 | 0 | 1 | …… |
| 标题： | 投资者关系 | 联系我们 | 使命 | …… |
| 好活动：| 1 | 1 | 1 | …… |
| 活动时间： | 2016-05-18 05:19:20 | 2016-05-18 08:10:20 | 2016-05-18 07:38:00 | …… |

这些示例仅显示数据的排列顺序。不同列的值单独存储，同一列的数据存储在一起。

面向列的 DBMS 示例：Vertica、Paraccel（Actian Matrix 和 Amazon Redshift）、Sybase IQ、Exasol、Infobright、InfiniDB、MonetDB（VectorWise 和 Actian Vector）、LucidDB、SAP HANA、Google Dremel、Google PowerDrill、Druid 和 kdb+.

不同的数据存储顺序更适合不同的场景。 数据访问场景是指进行哪些查询、查询频率、查询比例； 每种类型的查询读取多少数据——行、列和字节； 读取和更新数据之间的关系； 数据的工作大小及其在本地的使用方式； 是否使用交易，以及交易的隔离程度； 数据复制和逻辑完整性的要求； 每种类型的查询对延迟和吞吐量的要求等等。

系统负载越高，定制系统设置以匹配使用场景的要求就越重要，并且这种定制变得越细粒度。 没有任何系统能够同样适合截然不同的场景。 如果一个系统能够适应多种场景，那么在高负载下，该系统将同样糟糕地处理所有场景，或者仅适用于一种或少数可能的场景。

### OLAP 场景的关键属性

- 表“宽”，意味着它们包含大量列。
- 数据集很大，处理单个查询时查询需要高吞吐量（每台服务器每秒高达数十亿行）。
- 列值相当小：数字和短字符串（例如，每个 URL 60 字节）。
- 查询提取大量行，但仅提取一小部分列。
- 对于简单查询，允许 50 毫秒左右的延迟。
- 每个查询有一张大表； 除了一张桌子外，所有桌子都很小。
- 查询结果明显小于源数据。 换句话说，数据经过过滤或聚合，因此结果适合单个服务器的 RAM。
- 查询相对较少（通常每台服务器每秒数百个查询或更少）。
- 插入发生在相当大的批次中（\> 1000 行），而不是单行。
- 交易不是必需的。

不难看出，OLAP 场景与其他流行场景（例如 OLTP 或 Key-Value 访问）有很大不同。 因此，如果您想获得不错的性能，尝试使用 OLTP 或键值数据库来处理分析查询是没有意义的。 例如，如果您尝试使用 MongoDB 或 Redis 进行分析，与 OLAP 数据库相比，您将获得非常差的性能。

＃＃＃ 输入输出

1. 对于分析查询，只需要读取少量的表列。 在面向列的数据库中，您可以只读取所需的数据。 例如，如果您需要 100 列中的 5 列，则 I/O 预计会减少 20 倍。
2. 由于数据是按包读取的，因此更容易压缩。 列中的数据也更容易压缩。 这进一步减少了 I/O 量。
3. 由于 I/O 减少，系统缓存中可以容纳更多数据。

例如，查询“统计每个广告平台的记录数”需要读取一个“广告平台ID”列，该列未压缩时占用1个字节。 如果大部分流量不是来自广告平台，则该栏目至少会压缩 10 倍。 当使用快速压缩算法时，可以以每秒至少几GB未压缩数据的速度解压缩数据。 换句话说，这个查询在单个服务器上可以以大约每秒数十亿行的速度处理。 这个速度是在实践中实际达到的。

＃＃＃ 中央处理器

由于执行查询需要处理大量行，因此它有助于为整个向量而不是单独的行分派所有操作，或者实现查询引擎，以便几乎没有分派成本。 如果不这样做，对于任何不太好的磁盘子系统，查询解释器都将不可避免地使 CPU 停顿。 将数据存储在列中并在可能的情况下按列进行处理是有意义的。

有两种方法可以做到这一点：

1.矢量引擎。 所有操作都是为向量编写的，而不是为单独的值编写的。 这意味着您不需要经常调用操作，并且调度成本可以忽略不计。 操作代码包含优化的内部循环。

2. 代码生成。 为查询生成的代码包含所有间接调用。

在面向行的数据库中不会这样做，因为在运行简单查询时它没有意义。 不过，也有例外。 例如，MemSQL 使用代码生成来减少处理 SQL 查询时的延迟。 （作为比较，分析 DBMS 需要优化吞吐量，而不是延迟。）

请注意，为了提高 CPU 效率，查询语言必须是声明性的（SQL 或 MDX），或者至少是向量（J、K）。 查询应该只包含隐式循环，以便进行优化。

// TODO: Combine with getActivePageURLS.js

const fs = require('fs');
const path = require('path');
const matter = require('gray-matter');

const projectRoot = path.join(__dirname, '..', '..');
const docsRoot = path.join(projectRoot, 'docs');
const activeLinksPath = path.join(projectRoot, 'active_links.json');
const sidebarFilePath = path.join(projectRoot, 'sidebars.js');
const orphanedPagesPath = path.join(projectRoot, 'orphaned_pages.txt');
const sidebarLinksPath = path.join(projectRoot, 'sidebar_links.txt');
const activeLinksOutputPath = path.join(projectRoot, 'active_links.txt');

const ignoredPaths = [
  '/en/_placeholders/',
  '/en/_snippets/',
  '/_clients'
];

// Utility to normalize paths for consistent comparison
function normalizePath(link) {
  let normalizedLink = link.replace(/^\//, '').replace(/\/$/, '').toLowerCase();
  // Remove trailing "/index"
  if (normalizedLink.endsWith('/index')) {
    normalizedLink = normalizedLink.slice(0, -6);
  }
  return normalizedLink;
}

function shouldIgnorePath(link) {
  const normalizedLink = normalizePath(link);
  return ignoredPaths.some(ignored => normalizedLink.startsWith(normalizePath(ignored)));
}

function getLinksFromFile(filePath) {
  try {
    const data = fs.readFileSync(filePath, 'utf8');
    const json = JSON.parse(data);

    const links = Object.keys(json)
      .map(url => ({ original: url, normalized: normalizePath(url) }))
      .filter(link => link.normalized.length > 0 && !shouldIgnorePath(link.normalized));

    return links;
  } catch (error) {
    console.error(`Error reading file ${filePath}:`, error);
    return [];
  }
}

function getLinksFromSidebar() {
  try {
    const sidebars = require(sidebarFilePath);
    let sidebarLinks = new Set();

    // Helper function to recursively extract links from the sidebar
    function extractLinks(items) {
      items.forEach(item => {
        if (typeof item === 'string') {
          if (!shouldIgnorePath(item)) {
            sidebarLinks.add(normalizePath(item));
          }
        } else if (typeof item === 'object') {
          if (item.type === 'category' && Array.isArray(item.items)) {
            extractLinks(item.items);
          } else if (item.type === 'doc' && item.id) {
            if (!shouldIgnorePath(item.id)) {
              sidebarLinks.add(normalizePath(item.id));
            }
          } else if (item.type === 'autogenerated') {
            // Handle autogenerated folder
            const dirPath = path.join(docsRoot, item.dirName);
            const autogeneratedLinks = getLinksFromDirectory(dirPath);
            autogeneratedLinks.forEach(link => sidebarLinks.add(link));
          }
        }
      });
    }

    // Process all sidebars
    Object.values(sidebars).forEach(sidebar => {
      if (Array.isArray(sidebar)) {
        extractLinks(sidebar);
      } else if (typeof sidebar === 'object') {
        Object.values(sidebar).forEach(section => {
          if (Array.isArray(section)) {
            extractLinks(section);
          }
        });
      }
    });

    return sidebarLinks;
  } catch (error) {
    console.error(`Error reading sidebar file ${sidebarFilePath}:`, error);
    return new Set();
  }
}

function getLinksFromDirectory(dir) {
  let links = [];
  try {
    const files = fs.readdirSync(dir);
    files.forEach(file => {
      const fullPath = path.join(dir, file);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory()) {
        links = links.concat(getLinksFromDirectory(fullPath));
      } else if (stat.isFile() && file.endsWith('.md')) {
        const fileContent = fs.readFileSync(fullPath, 'utf8');
        const { data } = matter(fileContent);

        let link;
        if (data.slug) {
          link = normalizePath(data.slug);
        } else {
          link = normalizePath(path.relative(docsRoot, fullPath).replace(/\.md$/, ''));
          // Handle index files
          if (file === 'index.md') {
            link = link.replace(/\/index$/, '');
          }
        }

        if (!shouldIgnorePath(link)) {
          links.push(link);
        }
      }
    });
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error);
  }
  return links;
}

function findOrphanedPages() {
  const activeLinks = getLinksFromFile(activeLinksPath);
  const sidebarLinks = getLinksFromSidebar();

  const orphanedPages = activeLinks.filter(link => {
    // Skip orphan check for pages starting with "ru/" or "zh/"
    if (link.normalized.startsWith('ru/') || link.normalized.startsWith('zh/')) {
      return false;
    }

    return !sidebarLinks.has(link.normalized)
  }).map(link => {
    // Add back "index" if it was part of the original path
    if (link.original.endsWith('/index')) {
      return link.original.slice(1);
    }
    return link.original.slice(1);
  });

  // Write orphaned pages to orphaned_pages.txt
  try {
    fs.writeFileSync(orphanedPagesPath, orphanedPages.join('\n'), 'utf8');
    console.log(`Orphaned pages written to ${orphanedPagesPath}`);
  } catch (error) {
    console.error(`Error writing to file ${orphanedPagesPath}:`, error);
  }

  return orphanedPages;
}

function writeSidebarLinksToFile() {
  const sidebarLinks = getLinksFromSidebar();
  try {
    fs.writeFileSync(sidebarLinksPath, Array.from(sidebarLinks).join('\n'), 'utf8');
    console.log(`Sidebar links written to ${sidebarLinksPath}`);
  } catch (error) {
    console.error(`Error writing to file ${sidebarLinksPath}:`, error);
  }
}

function writeActiveLinksToFile() {
  const activeLinks = getLinksFromFile(activeLinksPath);
  try {
    fs.writeFileSync(activeLinksOutputPath, activeLinks.map(link => link.original).join('\n'), 'utf8');
    console.log(`Active links written to ${activeLinksOutputPath}`);
  } catch (error) {
    console.error(`Error writing to file ${activeLinksOutputPath}:`, error);
  }
}

findOrphanedPages();
writeSidebarLinksToFile();
writeActiveLinksToFile();
